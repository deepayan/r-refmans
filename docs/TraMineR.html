<!DOCTYPE html><html><head><title>Help for package TraMineR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TraMineR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TraMineR-package'>
<p>Trajectory Miner: Sequence Analysis Toolkit</p></a></li>
<li><a href='#actcal'><p>Example data set: Activity calendar from the Swiss Household Panel</p></a></li>
<li><a href='#actcal.tse'><p>Example data set: Activity calendar from the Swiss Household Panel (time stamped event format)</p></a></li>
<li><a href='#alphabet'><p>Get or set the alphabet of a state or event sequence object</p></a></li>
<li><a href='#bfspell'><p>Example data set: First 20 biofam sequences in SPELL form</p></a></li>
<li><a href='#biofam'><p>Example data set: Family life states from the Swiss Household Panel biographical survey</p></a></li>
<li><a href='#cpal'><p>Get or set the color palette of a sequence object</p></a></li>
<li><a href='#dissassoc'><p>Analysis of discrepancy from dissimilarity measures</p></a></li>
<li><a href='#disscenter'><p>Compute distances to the center of a group</p></a></li>
<li><a href='#dissdomassoc'><p>Domain association measures</p></a></li>
<li><a href='#dissmfacw'><p>Multi-factor ANOVA from a dissimilarity matrix</p></a></li>
<li><a href='#dissrep'><p>Extracting sets of representative objects using a dissimilarity matrix</p></a></li>
<li><a href='#dissrf'>
<p>Relative Frequency Groups.</p></a></li>
<li><a href='#disstree'><p>Dissimilarity Tree</p></a></li>
<li><a href='#disstree.assign'><p>Assign rules to profiles provided</p></a></li>
<li><a href='#disstree.get.rules'><p>Tree classification rules</p></a></li>
<li><a href='#disstree2dot'><p>Graphical representation of a dissimilarity tree</p></a></li>
<li><a href='#disstreeleaf'><p>Terminal node membership</p></a></li>
<li><a href='#dissvar'><p>Dissimilarity based discrepancy</p></a></li>
<li><a href='#ex1'><p>Example data set with missing values and weights</p></a></li>
<li><a href='#ex2'><p>Example data sets with weighted and unweighted sequence data</p></a></li>
<li><a href='#famform'><p>Example data set: sequences of family formation</p></a></li>
<li><a href='#is.eseq'><p>Event sequence object</p></a></li>
<li><a href='#is.stslist'><p>Test if is a proper state sequence (stslist) object</p></a></li>
<li><a href='#mvad'><p>Example data set: Transition from school to work</p></a></li>
<li><a href='#plot.seqdiff'>
<p>Plotting a seqdiff object.</p></a></li>
<li><a href='#plot.seqrf'>
<p>Plot method for seqrf objects of relative frequency groups of sequences.</p></a></li>
<li><a href='#plot.stslist'><p>Plot method for state sequence objects</p></a></li>
<li><a href='#plot.stslist.freq'><p>Plot method for sequence frequency tables</p></a></li>
<li><a href='#plot.stslist.meant'><p>Plot method for objects produced by the seqmeant function</p></a></li>
<li><a href='#plot.stslist.modst'><p>Plot method for modal state sequences</p></a></li>
<li><a href='#plot.stslist.rep'><p>Plot method for representative sequence sets</p></a></li>
<li><a href='#plot.stslist.statd'><p>Plot method for objects produced by the seqstatd function</p></a></li>
<li><a href='#plot.subseqelist'><p>Plot frequencies of subsequences</p></a></li>
<li><a href='#plot.subseqelistchisq'><p>Plot discriminant subsequences</p></a></li>
<li><a href='#print.stslist'><p>Print method for state sequence objects</p></a></li>
<li><a href='#read.tda.mdist'><p>Read a distance matrix produced by TDA.</p></a></li>
<li><a href='#seqalign'><p>Computation details about a pairwise alignment</p></a></li>
<li><a href='#seqcomp'><p>Compare two state sequences</p></a></li>
<li><a href='#seqconc'><p>Concatenate vectors of states or events into a character string</p></a></li>
<li><a href='#seqcost'><p>Generate substitution and indel costs</p></a></li>
<li><a href='#seqdecomp'><p>Convert a character string into a vector of states or events</p></a></li>
<li><a href='#seqdef'><p>Create a state sequence object</p></a></li>
<li><a href='#seqdiff'><p>Position-wise discrepancy analysis between groups of sequences</p></a></li>
<li><a href='#seqdim'><p>Dimension of a set of sequences</p></a></li>
<li><a href='#seqdist'><p>Distances (dissimilarities) between sequences</p></a></li>
<li><a href='#seqdomassoc'><p>Measures of association between domains of sequence data</p></a></li>
<li><a href='#seqdss'><p>Extract sequences of distinct successive states</p></a></li>
<li><a href='#seqdur'><p>Extract state durations from a sequence object.</p></a></li>
<li><a href='#seqeapplysub'><p>Checking for the presence of given event subsequences</p></a></li>
<li><a href='#seqecmpgroup'><p>Identifying discriminating subsequences</p></a></li>
<li><a href='#seqeconstraint'><p>Setting time constraints and the counting method</p></a></li>
<li><a href='#seqecontain'><p>Check if sequence contains events</p></a></li>
<li><a href='#seqecreate'><p>Create event sequence objects.</p></a></li>
<li><a href='#seqefsub'><p>Searching for frequent subsequences</p></a></li>
<li><a href='#seqeid'><p>Retrieve unique ids from an event sequence object.</p></a></li>
<li><a href='#seqelength'><p>Lengths of event sequences</p></a></li>
<li><a href='#seqetm'><p>Create a transition-definition matrix</p></a></li>
<li><a href='#seqeweight'>
<p>Setting or retrieving weights of an event sequence object.</p></a></li>
<li><a href='#seqfcheck'><p>Check if sequences are in the compressed or extended format</p></a></li>
<li><a href='#seqfind'><p>Indexes of state sequence(s) x in state sequence object y</p></a></li>
<li><a href='#seqformat'><p>Conversion between sequence formats</p></a></li>
<li><a href='#seqfpos'><p>Search for the first occurrence of a given element in a sequence</p></a></li>
<li><a href='#seqfposend'><p>End of first spell in given state</p></a></li>
<li><a href='#seqgen'><p>Random sequences generation</p></a></li>
<li><a href='#seqibad'><p>Badness index</p></a></li>
<li><a href='#seqici'><p>Complexity index of individual sequences</p></a></li>
<li><a href='#seqient'><p>Within sequence entropies</p></a></li>
<li><a href='#seqindic'><p>Sequence indicators</p></a></li>
<li><a href='#seqintegr'><p>Integrative potential</p></a></li>
<li><a href='#seqipos'><p>Indicators for binary sequences of positive and negative states.</p></a></li>
<li><a href='#seqistatd'><p>State frequencies in each individual sequence</p></a></li>
<li><a href='#seqivardur'><p>Variance of spell durations in individual sequences</p></a></li>
<li><a href='#seqivolatility'><p>Volatility of individual state sequences</p></a></li>
<li><a href='#seqlegend'><p>Plot a legend for the states in a sequence object</p></a></li>
<li><a href='#seqlength'><p>Sequence length</p></a></li>
<li><a href='#seqlength.align'><p>Align sequence length across domains</p></a></li>
<li><a href='#seqLLCP'><p>Compute the length of the longest common prefix of two sequences</p></a></li>
<li><a href='#seqLLCS'><p>Compute the length of the longest common subsequence of two sequences</p></a></li>
<li><a href='#seqlogp'>
<p>Logarithm of the probabilities of state sequences</p></a></li>
<li><a href='#seqmaintokens'><p>Indexes of most frequent tokens</p></a></li>
<li><a href='#seqMD'><p>Multidomain sequences</p></a></li>
<li><a href='#seqmeant'><p>Mean durations in each state</p></a></li>
<li><a href='#seqmodst'><p>Sequence of modal states</p></a></li>
<li><a href='#seqmpos'><p>Number of matching positions between two sequences.</p></a></li>
<li><a href='#seqnum'><p>Transform into a sequence object with numerical alphabet.</p></a></li>
<li><a href='#seqpcplot'><p>Parallel coordinate plot for sequence data</p></a></li>
<li><a href='#seqplot'><p>Plot state sequence objects</p></a></li>
<li><a href='#seqplotMD'><p>Plot multidomain state sequences</p></a></li>
<li><a href='#seqpm'><p>Find substring patterns in sequences</p></a></li>
<li><a href='#seqprecarity'><p>Degradation, Precarity, and Insecurity indexes</p></a></li>
<li><a href='#seqprecstart'><p>State precarity</p></a></li>
<li><a href='#seqrecode'>
<p>Recoding state sequence objects and factors</p></a></li>
<li><a href='#seqrep'><p>Extracting sets of representative sequences</p></a></li>
<li><a href='#seqsep'><p>Adds separators to sequences stored as character string</p></a></li>
<li><a href='#seqST'><p>Sequences turbulence</p></a></li>
<li><a href='#seqstatd'><p>Sequence of transversal state distributions and their entropies</p></a></li>
<li><a href='#seqstatf'><p>State frequencies in the whole sequence data set</p></a></li>
<li><a href='#seqstatl'><p>List of distinct states or events (alphabet) in a sequence data set.</p></a></li>
<li><a href='#seqsubsn'><p>Number of distinct subsequences in a sequence.</p></a></li>
<li><a href='#seqtab'><p>Frequency table of the sequences</p></a></li>
<li><a href='#seqtransn'><p>Number of transitions in a sequence</p></a></li>
<li><a href='#seqtrate'><p>Compute transition rates between states</p></a></li>
<li><a href='#seqtree'>
<p>Tree structured analysis of a state sequence object.</p></a></li>
<li><a href='#seqtreedisplay'><p>Graphical rendering of a sequence regression tree</p></a></li>
<li><a href='#stlab'><p>Get or set the state labels of a sequence object</p></a></li>
<li><a href='#str.eseq'><p>String representation of an event sequence object</p></a></li>
<li><a href='#TraMineR.check.depr.args'>
<p>Checking and managing deprecated arguments</p></a></li>
<li><a href='#TraMineRInternal'><p>Access to TraMineR internal functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.2-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Trajectory Miner: a Sequence Analysis Toolkit</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, graphics, grDevices, stats, cluster, colorspace,
RColorBrewer, boot, vegan</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xtable, TraMineRextras</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of sequence analysis tools for manipulating, describing and rendering categorical sequences, and more generally mining sequence data in the field of social sciences. Although this sequence analysis package is primarily intended for state or event sequences that describe time use or life courses such as family formation histories or professional careers, its features also apply to many other kinds of categorical sequence data. It accepts many different sequence representations as input and provides tools for converting sequences from one format to another. It offers several functions for describing and rendering sequences, for computing distances between sequences with different metrics (among which optimal matching), original dissimilarity-based analysis tools, and functions for extracting the most frequent event subsequences and identifying the most discriminating ones among them. A user's guide can be found on the TraMineR web page.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://traminer.unige.ch">http://traminer.unige.ch</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gilbert Ritschard &lt;gilbert.ritschard@unige.ch&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 07:51:09 UTC; grits</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexis Gabadinho [aut, cph],
  Matthias Studer <a href="https://orcid.org/0000-0002-6269-1412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Nicolas Müller [aut],
  Reto Bürgin <a href="https://orcid.org/0000-0002-6212-1567"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Pierre-Alexandre Fonta [aut],
  Gilbert Ritschard <a href="https://orcid.org/0000-0001-7776-0903"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 11:50:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='TraMineR-package'>
Trajectory Miner: Sequence Analysis Toolkit
</h2><span id='topic+TraMineR-package'></span><span id='topic+TraMineR'></span>

<h3>Description</h3>

<p>(Version: 2.2-9) Set of sequence analysis tools for manipulating, describing and rendering categorical sequences, and more generally mining sequence data in the field of social sciences. Although this sequence analysis package is primarily intended for state or event sequences that describe time use or life courses such as family formation histories or professional careers, its features also apply to many other kinds of categorical sequence data. It accepts many different sequence representations as input and provides tools for converting sequences from one format to another. It offers several functions for describing and rendering sequences, for computing distances between sequences with different metrics (among which optimal matching), original dissimilarity-based analysis tools, and functions for extracting the most frequent event subsequences and identifying the most discriminating ones among them. A user's guide can be found on the TraMineR web page.
</p>


<h3>Details</h3>

<p>TraMineR provides tools for both state sequences and event
sequences. The first step when using the package is to define a
state sequence object (with <code><a href="#topic+seqdef">seqdef</a></code>) if you want to
explore state sequences, and an event sequence object (with
<code><a href="#topic+seqecreate">seqecreate</a></code>) if you are interested in event
sequencing.
</p>
<p>State sequences are defined from a series of variables giving the
states at the successive positions, while event sequences are
defined from (vertical) time stamped event data. The package,
however, can handle many other different data organizations and
provides tools to help converting state sequences into event
sequences and vice versa.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho, Matthias Studer, Nicolas S. Müller, Reto Bürgin, Pierre-Alexandre Fonta, and Gilbert Ritschard
</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011).
Analyzing and Visualizing State Sequences in R with TraMineR.
<em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
<a href="https://doi.org/10.18637/jss.v040.i04">doi:10.18637/jss.v040.i04</a>.
</p>
<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2009).
Mining Sequence Data in <code>R</code> with the <code>TraMineR</code> package:
A user's guide. Department of Econometrics and Laboratory of
Demography, University of Geneva
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the mvad data
library(TraMineR)
data(mvad)

## create a state sequence object from columns 17 to 86
mvad.seq &lt;- seqdef(mvad[,17:86])

## distribution plot by sex (male)
seqdplot(mvad.seq, group=mvad$male, border=NA)

## compute the LCS pairwise distance matrix
## among the first 10 sequences
mvad.lcs &lt;- seqdist(mvad.seq[1:10,], method="LCS")
</code></pre>

<hr>
<h2 id='actcal'>Example data set: Activity calendar from the Swiss Household Panel</h2><span id='topic+actcal'></span>

<h3>Description</h3>

<p>This data set contains 2000 individual sequences of monthly activity statuses from
January to December 2000.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(actcal)</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows, 12 state variables, 1 id variable and 11 covariates.</p>


<h3>Details</h3>

<p>The data set is a subsample of the data collected by the Swiss Household Panel (SHP).
</p>
<p>The state column (variable) names are '<code>jan00</code>', '<code>feb00</code>', etc... and correspond to columns 13 to 24.
</p>
<p>There are four possible states:<br />
<br />
A = Full-time paid job (&gt; 37 hours)<br />
B = Long part-time paid job (19-36 hours) <br />
C = Short part-time paid job (1-18 hours) <br />
D = Unemployed (no work) <br />
</p>
<p>The data set contains also the following covariates:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>age00</code>    </td><td style="text-align: left;"> (age in 2000) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>educat00</code> </td><td style="text-align: left;"> (education level) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>civsta00</code> </td><td style="text-align: left;"> (civil status) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>nbadul00</code> </td><td style="text-align: left;"> (number of adults in household) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>nbkid00</code>  </td><td style="text-align: left;"> (number of children) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>aoldki00</code> </td><td style="text-align: left;"> (age of oldest kid) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ayouki00</code> </td><td style="text-align: left;"> (age of youngest kid) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>region00</code> </td><td style="text-align: left;"> (residence region) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>com2.00</code>  </td><td style="text-align: left;"> (residence commune type) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>sex</code>      </td><td style="text-align: left;"> (sex of respondent)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>birthy</code>   </td><td style="text-align: left;"> (birth year) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Swiss Household Panel</p>


<h3>References</h3>

<p><a href="https://forscenter.ch/projects/swiss-household-panel/">https://forscenter.ch/projects/swiss-household-panel/</a></p>

<hr>
<h2 id='actcal.tse'>Example data set: Activity calendar from the Swiss Household Panel (time stamped event format)</h2><span id='topic+actcal.tse'></span>

<h3>Description</h3>

<p>This data set contains events defined from the state sequences in the actcal data set. It was created with the code shown in the examples section. It is provided to symplify example of event sequence mining.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(actcal.tse)</code></pre>


<h3>Format</h3>

<p>Time stamped events derived from state sequences in the actcal data set.</p>


<h3>Source</h3>

<p>Swiss Household Panel</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqformat">seqformat</a>, <a href="#topic+actcal">actcal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
actcal.seq &lt;- seqdef(actcal[,13:24])

## Defining the transition matrix
transition &lt;- seqetm(actcal.seq, method="transition")
transition[1,1:4] &lt;- c("FullTime"         , "Decrease,PartTime",
     "Decrease,LowPartTime", "Stop")
transition[2,1:4] &lt;- c("Increase,FullTime", "PartTime"         ,
     "Decrease,LowPartTime", "Stop")
transition[3,1:4] &lt;- c("Increase,FullTime", "Increase,PartTime",
    "LowPartTime"         , "Stop")
transition[4,1:4] &lt;- c("Start,FullTime"   , "Start,PartTime"   ,
    "Start,LowPartTime"   , "NoActivity")
transition

## Converting STS data to TSE
actcal.tse &lt;- seqformat(actcal, 13:24, from = "STS",to = "TSE",
  tevent = transition)

## Defining the event sequence object
actcal.eseq &lt;- seqecreate(id=actcal.tse$id,
	time=actcal.tse$time, event=actcal.tse$event)
</code></pre>

<hr>
<h2 id='alphabet'>Get or set the alphabet of a state or event sequence object</h2><span id='topic+alphabet'></span><span id='topic+alphabet+3C-'></span>

<h3>Description</h3>

<p>For state sequences, the function gets or sets the (short) labels associated to the states in the alphabet of a state sequence object (the list of all possible states). The get form also applies to event sequences, while the set form does not work with event sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphabet(seqdata, with.missing=FALSE)
alphabet(seqdata) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphabet_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object of class <code>stslist</code> as defined with the <code><a href="#topic+seqdef">seqdef</a></code> function or, for the get form only, an event sequence object as defined with <code><a href="#topic+seqecreate">seqecreate</a></code> or a probabilistic suffix tree generated with the PST package.</p>
</td></tr>
<tr><td><code id="alphabet_+3A_value">value</code></td>
<td>
<p>For state sequences only. Vector of characters of the same length as the vector returned by the <code>alphabet</code> function, i.e. one label for each state in the alphabet.</p>
</td></tr>
<tr><td><code id="alphabet_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. When <code>seqdata</code> is a state sequence object (<code>stslist</code>), should the returned alphabet include the <code>nr</code> symbol standing for missing states?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A state sequence object&mdash;created with the <code><a href="#topic+seqdef">seqdef</a></code> function&mdash;stores sequences as a matrix where columns are factors. The levels of the factors include the alphabet plus the codes for missing values and void elements. The alphabet function retrieves or sets the &ldquo;alphabet&rdquo; attribute of the state sequence object.
The state names composing the alphabet are preferably short labels, since they are used for printing sequences. Longer labels for describing more precisely each state in legend are stored in the &ldquo;labels&rdquo; attribute of the sequence object.
</p>
<p>For an event sequence object&mdash;created with <code><a href="#topic+seqecreate">seqecreate</a></code>&mdash;the get form of <code>alphabet</code> works as an alias for <code>levels</code>. The set form <code>alphabet &lt;-</code> does not work and should not be used.
</p>


<h3>Value</h3>

<p>For &lsquo;<code>alphabet</code>&rsquo; a character vector containing the alphabet.
</p>
<p>For &lsquo;<code>alphabet &lt;-</code>&rsquo; the updated state sequence object.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdef">seqdef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object with the columns 13 to 24
## in the 'actcal' example data set
data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24)

## Retrieving the alphabet
alphabet(actcal.seq)

## Setting the alphabet
alphabet(actcal.seq) &lt;- c("FT", "PT", "LT", "NO")

## Event sequences
actcal.eseq &lt;- seqecreate(actcal.seq)
alphabet(actcal.eseq)
</code></pre>

<hr>
<h2 id='bfspell'>Example data set: First 20 biofam sequences in SPELL form</h2><span id='topic+bfspell'></span><span id='topic+bfspell20'></span><span id='topic+bfpdata20'></span>

<h3>Description</h3>

<p>First 20 sequences of the <code><a href="#topic+biofam">biofam</a></code> data set in SPELL form. The data serve to illustrate the use of <code><a href="#topic+seqformat">seqformat</a></code> for converting SPELL data into STS (horizontal) form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bfspell)
</code></pre>


<h3>Format</h3>

<p>A data set with two data frames: <code>bfspell20</code> with one row per spell and <code>bfpdata20</code> with one row per id. The <code>bfspell20</code> data frame contains the spell data themselves (4 variables <code>id</code>, <code>begin</code>, <code>end</code>, <code>states</code>) and <code>bfpdata20</code> the year when aged 15 (2 variables <code>id</code>, <code>when15</code>).
</p>


<h3>Details</h3>

<p>The states are coded with the following short labels<br />
<br />
P = &quot;Parent&quot; <br />
L = &quot;Left&quot; <br />
M = &quot;Married&quot; <br />
LM = &quot;Left+Marr&quot; <br />
C = &quot;Child&quot; <br />
LC = &quot;Left+Child&quot; <br />
LMC = &quot;Left+Marr+Child&quot; <br />
D = &quot;Divorced&quot; <br />
<br />
The data is a SPELL representation of <code>biofam[1:20,10:25]</code>, corresponding to 20 family life sequences between ages 15 and 30.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biofam">biofam</a></code>
</p>

<hr>
<h2 id='biofam'>Example data set: Family life states from the Swiss Household Panel biographical survey</h2><span id='topic+biofam'></span>

<h3>Description</h3>

<p>2000 16 year-long family life sequences built from the retrospective biographical survey carried out by the Swiss Household Panel (SHP) in 2002.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(biofam)

data(bfspell)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows, 16 state variables, 1 id variable and 7 covariates and 2 weights variables.</p>


<h3>Details</h3>

<p>The <em>biofam</em> data set was constructed by Müller et al. (2007)
from the data of the retrospective biographical survey carried out by the Swiss Household Panel (SHP) in 2002.
</p>
<p>The data set contains (in columns 10 to 25) sequences of family life states from age 15 to 30 (sequence length is 16) and a series of covariates. The sequences are a sample of 2000 sequences of those created from the SHP biographical survey. It includes only individuals who were at least 30 years old at the time of the survey.  The <em>biofam</em> data set describes family life courses of 2000 individuals born between 1909 and 1972.
</p>
<p>The states numbered from 0 to 7 are defined from the combination of five basic states, namely Living with parents (Parent), Left home (Left), Married (Marr), Having Children (Child), Divorced:<br />
<br />
0 = &quot;Parent&quot; <br />
1 = &quot;Left&quot; <br />
2 = &quot;Married&quot; <br />
3 = &quot;Left+Marr&quot; <br />
4 = &quot;Child&quot; <br />
5 = &quot;Left+Child&quot; <br />
6 = &quot;Left+Marr+Child&quot; <br />
7 = &quot;Divorced&quot; <br />
</p>
<p>The covariates are: <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>sex</code> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>birthyr </code>  </td><td style="text-align: left;"> (birth year)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>nat_1_02</code>  </td><td style="text-align: left;"> (first nationality) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>plingu02</code>  </td><td style="text-align: left;"> (language of questionnaire) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>p02r01 </code>   </td><td style="text-align: left;"> (religion)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>p02r04 </code>   </td><td style="text-align: left;"> (religious participation) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cspfaj </code>   </td><td style="text-align: left;"> (father's social status) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cspmoj </code>   </td><td style="text-align: left;"> (mother's social status) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Two additional weights variables are inserted for illustrative purpose ONLY (since <code>biofam</code> is a subsample of the original data, these weights are not adapted to the actual data): <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>wp00tbgp</code> </td><td style="text-align: left;"> (weights inflating to the Swiss population)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>wp00tbgs</code> </td><td style="text-align: left;"> (weights respecting sample size) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Swiss Household Panel <a href="https://forscenter.ch/projects/swiss-household-panel/">https://forscenter.ch/projects/swiss-household-panel/</a></p>


<h3>References</h3>

<p>Müller, N. S., M. Studer, G. Ritschard (2007).
Classification de parcours de vie à l'aide de l'optimal matching.
In <em>XIVe Rencontre de la Société francophone de classification
(SFC 2007), Paris, 5 - 7 septembre 2007</em>, pp. 157&ndash;160.
</p>

<hr>
<h2 id='cpal'>Get or set the color palette of a sequence object</h2><span id='topic+cpal'></span><span id='topic+cpal+3C-'></span>

<h3>Description</h3>

<p>This function gets or sets the color palette of a sequence object, that is, the list of colors used to represent the states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpal(seqdata)
cpal(seqdata) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpal_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="cpal_+3A_value">value</code></td>
<td>
<p>a vector containing the colors, of length equal to the number of states in the alphabet. The colors can be passed as character strings representing color names such as returned by the <code><a href="grDevices.html#topic+colors">colors</a></code> function, as hexadecimal values or as RGB vectors using the <code><a href="grDevices.html#topic+rgb">rgb</a></code> function. Each color is attributed to the corresponding state in the alphabet, the order being the one returned by the <code><a href="#topic+alphabet">alphabet</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the plot functions provided for visualizing sequence objects, a different color is associated to each state of the alphabet. The color palette is defined when creating the sequence object, either automatically or by specifying a user defined color vector. The <code>cpal</code> function can be used to get or set the color palette of a previously defined sequence object.</p>


<h3>Value</h3>

<p>For '<code>cpal(seqdata)</code>' a vector containing the colors.
</p>
<p>For '<code>cpal(seqdata) &lt;-</code>' the updated sequence object.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdef">seqdef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object with the columns 13 to 24
## in the 'actcal' example data set
## The color palette is automatically set
data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24)

## Retrieving the color palette
cpal(actcal.seq)
seqiplot(actcal.seq)

## Setting a user defined color palette
cpal(actcal.seq) &lt;- c("blue","red", "green", "yellow")
seqiplot(actcal.seq)
</code></pre>

<hr>
<h2 id='dissassoc'>Analysis of discrepancy from dissimilarity measures</h2><span id='topic+dissassoc'></span><span id='topic+hist.dissassoc'></span><span id='topic+print.dissassoc'></span>

<h3>Description</h3>

<p>Compute and test the share of discrepancy (defined from a dissimilarity matrix) explained by a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissassoc(diss, group, weights=NULL, R=1000,
          weight.permutation="replicate", squared=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissassoc_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a dist object (see <code><a href="stats.html#topic+dist">dist</a></code>)</p>
</td></tr>
<tr><td><code id="dissassoc_+3A_group">group</code></td>
<td>
<p>A categorical variable. For a numerical variable use <code><a href="#topic+dissmfacw">dissmfacw</a></code>.</p>
</td></tr>
<tr><td><code id="dissassoc_+3A_weights">weights</code></td>
<td>
<p>optional numerical vector containing weights.</p>
</td></tr>
<tr><td><code id="dissassoc_+3A_r">R</code></td>
<td>
<p>Number of permutations for computing the p-value. If equal to 1, no permutation test is performed.</p>
</td></tr>
<tr><td><code id="dissassoc_+3A_weight.permutation">weight.permutation</code></td>
<td>
<p>Weighted permutation method: <code>"diss"</code>
(attach weights to the dissimilarity matrix), <code>"replicate"</code> (replicate case using <code>weights</code>), <code>"rounded-replicate"</code> (replicate case using rounded <code>weights</code>), <code>"random-sampling"</code> (random assignment of covariate profiles to the objects using distributions defined by the weights.)</p>
</td></tr>
<tr><td><code id="dissassoc_+3A_squared">squared</code></td>
<td>
<p>Logical. If <code>TRUE</code> the dissimilarities <code>diss</code> are squared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dissassoc</code> function assesses the association
between objects characterized by their dissimilarity matrix and a
discrete covariate. It provides a generalization of the ANOVA
principle to any kind of distance metric. The function returns a pseudo F statistic, 
a pseudo Brown-Forsythe Fbf statistic, and
a pseudo R-square that can be interpreted as a usual R-square. The
statistical significance of the association is computed by means of
permutation tests. The function performs also a test of discrepancy
homogeneity (equality of within variances) using a generalization of
the Levene statistic and the Bartlett statistic. <br /> There are
<code>print</code> and <code>hist</code> methods (the latter producing an
histogram of the permuted values used for testing the significance).
</p>
<p>If a numeric <code>group</code> variable is provided, it will be treated as categorical, i.e., each different value will be considered as a different category. To measure the &lsquo;linear&rsquo; effect of a numerical variable, use <code><a href="#topic+dissmfacw">dissmfacw</a></code>.
</p>


<h3>Value</h3>

<p> An object of class <code>dissassoc</code> with the
following components:
</p>
<table>
<tr><td><code>groups</code></td>
<td>
<p>A data frame with the number of cases and the discrepancy of each group</p>
</td></tr>
<tr><td><code>anova.table</code></td>
<td>
<p>The pseudo ANOVA table</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>The value of the statistics (Pseudo F, Pseudo Fbf, Pseudo R2, Bartlett, and Levene) and their p-values</p>
</td></tr>
<tr><td><code>perms</code></td>
<td>
<p>The permutation object, containing the values computed for each permutation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2011). Discrepancy analysis of state sequences, <em>Sociological Methods and Research</em>, Vol. 40(3), 471-510, <a href="https://doi.org/10.1177/0049124111415372">doi:10.1177/0049124111415372</a>.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2010)
Discrepancy analysis of complex objects using dissimilarities.
In F. Guillet, G. Ritschard, H. Briand, and D. A. Zighed (Eds.),
<em>Advances in Knowledge Discovery and Management</em>,
Studies in Computational Intelligence, Volume 292, pp. 3-19. Berlin: Springer.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2009).
Analyse de dissimilarités par arbre d'induction. In EGC 2009,
<em>Revue des Nouvelles Technologies de l'Information</em>, Vol. E-15, pp. 7&ndash;18.
</p>
<p>Anderson, M. J. (2001) A new method for non-parametric multivariate analysis of variance.
<em>Austral Ecology</em> <b>26</b>, 32&ndash;46.
</p>
<p>Batagelj, V. (1988) Generalized Ward and related clustering problems. In H. Bock (Ed.),
<em>Classification and related methods of data analysis</em>, Amsterdam: North-Holland, pp. 67&ndash;74.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dissvar">dissvar</a></code> to compute the pseudo variance from dissimilarities and for a basic introduction to concepts of
pseudo variance analysis.
<br />
<code><a href="#topic+disstree">disstree</a></code> for an induction tree analyse of objects characterized by a dissimilarity matrix.
<br />
<code><a href="#topic+disscenter">disscenter</a></code> to compute the distance of each object to its group center from pairwise dissimilarities.
<br />
<code><a href="#topic+dissmfacw">dissmfacw</a></code> to perform multi-factor analysis of variance from pairwise dissimilarities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a state sequence object
data(mvad)
mvad.seq &lt;- seqdef(mvad[, 17:86])

## Building dissimilarities (any dissimilarity measure can be used)
mvad.ham &lt;- seqdist(mvad.seq, method="HAM")

## R=1 implies no permutation test
da &lt;- dissassoc(mvad.ham, group=mvad$gcse5eq, R=10)
print(da)
hist(da)
</code></pre>

<hr>
<h2 id='disscenter'>Compute distances to the center of a group</h2><span id='topic+disscenter'></span>

<h3>Description</h3>

<p>Computes the dissimilarity between objects and their group center from their pairwise dissimilarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disscenter(diss, group=NULL, medoids.index=NULL,
           allcenter = FALSE, weights=NULL, squared=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disscenter_+3A_diss">diss</code></td>
<td>
<p>a dissimilarity matrix such as generated by <code><a href="#topic+seqdist">seqdist</a></code>, or a
<code>dist</code> object (see <code><a href="stats.html#topic+dist">dist</a></code>)</p>
</td></tr>
<tr><td><code id="disscenter_+3A_group">group</code></td>
<td>
<p>if <code>NULL</code> (default), the whole data set is considered. Otherwise a different center is considered for each distinct value of the group variable</p>
</td></tr>
<tr><td><code id="disscenter_+3A_medoids.index">medoids.index</code></td>
<td>
<p>if <code>NULL</code>, returns the dissimilarity to the center.
If set to <code>"first"</code>, returns the index of the first encountered
most central sequence. If <code>group</code> is set, an index is returned per group. When set to <code>"all"</code>, indexes of all medoids (one list per group) are returned.</p>
</td></tr>
<tr><td><code id="disscenter_+3A_allcenter">allcenter</code></td>
<td>
<p>logical. If <code>TRUE</code>, returns a <code>data.frame</code>
containing the dissimilarity between each object and its group
center, each column corresponding to a group.</p>
</td></tr>
<tr><td><code id="disscenter_+3A_weights">weights</code></td>
<td>
<p>optional numerical vector containing weights.</p>
</td></tr>
<tr><td><code id="disscenter_+3A_squared">squared</code></td>
<td>
<p>Logical. If <code>TRUE</code> <code>diss</code> is squared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the dissimilarity between given objects and their group center. It is possible that the group center does not belong to the space formed by the objects (in the same way as the average of integer numbers is not necessarily an integer itself).
This distance can also be understood as the contribution to the discrepancy (see <code><a href="#topic+dissvar">dissvar</a></code>).
Note that when the dissimilarity measure does not respect the triangle inequality, the dissimilarity between a given object and its group center may be negative
</p>
<p>It can be shown that this dissimilarity is equal to (see <cite>Batagelj 1988</cite>):
</p>
<p style="text-align: center;"><code class="reqn">d_{x\tilde{g}}=\frac{1}{n}\big(\sum_{i=1}^{n}d_{xi}-SS\big)</code>
</p>

<p>where <code class="reqn">SS</code> is the sum of squares (see <code><a href="#topic+dissvar">dissvar</a></code>).
</p>


<h3>Value</h3>

<p>A vector with the dissimilarity to the group center for each object, or a list of medoid indexes.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2011). Discrepancy analysis of state sequences, <em>Sociological Methods and Research</em>, Vol. 40(3), 471-510, <a href="https://doi.org/10.1177/0049124111415372">doi:10.1177/0049124111415372</a>.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2010)
Discrepancy	analysis of complex objects using dissimilarities.
In F. Guillet, G. Ritschard, D. A. Zighed and H. Briand (Eds.),
<em>Advances in Knowledge Discovery and Management</em>,
Studies in Computational Intelligence, Volume 292, pp. 3-19. Berlin: Springer.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2009)
Analyse de dissimilarités par arbre d'induction. In EGC 2009,
<em>Revue des Nouvelles Technologies de l'Information</em>, Vol. E-15, pp. 7&ndash;18.
</p>
<p>Batagelj, V. (1988) Generalized ward and related clustering problems. In H. Bock (Ed.),
<em>Classification and related methods of data analysis</em>, Amsterdam: North-Holland, pp. 67&ndash;74.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dissvar">dissvar</a></code> to compute the pseudo variance from dissimilarities and for a basic introduction to concepts of pseudo variance analysis
<br />
<code><a href="#topic+dissassoc">dissassoc</a></code> to test association between objects represented by their dissimilarities and a covariate.
<br />
<code><a href="#topic+disstree">disstree</a></code> for an induction tree analyse of objects characterized by a dissimilarity matrix.
<br />
<code><a href="#topic+dissmfacw">dissmfacw</a></code> to perform multi-factor analysis of variance from pairwise dissimilarities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a state sequence object
data(mvad)
mvad.seq &lt;- seqdef(mvad[, 17:86])

## Building dissimilarities (any dissimilarity measure can be used)
mvad.ham &lt;- seqdist(mvad.seq, method="HAM")

## Compute distance to center according to group gcse5eq
dc &lt;- disscenter(mvad.ham, group=mvad$gcse5eq)

## Ploting distribution of dissimilarity  to center
boxplot(dc~mvad$gcse5eq, col="cyan")

## Retrieving index of the first medoids, one per group
dc &lt;- disscenter(mvad.ham, group=mvad$Grammar, medoids.index="first")
print(dc)

## Retrieving index of all medoids in each group
dc &lt;- disscenter(mvad.ham, group=mvad$Grammar, medoids.index="all")
print(dc)
</code></pre>

<hr>
<h2 id='dissdomassoc'>Domain association measures</h2><span id='topic+dissdomassoc'></span><span id='topic+summary.ddomassoc'></span>

<h3>Description</h3>

<p>Measures of association between domains are computed as the association between the pairwise dissimilarities in the domains. Measures are: Pearson correlation, Spearman correlation, global Cronbach alpha, and Cronbach alpha for each subset of the domains. The function can also return the share of variance (R-square) of the dissimilarities in one domain that can be reproduced from the dissimilarities in the other domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dissdomassoc(domdiss, jointdiss = NULL, what = c("pearson","R2"),
        dnames=names(domdiss), weights=NULL, w.rank=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissdomassoc_+3A_domdiss">domdiss</code></td>
<td>
<p>List of symmetrical matrices or dist objects: the pairwise dissimilarities per domain.</p>
</td></tr>
<tr><td><code id="dissdomassoc_+3A_jointdiss">jointdiss</code></td>
<td>
<p><code>NULL</code> (default), matrix or dist object: pairwise dissimilarities for joint dimensions.</p>
</td></tr>

<tr><td><code id="dissdomassoc_+3A_what">what</code></td>
<td>
<p>String or vector of strings: requested association measures among <code>'pearson'</code>, <code>'spearman'</code>, <code>'R2'</code> <code>'cronbach'</code>, <code>'cron.subsets'</code>. Can also be <code>'all'</code> for all measures but <code>'spearman'</code>.</p>
</td></tr>
<tr><td><code id="dissdomassoc_+3A_dnames">dnames</code></td>
<td>
<p>String vector of length equal to number of domains. Names of domains. Default is <code>names(domdiss)</code>.</p>
</td></tr>
<tr><td><code id="dissdomassoc_+3A_weights">weights</code></td>
<td>
<p>Vector of non-negative weights. If <code>NULL</code>, no weights are applied. (Currently Cronbach measures ignore weights!). </p>
</td></tr>
<tr><td><code id="dissdomassoc_+3A_w.rank">w.rank</code></td>
<td>
<p>Logical. If weights are provided and <code>'spearman'</code> is selected, should we use weighted ranks. Caution: computation of weighted ranks considerably increases computation time!</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The <code>dissdomassoc</code> function computes the domain association measures proposed by <cite>Piccarreta (2017)</cite>.
These are for each pair of domains the correlation (Pearson or Spearman) between the domain specific pairwise dissimilarities. When <code>'R2'</code> is requested, the function computes the share of variance of the dissimilarities in one domain that is reproduced by the dissimilarities in all other domains. The Cronbach alpha measures the coherence between the domains. With <code>'cron.subsets'</code>, Cronbach alpha is computed for the entire set of domains as well as for each possible subset of two or more domains.
</p>
<p>When a <code>jointdiss</code> distance matrix or object is provided, correlations of each individual with this joint domain are also computed. The R2 of the joint domain takes account of all domains. However, R2's for the domains remain unchanged, i.e. they ignore the joint domain. Likewise, <code>jointdiss</code> does not affect the Cronbach alpha.
</p>
<p>Spearman correlations are based on rank values of the distances. The computation of weighted ranks may take a while for large number of sequences (<code>&gt; 500</code>,  i.e. 124750 distances per domain). Therefore, weighted ranks are only used when explicitly requested by setting <code>w.rank = TRUE</code>. When <code>w.rank = FALSE</code> (default), Spearman is computed as the weighted Pearson correlation between non-weighted ranks.
</p>
<p>When <code>"pearson"</code> and/or <code>"spearman"</code> correlations are requested, p-values (probability to get a stronger correlation under the zero correlation assumption) are automatically computed.
</p>


<h3>Value</h3>

<p>An object of class <code>ddomassoc</code>, which is a list of tables of the requested association measures and tables of p-values of the Pearson and Spearman correlations when applicable. The <code>summary</code> method organizes the correlations and their p-values in table form.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Piccarreta (2017). Joint Sequence Analysis: Association and Clustering. <em>Sociological Methods and Research</em>, 46(2), 252–287. <a href="https://doi.org/10.1177/0049124115591013">doi:10.1177/0049124115591013</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdomassoc">seqdomassoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)

## Building one channel per type of event left, children or married
## Using only first 200 sequences
bf &lt;- as.matrix(biofam[1:200, 10:25])
children &lt;-  bf==4 | bf==5 | bf==6
married &lt;- bf == 2 | bf== 3 | bf==6
left &lt;- bf==1 | bf==3 | bf==5 | bf==6
## weights
weights &lt;- biofam[1:200,"wp00tbgs"]

## Building sequence objects
child.seq &lt;- seqdef(children)
marr.seq &lt;- seqdef(married)
left.seq &lt;- seqdef(left)
## distances by channel
dchild &lt;- seqdist(child.seq, method="OM", sm="INDELSLOG")
dmarr &lt;- seqdist(marr.seq, method="OM", sm="INDELSLOG")
dleft &lt;- seqdist(left.seq, method="OM", sm="INDELSLOG")
dbiofam &lt;- list(dchild,dmarr,dleft)
names(dbiofam) &lt;- c("child","marr","left")

## Association between domains and R2 by domain
rass &lt;- dissdomassoc(dbiofam, weights=weights)

## Joint distances using additive trick with domain INDELSLOG costs.
mcdist &lt;- seqMD(channels=list(child.seq, marr.seq, left.seq), what="diss",
                    method="OM", sm =list("INDELSLOG", "INDELSLOG", "INDELSLOG"))

rassj &lt;- dissdomassoc(dbiofam, jointdiss=mcdist, what=c("all"), weights=weights)
rassj[["Pearson.Rsquare"]]
rass[["Pearson.Rsquare"]]
summary(rassj)
</code></pre>

<hr>
<h2 id='dissmfacw'>Multi-factor ANOVA from a dissimilarity matrix</h2><span id='topic+dissmfacw'></span><span id='topic+gower_matrix'></span><span id='topic+print.dissmultifactor'></span>

<h3>Description</h3>

<p>Perform a multi-factor analysis of variance from a dissimilarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissmfacw(formula, data, R = 1000, gower = FALSE, squared = FALSE,
    weights = NULL)
    
gower_matrix(diss, squared=TRUE, weights=NULL)

## S3 method for class 'dissmultifactor'
print(x, pvalue.confint=0.95, digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissmfacw_+3A_formula">formula</code></td>
<td>
<p>A regression-like formula. The left hand side term should be a dissimilarity matrix or a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="dissmfacw_+3A_data">data</code></td>
<td>
<p>A data frame from which the variables in <code>formula</code> should be taken.</p>
</td></tr>
<tr><td><code id="dissmfacw_+3A_r">R</code></td>
<td>
<p>Number of permutations used to assess significance.</p>
</td></tr>
<tr><td><code id="dissmfacw_+3A_gower">gower</code></td>
<td>
<p>Logical: Is the dissimilarity matrix already a Gower matrix?</p>
</td></tr>
<tr><td><code id="dissmfacw_+3A_squared">squared</code></td>
<td>
<p>Logical: Should we square the provided dissimilarities?</p>
</td></tr>
<tr><td><code id="dissmfacw_+3A_weights">weights</code></td>
<td>
<p>Optional numerical vector of case weights.</p>
</td></tr>
<tr><td><code id="dissmfacw_+3A_diss">diss</code></td>
<td>
<p>Dissimilarity matrix</p>
</td></tr>
<tr><td><code id="dissmfacw_+3A_x">x</code></td>
<td>
<p>a <code>dissmultifactor</code> object as returned by <code>dissmfacw</code></p>
</td></tr>
<tr><td><code id="dissmfacw_+3A_pvalue.confint">pvalue.confint</code></td>
<td>
<p>Real in range [0,1]. Confidence probability. </p>
</td></tr>
<tr><td><code id="dissmfacw_+3A_digits">digits</code></td>
<td>
<p>Integer or <code>NULL</code>. Number of digits.</p>
</td></tr>
<tr><td><code id="dissmfacw_+3A_...">...</code></td>
<td>
<p>Other generic print arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>dissmfacw</code> is, in some way, a generalization of <code><a href="#topic+dissassoc">dissassoc</a></code> to account for several explanatory variables.
The function computes the part of discrepancy explained by the list of covariates specified in the <code>formula</code>.
It provides for each covariate the Type-II effect, i.e. the effect measured when removing the covariate from the full model with all variables included.
</p>
<p>(The returned F values may slightly differ from those obtained with TraMineR versions older than 1.8-9. Since 1.8-9, the within sum of squares at the denominator is divided by <code class="reqn">n-m</code> instead of <code class="reqn">n-m-1</code>, where <code class="reqn">n</code> is the sample size and <code class="reqn">m</code> the total number of predictors and/or contrasts used to represent categorical factors.)
</p>
<p>For a single factor <code>dissmfacw</code> is slower than <code><a href="#topic+dissassoc">dissassoc</a></code>.
Moreover, the latter performs also tests for homogeneity in within-group discrepancies (equality of variances) with a generalization of Levene's and Bartlett's statistics.
</p>
<p>Part of the function is based on the Multivariate Matrix Regression with qr decomposition algorithm written in SciPy-Python by Ondrej Libiger and Matt Zapala (See <cite>Zapala and Schork</cite>, 2006, for a full reference.)  The algorithm has been adapted for Type-II effects and extended to account for case weights.
</p>
<p>Function <code>gower_matrix</code> transforms the provided dissimilarity matrix into a Gower matrix.
</p>


<h3>Value</h3>

<p>A <code>dissmultifactor</code> object with the following components:
</p>
<table>
<tr><td><code>mfac</code></td>
<td>
<p>The part of variance explained by each variable (comparing full model to model without the specified variable) and its significance using permutation test</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call</p>
</td></tr>
<tr><td><code>perms</code></td>
<td>
<p>Permutation values as a <code>boot</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2011). Discrepancy analysis of state sequences, <em>Sociological Methods and Research</em>, Vol. 40(3), 471-510, <a href="https://doi.org/10.1177/0049124111415372">doi:10.1177/0049124111415372</a>.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2010)
Discrepancy analysis of complex objects using dissimilarities.
In F. Guillet, G. Ritschard, D. A. Zighed and H. Briand (Eds.),
<em>Advances in Knowledge Discovery and Management</em>,
Studies in Computational Intelligence, Volume 292, pp. 3-19. Berlin: Springer.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2009).
Analyse de dissimilarités par arbre d'induction. In EGC 2009,
<em>Revue des Nouvelles Technologies de l'Information</em>, Vol. E-15, pp. 7-18.
</p>
<p>Anderson, M. J. (2001). A new method for non-parametric multivariate analysis of variance.
<em>Austral Ecology</em> 26, 32-46.
</p>
<p>McArdle, B. H. and M. J. Anderson (2001). Fitting multivariate models to community data: A
comment on distance-based redundancy analysis. <em>Ecology</em> 82(1), 290-297.
</p>
<p>Zapala, M. A. and N. J. Schork (2006). Multivariate regression analysis of distance matrices for
testing associations between gene expression patterns and related variables. <em>Proceedings of
the National Academy of Sciences of the United States of America</em> 103(51), 19430-19435.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dissvar">dissvar</a></code> to compute a pseudo variance from dissimilarities and for a basic introduction to concepts of discrepancy analysis.
<br />
<code><a href="#topic+dissassoc">dissassoc</a></code> to test association between objects represented by their dissimilarities and a covariate.
<br />
<code><a href="#topic+disstree">disstree</a></code> for an induction tree analysis of objects characterized by a dissimilarity matrix.
<br />
<code><a href="#topic+disscenter">disscenter</a></code> to compute the distance of each object to its group center from pairwise dissimilarities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define the state sequence object
data(mvad)
mvad.seq &lt;- seqdef(mvad[, 17:86])
## Here, we use only first 100 sequences
mvad.seq &lt;- mvad.seq[1:100,]

## Compute dissimilarities (any dissimilarity measure can be used)
mvad.ham &lt;- seqdist(mvad.seq, method="HAM")

## And now the multi-factor analysis
print(dissmfacw(mvad.ham ~ male + Grammar + funemp +
	gcse5eq + fmpr + livboth, data=mvad[1:100,], R=10))
</code></pre>

<hr>
<h2 id='dissrep'>Extracting sets of representative objects using a dissimilarity matrix</h2><span id='topic+dissrep'></span>

<h3>Description</h3>

<p>The function extracts a set of representative objects that exhibits the key features of the whole data set, the goal being to get easy sounded interpretation of the latter. The user can set either the desired coverage level (the proportion of objects having a representative in their neighborhood) or the desired number of representatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissrep(diss, criterion = "density", score = NULL, decreasing = TRUE,
  coverage = 0.25, nrep = NULL, pradius = 0.10, dmax = NULL,
  weights = NULL, trep, tsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissrep_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a <code>dist</code> object (see <code><a href="stats.html#topic+dist">dist</a></code>)</p>
</td></tr>
<tr><td><code id="dissrep_+3A_criterion">criterion</code></td>
<td>
<p>the representativeness criterion for sorting the
candidate list. One of <code>"freq"</code> (frequency), <code>"density"</code>
(neighborhood density) or <code>"dist"</code> (centrality). An optional
vector containing the scores for sorting the candidate objects may
also be provided. See below and details.</p>
</td></tr>
<tr><td><code id="dissrep_+3A_score">score</code></td>
<td>
<p>an optional vector containing the representativeness
scores used for sorting the objects in the candidate list. The length
of the vector must be equal to the number of rows/columns in the
distance matrix, i.e the number of objects.</p>
</td></tr>
<tr><td><code id="dissrep_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. If a score vector is provided, should
the objects in the candidate list be sorted in ascending order of the score. If <code>FALSE</code>, sort is in descending order. The first object in the candidate list is supposed to be the most representative.</p>
</td></tr>
<tr><td><code id="dissrep_+3A_coverage">coverage</code></td>
<td>
<p>controls the size of the representative set by setting
the desired coverage level, i.e the proportion of objects having a
representative in their neighborhood. Neighborhood radius is defined
by <code>pradius</code>.</p>
</td></tr>
<tr><td><code id="dissrep_+3A_nrep">nrep</code></td>
<td>
<p>number of representatives. If <code>NULL</code> (default),
<code>coverage</code> argument is used to control the size of the
representative set.</p>
</td></tr>
<tr><td><code id="dissrep_+3A_pradius">pradius</code></td>
<td>
<p>neighborhood
radius as a percentage of the maximum (theoretical)
distance  <code>dmax</code>. Defaults to 0.1 (10%). Object <code class="reqn">y</code> is
redundant to object <code class="reqn">x</code> when it is in the neighborhood of <code class="reqn">x</code>, i.e., within a distance
<code>pradius*dmax</code> from <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="dissrep_+3A_dmax">dmax</code></td>
<td>
<p>maximum theoretical distance. The <code>dmax</code> value is used to derive the neighborhood radius as <code>pradius*dmax</code>. If <code>NULL</code>, the value of <code>dmax</code> is derived from the dissimilarity matrix.</p>
</td></tr>
<tr><td><code id="dissrep_+3A_weights">weights</code></td>
<td>
<p>vector of weights of length equal to the number of rows of the dissimilarity matrix. If <code>NULL</code>, equal weights are assigned.</p>
</td></tr>
<tr><td><code id="dissrep_+3A_trep">trep</code></td>
<td>
<p>Deprecated. Use <code>coverage</code> instead.</p>
</td></tr>
<tr><td><code id="dissrep_+3A_tsim">tsim</code></td>
<td>
<p>Deprecated. Use <code>pradius</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The representative set is obtained by an heuristic. Representatives are selected by successively extracting from  the sequences sorted by their representativeness score those which are not redundant with already retained representatives. The selection stops when either the desired coverage or the wanted number of representatives is reached. Objects are sorted either by the values provided as <code>score</code> argument, or by specifying one of the following as <code>criterion</code> argument: <code>"freq"</code> (<em>sequence frequency</em>), <code>"density"</code>
(<em>neighborhood density</em>), <code>"dist"</code>
(<em>centrality</em>).
</p>
<p>The <em>frequency</em> criterion uses the frequencies as
representativeness score. The frequency of an object in the data is
computed as the number of other objects with whom the dissimilarity
is equal to 0. The more frequent an object the more representative it
is supposed to be. Hence, objects are sorted in decreasing frequency
order. This criterion is equivalent to the neighborhood (see below)
criterion with a neighborhood radius equal to 0.
</p>
<p>The <em>neighborhood density</em> is the
number&mdash;density&mdash;of objects in the neighborhood of the object. This requires to set the neighborhood radius <code>pradius</code>.  Objects are
sorted in decreasing density order.
</p>
<p>The <em>centrality</em> criterion is the sum of distances to all other objects. The
smallest the sum, the most representative the object.
</p>
<p>Use <code>criterion="dist"</code> (centrality) and <code>nrep=1</code> to get the medoid and <code>criterion="density"</code> and <code>nrep=1</code> to get the densest object pattern.
</p>
<p>For more details, see <cite>Gabadinho and Ritschard, 2013</cite>.
</p>


<h3>Value</h3>

<p>An object of class <code>diss.rep</code>. This is a vector containing
the indexes of the representative objects with the following additional attributes:
</p>
<table>
<tr><td><code>Scores</code></td>
<td>
<p>vector with the representative score of each object given the chosen criterion.</p>
</td></tr>
<tr><td><code>Distances</code></td>
<td>
<p>matrix with the distance of each object to its nearest representative.</p>
</td></tr>
<tr><td><code>Rep.group</code></td>
<td>
<p>vector with, for each object, the representative that represents it.</p>
</td></tr>
<tr><td><code>idx.rep</code></td>
<td>
<p>list with indexes of occurrences of each representative in original data.</p>
</td></tr>
<tr><td><code>Statistics</code></td>
<td>
<p>a data frame with quality measures for each representative: number of objects assigned to the representative,
number of objects in the representative's neighborhood, mean distance
to the representative.</p>
</td></tr>
<tr><td><code>Quality</code></td>
<td>
<p>overall quality measure.</p>
</td></tr>
</table>
<p>Print and summary methods are available.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>References</h3>

<p>Gabadinho A, Ritschard G (2013). &quot;Searching for typical life trajectories applied to child birth histories&quot;, In R Lévy, E. Widmer (eds.), <em>Gendered Life Courses</em>, pp. 287-312. Vienna: LIT.
</p>
<p>Gabadinho A, Ritschard G, Studer M, Müller NS (2011). &quot;Extracting and Rendering Representative Sequences&quot;, In A Fred, JLG Dietz, K Liu, J Filipe (eds.), <em>Knowledge Discovery, Knowledge Engineering and Knowledge Management</em>, volume 128 of <em>Communications in Computer and Information Science (CCIS)</em>, pp. 94-106. Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqrep">seqrep</a></code>, <code><a href="#topic+disscenter">disscenter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
"Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.seq &lt;- seqdef(biofam[, 10:25], labels=biofam.lab)

## Computing the distance matrix
costs &lt;- seqsubm(biofam.seq, method="TRATE")
biofam.om &lt;- seqdist(biofam.seq, method="OM", sm=costs)

## Representative set using the neighborhood density criterion
biofam.rep &lt;- dissrep(biofam.om)
biofam.rep
summary(biofam.rep)
## indexes of first occurrence of second representatives in original data
attr(biofam.rep,"idx.rep")[[2]][1]

</code></pre>

<hr>
<h2 id='dissrf'>
Relative Frequency Groups.
</h2><span id='topic+dissrf'></span><span id='topic+seqrf'></span><span id='topic+summary.dissrf'></span><span id='topic+summary.seqrf'></span><span id='topic+print.dissrf'></span><span id='topic+print.seqrf'></span>

<h3>Description</h3>

<p>Relative Frequency (RF) groups are equally sized groups obtained by partitioning sorted cases into <code class="reqn">k</code> consecutive groups. Function <code>dissrf</code> returns the medoid indexes of the RF groups and related statistics. Function <code>seqrf</code> is for sequence data and returns in addition the RF medoid sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissrf(diss,
       k=NULL,
       sortv="mds",
       weights=NULL,
       grp.meth = "prop",
       squared = FALSE,
       pow = NULL)

seqrf(seqdata,
       diss,
       k=NULL,
       sortv="mds",
       weights=NULL,
       weighted=TRUE,
       grp.meth = "prop",
       squared = FALSE,
       pow = NULL)

## S3 method for class 'dissrf'
summary(object, dist.idx = 1:10, ...)

## S3 method for class 'seqrf'
summary(object, format="SPS", dist.idx = 1:10, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissrf_+3A_diss">diss</code></td>
<td>
<p>Matrix or distance object. Pairwise dissimilarities between analyzed cases.</p>
</td></tr>
<tr><td><code id="dissrf_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence <code>stslist</code> object as produced by <code><a href="#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="dissrf_+3A_k">k</code></td>
<td>
<p>Integer: Number of groupings (RF groups). When <code>NULL</code>, <code>k</code> is set as the minimum between 100 and the sum of weights over 10.</p>
</td></tr>
<tr><td><code id="dissrf_+3A_sortv">sortv</code></td>
<td>
<p>Real vector (of length <code>nrow(diss)</code>), character string, or <code>NULL</code>. Sorting variable used to compute the frequency groups.  If <code>NULL</code>, the original data order is used. If <code>"mds"</code> (default), the first MDS factor of <code>diss</code> (<code>diss^2</code> when <code>squared=TRUE</code>) is used. Ties are randomly ordered. For <code>seqrf</code> only, can also be one of <code>"from.start"</code> and <code>"from.end"</code>.</p>
</td></tr>
<tr><td><code id="dissrf_+3A_weights">weights</code></td>
<td>
<p>Vector  (of length <code>nrow(diss)</code>) of non-negative weights. If <code>NULL</code> (default), equal weights except when <code>weighted</code> is set as <code>TRUE</code> in <code>seqrf</code>.</p>
</td></tr>
<tr><td><code id="dissrf_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Should weights be used when there are weights in <code>seqdata</code>? (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="dissrf_+3A_grp.meth">grp.meth</code></td>
<td>
<p>Character string. One of <code>"prop"</code>, <code>"first"</code>, and <code>"random"</code>. Grouping method. See details.</p>
</td></tr>
<tr><td><code id="dissrf_+3A_squared">squared</code></td>
<td>
<p>Logical. Should medoids (and computation of <code>sortv</code> when applicable) be based on squared dissimilarities? (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="dissrf_+3A_pow">pow</code></td>
<td>
<p>Double. Dissimilarity power exponent (typically 1 or 2) for computation of pseudo R2 and F. When <code>NULL</code>, <code>pow</code> is set as 1 when <code>squared = FALSE</code>, and as 2 otherwise.</p>
</td></tr>
<tr><td><code id="dissrf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods such as <code><a href="#topic+print.stslist">print.stslist</a></code></p>
</td></tr>
<tr><td><code id="dissrf_+3A_object">object</code></td>
<td>
<p>Object of class <code>dissrf</code> or <code>seqrf</code></p>
</td></tr>
<tr><td><code id="dissrf_+3A_format">format</code></td>
<td>
<p>String. One of <code>"SPS"</code> (default) or <code>"STS"</code>. Display format of the medoid sequences.</p>
</td></tr>
<tr><td><code id="dissrf_+3A_dist.idx">dist.idx</code></td>
<td>
<p>Indexes of RF groups for which summary statistics of distances to the medoids are displayed. Default is <code>1:10</code>. Set as 0 to plot statistics for all RF groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>dissrf</code> partitions the <code class="reqn">n</code> cases (rows of the <code>diss</code> matrix) into <code class="reqn">k</code> equally sized groups (RF groups). First, the cases are sorted according to the <code>sortv</code> variable.  Then the groups are built by consecutively grouping the first <code class="reqn">n/k</code> cases, then the next <code class="reqn">n/k</code> cases, and so on. In <code>seqrf</code>, one of sort methods <code>"from.start"</code> and <code>"from.end"</code> can be specified as <code>sortv</code> argument.
</p>
<p>Ties in the <code>sortv</code> variable are handled by <code><a href="base.html#topic+order">order</a></code> using the default method, which produces stable outcome. To use a different method, compute a suited variable without ties (e.g. using <code>order</code> with the wanted method for ties) and pass it as <code>sortv</code> argument.
</p>
<p>The <code>grp.meth</code> argument applies when the group size (<code class="reqn">n/k</code>) is not integer. With <code>grp.meth="first"</code>, the integer part of <code class="reqn">n/k</code> is used as basic group size and the size of the first groups is augmented by one unit so that the sum of the group sizes equals <code class="reqn">n</code>. With <code>grp.meth="random"</code>, randomly selected groups have their size augmented by one unit, and with <code>grp.meth="prop"</code> (default), cases at the limit between groups are proportionally assigned to each of the two groups.
</p>
<p>For <code>seqrf</code>, when <code>weights=NULL</code> and <code>weighted=TRUE</code>, <code>weights</code> is set as the <code>weights</code> attribute of <code>seqdata</code>.
</p>
<p>When <code>weights</code> is non-null (<code>dissrf</code>) or when <code>wheighted=TRUE</code> and there are weights in <code>seqdata</code> (<code>seqrf</code>), only <code>grp.meth="prop"</code> applies.
</p>
<p>The function computes indicative statistics of the resulting partition, namely a pseudo R2 and a pseudo F statistics. These statistics compare the mean distance to the group medoid with the mean distance to the overall medoid. When <code>pow</code> is <code>2</code>, mean squared dissimilarities are used and when <code>pow</code> is 1 the R2 and F ratios are based on mean of non-squared dissimilarities. An indicative p-value of the F statistics is computed using the F distribution. This p-value should be interpreted with caution since F is not a true F value.
</p>


<h3>Value</h3>

<p><code>dissrf</code> returns a list of class <code>dissrfprop</code> when <code>grp.meth="prop"</code> and of class <code>dissrfcrisp</code> otherwise. In both cases the list also receives class <code>"dissrf"</code>. The elements of the list are:
</p>
<table>
<tr><td><code>medoids</code></td>
<td>
<p>index of the group medoids</p>
</td></tr>
<tr><td><code>med.names</code></td>
<td>
<p>names (diss colnames) of the group medoids</p>
</td></tr>
<tr><td><code>wg</code></td>
<td>
<p>working matrix used by the <code>"prop"</code> procedure (class <code>dissrfprop</code> only)</p>
</td></tr>
<tr><td><code>dist.list</code></td>
<td>
<p>list with for each successive group the distances from its elements to the group medoid</p>
</td></tr>
<tr><td><code>index.list</code></td>
<td>
<p>list with for each successive group the index of its elements</p>
</td></tr>
<tr><td><code>weights.list</code></td>
<td>
<p>list with for each successive group the weights of its elements in the group</p>
</td></tr>
<tr><td><code>heights</code></td>
<td>
<p>relative group size, which may be different when <code>grp.meth</code> is <code>"first"</code> or <code>"random"</code></p>
</td></tr>
<tr><td><code>kmedoid.index</code></td>
<td>
<p>vector with for each case the index of its group medoid (class <code>dissrfcrisp</code> only)</p>
</td></tr>
<tr><td><code>kmedoid.dist</code></td>
<td>
<p>vector with for each case the distance to its group medoid (class <code>dissrfcrisp</code> only)</p>
</td></tr>
<tr><td><code>mdsk</code></td>
<td>
<p>vector of group membership (class <code>dissrfcrisp</code> only)</p>
</td></tr>
<tr><td><code>at</code></td>
<td>
<p>positions for the boxplots of distances to group medoids</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>Pseudo R2: Mean distance to the group medoids over mean distance to the overall medoid</p>
</td></tr>
<tr><td><code>Fstat</code></td>
<td>
<p>Pseudo F statistics</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>p-value of the pseudo F (to be used with caution since F is not a true F value)</p>
</td></tr>
<tr><td><code>sizes</code></td>
<td>
<p><code>ncase</code> (number of cases), <code>wsum</code> (sum of weights), <code>k</code> (number of groups), <code>gsize</code> (group size)</p>
</td></tr>
<tr><td><code>grp.meth</code></td>
<td>
<p>grouping method used</p>
</td></tr>
</table>
<p><code>seqrf</code> returns a list of class <code>seqrfprop</code> when <code>grp.meth="prop"</code> and of class <code>seqrfcrisp</code> otherwise. In both cases the list also receives class <code>"seqrf"</code>. The elements of the list are:
</p>
<table>
<tr><td><code>seqtoplot</code></td>
<td>
<p>RF medoid sequences as a state sequence <code>stslist</code> object</p>
</td></tr>
<tr><td><code>rf</code></td>
<td>
<p>the associated <code>dissrf</code> object</p>
</td></tr>
</table>
<p>There are print and summary methods for objects of class <code>dissrf</code> and <code>seqrf</code>, and a plot method for objects of class <code>seqrf</code>
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard.
</p>


<h3>References</h3>

<p>Fasang, Anette Eva and Tim F. Liao. 2014. &quot;Visualizing Sequences in the Social Sciences: Relative Frequency Sequence Plots.&quot; Sociological Methods &amp; Research 43(4):643-676.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.seqrf">plot.seqrf</a></code>, <code><a href="#topic+seqrfplot">seqrfplot</a></code>, <code><a href="#topic+dissrep">dissrep</a></code>, and <code><a href="#topic+seqrep">seqrep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
"Child", "Left+Child", "Left+Marr+Child", "Divorced")

## Here, we use only 100 cases selected such that all elements
## of the alphabet be present.
## (More cases and a larger k would be necessary to get a meaningful example.)
biofam.seq &lt;- seqdef(biofam[501:600, 10:25], labels=biofam.lab,
                    weights=biofam[501:600,"wp00tbgs"])
diss &lt;- seqdist(biofam.seq, method="LCS")

## Using 12 groups, default MDS sorting,
##  and original method by Fasang and Liao (2014)
dissrf(diss=diss, k=12, grp.meth="first")

## Using 12 groups, weights, default MDS sorting,
##  and default "prop" method
w &lt;- attr(biofam.seq, "weights")
dissrf(diss=diss, k=12, weights=w)

## With a user specified sorting variable
## Here time spent in parental home, which has ties
parentTime &lt;- seqistatd(biofam.seq)[, 1]
b.srf &lt;- seqrf(biofam.seq, diss=diss, k=12, sortv=parentTime)

## print, summary, and plot methods
b.srf
summary(b.srf)
plot(b.srf)
plot(b.srf, which.plot="both")

</code></pre>

<hr>
<h2 id='disstree'>Dissimilarity Tree</h2><span id='topic+disstree'></span><span id='topic+print.disstree'></span>

<h3>Description</h3>

<p>Tree structured discrepancy analysis of objects described by their pairwise dissimilarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disstree(formula, data = NULL, weights = NULL, min.size = 0.05,
  max.depth = 5, R = 1000, pval = 0.01, object = NULL,
  weight.permutation = "replicate", squared = FALSE, first = NULL,
  minSize, maxdepth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disstree_+3A_formula">formula</code></td>
<td>
<p>Formula with a dissimilarity matrix as left hand side and the candidate partitioning variables on the right side.</p>
</td></tr>
<tr><td><code id="disstree_+3A_data">data</code></td>
<td>
<p>Data frame where variables in formula will be searched for.</p>
</td></tr>
<tr><td><code id="disstree_+3A_weights">weights</code></td>
<td>
<p>Optional numerical vector of weights.</p>
</td></tr>
<tr><td><code id="disstree_+3A_min.size">min.size</code></td>
<td>
<p>Minimum number of cases in a node, will be treated as a proportion if less than 1.</p>
</td></tr>
<tr><td><code id="disstree_+3A_max.depth">max.depth</code></td>
<td>
<p>Maximum depth of the tree</p>
</td></tr>
<tr><td><code id="disstree_+3A_r">R</code></td>
<td>
<p>Number of permutations used to assess the significance of the split.</p>
</td></tr>
<tr><td><code id="disstree_+3A_pval">pval</code></td>
<td>
<p>Maximum allowed p-value for a split</p>
</td></tr>
<tr><td><code id="disstree_+3A_object">object</code></td>
<td>
<p>An optional R object represented by the dissimilarity matrix. This object may be used by the <code>print</code> method or  <code><a href="#topic+disstree2dot">disstree2dot</a></code> to render specific object type.</p>
</td></tr>
<tr><td><code id="disstree_+3A_weight.permutation">weight.permutation</code></td>
<td>
<p>Weight permutation method: <code>"diss"</code> (attach weights to the dissimilarity matrix), <code>"replicate"</code> (replicate cases using <code>weights</code>), <code>"rounded-replicate"</code> (replicate case using rounded <code>weights</code>), <code>"random-sampling"</code> (random assignment of covariate profiles to the objects using distributions defined by the weights.)</p>
</td></tr>
<tr><td><code id="disstree_+3A_squared">squared</code></td>
<td>
<p>Logical: Should the <code>diss</code> dissimilarities be squared?</p>
</td></tr>
<tr><td><code id="disstree_+3A_first">first</code></td>
<td>
<p>One of the variable in the right-hand side of the formula. This forces the first node of the tree to be split by this variable.</p>
</td></tr>
<tr><td><code id="disstree_+3A_minsize">minSize</code></td>
<td>
<p>Deprecated. Use <code>min.size</code> instead.</p>
</td></tr>
<tr><td><code id="disstree_+3A_maxdepth">maxdepth</code></td>
<td>
<p>Deprecated. Use <code>max.depth</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure iteratively splits the data. At each step, the procedure selects the variable and split that explain the greatest part of the discrepancy,
i.e., the split for which we get the highest pseudo R2.
The significance of the retained split is assessed through a permutation test.
</p>
<p><code><a href="#topic+seqtree">seqtree</a></code> provides a simpler interface if you plan to use <code>disstree</code> for state sequence objects.
</p>


<h3>Value</h3>

<p>An object of class <code>disstree</code> that contains the following components:
</p>
<table>
<tr><td><code>root</code></td>
<td>
<p>A node object, root of the tree</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>General information such as parameters used to build the tree</p>
</td></tr>
<tr><td><code>info$adjustment</code></td>
<td>
<p>A <code><a href="#topic+dissassoc">dissassoc</a></code> object providing global statistics for tree.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula used to generate the tree</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data used to build the tree</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2011). Discrepancy analysis of state sequences, <em>Sociological Methods and Research</em>, Vol. 40(3), 471-510, <a href="https://doi.org/10.1177/0049124111415372">doi:10.1177/0049124111415372</a>.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2010)
Discrepancy	analysis of complex objects using dissimilarities.
In F. Guillet, G. Ritschard, D. A. Zighed and H. Briand (Eds.),
<em>Advances in Knowledge Discovery and Management</em>,
Studies in Computational Intelligence, Volume 292, pp. 3-19. Berlin: Springer.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2009)
Analyse de dissimilarités par arbre d'induction. In EGC 2009,
<em>Revue des Nouvelles Technologies de l'Information</em>, Vol. E-15, pp. 7-18.
</p>
<p>Anderson, M. J. (2001) A new method for non-parametric multivariate analysis of variance.
<em>Austral Ecology</em> <b>26</b>, 32-46.
</p>
<p>Batagelj, V. (1988) Generalized ward and related clustering problems. In H. Bock (Ed.),
<em>Classification and related methods of data analysis</em>, Amsterdam: North-Holland, pp. 67-74.
</p>
<p>Piccarreta, R. et F. C. Billari (2007) Clustering work and family trajectories by using a divisive
algorithm. <em>Journal of the Royal Statistical Society A</em> <b>170</b>(4), 1061&ndash;1078.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqtree">seqtree</a></code> to generate a specific <code>disstree</code> objects for analyzing state sequences.
<br />
<code><a href="#topic+seqtreedisplay">seqtreedisplay</a></code> to generate graphic representation of <code>seqtree</code> objects when analyzing state sequences.
<br />
<code><a href="#topic+disstreedisplay">disstreedisplay</a></code> is a more general interface to generate such representation for other type of objects.
<br />
<code><a href="#topic+disstreeleaf">disstreeleaf</a></code> to get leaf membership of each case.
<br />
<code><a href="#topic+disstree.get.rules">disstree.get.rules</a></code> to get the list of classification rules as R commands.
<br />
<code><a href="#topic+disstree.assign">disstree.assign</a></code> for the index of the rules applying to provided profiles.
<br />
<code><a href="#topic+dissvar">dissvar</a></code> to compute discrepancy using dissimilarities and for a basic introduction to discrepancy analysis.
<br />
<code><a href="#topic+dissassoc">dissassoc</a></code> to test association between objects represented by their dissimilarities and a covariate.
<br />
<code><a href="#topic+dissmfacw">dissmfacw</a></code> to perform multi-factor analysis of variance from pairwise dissimilarities.
<br />
<code><a href="#topic+disscenter">disscenter</a></code> to compute the distance of each object to its group center from pairwise dissimilarities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)

## Defining a state sequence object
mvad.seq &lt;- seqdef(mvad[, 17:86])

## Computing dissimilarities (any dissimilarity measure can be used)
mvad.ham &lt;- seqdist(mvad.seq, method="HAM")
## Grow the tree using a low R value for illustration.
## For R=10, pval cannot be lower than 0.1
dt &lt;- disstree(mvad.ham~ male + Grammar + funemp + gcse5eq + fmpr + livboth,
               data=mvad, R = 10, pval = 0.1)
print(dt)


## Will only work if GraphViz is properly installed
## See seqtree for a simpler way to plot a sequence tree.
## Not run: 
disstreedisplay(dt, image.fun = seqdplot, image.data = mvad.seq,
                ## Additional parameters passed to seqdplot
                with.legend = FALSE, xaxis = FALSE, ylab = "", border=NA)

## End(Not run)

## Second method, using a specific function
myplotfunction &lt;- function(individuals, seqs, ...) {
  par(font.sub=2, mar=c(3,0,6,0), mgp=c(0,0,0))
  ## using mds to order sequence in seqIplot
  mds &lt;- suppressMessages(cmdscale(seqdist(seqs[individuals,], method="HAM"),k=1))
  seqIplot(seqs[individuals,], sortv=mds,...)
}

## If image.data is not set, indexes of individuals are sent to image.fun
## Not run: 
disstreedisplay(dt, image.fun = myplotfunction, cex.main = 3,
                ## additional parameters passed to myplotfunction
                seqs = mvad.seq,
                ## additional parameters passed to seqIplot (through myplotfunction)
                with.legend = FALSE, xaxis = FALSE, ylab = "")

## End(Not run)

## Retrieving terminal node membership
term.leaf &lt;- disstreeleaf(dt)
table(term.leaf)

## Retrieving classification rules
rules &lt;- disstree.get.rules(dt)

## Index of rule (terminal leaf) that applies to a specified profile
## covariates are: male, Grammar, funemp, gcse5eq, fmpr, livboth

profile &lt;- data.frame(male="no", Grammar="yes", funemp="no", gcse5eq="yes", fmpr="no", livboth="no")
rules[disstree.assign(rules, profile=profile)]

</code></pre>

<hr>
<h2 id='disstree.assign'>Assign rules to profiles provided</h2><span id='topic+disstree.assign'></span>

<h3>Description</h3>

<p>Find the tree classification rule that applies to provided cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disstree.assign(rules, profile, covar=attr(rules,"covariates"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disstree.assign_+3A_rules">rules</code></td>
<td>
<p>Character vector. List of classification rules such as those returned by <code><a href="#topic+disstree.get.rules">disstree.get.rules</a></code>.</p>
</td></tr>
<tr><td><code id="disstree.assign_+3A_profile">profile</code></td>
<td>
<p>Data frame. Profiles of cases to be classified with the rules.</p>
</td></tr>
<tr><td><code id="disstree.assign_+3A_covar">covar</code></td>
<td>
<p>Character vector. List of names of covariates used by the rules.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rules</code> must be given as strings of R commands. Use <code><a href="#topic+disstree.get.rules">disstree.get.rules</a></code> to get the classification rules of a tree of class <code>disstree</code>.
</p>
<p>Rules are expected to create a full partition of the space of possible values of the covariates, i.e., any profile must satisfy one and only one of the rules.
</p>


<h3>Value</h3>

<p>A vector of length equal to the number of rows of <code>profile</code> with for each case the index of the rule that applies.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard)</p>


<h3>See Also</h3>

<p><code><a href="#topic+disstree">disstree</a></code>, <code><a href="#topic+disstreeleaf">disstreeleaf</a></code>, <code><a href="#topic+disstree.get.rules">disstree.get.rules</a></code></p>

<hr>
<h2 id='disstree.get.rules'>Tree classification rules</h2><span id='topic+disstree.get.rules'></span>

<h3>Description</h3>

<p>Tree classification rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disstree.get.rules(tree, collapse="; ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disstree.get.rules_+3A_tree">tree</code></td>
<td>
<p>A tree (<code>disstree</code> or <code>DissTreeNode</code> object).</p>
</td></tr>
<tr><td><code id="disstree.get.rules_+3A_collapse">collapse</code></td>
<td>
<p>Character string. Separator between categories in class of categorical values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>disstree.get.rules</code> extracts the classification rules defined by a tree grown from a dissimilarity matrix and returns them as a vector of character strings. The rules are expressed as R commands and the i-th rule, for example, can be applied using <code><a href="base.html#topic+eval">eval</a>(parse(text=rule[i]))</code>. Rules are built through a call to <code><a href="#topic+disstreeleaf">disstreeleaf</a></code>.
</p>


<h3>Value</h3>

<p>Character vector with the rules as R commands and an attribute <code>covariates</code> providing the names of the variables involved in the rules.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard)</p>


<h3>See Also</h3>

<p><code><a href="#topic+disstree">disstree</a></code>, <code><a href="#topic+disstreeleaf">disstreeleaf</a></code>, <code><a href="#topic+disstree.assign">disstree.assign</a></code></p>

<hr>
<h2 id='disstree2dot'>Graphical representation of a dissimilarity tree</h2><span id='topic+disstree2dot'></span><span id='topic+disstree2dotp'></span><span id='topic+seqtree2dot'></span>

<h3>Description</h3>

<p>Functions to generate a &quot;dot&quot; file and associated images files that can be
used in GraphViz to get a graphical representation of the tree. </p>


<h3>Usage</h3>

<pre><code class='language-R'>disstree2dot(tree, filename, digits = 3, image.fun = NULL, image.data = NULL,
  only.leaf = FALSE, device = "jpeg", image.format = "jpg",
  device.args = list(), use.title = TRUE, label.pos = "main",
  node.pos = "main", split.pos = "sub", cex.main = 1,
  legend.text = NULL, image.legend = NULL, image.quality = NULL,
  show.depth = FALSE, title.outer = FALSE,
  imagefunc, imagedata, imgLeafOnly, devicefunc, imageext,
  device.arg, label.loc, node.loc, split.loc, title.cex, legendtext,
  legendimage, qualityimage, showdepth, ...)

disstree2dotp(tree, filename, image.data = NULL, only.leaf = FALSE,
  image.fun = plot, cex.main = 3, with.quality = TRUE,
  cex.quality = cex.main, title.outer = FALSE,
  imagedata, imgLeafOnly, imagefunc, title.cex, withquality,
  quality.fontsize, ...)

seqtree2dot(tree, filename, seqdata = tree$info$object, only.leaf = FALSE,
  sortv = NULL, diss = NULL, cex.main = 3, with.legend = "auto",
  cex.legend = cex.main, with.quality = FALSE,
  cex.quality = cex.main, xaxis = FALSE,
  imgLeafOnly, dist.matrix, title.cex,
  withlegend, withquality, axes,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disstree2dot_+3A_tree">tree</code></td>
<td>
<p>The tree to be plotted.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_filename">filename</code></td>
<td>
<p>A filename, without extension, that will be used to generate image and dot files.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to plot.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_image.fun">image.fun</code></td>
<td>
<p>A function to plot the individuals in a node, see details.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_image.data">image.data</code></td>
<td>
<p>a <code>data.frame</code> that will be passed to <code>image.fun</code>, see details.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_only.leaf">only.leaf</code></td>
<td>
<p>Logical: If <code>TRUE</code>, only terminal node will be plotted.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_device">device</code></td>
<td>
<p>A device function, <code>"jpeg"</code> by default.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_image.format">image.format</code></td>
<td>
<p>extension for image files.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_device.args">device.args</code></td>
<td>
<p>Argument passed to <code>device</code>.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_use.title">use.title</code></td>
<td>
<p>Logical: If <code>TRUE</code>, node information will be printed using <code><a href="graphics.html#topic+title">title</a></code> command, see details.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_label.pos">label.pos</code></td>
<td>
<p>Location of the node label, see <code><a href="graphics.html#topic+title">title</a></code> for possible values.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_node.pos">node.pos</code></td>
<td>
<p>Node content location, see <code><a href="graphics.html#topic+title">title</a></code> for possible values.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_split.pos">split.pos</code></td>
<td>
<p>Split information location, see <code><a href="graphics.html#topic+title">title</a></code> for possible values.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_cex.main">cex.main</code></td>
<td>
<p><code>cex</code> applied to all calls to <code>title</code> (see <code>use.title</code>).</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_title.outer">title.outer</code></td>
<td>
<p>Logical: If <code>TRUE</code>, the title (see <code>use.title</code>) is printed in the outer margins.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_legend.text">legend.text</code></td>
<td>
<p>An optional text appearing in a distinct node.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_image.legend">image.legend</code></td>
<td>
<p>An optional image file appearing in a distinct node.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_image.quality">image.quality</code></td>
<td>
<p>An optional image file appearing in a distinct node.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_show.depth">show.depth</code></td>
<td>
<p>Logical. If <code>TRUE</code>, information about depth of the tree is added to the plot.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_with.quality">with.quality</code></td>
<td>
<p>If <code>TRUE</code>, a node displaying fitting measures of the tree is added to the plot.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_cex.quality">cex.quality</code></td>
<td>
<p>Numeric. Size of the font of the fitting measures node.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object as defined by the the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_sortv">sortv</code></td>
<td>
<p>The name of an optional variable used to sort the data before plotting, see <code><a href="#topic+seqplot">seqplot</a></code>.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_diss">diss</code></td>
<td>
<p>The name of an optional dissimilarity matrix used to find representative sequences, <code><a href="#topic+seqrplot">seqrplot</a></code>.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_with.legend">with.legend</code></td>
<td>
<p>defines if and where the legend of the state colors is plotted. The default value <code>"auto"</code> sets the position of the legend automatically. Other possible value is <code>"right"</code>. Obsolete value <code>TRUE</code> is equivalent to <code>"auto"</code>.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Size of the font of the legend.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_xaxis">xaxis</code></td>
<td>
<p>Logical. Should the x-axis be drawn on the plots?</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_imagefunc">imagefunc</code></td>
<td>
<p>Deprecated. Use <code>image.fun</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_imagedata">imagedata</code></td>
<td>
<p>Deprecated. Use <code>image.data</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_imgleafonly">imgLeafOnly</code></td>
<td>
<p>Deprecated. Use <code>only.leaf</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_devicefunc">devicefunc</code></td>
<td>
<p>Deprecated. Use <code>device</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_imageext">imageext</code></td>
<td>
<p>Deprecated. Use <code>image.format</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_device.arg">device.arg</code></td>
<td>
<p>Deprecated. Use <code>device.args</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_label.loc">label.loc</code></td>
<td>
<p>Deprecated. Use <code>label.pos</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_node.loc">node.loc</code></td>
<td>
<p>Deprecated. Use <code>node.pos</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_split.loc">split.loc</code></td>
<td>
<p>Deprecated. Use <code>split.pos</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_title.cex">title.cex</code></td>
<td>
<p>Deprecated. Use <code>cex.main</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_legendtext">legendtext</code></td>
<td>
<p>Deprecated. Use <code>legend.text</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_legendimage">legendimage</code></td>
<td>
<p>Deprecated. Use <code>image.legend</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_qualityimage">qualityimage</code></td>
<td>
<p>Deprecated. Use <code>image.quality</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_showdepth">showdepth</code></td>
<td>
<p>Deprecated. Use <code>show.depth</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_withquality">withquality</code></td>
<td>
<p>Deprecated. Use <code>with.quality</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_quality.fontsize">quality.fontsize</code></td>
<td>
<p>Deprecated. Use <code>cex.quality</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_dist.matrix">dist.matrix</code></td>
<td>
<p>Deprecated. Use <code>diss</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_withlegend">withlegend</code></td>
<td>
<p>Deprecated. Use <code>with.legend</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_axes">axes</code></td>
<td>
<p>Deprecated. Use <code>xaxis</code> instead.</p>
</td></tr>
<tr><td><code id="disstree2dot_+3A_...">...</code></td>
<td>
<p>other parameters that will be passed to <code>image.fun</code> or <code><a href="#topic+seqplot">seqplot</a></code> (for <code>seqtree2dot</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions generate a &quot;dot&quot; file that can be used in GraphViz (<code>http://www.graphviz.org</code>).
It also generates one image per node through a call to
<code>image.fun</code> passing the selected lines of <code>image.data</code> if
present or otherwise a list of indexes (of individuals belonging to a
node). These functions are not intended to be used by end-user. See <code><a href="#topic+seqtreedisplay">seqtreedisplay</a></code>
and <code><a href="#topic+disstreedisplay">disstreedisplay</a></code> for a much simpler way to generate a graphical representation of a
tree (<code><a href="#topic+seqtree">seqtree</a></code> or <code><a href="#topic+disstree">disstree</a></code>).
</p>
<p>If the path to GraphViz is not found, pass the path as <code>gvpath</code> argument among the ... list.
</p>
<p><code>seqtree2dot</code> is a shortcut for sequences objects using the plot function <code><a href="#topic+seqplot">seqplot</a></code>. For each node, it calls <code><a href="#topic+seqplot">seqplot</a></code> with the corresponding subset of rows of <code>seqdata</code> and the provided <code><a href="#topic+seqplot">seqplot</a></code>'s arguments.
You should at least specify the <code>type</code> of the plot (e.g.  <code>type="d"</code>, see <code><a href="#topic+seqplot">seqplot</a></code> for more details).
</p>
<p>If <code>use.title</code> is <code>TRUE</code>, <code>image.fun</code> should take care
to leave enough space for the title.
</p>
<p><code>disstree2dotp</code> is a simplified interface of
<code>disstree2dot</code> which automatically leaves enough space for the title and subtitles. These functions are intended to be generic.
</p>


<h3>Value</h3>

<p>Nothing but generates a &quot;dot&quot; and several image files (one per node) in the current working directory (see <code><a href="base.html#topic+getwd">getwd</a></code> and <code><a href="base.html#topic+setwd">setwd</a></code>).
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqtree">seqtree</a></code> and <code><a href="#topic+seqtreedisplay">seqtreedisplay</a></code>, <code><a href="#topic+disstree">disstree</a></code> and <code><a href="#topic+disstreedisplay">disstreedisplay</a></code>.</p>

<hr>
<h2 id='disstreeleaf'>Terminal node membership</h2><span id='topic+disstreeleaf'></span>

<h3>Description</h3>

<p>Get the terminal node membership of each case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disstreeleaf(tree, label=FALSE, collapse=", ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disstreeleaf_+3A_tree">tree</code></td>
<td>
<p>A tree (<code>disstree</code> or <code>DissTreeNode</code> object).</p>
</td></tr>
<tr><td><code id="disstreeleaf_+3A_label">label</code></td>
<td>
<p>Logical. Should leaf memberships be labelled with classification rules?</p>
</td></tr>
<tr><td><code id="disstreeleaf_+3A_collapse">collapse</code></td>
<td>
<p>Character string. Separator between categories in class of categorical values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>disstreeleaf</code> returns the terminal node membership of the cases either as the leaf number of the terminal node to which the cases are assigned or, when <code>label=TRUE</code>, as the classification rule leading to the assigned terminal node. In the latter case, <code>collapse</code> is used as separator between categorical values in classes of categorical values. The default <code>collapse</code> is <code>", "</code>. It is advisable to change this default when categorical values contain commas.
</p>


<h3>Value</h3>

<p>Either a vector of leaf numbers or a factor. When <code>label=FALSE</code> (default), vector of assigned terminal node numbers. When <code>label=TRUE</code>, a factor with levels labelled with classification rules.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer and Gilbert Ritschard)</p>


<h3>See Also</h3>

<p><code><a href="#topic+disstree">disstree</a></code> for examples, <code><a href="#topic+disstree.get.rules">disstree.get.rules</a></code>, and <code><a href="#topic+disstree.assign">disstree.assign</a></code>.</p>

<hr>
<h2 id='dissvar'>Dissimilarity based discrepancy</h2><span id='topic+dissvar'></span>

<h3>Description</h3>

<p>Compute the discrepancy from the pairwise dissimilarities between objects. The discrepancy is a measure of dispersion of the set of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissvar(diss, weights=NULL, squared = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissvar_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a <code>dist</code> object (see <code><a href="stats.html#topic+dist">dist</a></code>)</p>
</td></tr>
<tr><td><code id="dissvar_+3A_weights">weights</code></td>
<td>
<p>optional numerical vector containing weights.</p>
</td></tr>
<tr><td><code id="dissvar_+3A_squared">squared</code></td>
<td>
<p>Logical. If <code>TRUE</code> <code>diss</code> is squared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrepancy is an extension of the concept of variance to any kind of objects for which we can compute pairwise dissimilarities.
The discrepancy <code class="reqn">s^2</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">s^2=\frac{1}{2n^2}\sum_{i=1}^{n}\sum_{j=1}^{n}d_{ij}</code>
</p>

<p><em>Mathematical ground</em>:
In the Euclidean case, the sum of squares can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">SS=\sum_{i=1}^{n}(y_i-\bar{y})^2=\frac{1}{2n}\sum_{i=1}^{n}\sum_{j=1}^{n}(y_i-y_j)^2</code>
</p>

<p>The concept of discrepancy generalizes the equation by allowing to replace the  <code class="reqn">(y_i - y_j)^2</code> term with any  measure of dissimilarity <code class="reqn">d_{ij}</code>.
</p>


<h3>Value</h3>

<p>The discrepancy.</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2011). Discrepancy analysis of state sequences, <em>Sociological Methods and Research</em>, Vol. 40(3), 471-510, <a href="https://doi.org/10.1177/0049124111415372">doi:10.1177/0049124111415372</a>.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2010)
Discrepancy analysis of complex objects using dissimilarities.
In F. Guillet, G. Ritschard, D. A. Zighed and H. Briand  (Eds.),
<em>Advances in Knowledge Discovery and Management</em>,
Studies in Computational Intelligence, Volume 292, pp. 3-19. Berlin: Springer.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2009)
Analyse de dissimilarités par arbre d'induction. In EGC 2009,
<em>Revue des Nouvelles Technologies de l'Information</em>, Vol. E-15, pp. 7-18.
</p>
<p>Anderson, M. J. (2001) A new method for non-parametric multivariate analysis of variance.
<em>Austral Ecology</em> <b>26</b>, 32-46.
</p>
<p>Batagelj, V. (1988) Generalized ward and related clustering problems. In H. Bock (Ed.),
<em>Classification and related methods of data analysis</em>, Amsterdam: North-Holland, pp. 67-74.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dissassoc">dissassoc</a></code> to test association between objects represented by their dissimilarities and a covariate.
<br />
<code><a href="#topic+disstree">disstree</a></code> for an induction tree analyse of objects characterized by a dissimilarity matrix.
<br />
<code><a href="#topic+disscenter">disscenter</a></code> to compute the distance of each object to its group center from pairwise dissimilarities.
<br />
<code><a href="#topic+dissmfacw">dissmfacw</a></code> to perform multi-factor analysis of variance from pairwise dissimilarities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a state sequence object
data(mvad)
mvad.seq &lt;- seqdef(mvad[, 17:86])

## Building dissimilarities (any dissimilarity measure can be used)
mvad.ham &lt;- seqdist(mvad.seq, method="HAM")

## Pseudo variance of the sequences
print(dissvar(mvad.ham))
</code></pre>

<hr>
<h2 id='ex1'>Example data set with missing values and weights</h2><span id='topic+ex1'></span>

<h3>Description</h3>

<p>Example data set used to demonstrate the handling of missing values and weights.
</p>
<p>The state columns (variable) are named <code>'P1'</code> to <code>'P13'</code>.
</p>
<p>The alphabet is made of four possible states: <code>A, B, C</code> and <code>D</code>.
<br />
</p>
<p>The data set contains also case weights (variable <code>weights</code>). The sum of the weights is 60.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ex1)</code></pre>


<h3>Format</h3>

<p>A data frame with 7 rows, 13 state variables, 1 weight variable.</p>


<h3>Source</h3>

<p>The brain of the TraMineR package team.</p>

<hr>
<h2 id='ex2'>Example data sets with weighted and unweighted sequence data</h2><span id='topic+ex2'></span><span id='topic+ex2.weighted'></span><span id='topic+ex2.unweighted'></span>

<h3>Description</h3>

<p>Example data sets used to demonstrate the handling of weights. The <code>'ex2.weighted'</code> data set contains 6 sequences with weights inflating to 100 sequences (sum of weights is 100). The second data frame <code>'ex2.unweighted'</code> contains the corresponding 100 sequences.
</p>
<p>The sequences are, in both data frames, in the <code>'seq'</code> column, and weights in the <code>'weight'</code> column of <code>'ex2.weighted'</code>.
</p>
<p>The alphabet is made of four possible states: <code>A, B, C</code> and <code>D</code>.
<br />
</p>
<p>These data sets are mainly intended to test and illustrate the handling of weights in TraMineR's functions. Weighted results obtained with '<code>ex2.weighted</code>' data set should be exactly the same as unweighted results obtained with the '<code>ex2.unweighted</code>' data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ex2)</code></pre>


<h3>Format</h3>

<p>The command <code>data(ex2)</code> generates two data frames:
<br />
<code>ex2.weighted</code>: a data frame with 6 rows, 1 variable containing sequences as character strings, 1 weight variable.
<br />
<code>ex2.unweighted</code>: a data frame with 100 rows, 1 variable containing sequences as character strings.
</p>


<h3>Source</h3>

<p>The brain of the TraMineR package team.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex2)

ex2w.seq &lt;- seqdef(ex2.weighted, 1, weights=ex2.weighted$weight)
ex2u.seq &lt;- seqdef(ex2.unweighted)
</code></pre>

<hr>
<h2 id='famform'>Example data set: sequences of family formation</h2><span id='topic+famform'></span>

<h3>Description</h3>

<p>This data set contains 5 sequences of family formation histories, used by Elzinga (2008) to introduce several metrics for computing distances between sequences. These sequences don't contain information about the duration spent in each state, they contain only distinct successive states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(famform)</code></pre>


<h3>Format</h3>

<p>A data frame with 5 rows and 1 variable.</p>


<h3>Details</h3>

<p>The sequences are in &lsquo;STS&rsquo; format and stored in character strings with states separated with &lsquo;-&rsquo;.
</p>
<p>This data set is used in TraMineR's manual to crosscheck some results with those presented by Elzinga.
</p>


<h3>Source</h3>

<p>Elzinga (2008)</p>


<h3>References</h3>

<p>Elzinga, Cees H. (2008). Sequence analysis: Metric representations of categorical time
series. Non published manuscript. VU University, Amsterdam.
</p>

<hr>
<h2 id='is.eseq'>Event sequence object</h2><span id='topic+is.eseq'></span><span id='topic+is.seqe'></span><span id='topic+is.seqelist'></span><span id='topic+print.eseq'></span><span id='topic+print.seqelist'></span><span id='topic+levels.seqelist'></span><span id='topic++5B.seqelist'></span><span id='topic+levels.eseq'></span><span id='topic+Math.eseq'></span><span id='topic+Math.seqelist'></span><span id='topic+Ops.eseq'></span><span id='topic+Ops.seqelist'></span><span id='topic+Summary.eseq'></span><span id='topic+Summary.seqelist'></span>

<h3>Description</h3>

<p>TraMineR uses an internal event sequence object for all its operations
with event sequences such as mining frequent subsequences. The
function <code>is.seqelist</code> checks wether the argument is an event
sequence object while <code>is.eseq</code> checks wether the argument is a
single element of an event sequence object.

</p>
<p>There is a print method that can be applied to such event sequence object.
</p>
<p>is.seqe() has been removed in TraMineR 2.x, use is.eseq() instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.eseq(eseq, s)
is.seqelist(eseq, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.eseq_+3A_eseq">eseq</code></td>
<td>
<p>Sequence</p>
</td></tr>
<tr><td><code id="is.eseq_+3A_s">s</code></td>
<td>
<p>Deprecated. Use <code>eseq</code> instead.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+str.seqelist">str.seqelist</a></code>, <code><a href="#topic+str.eseq">str.eseq</a></code>,<code><a href="#topic+as.character.seqelist">as.character.seqelist</a></code> and <code><a href="#topic+as.character.eseq">as.character.eseq</a></code> to convert sequences from an event sequence object into character strings</p>

<hr>
<h2 id='is.stslist'>Test if is a proper state sequence (stslist) object</h2><span id='topic+is.stslist'></span>

<h3>Description</h3>

<p>The function tests whether <code>x</code> is of class <code>stslist</code> and if its <code>weights</code> attribute has the expected length and names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.stslist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.stslist_+3A_x">x</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical: result of the test.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdef">seqdef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object with the columns 13 to 24
## in the 'actcal' example data set
data(biofam)
biofam &lt;- biofam[sample(nrow(biofam),300),]
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
                "Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.seq &lt;- seqdef(biofam[,10:25], weights=biofam$wp00tbgs)

is.stslist(biofam.seq) #TRUE

attr(biofam.seq,"weights") &lt;- NULL
is.stslist(biofam.seq) #TRUE

attr(biofam.seq,"weights") &lt;- rep(1, nrow(biofam.seq))
is.stslist(biofam.seq) #FALSE

w &lt;- rep(1, nrow(biofam.seq))
names(w) &lt;- rownames(biofam.seq)
attr(biofam.seq,"weights") &lt;- w
is.stslist(biofam.seq) #TRUE

</code></pre>

<hr>
<h2 id='mvad'>Example data set: Transition from school to work</h2><span id='topic+mvad'></span>

<h3>Description</h3>

<p> The data comes from a study by McVicar and Anyadike-Danes on
transition from school to work. The data consist of static background
characteristics and a time series sequence of 72 monthly labour market
activities for each of 712 individuals in a cohort survey. The individuals
were followed up from July 1993 to June 1999. The monthly states are recorded
in columns 15 (<code>Jul.93</code>)  to 86 (<code>Jun.99</code>).
</p>
<p>States are:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>employment</code>  </td><td style="text-align: left;"> (EM) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>FE</code>          </td><td style="text-align: left;"> further education (FE)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>HE</code>          </td><td style="text-align: left;"> higher education (HE) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>joblessness</code> </td><td style="text-align: left;"> (JL) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>school</code>      </td><td style="text-align: left;"> (SC) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>training</code>    </td><td style="text-align: left;"> (TR)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The data set contains also ids (<code>id</code>) and sample weights (<code>weight</code>) as well as the following binary covariates:<br />
<br />
<code>male</code><br />
<code>catholic</code><br />
<code>Belfast</code>, <code>N.Eastern</code>, <code>Southern</code>, <code>S.Eastern</code>, <code>Western</code> (location of school, one of five Education and Library Board areas in Northern Ireland)<br />
<code>Grammar</code> (type of secondary education, 1=grammar school)<br />
<code>funemp</code> (father's employment status at time of survey, 1=father unemployed)<br />
<code>gcse5eq</code> (qualifications gained by the end of compulsory education, 1=5+ GCSEs at grades A-C, or equivalent)<br />
<code>fmpr</code> (SOC code of father's current or most recent job, 1=SOC1 (professional, managerial or related))<br />
<code>livboth</code> (living arrangements at time of first sweep of survey (June 1995), 1=living with both parents)<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mvad)</code></pre>


<h3>Format</h3>

<p>A data frame containing 712 rows, 72 state variables, 1 id variable and 13 covariates.</p>


<h3>Source</h3>

<p>McVicar and Anyadike-Danes (2002)</p>


<h3>References</h3>

<p>McVicar, Duncan and Anyadike-Danes, Michael (2002). Predicting Successful and Unsuccessful Transitions from School to Work by Using Sequence Methods,
<em>Journal of the Royal Statistical Society. Series A (Statistics in Society)</em>, 165, 2, pp. 317&ndash;334.
</p>

<hr>
<h2 id='plot.seqdiff'>
Plotting a seqdiff object.
</h2><span id='topic+plot.seqdiff'></span>

<h3>Description</h3>

<p>Plot method for the sliding values returned by <code><a href="#topic+seqdiff">seqdiff</a></code>. Plots a statistic (the Pseudo R2 by default) along the position axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqdiff'
plot(x, stat = "Pseudo R2", type = "l", ylab = stat,
  xlab = "", legend.pos = "top", ylim = NULL, xaxis = TRUE, col = NULL,
  xtstep = NULL, tick.last = NULL, legendposition, xaxt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.seqdiff_+3A_x">x</code></td>
<td>
<p>an object produced by <code><a href="#topic+seqdiff">seqdiff</a></code></p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_stat">stat</code></td>
<td>
<p>character. Name of the statistic to be plotted. Can be any of the statistics returned by <code><a href="#topic+seqdiff">seqdiff</a></code> or <code>"discrepancy"</code>. See details.</p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_type">type</code></td>
<td>
<p>the line <code>type</code>, see <code><a href="graphics.html#topic+lines">lines</a></code> </p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_ylab">ylab</code></td>
<td>
<p>character: y-axis label.</p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_xlab">xlab</code></td>
<td>
<p>character: x-axis label.</p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_legend.pos">legend.pos</code></td>
<td>
<p>character: position of the line legend, see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_ylim">ylim</code></td>
<td>
<p>numeric: if not <code>NULL</code>, range of the y-axis.</p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_xaxis">xaxis</code></td>
<td>
<p>logical: if <code>TRUE</code> an x-axis is plotted.</p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_col">col</code></td>
<td>
<p>list of colors to use for each line.</p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_xtstep">xtstep</code></td>
<td>
<p>integer: optional step between tick-marks and labels on the x-axis. If unspecified, the <code>xtstep</code> attribute of the sequence object <code>x</code> is used. (see <code><a href="#topic+seqdef">seqdef</a></code>)</p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_tick.last">tick.last</code></td>
<td>
<p>Logical. Should a tick mark be enforced at the last position on the x-axis? If unspecified, the <code>tick.last</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_legendposition">legendposition</code></td>
<td>
<p>Deprecated. Use <code>legend.pos</code> instead.</p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_xaxt">xaxt</code></td>
<td>
<p>Deprecated. Use <code>xaxis</code> instead.</p>
</td></tr>
<tr><td><code id="plot.seqdiff_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="graphics.html#topic+lines">lines</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots the sliding values of the requested statistic.
</p>
<p>You can plot the evolution of two statistics by providing for instance <code>stat=c("Pseudo R2", "Levene")</code>.
</p>
<p>Use <code>stat="discrepancy"</code> to plot the within-discrepancies.
</p>
<p>For <code>"discrepancy"</code>, a separate line is drawn for the whole set of sequences and for each group. Those two values cannot be paired with another statistic.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdiff">seqdiff</a></code></p>

<hr>
<h2 id='plot.seqrf'>
Plot method for seqrf objects of relative frequency groups of sequences.
</h2><span id='topic+plot.seqrf'></span>

<h3>Description</h3>

<p>Plots the medoids of the RF groups of sequences and/or the boxplots of the distribution of the distances from the sequences to their group medoid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqrf'
plot(x,
        space=0,
        border=NA,
        which.plot="medoids",
        ylab=NA,
        main=NULL,
        frame.plot=FALSE,
        info="all",
        skipar=FALSE,
        ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.seqrf_+3A_x">x</code></td>
<td>
<p>a <code>seqrf</code> object</p>
</td></tr>
<tr><td><code id="plot.seqrf_+3A_space">space</code></td>
<td>
<p>space between horizontal bars representing medoid sequences (see <code><a href="graphics.html#topic+barplot">barplot</a></code>)</p>
</td></tr>
<tr><td><code id="plot.seqrf_+3A_border">border</code></td>
<td>
<p>the color to be used for the border of the bars. Use border = NA to omit borders. (see <code><a href="graphics.html#topic+barplot">barplot</a></code>)</p>
</td></tr>
<tr><td><code id="plot.seqrf_+3A_which.plot">which.plot</code></td>
<td>
<p>string. One of <code>"both"</code>, <code>"medoids"</code>, <code>"diss.to.med"</code>. When <code>"medoids"</code>, only the index plot of the medoids is displayed, when <code>"diss.to.med"</code>, the grouped boxplots of the distances to the medoids is displayed, and when <code>"both"</code> a combined plot of the two plots is displayed.</p>
</td></tr>
<tr><td><code id="plot.seqrf_+3A_ylab">ylab</code></td>
<td>
<p>string. An optional label for the y-axis. If set as <code>NA</code> (default), no label is drawn.</p>
</td></tr>
<tr><td><code id="plot.seqrf_+3A_main">main</code></td>
<td>
<p>main graphic title. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.seqrf_+3A_frame.plot">frame.plot</code></td>
<td>
<p>logical. Should a frame be plotted around the grouped boxplots?</p>
</td></tr>
<tr><td><code id="plot.seqrf_+3A_info">info</code></td>
<td>
<p>string. One of <code>"all"</code> (default), <code>"subtitle"</code>, <code>"stat"</code>, and <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="plot.seqrf_+3A_skipar">skipar</code></td>
<td>
<p>logical. Should <code>plot</code> skip internal <code>par</code> and <code>layout</code> commands. May be necessary to combine <code>"medoids"</code> or <code>"diss.to.med"</code> plots with <code>layout</code> or <code>par(mfrow=...)</code></p>
</td></tr>
<tr><td><code id="plot.seqrf_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+plot.stslist">plot.stslist</a></code> including graphical parameters (<code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot of the medoids is generated with the plot method for <code>stslist</code> objects and the boxplots with a slightly adapted version of the boxplot function for weighted data (<code>wtd.boxplot</code>) of the ENmisc package by Erich Neuwirth.
</p>
<p>When <code>which.plot="both"</code>, <code><a href="graphics.html#topic+layout">layout</a></code> is used to produce the combined plot. Therefore, the resulting combined plot cannot be nested into other combinations using either <code>par(mfrow=...)</code> or <code>layout</code>. To combine with other plots, you must produce separately the plot of the medoids and the grouped boxplots using successively <code>which.plot="medoids"</code> and <code>which.plot="diss.to.med"</code>.
</p>
<p>When arguments <code>xaxis</code> and <code>yaxis</code> are on the <code>...</code> list to be passed to <code><a href="#topic+plot.stslist">plot.stslist</a></code>, they are also used to control the display of the x and y axis of the boxplot.
</p>
<p>With <code>info="stat"</code> or <code>"all"</code>, the pseudo R2 and F statistics are displayed under the plot, but only when <code>which.plot = "both"</code>.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqrf">seqrf</a></code>, <code><a href="#topic+seqrfplot">seqrfplot</a></code>
</p>

<hr>
<h2 id='plot.stslist'>Plot method for state sequence objects</h2><span id='topic+plot.stslist'></span>

<h3>Description</h3>

<p>This is the plot method for state sequence objects of class <code>stslist</code> created by the <code>seqdef</code> function. It produces a sequence index plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stslist'
plot(x, idxs = NULL, weighted = TRUE, sortv = NULL,
  cpal = NULL, missing.color = NULL, ylab = NULL,
  yaxis = TRUE, xaxis = TRUE, ytlab = NULL, las = par("las"),
  xtlab = NULL, xtstep = NULL, tick.last = NULL, cex.axis = par("cex.axis"),
  tlim, cex.plot, ylas, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stslist_+3A_x">x</code></td>
<td>
<p>A state sequence object created with the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_idxs">idxs</code></td>
<td>
<p>Indexes of the sequences to be plotted (default value is <code>1:10</code>), for instance <code>20:50</code> to plot sequences 20 to 50, <code>c(2,8,12,25)</code> to plot sequences 2,8,12 and 25 in <code>seqdata</code>. If set to <code>0</code>, all sequences in <code>seqdata</code> are plotted.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_weighted">weighted</code></td>
<td>
<p>Logical: Should the bar representing each sequence be proportional to its weight? Ignored when no weights are assigned to sequences (see <code><a href="#topic+seqdef">seqdef</a></code>.)</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_sortv">sortv</code></td>
<td>
<p>A sorting variable or a sort method (one of <code>"from.start"</code> or <code>"from.end"</code>). See details.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_cpal">cpal</code></td>
<td>
<p>Color palette for the states. A vector of colors of length equal to the number of states in the alphabet. If <code>NULL</code> (default), the <code>cpal</code> attribute of the <code>seqdata</code> sequence object is used (see <code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_missing.color">missing.color</code></td>
<td>
<p>Color for representing missing values inside the sequences. If <code>NULL</code> (default) the color is taken from the &quot;missing.color&quot; attribute of the <code>x</code> sequence object.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_ylab">ylab</code></td>
<td>
<p>String. Optional label of the y-axis. If set to <code>NA</code>, no label is drawn.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_yaxis">yaxis</code></td>
<td>
<p>Logical. Should the y-axis be plotted. When set as <code>TRUE</code>, sequence indexes are displayed.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_xaxis">xaxis</code></td>
<td>
<p>Logical. Should the x-axis (time) be plotted? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_ytlab">ytlab</code></td>
<td>
<p>Character string or vector of length equal to the number of  sequences. Labels of the plotted sequences to be used as tick labels on the y-axis. Default is the indexes of the sequences as defined by the <code>idxs</code> argument. Can be set to <code>"id"</code> for displaying the row names (id) of the sequences instead of their indexes; row names can be assigned to the sequence object with the  <code>id</code> argument of the <code><a href="#topic+seqdef">seqdef</a></code> function or afterwards with <code><a href="base.html#topic+rownames">rownames</a></code>. Otherwise <code>ytlab</code> can be set to a vector of length equal to the number of  sequences to be plotted.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_las">las</code></td>
<td>
<p>numeric in {0,1,2,3}; the orientation of tick labels.
<br />
0: always parallel to the axis (default),
<br />
1: always horizontal,
<br />
2: always perpendicular to the axis,
<br />
3: always vertical.
</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_xtlab">xtlab</code></td>
<td>
<p>optional labels for the x-axis tick labels. If unspecified, the column names of the <code>seqdata</code> sequence object are used (see <code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_xtstep">xtstep</code></td>
<td>
<p>optional interval at which tick marks and labels of the x-axis are displayed. For example, with <code>xtstep=3</code> a tick mark is drawn at position 1, 4, 7, etc... The display of the corresponding labels depends on the available space and is dealt with automatically. If unspecified, the <code>xtstep</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_tick.last">tick.last</code></td>
<td>
<p>Logical. Should a tick mark be enforced at the last position on the x-axis? If unspecified, the <code>tick.last</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Axis annotation magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_tlim">tlim</code></td>
<td>
<p>Deprecated. Use <code>idxs</code> instead.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_cex.plot">cex.plot</code></td>
<td>
<p>Deprecated. Use <code>cex.axis</code> instead.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_ylas">ylas</code></td>
<td>
<p>Deprecated. Use <code>las</code> instead.</p>
</td></tr>
<tr><td><code id="plot.stslist_+3A_...">...</code></td>
<td>
<p>further graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>) and <code><a href="graphics.html#topic+barplot">barplot</a></code> arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the default plot method for state sequence objects (produced by the <code><a href="#topic+seqdef">seqdef</a></code> function), i.e., for objects of class <em>stslist</em>. It produces a sequence index plot, where individual sequences are rendered with stacked bars depicting the successive states in each of the sequences.
<br />
<br />
</p>
<p>This method is invoked by several advanced plot functions such as  <code>seqiplot</code> and <code>seqIplot</code> (<code><a href="#topic+seqplot">seqplot</a></code> with <code>type="i"</code> or <code>"I"</code>), which, in addition to index plots, automatically display the state color legend and allow plotting by group.
</p>
<p>When a <code>sortv</code> variable is provided, the sequences are sorted bottom-up according to its values. With <code>sortv = "from.start"</code>, sequence are sorted by the elements of the alphabet at the successive positions starting from the beginning of the sequences. Method <code>"from.end"</code> proceeds similarly, but backward from the last position.
</p>
<p>Index plots of thousands of sequences result in very heavy graphic files when stored in vectorial (PDF or POSTSCRIPT) format because each sequence, even if hidden, is drawn individually. To reduce the file size, we suggest saving the figures in bitmap format by using for instance <code><a href="grDevices.html#topic+png">png</a></code> instead of <code><a href="grDevices.html#topic+postscript">postscript</a></code> or <code><a href="grDevices.html#topic+pdf">pdf</a></code>.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqplot">seqplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam &lt;- biofam[500:600,] ## using a subsample only
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
    "Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.seq &lt;- seqdef(biofam, 10:25, labels=biofam.lab)

## Plot of the 10 most frequent sequences
## with bar width proportional to the frequency
plot(biofam.seq)

## Plotting the whole data set
## with no borders
plot(biofam.seq, idxs=0, space=0, border=NA)

## =======
## Weights
## =======
data(ex1)
ex1.seq &lt;- seqdef(ex1, 1:13, weights=ex1$weights)
plot(ex1.seq)
plot(ex1.seq, weighted=FALSE)
</code></pre>

<hr>
<h2 id='plot.stslist.freq'>Plot method for sequence frequency tables</h2><span id='topic+plot.stslist.freq'></span>

<h3>Description</h3>

<p>Plot method for output produced by the <code>seqtab</code> function, i.e objects of class <code>stslist.freq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stslist.freq'
plot(x, cpal = NULL, missing.color = NULL, pbarw = TRUE,
  ylab = NULL, yaxis = TRUE, xaxis = TRUE,
  xtlab = NULL, xtstep = NULL, tick.last = NULL, cex.axis = par("cex.axis"),
  cex.plot, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stslist.freq_+3A_x">x</code></td>
<td>
<p>an object of class <code>stslist.freq</code> as produced by the <code>seqtab</code> function.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_cpal">cpal</code></td>
<td>
<p>alternative color palette to be used for the states. If user specified, a vector of colors with number of elements equal to the number of states in the alphabet. By default, the <code>cpal</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_missing.color">missing.color</code></td>
<td>
<p>alternative color for representing missing values inside the sequences. By default, the <code>missing.color</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_pbarw">pbarw</code></td>
<td>
<p>if <code>pbarw=TRUE</code> (default), the width of the bars are proportional to the sequence frequency in the dataset.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_ylab">ylab</code></td>
<td>
<p>label of the y axis. If set to <code>NA</code>, no label is drawn.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_yaxis">yaxis</code></td>
<td>
<p>if <code>TRUE</code> or <code>"cum"</code>, the y axis is plotted with a label showing the cumulated percentage frequency of the displayed sequences. If <code>"pct"</code>, the percentage value for each sequence is displayed.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_xaxis">xaxis</code></td>
<td>
<p>if <code>TRUE</code> (default) the x-axis is plotted.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_xtlab">xtlab</code></td>
<td>
<p>tick labels of the x-axis. If unspecified, the <code>names</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_xtstep">xtstep</code></td>
<td>
<p>interval at which the tick-marks and labels of the x-axis are displayed. For example, with xtstep=3 a tick-mark is drawn at position 1, 4, 7, etc... The display of the corresponding labels depends on the available space and is dealt with automatically. If unspecified, the <code>xtstep</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_tick.last">tick.last</code></td>
<td>
<p>Logical. Should a tick mark be enforced at the last position on the x-axis? If unspecified, the <code>tick.last</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Axis annotation magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_...">...</code></td>
<td>
<p>further graphical and <code><a href="graphics.html#topic+barplot">barplot</a></code> parameters. For example <code>border=NA</code> removes the bars borders, <code>space=0</code> removes space between sequences, <code>las</code> controls orientation of tick labels. See <code><a href="graphics.html#topic+barplot">barplot</a></code> and <code><a href="graphics.html#topic+par">par</a></code> for details. </p>
</td></tr>
<tr><td><code id="plot.stslist.freq_+3A_cex.plot">cex.plot</code></td>
<td>
<p>Deprecated. Use <code>cex.axis</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for output of the <code><a href="#topic+seqtab">seqtab</a></code> function, i.e., for objects of class <em>stslist.freq</em>. It plots the sequences bottom-up according to their frequency in the data set.
</p>
<p>The method is invoked by  <code><a href="#topic+seqfplot">seqfplot</a></code> (<code>seqplot</code> with <code>type="f"</code>), which produces frequency plots with automatic display of the state color legend and allows plotting by group.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqfplot">seqfplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading the 'actcal' example data set
data(actcal)

## Defining a sequence object with data in columns 13 to 24
## (activity status from january to december 2000)
actcal.lab &lt;- c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work")
actcal.seq &lt;- seqdef(actcal, 13:24, labels=actcal.lab)

## 10 most frequent sequences in the data
actcal.freq &lt;- seqtab(actcal.seq)

## Plotting the object
plot(actcal.freq, main="Sequence frequencies - actcal data set")

## Plotting all the distinct sequences without borders
## and space between sequences
actcal.freq2 &lt;- seqtab(actcal.seq, idxs=0)
plot(actcal.freq2, main="Sequence frequencies - actcal data set",
  border=NA, space=0)
</code></pre>

<hr>
<h2 id='plot.stslist.meant'>Plot method for objects produced by the seqmeant function</h2><span id='topic+plot.stslist.meant'></span>

<h3>Description</h3>

<p>This is the plot method for objects of class <em>stslist.meant</em> produced by the <code><a href="#topic+seqmeant">seqmeant</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stslist.meant'
plot(x, cpal = NULL, ylab = NULL, yaxis = TRUE,
  xaxis = TRUE, cex.axis = par("cex.axis"), ylim = NULL, bar.labels = NULL,
  cex.barlab = cex.axis, offset.barlab = .1, cex.plot, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stslist.meant_+3A_x">x</code></td>
<td>
<p>object of class <code>stslist.meant</code> as produced by the <code>seqmeant</code> function.</p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_cpal">cpal</code></td>
<td>
<p>vector of colors of length the number of states in the alphabet. If <code>NULL</code> (default), the '<code>cpal</code>' attribute of the '<code>seqdata</code>' sequence object is used (see <code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_ylab">ylab</code></td>
<td>
<p>optional label of the y-axis. If set to <code>NA</code>, no label is drawn.</p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_yaxis">yaxis</code></td>
<td>
<p>should the y-axis be plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_xaxis">xaxis</code></td>
<td>
<p>should the x-axis be plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Tick labels magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_ylim">ylim</code></td>
<td>
<p>optional vector of length 2 setting the limits of the y-axis. If <code>NULL</code> (default), limits are set to (0, max. sequence length).</p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_bar.labels">bar.labels</code></td>
<td>
<p>Vector of bar labels of length equal to size of alphabet.</p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_cex.barlab">cex.barlab</code></td>
<td>
<p>Real. Bar labels magnification. Defaults to <code>cex.axis</code></p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_offset.barlab">offset.barlab</code></td>
<td>
<p>Real. Vertical offset of bar labels as a proportion of <code>max(ylim)</code>.  Default is 0.1.</p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_cex.plot">cex.plot</code></td>
<td>
<p>Deprecated. Use <code>cex.axis</code> instead.</p>
</td></tr>
<tr><td><code id="plot.stslist.meant_+3A_...">...</code></td>
<td>
<p>further graphical parameters. For more details about the graphical parameter arguments, see <code>barplot</code> and <code>par</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for the output produced by the <code><a href="#topic+seqmeant">seqmeant</a></code> function, i.e., objects of class <em>stslist.meant</em>. It produces a plot showing the mean times spent in each state of the alphabet.
</p>
<p>When the <code>"se"</code> attribute of <code>x</code> is <code>TRUE</code>, i.e., when <code>x</code> contains also the standard errors of the mean times, error bars are automatically displayed on the plot. See the <code>serr</code> argument of  <code><a href="#topic+seqmeant">seqmeant</a></code>.
</p>
<p>The method is invoked by <code><a href="#topic+seqmtplot">seqmtplot</a></code> (<code>seqplot</code> with <code>type="mt"</code>), which plots mean times with automatic display of the state color legend and allows plotting by group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading the mvad data set and creating a sequence object
data(mvad)
mvad.labels &lt;- c("employment", "further education", "higher education",
                    "joblessness", "school", "training")
mvad.scodes &lt;- c("EM","FE","HE","JL","SC","TR")
mvad.seq &lt;- seqdef(mvad, 15:86, states=mvad.scodes, labels=mvad.labels)

## Computing the mean times
mvad.meant &lt;- seqmeant(mvad.seq)

## Plotting
plot(mvad.meant, main="Mean durations in each state of the alphabet")

## Changing the y axis limits
plot(mvad.meant, main="Mean durations in each state of the alphabet",
 ylim=c(0,40))

## Displaying error bars
mvad.meant.e &lt;- seqmeant(mvad.seq, serr=TRUE)
plot(mvad.meant.e, main="Mean durations in each state of the alphabet",
 ylim=c(0,40))

</code></pre>

<hr>
<h2 id='plot.stslist.modst'>Plot method for modal state sequences</h2><span id='topic+plot.stslist.modst'></span>

<h3>Description</h3>

<p>Plot method for output produced by the seqmodst function, i.e objects of class stslist.modst.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stslist.modst'
plot(x, cpal = NULL, ylab = NULL, yaxis = TRUE,
  xaxis = TRUE, xtlab = NULL, xtstep = NULL, tick.last = NULL,
  info = TRUE, cex.axis = par("cex.axis"), las = 1, cex.plot, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stslist.modst_+3A_x">x</code></td>
<td>
<p>an object of class <code>stslist.modst</code> as produced by the <code>seqmodst</code> function.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_cpal">cpal</code></td>
<td>
<p>alternative color palette to use for the states. If user specified, a vector of colors with number of elements equal to the number of states in the alphabet. By default, the 'cpal' attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_ylab">ylab</code></td>
<td>
<p>an optional label for the y axis. If set to NA, no label is drawn.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_yaxis">yaxis</code></td>
<td>
<p>if TRUE (default) the y axis is plotted.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_xaxis">xaxis</code></td>
<td>
<p>if TRUE (default) the x axis is plotted.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_xtlab">xtlab</code></td>
<td>
<p>optional labels for the x axis ticks. If unspecified, the <code>names</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_xtstep">xtstep</code></td>
<td>
<p>optional interval at which the tick-marks and labels of the x-axis are displayed. For example, with xtstep=3 a tick-mark is drawn at position 1, 4, 7, etc... The display of the corresponding labels depends on the available space and is dealt with automatically. If unspecified, the <code>xtstep</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_tick.last">tick.last</code></td>
<td>
<p>Logical. Should a tick mark be enforced at the last position on the x-axis? If unspecified, the <code>tick.last</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_info">info</code></td>
<td>
<p>Logical: should info about frequency of occurrence of the sequence of modal states be displayed?</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Axis annotation magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_las">las</code></td>
<td>
<p>Integer in {0, 1, 2, 3}. Orientation of tick labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_cex.plot">cex.plot</code></td>
<td>
<p>Deprecated. Use <code>cex.axis</code> instead.</p>
</td></tr>
<tr><td><code id="plot.stslist.modst_+3A_...">...</code></td>
<td>
<p>further graphical and <code>barplot</code> parameters. See <code><a href="graphics.html#topic+barplot">barplot</a></code> and <code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for output of <code><a href="#topic+seqmodst">seqmodst</a></code>, i.e., for objects of class <em>stslist.modst</em>. It plots the sequence of modal states with bar height proportional to the frequency of the modal state at each successive position.
</p>
<p>The method is invoked by <code><a href="#topic+seqmsplot">seqmsplot</a></code> (<code>seqplot</code> with <code>type="ms"</code>), which in addition to the modal states  automatically displays of the state color legend and allows plotting by group.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqmsplot">seqmsplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
"Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.seq &lt;- seqdef(biofam, 10:25, labels=biofam.lab)

## Modal state sequence
biofam.modst &lt;- seqmodst(biofam.seq)
plot(biofam.modst)
</code></pre>

<hr>
<h2 id='plot.stslist.rep'>Plot method for representative sequence sets</h2><span id='topic+plot.stslist.rep'></span>

<h3>Description</h3>

<p>This is the plot method for output produced by the <code><a href="#topic+seqrep">seqrep</a></code> function, i.e, for objects of class <em>stslist.rep</em>. It produces a
representative sequence plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stslist.rep'
plot(x, cpal = NULL, missing.color = NULL, pbarw = TRUE,
  dmax = NULL, stats = TRUE, ylab = NULL, xaxis = TRUE, xtlab = NULL,
  xtstep = NULL, tick.last = NULL, seq.alt = NULL, info = TRUE,
  cex.with.axis = 1, cex.plot, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stslist.rep_+3A_x">x</code></td>
<td>
<p>an object of class <em>stslist.rep</em> as produced by the <code><a href="#topic+seqrep">seqrep</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_cpal">cpal</code></td>
<td>
<p>alternative color palette to use for the states. If user specified, a vector of colors with number of
elements equal to the number of states in the alphabet. By default, the 'cpal' attribute of the <code>x</code> object is
used.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_missing.color">missing.color</code></td>
<td>
<p>alternative color for representing missing values inside the sequences. By default, this color is taken from the &quot;missing.color&quot; attribute of the sequence object being plotted.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_pbarw">pbarw</code></td>
<td>
<p>when <code>TRUE</code>, the bar heights are set proportional to the number of represented sequences.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_dmax">dmax</code></td>
<td>
<p>maximal theoretical distance, used for the x axis limits.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_stats">stats</code></td>
<td>
<p>if <code>TRUE</code> (default), mean discrepancy in each subset defined by all sequences attributed to one representative sequence and the mean distance to this representative sequence are displayed.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_ylab">ylab</code></td>
<td>
<p>an optional label for the y axis. If set to <code>NA</code>, no label is drawn.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_xaxis">xaxis</code></td>
<td>
<p>controls whether a x axis is plotted.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_xtlab">xtlab</code></td>
<td>
<p>optional labels for the x axis ticks labels. If unspecified, the column names of the object being plotted.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_xtstep">xtstep</code></td>
<td>
<p>optional interval at which the tick-marks and labels of the x-axis are displayed. For example, with <code>xtstep=3</code> a tick-mark is drawn at position 1, 4, 7, etc... The display of the corresponding labels depends on the available space and is dealt with automatically. If unspecified, the <code>xtstep</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_tick.last">tick.last</code></td>
<td>
<p>Logical. Should a tick mark be enforced at the last position on the x-axis? If unspecified, the <code>tick.last</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_seq.alt">seq.alt</code></td>
<td>
<p>an object of class <em>stslist</em> with same number of sequences than the sequence object for which the representatives <code>x</code> are provided. When not <code>NULL</code>, representatives are plotted in this alternative domain.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_info">info</code></td>
<td>
<p>Logical. Should coverage info be displayed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_cex.with.axis">cex.with.axis</code></td>
<td>

<p>Text and symbols magnification.
</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_cex.plot">cex.plot</code></td>
<td>
<p>Deprecated. Use <code>cex.with.axis</code> instead.</p>
</td></tr>
<tr><td><code id="plot.stslist.rep_+3A_...">...</code></td>
<td>
<p>further graphical parameters such as <code>las</code> to control orientation of tick labels (see <code><a href="graphics.html#topic+par">par</a></code>) and <code><a href="graphics.html#topic+barplot">barplot</a></code> arguments such as <code>border=NA</code> to remove the borders of the bars.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for the output produced by the <code><a href="#topic+seqrep">seqrep</a></code> function, i.e. objects of class <em>stslist.rep</em>.
It produces a plot where the representative sequences are displayed as horizontal bars with width proportional to the
number of sequences assigned to them. Sequences are plotted bottom-up according to their representativeness score. <br />
Above the plot, two parallel series of symbols associated to each representative are displayed horizontally on a scale ranging
from 0 to the maximal theoretical distance <code class="reqn">D_{max}</code>. The location of the symbol associated to the representative <code class="reqn">r_i</code>
indicates on axis <code class="reqn">A</code> the (pseudo) variance (<code class="reqn">V_i</code>) within the subset of sequences assigned to <code class="reqn">r_i</code> and on the axis <code class="reqn">B</code>
the mean distance <code class="reqn">MD_i</code> to the representative.
</p>
<p>This method is called by the generic <code><a href="#topic+seqplot">seqplot</a></code> function (if <code>type="r"</code>) that produces more sophisticated
plots with group splits and automatic display of the color legend. The <code><a href="#topic+seqrplot">seqrplot</a></code> function is a shortcut for
calling <code>seqplot</code> with <code>type="r"</code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading the mvad data set and creating a sequence object
data(mvad)
mvad.labels &lt;- c("employment", "further education", "higher education",
                    "joblessness", "school", "training")
mvad.scodes &lt;- c("EM","FE","HE","JL","SC","TR")

## First 36 months trajectories
mvad.seq &lt;- seqdef(mvad, 15:50, states=mvad.scodes, labels=mvad.labels)

## Computing Hamming distances
##
dist.ham &lt;- seqdist(mvad.seq, method="HAM")

## Extracting a representative set using the sequence frequency
## as a representativeness criterion
mvad.rep &lt;- seqrep(mvad.seq, diss=dist.ham)

## Plotting the representative set
plot(mvad.rep)
</code></pre>

<hr>
<h2 id='plot.stslist.statd'>Plot method for objects produced by the seqstatd function</h2><span id='topic+plot.stslist.statd'></span>

<h3>Description</h3>

<p>This is the plot method for output produced by the <code><a href="#topic+seqstatd">seqstatd</a></code> function, i.e for objects of class <em>stslist.statd</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stslist.statd'
plot(x, type = "d", cpal = NULL,
  ylab = NULL, yaxis = TRUE,
  xaxis = TRUE, xtlab = NULL, xtstep = NULL,
  tick.last = NULL,
  cex.axis = par("cex.axis"),
  space = 0, xlab = NULL, lwd=3.5, col="blue",
  ylim=NULL, cex.plot, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stslist.statd_+3A_x">x</code></td>
<td>
<p>an object of class <code>stslist.statd</code> as produced by the <code><a href="#topic+seqstatd">seqstatd</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_type">type</code></td>
<td>
<p>if <code>"d"</code> (default), a state distribution plot is produced. If <code>"Ht"</code> an entropy index plot is produced.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_cpal">cpal</code></td>
<td>
<p>alternative color palette to be used for the states. If user specified, a vector of colors with number of elements equal to the number of states in the alphabet. By default, the 'cpal' attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_ylab">ylab</code></td>
<td>
<p>an optional label for the y axis. If set to NA, no label is drawn.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_yaxis">yaxis</code></td>
<td>
<p>Logical. Should the y axis be displayed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_xaxis">xaxis</code></td>
<td>
<p>Logical. Should the x-axis be displayed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_xtlab">xtlab</code></td>
<td>
<p>optional labels for the ticks of the x-axis. If unspecified, the <code>names</code> attribute of the input <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_xtstep">xtstep</code></td>
<td>
<p>optional interval at which the tick-marks and labels of the x-axis are displayed. For example, with xtstep=3 a tick-mark is drawn at position 1, 4, 7, etc... The display of the corresponding labels depends on the available space and is dealt with automatically. If unspecified, the <code>xtstep</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_tick.last">tick.last</code></td>
<td>
<p>Logical. Should a tick mark be enforced at the last position on the x-axis? If unspecified, the <code>tick.last</code> attribute of the <code>x</code> object is used.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Axis annotation magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_space">space</code></td>
<td>
<p>the space between the stacked bars. Default is 0, i.e. no space.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_xlab">xlab</code></td>
<td>
<p>Optional title for the x axis. See <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_lwd">lwd</code></td>
<td>
<p>Width of entropy line. Default is 3.5. Ignored when <code>type="d"</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_col">col</code></td>
<td>
<p>Color of entropy line. Default is <code>"blue"</code>. Ignored when <code>type="d"</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_ylim">ylim</code></td>
<td>
<p>Real vector of length two. Limits of the y-axis for the entropy line. Default is <code>NULL</code>. Ignored when <code>type="d"</code>.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_cex.plot">cex.plot</code></td>
<td>
<p>Deprecated. Use <code>cex.axis</code> instead.</p>
</td></tr>
<tr><td><code id="plot.stslist.statd_+3A_...">...</code></td>
<td>
<p>further graphical parameters such as <code>las</code> to control orientation of tick labels (see <code><a href="graphics.html#topic+par">par</a></code>) and <code><a href="graphics.html#topic+barplot">barplot</a></code> arguments such as <code>border=NA</code> to remove the borders of the bars.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for output produced by the <code><a href="#topic+seqstatd">seqstatd</a></code> function, i.e. for objects of class <em>stslist.statd</em>. If <code>type="d"</code> it produces a state distribution plot presenting the sequence of the transversal state frequencies at each successive (time) position, as computed by the <code><a href="#topic+seqstatd">seqstatd</a></code> function. With <code>type="Ht"</code>, the series of entropies of the transversal state distributions is plotted.
With <code>type="dH"</code> the entropy line is overlayed on the state distribution plot.
</p>
<p>When <code>ylim=NULL</code>, <code>ylim</code> is set as <code>c(0,1)</code> when entropy is normalized and otherwise as <code>c(0,1.1*max(entropy))</code>.
</p>
<p>This plot method is called by the generic <code><a href="#topic+seqplot">seqplot</a></code> function (if <code>type="d"</code>, <code>type="Ht"</code>, or <code>"dH"</code>) that produces more sophisticated plots, allowing grouping and automatic display of the state color legend. The <code>seqdplot</code>, <code>seqHtplot</code>, and <code>seqdHplot</code> functions are aliases for calling <code>seqplot</code> with <code>type="d"</code>, <code>type="Ht"</code>, and <code>dH</code> respectively.
</p>


<h3>Value</h3>

<p>The plotted values, i.e. for <code>type="d"</code> the cross-sectional distributions, for <code>type="Ht"</code> the cross-sectional entropies, and for <code>type="dH"</code> the <code>x</code> <code>stslist.statd</code> object.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
"Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.seq &lt;- seqdef(biofam, 10:25, labels=biofam.lab)

## State distribution
biofam.statd &lt;- seqstatd(biofam.seq)

## State distribution plot (default type="d" option)
plot(biofam.statd)

## Entropy index plot
plot(biofam.statd, type="Ht")

## State distribution and entropy line
plot(biofam.statd, type="dH")

</code></pre>

<hr>
<h2 id='plot.subseqelist'>Plot frequencies of subsequences</h2><span id='topic+plot.subseqelist'></span>

<h3>Description</h3>

<p>Plot frequencies of subsequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'subseqelist'
plot(x, freq=NULL,cex=1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.subseqelist_+3A_x">x</code></td>
<td>
<p>The subsequences to plot (a <code>subseqelist</code> object</p>
</td></tr>
<tr><td><code id="plot.subseqelist_+3A_freq">freq</code></td>
<td>
<p>The frequencies to plot, support if <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot.subseqelist_+3A_cex">cex</code></td>
<td>
<p>Plotting text and symbols magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>

<tr><td><code id="plot.subseqelist_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+barplot">barplot</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqefsub">seqefsub</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## loading data
data(actcal.tse)

## creating sequences
actcal.eseq &lt;- seqecreate(actcal.tse)

## Looking for frequent subsequences
fsubseq &lt;- seqefsub(actcal.eseq,pmin.support=0.01)

## Frequence of first ten subsequences
plot(fsubseq[1:10], cex=2)
plot(fsubseq[1:10])

</code></pre>

<hr>
<h2 id='plot.subseqelistchisq'>Plot discriminant subsequences</h2><span id='topic+plot.subseqelistchisq'></span>

<h3>Description</h3>

<p>Plot the result of <code><a href="#topic+seqecmpgroup">seqecmpgroup</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'subseqelistchisq'
plot(x, ylim = "uniform", rows = NA, cols = NA,
  resid.levels = c(0.05,0.01),
  cpal = brewer.pal(1 + 2 * length(resid.levels), "RdBu"), vlegend = NULL,
  cex.legend = 1, ptype = "freq", legend.title = NULL, 
  with.legend = TRUE, residlevels, legendcol, legend.cex, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.subseqelistchisq_+3A_x">x</code></td>
<td>
<p>The subsequences to plot (a <code>subseqelist</code> object).</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_ylim">ylim</code></td>
<td>
<p>if <code>"uniform"</code> all axes have same limits.</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_rows">rows</code></td>
<td>
<p>Number of graphic rows</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_cols">cols</code></td>
<td>
<p>Number of graphic columns</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_resid.levels">resid.levels</code></td>
<td>
<p>Significance levels used to colorize the Pearson residual</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_cpal">cpal</code></td>
<td>
<p>Color palette used to color the results</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_vlegend">vlegend</code></td>
<td>
<p>When <code>TRUE</code> the legend is printed vertically, when <code>FALSE</code> it is printed horizontally. If <code>NULL</code> (default) the best position will be chosen.</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Scale parameters for text legend.</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_ptype">ptype</code></td>
<td>
<p>If set to <code>"resid"</code>, Pearson residuals are plotted instead of frequencies</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_legend.title">legend.title</code></td>
<td>
<p>Legend title.</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_with.legend">with.legend</code></td>
<td>
<p>Logical. Should legend be displayed?</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_residlevels">residlevels</code></td>
<td>
<p>Deprecated. Use <code>resid.levels</code> instead.</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_legendcol">legendcol</code></td>
<td>
<p>Deprecated. Use <code>vlegend</code> instead.</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_legend.cex">legend.cex</code></td>
<td>
<p>Deprecated. Use <code>cex.legend</code> instead.</p>
</td></tr>
<tr><td><code id="plot.subseqelistchisq_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="graphics.html#topic+barplot">barplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqecmpgroup">seqecmpgroup</a></code></p>

<hr>
<h2 id='print.stslist'>Print method for state sequence objects</h2><span id='topic+print.stslist'></span>

<h3>Description</h3>

<p>This is the print method for state sequence objects of class <code>stslist</code> created by the <code>seqdef</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stslist'
print(x, format='STS', extended=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.stslist_+3A_x">x</code></td>
<td>
<p>A state sequence (<code>stslist</code>) object.</p>
</td></tr>
<tr><td><code id="print.stslist_+3A_format">format</code></td>
<td>
<p>String: print format. One of <code>"STS"</code> (default) or <code>"SPS"</code>.</p>
</td></tr>
<tr><td><code id="print.stslist_+3A_extended">extended</code></td>
<td>
<p>Logical: should the output be printed in extended matrix form?</p>
</td></tr>
<tr><td><code id="print.stslist_+3A_...">...</code></td>
<td>
<p>Additional print arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdef">seqdef</a></code>, <code><a href="#topic+plot.stslist">plot.stslist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam &lt;- biofam[500:600,] ## using a subsample only
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
    "Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.shortlab &lt;- c("P","L","M","LM","C","LC","LMC","D")
biofam.seq &lt;- seqdef(biofam, 10:25, states=biofam.shortlab, 
  labels=biofam.lab)

## Print of first 5 sequences
print(biofam.seq[1:5,])
print(biofam.seq[1:5,], extended=TRUE)
print(biofam.seq[1:5,], format="SPS")
print(biofam.seq[1:5,], format="SPS", SPS.out = list(xfix = "", sdsep = "/"))

</code></pre>

<hr>
<h2 id='read.tda.mdist'>Read a distance matrix produced by TDA.</h2><span id='topic+read.tda.mdist'></span>

<h3>Description</h3>

<p>This function reads a distance matrix produced by TDA into an R object. When computing OM distances in TDA, the output is a 'half' matrix stored in a text file as a vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.tda.mdist(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.tda.mdist_+3A_file">file</code></td>
<td>
<p>the path to the file containing TDA output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a R matrix containing the distances.</p>

<hr>
<h2 id='seqalign'>Computation details about a pairwise alignment</h2><span id='topic+seqalign'></span><span id='topic+plot.seqalign'></span><span id='topic+print.seqalign'></span>

<h3>Description</h3>

<p>The function provides details about a pairwise alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqalign(seqdata, indices, indel=1, sm, with.missing = FALSE)

## S3 method for class 'seqalign'
plot(x, cpal = NULL, missing.color = NULL, ylab = NULL,
  yaxis = TRUE, xaxis = TRUE, ytlab = NULL, ylas = 0, xtlab = NULL,
  cex.axis = 1, cex.plot, ...)

## S3 method for class 'seqalign'
print(x, digits=3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqalign_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object defined with the <code><a href="#topic+seqdef">seqdef</a></code> function.
</p>
</td></tr>
<tr><td><code id="seqalign_+3A_indices">indices</code></td>
<td>

<p>a vector of length 2 giving the indexes of the two sequences
</p>
</td></tr>
<tr><td><code id="seqalign_+3A_indel">indel</code></td>
<td>

<p>indel cost (see <code><a href="#topic+seqdist">seqdist</a></code>)
</p>
</td></tr>
<tr><td><code id="seqalign_+3A_sm">sm</code></td>
<td>

<p>matrix of substitution costs or a method for computing the costs (see <code><a href="#topic+seqdist">seqdist</a></code>)
</p>
</td></tr>
<tr><td><code id="seqalign_+3A_with.missing">with.missing</code></td>
<td>

<p>logical: Should the missing state be considered as an element of the alphabet?
</p>
</td></tr>
<tr><td><code id="seqalign_+3A_x">x</code></td>
<td>

<p>an object of class <code>seqalign</code></p>
</td></tr>
<tr><td><code id="seqalign_+3A_cpal">cpal</code></td>
<td>
<p>color palette</p>
</td></tr>
<tr><td><code id="seqalign_+3A_missing.color">missing.color</code></td>
<td>
<p>color for missing elements</p>
</td></tr>
<tr><td><code id="seqalign_+3A_ylab">ylab</code></td>
<td>
<p>y label</p>
</td></tr>
<tr><td><code id="seqalign_+3A_yaxis">yaxis</code></td>
<td>
<p>yaxis</p>
</td></tr>
<tr><td><code id="seqalign_+3A_xaxis">xaxis</code></td>
<td>
<p>xaxis</p>
</td></tr>
<tr><td><code id="seqalign_+3A_ytlab">ytlab</code></td>
<td>
<p>ytlab</p>
</td></tr>
<tr><td><code id="seqalign_+3A_ylas">ylas</code></td>
<td>
<p>ylas</p>
</td></tr>
<tr><td><code id="seqalign_+3A_xtlab">xtlab</code></td>
<td>
<p>xtlab</p>
</td></tr>
<tr><td><code id="seqalign_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Axis annotation magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="seqalign_+3A_digits">digits</code></td>
<td>
<p>number of digits for printed output</p>
</td></tr>
<tr><td><code id="seqalign_+3A_cex.plot">cex.plot</code></td>
<td>
<p>Deprecated. Use <code>cex.axis</code> instead.</p>
</td></tr>
<tr><td><code id="seqalign_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are print and plot methods for <code>seqalign</code> objects.
</p>


<h3>Value</h3>

<p>Object of class <code>seqalign</code></p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho (plot.seqalign) and Matthias Studer (seqalign) (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdist">seqdist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)
biofam.seq &lt;- seqdef(biofam, 10:25)
costs &lt;- seqsubm(biofam.seq, method="TRATE")
sa &lt;- seqalign(biofam.seq, 1:2, indel=1, sm=costs)
print(sa)
plot(sa)
sa &lt;- seqalign(biofam.seq, c(1,5), indel=0.5, sm=costs)
print(sa)
plot(sa)
</code></pre>

<hr>
<h2 id='seqcomp'>Compare two state sequences</h2><span id='topic+seqcomp'></span>

<h3>Description</h3>

<p>Check whether two state sequences are identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqcomp(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqcomp_+3A_x">x</code></td>
<td>
<p>a state sequence object containing a single sequence (typically the row of a main sequence
object, see <code><a href="#topic+seqdef">seqdef</a></code>)</p>
</td></tr>
<tr><td><code id="seqcomp_+3A_y">y</code></td>
<td>
<p>a state sequence object containing a single sequence (typically the row of a main sequence
object, see <code><a href="#topic+seqdef">seqdef</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if sequences are identical, <code>FALSE</code> otherwise</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqfind">seqfind</a>, <a href="#topic+seqfpos">seqfpos</a>, <a href="#topic+seqpm">seqpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
mvad.shortlab &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad.seq &lt;- seqdef(mvad, states=mvad.shortlab, 15:86)

## Comparing sequences 1 and 2 in mvad.seq
seqcomp(mvad.seq[1,],mvad.seq[2,])

## Comparing sequences 176 and 211 in mvad.seq
seqcomp(mvad.seq[176,],mvad.seq[211,])
</code></pre>

<hr>
<h2 id='seqconc'>Concatenate vectors of states or events into a character string</h2><span id='topic+seqconc'></span>

<h3>Description</h3>

<p>Concatenate vectors of states or events into a character string. In the string, each state is separated by 'sep'. The void elements in the input sequences are eliminated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqconc(data, var=NULL, sep="-", vname="Sequence", void=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqconc_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing sequence data (tibble will be converted with <code>as.data.frame</code>).</p>
</td></tr>
<tr><td><code id="seqconc_+3A_var">var</code></td>
<td>
<p>List of the columns containing the sequences. Default is <code>NULL</code> in which case all  columns are retained. Whether the sequences are in the compressed (character strings) or extended format is automatically detected by counting the number of columns.</p>
</td></tr>
<tr><td><code id="seqconc_+3A_sep">sep</code></td>
<td>
<p>Character used as separator. By default, &quot;<code>-</code>&quot;.</p>
</td></tr>
<tr><td><code id="seqconc_+3A_vname">vname</code></td>
<td>
<p>an optional name for the variable containing the sequences. By default, <code>"Sequence"</code>.</p>
</td></tr>
<tr><td><code id="seqconc_+3A_void">void</code></td>
<td>
<p>the code used for void elements appearing in the sequences (see <cite>Gabadinho et al. (2009)</cite> for more details on missing values and void elements in sequences). Default is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character strings, one for each row in the input data.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2009). Mining Sequence Data in <code>R</code> with the <code>TraMineR</code> package: A user's guide. <em>Department of Econometrics and Laboratory of Demography, University of Geneva</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdecomp">seqdecomp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
actcal.string &lt;- seqconc(actcal,13:24)
head(actcal.string)
</code></pre>

<hr>
<h2 id='seqcost'>Generate substitution and indel costs</h2><span id='topic+seqcost'></span><span id='topic+seqsubm'></span>

<h3>Description</h3>

<p>The function <code>seqcost</code> proposes different ways to generate substitution costs
(supposed to represent state dissimilarities) and possibly indel costs. Proposed methods are:
<code>"CONSTANT"</code> (same cost for all substitutions), <code>"TRATE"</code> (derived from the observed transition rates), <code>"FUTURE"</code> (Chi-squared distance between conditional state distributions <code>lag</code> positions ahead), <code>"FEATURES"</code> (Gower distance between state features), <code>"INDELS"</code>, <code>"INDELSLOG"</code> (based on estimated indel costs).
The substitution-cost matrix is intended to serve as <code>sm</code> argument in the <code><a href="#topic+seqdist">seqdist</a></code> function that computes distances between sequences. <code>seqsubm</code> is an alias that returns only the substitution cost matrix, i.e., no indel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqcost(seqdata, method, cval = NULL, with.missing = FALSE, miss.cost = NULL,
  time.varying = FALSE, weighted = TRUE, transition = "both", lag = 1,
  miss.cost.fixed = NULL, state.features = NULL, feature.weights = NULL,
  feature.type = list(), proximities = FALSE)

seqsubm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqcost_+3A_seqdata">seqdata</code></td>
<td>
<p>A sequence object as returned by the <a href="#topic+seqdef">seqdef</a> function.</p>
</td></tr>
<tr><td><code id="seqcost_+3A_method">method</code></td>
<td>
<p>String. How to generate the costs. One of <code>"CONSTANT"</code> (same cost for all substitutions), <code>"TRATE"</code> (derived from the observed transition rates), <code>"FUTURE"</code> (Chi-squared distance between conditional state distributions <code>lag</code> positions ahead), <code>"FEATURES"</code> (Gower distance between state features), <code>"INDELS"</code>, <code>"INDELSLOG"</code> (based on estimated indel costs).</p>
</td></tr>
<tr><td><code id="seqcost_+3A_cval">cval</code></td>
<td>
<p>Scalar. For method <code>"CONSTANT"</code>, the single substitution cost. <br />
For method <code>"TRATE"</code>, a base value from which transition probabilities are subtracted.<br />
If <code>NULL</code>, <code>cval=2</code> is used, unless <code>transition</code>
is <code>"both"</code> and <code>time.varying</code> is <code>TRUE</code>, in which case <code>cval=4</code>.</p>
</td></tr>
<tr><td><code id="seqcost_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. Should an additional entry be added in the matrix for the missing states?
If <code>TRUE</code>, the &lsquo;missing&rsquo; state is also added to the alphabet. Set as <code>TRUE</code> if you want to use the costs for distances between sequences containing non deleted (non void) missing values. Forced as <code>FALSE</code> when there are no non-void missing values in <code>seqdata</code>. See <cite>Gabadinho et al. (2010)</cite> for more details on the options for handling missing values when creating the state sequence object with <code><a href="#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="seqcost_+3A_miss.cost">miss.cost</code></td>
<td>
<p>Scalar or vector. Cost for substituting the missing state. Default is <code>cval</code>.</p>
</td></tr>
<tr><td><code id="seqcost_+3A_miss.cost.fixed">miss.cost.fixed</code></td>
<td>
<p>Logical. Should the substitution cost for missing be set as the <code>miss.cost</code> value. When <code>NULL</code> (default) it will be set as <code>FALSE</code> when <code>method = "INDELS"</code> or <code>"INDELSLOG"</code>, and <code>TRUE</code> otherwise.</p>
</td></tr>
<tr><td><code id="seqcost_+3A_time.varying">time.varying</code></td>
<td>
<p>Logical. If <code>TRUE</code> return an <code><a href="base.html#topic+array">array</a></code> with a distinct matrix for each time unit. Time is the third dimension (subscript) of the returned array. Time varying works only with <code>method='CONSTANT'</code>, <code>'TRATE'</code>, <code>'INDELS'</code>, and <code>'INDELSLOG'</code>.</p>
</td></tr>
<tr><td><code id="seqcost_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Should weights in <code>seqdata</code> be used when applicable?</p>
</td></tr>
<tr><td><code id="seqcost_+3A_transition">transition</code></td>
<td>
<p>String. Only used if <code>method="TRATE"</code> and <code>time.varying=TRUE</code>. On which transition are rates based? Should be one of <code>"previous"</code> (from previous state), <code>"next"</code> (to next state) or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="seqcost_+3A_lag">lag</code></td>
<td>
<p>Integer. For methods <code>TRATE</code> and <code>FUTURE</code> only. Time ahead to which transition rates are computed
(default is <code>lag=1</code>).</p>
</td></tr>
<tr><td><code id="seqcost_+3A_state.features">state.features</code></td>
<td>
<p>Data frame with features values for each state.</p>
</td></tr>
<tr><td><code id="seqcost_+3A_feature.weights">feature.weights</code></td>
<td>
<p>Vector of feature weights with a weight per column of <code>state.features</code>.</p>
</td></tr>
<tr><td><code id="seqcost_+3A_feature.type">feature.type</code></td>
<td>
<p>List of feature types. See <code><a href="cluster.html#topic+daisy">daisy</a></code> for details.</p>
</td></tr>
<tr><td><code id="seqcost_+3A_proximities">proximities</code></td>
<td>
<p>Logical: should state proximities be returned instead of substitution costs?</p>
</td></tr>
<tr><td><code id="seqcost_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>seqcost</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The substitution-cost matrix has dimension <code class="reqn">ns*ns</code>, where
<code class="reqn">ns</code> is the number of states in the <a href="#topic+alphabet">alphabet</a> of the
sequence object. The element <code class="reqn">(i,j)</code> of the matrix is the cost of
substituting state <code class="reqn">i</code> with state <code class="reqn">j</code>. It represents the dissimilarity between the states <code class="reqn">i</code> and <code class="reqn">j</code>. The indel cost of the cost of inserting or deleting a state.
</p>
<p>With method <code>CONSTANT</code>, the substitution costs are all set equal to the <code>cval</code> value, the default value being 2.
</p>
<p>With method <code>TRATE</code>
(transition rates), the transition probabilities between all pairs of
states is first computed (using the <a href="#topic+seqtrate">seqtrate</a> function). Then, the
substitution cost between states <code class="reqn">i</code> and <code class="reqn">j</code> is obtained with
the formula
</p>
<p style="text-align: center;"><code class="reqn">SC(i,j) = cval - P(i|j) -P(j|i)</code>
</p>

<p>where <code class="reqn">P(i|j)</code> is the probability of transition from state <code class="reqn">j</code> to
<code class="reqn">i</code> <code>lag</code> positions ahead. Default <code>cval</code> value is 2. When <code>time.varying=TRUE</code> and <code>transition="both"</code>, the substitution cost at position <code class="reqn">t</code> is set as
</p>
<p style="text-align: center;"><code class="reqn">SC(i,j,t) = cval - P(i|j,t-1) -P(j|i,t-1) - P(i|j,t) - P(j|i,t)</code>
</p>

<p>where <code class="reqn">P(i|j,t-1)</code> is the probability to transit from state <code class="reqn">j</code> at <code class="reqn">t-1</code> to <code class="reqn">i</code> at <code class="reqn">t</code>. Here, the default <code>cval</code> value is 4.
</p>
<p>With method <code>FUTURE</code>, the cost between <code class="reqn">i</code> and <code class="reqn">j</code> is the Chi-squared distance between the vector (<code class="reqn">d(alphabet | i)</code>) of probabilities of transition from states <code class="reqn">i</code> and
<code class="reqn">j</code> to all the states in the alphabet <code>lag</code> positions ahead:
</p>
<p style="text-align: center;"><code class="reqn">SC(i,j) = ChiDist(d(alphabet | i), d(alphabet | j))</code>
</p>

<p>With method <code>FEATURES</code>, each state is characterized by the variables <code>state.features</code>, and the cost between <code class="reqn">i</code> and <code class="reqn">j</code> is computed as the Gower distance between their vectors of <code>state.features</code> values.
</p>
<p>With methods <code>INDELS</code> and <code>INDELSLOG</code>, values of indels are first derived from the state relative frequencies <code class="reqn">f_i</code>. For <code>INDELS</code>, <code class="reqn">indel_i = 1/f_i</code> is used, and for <code>INDELSLOG</code>, <code class="reqn">indel_i = \log[2/(1 + f_i)]</code>.
Substitution costs are then set as <code class="reqn">SC(i,j) = indel_i + indel_j</code>.
</p>
<p>For all methods but <code>INDELS</code> and <code>INDELSLOG</code>, the indel is set as <code class="reqn">\max(sm)/2</code> when <code>time.varying=FALSE</code> and as <code class="reqn">1</code> otherwise.
</p>


<h3>Value</h3>

<p>For <code>seqcost</code>, a list of two elements, <code>indel</code> and <code>sm</code> or <code>prox</code>:
</p>
<table>
<tr><td><code>indel</code></td>
<td>

<p>The indel cost. Either a scalar or a vector of size <code class="reqn">ns</code>. When <code>time.varying=TRUE</code> and <code>method</code> is one of <code>"INDELS"</code> or <code>"INDELSLOG"</code>, a matrix with indels per time point in columns.
</p>
</td></tr>
<tr><td><code>sm</code></td>
<td>

<p>The substitution-cost matrix (or array) when <code>proximities = FALSE</code> (default).
</p>
</td></tr>
<tr><td><code>prox</code></td>
<td>

<p>The state proximity matrix when <code>proximities = TRUE</code>.
</p>
</td></tr>
</table>
<p><code>sm</code> and <code>prox</code> are, when <code>time.varying = FALSE</code>, a matrix of size <code class="reqn">ns * ns</code>, where <code class="reqn">ns</code>
is the number of states in the alphabet of the sequence object. When <code>time.varying = TRUE</code>, they are a three dimensional array of size <code class="reqn">ns * ns * L</code>, where <code class="reqn">L</code> is the maximum sequence length.
</p>
<p>For <code>seqsubm</code>, only one element, the matrix (or array) <code>sm</code>.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard and Matthias Studer (and Alexis Gabadinho for first version of <code>seqsubm</code>)</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>
<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2010). Mining Sequence Data in
<code>R</code> with the <code>TraMineR</code> package: A user's guide. Department of Econometrics and
Laboratory of Demography, University of Geneva.
</p>
<p>Studer, M. &amp; Ritschard, G. (2016), &quot;What matters in differences between life trajectories: A comparative review of sequence dissimilarity measures&quot;, <em>Journal of the Royal Statistical Society, Series A</em>. <b>179</b>(2), 481-511. <a href="https://doi.org/10.1111/rssa.12125">doi:10.1111/rssa.12125</a>
</p>
<p>Studer, M. and G. Ritschard (2014). &quot;A Comparative Review of Sequence Dissimilarity Measures&quot;. <em>LIVES Working Papers</em>, <b>33</b>. NCCR LIVES, Switzerland, 2014. <a href="https://doi.org/10.12682/lives.2296-1658.2014.33">doi:10.12682/lives.2296-1658.2014.33</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqtrate">seqtrate</a></code>, <code><a href="#topic+seqdef">seqdef</a></code>, <code><a href="#topic+seqdist">seqdist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with columns 10 to 25
## of a subset of the 'biofam' example data set.
data(biofam)
biofam.seq &lt;- seqdef(biofam[501:600,10:25])

## Indel and substitution costs based on log of inverse state frequencies
lifcost &lt;- seqcost(biofam.seq, method="INDELSLOG")
## Here lifcost$indel is a vector
biofam.om &lt;- seqdist(biofam.seq, method="OM", indel=lifcost$indel, sm=lifcost$sm)

## Optimal matching using transition rates based substitution-cost matrix
## and the associated indel cost
## Here trcost$indel is a scalar
trcost &lt;- seqcost(biofam.seq, method="TRATE")
biofam.om &lt;- seqdist(biofam.seq, method="OM", indel=trcost$indel, sm=trcost$sm)

## Using costs based on FUTURE with a forward lag of 4
fucost &lt;- seqcost(biofam.seq, method="FUTURE", lag=4)
biofam.om &lt;- seqdist(biofam.seq, method="OM", indel=fucost$indel, sm=fucost$sm)

## Optimal matching using a unique substitution cost of 2
## and an insertion/deletion cost of 3
ccost &lt;- seqsubm(biofam.seq, method="CONSTANT", cval=2)
biofam.om.c2 &lt;- seqdist(biofam.seq, method="OM",indel=3, sm=ccost)

## Displaying the distance matrix for the first 10 sequences
biofam.om.c2[1:10,1:10]

## =================================
## Example with weights and missings
## =================================
data(ex1)
ex1.seq &lt;- seqdef(ex1[,1:13], weights=ex1$weights)

## Unweighted
subm &lt;- seqcost(ex1.seq, method="INDELSLOG", with.missing=TRUE, weighted=FALSE)
ex1.om &lt;- seqdist(ex1.seq, method="OM", indel=subm$indel, sm=subm$sm, with.missing=TRUE)

## Weighted
subm.w &lt;- seqcost(ex1.seq, method="INDELSLOG", with.missing=TRUE, weighted=TRUE)
ex1.omw &lt;- seqdist(ex1.seq, method="OM", indel=subm.w$indel, sm=subm.w$sm, with.missing=TRUE)

ex1.om == ex1.omw
</code></pre>

<hr>
<h2 id='seqdecomp'>Convert a character string into a vector of states or events</h2><span id='topic+seqdecomp'></span>

<h3>Description</h3>

<p>States can be represented by any substring that does not include the <code>sep</code> value. An empty separator <code>sep = ""</code> can only be used when each state is coded with a single character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqdecomp(data, var=NULL, sep='-', miss="NA", vnames=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqdecomp_+3A_data">data</code></td>
<td>
<p>a dataframe, matrix, or character string vector containing sequence data (tibble will be converted with <code>as.data.frame</code>).</p>
</td></tr>
<tr><td><code id="seqdecomp_+3A_var">var</code></td>
<td>
<p>the list of columns containing the sequences. Default is <code>NULL</code>, ie all the columns. Whether the sequences are in the compressed (character strings) or extended format is automatically detected by counting the number of columns.</p>
</td></tr>
<tr><td><code id="seqdecomp_+3A_sep">sep</code></td>
<td>
<p>the between states/events separator used in the input data set. Default is '<code>-</code>'.</p>
</td></tr>
<tr><td><code id="seqdecomp_+3A_miss">miss</code></td>
<td>
<p>the symbol for missing values (if any) used in the input data set. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="seqdecomp_+3A_vnames">vnames</code></td>
<td>
<p>optional names for the column/variables of the output data set. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+seqconc">seqconc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1 sequence of length 4
seqdecomp("A-BB-C-DD")

# 2 sequences of length 6
seqdecomp(c("ABBCDD","BBCCAD"),sep="")
</code></pre>

<hr>
<h2 id='seqdef'>Create a state sequence object</h2><span id='topic+seqdef'></span><span id='topic+rbind.stslist'></span><span id='topic+summary.stslist'></span>

<h3>Description</h3>

<p>Create a state sequence object with attributes such as alphabet, color palette and state labels. Most TraMineR functions for state sequences require such a state sequence object as input argument. There are specific methods for plotting,  summarizing and printing state sequence objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqdef(data, var=NULL, informat="STS", stsep=NULL,
       alphabet=NULL, states=NULL, id=NULL, weights=NULL, start=1,
       left=NA, right="DEL", gaps=NA, missing=NA, void="%", nr="*",
       cnames=NULL, xtstep=1, tick.last=FALSE, cpal=NULL,
       missing.color="darkgrey", labels=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqdef_+3A_data">data</code></td>
<td>
<p>a data frame, matrix, or character string vector containing sequence data (tibble will be converted with <code>as.data.frame</code>).</p>
</td></tr>
<tr><td><code id="seqdef_+3A_var">var</code></td>
<td>
<p>the list of columns containing the sequences. Default is
<code>NULL</code>, i.e. all the columns. The function detects automatically
whether the sequences are in the compressed (successive states in a
character string) or extended format.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_informat">informat</code></td>
<td>
<p>format of the original data. Default is <code>"STS"</code>.
Other available formats are: <code>"SPS"</code> and <code>"SPELL"</code>, in which case the <code><a href="#topic+seqformat">seqformat</a></code> function is called to convert the data into the <code>"STS"</code> format (see TraMineR user's manual (<cite>Gabadinho et al., 2010</cite>) for a
description of these formats). A better solution is nonetheless to convert first your
data with <code><a href="#topic+seqformat">seqformat</a></code>, so as to have better control over the conversion process and visualize the intermediate <code>"STS"</code> formatted data.
</p>
</td></tr>
<tr><td><code id="seqdef_+3A_stsep">stsep</code></td>
<td>
<p>the character used as separator in the original
data if input format is successive states in a character string. If
<code>NULL</code> (default value), the <code><a href="#topic+seqfcheck">seqfcheck</a></code> function is
called for detecting automatically a separator among &quot;-&quot; and &quot;:&quot;.
Other separators must be specified explicitly.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_alphabet">alphabet</code></td>
<td>
<p>optional vector containing the alphabet (the list of all possible states). Use this option if some states in the alphabet don't appear in the data or if you want to reorder the states. The specified vector MUST contain AT LEAST all the states appearing in the data. It may possibly contain additional states not appearing in the data. If <code>NULL</code>, the alphabet is set to the distinct states appearing in the data as returned by the <code><a href="#topic+seqstatl">seqstatl</a></code> function. See details.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_states">states</code></td>
<td>
<p>an optional vector containing the short state labels. Must have a length equal to the size of the alphabet and the labels must be ordered conformably with alpha-numeric ordered values returned by the <code><a href="#topic+seqstatl">seqstatl</a></code> function, or, when <code>alphabet=</code> is set, with the thus newly defined alphabet.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_id">id</code></td>
<td>
<p>optional argument for setting the rownames of the sequence object. If <code>NULL</code> (default), the rownames are taken from the input data. If set to <code>"auto"</code>, sequences are numbered from 1 to the number of sequences. A vector of rownames of length equal to the number of sequences may be specified as well.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_weights">weights</code></td>
<td>
<p>optional numerical vector containing weights, which are accounted for by plotting and statistical functions when applicable.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_start">start</code></td>
<td>
<p>starting time. For instance, if sequences begin
at age 15, you can specify 15. At this stage, used only for labelling column names.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_left">left</code></td>
<td>
<p>the behavior for missing values appearing before the
first (leftmost) valid state in each sequence. When <code>NA</code> (default),
left missing values are treated as 'real' missing values and converted to the
internal missing value code defined by the <code>nr</code> option. Other
options are <code>"DEL"</code> to delete the positions containing missing values
or a state code (belonging to the alphabet or not) to replace the
missing values. See <cite>Gabadinho et
al. (2010)</cite> for more details on the options for handling missing
values when defining sequence objects.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_right">right</code></td>
<td>
<p>the behavior for missing values appearing after the
last (rightmost) valid state in each sequence. Same options as for
the <code>left</code> argument. Default is <code>'DEL'</code>.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_gaps">gaps</code></td>
<td>
<p>the behavior for missing values appearing inside the
sequences, i.e. after the first (leftmost) valid state and before the
last (rightmost) valid state of each sequence. Same options as for
the <code>left</code> argument. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_missing">missing</code></td>
<td>
<p>the code used for missing values in the input
data. Default is <code>NA</code>. When any other value, all cells containing this value are treated
as <code>NA</code>s and replaced by <code>nr</code> or <code>void</code> code according to the
<code>left</code>, <code>gaps</code>, and <code>right</code> options.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_void">void</code></td>
<td>
<p>the internal
code used by TraMineR for representing void elements in the
sequences. Default is <code>"%"</code>. Must be different from <code>left</code>, <code>gaps</code>, and <code>right</code>.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_nr">nr</code></td>
<td>
<p>the internal code used by TraMineR for representing real
missing elements in the sequences. Default is <code>"*"</code>.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_cnames">cnames</code></td>
<td>
<p>optional names for the columns composing the
sequence data. Those names will be used by default in the graphics as
axis labels. If <code>NULL</code> (default), names are taken from the
original column names in the data.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_xtstep">xtstep</code></td>
<td>
<p>step between displayed tick-marks and labels on the time x-axis of state sequence plots.
If not overridden by the user, plotting functions retrieve this parameter from the <code>xtstep</code> attribute of the sequence object. For example, with <code>xtstep=3</code> a tick-mark is displayed at positions 1, 4, 7, etc...  Default value is 1; i.e., a tick mark is displayed at each position. The display of the corresponding labels depends on the available space and is dealt with automatically.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_tick.last">tick.last</code></td>
<td>
<p>Logical. Should a tick mark be enforced at the last position on the time x-axis?</p>
</td></tr>
<tr><td><code id="seqdef_+3A_cpal">cpal</code></td>
<td>
<p>an optional color palette for representing the states
in the graphics. If <code>NULL</code> (default), a color palette is created
by means of the <code>brewer.pal</code> function of the <code>RColorBrewer</code>
package for number of states up to 12. When the number of states is less or equal than 8, the
<code>"Accent"</code> palette is used. If number of states is between 8 and
12, the <code>"Set3"</code> palette is used. When the number of states is greater than 12,
colors are set using <code>hcl.colors</code> with
the &quot;Set 3&quot; palette. To specify your own palette use e.g. the <code><a href="grDevices.html#topic+colors">colors</a></code>
function, or the RColorBrewer or colorspace packages.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_missing.color">missing.color</code></td>
<td>
<p>alternative color for representing missing
values inside the sequences. Defaults to <code>"darkgrey"</code>.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_labels">labels</code></td>
<td>
<p>optional state labels used for the color legend of
TraMineR's graphics. If <code>NULL</code> (default), the state names in the
alphabet are used as state labels as well.</p>
</td></tr>
<tr><td><code id="seqdef_+3A_...">...</code></td>
<td>
<p>options passed to the <code><a href="#topic+seqformat">seqformat</a></code> function
for handling input data that is not in STS format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applying subscripts to sequence objects (eg. <code>seq[,1:5]
or seq[1:10,]</code>) returns a state sequence object with some attributes
preserved (alphabet, missing) and some others (start, column names, weights)
adapted to the selected column or row subset. When the number of
columns selected is 1, the returned object is a factor. <br />
</p>
<p>For reordering the states use the <code>alphabet</code> argument. This may
for instance be useful to compare data from
different sources with different codings of similar states. Using
<code>alphabet</code> permits to order the states conformably in all
sequence objects. Otherwise, the default state order is the
alpha-numeric order returned by the <code><a href="#topic+seqstatl">seqstatl</a></code> function
which may differ when you have different original codings.
</p>


<h3>Value</h3>

<p>An object of class <code>stslist</code>.
</p>
<p>There are <code>print</code>, <code>plot</code>, <code>rbind</code>, <code>summary</code>, and subsetting <code>[,]</code> methods for such objects.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>
<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2010). Mining Sequence Data in <code>R</code> with the <code>TraMineR</code>
package: A user's guide. <em>Department of Econometrics and
Laboratory of Demography, University of Geneva</em>. </p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stslist">plot.stslist</a></code> plot method for state sequence objects,<br />
<code><a href="#topic+print.stslist">print.stslist</a></code> print method for state sequence objects,<br />
<code><a href="#topic+is.stslist">is.stslist</a></code> to test whether an object is a proper <code>stslist</code> object,<br />
<code><a href="#topic+seqplot">seqplot</a></code> for high level plots of state sequence objects,<br />
<code><a href="#topic+seqecreate">seqecreate</a></code> to create an event sequence object,<br />
<code><a href="#topic+seqformat">seqformat</a></code> for converting between various longitudinal data formats. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object with the columns 13 to 24
## in the 'actcal' example data set
data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24,
	labels=c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work"))

## Displaying the first 10 rows of the sequence object
actcal.seq[1:10,]

## Displaying the first 10 rows of the sequence object
## in SPS format
print(actcal.seq[1:10,], format="SPS")

## Plotting the first 10 sequences
plot(actcal.seq)

## Re-ordering the alphabet
actcal.seq &lt;- seqdef(actcal,13:24,alphabet=c("B","A","D","C"))
alphabet(actcal.seq)

## Adding a state not appearing in the data to the
## alphabet
actcal.seq &lt;- seqdef(actcal,13:24,alphabet=c("A","B","C","D","E"))
alphabet(actcal.seq)

## Adding a state not appearing in the data to the
## alphabet and changing the states labels
actcal.seq &lt;- seqdef(actcal,13:24,
  alphabet=c("A","B","C","D","E"),
  states=c("FT","PT","LT","NO","TR"))
alphabet(actcal.seq)

## rbind and summary
seq1 &lt;- actcal.seq[1:10,]
seq2 &lt;- actcal.seq[20:25,]
seq &lt;- rbind(seq1,seq2)
summary(seq)

## ============================
## Example with missing values
## ============================
data(ex1)

## With right="DEL" default value
seqdef(ex1,1:13)

## Eliminating 'left' missing values
seqdef(ex1,1:13, left="DEL")

## Eliminating 'left' missing values and gaps
seqdef(ex1,1:13, left="DEL", gaps="DEL")

## ====================
## Example with weights
## ====================
ex1.seq &lt;- seqdef(ex1, 1:13, weights=ex1$weights)

## weighted sequence frequencies
seqtab(ex1.seq)


</code></pre>

<hr>
<h2 id='seqdiff'>Position-wise discrepancy analysis between groups of sequences</h2><span id='topic+seqdiff'></span><span id='topic+print.seqdiff'></span>

<h3>Description</h3>

<p>The function analyses how the differences between groups of sequences evolve along the positions. It runs a sequence of  discrepancy analyses on sliding windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqdiff(seqdata, group, cmprange = c(0, 1),
  seqdist.args = list(method = "LCS", norm = "auto"), with.missing = FALSE,
  weighted = TRUE, squared = FALSE, seqdist_arg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqdiff_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object created with the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqdiff_+3A_group">group</code></td>
<td>
<p>The group variable.</p>
</td></tr>
<tr><td><code id="seqdiff_+3A_cmprange">cmprange</code></td>
<td>
<p>Vector of two integers: Time range of the sliding windows. Comparison at <code class="reqn">t</code> is computed on the window (<code class="reqn">t + </code><code>cmprange[1]</code>, <code class="reqn">t + </code><code>cmprange[2]</code>).</p>
</td></tr>
<tr><td><code id="seqdiff_+3A_seqdist.args">seqdist.args</code></td>
<td>
<p>List of arguments passed to <code><a href="#topic+seqdist">seqdist</a></code> for computing the distances.</p>
</td></tr>
<tr><td><code id="seqdiff_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. If <code>TRUE</code>, missing values are considered as an additional state. If <code>FALSE</code> subsequences with missing values are removed from the analysis.</p>
</td></tr>
<tr><td><code id="seqdiff_+3A_weighted">weighted</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>seqdiff</code> uses the weights specified in <code>seqdata</code>.</p>
</td></tr>
<tr><td><code id="seqdiff_+3A_squared">squared</code></td>
<td>
<p>Logical. If <code>TRUE</code> the dissimilarities are squared for computing the discrepancy.</p>
</td></tr>
<tr><td><code id="seqdiff_+3A_seqdist_arg">seqdist_arg</code></td>
<td>
<p>Deprecated. Use <code>seqdist.args</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function analyses how the part of discrepancy explained by the <code>group</code> variable evolves along the position axis. It runs successively discrepancy analyses within a sliding time-window of range <code>cmprange</code>). At
each position <code class="reqn">t</code>, the method uses <code><a href="#topic+seqdist">seqdist</a></code> to compute a distance matrix over the time-window (<code class="reqn">t + </code><code>cmprange[1]</code>, <code class="reqn">t + </code><code>cmprange[2]</code>) and then derives the explained discrepancy on that window with <code><a href="#topic+dissassoc">dissassoc</a></code>.
</p>
<p>There are print and plot methods for the returned value.</p>


<h3>Value</h3>

<p>A <code>seqdiff</code> object, with the following items:
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>A <code>data.frame</code> with five statistics (Pseudo F, Pseudo Fbf, Pseudo R2, Bartlett, 
and Levene) for each time stamp of the sequence
(see <code><a href="#topic+dissassoc">dissassoc</a></code>)</p>
</td></tr>
<tr><td><code>discrepancy</code></td>
<td>
<p>A <code>data.frame</code> with, at each time position <code class="reqn">t</code>, the discrepancy within the whole set of sequences and within each group (defined by the <code>group</code> variable).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2011). Discrepancy analysis of state sequences, <em>Sociological Methods and Research</em>, Vol. 40(3), 471-510, <a href="https://doi.org/10.1177/0049124111415372">doi:10.1177/0049124111415372</a>.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2010)
Discrepancy analysis of complex objects using dissimilarities.
In F. Guillet, G. Ritschard, D. A. Zighed and H. Briand (Eds.),
<em>Advances in Knowledge Discovery and Management</em>,
Studies in Computational Intelligence, Volume 292, pp. 3-19. Berlin: Springer.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2009)
Analyse de dissimilarités par arbre d'induction. In EGC 2009,
<em>Revue des Nouvelles Technologies de l'Information</em>, Vol. E-15, pp. 7-18.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dissassoc">dissassoc</a></code> to analyse the association of the <code>group</code> variable with the whole sequence</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define a state sequence object
data(mvad)
## First 12 months of first 100 trajectories
mvad.seq &lt;- seqdef(mvad[1:100, 17:28])

## Position-wise discrepancy analysis using
##  centered sliding windows of length 5.
mvad.diff &lt;- seqdiff(mvad.seq, group=mvad$gcse5eq[1:100], cmprange=c(-2,2))
print(mvad.diff)
plot(mvad.diff, stat=c("Pseudo R2", "Levene"))
plot(mvad.diff, stat="discrepancy")
</code></pre>

<hr>
<h2 id='seqdim'>Dimension of a set of sequences</h2><span id='topic+seqdim'></span>

<h3>Description</h3>

<p>Returns the number of sequences (rows) and the maximum length of a set of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqdim(seqdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqdim_+3A_seqdata">seqdata</code></td>
<td>
<p>a set of sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will first search for separators '-' or ':' in the sequences in order to detect wether they are in the compressed or extended format.
</p>


<h3>Value</h3>

<p>a vector with the number of sequences and the maximum sequence length.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>

<hr>
<h2 id='seqdist'>Distances (dissimilarities) between sequences</h2><span id='topic+seqdist'></span>

<h3>Description</h3>

<p>Computes pairwise dissimilarities between sequences or dissimilarity from
a reference sequence. Several dissimilarity measures can be chosen, including
optimal matching (OM) and many of its variants, distance based on the count
of common attributes, and distances between sequence state distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqdist(seqdata, method, refseq = NULL, norm = "none", indel = "auto", sm = NULL,
  with.missing = FALSE, full.matrix = TRUE, kweights = rep(1.0, ncol(seqdata)),
  tpow = 1.0, expcost = 0.5, context, link = "mean", h = 0.5, nu,
  transindel = "constant", otto, previous = FALSE, add.column = TRUE,
  breaks = NULL, step = 1, overlap = FALSE, weighted = TRUE,
  global.pdotj = NULL, prox = NULL, check.max.size=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqdist_+3A_seqdata">seqdata</code></td>
<td>

<p>State sequence object of class <code>stslist</code>.
The sequence data to use.
Use <code><a href="#topic+seqdef">seqdef</a></code> to create such an object.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_method">method</code></td>
<td>

<p>String.
The dissimilarity measure to use.
It can be <code>"OM"</code>, <code>"OMloc"</code>, <code>"OMslen"</code>, <code>"OMspell"</code>,
<code>"OMstran"</code>, <code>"HAM"</code>, <code>"DHD"</code>, <code>"CHI2"</code>, <code>"EUCLID"</code>,
<code>"LCS"</code>, <code>"LCP"</code>, <code>"RLCP"</code>, <code>"NMS"</code>, <code>"NMSMST"</code>,
<code>"SVRspell"</code>, or <code>"TWED"</code>. See the Details section.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_refseq">refseq</code></td>
<td>

<p><code>NULL</code>, Integer, State Sequence Object, or List.
Default: <code>NULL</code>.
The baseline sequence to compute the distances from.
</p>
<p>When an integer, the index of a sequence in <code>seqdata</code> or <code>0</code> for the most frequent sequence.
</p>
<p>When a state sequence object, it must contain a single sequence and have the same
alphabet as <code>seqdata</code>.
</p>
<p>When a list, it must be a list of two sets of indexes of <code>seqdata</code> rows.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_norm">norm</code></td>
<td>

<p>String.
Default: <code>"none"</code>.
The normalization to use when <code>method</code> is one of <code>"OM"</code>,
<code>"OMloc"</code>, <code>"OMslen"</code>, <code>"OMspell"</code>,
<code>"OMstran"</code>, <code>"TWED"</code>, <code>"HAM"</code>, <code>"DHD"</code>, <code>"LCS"</code>,
<code>"LCP"</code>, <code>"RLCP"</code>, <code>"CHI2"</code>, <code>"EUCLID"</code>.
It can be <code>"none"</code>, <code>"auto"</code>, or, except for
<code>"CHI2"</code> and <code>"EUCLID"</code>, <code>"maxlength"</code>,
<code>"gmean"</code>, <code>"maxdist"</code>, or <code>"YujianBo"</code>. <code>"auto"</code> is
equivalent to <code>"maxlength"</code> when <code>method</code> is one of <code>"OM"</code>,
<code>"HAM"</code>, or <code>"DHD"</code>, to <code>"gmean"</code> when <code>method</code> is one
of <code>"LCS"</code>, <code>"LCP"</code>, or <code>"RLCP"</code>, to <code>YujianBo</code> when
<code>method</code> is one of <code>"OMloc"</code>, <code>"OMslen"</code>, <code>"OMspell"</code>,
<code>"OMstran"</code>, <code>"TWED"</code>. See the Details section.

</p>
</td></tr>
<tr><td><code id="seqdist_+3A_indel">indel</code></td>
<td>

<p>Double, Vector of Doubles, or String.
Default: <code>"auto"</code>.
Insertion/deletion cost(s). Applies when <code>method</code> is one of <code>"OM"</code>, <code>"OMslen"</code>, <code>"OMspell"</code>,
or <code>"OMstran"</code>.
</p>
<p>The single state-independent insertion/deletion cost when a double.

</p>
<p>The state-dependent insertion/deletion costs when a vector of doubles.
The vector should contain an indel cost by state in the order of the alphabet.
</p>
<p>When <code>"auto"</code>, the indel is set as <code>max(sm)/2</code> when <code>sm</code> is
a matrix and is computed by means of <code><a href="#topic+seqcost">seqcost</a></code> when <code>sm</code> is
a string specifying a cost method.
</p>

</td></tr>
<tr><td><code id="seqdist_+3A_sm">sm</code></td>
<td>

<p><code>NULL</code>, Matrix, Array, or String. Substitution costs.
Default: <code>NULL</code>.
</p>
<p>The substitution-cost matrix when a matrix and <code>method</code> is one of
<code>"OM"</code>, <code>"OMloc"</code>, <code>"OMslen"</code>, <code>"OMspell"</code>,
<code>"OMstran"</code>, <code>"HAM"</code>, or <code>"TWED"</code>.
</p>
<p>The series of the substitution-cost matrices when an array and
<code>method = "DHD"</code>. They are grouped in a 3-dimensional array with the
third index referring to the position in the sequence.
</p>
<p>One of the strings <code>"CONSTANT"</code>, <code>"INDELS"</code>, <code>"INDELSLOG"</code>,
or <code>"TRATE"</code>. Designates a <code><a href="#topic+seqcost">seqcost</a></code> method
to build <code>sm</code>. <code>"CONSTANT"</code> is not relevant for <code>"DHD"</code>.
</p>




<p><code>sm</code> is mandatory when <code>method</code> is one of <code>"OM"</code>,
<code>"OMloc"</code>, <code>"OMslen"</code>, <code>"OMspell"</code>, <code>"OMstran"</code>,
or <code>"TWED"</code>.
</p>
<p><code>sm</code> is autogenerated when <code>method</code> is one of <code>"HAM"</code> or
<code>"DHD"</code> and <code>sm = NULL</code>. See the Details section.
</p>
<p>Note: With <code>method = "NMS"</code> or <code>method = "SVRspell"</code>, use
<code>prox</code> instead.
</p>

</td></tr>
<tr><td><code id="seqdist_+3A_with.missing">with.missing</code></td>
<td>

<p>Logical.
Default: <code>FALSE</code>.
Should the non-deleted missing value be added to the alphabet as an additional
state? If <code>FALSE</code> and <code>seqdata</code> or <code>refseq</code> contains such
gaps, an error is raised.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_full.matrix">full.matrix</code></td>
<td>

<p>Logical.
Default: <code>TRUE</code>.
When <code>refseq = NULL</code>, if <code>TRUE</code>, the full distance matrix is
returned, if <code>FALSE</code>, an object of class <code><a href="stats.html#topic+dist">dist</a></code> is returned,
that is, a vector containing only values from the lower triangle of the
distance matrix. Objects of class <code>dist</code> are smaller and can be passed
directly as arguments to most clustering functions.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_kweights">kweights</code></td>
<td>

<p>Double or vector of doubles.
Default: vector of <code>1</code>s.
The weights applied to subsequences when <code>method</code> is one of <code>"NMS"</code>,
<code>"NMSMST"</code>, or <code>"SVRspell"</code>. It contains at position <code class="reqn">k</code> the
weight applied to the subsequences of length <code class="reqn">k</code>. It must be positive. 
Its length should be equal to the number of columns of <code>seqdata</code>. If shorter,
longer subsequences are ignored. If a scalar, it is transformed into
<code>rep(kweights,ncol(sedata))</code>.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_tpow">tpow</code></td>
<td>

<p>Double.
Default: <code>1.0</code>.
The exponential weight of spell length when <code>method</code> is one of
<code>"OMspell"</code>, <code>"NMSMST"</code>, or <code>"SVRspell"</code>.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_expcost">expcost</code></td>
<td>

<p>Double.
Default: <code>0.5</code>.
The cost of spell length transformation when <code>method = "OMloc"</code> or
<code>method = "OMspell"</code>. It must be positive. The exact interpretation is
distance-dependent.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_context">context</code></td>
<td>

<p>Double.
Default: <code>1-2*expcost</code>.
The cost of local insertion when <code>method = "OMloc"</code>. It must be positive.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_link">link</code></td>
<td>

<p>String.
Default: <code>"mean"</code>.
The function used to compute substitution costs when <code>method = "OMslen"</code>.
One of <code>"mean"</code> (arithmetic average) or <code>"gmean"</code> (geometric mean
as in the original proposition of Halpin 2010).
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_h">h</code></td>
<td>

<p>Double.
Default: <code>0.5</code>.
It must be greater than or equal to 0.
</p>
<p>The exponential weight of spell length when <code>method = "OMslen"</code>.
</p>
<p>The gap penalty when <code>method = "TWED"</code>. It corresponds to the lambda
in <cite>Halpin (2014), p 88</cite>. It is usually chosen in the range [0,1]
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_nu">nu</code></td>
<td>

<p>Double.
Stiffness when <code>method = "TWED"</code>. It must be strictly greater than 0
and is usually less than 1.
See <cite>Halpin (2014), p 88</cite>.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_transindel">transindel</code></td>
<td>

<p>String.
Default: <code>"constant"</code>.
Method for computing transition indel costs when <code>method = "OMstran"</code>.
One of <code>"constant"</code> (single indel of 1.0), <code>"subcost"</code> (based on
substitution costs), or <code>"prob"</code> (based on transition probabilities).
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_otto">otto</code></td>
<td>

<p>Double.
The origin-transition trade-off weight when <code>method = "OMstran"</code>. It
must be in [0, 1].
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_previous">previous</code></td>
<td>

<p>Logical.
Default: <code>FALSE</code>.
When <code>method = "OMstran"</code>, should we also account for the transition
from the previous state?
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_add.column">add.column</code></td>
<td>

<p>Logical.
Default: <code>TRUE</code>.
When <code>method = "OMstran"</code>, should the last column (and also the first
column when <code>previous = TRUE</code>) be duplicated? When sequences have different
lengths, should the last (first) valid state be duplicated.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_breaks">breaks</code></td>
<td>

<p><code>NULL</code>, List of pairs Integers.
Default: <code>NULL</code>.
The list of the possibly overlapping intervals when <code>method = "CHI2"</code>
or <code>method = "EUCLID"</code>.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_step">step</code></td>
<td>

<p>Integer.
Default: <code>1</code>.
The length of the intervals when <code>method = "CHI2"</code> or
<code>method = "EUCLID"</code> and <code>breaks = NULL</code>. It must be positive.
It must also be even when <code>overlap = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_overlap">overlap</code></td>
<td>

<p>Logical.
Default: <code>FALSE</code>.
When <code>method = "CHI2"</code> or <code>method = "EUCLID"</code> and
<code>breaks = NULL</code>, should the intervals overlap?
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_weighted">weighted</code></td>
<td>

<p>Logical.
Default: <code>TRUE</code>.
When <code>method</code> is <code>"CHI2"</code> or when <code>sm</code> is a string (method),
should the distributions of the states account for the sequence weights
in <code>seqdata</code>? See <code><a href="#topic+seqdef">seqdef</a></code>.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_global.pdotj">global.pdotj</code></td>
<td>

<p>Numerical vector, <code>"obs"</code>, or <code>NULL</code>.
Default: <code>NULL</code>.
Only for <code>method = "CHI2"</code>.
The vector of state proportions to be used as marginal distribution. When <code>NULL</code>, the state distribution on the corresponding interval is used. When <code>"obs"</code>, the overall state distribution in <code>seqdata</code> is used for all intervals. When a vector of proportions, it is used as marginal distribution for all intervals.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_prox">prox</code></td>
<td>

<p><code>NULL</code> or Matrix.
Default: <code>NULL</code>.
The matrix of state proximities when <code>method = "NMS"</code> or
<code>method = "SVRspell"</code>.
</p>
</td></tr>
<tr><td><code id="seqdist_+3A_check.max.size">check.max.size</code></td>
<td>

<p>Logical. Should <code>seqdist</code> stop when maximum allowed number of unique sequences is exceeded? Caution, setting <code>FALSE</code> may produce unexpected results or even crash R.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>seqdist</code> function returns a matrix of distances between sequences
or a vector of distances from the reference sequence when <code>refseq</code> is set.
The available metrics (see <code>method</code> option) include:
</p>

<ul>
<li>
<p><em>Edit distances</em>: optimal matching (<code>"OM"</code>), localized OM
(<code>"OMloc"</code>), spell-length-sensitive OM (<code>"OMslen"</code>), OM of spell
sequences (<code>"OMspell"</code>), OM of transition sequences (<code>"OMstran"</code>),
Hamming (<code>"HAM"</code>), dynamic Hamming (<code>"DHD"</code>), and the time warp edit
distance (<code>"TWED"</code>).

</p>
</li>
<li>
<p><em>Metrics based on counts of common attributes</em>: distance based on
the longest common subsequence (<code>"LCS"</code>), on the longest common prefix
(<code>"LCP"</code>), on the longest common suffix (<code>"RLCP"</code>), on the number
of matching subsequences (<code>"NMS"</code>), on the number of matching
subsequences weighted by the minimum shared time (<code>"NMSMST"</code>) and,
the subsequence vectorial representation distance (<code>"SVRspell"</code>).

</p>
</li>
<li>
<p><em>Distances between state distributions</em>: Euclidean (<code>"EUCLID"</code>),
Chi-squared (<code>"CHI2"</code>).

</p>
</li></ul>

<p>See <cite>Studer and Ritschard (2014, 2016)</cite> for a description and the comparison
of the above dissimilarity measures except <code>"TWED"</code> for which we refer to
<cite>Marteau (2009)</cite> and <cite>Halpin (2014)</cite>.
</p>
<p>Each method can be controlled with the following parameters:
</p>

<table>
<tr>
 <td style="text-align: left;">
    method </td><td style="text-align: left;"> parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
    ------------------ </td><td style="text-align: left;"> ---------------------------------</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;OM&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;sm, indel, norm&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;OMloc&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;sm, expcost, context, norm&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;OMslen&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;sm, indel, link, h, norm&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;OMspell&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;sm, indel, norm, tpow, expcost, norm&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;OMstran&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;sm, indel, transindel, otto, previous, add.column, norm&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;HAM, DHD&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;sm, norm&#8288;</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;CHI2&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;breaks, step, overlap, norm, weighted, global.pdotj, norm&#8288;</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;EUCLID&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;breaks, step, overlap, norm&#8288;</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;LCS, LCP, RLCP&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;norm&#8288;</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;NMS&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;prox, kweights&#8288;</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;NMSMST&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;kweights, tpow&#8288;</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;SVRspell&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;prox, kweights, tpow&#8288;</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code style="white-space: pre;">&#8288;TWED&#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;sm, (indel), h, nu, norm&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    ------------------ </td><td style="text-align: left;"> ---------------------------------
  </td>
</tr>

</table>

<p><code>"LCS"</code> is <code>"OM"</code> with a substitution cost of 2 (<code>sm = "CONSTANT",
  cval = 2</code>) and an <code>indel</code> of <code>1.0</code>. <code>"HAM"</code> is <code>"OM"</code> without
indels. <code>"DHD"</code> is <code>"HAM"</code> with specific substitution costs at each
position.
</p>
<p><code>"HAM"</code> and <code>"DHD"</code> apply only to sequences of equal length.
</p>
<p>For <code>"TWED"</code>, the (single) indel serves only for empty sequences.
The distance to an empty sequence is set as <code class="reqn">n*</code><code>indel</code>, where <code class="reqn">n</code> is
the length of the non empty sequence. By default (<code>indel="auto"</code>), indel is set
as <code>2 * max(sm) + nu + h</code>.
</p>

<p>When <code>sm = NULL</code>, the substitution-cost matrix is automatically created
for <code>"HAM"</code> with a single substitution cost of 1 and for <code>"DHD"</code> with
the costs derived from the transition rates at the successive positions, i.e. with
<code>sm = "TRATE"</code>.
</p>
<p>Some distances can optionally be normalized by means of the <code>norm</code> argument.
Let <code class="reqn">d</code> be the distance, <code class="reqn">m</code> the maximum possible of the distance
given the lengths <code class="reqn">p</code> and <code class="reqn">q</code> of the two sequences, and <code class="reqn">k</code> the
length of the longer sequence. Normalization <code>"maxlength"</code> is <code class="reqn">d/k</code>
(Abbott's normalization), <code>"gmean"</code> is <code class="reqn">1-(m-d)/(p*q)^.5</code> (Elzinga's
normalization), <code>"maxdist"</code> is <code class="reqn">d/m</code>, and &quot;YujianBo&quot; is <code class="reqn">2*d/(m+d)</code>.
For more details, see  <cite>Gabadinho et al. (2009, 2011)</cite>.
Actually, to avoid negative outcomes, the length <code class="reqn">p</code>, <code class="reqn">q</code>, and <code class="reqn">k</code> are
set as (max) indel times the corresponding length. For some distances, <code class="reqn">m</code> is
only a possibly non-reachable upper bound.
</p>
<p>When <code>norm="auto"</code>, <code>"gmean"</code> is applied to <code>"LCS"</code>,
<code>"LCP"</code> and <code>"RLCP"</code> distances, <code>"maxlength"</code> is applied to <code>"OM"</code>, <code>"HAM"</code>
and <code>"DHD"</code>, and the normalization &quot;YujianBo&quot; of <cite>Yujian and Bo (2007)</cite> that preserves the
triangle inequality is used in the other cases except <code>"CHI2"</code> and <code>"EUCLID"</code>.
For the latter two, the square of the
distances are normalized by the number of intervals and the maximal distance
on each interval. Note that for 'CHI2' the maximal distance on each interval
depends on the state distribution on the interval.
</p>
<p>When sequences contain gaps and the <code>left = NA</code>, <code>gaps = NA</code>, or <code>right = NA</code>
option was passed to
<code><a href="#topic+seqdef">seqdef</a></code> (i.e. when there are non deleted missing values), the
<code>with.missing</code> argument should be set as <code>TRUE</code>. If left as
<code>FALSE</code> the function stops when it encounters a gap. This is to make the
user aware that there are gaps in the sequences. For methods that need an
<code>sm</code> value, <code>seqdist</code> expects a substitution-cost matrix with a row
and a column entry for the missing state (symbol defined with the <code>nr</code>
option of <code><a href="#topic+seqdef">seqdef</a></code>). Substitution-cost matrices returned by
<code><a href="#topic+seqcost">seqcost</a></code> (and so <code><a href="#topic+seqsubm">seqsubm</a></code>) include these additional
entries when the function is called with <code>with.missing = TRUE</code>. More
details on how to compute distances with sequences containing gaps can be
found in <cite>Gabadinho et al. (2009)</cite>.
</p>


<h3>Value</h3>

<p>When <code>refseq</code> is <code>NULL</code> (default), the whole matrix of pairwise
distances between sequences or, if <code>full.matrix = FALSE</code>,
the corresponding <code>dist</code> object of pairwise distances between sequences.
</p>
<p>When <code>refseq</code> is a <code>list</code> of two sets of indexes, the matrix
of distances from the first set of sequences (rows) to the second set (columns).
</p>
<p>Otherwise, a vector with distances between the sequences in the
state sequence object and the reference sequence specified with <code>refseq</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer, Gilbert Ritschard, Pierre-Alexandre Fonta, Alexis Gabadinho, Nicolas S. Müller.
.
</p>


<h3>References</h3>

<p>Studer, M. and G. Ritschard (2016), &quot;What matters in differences between life
trajectories: A comparative review of sequence dissimilarity measures&quot;,
<em>Journal of the Royal Statistical Society, Series A</em>. <b>179</b>(2),
481-511, <a href="https://doi.org/10.1111/rssa.12125">doi:10.1111/rssa.12125</a>
</p>
<p>Studer, M. and G. Ritschard (2014). &quot;A Comparative Review of Sequence
Dissimilarity Measures&quot;. <em>LIVES Working Papers</em>, <b>33</b>. NCCR LIVES,
Switzerland, <a href="https://doi.org/10.12682/lives.2296-1658.2014.33">doi:10.12682/lives.2296-1658.2014.33</a>
</p>
<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and
Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical
Software</em> <b>40</b>(4), 1&ndash;37.
</p>
<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2009). Mining
Sequence Data in <code>R</code> with the <code>TraMineR</code> package: A user's guide.
Department of Econometrics and Laboratory of Demography, University of Geneva
</p>
<p>Halpin, B. (2014). Three Narratives of Sequence Analysis, in Blanchard, P.,
Bühlmann, F. and Gauthier, J.-A. (Eds.) <em>Advances in Sequence Analysis:
Theory, Method, Applications</em>, Vol 2 of Series <em>Life Course Research and
Social Policies</em>, pages 75&ndash;103, Heidelberg: Springer. <a href="https://doi.org/10.1007/978-3-319-04969-4_5">doi:10.1007/978-3-319-04969-4_5</a>
</p>
<p>Marteau, P.-F. (2009). Time Warp Edit Distances with Stiffness Adjustment for
Time Series Matching. <em>IEEE Transactions on Pattern Analysis and Machine
Intelligence</em>, <b>31</b>(2), 306&ndash;318. <a href="https://doi.org/10.1109/TPAMI.2008.76">doi:10.1109/TPAMI.2008.76</a>
</p>
<p>Yujian, L. and Bo, L. (2007). A normalized Levenshtein distance metric.
<em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>,
<b>29</b>(6), 1091&ndash;1095. <a href="https://doi.org/10.1109/TPAMI.2007.1078">doi:10.1109/TPAMI.2007.1078</a>
</p>
<p>See also all references in <cite>Studer and Ritschard (2014, 2016)</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqcost">seqcost</a></code>, <code><a href="#topic+seqsubm">seqsubm</a></code>, <code><a href="#topic+seqdef">seqdef</a></code>, and <code><a href="#topic+seqMD">seqMD</a></code> for
multidomain (multichannel) distances using the cost additive trick.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =========================
## Examples without missings
## =========================

## Defining a sequence object with columns 10 to 25
## of a subset of the 'biofam' data set
data(biofam)
biofam.seq &lt;- seqdef(biofam[501:600, 10:25])

## OM distances using the vector of indels and substitution
## costs derived from the estimated state frequencies
costs &lt;- seqcost(biofam.seq, method = "INDELSLOG")
biofam.om &lt;- seqdist(biofam.seq, method = "OM",
                     indel = costs$indel, sm = costs$sm)

## OM between sequences of transitions
biofam.omstran &lt;- seqdist(biofam.seq, method = "OMstran",
                     indel = costs$indel, sm = costs$sm,
                     otto=.3, transindel="subcost")

## Normalized LCP distances
biofam.lcp.n &lt;- seqdist(biofam.seq, method = "LCP",
                        norm = "auto")

## Normalized LCS distances to the most frequent sequence
biofam.dref1 &lt;- seqdist(biofam.seq, method = "LCS",
                        refseq = 0, norm = "auto")

## LCS distances to an external sequence
ref &lt;- seqdef(as.matrix("(0,5)-(3,5)-(4,6)"), informat = "SPS",
              alphabet = alphabet(biofam.seq))
biofam.dref2 &lt;- seqdist(biofam.seq, method = "LCS",
                        refseq = ref)

## LCS distances between two subsets of sequences
set1 &lt;- 1:10
set2 &lt;- 31:36
biofam.dref2 &lt;- seqdist(biofam.seq, method = "LCS",
                        refseq = list(set1,set2))


## Chi-squared distance over the full observed timeframe
biofam.chi.full &lt;- seqdist(biofam.seq, method = "CHI2",
                           step = max(seqlength(biofam.seq)))

## Chi-squared distance over successive overlapping
## intervals of length 4
biofam.chi.ostep &lt;- seqdist(biofam.seq, method = "CHI2",
                            step = 4, overlap = TRUE)


## ======================
## Examples with missings
## ======================
data(ex1)
## Ignore empty row 7
ex1.seq &lt;- seqdef(ex1[1:6, 1:13])

## OM with indel and substitution costs based on
## log of inverse state frequencies
costs.ex1 &lt;- seqcost(ex1.seq, method = "INDELSLOG",
                     with.missing = TRUE)
ex1.om &lt;- seqdist(ex1.seq, method = "OM",
                  indel = costs.ex1$indel, sm = costs.ex1$sm,
                  with.missing = TRUE)

## Localized OM
ex1.omloc &lt;- seqdist(ex1.seq, method = "OMloc",
                     sm = costs.ex1$sm, expcost=.1, context = .4,
                     with.missing = TRUE)

## OMspell with a scalar indel
indel &lt;- max(costs.ex1$indel)
## OM of spells
ex1.omspell &lt;- seqdist(ex1.seq, method = "OMspell",
                       indel = indel, sm = costs.ex1$sm,
                       with.missing = TRUE)

## Distance based on number of matching subsequences
ex1.nms &lt;- seqdist(ex1.seq, method = "NMS",
                   with.missing = TRUE)

## Using the sequence vectorial representation metric
costs.fut &lt;- seqcost(ex1.seq, method = "FUTURE", lag = 4,
                     proximities = TRUE, with.missing = TRUE)
ex1.svr &lt;- seqdist(ex1.seq, method = "SVRspell",
                   prox = costs.fut$prox, with.missing = TRUE)
</code></pre>

<hr>
<h2 id='seqdomassoc'>Measures of association between domains of sequence data</h2><span id='topic+seqdomassoc'></span><span id='topic+print.sdomassoc'></span>

<h3>Description</h3>

<p>The function computes pairwise domain association based on cross-tabulation of the states observed in the sequences of the two domains involved. The association measure returned can be Cramer's V or the likelihood ratio (LRT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqdomassoc(
  seqdata.dom,
  rep.method = "overall",
  assoc = c("LRT", "V"),
  diss.dom = NULL,
  wrange = NULL,
  p.value = TRUE,
  struct.zero = TRUE,
  cross.table = FALSE,
  with.missing = FALSE,
  weighted = TRUE,
  seqrep.args = list(coverage = 0.8, pradius = 0.1),
  seqrf.args = list(k = 20),
  dnames = names(seqdata.dom)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqdomassoc_+3A_seqdata.dom">seqdata.dom</code></td>
<td>
<p>List of <code>stslist</code> objects (one per dimension)</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_rep.method">rep.method</code></td>
<td>
<p>Character string. Method for determining the sequences on which the association is computed. One of &quot;rep&quot; (representative sequences), &quot;eq.group&quot; (medoids of equally spaced groups), or &quot;overall&quot;.</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_assoc">assoc</code></td>
<td>
<p>Character string. The association measure to be computed. One of &quot;V&quot; (Cramer V) or &quot;LRT&quot; or a vector with both.</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_diss.dom">diss.dom</code></td>
<td>
<p>List of dissimilarity matrices used for selecting representatives. Ignored when <code>rep.method="overall"</code>.</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_wrange">wrange</code></td>
<td>
<p>Vector of two integers. Window range for count of co-occurrences. A state at <code>p</code> in the first domain is compared with states in [<code>p+wrange[1]</code>, <code>p+wrange[2]</code>] in the second domain.</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_p.value">p.value</code></td>
<td>
<p>Logical. Should p-values be returned?</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_struct.zero">struct.zero</code></td>
<td>
<p>Logical. Should zeros in cross tables be treated as structural zeros?</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_cross.table">cross.table</code></td>
<td>
<p>Logical. Should cross tables be returned? If <code>TRUE</code>, cross tables are returned as the list attribute <code>cross.tables</code>.</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. Should missing be treated as a regular state.</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Should sequence weights be taken into account when present in the sequence objects? When applicable, weights of the first domain are used.</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_seqrep.args">seqrep.args</code></td>
<td>
<p>List of arguments passed to <code><a href="#topic+seqrep">seqrep</a></code> when <code>rep.method="rep"</code>.</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_seqrf.args">seqrf.args</code></td>
<td>
<p>List of arguments passed to <code><a href="#topic+seqrf">seqrf</a></code> when <code>rep.method="eq.group"</code>.</p>
</td></tr>
<tr><td><code id="seqdomassoc_+3A_dnames">dnames</code></td>
<td>
<p>String vector: names of dimensions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of domains, <code>seqdomassoc</code> cross-tabulates the position-wise states across domains using all sequences when <code>rep.method = "overall"</code>.  When <code>rep.method = "rep"</code>, each observed sequence is first replaced by the closest representative sequence and, when <code>rep.method = "eq.group"</code>, each observed sequence is replaced by the group medoid of its group. Then, the selected association measures are computed on the resulting cross-tables.
</p>
<p>The <code>"overall"</code> method implies a strong position-wise association and will not detect association occurring after a small time warp. With representative sequences, the same holds, but for representatives only. Using dissimilarity measures that allow for time warp for identifying representatives, observed sequences may differ from their representatives in the timing of the states. Therefore, using representatives instead of all sequences relaxes somewhat the strong timing constraint.
</p>


<h3>Value</h3>

<p>An object of class <code>sdomassoc</code>, which is the table (matrix) of association statistics with the list of cross tables in attribute <code>cross.tables</code>.
</p>
<p>The print method for objects <code>sdomassoc</code> prints only the table of association statistics.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard
</p>


<h3>References</h3>

<p>Ritschard, G., T.F. Liao, and E. Struffolino (2023). Strategies for
multidomain sequence analysis in social research.
<em>Sociological Methodology</em>, 53(2), 288-322. <a href="https://doi.org/10.1177/00811750231163833">doi:10.1177/00811750231163833</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dissdomassoc">dissdomassoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)

## Building one channel per type of event (left, children or married)
cases &lt;- 1:50
bf &lt;- as.matrix(biofam[cases, 10:25])
children &lt;-  bf==4 | bf==5 | bf==6
married &lt;- bf == 2 | bf== 3 | bf==6
left &lt;- bf==1 | bf==3 | bf==5 | bf==6

## Building sequence objects
child.seq &lt;- seqdef(children, weights = biofam[cases,'wp00tbgs'])
marr.seq &lt;- seqdef(married, weights = biofam[cases,'wp00tbgs'])
left.seq &lt;- seqdef(left, weights = biofam[cases,'wp00tbgs'])

## distances by channel
dchild &lt;- seqdist(child.seq, method="OM", sm="INDELSLOG")
dmarr &lt;- seqdist(marr.seq, method="OM", sm="INDELSLOG")
dleft &lt;- seqdist(left.seq, method="OM", sm="INDELSLOG")
dbiofam &lt;- list(dchild,dmarr,dleft)
dnames &lt;- names(dbiofam) &lt;- c("child","marr","left")


seqdomassoc(list(child.seq,marr.seq,left.seq), dnames=dnames)
seqdomassoc(list(child.seq,marr.seq,left.seq), diss.dom=dbiofam,
            rep.method="rep", assoc="V", dnames=dnames)
seqdomassoc(list(child.seq,marr.seq,left.seq), diss.dom=dbiofam,
            rep.method="eq.group", assoc="V", dnames=dnames)


</code></pre>

<hr>
<h2 id='seqdss'>Extract sequences of distinct successive states</h2><span id='topic+seqdss'></span>

<h3>Description</h3>

<p>Extract the sequence of distinct successive states from each sequence in a  object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqdss(seqdata, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqdss_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqdss_+3A_with.missing">with.missing</code></td>
<td>
<p>Should non-void missing values be considered as regular states? See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a sequence object containing the sequences of distinct successive states (DSS). The spell durations are not taken into account. E.g., the DSS contained in <code>'D-D-D-D-A-A-A-A-A-A-A-D'</code> is <code>'D-A-D'</code>. Associated durations can be extracted with the <code><a href="#topic+seqdur">seqdur</a></code> function.
</p>
<p>When <code>{with.missing=TRUE}</code>, non-void missing values are considered as a regular state of the alphabet. For example, the DSS of <code>A-A-*-*-*-B-B-C-C-D</code> is <code>A-*-B-C-D</code>.
</p>
<p>When <code>with.missing=FALSE</code> (default) missing values are ignored and a substring <code>A-A-*-*-*A</code> for example will be considered as a single spell in <code>A</code> while the DSS of this substring would be <code>A-*-A</code> whith <code>with.missing=TRUE</code>.
</p>
<p>See <a href="#topic+seqdef">seqdef</a> on options for handling missing values when creating sequence objects.
</p>


<h3>Value</h3>

<p>a sequence object containing the distinct state sequence (DSS) for each sequence in the object given as argument. </p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdur">seqdur</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object from columns 13 to 24
## in the 'actcal' example data set
## Here we retain the first 10 sequences only.
data(actcal)
actcal.seq &lt;- seqdef(actcal[1:10,13:24])

## Retrieving the DSS
actcal.dss &lt;- seqdss(actcal.seq)

## Displaying the DSS for the first 10 sequences
actcal.dss

## Example with with.missing argument
data(ex1)
ex1.seq &lt;- seqdef(ex1[, 1:13])

seqdss(ex1.seq)
seqdss(ex1.seq, with.missing=TRUE)
</code></pre>

<hr>
<h2 id='seqdur'>Extract state durations from a sequence object.</h2><span id='topic+seqdur'></span>

<h3>Description</h3>

<p>Extracts states durations from a sequence object. Returns a matrix containing the states durations for the sequences. The states durations in <code>'D-D-D-D-A-A-A-A-A-A-A-D'</code> are 4,7,1. Distinct states can be extracted with the <code><a href="#topic+seqdss">seqdss</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqdur(seqdata, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqdur_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqdur_+3A_with.missing">with.missing</code></td>
<td>
<p>Should non-void missing values be considered as regular states? See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>with.missing=FALSE</code> (default) missing values are ignored and a substring <code>AA***A</code> for example will be considered as a spell <code>AAA</code> of duration 3. When <code>with.missing=TRUE</code>, durations are also computed for spells of missing values (gaps in sequences).
</p>
<p>See <a href="#topic+seqdef">seqdef</a> on options for handling missing values when creating sequence objects.
</p>


<h3>Value</h3>

<p>a matrix containing the states durations for each distinct state in each sequence.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdss">seqdss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object from columns 13 to 24
## in the 'actcal' example data set
## Here we retain the first 10 sequences only.
data(actcal)
actcal.seq &lt;- seqdef(actcal[1:10,13:24])

## Retrieving the spell durations
actcal.dur &lt;- seqdur(actcal.seq)

## Displaying the durations for the first 10 sequences
actcal.dur
</code></pre>

<hr>
<h2 id='seqeapplysub'>Checking for the presence of given event subsequences</h2><span id='topic+seqeapplysub'></span>

<h3>Description</h3>

<p>Checks occurrences of the subsequences <code>subseq</code> among the event sequences and returns the result according to the selected <code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqeapplysub(subseq, method = NULL, constraint = NULL,
            rules=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqeapplysub_+3A_subseq">subseq</code></td>
<td>
<p>list of subsequences (an event subsequence object) such as created by <code><a href="#topic+seqefsub">seqefsub</a></code></p>
</td></tr>
<tr><td><code id="seqeapplysub_+3A_method">method</code></td>
<td>
<p>type of result, should be one of <code>"count"</code>, <code>"presence"</code> or <code>"age"</code></p>
</td></tr>
<tr><td><code id="seqeapplysub_+3A_constraint">constraint</code></td>
<td>

<p>Time constraints overriding those used to compute <code>subseq</code>. See <code><a href="#topic+seqeconstraint">seqeconstraint</a></code>
</p>
</td></tr>
<tr><td><code id="seqeapplysub_+3A_rules">rules</code></td>
<td>
<p>If set to <code>TRUE</code>, instead of checking occurrences of the subsequences among the event sequences, check the occurrence of the subsequences inside the subsequences (internally used by <code>seqerules</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three methods implemented:
<code>"count"</code> counts the number of occurrence of each given subsequence in each event sequence;
<code>"presence"</code> returns 1 if the subsequence is present, 0 otherwise;
<code>"age"</code> returns the age of appearance of each subsequence in each event sequence.
In case of multiple possibilities, the age of the first occurrence is returned. When the subsequence is not in the sequence, -1 is returned.
</p>


<h3>Value</h3>

<p>The return value is a matrix where each row corresponds to a sequence (row names are set accordingly) and each column corresponds to a subsequence (col names are set accordingly).
The cells of the matrix contain the requested values (count, presence-absence indicator or age).
</p>


<h3>Author(s)</h3>

<p>Matthias Studer and Reto Bürgin (alternative counting methods) (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2009). Mining Sequence Data in <code>R</code> with the <code>TraMineR</code> package: A user's guide. Department of Econometrics and Laboratory of Demography, University of Geneva.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqecreate">seqecreate</a></code> for more information on event sequence object and <cite>Gabadinho et al. (2009)</cite> on how to use the event sequence analysis module.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading data
data(actcal.tse)

## Creating the event sequence object
actcal.eseq &lt;- seqecreate(actcal.tse)

## Printing sequences
actcal.eseq[1:10]

## Looking for frequent subsequences
fsubseq &lt;- seqefsub(actcal.eseq,pmin.support=0.01)

## Counting the number of occurrences of each subsequence
msubcount &lt;- seqeapplysub(fsubseq,method="count")
## First lines...
msubcount[1:10,1:10]
## Presence-absence of each subsequence
msubpres &lt;- seqeapplysub(fsubseq,method="presence")
## First lines...
msubpres[1:10,1:10]

## Age at first appearance of each subsequence
msubage &lt;- seqeapplysub(fsubseq,method="age")

## First lines...
msubage[1:10,1:10]
</code></pre>

<hr>
<h2 id='seqecmpgroup'>Identifying discriminating subsequences</h2><span id='topic+seqecmpgroup'></span>

<h3>Description</h3>

<p>Identify and sort the most discriminating subsequences by their discriminating power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqecmpgroup(subseq, group, method="chisq", pvalue.limit=NULL,
             weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqecmpgroup_+3A_subseq">subseq</code></td>
<td>
<p>A <code>subseqelist</code> object (list of subsequences) such as produced by <code><a href="#topic+seqefsub">seqefsub</a></code></p>
</td></tr>
<tr><td><code id="seqecmpgroup_+3A_group">group</code></td>
<td>
<p>Group membership, i.e., a variable or factor defining the groups which we want to discriminate</p>
</td></tr>
<tr><td><code id="seqecmpgroup_+3A_method">method</code></td>
<td>
<p>The discrimination method; one of <code>"bonferroni"</code> or <code>"chisq"</code></p>
</td></tr>
<tr><td><code id="seqecmpgroup_+3A_pvalue.limit">pvalue.limit</code></td>
<td>
<p>Can be used to filter the results. Only subsequences with a p-value lower than this parameter are selected. If <code>NULL</code> all subsequences are returned (regardless of their p-values).</p>
</td></tr>
<tr><td><code id="seqecmpgroup_+3A_weighted">weighted</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>seqecmpgroup</code> uses the weights specified in <code>subseq</code>, (see <code><a href="#topic+seqefsub">seqefsub</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following discrimination test functions are implemented:
<code>chisq</code>, the Pearson Independence Chi-squared test, and
<code>bonferroni</code>, the Pearson Independence Chi-squared test with Bonferroni correction.
</p>


<h3>Value</h3>

<p>An objet of type <code>subseqelistchisq</code> (subtype of <code>subseqelist</code>) with the following elements
</p>
<table>
<tr><td><code>subseq</code></td>
<td>
<p>Sorted list of found discriminating subsequences</p>
</td></tr>
<tr><td><code>eseq</code></td>
<td>
<p>The event sequence object on which the tests were computed</p>
</td></tr>
<tr><td><code>constraint</code></td>
<td>
<p>Time constraints used for searching the subsequences (see <code><a href="#topic+seqeconstraint">seqeconstraint</a></code>)</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>Levels (value labels) of the target group variable</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of test used</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A data frame with columns support, index (original rank of the subsequence, i.e., its position in the inputted <code>subseq</code>) and a pair of frequency and Pearson residual columns for each group</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Studer, M., Müller, N.S., Ritschard, G. &amp; Gabadinho, A. (2010), &quot;Classer, discriminer et visualiser des séquences d'événements&quot;, In Extraction et gestion des connaissances (EGC 2010), <em>Revue des nouvelles technologies de l'information</em> RNTI. Vol. E-19, pp. 37-48.
</p>
<p>Ritschard, G., Bürgin, R., and Studer, M. (2014), &quot;Exploratory Mining of Life Event Histories&quot;, In McArdle, J.J. &amp; Ritschard, G. (eds) <em>Contemporary Issues in Exploratory Data Mining in the Behavioral Sciences</em>. Series: Quantitative Methodology, pp. 221-253. New York: Routledge.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+plot.subseqelistchisq">plot.subseqelistchisq</a></code> to plot the results</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal.tse)
actcal.eseq &lt;- seqecreate(actcal.tse)

##Searching for frequent subsequences, that is, appearing at least 20 times
fsubseq &lt;- seqefsub(actcal.eseq, pmin.support=0.01)

##searching for susbsequences discriminating the most men and women
data(actcal)
discr &lt;- seqecmpgroup(fsubseq, group=actcal$sex, method="bonferroni")
##Printing the six most discriminating subsequences
print(discr[1:6])
##Plotting the six most discriminating subsequences
plot(discr[1:6])

</code></pre>

<hr>
<h2 id='seqeconstraint'>Setting time constraints and the counting method</h2><span id='topic+seqeconstraint'></span><span id='topic+print.seqeconstraint'></span>

<h3>Description</h3>

<p>Function used to set time constraints and the counting method in  methods (<code>seqe...</code>) for event sequences such as <code><a href="#topic+seqefsub">seqefsub</a></code> for searching frequent subsequences or <code><a href="#topic+seqeapplysub">seqeapplysub</a></code> for checking occurrences of subsequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqeconstraint(max.gap = -1, window.size = -1, age.min = -1, age.max = -1,
  age.max.end = -1, count.method = 1, maxGap, windowSize, ageMin, ageMax,
ageMaxEnd, countMethod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqeconstraint_+3A_max.gap">max.gap</code></td>
<td>
<p>The maximum time gap between two events</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_window.size">window.size</code></td>
<td>
<p>The maximum time span accepted for subsequences</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_age.min">age.min</code></td>
<td>
<p>Minimal start time position allowed for subsequences. Ignored when equal to -1 (default).</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_age.max">age.max</code></td>
<td>
<p>Maximal start time position allowed for subsequences. Ignored when equal to -1 (default).</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_age.max.end">age.max.end</code></td>
<td>
<p>Maximal end time position allowed for subsequences. Ignored when equal to -1 (default).</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_count.method">count.method</code></td>
<td>
<p>By default, subsequences are counted only
one time by sequence (<code>'COBJ'</code> method). Alternative counting methods
are <code>'CDIST_O'</code>, <code>'CWIN'</code>,
<code>'CMINWIN'</code> or <code>'CDIST'</code> respectively. See details.</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_maxgap">maxGap</code></td>
<td>
<p>Deprecated. Use <code>max.gap</code> instead.</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_windowsize">windowSize</code></td>
<td>
<p>Deprecated. Use <code>window.size</code> instead.</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_agemin">ageMin</code></td>
<td>
<p>Deprecated. Use <code>age.min</code> instead.</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_agemax">ageMax</code></td>
<td>
<p>Deprecated. Use <code>age.max</code> instead.</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_agemaxend">ageMaxEnd</code></td>
<td>
<p>Deprecated. Use <code>age.max.end</code> instead.</p>
</td></tr>
<tr><td><code id="seqeconstraint_+3A_countmethod">countMethod</code></td>
<td>
<p>Deprecated. Use <code>count.method</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>max.gap</code>, <code>window.size</code>, <code>age.min</code>, <code>age.max</code> and
<code>age.max.end</code>. If so, two events should not be separated by more
than <code>max.gap</code> and the whole subsequence should not exceed a
<code>window.size</code>  time span.
The other parameters specify the start and end age of the subsequence,
it should start between <code>age.min</code> and <code>age.max</code> and finish
before <code>age.max.end</code>.
Parameters <code>age.min</code>, <code>age.max</code> and <code>age.max.end</code> are
interpreted as the number of positions (time units) from the beginning
of the sequence.
</p>
<p>There are 5 options for the <code>count.method</code> argument. (1) By default,
the count is the number of sequences that contain the subsequence (<code>"COBJ"</code> method).
Alternatives are (2) <code>"CDIST_O"</code> (counts all distinct occurrences in each sequence including possibly overlapping occurrences, i.e., occurrences sharing a same event occurrence), (3) <code>"CWIN"</code> (number of slidden windows of length <code>window.size</code>  that contain an occurrence of the subsequence),
(4) <code>"CMINWIN"</code> (number of minimal windows of occurrence) and (5) <code>"CDIST"</code> (distinct occurrences without event occurrences overlap). See
references.
</p>


<h3>Value</h3>

<p>A constraint object containing one item per constraint type.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer, Nicolas S. Müller and Reto Bürgin (alternative counting methods) (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Joshi, Mahesh V., George Karypis, and Vipin Kumar (2001) A Universal Formulation of
Sequential Patterns <em>Proceedings of the KDD'2001 Workshop on
Temporal Data Mining</em>, San Francisco.
</p>
<p>Ritschard, G., A. Gabadinho, N.S. Müller and M. Studer (2008), Mining event sequences: A social science perspective, <em>International Journal of Data Mining, Modelling and Management, IJDMMM</em>, 1(1), 68-90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqefsub">seqefsub</a></code>, <code><a href="#topic+seqeapplysub">seqeapplysub</a></code></p>

<hr>
<h2 id='seqecontain'>Check if sequence contains events</h2><span id='topic+seqecontain'></span>

<h3>Description</h3>

<p>Check if an event sequence or subsequence contains given events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqecontain(eseq, event.list, unknown.exclude = FALSE,
  seq, eventList, exclude)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqecontain_+3A_eseq">eseq</code></td>
<td>
<p>A event sequence object (<code>seqelist</code>) or a an event subsequence object (<code>subseqelist</code>)</p>
</td></tr>
<tr><td><code id="seqecontain_+3A_event.list">event.list</code></td>
<td>
<p>A list of events</p>
</td></tr>
<tr><td><code id="seqecontain_+3A_unknown.exclude">unknown.exclude</code></td>
<td>
<p>if <code>TRUE</code> the search is exclusive and returns <code>FALSE</code> for any subsequence containing an event that is not in <code>event.list</code></p>
</td></tr>
<tr><td><code id="seqecontain_+3A_seq">seq</code></td>
<td>
<p>Deprecated. Use <code>eseq</code> instead.</p>
</td></tr>
<tr><td><code id="seqecontain_+3A_eventlist">eventList</code></td>
<td>
<p>Deprecated. Use <code>event.list</code> instead.</p>
</td></tr>
<tr><td><code id="seqecontain_+3A_exclude">exclude</code></td>
<td>
<p>Deprecated. Use <code>unknown.exclude</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks, for each provided event sequence, if it contains one of the events in <code>event.list</code>.
If <code>unknown.exclude</code> is <code>TRUE</code>, <code>seqecontain</code> looks if all events of the subsequence are in <code>event.list</code>.
</p>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqecreate">seqecreate</a></code> for creating event sequence objects and <code><a href="#topic+seqefsub">seqefsub</a></code> for creating event subsequence objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal.tse)
actcal.eseq &lt;- seqecreate(actcal.tse)

##Searching for frequent subsequences, that is appearing at least 20 times
fsubseq &lt;- seqefsub(actcal.eseq,min.support=20)

##looking for subsequence with FullTime
seqecontain(fsubseq,c("FullTime"))

</code></pre>

<hr>
<h2 id='seqecreate'>Create event sequence objects.</h2><span id='topic+seqecreate'></span>

<h3>Description</h3>

<p>Create an event sequence object either from time stamped events or from a state sequence object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqecreate(data = NULL, id = NULL,timestamp = NULL, event = NULL,
  end.event = NULL, tevent = "transition", use.labels = TRUE,
  weighted = TRUE, endEvent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqecreate_+3A_data">data</code></td>
<td>
<p>A state sequence object (see <code><a href="#topic+seqdef">seqdef</a></code>) or a data frame </p>
</td></tr>
<tr><td><code id="seqecreate_+3A_id">id</code></td>
<td>
<p>Integer. The sequence 'id' column when data are provided in TSE format (ignored if <code>data</code> argument is provided).</p>
</td></tr>
<tr><td><code id="seqecreate_+3A_timestamp">timestamp</code></td>
<td>
<p>Double. The event 'timestamp' column when data are provided in TSE format, i.e., the time at which events occur (ignored if <code>data</code> argument is provided).</p>
</td></tr>
<tr><td><code id="seqecreate_+3A_event">event</code></td>
<td>
<p>Character or factor. The 'event' column when data are provided in TSE format, i.e., the events occurring at the specified time stamps  (ignored if <code>data</code> argument is provided).</p>
</td></tr>
<tr><td><code id="seqecreate_+3A_end.event">end.event</code></td>
<td>
<p>Character. If specified this event indicates the end of observation time (total length of event sequences) when it is not followed by any other valid event. The event is ignored when occurring in between two valid events.</p>
</td></tr>
<tr><td><code id="seqecreate_+3A_tevent">tevent</code></td>
<td>
<p>Either a transition matrix or a method to generate events from state sequences (see <code><a href="#topic+seqetm">seqetm</a></code>). Used only when <code>data</code> is a state sequence object.</p>
</td></tr>
<tr><td><code id="seqecreate_+3A_use.labels">use.labels</code></td>
<td>
<p>Logical. If <code>TRUE</code>, transitions names are built from long state labels rather than from the short state names of the alphabet.</p>
</td></tr>
<tr><td><code id="seqecreate_+3A_weighted">weighted</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>data</code> is a state sequence object, use the weights specified in <code>data</code> (see <code><a href="#topic+seqdef">seqdef</a></code>)</p>
</td></tr>
<tr><td><code id="seqecreate_+3A_endevent">endEvent</code></td>
<td>
<p>Deprecated. Use <code>end.event</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are several ways to create an event sequence object. The first one is by providing the events in TSE format (see <code><a href="#topic+seqformat">seqformat</a></code>), i.e. by providing three paired lists: id, timestamp and event, such that each triplet (id, timestamp, event) defines the event that occurs at time timestamp for case id. Several events at the same time for a same id are allowed. The lists can be provided with the arguments <code>id</code>, <code>timestamp</code> and <code>event</code>. An alternative is by providing a data frame as <code>data</code> argument in which case the function takes the required information from the &quot;id&quot;, &quot;timestamp&quot; and &quot;event&quot; columns of that data frame. In any case with TSE format, <b>listed events should be  grouped by id</b> and an error will be thrown otherwise. Such grouping can be achieved by ordering the data according to the id column using the <code><a href="base.html#topic+order">order</a></code> function (e.g., <code>data[order(data$id), ]</code>).
</p>
<p>The other way is to pass a state sequence object (as <code>data</code> argument) and to perform an automatic state-to-event conversion. The simplest way to make a conversion is by means of a predefined method (see <code><a href="#topic+seqetm">seqetm</a></code>), such as <code>"transition"</code> (one distinct event per possible transition), <code>"state"</code> (a new event for each entering in a new state) and <code>"period"</code> (a pair of events, one start-state event and one end-state event for each found transition).  For a more customized conversion, you can specify a transition matrix in the same way as in <code><a href="#topic+seqformat">seqformat</a></code>. Function <code><a href="#topic+seqetm">seqetm</a></code> can help you in creating your transition matrix.
</p>
<p>Event sequence objects as created by <code>seqecreate</code> are required by most other '<code>seqe</code>' methods, such as <code><a href="#topic+seqefsub">seqefsub</a></code> or <code><a href="#topic+seqeapplysub">seqeapplysub</a></code> for example.
</p>


<h3>Value</h3>

<p>An object of class <code>seqelist</code>. There are <code>print</code>,
and <code>plot</code> methods for such objects.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Ritschard, G., Bürgin, R., and Studer, M. (2014), &quot;Exploratory Mining of Life Event Histories&quot;, In McArdle, J.J. &amp; Ritschard, G. (eds) <em>Contemporary Issues in Exploratory Data Mining in the Behavioral Sciences</em>. Series: Quantitative Methodology, pp. 221-253. New York: Routledge.
</p>
<p>Ritschard, G., A. Gabadinho, M. Studer and N. S. Müller. Converting between
various sequence representations. in Ras, Z. &amp; Dardzinska, A. (eds.)
<em>Advances in Data Management</em>, Springer, 2009, 223, 155-175.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqformat">seqformat</a></code> for converting between sequence formats,
<code><a href="#topic+seqeweight">seqeweight</a></code> for retrieving or assigning weights,
<code><a href="#topic+seqefsub">seqefsub</a></code> for searching frequent subsequences,
<code><a href="#topic+seqecmpgroup">seqecmpgroup</a></code> to search for discriminant subsequences,
<code><a href="#topic+seqeapplysub">seqeapplysub</a></code> for counting subsequence occurrences,
<code><a href="#topic+seqelength">seqelength</a></code> for information about length (observation time) of event sequences,
<code><a href="#topic+seqdef">seqdef</a></code> to create a state sequence object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Starting with states sequences
##Loading data
data(biofam)
## Creating state sequences
biofam.seq &lt;- seqdef(biofam,10:25, informat='STS')
## Creating event sequences from biofam
biofam.eseq &lt;- seqecreate(biofam.seq)

## Loading data
data(actcal.tse)
## Creating sequences
actcal.eseq &lt;- seqecreate(id=actcal.tse$id, timestamp=actcal.tse$time,
	event=actcal.tse$event)
##printing sequences
actcal.eseq[1:10]
## Using the data argument
actcal.eseq &lt;- seqecreate(data=actcal.tse)

## Example with missings
data(ex1) ## STS data with missing values

## Creating the state sequence object with by default
## the left missings and gaps coded as '*' and
## end missings coded as void ('%')
sqex1 &lt;- seqdef(ex1[,1:13])
## and without ignoring right missings (coded as '*')
sqex1b &lt;- seqdef(ex1[,1:13], right=NA)

## Compare the outcome
seqecreate(sqex1)
seqecreate(sqex1, tevent='state')
seqecreate(sqex1, tevent='state', end.event=attr(sqex1,'void'))
seqecreate(sqex1b, tevent='state')
</code></pre>

<hr>
<h2 id='seqefsub'>Searching for frequent subsequences</h2><span id='topic+seqefsub'></span><span id='topic+is.subseqelist'></span><span id='topic+print.subseqelist'></span>

<h3>Description</h3>

<p>Returns the list of subsequences with minimal support sorted in decreasing order of support. Various time constraints can be set to restrict the search to specific time periods or subsequence durations. The function permits also to get information on specified subsequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqefsub(eseq, str.subseq = NULL, min.support = NULL,
  pmin.support = NULL, constraint = seqeconstraint(), max.k = -1,
  weighted = TRUE, seq, strsubseq, minSupport, pMinSupport, maxK)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqefsub_+3A_eseq">eseq</code></td>
<td>
<p>A list of event sequences</p>
</td></tr>
<tr><td><code id="seqefsub_+3A_str.subseq">str.subseq</code></td>
<td>
<p>A list of specific subsequences to look for. See details.</p>
</td></tr>
<tr><td><code id="seqefsub_+3A_min.support">min.support</code></td>
<td>
<p>The minimum support (in number of sequences)</p>
</td></tr>
<tr><td><code id="seqefsub_+3A_pmin.support">pmin.support</code></td>
<td>
<p>The minimum support (in percentage, corresponding count will be rounded)</p>
</td></tr>
<tr><td><code id="seqefsub_+3A_constraint">constraint</code></td>
<td>
<p>A time constraint object as returned by <code><a href="#topic+seqeconstraint">seqeconstraint</a></code></p>
</td></tr>
<tr><td><code id="seqefsub_+3A_max.k">max.k</code></td>
<td>
<p>The maximum number of events allowed in a subsequence</p>
</td></tr>
<tr><td><code id="seqefsub_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Should <code>seqefsub</code> use the weights specified in <code>eseq</code> (see <code><a href="#topic+seqeweight">seqeweight</a></code>).</p>
</td></tr>
<tr><td><code id="seqefsub_+3A_seq">seq</code></td>
<td>
<p>Deprecated. Use <code>eseq</code> instead.</p>
</td></tr>
<tr><td><code id="seqefsub_+3A_strsubseq">strsubseq</code></td>
<td>
<p>Deprecated. Use <code>str.subseq</code> instead.</p>
</td></tr>
<tr><td><code id="seqefsub_+3A_minsupport">minSupport</code></td>
<td>
<p>Deprecated. Use <code>min.support</code> instead.</p>
</td></tr>
<tr><td><code id="seqefsub_+3A_pminsupport">pMinSupport</code></td>
<td>
<p>Deprecated. Use <code>pmin.support</code> instead.</p>
</td></tr>
<tr><td><code id="seqefsub_+3A_maxk">maxK</code></td>
<td>
<p>Deprecated. Use <code>max.k</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two usages of this function. The first is for searching subsequences satisfying a support condition.
By default, the support is counted per sequence and not per occurrence, i.e. when a sequence contains several occurrences of a same subsequence it is counted only once. Use the <code>count.method</code> argument of <code><a href="#topic+seqeconstraint">seqeconstraint</a></code> to change that. The minimal required support can be set with <code>pmin.support</code> as a proportion (between 0 and 1) in which case the support will be rounded, or through min.support as a number of sequences.
Time constraints can also be imposed with the <code>constraint</code> argument, which must be the outcome of a call to the <code><a href="#topic+seqeconstraint">seqeconstraint</a></code> function.
</p>
<p>The second possibility is for searching sequences that contain specified subsequences. This is done by passing the list of subsequences with the <code>str.subseq</code> argument. The subsequences must contain only events from the alphabet of events of <code>eseq</code> and must be in the same format as that used to display subsequences (see <code><a href="#topic+str.seqelist">str.seqelist</a></code>).
Each transition (group of events) should be enclosed in parentheses () and separated with commas, and the succession of transitions should be denoted by a '-' indicating a time gap.
For instance &quot;(FullTime)-(PartTime, Children)&quot; stands for the subsequence &quot;FullTime&quot; followed by the transition defined by the two simultaneously occurring events &quot;PartTime&quot; and &quot;Children&quot;.
</p>
<p>To get information such as the number of occurrences of the subsequences returned by <code>seqefsub</code> or the sequences that contain each subsequence use the function <code><a href="#topic+seqeapplysub">seqeapplysub</a></code>.
</p>
<p>Subsets of the returned <code>subseqelist</code> can be accessed with the <code>[]</code> operator (see example). There are print and plot methods for <code>subseqelist</code>.
</p>


<h3>Value</h3>

<p>A <code>subseqelist</code> object with at least the following attributes:
</p>
<table>
<tr><td><code>eseq</code></td>
<td>
<p>The list of sequences in which the subsequences were searched (a <code>seqelist</code> event sequence object).</p>
</td></tr>
<tr><td><code>subseq</code></td>
<td>
<p>A list of subsequences (a <code>seqelist</code> event sequence object).</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A data frame containing details (support, frequency, ...) about the subsequences</p>
</td></tr>
<tr><td><code>constraint</code></td>
<td>
<p>The constraint object used when searching the subsequences.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of search: 'frequent' or 'user'</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Matthias Studer and Reto Bürgin (alternative counting methods) (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Ritschard, G., Bürgin, R., and Studer, M. (2014), &quot;Exploratory Mining of Life Event Histories&quot;, In McArdle, J.J. &amp; Ritschard, G. (eds) <em>Contemporary Issues in Exploratory Data Mining in the Behavioral Sciences</em>. Series: Quantitative Methodology, pp. 221-253. New York: Routledge.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+plot.subseqelist">plot.subseqelist</a></code> to plot the result.
See <code><a href="#topic+seqecreate">seqecreate</a></code> for creating event sequences. 
See <code><a href="#topic+seqeapplysub">seqeapplysub</a></code> to count the number of occurrences of frequent subsequences in each sequence.
See <code><a href="#topic+is.seqelist">is.seqelist</a></code> about <code>seqelist</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal.tse)
actcal.eseq &lt;- seqecreate(actcal.tse)

## Searching for subsequences appearing at least 20 times
fsubseq &lt;- seqefsub(actcal.eseq, min.support=20)
## The same using a percentage
fsubseq &lt;- seqefsub(actcal.eseq, pmin.support=0.01)
## Getting a string representation of subsequences
## First ten most frequent subsequences
fsubseq[1:10]

## Using time constraints
## Looking for subsequences starting in Summer (between June and September)
fsubseq &lt;- seqefsub(actcal.eseq, min.support=10,
  constraint=seqeconstraint(age.min=6, age.max=9))
fsubseq[1:10]

##Looking for subsequences occurring in Summer (between June and September)
fsubseq &lt;- seqefsub(actcal.eseq, min.support = 10,
  constraint=seqeconstraint(age.min=6, age.max=9, age.max.end=9))
fsubseq[1:10]

##Looking for subsequence enclosed in a 6 month period
## and with a maximum gap of 2 month
fsubseq &lt;- seqefsub(actcal.eseq, min.support=10,
  constraint=seqeconstraint(max.gap=2, window.size=6))
fsubseq[1:10]
</code></pre>

<hr>
<h2 id='seqeid'>Retrieve unique ids from an event sequence object.</h2><span id='topic+seqeid'></span>

<h3>Description</h3>

<p>Retrieve the unique ids from an event sequence object or from a list of event sequence object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqeid(eseq, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqeid_+3A_eseq">eseq</code></td>
<td>
<p>An event sequence object (as created with <code><a href="#topic+seqecreate">seqecreate</a></code>) or a list of event sequence objects</p>
</td></tr>
<tr><td><code id="seqeid_+3A_s">s</code></td>
<td>
<p>Deprecated. Use <code>eseq</code> instead.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal.tse)
actcal.eseq &lt;- seqecreate(actcal.tse)
sid &lt;- seqeid(actcal.eseq)
length(sid)
head(sid)
</code></pre>

<hr>
<h2 id='seqelength'>Lengths of event sequences</h2><span id='topic+seqelength'></span><span id='topic+seqelength+3C-'></span>

<h3>Description</h3>

<p>The length of an event sequence is its time span, i.e., the total time of observation. This information is useful to perform for instance a survival analysis. The function
<code>seqelength</code> retrieves the lengths of the provided sequences, while
<code>seqelength &lt;-</code> sets the length of the sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqelength(eseq, s)
seqelength(eseq, s) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqelength_+3A_eseq">eseq</code></td>
<td>
<p>An event sequence object (<code>seqelist</code>).</p>
</td></tr>
<tr><td><code id="seqelength_+3A_value">value</code></td>
<td>
<p>A list of sequence lengths.</p>
</td></tr>
<tr><td><code id="seqelength_+3A_s">s</code></td>
<td>
<p>Deprecated. Use <code>eseq</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the lengths of the sequences.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal.tse)
actcal.eseq &lt;- seqecreate(actcal.tse)
## Since end.event is not specified, contains no sequence lengths
## We set them manually as 12 for all sequences
sl &lt;- numeric()
sl[1:2000] &lt;- 12
seqelength(actcal.eseq) &lt;- sl
actcal.eseq[1:10]
## Retrieve lengths
slen &lt;- seqelength(actcal.eseq)
summary(slen)
</code></pre>

<hr>
<h2 id='seqetm'>Create a transition-definition matrix</h2><span id='topic+seqetm'></span>

<h3>Description</h3>

<p>This function automatically creates a transition-definition matrix from a state sequence object to  transform the state sequences into time stamped event sequences (in TSE format).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqetm(seqdata, method = "transition", use.labels = TRUE, sep = "&gt;",
  bp = "", ep = "end", seq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqetm_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object from which transition events will be determined</p>
</td></tr>
<tr><td><code id="seqetm_+3A_method">method</code></td>
<td>
<p>The method to use. One of <code>"transition"</code>, <code>"period"</code> or <code>"state"</code>.</p>
</td></tr>
<tr><td><code id="seqetm_+3A_use.labels">use.labels</code></td>
<td>
<p>If <code>TRUE</code>, transition names are built from state labels rather than from the alphabet.</p>
</td></tr>
<tr><td><code id="seqetm_+3A_sep">sep</code></td>
<td>
<p>Separator to be used between the from-state and to-state that define the transition (&quot;transition&quot; method).</p>
</td></tr>
<tr><td><code id="seqetm_+3A_bp">bp</code></td>
<td>
<p>Prefix for beginning of period event names (<code>"period"</code> method)</p>
</td></tr>
<tr><td><code id="seqetm_+3A_ep">ep</code></td>
<td>
<p>Prefix for end of period event names (<code>"period"</code> method)</p>
</td></tr>
<tr><td><code id="seqetm_+3A_seq">seq</code></td>
<td>
<p>Deprecated. Use <code>seqdata</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning!!!: State labels should not contain commas <code>","</code> which are reserved for separating multiple events of a same transition!
</p>
<p>One of three methods can be selected with the <code>method</code> argument:
</p>
<p><code>"transition"</code> generates a single (from-state &gt; to-state) event for each found transition and a distinct start-state event for each different sequence start;
</p>
<p><code>"period"</code> generates a pair of events (end-state-event, start-state-event) for each found transition, a start-state event for the beginning of the sequence and an end-state event for the end of the sequence; names used for end-state and start-state names can be controlled with the <code>bp</code> and <code>ep</code> arguments;
</p>
<p><code>"state"</code> generates only the to-state event of each found transition (useful for analysing state sequences with methods for event sequences);
</p>


<h3>Value</h3>

<p>The transition-definition matrix.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqformat">seqformat</a></code> for converting to TSE format,
<code><a href="#topic+seqecreate">seqecreate</a></code> for creating an event sequence object,
<code><a href="#topic+seqdef">seqdef</a></code> for creating a state sequence object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a state sequence object from columns 13 to 24
## in the 'actcal' example data set
data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24,
        labels=c("FullTime", "PartTime", "LowPartTime", "NoWork"))
## Creating a transition matrix, one event per transition
seqetm(actcal.seq,method = "transition")

## Creating a transition matrix, single to-state events
seqetm(actcal.seq,method = "state")

## Creating a transition matrix, two events per transition
seqetm(actcal.seq,method = "period")

## changing the prefix of period start event.
seqetm(actcal.seq,method = "period", bp="begin")
</code></pre>

<hr>
<h2 id='seqeweight'>
Setting or retrieving weights of an event sequence object.
</h2><span id='topic+seqeweight'></span><span id='topic+seqeweight+3C-'></span>

<h3>Description</h3>

<p>Event sequence objects can be weighted. Weights are used by other functions such as <code><a href="#topic+seqefsub">seqefsub</a></code> or <code><a href="#topic+seqecmpgroup">seqecmpgroup</a></code> to compute weighted statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqeweight(eseq, s)
seqeweight(eseq, s) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqeweight_+3A_eseq">eseq</code></td>
<td>
<p>An event sequence object (<code>seqelist</code>).</p>
</td></tr>
<tr><td><code id="seqeweight_+3A_value">value</code></td>
<td>
<p>Numerical vector containing weights</p>
</td></tr>
<tr><td><code id="seqeweight_+3A_s">s</code></td>
<td>
<p>Deprecated. Use <code>eseq</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>seqeweight</code> returns a numerical vector containing the weights associated to each event sequence.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Starting with states sequences
##Loading data
data(biofam)
## Creating state sequences
biofam.seq &lt;- seqdef(biofam,10:25,informat='STS')

## Creating event sequences from biofam
biofam.eseq &lt;- seqecreate(biofam.seq, weighted=FALSE)

## Using the weights
seqeweight(biofam.eseq) &lt;- biofam$wp00tbgs

## Now seqefsub accounts for weights unless weighted is set to FALSE
fsubseq &lt;- seqefsub(biofam.eseq, pmin.support=0.01)

## Searching for weighted susbsequences which best
## discriminate the birth cohort
discr &lt;- seqecmpgroup(fsubseq, group=biofam$birthyr&gt;=1940)
plot(discr[1:15])

</code></pre>

<hr>
<h2 id='seqfcheck'>Check if sequences are in the compressed or extended format</h2><span id='topic+seqfcheck'></span>

<h3>Description</h3>

<p>Check whether <em>seqdata</em> contains sequences in the compressed format (as character strings with states separated by a separator) or in the extended format (sequences stored in a matrix with each successive state in a separate column.) For a more detailed description of the compressed and extended format, see <cite>Gabadinho, 2009</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqfcheck(seqdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqfcheck_+3A_seqdata">seqdata</code></td>
<td>
<p>a vector, data frame or matrix containing sequence data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whether the sequence(s) are in compressed format is checked by counting the number of columns and searching for the <code>'-'</code> or <code>':'</code> separator. The function returns the separator if it has been found in the data. If the data contains more than one column, the data is supposed to be in the extended format, and <code>'X'</code> is returned, unless some state codes contain the <code>'-'</code> character (e.g., states coded with negative integer values), in which case <code>'-X'</code> is returned.
</p>


<h3>Value</h3>

<p>a character string coding the format of the sequence data, either <code>':'</code>,<code>'-'</code>,<code>'X'</code> or <code>'-X'</code>.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2009). Mining Sequence Data in <code>R</code> with <code>TraMineR</code>: A user's guide. <em>Department of Econometrics and Laboratory of Demography, University of Geneva</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqconc">seqconc</a></code>, <code><a href="#topic+seqdecomp">seqdecomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The sequences in the actcal data set
## are in the extended format
data(actcal)
head(actcal[,13:24])
seqfcheck(actcal[,13:24])

## The sequences in the famform data set
## are in the compressed format
data(famform)
famform
seqfcheck(famform)
</code></pre>

<hr>
<h2 id='seqfind'>Indexes of state sequence(s) x in state sequence object y</h2><span id='topic+seqfind'></span>

<h3>Description</h3>

<p>Finds the row indexes of state sequence(s) x in the state sequence object y. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqfind(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqfind_+3A_x">x</code></td>
<td>
<p>a state sequence object containing one or more sequences (<code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqfind_+3A_y">y</code></td>
<td>
<p>a state sequence object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>row index(es) of sequence(s) x in the set of sequences y.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
mvad.shortlab &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad.seq &lt;- seqdef(mvad, states=mvad.shortlab, 15:86)

## Finding occurrences of sequence 176 in mvad.seq
seqfind(mvad.seq[176,],mvad.seq)

## Finding occurrences of sequence 1 to 8 in mvad.seq
seqfind(mvad.seq[1:8,],mvad.seq)
</code></pre>

<hr>
<h2 id='seqformat'>Conversion between sequence formats</h2><span id='topic+seqformat'></span>

<h3>Description</h3>

<p>Convert a sequence data set from one format to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqformat(data, var = NULL, from, to, compress = FALSE, nrep = NULL, tevent,
  stsep = NULL, covar = NULL, SPS.in = list(xfix = "()", sdsep = ","),
  SPS.out = list(xfix = "()", sdsep = ","), id = 1, begin = 2, end = 3,
  status = 4, process = TRUE, pdata = NULL, pvar = NULL, limit = 100,
  overwrite = TRUE, fillblanks = NULL, tmin = NULL, tmax = NULL, missing = "*",
  with.missing = TRUE, right="DEL", compressed, nr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqformat_+3A_data">data</code></td>
<td>

<p>Data frame, matrix, <code>stslist</code> state sequence object, or character string vector.
The data to use. (Tibble will be converted with <code>as.data.frame</code>).
</p>
<p>A data frame or a matrix with sequence data in one or more columns when
<code>from = "STS"</code> or <code>from = "SPS"</code>. If sequence data are in a single
column or in a string vector, they are assumed to be in the compressed form (see <code>stsep</code>).
</p>
<p>A data frame with sequence data in one or more columns when <code>from = "SPELL"</code>.
If sequence data has not four columns ordered as individual ID, spell
start time, spell end time, and spell state status, use <code>var</code> or
<code>id</code> / <code>begin</code> / <code>end</code> / <code>status</code>.
</p>
<p>A state sequence object when <code>from = "STS"</code> or <code>from</code> is not specified.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_var">var</code></td>
<td>

<p><code>NULL</code>, List of Integers or Strings.
Default: <code>NULL</code>.
The indexes or the names of the columns with the sequence data in <code>data</code>.
If <code>NULL</code>, all columns are considered.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_from">from</code></td>
<td>

<p>String.
The format of the input sequence data.
It can be <code>"STS"</code>, <code>"SPS"</code>, or <code>"SPELL"</code>. It is not needed
if <code>data</code> is a state sequence object.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_to">to</code></td>
<td>

<p>String.
The format of the output data.
It can be <code>"STS"</code>, <code>"DSS"</code>, <code>"SPS"</code>, <code>"SRS"</code>, <code>"SPELL"</code>, or <code>"TSE"</code>.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_compress">compress</code></td>
<td>


<p>Logical.
Default: <code>FALSE</code>.
When <code>to = "STS"</code>, <code>to = "DSS"</code>, or <code>to = "SPS"</code>, should the
sequences (row vector of states) be concatenated into strings? See
<code><a href="#topic+seqconc">seqconc</a></code>.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_nrep">nrep</code></td>
<td>


<p>Integer.
The number of shifted replications when <code>to = "SRS"</code>.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_tevent">tevent</code></td>
<td>


<p>Matrix.
The transition-definition matrix when <code>to = "TSE"</code>.
It should be of size <code class="reqn">d * d</code> where <code class="reqn">d</code> is the number of distinct
states appearing in the sequences. The cell <code class="reqn">(i,j)</code> lists the events
associated with a transition from state <code class="reqn">i</code> to state <code class="reqn">j</code>. It can be
created with <code><a href="#topic+seqetm">seqetm</a></code>.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_stsep">stsep</code></td>
<td>


<p><code>NULL</code>, Character.
Default: <code>NULL</code>.
The separator between states in the compressed form (strings) when
<code>from = "STS"</code> or <code>from = "SPS"</code>.
If <code>NULL</code>, <code><a href="#topic+seqfcheck">seqfcheck</a></code> is called for detecting automatically
a separator among &quot;-&quot; and &quot;:&quot;. Other separators must be specified explicitly.
See <code><a href="#topic+seqdecomp">seqdecomp</a></code>.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_covar">covar</code></td>
<td>


<p>List of Integers or Strings.
The indexes or the names of additional columns in <code>data</code> to include as
covariates in the output when <code>to = "SRS"</code>.
The covariates are replicated across the shifted replicated rows.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_sps.in">SPS.in</code></td>
<td>


<p>List.
Default: <code>list(xfix = "()", sdsep = ",")</code>.
The specifications for the state-duration couples in the input data when
<code>from = "SPS"</code>.
The first specification, <code>xfix</code>, specifies the prefix/suffix character.
Use a two-character string if the prefix and the suffix differ. Use
<code>xfix = ""</code> when no prefix/suffix are present. The second
specification, <code>sdsep</code>, specifies the state/duration separator.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_sps.out">SPS.out</code></td>
<td>


<p>List.
Default: <code>list(xfix = "()", sdsep = ",")</code>.
The specifications for the state-duration couples in the output data when
<code>to = "SPS"</code>.
See <code>SPS.in</code> above.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_id">id</code></td>
<td>



<p><code>NULL</code>, Integer, String, List of Integers or Strings.
Default: <code>1</code>.
</p>
<p>When <code>from = "SPELL"</code>, the index or the name of the column containing
the individual IDs in <code>data</code> (after <code>var</code> filtering).
</p>
<p>When <code>to = "TSE"</code>, the index or the name of the column containing
the individual IDs in <code>data</code> (after <code>var</code> filtering) or the unique
individual IDs. If <code>id</code> is not manually specified, <code>id</code> is set as
<code>NULL</code> for backward compatibility with TraMineR 1.8-13 behaviour. If
<code>id</code> is manually or automatically set as <code>NULL</code>, the original
individual IDs are ignored and replaced by the indexes of the sequences in the
input data.
</p>
<p>When <code>from = "SPELL"</code> and <code>to = "TSE"</code>, the index or the name of
the column containing the individual IDs in <code>data</code> (after <code>var</code>
filtering). The TSE output will use the original individual IDs.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_begin">begin</code></td>
<td>


<p>Integer or String.
Default: <code>2</code>.
The index or the name of the column containing the spell start times in
<code>data</code> (after <code>var</code> filtering) when <code>from = "SPELL"</code>.
Start times should be positive integers.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_end">end</code></td>
<td>


<p>Integer or String.
Default: <code>3</code>.
The index or the name of the column containing the spell end times in
<code>data</code> (after <code>var</code> filtering) when <code>from = "SPELL"</code>.
End times should be positive integers.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_status">status</code></td>
<td>


<p>Integer or String.
Default: <code>4</code>.
The index or the name of the column containing the spell statuses in
<code>data</code> (after <code>var</code> filtering) when <code>from = "SPELL"</code>.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_process">process</code></td>
<td>


<p>Logical.
Default: <code>TRUE</code>.
When <code>from = "SPELL"</code>, if <code>TRUE</code>, create sequences on a process
time axis, if <code>FALSE</code>, create sequences on a calendar time axis.


</p>
<p>This <code>process</code> argument as well as the associated <code>pdata</code> and <code>pvar</code>
arguments are intended for <code>data</code> containing spell data with calendar begin
and end times. When those times are ages, use <code>process = FALSE</code> with
<code>pdata=NULL</code> to use those ages as process times. Option <code>process = TRUE</code>
does currently not work for age times.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_pdata">pdata</code></td>
<td>



<p><code>NULL</code>, <code>"auto"</code>, or data frame.
Default: <code>NULL</code>. (tibble will be converted with <code>as.data.frame</code>).
</p>
<p>If <code>NULL</code>, the start and end times of each spell are supposed to be, if
<code>process = TRUE</code>, ages, if <code>process = FALSE</code>, years when
<code>from = "SPELL"</code>.
</p>
<p>If <code>"auto"</code>, ages are computed using the start time of the first spell
of each individual as her/his birthdate when <code>from = "SPELL"</code> and
<code>process = TRUE</code>. For <code>from = "SPELL"</code> and <code>process = FALSE</code>, <code>"auto"</code> is equivalent to <code>NULL</code>.
</p>
<p>A data frame containing the ID and the birth time of the individuals when
<code>from = "SPELL"</code> or <code>to = "SPELL"</code>. Use <code>pvar</code> to specify
the column names. The ID is used to match the birth time of each individual
with the sequence data. The birth time should be integer. It is the start
time from which the positions on the time axis are computed. It also serves
to compute <code>tmin</code> and to guess <code>tmax</code> when the latter are <code>NULL</code>,
<code>from = "SPELL"</code>, and <code>process = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_pvar">pvar</code></td>
<td>



<p>List of Integers or Strings.
The indexes or names of the columns of the data frame <code>pdata</code> that
contain the ID and the birth time of the individuals in that order.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_limit">limit</code></td>
<td>


<p>Integer.
Default: <code>100</code>.
The maximum age of age sequences when <code>from = "SPELL"</code> and <code>process = TRUE</code>.
Age sequences will be considered to start at 1 and to end at <code>limit</code>.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_overwrite">overwrite</code></td>
<td>


<p>Logical.
Default: <code>TRUE</code>.
When <code>from = "SPELL"</code>, if <code>TRUE</code>, the most recent episode
overwrites the older one when they overlap each other, if <code>FALSE</code>,
in case of overlap, the most recent episode starts after the end of the
previous one.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_fillblanks">fillblanks</code></td>
<td>


<p>Character.
The value to fill gaps between episodes when <code>from = "SPELL"</code>.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_tmin">tmin</code></td>
<td>


<p><code>NULL</code> or Integer.
Default: <code>NULL</code>.
The start time of the axis when <code>from = "SPELL"</code> and <code>process = FALSE</code>.
If <code>NULL</code>, the value is the minimum of the spell start times
(see <code>begin</code>) or the minimum of the birth time of the individuals
(see <code>pdata</code> when it is a data frame and <code>process = FALSE</code>).
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_tmax">tmax</code></td>
<td>


<p><code>NULL</code> or Integer.
Default: <code>NULL</code>.
The end time of the axis when <code>from = "SPELL"</code> and <code>process = FALSE</code>.
If <code>NULL</code>, the value is the maximum of the spell end times (see <code>end</code>)
or the sum of the maximum of the spell end times and of the maximum of the
birth time of the individuals (see <code>pdata</code> when it is a data frame and
<code>process = FALSE</code>).
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_missing">missing</code></td>
<td>

<p>String.
Default: <code>"*"</code>.
The code for missing states in <code>data</code>.
It will be replaced by <code>NA</code> in the output data. Ignored when <code>data</code> is a state sequence object
(see <code><a href="#topic+seqdef">seqdef</a></code>), in which case the attribute <code>nr</code> is used as missing value code.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_with.missing">with.missing</code></td>
<td>


<p>Logical.
Default: <code>TRUE</code>.
When <code>to = "SPELL"</code>, should the spells of missing states be included?
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_right">right</code></td>
<td>


<p>One of <code>"DEL"</code> or <code>NA</code>.
Default: <code>"DEL"</code>.
When <code>to = "SPELL"</code> and <code>with.missing=TRUE</code>, set <code>right=NA</code> to include the end spells of missing states.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_compressed">compressed</code></td>
<td>

<p>Deprecated. Use <code>compress</code> instead.
</p>
</td></tr>
<tr><td><code id="seqformat_+3A_nr">nr</code></td>
<td>

<p>Deprecated. Use <code>missing</code> instead.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>seqformat</code> function is used to convert data from one format to
another. The input data is first converted into the STS format and then
converted to the output format. Depending on input and output formats, some
information can be lost in the conversion process. The output is a matrix or
a data frame, NOT a sequence <code>stslist</code> object. To process, print or plot
the sequences with TraMineR functions, you will have to first transform the data frame
into a <code>stslist</code> state sequence object with <code><a href="#topic+seqdef">seqdef</a></code>.
See <cite>Gabadinho et al. (2009)</cite> and <cite>Ritschard et al. (2009)</cite> for more
details on longitudinal data formats and converting between them.
</p>
<p>When data are in <code>"SPELL"</code> format (<code>from = "SPELL"</code>), the begin and end times are expected to be positions in the sequences. Therefore they should be strictly positive integers.
With <code>process=TRUE</code>, the outcome sequences will be aligned on ages (process duration since birth), while with <code>process=FALSE</code> they will be aligned on dates (position on the calendar time). If <code>process=TRUE</code>, values in the <code>begin</code> and <code>end</code> columns of <code>data</code> are assumed to be ages when <code>pdata</code> is <code>NULL</code> and integer dates otherwise. If <code>process=FALSE</code>, begin and end values are assumed to be integer dates when <code>pdata</code> is <code>NULL</code> and ages otherwise.
</p>


<h3>Value</h3>

<p>A data frame for <code>SRS</code>, <code>TSE</code>, and <code>SPELL</code>, a matrix otherwise.
</p>
<p>When <code>from="SPELL"</code>, outcome has an attribute <code>issues</code> with indexes of sequences with issues (truncated sequences, missing start time, spells before birth year, ...)
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho, Pierre-Alexandre Fonta, Nicolas S. Müller, Matthias Studer,
and Gilbert Ritschard.
</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2009). Mining
Sequence Data in <code>R</code> with the <code>TraMineR</code> package: A user's guide.
Department of Econometrics and Laboratory of Demography, University of Geneva.
</p>
<p>Ritschard, G., A. Gabadinho, M. Studer and N. S. Müller. Converting between
various sequence representations. in Ras, Z. &amp; Dardzinska, A. (eds.)
<em>Advances in Data Management</em>, Springer, 2009, 223, 155-175.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdef">seqdef</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## ========================================
## Examples with raw STS sequences as input
## ========================================

## Loading a data frame with sequence data in the columns 13 to 24
data(actcal)

## Converting to SPS format
actcal.SPS.A &lt;- seqformat(actcal, 13:24, from = "STS", to = "SPS")
head(actcal.SPS.A)

## Converting to compressed SPS format with no
## prefix/suffix and with "/" as state/duration separator
actcal.SPS.B &lt;- seqformat(actcal, 13:24, from = "STS", to = "SPS",
  compress = TRUE, SPS.out = list(xfix = "", sdsep = "/"))
head(actcal.SPS.B)

## Converting to compressed DSS format
actcal.DSS &lt;- seqformat(actcal, 13:24, from = "STS", to = "DSS",
  compress = TRUE)
head(actcal.DSS)


## ==============================================
## Examples with a state sequence object as input
## ==============================================

## Loading a data frame with sequence data in the columns 10 to 25
data(biofam)

## Limiting the number of considered cases to the first 20
biofam &lt;- biofam[1:20, ]

## Creating a state sequence object
biofam.labs &lt;- c("Parent", "Left", "Married", "Left/Married",
  "Child", "Left/Child", "Left/Married/Child", "Divorced")
biofam.short.labs &lt;- c("P", "L", "M", "LM", "C", "LC", "LMC", "D")
biofam.seq &lt;- seqdef(biofam, 10:25, alphabet = 0:7,
  states = biofam.short.labs, labels = biofam.labs)

## Converting to SPELL format
bf.spell &lt;- seqformat(biofam.seq, from = "STS", to = "SPELL",
  pdata = biofam, pvar = c("idhous", "birthyr"))
head(bf.spell)


## ======================================
## Examples with SPELL sequences as input
## ======================================

## Loading two data frames: bfspell20 and bfpdata20
## bfspell20 contains the first 20 biofam sequences in SPELL format
## bfpdata20 contains the IDs and the years at which the
## considered individuals were aged 15
data(bfspell)

## Converting to STS format with alignement on calendar years
bf.sts.y &lt;- seqformat(bfspell20, from = "SPELL", to = "STS",
  id = "id", begin = "begin", end = "end", status = "states",
  process = FALSE)
head(bf.sts.y)

## Converting to STS format with alignement on ages
bf.sts.a &lt;- seqformat(bfspell20, from = "SPELL", to = "STS",
  id = "id", begin = "begin", end = "end", status = "states",
  process = TRUE, pdata = bfpdata20, pvar = c("id", "when15"),
  limit = 16)
names(bf.sts.a) &lt;- paste0("a", 15:30)
head(bf.sts.a)


## ==================================
## Examples for TSE and SPELL output
## in presence of missing values
## ==================================

data(ex1) ## STS data with missing values
## creating the state sequence object with by default
## the end missings coded as void ('%')
sqex1 &lt;- seqdef(ex1[,1:13])
as.matrix(sqex1)

## Creating state-event transition matrices
ttrans &lt;- seqetm(sqex1, method='transition')
tstate &lt;- seqetm(sqex1, method='state')

## Converting into time stamped events
seqformat(sqex1, from = "STS", to = "TSE", tevent = ttrans)
seqformat(sqex1, from = "STS", to = "TSE", tevent = tstate)

## Converting into vertical spell data
seqformat(sqex1, from = "STS", to = "SPELL", with.missing=TRUE)
seqformat(sqex1, from = "STS", to = "SPELL", with.missing=TRUE, right=NA)
seqformat(sqex1, from = "STS", to = "SPELL", with.missing=FALSE)
</code></pre>

<hr>
<h2 id='seqfpos'>Search for the first occurrence of a given element in a sequence</h2><span id='topic+seqfpos'></span>

<h3>Description</h3>

<p>Returns a vector containing the position of the first occurrence of the given element in each of the sequences in the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqfpos(seqdata, state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqfpos_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object (see <code><a href="#topic+seqdef">seqdef</a></code> function).</p>
</td></tr>
<tr><td><code id="seqfpos_+3A_state">state</code></td>
<td>
<p>the state element to search in the sequences</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the state to search for has to be passed as a character string, and must be one of the state returned by the <code><a href="#topic+alphabet">alphabet</a></code> function. If the state is not contained in a sequence, NA is returned for this sequence.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)
biofam.seq &lt;- seqdef(biofam,10:25)

## Searching for the first occurrence of state 1
## in each of the 5 first sequence of the biofam data set.
seqfpos(biofam.seq[1:5,],"1")
</code></pre>

<hr>
<h2 id='seqfposend'>End of first spell in given state</h2><span id='topic+seqfposend'></span>

<h3>Description</h3>

<p>Returns the position in the sequences of end of first spell in a given state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqfposend(seqdata, state, with.missing=FALSE, lead=0, from.seq.start=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqfposend_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object of class <code>stslist</code> as produced by <code><a href="#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="seqfposend_+3A_state">state</code></td>
<td>
<p>Element of the alphabet of <code>seqdata</code>.</p>
</td></tr>
<tr><td><code id="seqfposend_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. Should non-void missing values be considered as regular states? See <code><a href="#topic+seqdss">seqdss</a></code> and <code><a href="#topic+seqdur">seqdur</a></code>.</p>
</td></tr>
<tr><td><code id="seqfposend_+3A_lead">lead</code></td>
<td>
<p>Integer. Value to be added to the end position.</p>
</td></tr>
<tr><td><code id="seqfposend_+3A_from.seq.start">from.seq.start</code></td>
<td>
<p>Logical. Should position be computed from the start of the sequence? Default is <code>TRUE</code>. If <code>FALSE</code>, position is computed from the start of the spell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of integers giving position of end of spell in the sequences.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqfpos">seqfpos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## End of spell in further education (FE) in first 10 mvad sequences

data(mvad)
m.seq &lt;- seqdef(mvad[1:10,17:86])
seqfposend(m.seq, state="FE")

</code></pre>

<hr>
<h2 id='seqgen'>Random sequences generation</h2><span id='topic+seqgen'></span>

<h3>Description</h3>

<p>Generates random sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqgen(n, length, alphabet, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqgen_+3A_n">n</code></td>
<td>
<p>number of sequences to generate</p>
</td></tr>
<tr><td><code id="seqgen_+3A_length">length</code></td>
<td>
<p>sequences length</p>
</td></tr>
<tr><td><code id="seqgen_+3A_alphabet">alphabet</code></td>
<td>
<p>the alphabet from which the sequences are generated</p>
</td></tr>
<tr><td><code id="seqgen_+3A_p">p</code></td>
<td>
<p>an optional vector of probabilities for the states in the alphabet. Must be of the same length as the alphabet. If not specified, equal probabilities are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each sequence is generated by choosing a set of random numbers (with min=1 and max=length of the alphabet) using the <code><a href="stats.html#topic+runif">runif</a></code> function. When the probability distribution is not specified, the uniform probability distribution giving same probability to each state is used to generate the sequences.
</p>


<h3>Value</h3>

<p>a sequence object.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho (with Gilbert Ritschard for the help page)</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq &lt;- seqgen(1000,10,1:4,c(0.2,0.1,0.3,0.4))
seqstatd(seqdef(seq))
</code></pre>

<hr>
<h2 id='seqibad'>Badness index</h2><span id='topic+seqibad'></span>

<h3>Description</h3>

<p>Badness index of each sequence, i.e. the sum of undesirableness of each state weighted by the potential to integrate that state in the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  seqibad(seqdata, pow=1, with.missing=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqibad_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (<code>stslist</code>) as returned by <code><a href="#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="seqibad_+3A_pow">pow</code></td>
<td>
<p>real. Exponent applied to the position in the sequence. Higher value increase the importance of recency (see <code><a href="#topic+seqintegration">seqintegration</a></code>). Default is 1.</p>
</td></tr>
<tr><td><code id="seqibad_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state? If <code>FALSE</code> (default) missing values are ignored.</p>
</td></tr>
<tr><td><code id="seqibad_+3A_...">...</code></td>
<td>
<p>arguments such as <code>stprec</code> or <code>state.order</code> required by <code><a href="#topic+seqprecstart">seqprecstart</a></code> to determine/normalize the state undesirableness degrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each sequence, the badness is the sum of the undesirableness of each state weighted by the potential to integrate the state. As long as <code>pow</code> is strictly greater than zero, the undesirableness of states occurring at the end of the sequence get higher weights than those at the beginning. The index reaches its maximum 1 for a sequence made of a single spell in the worst state and the minimum 0 for a sequence made of a single spell is the most favorable state.
</p>


<h3>Value</h3>

<p>A vector with the badness index for each sequence.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqintegr">seqintegr</a></code>, <code><a href="#topic+seqidegrad">seqidegrad</a></code>, <code><a href="#topic+seqprecarity">seqprecarity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex1)
sx &lt;- seqdef(ex1[,1:13], right="DEL")

seqibad(sx) ## using original alphabet order
seqibad(sx, stprec=c(1,2,3,6)) ## user defined undesirableness values
seqibad(sx, with.missing=TRUE, state.order=c('A','B','C','D'))

</code></pre>

<hr>
<h2 id='seqici'>Complexity index of individual sequences</h2><span id='topic+seqici'></span>

<h3>Description</h3>

<p> Computes the complexity index, a composite measure of
sequence complexity. The index uses the number of transitions in the
sequence as a measure of the complexity induced by the state ordering
and the longitudinal entropy as a measure of the complexity induced
by the state distribution in the sequence. </p>


<h3>Usage</h3>

<pre><code class='language-R'> seqici(seqdata, with.missing=FALSE, silent=TRUE)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqici_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object as returned by the the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqici_+3A_with.missing">with.missing</code></td>
<td>
<p>if set to <code>TRUE</code>, missing status (gaps in sequences)
is handled as an additional state when computing the state
distribution and the number of transitions in the sequence.</p>
</td></tr>
<tr><td><code id="seqici_+3A_silent">silent</code></td>
<td>
<p>logical: should messages about running operations be displayed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>complexity index</em> <code class="reqn">C(s)</code> of a sequence
<code class="reqn">s</code> is
</p>
<p style="text-align: center;"><code class="reqn"> C(s)= \sqrt{\frac{q(s)}{q_{max}} \,\frac{h(s)}{h_{max}}} </code>
</p>

<p>where <code class="reqn">q(s)</code> is the number of transitions in the sequence,
<code class="reqn">q_{max}</code> the maximum number of transitions,
<code class="reqn">h(s)</code> the within entropy, and <code class="reqn">h_{max}</code> the theoretical maximum
entropy which is <code class="reqn">h_{max} = -\log 1/|A|</code> with <code class="reqn">|A|</code> the size of the alphabet.
</p>
<p>The index <code class="reqn">C(s)</code> is the geometric mean of its two normalized components and is,
therefore, itself normalized.
The minimum value of 0 can only be reached by a
sequence made of one distinct state, thus containing 0 transitions
and having an entropy of 0. The maximum 1 of <code class="reqn">C(s)</code> is reached
when the two following conditions are fulfilled: i) Each of the state
in the alphabet is present in the sequence, and the total durations
are uniform, i.e. each state occurs <code class="reqn">\ell/|A|</code> times, and ii) the number
of transitions in the sequence is <code class="reqn">\ell-1</code>, meaning that the length <code class="reqn">\ell_d</code> of the DSS is equal to the length of the sequence <code class="reqn">\ell</code>.
</p>


<h3>Value</h3>

<p>a single-column matrix of length equal to the number of sequences in
<code>seqdata</code> containing the complexity index value of each
sequence.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>
<p>Gabadinho, A., Ritschard, G., Studer, M. and Müller,
N.S. (2010). &quot;Indice de complexité pour le tri et la comparaison de
séquences catégorielles&quot;, In <em>Extraction et gestion des
connaissances (EGC 2010), Revue des nouvelles technologies de
l'information RNTI</em>. Vol. E-19, pp. 61-66.
</p>
<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqindic">seqindic</a></code>, <code><a href="#topic+seqient">seqient</a></code>, <code><a href="#topic+seqipos">seqipos</a></code>.
</p>
<p>For alternative measures of sequence complexity see <code><a href="#topic+seqST">seqST</a></code>,  <code><a href="#topic+seqivolatility">seqivolatility</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object from the mvad data set
data(mvad)
mvad.labels &lt;- c("employment", "further education", "higher education",
                    "joblessness", "school", "training")
mvad.scodes &lt;- c("EM","FE","HE","JL","SC","TR")
mvad.seq &lt;- seqdef(mvad, 15:86, states=mvad.scodes, labels=mvad.labels)

##
mvad.ci &lt;- seqici(mvad.seq)
summary(mvad.ci)
hist(mvad.ci)

## Example using with.missing argument
data(ex1)
ex1.seq &lt;- seqdef(ex1, 1:13)
seqici(ex1.seq)
seqici(ex1.seq, with.missing=TRUE)
</code></pre>

<hr>
<h2 id='seqient'>Within sequence entropies</h2><span id='topic+seqient'></span>

<h3>Description</h3>

<p>Computes normalized or non-normalized within sequence entropies</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqient(seqdata, norm=TRUE, base=exp(1), with.missing=FALSE, silent=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqient_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object as returned by the the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqient_+3A_norm">norm</code></td>
<td>
<p>logical: should the entropy be normalized? <code>TRUE</code> by default. (see details)</p>
</td></tr>
<tr><td><code id="seqient_+3A_base">base</code></td>
<td>
<p>real positive value: base of the logarithm used in the entropy formula (see details). Default is <code>exp(1)</code>, i.e., the natural logarithm is used.</p>
</td></tr>
<tr><td><code id="seqient_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: if <code>TRUE</code>, the missing state (gap in sequences) is handled as an additional state when computing the state distribution in the sequence.</p>
</td></tr>
<tr><td><code id="seqient_+3A_silent">silent</code></td>
<td>
<p>logical: should messages about running operations be displayed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The seqient function returns the Shannon entropy of each sequence in <code>seqdata</code>. The entropy of a sequence is computed using the formula
</p>
<p style="text-align: center;"><code class="reqn">h(\pi_1,\ldots,\pi_s)=-\sum_{i=1}^{s}\pi_i\log \pi_i</code>
</p>

<p>where <code class="reqn">s</code> is the size of the alphabet and <code class="reqn">\pi_i</code> the proportion of occurrences of the <code class="reqn">i</code>th state in the considered sequence. The base of the log is controlled with the <code>base</code> argument. Ba default the natural logarithm, i.e. the logarithm in base <code class="reqn">e</code>, is used. The entropy can be interpreted as the &lsquo;uncertainty&rsquo; of predicting the states in a given sequence. If all states in the sequence are the same, the entropy is equal to 0. For example, the maximum entropy for a sequence of length 12 with an alphabet of 4 states is 1.386294 and is attained when each of the four states appears 3 times.
</p>
<p>Normalization can be requested with the <code>norm=TRUE</code> option, in which case the returned value is the entropy divided by the entropy of the alphabet. The latter is an upper bound for the entropy of sequences made from this alphabet. It is exactly the maximal entropy when the sequence length is a multiple of the alphabet size. The value of the normalized entropy is independent of the chosen logarithm base.
</p>


<h3>Value</h3>

<p>a single-column matrix with an entropy value for each sequence in <code>seqdata</code>; the column length is equal to the number of sequences.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>
<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2009). Mining Sequence Data in <code>R</code> with the <code>TraMineR</code> package: A user's guide. <em>Department of Econometrics and Laboratory of Demography, University of Geneva</em>.
</p>
<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqindic">seqindic</a></code>, <code><a href="#topic+seqici">seqici</a></code>, <code><a href="#topic+seqST">seqST</a></code>, and <code><a href="#topic+seqstatd">seqstatd</a></code> for the entropy of the cross-sectional state distributions by positions in the sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24)

## Summarize and plots an histogram
## of the within sequence entropy
actcal.ient &lt;- seqient(actcal.seq)
summary(actcal.ient)
hist(actcal.ient)

## Examples using with.missing argument
data(ex1)
ex1.seq &lt;- seqdef(ex1, 1:13, weights=ex1$weights)

seqient(ex1.seq)
seqient(ex1.seq, with.missing=TRUE)
</code></pre>

<hr>
<h2 id='seqindic'>Sequence indicators</h2><span id='topic+seqindic'></span>

<h3>Description</h3>

<p>Table of per sequence values of selected indicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqindic(seqdata, indic=c("visited","trans","entr","cplx","turb2n"),
    with.missing=FALSE, ipos.args=list(), prec.args=list(), w=.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqindic_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (class <code>stslist</code>) as returned by <code><a href="#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="seqindic_+3A_indic">indic</code></td>
<td>
<p>vector of character strings. List of selected indicators among <code>"lgth"</code> (sequence length), <code>"nonm"</code> (number of non-missing elements), <code>"dlgth"</code> (number of spells), <code>"visited"</code> (number of visited states), <code>"visitp"</code> (proportion of states visites), <code>"trans"</code> (number of state changes), <code>"transp"</code> (number of state changes as a proportion of maximum possible transitions), <code>"meand"</code> (mean spell duration),  <code>"dustd"</code> (duration standard deviation),
<code>"meand2"</code> (mean spell duration taking non-visited states into account), <code>"dustd2"</code> (duration standard deviation taking non-visited states into account),
<code>"entr"</code> (longitudinal normalized entropy), <code>"nsubs"</code> (number of subsequences of the DSS sequence), <code>"volat"</code> (objective volatility), <code>"cplx"</code> (complexity index),
<code>"turb"</code> (turbulence), <code>"turbn"</code> (normalized turbulence),
<code>"turb2"</code> (turbulence taking non-visited states into account), <code>"turb2n"</code> (normalized turbulence taking non-visited states into account),
<code>"ppos"</code> (proportion of positive states), <code>"nvolat"</code> (normative volatility), <code>"vpos"</code> objective volatility of positive-negative state sequences, <code>"integr"</code> (integrative potential),  <code>"degrad"</code> (degradation), <code>"bad"</code> (badness), <code>"prec"</code> (precarity index),  <code>"insec"</code> (insecurity). Can also be <code>"all"</code>, <code>"basic"</code>, <code>"diversity"</code>, <code>"complexity"</code>,  <code>"binary"</code> or <code>"ranked"</code> that each selects a subset of the indicators. Setting <code>indic="all"</code> selects all indicators but <code>"ppos"</code>, <code>"vpos"</code>, <code>"nvolat"</code>, <code>"integr"</code>, <code>"degrad"</code>, <code>"bad"</code>, <code>"prec"</code>, and <code>"insec"</code> that require an additional argument list.</p>
</td></tr>
<tr><td><code id="seqindic_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state? If <code>FALSE</code> (default) missing values are ignored.</p>
</td></tr>
<tr><td><code id="seqindic_+3A_ipos.args">ipos.args</code></td>
<td>
<p>list: when any of <code>"ppos"</code>, <code>"nvolat"</code>, <code>"vpos"</code>, or <code>"integr"</code> is requested, the arguments passed to <code>seqipos</code> together with <code>seqdata</code> and <code>with.missing</code>. See <code><a href="#topic+seqipos">seqipos</a></code></p>
</td></tr>

<tr><td><code id="seqindic_+3A_prec.args">prec.args</code></td>
<td>
<p>list: when any of <code>"degrad"</code>, <code>"bad"</code>, <code>"prec"</code>, or <code>"insec"</code> is requested, the arguments passed to the underlying functions together with <code>seqdata</code> and <code>with.missing</code>. See <code><a href="#topic+seqprecarity">seqprecarity</a></code> and <code>link{seqibad}</code>.</p>
</td></tr>
<tr><td><code id="seqindic_+3A_w">w</code></td>
<td>
<p>real in range [0,1]: when <code>volat</code> weight coefficient passed to <code><a href="#topic+seqivolatility">seqivolatility</a></code>. Default is .5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of visited states is the number of different elements in the sequence, e.g. 2 for <code>aababba</code>. The recurrence index <code>'recu'</code> is the average number of visits of visited states, i.e. <code>Dlgth/Visited</code>, the number of spells on the number of visited states.
</p>
<p>The sequence length, number of transitions, longitudinal entropy, duration standard deviation, volatility, complexity, turbulence, degradation, badness, precarity, and insecurity are computed respectively with functions <code><a href="#topic+seqlength">seqlength</a></code>, <code><a href="#topic+seqtransn">seqtransn</a></code>, <code><a href="#topic+seqient">seqient</a></code>, <code><a href="#topic+seqivardur">seqivardur</a></code>,  <code><a href="#topic+seqivolatility">seqivolatility</a></code>, <code><a href="#topic+seqici">seqici</a></code>, <code><a href="#topic+seqST">seqST</a></code>, <code><a href="#topic+seqidegrad">seqidegrad</a></code>, <code><a href="#topic+seqibad">seqibad</a></code>,  <code><a href="#topic+seqprecarity">seqprecarity</a></code>, and  <code><a href="#topic+seqinsecurity">seqinsecurity</a></code>. The proportion of positive states, normative volatility, and integrative potential are computed with <code><a href="#topic+seqipos">seqipos</a></code>. See corresponding help pages for details.
</p>
<p>The proportion of positive states (<code>'ppos'</code>) and the normative volatility (<code>'nvolat'</code>) are the proportions of positive elements in respectively the original sequences and the DSS. They ignore the value of <code>dss</code> in the <code>ipos.args</code> list.
</p>
<p>The <code>with.missing</code> argument applies to all indicators but the length. <code>'lgth'</code> returns the length obtained with <code>with.missing=TRUE</code>, and <code>'nonm'</code> the length obtained with <code>with.missing=FALSE</code>.
</p>


<h3>Value</h3>

<p>A data frame with the selected indicators. Names are:
<br /> <code>Lght</code>: Length of the sequence
<br /> <code>NonM</code>: Number of non-missing elements
<br /> <code>Dlgth</code>: Number of spells (length of DSS)
<br /> <code>Visited</code>: Number of visited states
<br /> <code>Visitp</code>: Proportion of states visited
<br /> <code>Recu</code>: Recurrence: average number of visits to visited states
<br /> <code>Trans</code>: Number of transitions (state changes)
<br /> <code>Transp</code>: Number of state changes as a proportion of maximum number of transitions
<br /> <code>Entr</code>: Longitudinal entropy
<br /> <code>Meand</code>: Mean spell duration
<br /> <code>Dustd</code>: Duration standard deviation
<br /> <code>Meand2</code>: Mean spell duration taking non visited states into account
<br /> <code>Dustd2</code>: Duration standard deviation taking non visited states into account
<br /> <code>Nsubs</code>: Number of subsequences of the DSS sequence
<br /> <code>Volat</code>: Objective volatility
<br /> <code>Cplx</code>: Complexity
<br /> <code>Turb</code>: Turbulence
<br /> <code>Turbn</code>: Normalized turbulence
<br /> <code>Turb2</code>: Turbulence taking non visited states into account
<br /> <code>Turbn2</code>: Normalized turbulence taking non visited states into account
<br /> <code>Ppos</code>: Proportion of positive states
<br /> <code>Nvolat</code>: Normative volatility (proportion of positive spells)
<br /> <code>Vpos</code>: Objective volatility of positive-negative state sequences
<br /> <code>Integr</code>: Integrative capacity (potential)
<br /> <code>Degrad</code>: Degradation
<br /> <code>Bad</code>: Badness
<br /> <code>Prec</code>: Precarity
<br /> <code>Insec</code>: Insecurity
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqlength">seqlength</a></code>, <code><a href="#topic+seqtransn">seqtransn</a></code>, <code><a href="#topic+seqient">seqient</a></code>, <code><a href="#topic+seqivardur">seqivardur</a></code>,  <code><a href="#topic+seqivolatility">seqivolatility</a></code>, <code><a href="#topic+seqici">seqici</a></code>, <code><a href="#topic+seqST">seqST</a></code>, <code><a href="#topic+seqidegrad">seqidegrad</a></code>, <code><a href="#topic+seqibad">seqibad</a></code>,  <code><a href="#topic+seqprecarity">seqprecarity</a></code>,  <code><a href="#topic+seqinsecurity">seqinsecurity</a></code>, <code><a href="#topic+seqipos">seqipos</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex1)
sx &lt;- seqdef(ex1[,1:13], right="DEL")
print(sx, format='SPS')
seqindic(sx, indic=c("lgth","nonm","visited","turbn","cplx"))
seqindic(sx, indic=c("lgth","nonm","visited","turbn","cplx"), with.missing=TRUE)
seqindic(sx, indic=c("lgth","dlgth","ppos","integr","prec"), with.missing=TRUE,
          ipos.args=list(pos.states=c("A","B")),
          prec.args=list(state.order=c("A","B","C"), state.equiv=list(c("C","D"))))
seqindic(sx, indic=c("volat","binary"), ipos.args=list(pos.states=c("A","B")))
seqindic(sx, indic=c("basic","integr"), ipos.args=list(pos.states="D"))
</code></pre>

<hr>
<h2 id='seqintegr'>Integrative potential</h2><span id='topic+seqintegr'></span><span id='topic+seqintegration'></span>

<h3>Description</h3>

<p>Returns the index of integrative potential (capability) for each sequence, either a table with the index for each state or a vector with the index for the selected state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  seqintegr(seqdata, state=NULL, pow=1, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqintegr_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (<code>stslist</code>) as returned by <code><a href="#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="seqintegr_+3A_state">state</code></td>
<td>
<p>character string. The state for which to compute the integrative index (see Details). When <code>NULL</code> the index is computed for each state.</p>
</td></tr>
<tr><td><code id="seqintegr_+3A_pow">pow</code></td>
<td>
<p>real. Exponent applied to the position in the sequence. Higher value increase the importance of recency (see Details). Default is 1.</p>
</td></tr>
<tr><td><code id="seqintegr_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state? If <code>FALSE</code> (default) missing values are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The index of integrative potential or capability <cite>(Brzinsky-Fay, 2007, 2018)</cite> measures the capacity to integrate the selected state within the sequence, i.e. the tendency to reach the selected state and end up in it. The index is defined as the sum of the position numbers occupied by the selected state in the sequence over the sum of all position numbers. Formally, for a sequence <code class="reqn">s</code> of length <code class="reqn">L</code>, and numbering the positions <code class="reqn">i</code> from 1 to <code class="reqn">L</code>, the index is
</p>
<p style="text-align: center;"><code class="reqn">integr = \sum_{(i | s_i = state)} i^{pow} / \sum_i i^{pow}</code>
</p>

<p>where <code class="reqn">state</code> is the selected state. This same index has also been independently developed by <cite>Manzoni and Mooi-Reci (2018)</cite> under the name of quality index.
</p>
<p>The recency exponent <code class="reqn">pow</code> permits to control the focus given on the latest positions in the sequence. The higher <code>pow</code>, the higher the importance of the last positions relative to the first ones.
</p>
<p>When <code>with.missing = FALSE</code>, the index is obtained by using the sum of the positions numbers of the non-missing elements as denominator. To compute the index for the missing state, <code>with.missing</code> should be set as <code>TRUE</code>.
</p>
<p>For capability to integrate a set of states see <code><a href="#topic+seqipos">seqipos</a></code>.
</p>


<h3>Value</h3>

<p>when <code>state=NULL</code>, a numeric matrix with a row for each sequence and a column by state. When a state is provides, a single column.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Brzinsky-Fay, C. (2007) Lost in Transition? Labour Market Entry Sequences of School Leavers in Europe, <em>European Sociological Review</em>, 23(4). <a href="https://doi.org/10.1093/esr/jcm011">doi:10.1093/esr/jcm011</a>
</p>
<p>Brzinsky-Fay, C. (2018) Unused Resources: Sequence and Trajectory Indicators. International Symposium on Sequence Analysis and Related Methods, Monte Verita, TI, Switzerland, October 10-12, 2018.
</p>
<p>Manzoni, A and I. Mooi-Reci (2018) Measuring Sequence Quality, in Ritschard and Studer (eds), <em>Sequence Analysis and Related Approaches. Innovative Methods and Applications</em>, Springer, 2018, pp 261-278.
</p>
<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqipos">seqipos</a></code>, <code><a href="#topic+seqivolatility">seqivolatility</a></code>, <code><a href="#topic+seqindic">seqindic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex1)
sx &lt;- seqdef(ex1[,1:13], right="DEL")

seqintegr(sx)
seqintegr(sx, with.missing=TRUE)
seqintegr(sx, state="B")
seqintegr(sx, state="B", pow=1.5)

</code></pre>

<hr>
<h2 id='seqipos'>Indicators for binary sequences of positive and negative states.</h2><span id='topic+seqipos'></span>

<h3>Description</h3>

<p>Indicators for the underlying binary sequences of positive and negative states.
Possible indicators are the proportion of positive states within each sequence, i.e. of positive spells if computed on the sequences of distinct successive states (DSS), objective volatility of the binary sequences, and capacity to integrate a positive state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  seqipos(seqdata, dss=NULL, pos.states=NULL, neg.states=NULL, index="share",
     pow=1, w=.5, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqipos_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (<code>stslist</code>) as returned by <code><a href="#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="seqipos_+3A_dss">dss</code></td>
<td>
<p>logical. Should the proportion be computed inside the DSS sequences? Defaults to <code>TRUE</code> when <code>index="share"</code> and to <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="seqipos_+3A_pos.states">pos.states</code></td>
<td>
<p>vector of positive states.</p>
</td></tr>
<tr><td><code id="seqipos_+3A_neg.states">neg.states</code></td>
<td>
<p>vector of negative states.</p>
</td></tr>
<tr><td><code id="seqipos_+3A_index">index</code></td>
<td>
<p>character string. One of <code>"share"</code> (proportion of positive states or spells), <code>"volatility"</code> (objective volatility), or <code>"integr"</code> (capability to integrate a positive state). See Details. Default is <code>"share"</code>.</p>
</td></tr>
<tr><td><code id="seqipos_+3A_pow">pow</code></td>
<td>
<p>real. Recency exponent passed to <code><a href="#topic+seqintegr">seqintegr</a></code>. Only used when <code>index="integr"</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="seqipos_+3A_w">w</code></td>
<td>
<p>real in range [0,1]. Relative weight of proportion of visited states in volatility (see <code><a href="#topic+seqivolatility">seqivolatility</a></code>). Only used when <code>index="volatility"</code>. Default is .5.</p>
</td></tr>
<tr><td><code id="seqipos_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state? If <code>FALSE</code> (default) missing values are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function transforms the provided state sequences into binary sequences of positive and negative states. When <code>dss = TRUE</code>, the counts of positive and negative elements give the number of positive and negative spells. The binary state sequence object is returned as an attribute.
</p>
<p>When <code>neg.states=NULL</code>, states not listed on the <code>pos.states</code> argument are considered as negative and conversely when <code>pos.states=NULL</code>. When <code>with.missing=TRUE</code>, the missing state <code>nr</code> will be considered as positive if included in the <code>pos.states</code> list or as negative if in <code>neg.states</code>.  When <code>with.missing=FALSE</code> (default) missing states are ignored. However, when missing values appear within a spell, such as in AA*ABB, the spell is split into two consecutive spells in a same state. For the example we would have AAB, i.e. if A is positive and B negative, a proportion of 2/3 of positive spells.
</p>
<p>When both <code>pos.states</code> and <code>neg.states</code> are provided, states of the alphabet (including the <code>nr</code> code when <code>with.missing=TRUE</code>) that belong nor to <code>pos.states</code> nor to <code>neg.states</code> are ignored.
</p>
<p>For <code>index="share"</code>, letting <code class="reqn">npos</code> be the number of positive states and <code class="reqn">nneg</code> the number of negative states in the sequence, the function returns the value of <code class="reqn">npos/(npos + nneg)</code> for each sequence. With <code>dss=TRUE</code>, this is the normative volatility of Brzinsky-Fay (2007,2018).
</p>
<p>For <code>index="volatility"</code>, the function returns the objective volatility of the binary sequences. See <code><a href="#topic+seqivolatility">seqivolatility</a></code>.
</p>
<p>For <code>index="integr"</code>, the function returns the index of integrative potential for the positive state. See <code><a href="#topic+seqintegr">seqintegr</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of <br />
- when <code>index="share"</code>, the proportion of positive states (or spells) within each sequence;<br />
- when <code>index="volatility"</code>, the objective volatility of the binary sequences;<br />
- when <code>index="integration"</code>, the index of integration into a positive state.<br />
The binary sequence as an attribute <code>sbinary</code>.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Brzinsky-Fay, C. (2007) Lost in Transition? Labour Market Entry Sequences of School Leavers in Europe, <em>European Sociological Review</em>, 23(4). <a href="https://doi.org/10.1093/esr/jcm011">doi:10.1093/esr/jcm011</a>
</p>
<p>Brzinsky-Fay, C. (2018) Unused Resources: Sequence and Trajectory Indicators. International Symposium on Sequence Analysis and Related Methods, Monte Verita, TI, Switzerland, October 10-12, 2018.
</p>
<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqindic">seqindic</a>, <a href="#topic+seqintegr">seqintegr</a>, <a href="#topic+seqivolatility">seqivolatility</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex1)
sx &lt;- seqdef(ex1[,1:13], right="DEL")
nr &lt;- attr(sx,'nr') ## code for missing values

seqipos(sx, pos.states=c("A","B"))
seqipos(sx, pos.states=c("A","B"), with.missing=TRUE)

## ignoring state "D"
seqipos(sx, pos.states=c("A","B"), neg.states=c("C",nr), with.missing=TRUE)

seqipos(sx, pos.states=c("A","B"), dss=FALSE)
seqipos(sx, pos.states=c("A","B",nr), dss=FALSE, with.missing=TRUE)

seqipos(sx, pos.states=c("A","B"), index="volatility")
seqipos(sx, pos.states=c("A","B"), index="integr")

## retrieving the binary sequences
ip &lt;- seqipos(sx, pos.states=c("A","B"))
attr(ip,"sbinary")
ip &lt;- seqipos(sx, pos.states=c("A","B"), with.missing=TRUE)
attr(ip,"sbinary")

</code></pre>

<hr>
<h2 id='seqistatd'>State frequencies in each individual sequence</h2><span id='topic+seqistatd'></span>

<h3>Description</h3>

<p>Returns the state frequencies (total durations) for each sequence in the sequence object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqistatd(seqdata, with.missing=FALSE, prop=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqistatd_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object (see <code><a href="#topic+seqdef">seqdef</a></code> function).</p>
</td></tr>
<tr><td><code id="seqistatd_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: if set as <code>TRUE</code>, total durations are also computed for the missing status (gaps in the sequences). See <a href="#topic+seqdef">seqdef</a> on options for handling missing values when creating sequence objects.</p>
</td></tr>
<tr><td><code id="seqistatd_+3A_prop">prop</code></td>
<td>
<p>logical: if <code>TRUE</code>, proportions of time spent in each state are returned instead of absolute values. This option is specially useful when sequences contain missing states, since the sum of the state durations may not be the same for all sequences.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>
<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24)
seqistatd(actcal.seq[1:10,])

## Example using "with.missing" argument
data(ex1)
ex1.seq &lt;- seqdef(ex1, 1:13, weights=ex1$weights)

seqistatd(ex1.seq)
seqistatd(ex1.seq, with.missing=TRUE)

</code></pre>

<hr>
<h2 id='seqivardur'>Variance of spell durations in individual sequences</h2><span id='topic+seqivardur'></span><span id='topic+print.seqivardur'></span>

<h3>Description</h3>

<p>Variance of spell durations of individual state sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqivardur(seqdata, type=1, with.missing=FALSE)

## S3 method for class 'seqivardur'
print(x, stat='var', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqivardur_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (<code>stslist</code>) as returned by <code><a href="#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="seqivardur_+3A_type">type</code></td>
<td>
<p>either 1 or 2. The default <code>type=1</code> ignores non visited states. Type 2 takes into account the 0-time spent in non-visited states (see Details).</p>
</td></tr>
<tr><td><code id="seqivardur_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state? If <code>FALSE</code> (default) missing values are ignored.</p>
</td></tr>
<tr><td><code id="seqivardur_+3A_x">x</code></td>
<td>
<p>an outcome of <code>seqivardur</code>.</p>
</td></tr>
<tr><td><code id="seqivardur_+3A_stat">stat</code></td>
<td>
<p>string or vector of strings. Duration statistic to be printed. Either <code>'mean'</code> (mean duration), <code>'std'</code> (standard deviation), <code>'var'</code> (variance), <code>'vmax'</code> (maximum variance for number of spells), or <code>'all'</code>. Default is <code>'var'</code>.</p>
</td></tr>
<tr><td><code id="seqivardur_+3A_...">...</code></td>
<td>
<p>further arguments such as <code>digits</code> passed to the next <code><a href="base.html#topic+print">print</a></code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned variance is a population variance, i.e. the sum of squares divided by the number of terms.
</p>
<p>When <code>type=1</code>, this is the variance of the observed spells in the sequence. When <code>type=2</code>, in addition to the observed spells one spell of length 0 is considered for each non-visited state. The mean duration is computed the same way.
</p>


<h3>Value</h3>

<p>A numeric vector with the variance of spell duration of each sequence.
</p>
<p>The returned object has two attributes:
</p>
<table>
<tr><td><code>vmax</code></td>
<td>
<p>the maximum value that the variance of each sequence could reach given its number of spells.</p>
</td></tr>
<tr><td><code>meand</code></td>
<td>
<p>the mean spell duration of each sequence.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdur">seqdur</a></code>, <code><a href="#topic+seqindic">seqindic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sq.dat &lt;- c('AAAA','AAAC','ABC','ABAA','AC')
sq &lt;- seqdef(seqdecomp(sq.dat, sep=''), right=NA)

seqivardur(sq, type=1)
seqivardur(sq, type=1, with.missing=TRUE)
vd2 &lt;- seqivardur(sq, type=2)
print(vd2, stat='all')
vd2m &lt;- seqivardur(sq, type=2, with.missing=TRUE)
print(vd2m, stat=c('var','vmax'))

</code></pre>

<hr>
<h2 id='seqivolatility'>Volatility of individual state sequences</h2><span id='topic+seqivolatility'></span>

<h3>Description</h3>

<p>Returns Brzinsky-Fay's objective volatility of each sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  seqivolatility(seqdata, w=.5, with.missing=FALSE, adjust=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqivolatility_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (<code>stslist</code>) as returned by <code><a href="#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="seqivolatility_+3A_adjust">adjust</code></td>
<td>
<p>Logical. Should the indicator be adjusted such that it can reach its bounds 0 and 1. Deafult is <code>TRUE</code> (see Details).</p>
</td></tr>
<tr><td><code id="seqivolatility_+3A_w">w</code></td>
<td>
<p>Real in the range [0, 1]. Default is 0.5. Weight given to the proportion of states visited (see Details).</p>
</td></tr>
<tr><td><code id="seqivolatility_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical: should non-void missing values be treated as a regular state? If <code>FALSE</code> (default) missing values are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (objective) volatility is the weighted average between the proportion <code class="reqn">pvisited</code> of states visited and the frequency <code class="reqn">ftrans</code> of transitions (state changes). Formally,
</p>
<p style="text-align: center;"><code class="reqn">volatility = w \cdot pvisited + (1-w) \cdot ftrans</code>
</p>

<p>The proportion of states visited is computed as <code class="reqn">(visited - 1)/(|a| - 1</code>) when <code>adjsut=TRUE</code> and as <code class="reqn">visited / |a|</code> when <code>adjsut=FALSE</code>. Here, <code class="reqn">visited</code> is the number of states visited and <code class="reqn">|a|</code> the size of the alphabet.
</p>
<p>The frequency of transition is <code class="reqn">ftrans = \frac{transn}{max.transn}</code> where
<code class="reqn">transn</code> is the number of transitions (state changes) within the sequence, and <code class="reqn">max.transn</code> the maximum possible transitions in the sequence.
</p>
<p>For the normative volatility, see <code><a href="#topic+seqipos">seqipos</a></code>. For alternative measures of sequence complexity see <code><a href="#topic+seqST">seqST</a></code>,  <code><a href="#topic+seqici">seqici</a></code>, <code><a href="#topic+seqindic">seqindic</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector with the volatility of each sequence.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Brzinsky-Fay, C. Unused Resources: Sequence and Trajectory Indicators. International Symposium on Sequence Analysis and Related Methods, Monte Verita, TI, Switzerland, Oct 10-11, 2018
</p>
<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqintegr">seqintegr</a></code>, <code><a href="#topic+seqipos">seqipos</a></code>, <code><a href="#topic+seqindic">seqindic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex1)
sx &lt;- seqdef(ex1[,1:13], right="DEL")

seqivolatility(sx)
seqivolatility(sx, adjust=FALSE)
seqivolatility(sx, with.missing=TRUE)
seqivolatility(sx, w=.7, with.missing=TRUE)

</code></pre>

<hr>
<h2 id='seqlegend'>Plot a legend for the states in a sequence object</h2><span id='topic+seqlegend'></span>

<h3>Description</h3>

<p>Plots a legend for the states in a sequence object. Useful if several graphics are plotted together and only one legend is necessary. Unless specified by the user, the <em>cpal</em> and <em>labels</em> attributes of the sequence object are used for the colors and text appearing in the legend (see <code><a href="#topic+seqdef">seqdef</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqlegend(seqdata, with.missing = "auto", cpal = NULL, missing.color = NULL,
  ltext = NULL, position = "topleft", cex = 1, boxes=TRUE, fontsize, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqlegend_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (of class <code>stslist</code>) as returned by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqlegend_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: if set to <code>"auto"</code> (default), a legend for the missing state is added automatically if one or more of the sequences in seqdata contains a missing state. If <code>TRUE</code> a legend for the missing state is added in any case. Setting to <code>FALSE</code> omits the legend for the missing state.</p>
</td></tr>
<tr><td><code id="seqlegend_+3A_cpal">cpal</code></td>
<td>
<p>alternative color palette to use for the states. If user specified, a vector of colors with number of elements equal to the number of distinct states. By default, the 'cpal' attribute of the 'seqdata' sequence object is used (see <code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqlegend_+3A_missing.color">missing.color</code></td>
<td>
<p>alternative color for representing missing values inside the sequences. By default, this color is taken from the &quot;missing.color&quot; attribute of the sequence object being plotted.</p>
</td></tr>
<tr><td><code id="seqlegend_+3A_ltext">ltext</code></td>
<td>
<p>optional description of the states to appear in the legend. Must be a vector of character strings with number of elements equal to the number of distinct states. If unspecified, the 'labels' attributes of the 'seqdata' sequence object is used (see <code><a href="#topic+seqdef">seqdef</a></code>). </p>
</td></tr>
<tr><td><code id="seqlegend_+3A_position">position</code></td>
<td>
<p>the position of the legend in the graphic area. For accepted values, see the <code>x</code> argument of <code><a href="graphics.html#topic+legend">legend</a></code>. Defaults to <code>"topleft"</code>.</p>
</td></tr>
<tr><td><code id="seqlegend_+3A_cex">cex</code></td>
<td>
<p>size of the font for the labels. A value less than 1 decreases the font size, a value greater than 1 increases the font size. Defaults to 1.</p>
</td></tr>
<tr><td><code id="seqlegend_+3A_boxes">boxes</code></td>
<td>
<p>logical: should the colors be displayed in small square boxes? Default is <code>TRUE</code>. If <code>FALSE</code>, colors are shown using small line segments of by default length .4 and width 15. The latter can be changed by means of the <code>lwd</code> and <code>seg.len</code> <code><a href="graphics.html#topic+par">par</a></code> arguments.
</p>
</td></tr>
<tr><td><code id="seqlegend_+3A_fontsize">fontsize</code></td>
<td>
<p>Deprecated. Use <code>cex</code> instead.</p>
</td></tr>
<tr><td><code id="seqlegend_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the <code><a href="graphics.html#topic+legend">legend</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code>, <code>legend</code>, or <code>col</code> arguments are provided, they supersede respectively the <code>position</code>, <code>ltext</code>, and <code>cpal</code> values.
</p>


<h3>Value</h3>

<p>Coordinate values returned by the <code><a href="graphics.html#topic+legend">legend</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading the 'actcal' example data set
## and defining a sequence object with
## activity statuses from Jan. to Dec. 2000 (columns 13 to 24)
## of first 100 cases.
data(actcal)
actcal.seq &lt;- seqdef(actcal[1:100,13:24],
	labels=c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work"))

## Plotting the sequences frequency,
## the states distribution
## and the legend
par(mfrow=c(2,2))
seqIplot(actcal.seq, sortv="from.start", with.legend=FALSE)
seqfplot(actcal.seq, pbarw=TRUE, with.legend=FALSE)
seqdplot(actcal.seq, with.legend=FALSE)
seqlegend(actcal.seq)
</code></pre>

<hr>
<h2 id='seqlength'>Sequence length</h2><span id='topic+seqlength'></span>

<h3>Description</h3>

<p>Returns the length of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqlength(seqdata, with.missing=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqlength_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object created with the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqlength_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state?
Default is <code>TRUE</code>.
If <code>FALSE</code> missing values are considered as void.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of a sequence is computed by counting its number of non void elements, i.e. including non-void missing values. The <code>seqlength</code> function returns a vector containing the length of each sequence in the provided sequence object.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqlength.align">seqlength.align</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading the 'famform' example data set
data(famform)

## Defining a sequence object with the 'famform' data set
ff.seq &lt;- seqdef(famform)

## Retrieving the length of the sequences
## in the ff.seq sequence object
seqlength(ff.seq)
</code></pre>

<hr>
<h2 id='seqlength.align'>Align sequence length across domains</h2><span id='topic+seqlength.align'></span>

<h3>Description</h3>

<p>Sets lengths of sequences of multiple domains as the shortest lengths across domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqlength.align(seq.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqlength.align_+3A_seq.list">seq.list</code></td>
<td>
<p>list of sequence objects (of class <code>stslist</code>) created with the <code><a href="#topic+seqdef">seqdef</a></code> function. The sequence objects must all have the same number of sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sequences in the sequence objects are assumed to be ordered conformably. The length of the <code class="reqn">i</code>-th sequence in each domain is set as the length of the shortest <code class="reqn">i</code>-th sequence of the domains. The reduction of length is done by filling end positions with voids.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqlength">seqlength</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the ex1 data set with sequences of different length
data(ex1)
s1 &lt;- seqdef(ex1[,1:13])
seqlength(s1)

## sequence object s2 with a shorter 1st sequence

s2 &lt;- s1
s2[1,8:13] &lt;- attr(s2,"void")
seqlength(s2)

## aligning sequence lengths
seqlength.align(list(s1,s2))

</code></pre>

<hr>
<h2 id='seqLLCP'>Compute the length of the longest common prefix of two sequences</h2><span id='topic+seqLLCP'></span>

<h3>Description</h3>

<p>Returns the length of the longest common prefix of two sequences. This attribute is described in <cite>Elzinga (2008)</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqLLCP(seq1, seq2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqLLCP_+3A_seq1">seq1</code></td>
<td>
<p>a sequence from a sequence object.</p>
</td></tr>
<tr><td><code id="seqLLCP_+3A_seq2">seq2</code></td>
<td>
<p>a sequence from a sequence object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer being the length of the longest common prefix of the two sequences.</p>


<h3>References</h3>

<p>Elzinga, Cees H. (2008). Sequence analysis: Metric representations of categorical time
series. <em>Technical Report</em>, Department of Social Science Research Methods, Vrije Universiteit, Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdist">seqdist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(famform)
famform.seq &lt;- seqdef(famform)

## The LCP's length between sequences 1 and 2
## in the famform sequence object is 2
seqLLCP(famform.seq[1,],famform.seq[2,])
</code></pre>

<hr>
<h2 id='seqLLCS'>Compute the length of the longest common subsequence of two sequences</h2><span id='topic+seqLLCS'></span>

<h3>Description</h3>

<p>Returns the length of the longest common subsequence of two sequences. This attribute is described in <cite>Elzinga (2008)</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqLLCS(seq1, seq2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqLLCS_+3A_seq1">seq1</code></td>
<td>
<p>a sequence from a sequence object</p>
</td></tr>
<tr><td><code id="seqLLCS_+3A_seq2">seq2</code></td>
<td>
<p>a sequence from a sequence object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer being the length of the longest common subsequence of the two sequences.</p>


<h3>References</h3>

<p>Elzinga, Cees H. (2008). Sequence analysis: Metric representations of categorical time
series. <em>Technical Report</em>, Department of Social Science Research Methods, Vrije Universiteit, Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdist">seqdist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>LCS.ex &lt;- c("S-U-S-M-S-U", "U-S-SC-MC", "S-U-M-S-SC-UC-MC")
LCS.ex &lt;- seqdef(LCS.ex)
seqLLCS(LCS.ex[1,],LCS.ex[3,])
</code></pre>

<hr>
<h2 id='seqlogp'>
Logarithm of the probabilities of state sequences
</h2><span id='topic+seqlogp'></span>

<h3>Description</h3>

<p>Logarithm of the probabilities of state sequences. The probability of a sequence is defined as the product of the probabilities of the successive states in the sequence. State probabilities can either be provided or be computed with one of a few basic models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqlogp(seqdata, prob="trate", time.varying=TRUE,
        begin="freq", weighted=TRUE, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqlogp_+3A_seqdata">seqdata</code></td>
<td>
<p>A state sequence object as produced by <code><a href="#topic+seqdef">seqdef</a></code>.</p>
</td></tr>
<tr><td><code id="seqlogp_+3A_prob">prob</code></td>
<td>
<p>String or numeric array. If a string, either <code>"trate"</code> or <code>"freq"</code> to select a probability model to compute the state probabilities. If a numeric array, a matrix or 3-dimensional array of transition probabilities. See details.</p>
</td></tr>
<tr><td><code id="seqlogp_+3A_time.varying">time.varying</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the probabilities (transitions or frequencies) are computed separately for each time <code class="reqn">t</code> point.</p>
</td></tr>
<tr><td><code id="seqlogp_+3A_begin">begin</code></td>
<td>
<p>String of numeric vector. Distribution used to determine the probability of the first state. If a vector, the probabilites to use. If a string, either <code>"freq"</code> or <code>global.freq</code>. With <code>freq</code>, the observed distribution at first position is used. If <code>global.freq</code>, the overall distribution is used. Default is <code>"freq"</code>.</p>
</td></tr>
<tr><td><code id="seqlogp_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Should we account for the weights when present in <code>seqdata</code>? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="seqlogp_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. Should non void missing states be treated as regular values? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence likelihood <code class="reqn">P(s)</code> is defined as the product of the probability with which each of its observed successive state is supposed to occur at its position.
Let <code class="reqn">s=s_{1}s_{2} \cdots s_{\ell}</code> be a sequence of length <code class="reqn">\ell</code>. Then
</p>
<p style="text-align: center;"><code class="reqn">
	P(s)=P(s_{1},1) \cdot P(s_{2},2) \cdots P(s_{\ell},\ell)
</code>
</p>

<p>with <code class="reqn">P(s_{t},t)</code> the probability to observe state <code class="reqn">s_t</code> at position <code class="reqn">t</code>.
</p>
<p>There are different ways to determine the state probabilities <code class="reqn">P(s_t,t)</code>. The method is chosen by means of the <code>prob</code> argument.
</p>
<p>With <code>prop = "freq"</code>, the probability <code class="reqn">P(s_{t},t)</code> is set as the observed relative frequency at position <code class="reqn">t</code>. In that case, the probability does not depend on the probabilities of transition. By default (<code>time.varying=TRUE</code>), the relative frequencies are computed separately for each position <code class="reqn">t</code>. With <code>time.varying=FALSE</code>, the relative frequencies are computed over the entire covered period, i.e. the same frequencies are used at each <code class="reqn">t</code>.
</p>
<p>Option <code>prop = "trate"</code> assumes that each <code class="reqn">P(s_t,t)</code>, <code class="reqn">t&gt;1</code> is set as the transition probability <code class="reqn">p(s_t|s_{t-1})</code>. The state distribution used to determine the probability of the first state <code class="reqn">s_1</code> is set by means of the <code>begin</code> argument (see below). With the default <code>time.varying=TRUE</code>), the transition probabilities are estimated separately at each position, yielding an array of transition matrices. With <code>time.varying=FALSE</code>, the transition probabilities are assumed to be constant over the successive positions and  are estimated over the entire sequence duration, i.e. from all observed transitions.
</p>
<p>Custom transition probabilities can be provided by passing a matrix or a 3-dimensional array as <code>prob</code> argument.
</p>
<p>The distribution used at the first position is set by means of the <code>begin</code> argument. You can either pass the distribution (probabilities of the states in the alphabet including the missing value when <code>with.missing=TRUE</code>), or specify <code>"freq"</code> for the observed distribution at the first position, or <code>global.freq</code> for the overall state distribution.
</p>
<p>The likelihood <code class="reqn">P(s)</code> being generally very small, <code>seqlogp</code> returns <code class="reqn">-\log P(s)</code>. The latter quantity is minimal when <code class="reqn">P(s)</code> is equal to <code class="reqn">1</code>.
</p>


<h3>Value</h3>

<p>Vector of the negative logarithm <code class="reqn">-\log P(s)</code> of the sequence probabilities.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer, Alexis Gabadinho, and Gilbert Ritschard</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating the sequence objects using weigths
data(biofam)
biofam.seq &lt;-  seqdef(biofam, 10:25, weights=biofam$wp00tbgs)

## Computing sequence probabilities
biofam.prob &lt;- seqlogp(biofam.seq)
## Comparing the probability of each cohort
cohort &lt;- biofam$birthyr&gt;1940
boxplot(biofam.prob~cohort)

</code></pre>

<hr>
<h2 id='seqmaintokens'>Indexes of most frequent tokens
</h2><span id='topic+seqmaintokens'></span>

<h3>Description</h3>

<p>Extracts the indexes of the most frequent token, either the <code>k</code> most frequent tokens or the tokens that occur on average more than <code>mint</code> times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqmaintokens(seqdata, k=8L, mint=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqmaintokens_+3A_seqdata">seqdata</code></td>
<td>
<p>state sequence <code>stslist</code> object as produced by <code><a href="#topic+seqdef">seqdef</a></code>.
</p>
</td></tr>
<tr><td><code id="seqmaintokens_+3A_k">k</code></td>
<td>
<p>Integer. Number of main states.
</p>
</td></tr>
<tr><td><code id="seqmaintokens_+3A_mint">mint</code></td>
<td>
<p>Real. Minimal mean number of occurrences per sequence.
</p>
</td></tr>
<tr><td><code id="seqmaintokens_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+seqmeant">seqmeant</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>mint</code> is <code>NULL</code>, indexes of the <code>k</code> most frequent tokens. Otherwise, indexes of tokens occurring on average more than <code>tmin</code> times are returned as long as their number does not exceed <code>k</code>. If more than <code>k</code>, indexes of the <code>k</code> most frequent are returned.
</p>


<h3>Value</h3>

<p>Vector of indexes of the most frequent tokens repecting order of the alphabet.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqmeant">seqmeant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)
b.lab &lt;- c("Parent",
           "Left",
           "Married",
           "Left+Marr",
           "Child",
           "Left+Child",
           "Left+Marr+Child",
           "Divorced"
)
b.short &lt;- c("P","L","M","L+M","C","L+C","L+M+C","D")
set.seed(5)
cases &lt;- sample(nrow(biofam),100)
b.seq &lt;- seqdef(biofam[cases,10:25], labels=b.lab, states=b.short,
                weights=biofam[cases,"wp00tbgs"])

## Tokens occurring at least once on average
alphabet(b.seq)[seqmaintokens(b.seq, mint=1)]
#[1] "P"     "L"     "L+M"   "L+M+C"

## Three more frequent tokens
main.tokens &lt;- seqmaintokens(b.seq, k=3)
## Labels of main tokens
attr(b.seq,"labels")[main.tokens]
#[1] "Parent"  "Left"    "Left+Marr+Child"
## Colors of main tokens
cpal(b.seq)[main.tokens]
#[1] "#7FC97F" "#BEAED4" "#BF5B17"</code></pre>

<hr>
<h2 id='seqMD'>Multidomain sequences</h2><span id='topic+seqMD'></span><span id='topic+seqdistmc'></span>

<h3>Description</h3>

<p>Build multidomain (MD) sequences of combined individual domain states (expanded alphabet), derive multidomain indel and substitution costs from domain costs by means of an additive trick (CAT), and compute OM pairwise distances using CAT costs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqMD(channels,
  method=NULL,
  norm="none",
  indel="auto",
  sm=NULL,
  with.missing=NULL,
  full.matrix=TRUE,
  link="sum",
  cval=2,
  miss.cost=2,
  cweight=NULL,
  what="MDseq",
  ch.sep="+",
  fill.with.miss=TRUE
  )

seqdistmc(channels, what="diss", ch.sep="@@@@TraMineRSep@@@@", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqMD_+3A_channels">channels</code></td>
<td>
<p>A list of domain state sequence <code>stslist</code> objects defined
with the <code><a href="#topic+seqdef">seqdef</a></code> function, each state sequence object corresponding
to a domain.</p>
</td></tr>
<tr><td><code id="seqMD_+3A_method">method</code></td>
<td>
<p>String. Default: <code>NULL</code>. Dissimilarity measure between sequences.
When <code>what="diss"</code>, must be one of <code>"OM"</code> (Optimal Matching),
<code>"HAM"</code> (Hamming distance), or <code>"DHD"</code> (Dynamic Hamming distance). Otherwise, ignored. Can also be <code>"LCS"</code> (Longest common subsequence), but see details. </p>
</td></tr>
<tr><td><code id="seqMD_+3A_norm">norm</code></td>
<td>

<p>String.
Default: <code>"none"</code>.
The normalization method to use. See <code><a href="#topic+seqdist">seqdist</a></code>. Ignored if <code>what</code> is not <code>"diss"</code>.
</p>
</td></tr>
<tr><td><code id="seqMD_+3A_indel">indel</code></td>
<td>
<p>Double, vector of doubles, or list with an insertion/deletion cost or a vector of state dependent indel costs for each domain. Can also be <code>"auto"</code> (default), in which case the indel cost of each domain is automatically set in accordance with the <code>sm</code> value of the domain. See <code>indel</code> argument of <code><a href="#topic+seqdist">seqdist</a></code>.
</p>
</td></tr>
<tr><td><code id="seqMD_+3A_sm">sm</code></td>
<td>
<p>A list with a substitution-cost matrix for each domain
or a list of method names for generating the domain substitution costs
(see <code><a href="#topic+seqcost">seqcost</a></code>). Ignored when <code>method="LCS"</code>.
</p>
</td></tr>
<tr><td><code id="seqMD_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical, vector of logical, or <code>NULL</code> (default). See <code><a href="#topic+seqdist">seqdist</a></code> and <code><a href="#topic+seqcost">seqcost</a></code>.
</p>
</td></tr>
<tr><td><code id="seqMD_+3A_full.matrix">full.matrix</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the full distance matrix between MD sequences is returned.
If <code>FALSE</code>, an object of class <code><a href="stats.html#topic+dist">dist</a></code> is returned.
</p>
</td></tr>
<tr><td><code id="seqMD_+3A_link">link</code></td>
<td>
<p>Character string. One of <code>"sum"</code> or <code>"mean"</code>. Method to compute the &quot;link&quot;
between domains. Default is to sum substitution and indel costs.
</p>
</td></tr>
<tr><td><code id="seqMD_+3A_cval">cval</code></td>
<td>
<p>Double. Domain substitution cost for <code>"CONSTANT"</code> matrix, see <code><a href="#topic+seqcost">seqcost</a></code>.</p>
</td></tr>
<tr><td><code id="seqMD_+3A_miss.cost">miss.cost</code></td>
<td>
<p>Double. Cost to substitute missing values at domain level, see <code><a href="#topic+seqcost">seqcost</a></code>.</p>
</td></tr>
<tr><td><code id="seqMD_+3A_cweight">cweight</code></td>
<td>
<p>A vector of domain weights. Default is 1 (same weight for each domain).</p>
</td></tr>
<tr><td><code id="seqMD_+3A_what">what</code></td>
<td>
<p>Character string. What output should be returned? One of <code>"MDseq", "cost", "diss"</code>. The deprecated value <code>what="sm"</code> is treated as <code>what="cost"</code>. <code>MDseq</code> returns the multidomain sequences expressed in terms of the expanded alphabet, <code>"cost"</code> the CAT costs, and &quot;diss&quot; the CAT-based multidomain distances.</p>
</td></tr>
<tr><td><code id="seqMD_+3A_ch.sep">ch.sep</code></td>
<td>
<p>Character string. Separator used for building state names of the expanded alphabet.</p>
</td></tr>
<tr><td><code id="seqMD_+3A_fill.with.miss">fill.with.miss</code></td>
<td>
<p>Logical. Should shorter domain sequences be filled with missings to match sequence lengths across domains? Applies only to domains that already have missings.</p>
</td></tr>
<tr><td><code id="seqMD_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>seqMD</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>seqMD</code> function builds MD sequences by combining the domain states. When <code>what="cost"</code>, it derives multidomain indel and substitution costs from the indel and substitution costs of each domain by means of the cost additive trick (CAT) (<cite>Ritschard et al., 2023</cite>, <cite>Pollock, 2007</cite>). When <code>what="diss"</code>, it computes multidomain distances using the CAT multidomain costs. The available metrics (see <code>method</code> argument) are optimal matching (<code>"OM"</code>), Hamming distance (<code>"HAM"</code>), and Dynamic Hamming Distance (<code>"DHD"</code>). If <code>method="LCS"</code>, distances are obtained with OM using CAT costs derived from domain indel and sm costs of respectively 1 and 2 (i.e. inputted <code>indel</code> and <code>sm</code> are ignored).  For other edit distances, extract the combined state sequence object (by setting <code>what="MDseq"</code>) and the CAT-multidomain substitution and indel costs (by setting <code>what="cost"</code>). Then use these outcomes as input in a call to <code>seqdist</code>.  See <code><a href="#topic+seqdist">seqdist</a></code> for more information about available distance measures.
</p>
<p>Normalization may be useful when dealing with sequences that are not all of the same length. For details on the applied normalization, see <code><a href="#topic+seqdist">seqdist</a></code>.
</p>
<p>Sequences lengths are supposed to match across domains. If <code>fill.with.miss</code> is <code>TRUE</code> and the i-th sequence is shorter in one domain than the longest i-th sequence, it will, when constructing the i-th MD sequence, be filled with missing values to adapt its length to that of the longest sequence. However, this applies only for domain that already have missings, i.e., domains with a corresponding <code>with.missing</code> value set as <code>TRUE</code>. </p>


<h3>Value</h3>

<p>When <code>what="MDseq"</code>, the MD sequences of combined states as a <code>stslist</code> sequence object.<br />
When <code>what="cost"</code>, the matrix of CAT-substitution costs with three attributes: <code>indel</code> the CAT-indel cost(s), <code>alphabet</code> the alphabet of the combined state sequences, and <code>cweight</code> the channel weights used.<br />
When <code>what="diss"</code>, a matrix of pairwise distances between MD sequences.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard and Matthias Studer</p>


<h3>References</h3>

<p>Ritschard, G., T.F. Liao, and E. Struffolino (2023). Strategies for
multidomain sequence analysis in social research.
<em>Sociological Methodology</em>, 53(2), 288-322. <a href="https://doi.org/10.1177/00811750231163833">doi:10.1177/00811750231163833</a>.
</p>
<p>Pollock, G. (2007) Holistic trajectories: a study of combined employment, housing and family careers by using multiple-sequence analysis. <em>Journal of the Royal Statistical Society: Series A</em> <b>170</b>, Part 1, 167&ndash;183.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+seqcost">seqcost</a></code>, <code><a href="#topic+seqdef">seqdef</a></code>, <code><a href="#topic+seqdist">seqdist</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)

## Building one channel per type of event left home, married, and child
cases &lt;- 200
bf &lt;- as.matrix(biofam[1:cases, 10:25])
left &lt;- bf==1 | bf==3 | bf==5 | bf==6
married &lt;- bf == 2 | bf== 3 | bf==6
children &lt;-  bf==4 | bf==5 | bf==6

## Building sequence objects
left.seq &lt;- seqdef(left)
marr.seq &lt;- seqdef(married)
child.seq &lt;- seqdef(children)
channels &lt;- list(LeftHome=left.seq, Marr=marr.seq, Child=child.seq)

## CAT multidomain distances based on channel specific cost methods
MDdist &lt;- seqMD(channels, method="OM",
    sm =list("INDELSLOG", "INDELSLOG", "TRATE"), what="diss")

## Providing channel specific substitution costs
smatrix &lt;- list()
smatrix[[1]] &lt;- seqsubm(left.seq, method="TRATE")
smatrix[[2]] &lt;- seqsubm(marr.seq, method="CONSTANT")
smatrix[[3]] &lt;- seqsubm(child.seq, method="CONSTANT")

## Retrieving the MD sequences
MDseq &lt;- seqMD(channels)
alphabet(MDseq)

## Retrieving the CAT multidomain substitution costs
## Using double weight for domain "child"
CATcost &lt;- seqMD(channels,
    sm=smatrix, cweight=c(1,1,2), what="cost")

## OMspell distances between MD sequences
MDdist2 &lt;- seqdist(MDseq, method="OMspell",
    sm = CATcost, indel=attr(CATcost,"indel"))

</code></pre>

<hr>
<h2 id='seqmeant'>Mean durations in each state</h2><span id='topic+seqmeant'></span>

<h3>Description</h3>

<p>Compute the mean total time spent in each state of the alphabet for the set of sequences given as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqmeant(seqdata, weighted=TRUE, with.missing=FALSE, prop=FALSE, serr=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqmeant_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqmeant_+3A_weighted">weighted</code></td>
<td>
<p>logical: if <code>TRUE</code>, the weights (weights attribute) attached to the sequence object are used for computing weighted mean total time.</p>
</td></tr>
<tr><td><code id="seqmeant_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: if set to <code>TRUE</code>, cumulated durations are also computed for the missing status (gaps in the sequences). See <a href="#topic+seqdef">seqdef</a> on options for handling missing values when creating sequence objects.</p>
</td></tr>
<tr><td><code id="seqmeant_+3A_prop">prop</code></td>
<td>
<p>logical: if <code>TRUE</code>, proportions of time spent in each state are returned instead of absolute values. This option is especially useful when sequences contain missing states, since the sum of the state durations may not be the same for all sequences.</p>
</td></tr>
<tr><td><code id="seqmeant_+3A_serr">serr</code></td>
<td>
<p>logical: if <code>TRUE</code>, the variance and standard deviation of the total time spent in the states, as well as the standard error of the mean are also computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <em>stslist.meant</em>. There are <code>print</code> and <code>plot</code> methods for such objects.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stslist.meant">plot.stslist.meant</a></code> for basic plots of <em>stslist.meant</em> objects and <code><a href="#topic+seqmtplot">seqmtplot</a></code> (<code><a href="#topic+seqplot">seqplot</a></code> with <code>type="mt"</code>) argument for more sophisticated plots of the mean durations allowing grouping and legend.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with columns 13 to 24
## in the actcal example data set
data(actcal)
actcal.lab &lt;- c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work")
actcal.seq &lt;- seqdef(actcal,13:24,labels=actcal.lab)

## Computing the mean time in the different states
seqmeant(actcal.seq)

## Mean times with their standard error 
seqmeant(actcal.seq, serr=TRUE)

</code></pre>

<hr>
<h2 id='seqmodst'>Sequence of modal states</h2><span id='topic+seqmodst'></span>

<h3>Description</h3>

<p>Sequence made of the modal state at each position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqmodst(seqdata, weighted=TRUE, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqmodst_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqmodst_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, distributions account for the weights assigned to the state sequence object
(see <code><a href="#topic+seqdef">seqdef</a></code>).
Set as <code>FALSE</code> if you want ignore the weights.</p>
</td></tr>
<tr><td><code id="seqmodst_+3A_with.missing">with.missing</code></td>
<td>
<p>If <code>FALSE</code> (default value), returned distributions ignore missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of multiple modal states at a given position, the first one is taken. Hence, the result may vary with the alphabet order.
</p>


<h3>Value</h3>

<p>an object of class <em>stslist.modst</em>. This is actually a state sequence object (containing a single state sequence) with additional attributes, among which the <code>Frequencies</code> attribute containing the transversal frequency of each state in the sequence. There are print and plot methods for such objects. More sophisticated plots can be produced with the <code>seqplot</code> function.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stslist.modst">plot.stslist.modst</a></code> for default plot method, <code><a href="#topic+seqplot">seqplot</a></code> for higher level plots.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
"Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.seq &lt;- seqdef(biofam, 10:25, labels=biofam.lab)

## Modal state sequence
seqmodst(biofam.seq)

## Examples using weights and with.missing arguments
data(ex1)
ex1.seq &lt;- seqdef(ex1, 1:13, weights=ex1$weights)

seqmodst(ex1.seq)
seqmodst(ex1.seq, weighted=FALSE)
seqmodst(ex1.seq, weighted=FALSE, with.missing=TRUE)
</code></pre>

<hr>
<h2 id='seqmpos'>Number of matching positions between two sequences.</h2><span id='topic+seqmpos'></span>

<h3>Description</h3>

<p>Returns the number of common elements, i.e., same states appearing at the same position in the two sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqmpos(seq1, seq2, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqmpos_+3A_seq1">seq1</code></td>
<td>
<p>a sequence from a sequence object.</p>
</td></tr>
<tr><td><code id="seqmpos_+3A_seq2">seq2</code></td>
<td>
<p>a sequence from a sequence object.</p>
</td></tr>
<tr><td><code id="seqmpos_+3A_with.missing">with.missing</code></td>
<td>
<p>if <code>TRUE</code>, gaps appearing at the same position in both sequences are also considered as common elements</p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho (with Gilbert Ritschard for help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqLLCP">seqLLCP</a></code>, <code><a href="#topic+seqLLCS">seqLLCS</a> </code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(famform)
famform.seq &lt;- seqdef(famform)

seqmpos(famform.seq[1,],famform.seq[2,])
seqmpos(famform.seq[2,],famform.seq[4,])

## Example with gaps in sequences
a &lt;- c(NA,"A",NA,"B","C")
b &lt;- c(NA,"C",NA,"B","C")

ex1.seq &lt;- seqdef(rbind(a,b))

seqmpos(ex1.seq[1,], ex1.seq[2,])
seqmpos(ex1.seq[1,], ex1.seq[2,], with.missing=TRUE)

</code></pre>

<hr>
<h2 id='seqnum'>Transform into a sequence object with numerical alphabet.</h2><span id='topic+seqnum'></span>

<h3>Description</h3>

<p>The function <code>seqnum</code> transforms the provided state sequence object into an equivalent sequence object in which the original alphabet is replaced with an alphabet of numbers ranging from <code>0</code> to <code>(nbstates-1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqnum(seqdata, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqnum_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqnum_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: Should missing elements in the sequences be turned into numerical values as well?  The code for missing values in the sequences is retrieved from the <code>'nr'</code> attribute of <code>seqdata</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first state (for example <code>'A'</code>) is coded with the value <code>0</code>, the second state (for example <code>'B'</code>) is coded with the value <code>1</code>, etc... The function returns a sequence object containing the original sequences coded with the new numerical alphabet
ranging from <code>0</code> to <code>(nbstates-1)</code></p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdef">seqdef</a></code>, <code><a href="#topic+alphabet">alphabet</a> </code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24)

## The first 10 sequences in the actcal.seq
## sequence object
actcal.seq[1:10,]
alphabet(actcal.seq)

## The first 10 sequences in the actcal.seq
## sequence object with numerical alphabet
seqnum(actcal.seq[1:10,])

## states A,B,C,D are now coded 0,1,2,3
alphabet(seqnum(actcal.seq))
</code></pre>

<hr>
<h2 id='seqpcplot'>Parallel coordinate plot for sequence data</h2><span id='topic+seqpcplot'></span><span id='topic+seqpcfilter'></span><span id='topic+plot.eseq'></span><span id='topic+plot.seqelist'></span>

<h3>Description</h3>

<p>A decorated parallel coordinate plot to render the order of the
successive elements in sequences. The sequences are displayed as
jittered frequency-weighted parallel lines.
The plot is also embedded as the <code>type="pc"</code> option of the
<code><a href="#topic+seqplot">seqplot</a></code> function and serves as plot
method for <code>eseq</code> and <code>seqelist</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqpcplot(seqdata, group = NULL, weights = NULL, cex = 1, lwd = 1/4,
  cpal = NULL, grid.scale = 1/5, ltype = "unique",
  embedding = "most-frequent", lorder = NULL , lcourse = "upwards",
  filter = NULL, hide.col = "grey80", alphabet = NULL,
  missing = "auto", order.align = "first", main = "auto", xlab = NULL,
  ylab = NULL, xaxis = TRUE, yaxis = TRUE, axes = "all", xtlab = NULL,
  cex.lab = 1, rows = NA, cols = NA, plot = TRUE, seed = NULL,
  weighted = TRUE, with.missing = TRUE,
  title, cex.plot, ...)

seqpcfilter(method = c("minfreq", "cumfreq", "linear"), level = 0.05)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqpcplot_+3A_seqdata">seqdata</code></td>
<td>
<p>The sequence data. Either an event sequence
object of class <code>seqelist</code> (see
<code><a href="#topic+seqecreate">seqecreate</a></code>) or a state sequence object of class
<code>stslist</code> (see <code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_group">group</code></td>
<td>
<p>a vector (numeric or factor) of group memberships
of length equal the number of
sequences. When specified, one plot is generated for each
different membership value.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights of length equal the number
of sequences. When <code>NULL</code>, the <code>weights</code> are taken from
the <code>seqdata</code> object.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_cex">cex</code></td>
<td>
<p>Plotting text and symbols magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_lwd">lwd</code></td>
<td>
<p>expansion factor for line widths. The expansion is
relative to the size of the squared symbols.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_cpal">cpal</code></td>
<td>
<p>color palette vector for line coloring.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_grid.scale">grid.scale</code></td>
<td>
<p>Expansion factor for the translation zones.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_ltype">ltype</code></td>
<td>
<p>the type of sequence that is drawn. Either <code>"unique"</code>
to render unique patterns or <code>"non-embeddable"</code> to render
non-embeddable sequences.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_embedding">embedding</code></td>
<td>
<p>The method for embedding sequences embeddable in
multiple non-embeddable sequences. Either <code>"most-frequent"</code>
(default) or <code>"uniformly"</code>. Relevant only with <code>ltype =
      "non-embeddable"</code>.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_lorder">lorder</code></td>
<td>
<p>line ordering. Either <code>"background"</code> or
<code>"foreground"</code>.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_lcourse">lcourse</code></td>
<td>
<p>Method to connect simultaneous elements with the
preceding and following ones. Either <code>"upwards"</code> (default) or
<code>"downwards"</code>.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_filter">filter</code></td>
<td>
<p>list of line coloring options. See details.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_hide.col">hide.col</code></td>
<td>
<p>Color for sequences filtered-out by the
<code>filter</code> specification.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_alphabet">alphabet</code></td>
<td>
<p>a vector of response levels in the order they should
appear on the y-axis. This argument is solely relevant for
<code>seqelist</code> objects.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_missing">missing</code></td>
<td>
<p>character. Whether and how missing values should be
displayed. Available are <code>"auto"</code>, <code>"show"</code> and
<code>"hide"</code>. If <code>"auto"</code>, the plot will show missings only if
present. <code>"hide"</code> will fade out missings and <code>"show"</code> will
always show missings. If <code>with.missing=FALSE</code>,
<code>missing</code> is turned into <code>"hide"</code>. If <code>with.missing=TRUE</code>
and <code>missing="hide"</code>, <code>missing</code> is turned into <code>"auto"</code>.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_order.align">order.align</code></td>
<td>
<p>Aligning method. For aligning on order positions use either <code>"first"</code> (default) or
<code>"last"</code>. Option <code>"first"</code> numbers the positions from the beginning
while <code>"last"</code> numbers them from the end. With <code>order.align = "time"</code>, the elements in the
sequences are aligned on their rounded timestamps.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_main">main</code></td>
<td>
<p>title for the graphic. Default <code>"auto"</code> prints default titles. Set as <code>NULL</code> to
suppress the title.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_xaxis">xaxis</code></td>
<td>
<p>logical: Should x-axis be plotted?</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_yaxis">yaxis</code></td>
<td>
<p>logical: Should y-axis be plotted?</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_axes">axes</code></td>
<td>
<p>if set as <code>"all"</code> (default value) x-axes are drawn
for each plot in the graphic. If set as <code>"bottom"</code> and
<code>group</code> is used, axes are drawn only under the plots at
the bottom of the graphic area. If <code>FALSE</code>, no x-axis is drawn.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_xtlab">xtlab</code></td>
<td>
<p>labels for the x-axis ticks.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>x and y labels magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_rows">rows</code>, <code id="seqpcplot_+3A_cols">cols</code></td>
<td>
<p>integers. Number of rows and columns of the plot panel.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_plot">plot</code></td>
<td>
<p>logical. Should the plot be displayed? Set as <code>FALSE</code> to retrieve the <code>seqpcplot</code>
object without plotting it.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_seed">seed</code></td>
<td>
<p>integer. Start seed value.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_weighted">weighted</code></td>
<td>
<p>logical. Should weights be accounted for? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_with.missing">with.missing</code></td>
<td>
<p>logical. Should we care about possible missings? Default is <code>TRUE</code>. See also the
<code>missing</code> argument.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_method">method</code></td>
<td>
<p>character string. Defines the filtering
function. Available are <code>"minfreq"</code>, <code>"cumfreq"</code> and
<code>"linear"</code>.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_level">level</code></td>
<td>
<p>numeric scalar between 0 and 1. The frequency threshold
for the filtering methods <code>"minfreq"</code> and <code>"cumfreq"</code>.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_title">title</code></td>
<td>
<p>Deprecated. Use <code>main</code> instead.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_cex.plot">cex.plot</code></td>
<td>
<p>Deprecated. Use <code>cex.lab</code> instead.</p>
</td></tr>
<tr><td><code id="seqpcplot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods, such as graphical
parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For plots by groups specified with the <code>group</code> argument, plotted
line widths and point sizes reflect relative frequencies within
group.
</p>
<p>The <code>filter</code> argument serves to specify filters to gray less
interesting patterns. The filtered-out patterns are displayed in the
<code>hide.col</code> color. The <code>filter</code> argument expects a list with
at least elements <code>type</code> and <code>value</code>. The following types
are implemented:
</p>
<p>Type <code>"sequence"</code>: colors a specific pattern, for example assign<br />
<code>filter = list(type = "sequence", value = "(Leaving
  Home,Union)-(Child)")</code>.
</p>
<p>Type <code>"subsequence"</code>: colors patterns which include a specific
subsequence, for example<br /> <code>filter = list(type =
  "subsequence", value = "(Child)-(Marriage)")</code> .
</p>
<p>Type <code>"value"</code>: gradually colors the patterns according to the
numeric vector (of length equal to the number of sequences) provided as
<code>"value"</code> element in the list. You can give something like
<code>filter = list(type = "value", value = c(0.2, 1, ...))</code> or
provide the distances to the medoid as <code>value</code> vector for
example.
</p>
<p>Type <code>"function"</code>: colors the patterns depending on the values
returned by a [0,1] valued function of the frequency x of the
pattern. Three native functions can be used: <code>"minfreq"</code>,
<code>"cumfreq"</code> and <code>"linear"</code>. Use
<code>filter = list(type = "function", value = "minfreq", level = 0.05)</code>
to color patterns with a
support of at least 5% (within group). Use
<br /><code>filter = list(type = "function", value = "cumfreq", level = 0.5)</code>
to highlight the 50% most
frequent patterns (within group). Or, use
<code>filter = list(type="function", value="linear")</code>
to use a linear gradient for the
color intensity (the most frequent trajectory gets
100% intensity). Other user-specified functions can be provided by
giving something like
<br /><code>filter = list(type="function", value=function(x, arg1, arg2) {return(x/max(x) * arg1/arg2)},</code>
<code>arg1 = 1, arg2 = 1)</code>. This latter function adjusts gradually the color intensity
of patterns according to the frequency of the pattern.
</p>
<p>The function <code>seqpcfilter</code> is a convenience function for type
<code>"function"</code>. The three examples above can be imitated by
<code>seqpcfilter("minfreq", 0.05)</code>,
<code>seqpcfilter("cumfreq", 0.5)</code> and <code>seqpcfilter("linear")</code>.
</p>
<p>If a numeric scalar is assigned to <code>filter</code>, the <code>"minfreq"</code>
filter is used.
</p>


<h3>Value</h3>

<p>An object of <code>class</code> <code>"seqpcplot"</code>
with various information necessary for constructing the plot,
e.g. coordinates. There is a <code>summary</code> method for such
objects.
</p>


<h3>Author(s)</h3>

<p>Reto Bürgin (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Bürgin, R. and G. Ritschard (2014), A decorated parallel coordinate plot for categorical longitudinal
data, <em>The American Statistician</em> 68(2), 98-103.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+seqplot">seqplot</a></code>, <code><a href="#topic+seqdef">seqdef</a></code>, <code><a href="#topic+seqecreate">seqecreate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ================
## plot biofam data
## ================

data(biofam)
lab &lt;- c("Parent","Left","Married","Left+Marr","Child","Left+Child",
         "Left+Marr+Child","Divorced")

## plot state sequences in STS representation
## ==========================================

## creating the weighted state sequence object.
biofam.seq &lt;- seqdef(data = biofam[,10:25], labels = lab,
                     weights = biofam$wp00tbgs)

## select the first 20 weighted sequences (sum of weights = 18)
biofam.seq &lt;- biofam.seq[1:20, ]

par(mar=c(4,8,2,2))
seqpcplot(seqdata = biofam.seq, order.align = "time")

## .. or
seqplot(seqdata = biofam.seq, type = "pc", order.align = "time")

## Distinct successive states (DSS)
## ==========================================

seqplot(seqdata = biofam.seq, type = "pc", order.align = "first")

## .. or (equivalently)

biofam.DSS &lt;- seqdss(seqdata = biofam.seq) # prepare format
seqpcplot(seqdata = biofam.DSS)

## plot event sequences
## ====================

biofam.eseq &lt;- seqecreate(biofam.seq, tevent = "state") # prepare data

## plot the time in the x-axis
seqpcplot(seqdata = biofam.eseq, order.align = "time", alphabet = lab)

## ordering of events
seqpcplot(seqdata = biofam.eseq, order.align = "first", alphabet = lab)

## ... or
plot(biofam.eseq, order.align = "first", alphabet = lab)

## additional arguments
## ====================

## non-embeddable sequences
seqpcplot(seqdata = biofam.eseq, ltype = "non-embeddable",
          order.align = "first", alphabet = lab)

## align on last event
par(mar=c(4,8,2,2))
seqpcplot(seqdata = biofam.eseq, order.align = "last", alphabet = lab)

## use group variables
seqpcplot(seqdata = biofam.eseq, group = biofam$sex[1:20],
          order.align = "first", alphabet = lab)

## color patterns (Parent)-(Married) and (Parent)-(Left+Marr+Child)
par(mfrow = c(1, 1))
seqpcplot(seqdata = biofam.eseq,
          filter = list(type = "sequence",
                          value=c("(Parent)-(Married)",
                                  "(Parent)-(Left+Marr+Child)")),
          alphabet = lab, order.align = "first")

## color subsequence pattern (Parent)-(Left)
seqpcplot(seqdata = biofam.eseq,
          filter = list(type = "subsequence",
                          value = "(Parent)-(Left)"),
          alphabet = lab, order.align = "first")

## color sequences over 10% (within group) (function method)
seqpcplot(seqdata = biofam.eseq,
          filter = list(type = "function",
                        value = "minfreq",
                        level = 0.1),
          alphabet = lab, order.align = "first", seed = 1)

## .. same result using the convenience functions
seqpcplot(seqdata = biofam.eseq,
          filter = 0.1,
          alphabet = lab, order.align = "first", seed = 1)

seqpcplot(seqdata = biofam.eseq,
          filter = seqpcfilter("minfreq", 0.1),
          alphabet = lab, order.align = "first", seed = 1)

## highlight the 50% most frequent sequences
seqpcplot(seqdata = biofam.eseq,
          filter = list(type = "function",
                          value = "cumfreq",
                          level = 0.5),
          alphabet = lab, order.align = "first", seed = 2)

## .. same result using the convenience functions
seqpcplot(seqdata = biofam.eseq,
          filter = seqpcfilter("cumfreq", 0.5),
          alphabet = lab, order.align = "first", seed = 2)

## linear gradient
seqpcplot(seqdata = biofam.eseq,
          filter = list(type = "function",
                          value = "linear"),
          alphabet = lab, order.align = "first", seed = 2)

seqpcplot(seqdata = biofam.eseq,
          filter = seqpcfilter("linear"),
          alphabet = lab, order.align = "first", seed = 1)



</code></pre>

<hr>
<h2 id='seqplot'>Plot state sequence objects</h2><span id='topic+seqplot'></span><span id='topic+seqdplot'></span><span id='topic+seqdHplot'></span><span id='topic+seqfplot'></span><span id='topic+seqrfplot'></span><span id='topic+seqiplot'></span><span id='topic+seqIplot'></span><span id='topic+seqHtplot'></span><span id='topic+seqmsplot'></span><span id='topic+seqmtplot'></span><span id='topic+seqrplot'></span>

<h3>Description</h3>

<p>High level plot functions to render state sequence objects. Can produce many different types of plots and can render sequences by group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqplot(seqdata,
  group = NULL,
  type = "i",
  main = "auto",
  cpal = NULL,
  missing.color = NULL,
  ylab = NULL,
  yaxis = "all",
  xaxis = "all",
  xtlab = NULL,
  cex.axis = 1,
  with.legend = "auto",
  ltext = NULL,
  cex.legend = 1,
  use.layout = (!is.null(group) | with.legend != FALSE),
  legend.prop = NA,
  rows = NA,
  cols = NA,
  title, cex.plot, withlegend, axes,
  ...)

seqdplot(seqdata, group = NULL, main = "auto", ...)
seqdHplot(seqdata, group = NULL, main = "auto", ...)
seqfplot(seqdata, group = NULL, main = "auto", ...)
seqiplot(seqdata, group = NULL, main = "auto", ...)
seqIplot(seqdata, group = NULL, main = "auto", ...)
seqHtplot(seqdata, group = NULL, main = "auto", ...)
seqmsplot(seqdata, group = NULL, main = "auto", ...)
seqmtplot(seqdata, group = NULL, main = "auto", ...)
seqrplot(seqdata, group = NULL, main = "auto", ...)
seqrfplot(seqdata, group = NULL, main = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqplot_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object created with the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_group">group</code></td>
<td>
<p>Grouping variable of length equal to the number of sequences. When not <code>NULL</code>, a distinct plot is generated for each level of <code>group</code>.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_type">type</code></td>
<td>
<p>the type of the plot. Available types are <code>"d"</code>
for state distribution plots (chronograms), <code>"dH"</code> for chronograms
with overlayed entropy line, <code>"f"</code> for sequence frequency
plots, <code>"Ht"</code> for transversal entropy plots, <code>"i"</code> for
selected sequence index plots, <code>"I"</code> for whole set index
plots, <code>"ms"</code> for plotting the sequence of modal states,
<code>"mt"</code> for mean times plots, <code>"pc"</code> for parallel
coordinate plots, <code>"r"</code> for representative sequence plots, and
<code>"rf"</code> for relative frequency plots.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_main">main</code></td>
<td>
<p>Character string. Title of the graphic. Default <code>"auto"</code> prints group levels as default title when group is not <code>NULL</code> and no title otherwise. Set as <code>NULL</code> to suppress titles. </p>
</td></tr>
<tr><td><code id="seqplot_+3A_cpal">cpal</code></td>
<td>
<p>Color palette of the states. By default, the <code>cpal</code> attribute of the <code>seqdata</code> sequence object is used (see <code><a href="#topic+seqdef">seqdef</a></code>). If user specified, a vector of colors of length and order corresponding to <code>alphabet(seqdata)</code>.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_missing.color">missing.color</code></td>
<td>
<p>Color for representing missing values inside the sequences. By default, this color is taken from the <code>missing.color</code> attribute of <code>seqdata</code>.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_ylab">ylab</code></td>
<td>
<p>Character string or vector of strings. Optional label of the y-axis. If a vector, y-axis label of each group level. If set as <code>NA</code>, no label is drawn.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_yaxis">yaxis</code></td>
<td>
<p>Logical or one of <code>"all"</code> or <code>"left"</code>. If set as <code>TRUE</code> or <code>"all"</code> (default value), sequence index numbers are displayed for <code>"i"</code> and <code>"I"</code>, mean time values for <code>"mt"</code>, percentages for <code>"d"</code> and <code>"f"</code>, and state/event labels for <code>"pc"</code>. Ignored for <code>"r"</code>. If <code>"left"</code> and <code>group</code> is used, the y-axis is displayed on plots of the left panel only. If <code>FALSE</code> no y-axis is drawn. For type <code>"f"</code>, can also be one of <code>"pct"</code> or <code>"left.pct"</code>.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_xaxis">xaxis</code></td>
<td>
<p>Logical or one of <code>"all"</code> or <code>"bottom"</code>. If set as <code>TRUE</code> or <code>"all"</code> (default value) x-axes are drawn for each plot in the graphic. If set as <code>"bottom"</code> and <code>group</code> is used, axes are drawn under the plots of the bottom panel only. If <code>FALSE</code>, no x-axis is drawn.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_xtlab">xtlab</code></td>
<td>
<p>Vector of length equal to the number of columns of <code>seqdata</code>. Optional x-axis tick labels. If unspecified, column names of the <code>seqdata</code> sequence object are used (see <code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Real value.
Axis annotation magnification. When <code>type = "r"</code> and for <code>seqrplot()</code>,
it also determines the magnification of the plotted text and symbols.
See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="seqplot_+3A_with.legend">with.legend</code></td>
<td>
<p>Character string or logical. Defines if and where the legend of the state colors is plotted. The default value <code>"auto"</code> sets the position of the legend automatically. Other possible value is <code>"right"</code>. Obsolete value <code>TRUE</code> is equivalent to <code>"auto"</code>.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_ltext">ltext</code></td>
<td>
<p>Vector of character strings of length and order corresponding to  <code>alphabet(seqdata)</code>. Optional description of the states to appear in the legend. If unspecified, the <code>label</code> attribute of the <code>seqdata</code> sequence object is used (see <code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqplot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Real. Legend magnification. See <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_use.layout">use.layout</code></td>
<td>
<p>Logical. Should <code><a href="graphics.html#topic+layout">layout</a></code> be used to arrange plots when using the group option or plotting a legend? When layout is activated, the standard '<code><a href="graphics.html#topic+par">par</a>(mfrow=....)</code>' for arranging plots does not work. With <code>with.legend=FALSE</code> and <code>group=NULL</code>, layout is automatically deactivated and '<code>par(mfrow=....)</code>' can be used.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_legend.prop">legend.prop</code></td>
<td>
<p>Real in range [0,1]. Proportion of the graphic area devoted to the legend plot when <code>use.layout=TRUE</code> and <code>with.legend=TRUE</code>. Default value is set according to the place (bottom or right of the graphic area) where the legend is plotted.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_rows">rows</code>, <code id="seqplot_+3A_cols">cols</code></td>
<td>
<p>Integers. Number of rows and columns of the plot panel when <code>use.layout=TRUE</code>.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_title">title</code></td>
<td>
<p>Deprecated. Use <code>main</code> instead.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_cex.plot">cex.plot</code></td>
<td>
<p>Deprecated. Use <code>cex.axis</code> instead.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_withlegend">withlegend</code></td>
<td>
<p>Deprecated. Use <code>with.legend</code> instead.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_axes">axes</code></td>
<td>
<p>Deprecated. Use <code>xaxis</code> instead.</p>
</td></tr>
<tr><td><code id="seqplot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function called to produce the appropriate statistics and the associated plot method (see details), or other graphical parameters. For example, the <code>weighted</code> argument can be passed to control whether (un)weighted statistics are produced, and <code>with.missing=TRUE</code> to take missing values into account when computing cross-sectional or longitudinal state distributions. Can also include arguments of <code><a href="graphics.html#topic+legend">legend</a></code> such as <code>bty="n"</code> to suppress the box surrounding the legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>seqplot</code> is the generic function for high level plots of state sequence objects with group splits and automatic display of the color legend. Many different types of plots can be produced by means of the <code>type</code> argument. Except for sequence index plots, <code>seqplot</code> first calls the specific function producing the required statistics and then the plot method for objects produced by this function (see below). For sequence index plots, the state sequence object itself is plotted by calling the <code><a href="#topic+plot.stslist">plot.stslist</a></code> method. When splitting by groups and/or displaying the color legend, the <code><a href="graphics.html#topic+layout">layout</a></code> function is used for arranging the plots.
</p>
<p>The <code>seqdplot</code>, <code>seqdHplot</code>, <code>seqfplot</code>, <code>seqiplot</code>, <code>seqIplot</code>,
<code>seqHtplot</code>, <code>seqmsplot</code>, <code>seqmtplot</code>, <code>seqpcplot</code>
and <code>seqrplot</code> functions are aliases for calling <code>seqplot</code>
with <code>type</code> argument set respectively to <code>"d"</code>, <code>"dH"</code>, <code>"f"</code>,
<code>"i"</code>, <code>"I"</code>, <code>"Ht"</code>, <code>"ms"</code>, <code>"mt"</code>,
<code>"pc"</code> or <code>"r"</code>.
</p>
<p>A <em>State distribution plot</em> (<code>type="d"</code>) represents the sequence of the cross-sectional state frequencies by position (time point) computed by the <code><a href="#topic+seqstatd">seqstatd</a></code> function and rendered with the <code><a href="#topic+plot.stslist.statd">plot.stslist.statd</a></code> method. Such plots are also known as <em>chronograms</em>.
</p>
<p>A <em>Sequence frequency plots</em> (<code>type="f"</code>) displays the most frequent sequences, each one with an horizontal stack bar of its successive states. Sequences are displayed bottom-up in decreasing order of their frequencies (computed by the <code><a href="#topic+seqtab">seqtab</a></code> function). The <code><a href="#topic+plot.stslist.freq">plot.stslist.freq</a></code> plot method is called for producing the plot. <br />
The <code>idxs</code> optional argument may be specified for selecting the sequences to be plotted (default is 1:10, i.e. the 10 most frequent sequences). The width of the bars representing the sequences is by default proportional to their frequencies, but this can be disabled with the <code>pbarw=FALSE</code> optional argument. If weights have been specified when creating <code>seqdata</code>, weighted frequencies are used unless you set the <code>weighted=TRUE</code> option. See examples below, the <code><a href="#topic+seqtab">seqtab</a></code> and <code><a href="#topic+plot.stslist.freq">plot.stslist.freq</a></code> manual pages for a complete list of optional arguments and <cite>Müller et al., (2008)</cite> for a description of sequence frequency plots.
</p>
<p>In <em>sequence index plots</em> (<code>type="i"</code> or <code>type="I"</code>), the requested individual sequences are rendered with horizontal stacked bars depicting the states over successive positions (time). Optional arguments are <code>idxs</code> for specifying the indexes of the sequences to be plotted (when <code>type="i"</code> defaults to the first ten sequences, i.e <code>idxs=1:10</code>). For nicely plotting a (large) whole set of sequences, use <code>type="I"</code> which is  <code>type="i"</code> with <code>idxs=0</code> and the additional graphical parameters <code>border=NA</code> and <code>space=0</code> to suppress bar borders and space between bars. The <code>sortv</code> argument can be used to pass a vector of numerical values for sorting the sequences or to specify a sorting method. See <code><a href="#topic+plot.stslist">plot.stslist</a></code> for a complete list of optional arguments and their description.
</p>
<p>The interest of sequence index plots has, for instance, been stressed by <cite>Scherer (2001)</cite> and <cite>Brzinsky-Fay et al. (2006)</cite>. Notice that index plots for thousands of sequences result in very heavy PDF or POSTSCRIPT graphic files. Dramatic file size reduction may be achieved by saving the figures in bitmap format by using for instance the <code><a href="grDevices.html#topic+png">png</a></code> graphic device instead of <code><a href="grDevices.html#topic+postscript">postscript</a></code> or <code><a href="grDevices.html#topic+pdf">pdf</a></code>.
</p>
<p>The <em>transversal entropy plot</em> (<code>type="Ht"</code>) displays the evolution over positions of the cross-sectional entropies (<cite>Billari, 2001</cite>). Cross-sectional entropies are computed by calling <code><a href="#topic+seqstatd">seqstatd</a></code> function and then plotted with the <code><a href="#topic+plot.stslist.statd">plot.stslist.statd</a></code> plot method. With <code>type="dH"</code>, the entropy line is overlayed on the state distribution plot.
</p>
<p>The <em>modal state sequence plot</em> (<code>type="ms"</code>) displays the sequence of the modal states with each mode proportional to its frequency at the given position. The <code><a href="#topic+seqmodst">seqmodst</a></code> function is called which returns the sequence and the result is plotted by calling the <code><a href="#topic+plot.stslist.modst">plot.stslist.modst</a></code> plot method.
</p>
<p>The <em>mean time plot</em> (<code>type="mt"</code>) displays the mean time spent in each state of the alphabet as computed by the <code><a href="#topic+seqmeant">seqmeant</a></code> function. The <code><a href="#topic+plot.stslist.meant">plot.stslist.meant</a></code> plot method is used to plot the resulting statistics. Set <code>serr=TRUE</code> to display error bars on the mean time plot. Bar labels can be specified by passing the <code>bar.labels</code> among the <code>...</code> arguments. In that case, <code>bar.labels</code> must be either a matrix with group specific labels in columns or a single vector to display the same labels for all groups.
</p>
<p>The <em>representative sequence plot</em> (<code>type="r"</code>) displays a reduced, non redundant set of representative sequences extracted from the provided state sequence object and sorted according to a representativeness criterion. The <code><a href="#topic+seqrep">seqrep</a></code> function is called to extract the representative set which is then plotted by calling the <code><a href="#topic+plot.stslist.rep">plot.stslist.rep</a></code> method. A distance matrix is required that is passed with the <code>diss</code> argument or by calling the <code>seqdist</code> function if <code>diss=NULL</code>. The <code>criterion</code> argument sets the representativeness criterion used to sort the sequences.  Refer to the <code><a href="#topic+seqrep">seqrep</a></code> and <code><a href="#topic+plot.stslist.rep">plot.stslist.rep</a></code> manual pages for a complete list of optional arguments.  See <cite>Gabadinho and Ritschard (2013)</cite> for more details on the extraction of representative sets. Also look at the examples below.
</p>
<p><em>Relative frequency plot</em> (<code>type="rf"</code>) displays the medoids of equal sized groups <cite>Fasang and Liao (2014)</cite>. The partition into equal sized groups and the identification of the medoids is done by calling <code><a href="#topic+seqrf">seqrf</a></code> and plots are generated by <code><a href="#topic+plot.seqrf">plot.seqrf</a></code>. See these functions for possible options. Option <code>which.plot = "both"</code> applies only when <code>group = NULL</code>. Whatever the value of <code>info</code>, <code>seqplot</code> does not display the statistics on the plot. When <code>sortv="mds"</code> is set, the first MDS factor of the whole <code>diss</code> matrix is computed and used for sorting each group. Set <code>sortv=NULL</code> to use the original data order.
</p>
<p>For <em>decorated parallel coordinate plots</em> (<code>type="pc"</code>) see the specific manual page of <code><a href="#topic+seqpcplot">seqpcplot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>References</h3>

<p>Billari, F. C. (2001). The analysis of early life courses: Complex description of
the transition to adulthood. <em>Journal of Population Research</em> <b>18</b>(2), 119-142.
</p>
<p>Brzinsky-Fay C., U. Kohler, M. Luniak (2006). Sequence Analysis with Stata. <em>The Stata Journal</em>, <b>6</b>(4), 435-460.
</p>
<p>Fasang, A.E. and T.F. Liao. (2014). Visualizing Sequences in the Social Sciences: Relative Frequency Sequence Plots. <em>Sociological Methods and Research</em> <b>43</b>(4), 643-676.
</p>
<p>Gabadinho, A., and G. Ritschard (2013), &quot;Searching for typical life trajectories applied to childbirth histories&quot;, In Levy, R. &amp; Widmer, E. (eds) <em>Gendered life courses - Between individualization and standardization. A European approach applied to Switzerland</em>, pp. 287-312. Vienna: LIT.
</p>
<p>Gabadinho, A., G. Ritschard, N.S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>
<p>Gabadinho A., G. Ritschard, M. Studer, N.S. Müller (2011). &quot;Extracting and Rendering Representative Sequences&quot;, In A Fred, JLG Dietz, K Liu, J Filipe (eds.), <em>Knowledge Discovery, Knowledge Engineering and Knowledge Management</em>, volume 128 of <em>Communications in Computer and Information Science (CCIS)</em>, pp. 94-106. Springer-Verlag.
</p>
<p>Müller, N.S., A. Gabadinho, G. Ritschard and M. Studer (2008). Extracting knowledge from life courses: Clustering and visualization. In <em>Data Warehousing and Knowledge Discovery, 10th International Conference  DaWaK 2008, Turin, Italy, September 2-5</em>, LNCS 5182, Berlin: Springer, 176-185.
</p>
<p>Scherer S (2001). Early Career Patterns: A Comparison of Great Britain and West Germany.
<em>European Sociological Review</em>, <b>17</b>(2), 119-144.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stslist.statd">plot.stslist.statd</a></code>, <code><a href="#topic+plot.stslist.freq">plot.stslist.freq</a></code>, <code><a href="#topic+plot.stslist">plot.stslist</a></code>, <code><a href="#topic+plot.stslist.modst">plot.stslist.modst</a></code>, <code><a href="#topic+plot.stslist.meant">plot.stslist.meant</a></code>, <code><a href="#topic+plot.stslist.rep">plot.stslist.rep</a></code>, <code><a href="#topic+seqrep">seqrep</a></code>,
<code><a href="#topic+seqpcplot">seqpcplot</a></code>,
<code><a href="TraMineRextras.html#topic+seqsplot">seqsplot</a></code>,
<code><a href="#topic+seqplotMD">seqplotMD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ======================================================
## Creating state sequence objects from example data sets
## ======================================================

## biofam data set
data(biofam)
## We use only a sample of 300 cases
set.seed(10)
biofam &lt;- biofam[sample(nrow(biofam),300),]
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
                "Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.seq &lt;- seqdef(biofam, 10:25, labels=biofam.lab)

## actcal data set
data(actcal)
## We use only a sample of 300 cases
set.seed(1)
actcal &lt;- actcal[sample(nrow(actcal),300),]
actcal.lab &lt;- c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work")
actcal.seq &lt;- seqdef(actcal,13:24,labels=actcal.lab)

## ex1 using weights
data(ex1)
ex1.seq &lt;- seqdef(ex1, 1:13, weights=ex1$weights)

## ====================
## Sequence index plots
## ====================

## First ten sequences
seqiplot(biofam.seq)

## All sequences sorted by age in 2000
## grouped by sex
seqIplot(actcal.seq, group=actcal$sex, sortv=actcal$age00)


## =======================
## State distribution plot
## =======================

## biofam grouped by sex
seqplot(biofam.seq, type="d", group=actcal$sex)

## actcal grouped by sex
seqplot(actcal.seq, type="d", group=actcal$sex)

## with overlayed entropy line
seqplot(actcal.seq, type="dH", group=actcal$sex)

## ===================
## Cross-sectional entropy plot
## ===================
seqplot(biofam.seq, type="Ht", group=biofam$sex)

## ========================
## Sequence frequency plots
## ========================

## Plot of the 10 most frequent sequences
seqplot(biofam.seq, type="f")

## Grouped by sex
seqfplot(actcal.seq, group=actcal$sex)

## Unweighted vs weighted frequencies
seqfplot(ex1.seq, weighted=FALSE)
seqfplot(ex1.seq, weighted=TRUE)

## =====================
## Modal states sequence
## =====================
seqplot(biofam.seq, type="ms")
## same as
seqmsplot(biofam.seq)

## ====================
## Representative plots
## ====================

## Computing a distance matrix
## with OM metric
costs &lt;- seqcost(actcal.seq, method="INDELSLOG")
actcal.om &lt;- seqdist(actcal.seq, method="OM", sm=costs$sm, indel=costs$indel)

## Plot of the representative sets grouped by sex
## using the default density criterion
seqrplot(actcal.seq, group=actcal$sex, diss=actcal.om, coverage=.5)

## Plot of the representative sets grouped by sex
## using the "dist" (centrality) criterion
seqrplot(actcal.seq, group=actcal$sex, criterion="dist", diss=actcal.om, coverage=.33)

## ========================
## Relative frequency plots
## ========================
## Using default sorting by first MDS variable
seqrfplot(actcal.seq, diss=actcal.om, sortv=NULL, group=actcal$sex)


## ===============
## Mean time plot
## ===============

## actcal data set, grouped by sex
seqplot(actcal.seq, type="mt", group=actcal$sex)

## displaying mean times as bar labels
group &lt;- factor(actcal$sex)
blab &lt;- NULL
for (i in 1:length(levels(group))){
  blab &lt;- cbind(blab,seqmeant(actcal.seq[group==levels(group)[i],]))
}
seqmtplot(actcal.seq, group=group,
          bar.labels = round(blab,digits=2), cex.barlab=1.2)

</code></pre>

<hr>
<h2 id='seqplotMD'>Plot multidomain state sequences</h2><span id='topic+seqplotMD'></span>

<h3>Description</h3>

<p>Plot function to render multidomain state sequences by domain and group. The function takes care to make the plots comparable across domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqplotMD(channels, 
  group = NULL, 
  type = "i", 
  main = NULL, 
  cpal.dom = NULL, 
  missing.color = NULL, 
  ylab = NULL, 
  yaxis = "all", 
  xaxis = "all", 
  xtlab = NULL, 
  stats = "all", 
  cex.axis = 1, 
  with.legend = "auto", 
  ltext.dom = NULL, 
  cex.legend = 1, 
  legend.prop = ifelse(dom.byrow,.25,.15),
  dom.byrow = FALSE, 
  dom.crit = 0, 
  dnames=names(channels), 
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqplotMD_+3A_channels">channels</code></td>
<td>
<p>List of paired domain state sequence objects.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_group">group</code></td>
<td>
<p>Grouping variable of length equal to the number of multidomain sequences. When not <code>NULL</code>, a distinct plot is generated for each level of <code>group</code>.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_type">type</code></td>
<td>
<p>the type of the plot. Available types are 
<code>"d"</code> for state distribution plots (chronograms), 
<code>"dH"</code> for chronograms with overlayed entropy line, 
<code>"f"</code> for sequence frequency plots, 
<code>"Ht"</code> for transversal entropy plots, 
<code>"i"</code> for index plots of selected sequences, 
<code>"I"</code> for index plots of the whole set of sequences, 
<code>"ms"</code> for plotting the sequence of modal states,
<code>"mt"</code> for mean times plots, 
<code>"pc"</code> for parallel  coordinate plots, 
<code>"r"</code> for representative sequence plots, and
<code>"rf"</code> for relative frequency plots.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_main">main</code></td>
<td>
<p>Character string. Title of the graphic. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_cpal.dom">cpal.dom</code></td>
<td>
<p>List. List of color palettes for the states of each domain. By default, the <code>cpal</code> attribute of each element of the list <code>channels</code> is used (see <code><a href="#topic+seqdef">seqdef</a></code>). If user specified, each element of the list should be a vector of colors of length of the alphabet of the corresponding element of <code>channels</code>.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_missing.color">missing.color</code></td>
<td>
<p>Color for representing missing values inside the sequences. By default, this color is taken for each domain from the <code>missing.color</code> attribute of the corresponding element of <code>channels</code>.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_ylab">ylab</code></td>
<td>
<p>Character string or vector of strings. Optional label of the y-axis. If a vector, y-axis label of each group level. If set as <code>NA</code>, no label is drawn.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_yaxis">yaxis</code></td>
<td>
<p>Logical or one of <code>"all"</code> or <code>"left"</code>. If set as <code>TRUE</code> or <code>"all"</code> (default value), sequence indexes are displayed for <code>"i"</code> and <code>"I"</code>, mean time values for <code>"mt"</code>, percentages for <code>"d"</code> and <code>"f"</code>, and state/event labels for <code>"pc"</code>.  If <code>"left"</code> and <code>group</code> is used, the y-axis is displayed on plots of the left panel only. If <code>FALSE</code> no y-axis is drawn. Ignored when <code>type="r"</code>. For <code>type="f"</code>, can also be one of <code>"pct"</code> and <code>"left.pct"</code>
</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_xaxis">xaxis</code></td>
<td>
<p>Logical or one of <code>"all"</code> or <code>"bottom"</code>. If set as <code>TRUE</code> or <code>"all"</code> (default value) x-axes are drawn for each plot in the graphic. If set as <code>"bottom"</code> is used, axes are drawn under the plots of the bottom panel only. If <code>FALSE</code>, no x-axis is drawn.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_xtlab">xtlab</code></td>
<td>
<p>Vector of length equal to the maximal length of the sequences. Optional labels of the x-axis tick labels. If unspecified, column names of the elements of <code>channels</code> are used (see <code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_stats">stats</code></td>
<td>
<p>Logical or one of <code>"all"</code> or <code>"first"</code>. When <code>type="r"</code>, if <code>"all"</code> (default), stats of the MD representatives are displayed on all plots and if <code>"first"</code>, MD stats are displayed only on the plot of the first domain. Ignored for all non-<code>"r"</code> types.</p>
</td></tr>   
<tr><td><code id="seqplotMD_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Real value.
Axis annotation magnification. When <code>type = "r"</code> and for <code>seqrplot()</code>,
it also determines the magnification of the plotted text and symbols.
See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_with.legend">with.legend</code></td>
<td>
<p>Character string or logical. Should legends of the state colors be plotted? Default value <code>"auto"</code> sets the position of the legend automatically. Value <code>TRUE</code> is equivalent to <code>"auto"</code>.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_ltext.dom">ltext.dom</code></td>
<td>
<p>List. List of vector of character strings of length and order corresponding to the alphabet of the corresponding elements of  <code>channels</code>. Optional description of the states to appear in the legend. If unspecified, the <code>label</code> attribute of the corresponding sequence object in <code>channels</code> is used (see <code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Real. Legend magnification. See <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_legend.prop">legend.prop</code></td>
<td>
<p>Real in range [0,1]. Proportion of the graphic area devoted to the legends when <code>with.legend=TRUE</code>. Default value used depends of <code>dom.byrow</code>.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_dom.byrow">dom.byrow</code></td>
<td>
<p>Logical. Should domains be displayed by row?</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_dom.crit">dom.crit</code></td>
<td>
<p>Integer in range <code>[-2,ndom]</code> where <code>ndom</code> is number of domains. Applies when  <code>sortv</code> is provided among the <code>...</code> arguments and is one of <code>"from.start"</code> or <code>"from.end"</code>. Domain on which sorting is done. When 0 (default), sorting is done on  multidomain sequences, when -1, sorting is done on first domain then, for ties, successively on the next domains, when -2, sorting is done across domains at each successive position. Does not apply when <code>sortv="mds"</code> for <code>"rf"</code> plots.</p>
</td></tr>
<tr><td><code id="seqplotMD_+3A_dnames">dnames</code></td>
<td>
<p>String vector. Names of the domains.</p>
</td></tr> 
<tr><td><code id="seqplotMD_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function called to produce the appropriate statistics and the associated plot method (see details), or other graphical parameters. For example, the <code>weighted</code> argument can be passed to control whether (un)weighted statistics are produced, and <code>with.missing=TRUE</code> to take missing values into account when computing cross-sectional or longitudinal state distributions. Can also include arguments of <code><a href="graphics.html#topic+legend">legend</a></code> such as <code>bty="n"</code> to suppress the box surrounding the legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>seqplotMD</code> function is intended for multidomain (or multichannel) sequences, i.e. situations where each case is represented by a sequence in each of several domains. The elements (set of state sequences) of the <code>channels</code> list are assumed to be paired. Sequences defined in terms of the expanded alphabet formed by the combination of the domain states are called MD sequences. Although the MD sequences may be used for some computations, <code>seqplotMD</code> does not plot the MD sequences themselves, but the corresponding domain sequences. 
</p>
<p>For details on the types of plot, see <code><a href="#topic+seqplot">seqplot</a></code>.
</p>
<p>The function organizes the plot area with either domains in rows, groups in columns, and domain legend on the right of each row, or conversely when <code>dom.byrow=FALSE</code>. Panel titles are defined as &quot;group level: domain&quot;, and are preceded by <code>main</code> when a main value is provided.
</p>
<p>The function takes the matching constraints into account as follows:
</p>
<p>- For index plots (<code>"i", "I"</code>), sequences are displayed in same order for each domain.  When a <code>sortv</code> vector is provided among the <code>...</code> list, this same sort order is applied to all domains. If a <code>sortv</code> method is provided, the sorting is computed on the domain specified by the <code>dom.crit</code> argument. When there is a <code>which.plot</code> argument (for <code>type="rf"</code>) in the <code>...</code> list, it cannot be <code>"both"</code>.
</p>
<p>- Likewise, for relative frequency plots (<code>"rf"</code>) the same order is retained for all domains. The <code>sortv</code> argument is handled as for <code>"i"</code> and <code>"I"</code>, except for <code>sortv="mds"</code>, in which case the sorting is done using the provided <code>diss</code> matrix. 
</p>
<p>- For frequency plots (<code>"f"</code>), sequences displayed correspond to the most frequent MD sequences.
</p>
<p>- For plots of representative sequences (<code>"r"</code>), the representatives are computed for the provided <code>diss</code> matrix (generally the distances between the MD sequences) and their representation in each domain are displayed. Likewise, for <code>type="rf"</code>, the medoids of the equally sized groups are computed using the required <code>diss</code> matrix.
</p>
<p>- When <code>type="mt"</code>, mean time plot, and there is a <code>bar.labels</code> argument among the <code>...</code> list, <code>bar.labels</code> should be a list of vector or matrices of bar labels by domain.
</p>
<p>No special handling other than the domain-group titles and the organization of the plot panels is applied to other types (<code>"d","dH","Ht","ms","pc"</code>).
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Ritschard, G., T.F. Liao, and E. Struffolino (2023). Strategies for
multidomain sequence analysis in social research.
<em>Sociological Methodology</em>, 53(2), 288-322. <a href="https://doi.org/10.1177/00811750231163833">doi:10.1177/00811750231163833</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqplot">seqplot</a></code>,
<code><a href="#topic+plot.stslist">plot.stslist</a></code>,  <code><a href="#topic+seqstatd">seqstatd</a></code>, <code><a href="#topic+plot.stslist.statd">plot.stslist.statd</a></code>, <code><a href="#topic+seqtab">seqtab</a></code>, <code><a href="#topic+plot.stslist.freq">plot.stslist.freq</a></code>, <code><a href="#topic+seqmodst">seqmodst</a></code>, <code><a href="#topic+plot.stslist.modst">plot.stslist.modst</a></code>, <code><a href="#topic+seqmeant">seqmeant</a></code>, <code><a href="#topic+plot.stslist.meant">plot.stslist.meant</a></code>, <code><a href="#topic+seqrep">seqrep</a></code>, <code><a href="#topic+plot.stslist.rep">plot.stslist.rep</a></code>, <code><a href="#topic+seqrf">seqrf</a></code>, 
<code><a href="#topic+plot.seqrf">plot.seqrf</a></code>, <code><a href="#topic+seqpcplot">seqpcplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)

## Building one channel per type of event (left, children or married)
cases &lt;- 200
bf &lt;- as.matrix(biofam[1:cases, 10:25])
children &lt;-  bf==4 | bf==5 | bf==6
married &lt;- bf == 2 | bf== 3 | bf==6
left &lt;- bf==1 | bf==3 | bf==5 | bf==6

## Building sequence objects
require(colorspace)
m.col &lt;- sequential_hcl(2, palette = "PurpOr")
c.col &lt;- sequential_hcl(2, palette = "Mint")
l.col &lt;- sequential_hcl(2, palette = "OrYel")

child.seq &lt;- seqdef(children, weights=biofam[1:cases,"wp00tbgs"], cpal=c.col)
marr.seq &lt;- seqdef(married, weights=biofam[1:cases,"wp00tbgs"], cpal=m.col)
left.seq &lt;- seqdef(left, weights=biofam[1:cases,"wp00tbgs"], cpal=l.col)
seqdom &lt;- list(LeftHome=left.seq,Marr=marr.seq,Child=child.seq)


seqplotMD(seqdom, type="d", group=biofam[1:cases,"sex"], xaxis="bottom")

seqplotMD(seqdom, type="dH", group=biofam[1:cases,"sex"], dom.byrow=TRUE, 
    xaxis="bottom", yaxis="left")

seqplotMD(seqdom, type="mt", group=biofam[1:cases,"sex"])

seqplotMD(seqdom, type="I", group=biofam[1:cases,"sex"],  
    xaxis="bottom", sortv="from.end")

## sorting on first domain
seqplotMD(seqdom, type="I", group=biofam[1:cases,"sex"],  
    xaxis="bottom", sortv="from.start", dom.crit=1)

seqplotMD(seqdom, type="f", group=biofam[1:cases,"sex"],   
    xaxis="bottom", yaxis="left")

## distances betweem MD sequences
MDseq &lt;- seqMD(seqdom, what="MDseq", ch.sep="+")
diss &lt;- seqdist(MDseq, method="OM", sm="INDELSLOG")

seqplotMD(seqdom, type="rf", group=biofam[1:cases,"sex"],  
    xaxis="bottom", sortv="from.end", dom.crit=0, diss=diss, k=10)

seqplotMD(seqdom, type="r", group=biofam[1:cases,"sex"],  
    xaxis="bottom", dom.crit=0, diss=diss)


</code></pre>

<hr>
<h2 id='seqpm'>Find substring patterns in sequences</h2><span id='topic+seqpm'></span>

<h3>Description</h3>

<p>Search for a pattern (substring) into sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqpm(seqdata, pattern, sep="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqpm_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqpm_+3A_pattern">pattern</code></td>
<td>
<p>a character string representing the pattern (substring) to search for.</p>
</td></tr>
<tr><td><code id="seqpm_+3A_sep">sep</code></td>
<td>
<p>state separator used in the pattern definition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function searches a pattern (a character string) into a set of sequences and returns the results as a list with two elements: '<code>Nbmatch</code>' the number of occurrences of the pattern and '<code>MatchesIndex</code>' the vector of indexes (row numbers) of the sequences that match the pattern (see examples below).
</p>


<h3>Value</h3>

<p>a list with two elements (see details).</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24)

## search for pattern "DAAD"
## (no work-full time work-full time work-no work)
## results are stored in the 'daad' object
daad &lt;- seqpm(actcal.seq,"DAAD")

## Looking at the sequences
## containing the pattern
actcal.seq[daad$MIndex,]

## search for pattern "AD"
## (full time work-no work)
seqpm(actcal.seq,"AD")
</code></pre>

<hr>
<h2 id='seqprecarity'>Degradation, Precarity, and Insecurity indexes</h2><span id='topic+seqidegrad'></span><span id='topic+seqprecarity'></span><span id='topic+seqinsecurity'></span><span id='topic+seqprecorr'></span><span id='topic+print.seqidegrad'></span><span id='topic+print.seqprec'></span>

<h3>Description</h3>

<p>The degradation index returned by <code>seqidegrad</code> is a normalized transformation of the difference between the proportion of downward and upward state changes (transitions).
The precarity and insecurity indexes are composite measures of complexity, degradation tendency, and undesirableness of the first state in the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqidegrad(seqdata, state.order=alphabet(seqdata, with.missing), state.equiv=NULL,
    stprec=NULL, with.missing=FALSE,
    penalized="BOTH", method="RANK", weight.type="ADD",
    pow=1, border.effect=10)

seqprecarity(seqdata, correction=NULL,
    state.order=alphabet(seqdata, with.missing), state.equiv=NULL,
    stprec=NULL, with.missing=FALSE,
    otto=.2, a=1, b=1.2, method = "TRATEDSS",
    ...)

seqinsecurity(seqdata, correction=NULL,
    state.order=alphabet(seqdata, with.missing), state.equiv=NULL,
    stprec=NULL, with.missing=FALSE,
    pow = 1, spow=pow, bound=FALSE, method = "RANK",
    ...)

seqprecorr(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqprecarity_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (class <code>stslist</code>) as returned by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>

<tr><td><code id="seqprecarity_+3A_correction">correction</code></td>
<td>
<p>Vector of non-negative correction factor values. If <code>NULL</code> (default), the correction factor is set as the degradation value returned by <code>seqidegrad</code>. See details.</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_state.order">state.order</code></td>
<td>
<p>Vector of short state labels defining the order of the states. First the less precarious (most positive) state and then the other states in increasing precariousness order. States of the alphabet that are not included here (and are not equivalent to one of the listed state) define the non-comparable states.</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_state.equiv">state.equiv</code></td>
<td>
<p>List of state equivalence classes. Each class in the list is given as the vector of the short labels of the states forming the class. </p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_stprec">stprec</code></td>
<td>
<p>Vector of state undesirableness degrees. If <code>NULL</code> the values are derived from the state order using <code><a href="#topic+seqprecstart">seqprecstart</a></code>. If not <code>NULL</code>, the values in <code>stprec</code> should conform the order of the alphabet.
Use negative values to indicate non-comparable states. See details.</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. Should the missing state be considered as an element of the alphabet?</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_otto">otto</code></td>
<td>
<p>Scalar in the range [0,1]. Trade-off weight between the precarity degree of the initial state and the corrected complexity. Default is <code>otto=.2</code></p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_a">a</code></td>
<td>
<p>Non-negative real value. Exponent weight of the complexity. Default is 1.</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_b">b</code></td>
<td>
<p>Non-negative real value. Exponent weight of the correction factor. Default is 1.2. </p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_penalized">penalized</code></td>
<td>
<p>One of <code>'BOTH'</code> (default), <code>'NEG'</code>, <code>'POS'</code>, or <code>'NO'</code>. What should be penalized or rewarded? <code>'NEG'</code> only negative transitions, <code>POS</code> only positive transitions (with negative penalization), <code>'BOTH'</code> penalize negative transitions and reward positive ones, <code>NO</code> no penalization. Can also be logical with <code>TRUE</code> equivalent to <code>'BOTH'</code> and <code>FALSE</code> equivalent to <code>'NO'</code>.</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_method">method</code></td>
<td>
<p>One of <code>'FREQ'</code>, <code>'FREQ+'</code>, <code>'TRATE'</code>, <code>'TRATE+'</code>, <code>'TRATEDSS'</code> (default for <code>seqprecarity</code> for backward compatibility), <code>'TRATEDSS+'</code>, <code>'RANK'</code> (default for <code>seqinsecurity</code> and <code>seqidegrad</code>), <code>'RANK+'</code>, or <code>'ONE'</code>. Method for determining transition weights. Weights based on transition probabilities: <code>'FREQ'</code> overall frequency of the transitions, <code>'TRATE'</code> transition probabilities, and <code>'TRATEDSS'</code> transition probabilites in the DSS sequences. <code>'RANK'</code> differences between state undesirableness degrees. <code>'ONE'</code> no weight. With the <code>+</code> form the returned penalty is adjusted by the mean transition weight in the sequence.</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_weight.type">weight.type</code></td>
<td>
<p>One of <code>'ADD'</code> (default), <code>'INV'</code>, or <code>'LOGINV'</code>. When <code>method</code> is one of <code>'FREQ'</code>, <code>'TRATE'</code> or <code>'TRATEDSS'</code>, how weights are derived from the transition probabilities: <code>'ADD'</code> additive (1-p), <code>'INV'</code> inverse (1/p), and <code>'LOGINV'</code> log of inverse. Ignored when any other <code>method</code> is selected.</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_pow">pow</code></td>
<td>
<p>Real or logical. Recency weight exponent for potential to integrate the next spell. If real, transition weights are  adjusted by the potential to integrate the next state using the <code>pow</code> value. <code>pow=TRUE</code> is equivalent to <code>pow=1</code>. (See details.)</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_spow">spow</code></td>
<td>
<p>Real. Recency weight exponent for potential to integrate the first spell.</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_bound">bound</code></td>
<td>
<p>Logical. Should the insecurity index be bounded by undesirableness degrees of best and worst states in the sequence?</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_border.effect">border.effect</code></td>
<td>
<p>Real. Value (strictly greater than 1) used to adjust estimated transition probabilities to avoid border effect. Default is 10. See details.</p>
</td></tr>
<tr><td><code id="seqprecarity_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>seqidegrad</code> when <code>correction=NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>seqidegrad</code> function returns for each sequence <code class="reqn">x</code> the difference <code class="reqn">q(x)</code> between the proportions of downward and upward transitions (state changes).
</p>
<p>The argument <code>penalized</code> allows to chose between three strategies for computing <code class="reqn">q(x)</code>: only penalizing negative weights (in which case <code class="reqn">q(x)</code> is the proportion of negative transitions), only rewarding (with negative penalties) positive transitions, and applying both positive and negative penalties. The transitions can be weighted and the type of transition weights used is selected with the <code>method</code> argument. For weights based on transition probabilities, the way how theses probabilites are transformed into weights is controlled with <code>weight.type</code>. To avoid a border effect, when any computed transition probability <code class="reqn">p</code> is close from 1 (<code class="reqn">p &gt; 1 - .1/d</code>), all <code class="reqn">p</code>'s are adjusted as <code class="reqn">p - p/d</code>, where <code class="reqn">d</code> is the <code>border.effect</code> parameter. With <code>method="RANK"</code>, the weights are set as the differences between the to and from state undesirableness.
When <code>pow</code> is not <code>FALSE</code>, the weight of each transition is multiplied by the potential to integrate the next spell using the provided <code>pow</code> value.
</p>
<p>The precarity and insecurity indexes of a sequence <code class="reqn">x</code> are both based on the complexity index (<cite>Gabadinho et al., 2010</cite>) <code class="reqn">c(x)</code> (See the <code><a href="#topic+seqici">seqici</a></code> function) and the undesirableness degree <code class="reqn">\pi(x_1)</code> of the starting state.
</p>
<p>The precarity applies a multiplicative correction to the complexity. It is defined as
</p>
<p style="text-align: center;"><code class="reqn">prec(x) = \lambda \pi(x_1) + (1-\lambda)(1 + r(x))^\beta c(x)^\alpha</code>
</p>

<p>where <code class="reqn">r(x)</code> is the correction factor (argument <code>correction</code>) for the sequence. The <code class="reqn">\lambda</code> parameter (argument <code>otto</code>) determines the trade-off between the importance of the undesirableness of the starting state and of the corrected complexity index. Parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> (arguments <code>a</code> and <code>b</code>) are exponent weights of respectively the complexity and the correction factor.
</p>
<p>The insecurity index applies an additive correction of the complexity:
</p>
<p style="text-align: center;"><code class="reqn">insec(x) = \pi(x_1) integr(x,sp1) + r(x) + c(x)</code>
</p>

<p>where <code class="reqn">integr(x,sp1)</code> is the potential to integrate the first spell (proportion of sequence length covered by first spell when <code>spow=0</code>).
</p>
<p>When <code>correction = NULL</code> (default), <code class="reqn">r(x)</code> is set as the degradation index <code class="reqn">q(x)</code> provided by <code>seqidegrad</code>. The degradation is computed with <code>pow=FALSE</code> for the precarity and using the provided <code>pow</code> value for the insecurity.
</p>
<p>When <code>stprec</code> is a vector, negative values indicate non-comparable sates that receive each the mean positive undesirableness value. After this transformation, the vector is normalized such that the minimum is 0 and the maximum 1.
</p>
<p>When equivalent classes are provided, the class mean undesirableness degree is assigned to each state of the class (see <code><a href="#topic+seqprecstart">seqprecstart</a></code>). For the count of transitions a same state value is assigned to all equivalent states.
</p>
<p>Non-comparable states (those not listed on the <code>state.order</code> argument and not equivalent to a listed state) all receive the mean undesirableness value. For the count of transitions, transitions from and to non-comparable states are ignored and replaced by a transition between the states that immediately precede and follow a spell in non-comparable states.
</p>
<p>When there are missing states in the sequences, set <code>with.missing = TRUE</code> to treat the missing state as an additional state. In that case the missing state will be considered as non-comparable unless you include the <code>nr</code> attribute of <code>seqdata</code> in <code>state.order</code> or <code>state.equiv</code>. With <code>with.missing = FALSE</code>, transitions to and from the missing state will just be ignored and the undesirableness value of the first valid state will be used as starting undesirableness.
</p>
<p>The earlier <code>seqprecorr</code> function is obsolete, use <code>seqidegrad</code> with <code>pow=FALSE</code> and <code>method='TRATEDSS'</code> instead.
</p>


<h3>Value</h3>

<p>For <code>seqprecarity</code> and <code>seqinsecurity</code>, an object of class <code>seqprec</code> with the value of the precarity or insecurity index for each sequence. The returned object has an attribute <code>stprec</code> that contains the state precarity degree used at the starting position. The associated print method (<code>print.seqprec</code>) prints the state precarity values without the additional attribute.
</p>
<p>For <code>seqidegrad</code> 
an object of class <code>seqidegrad</code> with the degradation index <code class="reqn">q(x)</code>
and as additional attributes: <code>tr</code> the used transition weights; <code>signs</code> the transitions signs; <code>state.noncomp</code> the non-comparable states; and <code>state.order</code> the used state order. The associated print method (<code>print.seqidegrad</code>) prints the outcome values without the additional attributes.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>
<p>Ritschard, G., Bussi, M., and O'Reilly, J. (2018), &quot;An index of precarity for
measuring early employment insecurity&quot;, in G. Ritschard, and M. Studer, <em>Sequence Analysis and Related Approaches: Innovative Methods and Applications</em>, Series Life Course Research and Social
Policies, Vol. 10, pp 279-295. Cham: Springer, <a href="https://doi.org/10.1007/978-3-319-95420-2_16">doi:10.1007/978-3-319-95420-2_16</a>.
</p>
<p>Gabadinho, A., Ritschard, G., Studer, M. and Müller, N.S. (2010), &quot;Indice de complexité pour le tri et la comparaison de séquences catégorielles&quot;, In Extraction et gestion des connaissances (EGC 2010), <em>Revue des nouvelles technologies de l'information RNTI</em>. Vol. E-19, pp. 61-66.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqici">seqici</a></code>, <code><a href="#topic+seqibad">seqibad</a></code>, <code><a href="#topic+seqprecstart">seqprecstart</a></code>, <code><a href="#topic+seqindic">seqindic</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with columns 13 to 24
## in the 'actcal' example data set
data(actcal)
actcal &lt;- actcal[1:20,] ## Here, only a subset
actcal.seq &lt;- seqdef(actcal[,13:24], alphabet=c('A','B','C','D'))

## insecurity and precarity using the original state order
insec &lt;- seqinsecurity(actcal.seq)
prec &lt;- seqprecarity(actcal.seq)
ici &lt;- seqici(actcal.seq) ## complexity

seqn &lt;- seqformat(actcal.seq, to="SPS", compress=TRUE)
tab &lt;- data.frame(seqn,ici,insec,prec)
names(tab) &lt;- c("seq","ici","insec","prec")
tab

## Assuming A and B as equivalent regarding insecurity
insec2 &lt;- seqinsecurity(actcal.seq, state.equiv=list(c('A','B')))
tab &lt;- cbind(tab,insec2)
names(tab)[ncol(tab)] &lt;- "insec2"

## and letting C be non-comparable
insec3 &lt;- seqinsecurity(actcal.seq, state.order=c("A","B","D"),
  state.equiv=list(c('A','B')))
tab &lt;- cbind(tab,insec3)
names(tab)[ncol(tab)] &lt;- "insec3"

## bounding insecurity with undesirableness of best and worst state in sequence
insec4 &lt;- seqinsecurity(actcal.seq, state.order=c("A","B","D"),
  state.equiv=list(c('A','B')), bound=TRUE)
tab &lt;- cbind(tab,insec4)
names(tab)[ncol(tab)] &lt;- "insec4"

## degrading index
degr &lt;- seqidegrad(actcal.seq, state.order=c("A","B","D"),
                  state.equiv=list(c('A','B')))
tab &lt;- cbind(tab,degr)
names(tab)[ncol(tab)] &lt;- "degr"
tab

## Precarity with transition weights based on differences in state undesirableness
prec.rank &lt;- seqprecarity(actcal.seq, method='RANK')

###############
## Indexes in presence of missing values:
##  missing state treated as an additional state
data(ex1)
## by default right missings are dropped from the sequences
s.ex1 &lt;- seqdef(ex1[,1:13])
state.order=c("A","B","C","D") ## missing left as non-comparable
seqprecarity(s.ex1, state.order=state.order, with.missing=TRUE)
seqinsecurity(s.ex1, state.order=state.order, with.missing=TRUE)

## same result using the correction argument
dgp &lt;- seqidegrad(s.ex1, with.missing=TRUE, state.order=state.order, method='TRATEDSS')
seqprecarity(s.ex1, state.order=state.order, with.missing=TRUE, correction=dgp)

dg &lt;- seqidegrad(s.ex1, with.missing=TRUE, state.order=state.order)
seqinsecurity(s.ex1, state.order=state.order, with.missing=TRUE, correction=dg)

## bounding insecurity with undesirableness of best and worst state in sequence
seqinsecurity(s.ex1, state.order=state.order, with.missing=TRUE, bound=TRUE)


</code></pre>

<hr>
<h2 id='seqprecstart'>State precarity</h2><span id='topic+seqprecstart'></span>

<h3>Description</h3>

<p>Determines the state undesirableness degree from the state ordering or conversely the state undesirableness values from the state ordering. (See details.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqprecstart(seqdata,
    state.order=alphabet(seqdata, with.missing), state.equiv=NULL,
    stprec=NULL, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqprecstart_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object (class <code>stslist</code>) as returned by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqprecstart_+3A_state.order">state.order</code></td>
<td>
<p>Vector of short state labels defining the order of the states. First the most desirable (most positive) state and then the other states in decreasing desirability order. States of the alphabet that are not included here define the non-comparable states.</p>
</td></tr>
<tr><td><code id="seqprecstart_+3A_state.equiv">state.equiv</code></td>
<td>
<p>List of state equivalence classes. The classes in the list are each set as the vector of the short labels of the states forming the class. </p>
</td></tr>
<tr><td><code id="seqprecstart_+3A_stprec">stprec</code></td>
<td>
<p>Vector of user defined state undesirableness degrees ordered conformably with the alphabet of <code>seqdata</code>. Use negative values to indicate non-comparable states.</p>
</td></tr>
<tr><td><code id="seqprecstart_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. Should the missing state be considered as an element of the alphabet?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>stprec</code> is provided, the order is determined from the <code>stprec</code> values and overwrites <code>state.order</code>.
</p>
<p>When <code>stprec=NULL</code>, the initial state undesirableness degrees are set as equivalently spaced values between 0 and 1 assigned to the states in specified order by <code>state.order</code>.
</p>
<p>Equivalent states get the mean value of the states in the equivalence class.
</p>
<p>Incomparable states (those not on the <code>state.order</code> list and not member of an equivalent class having a state listed in <code>state.order</code>) receive the average of all state undesirableness degrees.
</p>
<p>When <code>stprec</code> is user defined, the provided vector is normalized into a vector with minimum 0 and maximum 1 and mean value of states in a class are assigned to all class members.
</p>
<p>Only one state per class needs to be on the state order list. If more than one member is on the state order list they should be listed consecutively. Note that currently no check is performed.
</p>
<p>When <code>with.missing=TRUE</code>, use the <code>seqdata, "nr"</code> argument to possibly include it in the <code>state.order</code> or <code>state.equiv</code>.
</p>


<h3>Value</h3>

<p>The vector of assigned undesirableness degrees sorted according to the original order of states in the alphabet.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>
<p>Ritschard, G., Bussi, M., and O'Reilly, J. (2018), &quot;An index of precarity for
measuring early employment insecurity&quot;, in G. Ritschard, and M. Studer, <em>Sequence Analysis and Related Approaches: Innovative Methods and Applications</em>, Series Life Course Research and Social
Policies, Vol. 10, pp 279-295. Cham: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqprecarity">seqprecarity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with columns 13 to 24
## in the 'actcal' example data set
data(actcal)
actcal &lt;- actcal[1:200,] ## Here, only a subset
actcal.seq &lt;- seqdef(actcal[,13:24])

## state precarity levels using the original state order
seqprecstart(actcal.seq)

## Assuming A and B as equivalent regarding precarity
seqprecstart(actcal.seq, state.equiv=list(c('A','B')))

## and letting C be non-comparable
seqprecstart(actcal.seq, state.order=c("A","B","D"), state.equiv=list(c('A','B')))

</code></pre>

<hr>
<h2 id='seqrecode'>
Recoding state sequence objects and factors
</h2><span id='topic+seqrecode'></span><span id='topic+recodef'></span>

<h3>Description</h3>

<p>Utilities for recoding factors or state sequence objects created with <code><a href="#topic+seqdef">seqdef</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqrecode(seqdata, recodes, otherwise = NULL,
     labels = NULL, cpal = NULL)
recodef(x, recodes, otherwise=NULL, na=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqrecode_+3A_seqdata">seqdata</code></td>
<td>

<p>The state sequence object to be recoded (created with <code><a href="#topic+seqdef">seqdef</a></code>).
</p>
</td></tr>
<tr><td><code id="seqrecode_+3A_recodes">recodes</code></td>
<td>
<p>A <code>list</code> specifying the recoding operations where each element is in the form <code>newcode=oldcode</code> or <code>newcode=c(oldcode1, oldcode2,...)</code>. The rules are treated in the same order as they appear, hence subsequent rules may modify the first ones.</p>
</td></tr>
<tr><td><code id="seqrecode_+3A_otherwise">otherwise</code></td>
<td>
<p><code>NULL</code> or Character. Level given to cases uncovered by the <code>recodes</code> list. If <code>NULL</code>, old states remain unchanged.</p>
</td></tr>
<tr><td><code id="seqrecode_+3A_labels">labels</code></td>
<td>
<p>optional state labels used for the color legend of TraMineR's graphics. If <code>NULL</code> (default), the state names in the alphabet are also used as state labels (see <code><a href="#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="seqrecode_+3A_cpal">cpal</code></td>
<td>
<p>an optional color palette for representing the newly defined alphabet in graphics. If <code>NULL</code> (default), a color palette is created from the colors in <code>seqdata</code> by assigning to <code>newcode</code> the color of the first old state listed as <code>oldcode</code> and by leaving the colors of the other states unchanged.
</p>
</td></tr>
<tr><td><code id="seqrecode_+3A_x">x</code></td>
<td>
<p>A factor to be recoded.</p>
</td></tr>
<tr><td><code id="seqrecode_+3A_na">na</code></td>
<td>
<p>Character vector. If not <code>NULL</code>, the list of states that should be recoded as <code>NA</code> (missing values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p> The recoded factor or state sequence object.</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdef">seqdef</a></code> to create a state sequence object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Recoding a state sequence object with seqrecode
data(actcal)
## Creating a state sequence object
actcal.seq &lt;- seqdef(actcal,13:24, labels=c("&gt; 37 hours", "19-36 hours",
   "1-18 hours", "no work"))
## Regrouping states B and C and setting the whole alphabet to A BC D
actcal.new &lt;-seqrecode(actcal.seq,
    recodes = list("A"="A", "BC"=c("B", "C"), "D"="D"))
## Crosstabulate the first column of the recoded and
## original state sequence objects
table(actcal.new[,1], actcal.seq[,1])

## Same as before but using automatically original
## codes for unspecified states.
actcal.new2 &lt;-seqrecode(actcal.seq,
	recodes = list("BC"=c("B", "C")))
table(actcal.new2[,1], actcal.seq[,1])

## Same as before but using otherwise
actcal.new3 &lt;-seqrecode(actcal.seq, recodes = list("A"="A", "D"="D"),
   otherwise="BC")
table(actcal.new3[,1], actcal.seq[,1])

## Recoding factors
## Recoding the marital status to oppose married to all other case
maritalstatus &lt;- recodef(actcal$civsta00,
	recodes=list("Married"="married"), otherwise="Single")
summary(maritalstatus)
table(maritalstatus, actcal$civsta00)

## Recoding the number of kids in the household
## -2 is a missing value
nbkids &lt;- recodef(actcal$nbkid00,
   recodes=list("None"=0, "One"=1, "Two or more"=2:10), na=-2)
table(nbkids, actcal$nbkid00, useNA="always")

</code></pre>

<hr>
<h2 id='seqrep'>Extracting sets of representative sequences</h2><span id='topic+seqrep'></span>

<h3>Description</h3>

<p>Returns either an as small as possible set of non redundant representatives covering (having in their neighborhood) a desired percentage of all sequences, or a given number of patterns with highest coverage. Special cases are single representatives such as the medoid or the sequence pattern with densest neighborhood. See <code><a href="#topic+plot.stslist.rep">plot.stslist.rep</a></code> for the plot method and <code><a href="#topic+seqplot">seqplot</a></code> for other plot options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqrep(seqdata, criterion = "density", score = NULL, decreasing = TRUE,
  coverage = 0.25, nrep = NULL, pradius = 0.10, dmax = NULL, diss = NULL,
  weighted = TRUE, trep, tsim, dist.matrix, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqrep_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_criterion">criterion</code></td>
<td>
<p>the representativeness criterion for sorting the candidate list. One of <code>"freq"</code> (sequence
frequency), <code>"density"</code> (neighborhood density), <code>"mscore"</code> (mean state frequency), <code>"dist"</code>
(centrality) and <code>"prob"</code> (sequence likelihood). See details.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_score">score</code></td>
<td>
<p>an optional vector of representativeness scores for sorting the sequences in the candidate
list. The length of the vector must be equal to the number of sequences in the sequence object.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_decreasing">decreasing</code></td>
<td>
<p>if a score vector is provided, indicates whether the objects in the candidate list must be sorted in
ascending or descending order of this score. Default is <code>TRUE</code>, i.e. descending. The first object in the candidate list
is then supposed to be the most representative. </p>
</td></tr>
<tr><td><code id="seqrep_+3A_coverage">coverage</code></td>
<td>
<p>coverage threshold, i.e., minimum proportion of sequences that should have a representative in their
neighborhood (neighborhood radius is defined by <code>pradius</code>).</p>
</td></tr>
<tr><td><code id="seqrep_+3A_nrep">nrep</code></td>
<td>
<p>number of representative sequences. If <code>NULL</code> (default), the size of the representative set is
controlled by <code>coverage</code>.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_pradius">pradius</code></td>
<td>
<p>neighborhood
radius as a percentage of the maximum (theoretical)
distance <code>dmax</code>. Defaults to 0.1 (10%). Sequence <code class="reqn">y</code> is
redundant to sequence <code class="reqn">x</code> when it is in the neighborhood of <code class="reqn">x</code>, i.e., within a distance
<code>pradius*dmax</code> from <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_dmax">dmax</code></td>
<td>
<p>maximum theoretical distance. The <code>dmax</code> value is used to derive the neighborhood radius as <code>pradius*dmax</code>. If <code>NULL</code>, the value of <code>dmax</code> is derived from the dissimilarity matrix.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_diss">diss</code></td>
<td>
<p>matrix of pairwise dissimilarities between sequences in <code>seqdata</code>. If <code>NULL</code>, the
matrix is computed by calling the <code><a href="#topic+seqdist">seqdist</a></code> function. In that case, optional arguments to be passed to
the <code>seqdist</code> function (see <code>...</code> hereafter) should also be provided.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_weighted">weighted</code></td>
<td>
<p>logical: Should weights assigned to the state sequence object be accounted for? (See <code><a href="#topic+seqdef">seqdef</a></code>.)
Set as <code>FALSE</code> to ignore the weights.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_trep">trep</code></td>
<td>
<p>Deprecated. Use <code>coverage</code> instead.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_tsim">tsim</code></td>
<td>
<p>Deprecated. Use <code>pradius</code> instead.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_dist.matrix">dist.matrix</code></td>
<td>
<p>Deprecated. Use <code>diss</code> instead.</p>
</td></tr>
<tr><td><code id="seqrep_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to the <code>seqdist</code> function, mainly <code>dist.method</code> specifying the
metric for computing the distance matrix, <code>norm</code> for normalizing the distances, <code>indel</code> and <code>sm</code> for
indel and substitution costs when Optimal Matching metric is chosen. See <code><a href="#topic+seqdist">seqdist</a></code> manual page for
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The representative set is obtained by an heuristic. Representatives are selected by successively extracting from  the sequences sorted by their representativeness score those which are not redundant with already retained representatives. The selection stops when either the desired coverage or the wanted number of representatives is reached. Sequences are sorted either by the values provided as <code>score</code> argument or by specifying one of the following as <code>criterion</code> argument: <code>"freq"</code> (<em>sequence frequency</em>), <code>"density"</code>
(<em>neighborhood density</em>), <code>"mscore"</code> (<em>mean state frequency</em>), <code>"dist"</code>
(<em>centrality</em>), and <code>"prob"</code> (<em>sequence likelihood</em>).
</p>
<p>With the <em>sequence frequency</em> criterion, the more frequent a
sequence the more representative it is supposed to be. Therefore, sequences are sorted in decreasing frequency order.
</p>
<p>The <em>neighborhood density</em> is the
number&mdash;density&mdash;of sequences in the neighborhood of the
sequence. This requires to set the neighborhood radius
<code>pradius</code>.  Sequences are
sorted in decreasing density order.
</p>
<p>The <em>mean state frequency</em> criterion is the mean value of the transversal frequencies of the successive states.
Let <code class="reqn">s=s_{1}s_{2}\cdots s_{\ell}</code> be a sequence of length <code class="reqn">\ell</code> and <code class="reqn">(f_{s_1},
f_{s_2}, \ldots, f_{s_\ell})</code> the frequencies of the states at (time-)position <code class="reqn">(t_1,
t_2,\ldots t_{\ell})</code>. The mean state frequency is the sum of the state frequencies divided by the
sequence length
</p>
<p style="text-align: center;"><code class="reqn">
MSF(s)=\frac{1}{\ell} \sum_{i=1}^{\ell} f_{s_{i}}
</code>
</p>

<p>The lower and upper boundaries of <code class="reqn">MSF</code> are <code class="reqn">0</code> and <code class="reqn">1</code>. <code class="reqn">MSF</code> is equal to <code class="reqn">1</code> when all the sequences
in the set are identical, i.e. when there is a single sequence pattern. The most representative sequence is the one with
the highest score.
</p>
<p>The <em>centrality</em> criterion is the sum of distances to all other sequences. The
smallest the sum, the most representative is the sequence.
</p>
<p>The <em>sequence likelihood</em> <code class="reqn">P(s)</code> is defined as the product of the probability with which each of its observed
successive state is supposed to occur at its position.
Let  <code class="reqn">s=s_{1}s_{2} \cdots s_{\ell}</code>  be a sequence of length <code class="reqn">\ell</code>. Then
</p>
<p style="text-align: center;"><code class="reqn">
P(s)=P(s_{1},1) \cdot P(s_{2},2) \cdots P(s_{\ell},\ell)
</code>
</p>

<p>with <code class="reqn">P(s_{t},t)</code> the probability to observe state <code class="reqn">s_t</code> at position <code class="reqn">t</code>.
<br />
The question is how to determinate the state probabilities <code class="reqn">P(s_{t},t)</code>. One commonly used method for
computing them is to postulate a Markov Chain model, which can be of various order. The implemented criterion considers the
probabilities derived from the first order Markov model, that is each <code class="reqn">P(s_{t},t)</code>, <code class="reqn">t&gt;1</code> is set to the
transition rate <code class="reqn">p(s_t|s_{t-1})</code> estimated across sequences from the observations at positions <code class="reqn">t</code>
and <code class="reqn">t-1</code>. For <code class="reqn">t=1</code>, we set <code class="reqn">P(s_1,1)</code> to the observed frequency of the state <code class="reqn">s_1</code> at position 1.
</p>
<p>The likelihood <code class="reqn">P(s)</code> being generally very small, we use
<code class="reqn">-\log P(s)</code> as sorting criterion. The latter quantity reaches its minimum for
<code class="reqn">P(s)</code> equal to 1, which leads to sort the sequences in
ascending order of their score.
</p>
<p>Use <code>criterion="dist"</code> (centrality) and <code>nrep=1</code> to get the medoid, and <code>criterion="density"</code> and <code>nrep=1</code> to get the densest sequence pattern.
</p>
<p>For more details, see <cite>Gabadinho &amp; Ritschard, 2013</cite>.
</p>


<h3>Value</h3>

<p>An object of class <code>stslist.rep</code>. This is actually a
state sequence object (containing a list of state sequences) with the
following additional attributes:
</p>
<table>
<tr><td><code>Scores</code></td>
<td>
<p>a vector with the representative score of each sequence in the original set given the chosen criterion.</p>
</td></tr>
<tr><td><code>Distances</code></td>
<td>
<p>a matrix with the distance of each sequence to its nearest representative.</p>
</td></tr>
<tr><td><code>Rep.group</code></td>
<td>
<p>vector with, for each sequence, the representative that represents it.</p>
</td></tr>
<tr><td><code>idx.rep</code></td>
<td>
<p>list with indexes of occurrences of each representative in original data.</p>
</td></tr>
<tr><td><code>Statistics</code></td>
<td>
<p>a data frame with quality measures for each representative sequence: number <code class="reqn">na</code> of sequences
attributed to the representative, number <code class="reqn">nb</code> of sequences in the representative's neighborhood, mean distance <code class="reqn">MD</code> to the
representative and a few other indexes.</p>
</td></tr>
<tr><td><code>Quality</code></td>
<td>
<p>overall quality measure.</p>
</td></tr>
</table>
<p>Print, plot and summary methods are available. More elaborated plots
are produced by the <code><a href="#topic+seqplot">seqplot</a></code> function using the <code>type="r"</code>
argument, or the <code><a href="#topic+seqrplot">seqrplot</a></code> alias. </p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>References</h3>

<p>Gabadinho A, Ritschard G (2013). &quot;Searching for typical life trajectories applied to child birth histories&quot;, In R Lévy, E. Widmer (eds.), <em>Gendered Life Courses</em>, pp. 287-312. Vienna: LIT.
</p>
<p>Gabadinho A, Ritschard G, Studer M, Müller NS (2011). &quot;Extracting and Rendering Representative Sequences&quot;, In A Fred, JLG Dietz, K Liu, J Filipe (eds.), <em>Knowledge Discovery, Knowledge Engineering and Knowledge Management</em>, volume 128 of <em>Communications in Computer and Information Science (CCIS)</em>, pp. 94-106. Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqplot">seqplot</a></code>, <code><a href="#topic+plot.stslist.rep">plot.stslist.rep</a></code>, <code><a href="#topic+dissrep">dissrep</a></code>, <code><a href="#topic+disscenter">disscenter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Defining a sequence object with the data in columns 10 to 25
## (family status from age 15 to 30) in the biofam data set
data(biofam)
biofam.lab &lt;- c("Parent", "Left", "Married", "Left+Marr",
"Child", "Left+Child", "Left+Marr+Child", "Divorced")
biofam.seq &lt;- seqdef(biofam[,10:25], labels=biofam.lab)

## Computing the distance matrix
costs &lt;- seqsubm(biofam.seq, method="TRATE")
biofam.om &lt;- seqdist(biofam.seq, method="OM", sm=costs)

## Representative set using the neighborhood density criterion
biofam.rep &lt;- seqrep(biofam.seq, diss=biofam.om, criterion="density")
biofam.rep
summary(biofam.rep)
plot(biofam.rep)

## plot by groups represented by the representatives
seqdplot(biofam.seq, group=attr(biofam.rep,"Rep.group"), border=NA)

## indexes of sequences represented by 1st representative
r1.grp &lt;- which(attr(biofam.rep,"Rep.group")==1)
## indexes of occurrences of the first representative sequence
attr(biofam.rep,"idx.rep")[[1]]
</code></pre>

<hr>
<h2 id='seqsep'>Adds separators to sequences stored as character string</h2><span id='topic+seqsep'></span>

<h3>Description</h3>

<p>Adds separators to sequences stored as character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqsep(seqdata, sl=1, sep="-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqsep_+3A_seqdata">seqdata</code></td>
<td>
<p>a dataframe or matrix containing sequence data, as vectors of states or events.</p>
</td></tr>
<tr><td><code id="seqsep_+3A_sl">sl</code></td>
<td>
<p>the length of the states (the number of characters used to represent them). Default is 1.</p>
</td></tr>
<tr><td><code id="seqsep_+3A_sep">sep</code></td>
<td>
<p>the character used as separator. Set by default as <code>"-"</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+seqdecomp">seqdecomp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seqsep("ABAAAAAAD")</code></pre>

<hr>
<h2 id='seqST'>Sequences turbulence</h2><span id='topic+seqST'></span>

<h3>Description</h3>

<p>Elzinga's turbulence for each sequence in a sequence data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqST(seqdata, norm=FALSE, silent=TRUE, with.missing=FALSE, type=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqST_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object as returned by the the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqST_+3A_norm">norm</code></td>
<td>
<p>logical: should the turbulence index be normalized?</p>
</td></tr>
<tr><td><code id="seqST_+3A_silent">silent</code></td>
<td>
<p>logical: should messages about running operations (extracting dss and durations, computing turbulence) be displayed?</p>
</td></tr>
<tr><td><code id="seqST_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state? If <code>FALSE</code> (default) missing values are ignored.</p>
</td></tr>
<tr><td><code id="seqST_+3A_type">type</code></td>
<td>
<p>either 1 or 2. Type of duration variance. The default <code>type=1</code> ignores non visited states. Type 2 takes into account the 0-time spent in non-visited states  (see <code><a href="#topic+seqivardur">seqivardur</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sequence turbulence is a measure proposed by <cite>Elzinga
&amp; Liefbroer (2007)</cite>. It is based on the number <code class="reqn">\phi(x)</code>
of distinct subsequences that can be extracted from the distinct
successive state (DSS) sequence and the variance of the consecutive times <code class="reqn">t_i</code>
spent in the distinct states. For a sequence <code class="reqn">x</code>, the formula is
</p>
<p style="text-align: center;"><code class="reqn">T(x)=\log_{2}(\phi(x)\,\frac{s_{t,max}^2(x) + 1}{s_t^2(x) + 1})</code>
</p>

<p>where <code class="reqn">s_t^2(x)</code> is the variance of the successive state
durations in sequence <code class="reqn">x</code> and <code class="reqn">s_{t,max}^2(x)</code> is the maximum
value that this variance can take given the number of spells and the total
duration of the sequence. For <code>type=1</code>, this maximum is computed as
</p>
<p style="text-align: center;"><code class="reqn">s_{t,max}^2 =(d-1)(1-\bar{t})^2</code>
</p>

<p>where <code class="reqn">\bar{t}</code> is the mean consecutive time spent in the
distinct states, i.e. the sequence duration <code class="reqn">t</code> divided by the number
<code class="reqn">d</code> of distinct states in the sequence.
For <code>type=2</code>, the variance takes into account the 0-time spent in non-visited states and the maximum is adjusted for the maximum number of non-visited states for the number of spells (see <cite>Ritschard, 2021</cite>).
</p>
<p>When <code>with.missing=TRUE</code>, the function searches for missing states in the sequences and if found, adds the missing state to the alphabet for the computation of the turbulence. In this case the <code><a href="#topic+seqdss">seqdss</a></code> and <code><a href="#topic+seqdur">seqdur</a></code> functions for extracting the distinct successive state sequences and the associated durations are called with the <code>{with.missing=TRUE}</code> argument. Thus, a missing state in a sequence is considered as the occurrence of an additional symbol of the alphabet and two or more consecutive missing states are considered as two or more occurrences of this additional state. E.g. the DSS of <code>A-A-*-*-*-B-B-C-C-D</code> is <code>A-*-B-C-D</code> and the associated durations are <code>2-3-2-2-1</code>.
</p>
<p>The normalized value is obtained by subtracting 1 to the index and then dividing by the resulting value for a sequence made by the successive repetition of the alphabet up to the maximal length in <code>seqdata</code> (<cite>Ritschard, 2021)</cite>).
</p>


<h3>Value</h3>

<p>a sinlge-column matrix of length equal to the number of sequences in
<code>seqdata</code> containing the turbulence value of each sequence. Normalized values are returned when <code>norm=TRUE</code>.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>References</h3>

<p>Elzinga, Cees H. and Liefbroer, Aart C. (2007).
De-standardization of Family-Life Trajectories of Young Adults: A Cross-National Comparison Using Sequence Analysis.
<em>European Journal of Population</em>, 23, 225-250.
</p>
<p>Ritschard, G. (2023), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdss">seqdss</a></code>, <code><a href="#topic+seqdur">seqdur</a></code>, <code><a href="#topic+seqsubsn">seqsubsn</a></code>. For alternative measures of sequence complexity see <code><a href="#topic+seqivolatility">seqivolatility</a></code>,  <code><a href="#topic+seqici">seqici</a></code>, <code><a href="#topic+seqindic">seqindic</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Loading the 'actcal' example data set
  data(actcal)
  ## Here we consider only the first 10 sequences
  actcal &lt;- actcal[1:10,]

  ## Defining a sequence object with data in columns 13 to 24
  ## (activity status from January to December 2000)
  actcal.seq &lt;- seqdef(actcal[,13:24], informat='STS')

  ## Computing the sequences turbulence
  turb &lt;- seqST(actcal.seq)

  ## Normalized turbulence
  turb.norm &lt;- seqST(actcal.seq, norm=TRUE)

  ## Normalized turbulence taking non-visited states into account.
  turb2.norm &lt;- seqST(actcal.seq, norm=TRUE, type=2)

</code></pre>

<hr>
<h2 id='seqstatd'>Sequence of transversal state distributions and their entropies</h2><span id='topic+seqstatd'></span>

<h3>Description</h3>

<p>Returns the state relative frequencies, the number of valid states and the entropy of the state distribution at each position in the
sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqstatd(seqdata, weighted=TRUE, with.missing=FALSE, norm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqstatd_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqstatd_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, distributions account for the weights assigned to the state sequence object
(see <code><a href="#topic+seqdef">seqdef</a></code>).
Set as <code>FALSE</code> if you want ignore the weights.</p>
</td></tr>
<tr><td><code id="seqstatd_+3A_with.missing">with.missing</code></td>
<td>
<p>If <code>FALSE</code> (default value), returned distributions ignore missing values.</p>
</td></tr>
<tr><td><code id="seqstatd_+3A_norm">norm</code></td>
<td>
<p>if <code>TRUE</code> (default value), entropy is normalized, ie divided by the entropy of the alphabet. Set as <code>FALSE</code> if
you want the entropy without normalization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the state distribution at each position in the sequence, the <code>seqstatd</code> function provides also for each time
point the number of valid states and the Shannon entropy of the observed cross-sectional state distribution. Letting <code class="reqn">p_i</code> denote the
proportion of cases in state <code class="reqn">i</code> at the considered position, the entropy is
</p>
<p style="text-align: center;"><code class="reqn">
h(p_1,\ldots,p_s) = -\sum_{i=1}^{s} p_i \log(p_i)
</code>
</p>

<p>where <code class="reqn">s</code> is the size of the alphabet. The log is here the natural (base e) logarithm. The entropy is 0 when all cases are in the same state and is maximal when the same proportion of cases are in each state. The entropy is a measure of the diversity of states observed at the considered position. First studies using sequence of cross-sectional entropies (but with aggregated transversal data) are <cite>Billari (2001)</cite> and <cite>Fussell (2005)</cite>.
</p>


<h3>Value</h3>

<p>A list with three elements: <code>Frequencies</code> (relative frequencies), <code>ValidStates</code> (number of valid states at each position), and <code>Entropy</code> (cross-sectional entropy at each position).
</p>
<p>The returned list has attributes <code>nbseq</code> (number of sequences), <code>cpal</code>, <code>xtlab</code>, <code>xtstep</code>, <code>tick.last</code>, <code>weighted</code>, and <code>norm</code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho and Gilbert Ritschard</p>


<h3>References</h3>

<p>Ritschard, G. (2021), &quot;Measuring the nature of individual sequences&quot;, <em>Sociological Methods and Research</em>, <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>
<p>Billari, F. C. (2001). The analysis of early life courses: complex descriptions of the transition to adulthood.
<em>Journal of Population Research</em> 18 (2), 119-24.
</p>
<p>Fussell, E. (2005). Measuring the early adult life course in Mexico: An application of the entropy index. In R. Macmillan
(Ed.), <em>The Structure of the Life Course: Standardized? Individualized? Differentiated?</em>, Advances in Life Course
Research, Vol. 9, pp. 91-122. Amsterdam: Elsevier.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.stslist.statd">plot.stslist.statd</a></code> the plot method for objects of class <code>stslist.statd</code>, <br />
<code><a href="#topic+seqdplot">seqdplot</a></code> for higher level chronograms (state distribution plots)),<br />
<code><a href="#topic+seqHtplot">seqHtplot</a></code> for transversal entropy line over sequence positions, and<br />
<code><a href="#topic+seqdHplot">seqdHplot</a></code> for chronograms with overlayed entropy line.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)
biofam.seq &lt;- seqdef(biofam,10:25)
sd &lt;- seqstatd(biofam.seq)
## Plotting the state distribution
plot(sd, type="d")

## Line of cross-sectional entropies
plot(sd, type="Ht")

## ====================
## example with weights
## ====================
data(ex1)
ex1.seq &lt;- seqdef(ex1, 1:13, weights=ex1$weights)

## Unweighted
seqstatd(ex1.seq, weighted=FALSE)

seqstatd(ex1.seq, weighted=TRUE)
</code></pre>

<hr>
<h2 id='seqstatf'>State frequencies in the whole sequence data set</h2><span id='topic+seqstatf'></span>

<h3>Description</h3>

<p>Overall frequency of each state of the alphabet in the state sequence object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqstatf(seqdata, weighted = TRUE, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqstatf_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqstatf_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Should frequencies account for weights when present in the state sequence object
(see <code><a href="#topic+seqdef">seqdef</a></code>). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="seqstatf_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. Should non void missing states be treated as regular values? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>seqstatf</code> function computes the (weighted) count and frequency of each state of the alphabet in <code>seqdata</code>, i.e., the (weighted) sum of the occurrences of a state in <code>seqdata</code>.
</p>


<h3>Value</h3>

<p>A data frame with as many rows as states in the alphabet and two columns, one for the count (Freq) and one for the percentage frequencies (Percent).
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqstatd">seqstatd</a></code> for the state distribution by time point (position), <code><a href="#topic+seqistatd">seqistatd</a></code> for the state distribution within each sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object from the actcal data set
data(actcal)
actcal.lab &lt;- c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work")
actcal.seq &lt;- seqdef(actcal, 13:24, labels=actcal.lab)

## States frequencies
seqstatf(actcal.seq)

## Example with weights
data(ex1)
ex1.seq &lt;- seqdef(ex1, 1:13, weights=ex1$weights)

## Unweighted
seqstatf(ex1.seq, weighted=FALSE)

## Weighted
seqstatf(ex1.seq, weighted=TRUE)
</code></pre>

<hr>
<h2 id='seqstatl'>List of distinct states or events (alphabet) in a sequence data set.</h2><span id='topic+seqstatl'></span>

<h3>Description</h3>

<p>Returns a list containing distinct states or events found in a data frame or matrix containing sequence data, the alphabet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqstatl(data, var=NULL, format='STS')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqstatl_+3A_data">data</code></td>
<td>
<p>a data frame, matrix, or character string vector containing sequence data (tibble will be converted with <code>as.data.frame</code>).</p>
</td></tr>
<tr><td><code id="seqstatl_+3A_var">var</code></td>
<td>
<p>the list of columns containing the sequences. Default <code>NULL</code> means all columns. Whether the sequences are in the compressed (character strings) or extended format is automatically detected from the number of columns.</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="seqstatl_+3A_format">format</code></td>
<td>
<p>the format of the sequence data set. One of <code>"STS"</code>, <code>"SPS"</code>, <code>"DSS"</code>. Default is <code>"STS"</code>. The <code>seqstatl</code> function uses the <code><a href="#topic+seqformat">seqformat</a></code> function to translate between formats when necessary.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexis Gabadinho</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>
<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2009). Mining Sequence Data in
<code>R</code> with the <code>TraMineR</code> package: A user's guide. Department of Econometrics and
Laboratory of Demography, University of Geneva.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqformat">seqformat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
seqstatl(actcal,13:24)
</code></pre>

<hr>
<h2 id='seqsubsn'>Number of distinct subsequences in a sequence.</h2><span id='topic+seqsubsn'></span>

<h3>Description</h3>

<p>Computes the number of distinct subsequences in a sequence using Elzinga's algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seqsubsn(seqdata, DSS=TRUE, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqsubsn_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqsubsn_+3A_dss">DSS</code></td>
<td>
<p>if <code>TRUE</code>, the sequences of Distinct Successive States (DSS, see <code><a href="#topic+seqdss">seqdss</a></code>) are first extracted (e.g., the DSS contained in <code>'D-D-D-D-A-A-A-A-A-A-A-D'</code> is <code>'D-A-D'</code>), and the number of distinct subsequences in the DSS is computed. If <code>FALSE</code>, the number of distinct subsequences is computed from sequences as they appear in the input sequence object. Hence the number of distinct subsequences is in most cases much higher with the <code>DSS=FALSE</code> option.</p>
</td></tr>
<tr><td><code id="seqsubsn_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state? 
If <code>FALSE</code> (default) missing values are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first searches for missing states in the sequences and if found, adds the missing state to the alphabet for the extraction of the distinct subsequences. A missing state in a sequence is considered as the occurrence of an additional symbol of the alphabet, and two or more consecutive missing states are considered as two or more occurrences of the same state. The <code>with.missing=TRUE</code> argument is used for calling the <code><a href="#topic+seqdss">seqdss</a></code> function when <code>DSS=TRUE</code>.
</p>


<h3>Value</h3>

<p>Vector with the number of distinct subsequences for each sequence in the input state sequence object.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdss">seqdss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24)

## Number of subsequences with DSS=TRUE
seqsubsn(actcal.seq[1:10,])

## Number of subsequences with DSS=FALSE
seqsubsn(actcal.seq[1:10,],DSS=FALSE)
</code></pre>

<hr>
<h2 id='seqtab'>Frequency table of the sequences</h2><span id='topic+seqtab'></span><span id='topic+print.stslist.freq'></span>

<h3>Description</h3>

<p>Computes the frequency table of the sequences (count and percent of each sequence).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqtab(seqdata, idxs = 1:10, weighted = TRUE, format = "SPS", tlim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqtab_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqtab_+3A_idxs">idxs</code></td>
<td>
<p>returns the table for the sequences at ranks '<code>idxs</code>' in the list of distinct sequences sorted in decreasing order of their frequencies. Default is <code>1:10</code>, i.e. the 10 most frequent sequences. Can be any subset, like <code>5:10</code> (fifth to tenth most frequent sequences) or <code>c(2,10)</code> (second and tenth most frequent sequences). Set <code>idxs=0</code> to get the table for the whole set of distinct sequences.
</p>
</td></tr>
<tr><td><code id="seqtab_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> (default), frequencies account for the weights, if any, assigned to the state sequence object
(see <code><a href="#topic+seqdef">seqdef</a></code>). Set to <code>FALSE</code> for ignoring weights.</p>
</td></tr>
<tr><td><code id="seqtab_+3A_format">format</code></td>
<td>
<p>format used for displaying the rownames (the sequences) in the output table.
Default is SPS format, which yields shorter and more readable sequence representations.
Alternatively, <code>"STS"</code> may be specified.</p>
</td></tr>
<tr><td><code id="seqtab_+3A_tlim">tlim</code></td>
<td>
<p>Deprecated. Use <code>idxs</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>weighted</code> argument has no effect when no weights were assigned to the state sequence object since weights default in that case to 1.</p>


<h3>Value</h3>

<p>An object of class <code>stslist.freq</code>. This is actually a state sequence object (containing a list of state sequences) with added attributes, among others the <code>freq</code> attribute containing the frequency table. There are <code>print</code> and <code>plot</code> methods for such objects. More sophisticated plots can be produced with the <code>seqplot</code> function.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqplot">seqplot</a>, <a href="#topic+plot.stslist.freq">plot.stslist.freq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object from the actcal data set
data(actcal)
actcal.lab &lt;- c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work")
actcal.seq &lt;- seqdef(actcal, 13:24, labels=actcal.lab)

## 10 most frequent sequences in the data
seqtab(actcal.seq)

## With idxs=0, we get all distinct sequences in the data set
## sorted in decreasing order of their frequency
stab &lt;- seqtab(actcal.seq, idxs=0)
head(stab)
tail(stab)

## Example with weights
## from biofam data set using weigths
data(ex1)
ex1.seq &lt;-  seqdef(ex1, 1:13, weights=ex1$weights)

## Unweighted frequencies
seqtab(ex1.seq, weighted=FALSE)

## Weighted frequencies
seqtab(ex1.seq, weighted=TRUE)
</code></pre>

<hr>
<h2 id='seqtransn'>Number of transitions in a sequence</h2><span id='topic+seqtransn'></span>

<h3>Description</h3>

<p>Computes the number of transitions (state changes) in each sequence of a sequence object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqtransn(seqdata, with.missing=FALSE, norm=FALSE, pweight=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqtransn_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object as defined by the
<code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqtransn_+3A_with.missing">with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state? If <code>FALSE</code> (default) missing values are ignored.</p>
</td></tr>
<tr><td><code id="seqtransn_+3A_norm">norm</code></td>
<td>
<p>logical. If set as <code>TRUE</code>, the number of transitions is
divided by its theoretical maximum, the length of the sequence minus
1. When the length of the sequence is 1, the normalized value is set as 0.</p>
</td></tr>
<tr><td><code id="seqtransn_+3A_pweight">pweight</code></td>
<td>
<p>logical. EXPERIMENTAL! If set as <code>TRUE</code>, the count of transition weights  
each transition by its probability of transition in the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A transition in a sequence is a state change between
time/position <code class="reqn">t</code> and <code class="reqn">t+1</code>. For example, the sequence
<code>"A-A-A-A-B-B-A-D-D-D"</code> contains 3 transitions. The maximum
number of transitions a sequence can contain is <code class="reqn">\ell-1</code>
where <code class="reqn">\ell</code> is the length of the sequence. The number of
transitions is obtained by subtracting 1 to the length of the the
Distinct Successive State (DSS) sequence. </p>


<h3>Value</h3>

<p>a state sequence object containing the number of transitions
of each sequence in the object given as argument.</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdss">seqdss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object from columns 13 to 24
## in the 'actcal' example data set
data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24)

## Computing the number of transitions
actcal.trans &lt;- seqtransn(actcal.seq)

## Displaying the DSS for the first 10 sequences
actcal.trans[1:10]

## Example with with.missing argument
data(ex1)
ex1.seq &lt;- seqdef(ex1, 1:13)

seqtransn(ex1.seq)
seqtransn(ex1.seq, with.missing=TRUE)
</code></pre>

<hr>
<h2 id='seqtrate'>Compute transition rates between states</h2><span id='topic+seqtrate'></span>

<h3>Description</h3>

<p>Returns a matrix with transition rates between states, computed from a set of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqtrate(seqdata, sel.states = NULL, time.varying = FALSE, weighted = TRUE,
  lag = 1, with.missing = FALSE, count = FALSE, statl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqtrate_+3A_seqdata">seqdata</code></td>
<td>
<p>a sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="seqtrate_+3A_sel.states">sel.states</code></td>
<td>
<p>a list of states or events for which the transition rates will be computed. If omitted (default), transition rates are computed between the distinct states in seqdata (obtained with the <code><a href="#topic+alphabet">alphabet</a></code> function).</p>
</td></tr>
<tr><td><code id="seqtrate_+3A_time.varying">time.varying</code></td>
<td>
<p>Logical. If <code>TRUE</code>, return an <code><a href="base.html#topic+array">array</a></code> containing a distinct matrix for each time unit. The time is the third dimension (subscript).</p>
</td></tr>
<tr><td><code id="seqtrate_+3A_weighted">weighted</code></td>
<td>
<p>Logical. If <code>TRUE</code>, compute transition rates using weights specified in <code>seqdata</code>.</p>
</td></tr>
<tr><td><code id="seqtrate_+3A_lag">lag</code></td>
<td>
<p>Integer. Time between the two states considered to compute transition rates (one by default).</p>
</td></tr>
<tr><td><code id="seqtrate_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default value), returned transition rates ignore missing values.</p>
</td></tr>
<tr><td><code id="seqtrate_+3A_count">count</code></td>
<td>
<p>Logical. Should counts of transition be returned instead of transition probabilities. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="seqtrate_+3A_statl">statl</code></td>
<td>
<p>Deprecated. Use <code>sel.states</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transition rates are the probabilities of transition from one state to another observed in the sequence data. Substitution costs based on transition rates can be used when computing distances between sequences with the optimal matching method (see <a href="#topic+seqdist">seqdist</a>).
</p>


<h3>Value</h3>

<p>a matrix of dimension <code class="reqn">ns*ns</code>, where <code class="reqn">ns</code> is the number of states in the <a href="#topic+alphabet">alphabet</a> of the sequence object.</p>


<h3>Author(s)</h3>

<p>Matthias Studer, Alexis Gabadinho, and Gilbert Ritschard</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, N. S. Müller and M. Studer (2011). Analyzing and Visualizing State Sequences in R with TraMineR. <em>Journal of Statistical Software</em> <b>40</b>(4), 1-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdist">seqdist</a></code> <code><a href="#topic+seqsubm">seqsubm</a></code> <code><a href="#topic+alphabet">alphabet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Loading the 'actcal' example data set
  data(actcal)

  ## Defining a sequence object with data in columns 13 to 24
  ## (activity status from January to December 2000)
  actcal.seq &lt;- seqdef(actcal[,13:24])

  ## Computing transition rates
  seqtrate(actcal.seq)

  ## Computing transition rates between states "A" and "B" only
  seqtrate(actcal.seq, c("A","B"))

## ====================
## Example with weights
## ====================
data(ex1)
ex1.seq &lt;- seqdef(ex1[,1:13], weights=ex1$weights)

seqtrate(ex1.seq, weighted=FALSE)
seqtrate(ex1.seq, weighted=FALSE, count=TRUE)

## weights are accounted for by default
seqtrate(ex1.seq)
seqtrate(ex1.seq, count=TRUE)

</code></pre>

<hr>
<h2 id='seqtree'>
Tree structured analysis of a state sequence object.
</h2><span id='topic+seqtree'></span>

<h3>Description</h3>

<p>Facility for growing a regression tree for a state sequence object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqtree(formula, data = NULL, weighted = TRUE, min.size = 0.05,
  max.depth = 5, R = 1000, pval = 0.01, weight.permutation = "replicate",
  seqdist.args = list(method = "LCS", norm = "auto"), diss = NULL,
  squared = FALSE, first = NULL, minSize, maxdepth, seqdist_arg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqtree_+3A_formula">formula</code></td>
<td>
<p>a formula where the left hand side is a state sequence object (see <code><a href="#topic+seqdef">seqdef</a></code>)  and the right hand specifies the candidate variables for partitioning the set of sequences.</p>
</td></tr>
<tr><td><code id="seqtree_+3A_weighted">weighted</code></td>
<td>
<p>Logical. If <code>TRUE</code>, use the weights of the state sequence object.</p>
</td></tr>
<tr><td><code id="seqtree_+3A_data">data</code></td>
<td>
<p>a data frame where variables in the formula will be searched</p>
</td></tr>
<tr><td><code id="seqtree_+3A_min.size">min.size</code></td>
<td>
<p>minimum number of cases in a node, in percentage if less than 1.</p>
</td></tr>
<tr><td><code id="seqtree_+3A_max.depth">max.depth</code></td>
<td>
<p>maximum depth of the tree.</p>
</td></tr>
<tr><td><code id="seqtree_+3A_r">R</code></td>
<td>
<p>Number of permutations used to assess the significance of the split.</p>
</td></tr>
<tr><td><code id="seqtree_+3A_pval">pval</code></td>
<td>
<p>Maximum p-value, in percent.</p>
</td></tr>
<tr><td><code id="seqtree_+3A_weight.permutation">weight.permutation</code></td>
<td>
<p>Weights permutation method: &quot;diss&quot; (attach weights to the dissimilarity matrix), &quot;replicate&quot; (replicate case according to the <code>weights</code> arguments), &quot;rounded-replicate&quot; (replicate case according to the rounded <code>weights</code> arguments), &quot;random-sampling&quot; (random assignment of covariate profiles to the objects using distributions defined by the weights.)</p>
</td></tr>
<tr><td><code id="seqtree_+3A_seqdist.args">seqdist.args</code></td>
<td>
<p>list of arguments directly passed to <code><a href="#topic+seqdist">seqdist</a></code>, only used if <code>diss=NULL</code></p>
</td></tr>
<tr><td><code id="seqtree_+3A_diss">diss</code></td>
<td>
<p>An optional dissimilarity matrix. If not provided, a dissimilarity matrix is computed using <code><a href="#topic+seqdist">seqdist</a></code> and <code>seqdist.args</code></p>
</td></tr>
<tr><td><code id="seqtree_+3A_squared">squared</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the dissimilarity matrix is squared</p>
</td></tr>
<tr><td><code id="seqtree_+3A_first">first</code></td>
<td>
<p>Character. An optional variable name to force the first split.</p>
</td></tr>
<tr><td><code id="seqtree_+3A_minsize">minSize</code></td>
<td>
<p>Deprecated. Use <code>min.size</code> instead.</p>
</td></tr>
<tr><td><code id="seqtree_+3A_maxdepth">maxdepth</code></td>
<td>
<p>Deprecated. Use <code>max.depth</code> instead.</p>
</td></tr>
<tr><td><code id="seqtree_+3A_seqdist_arg">seqdist_arg</code></td>
<td>
<p>Deprecated. Use <code>seqdist.args</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides a simplified interface for applying <code><a href="#topic+disstree">disstree</a></code> on state sequence objects.
</p>
<p>The <code>seqtree</code> objects can be &quot;plotted&quot; with <code><a href="#topic+seqtreedisplay">seqtreedisplay</a></code>. A print method is also available which prints the medoid sequence for each terminal node.
</p>


<h3>Value</h3>

<p>A <code>seqtree</code> object with same attributes as <code><a href="#topic+disstree">disstree</a></code> objects.
</p>
<p>The leaf membership is in the first column of the fitted attribute. For example, the leaf memberships for a tree <code>dt</code>  are in <code>dt$fitted[,1]</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2011). Discrepancy analysis of state sequences, <em>Sociological Methods and Research</em>, Vol. 40(3), 471-510, <a href="https://doi.org/10.1177/0049124111415372">doi:10.1177/0049124111415372</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqtreedisplay">seqtreedisplay</a></code>, <code><a href="#topic+disstree">disstree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)

## Defining a state sequence object
mvad.seq &lt;- seqdef(mvad[, 17:86])

## Growing a seqtree from Hamming distances:
##   Warning: The R=10 used here to save computation time is
##   much too small and will generate strongly unstable results.
##   We recommend to set R at least as R=1000.
##   To comply with this small R value, we set pval = 0.1.
seqt &lt;- seqtree(mvad.seq~ male + Grammar + funemp + gcse5eq + fmpr + livboth,
    data=mvad, R=10, pval=0.1, seqdist.arg=list(method="HAM", norm="auto"))
print(seqt)

## Growing a seqtree from an existing distance matrix
mvad.dhd &lt;- seqdist(mvad.seq, method="DHD")
seqt &lt;- seqtree(mvad.seq~ male + Grammar + funemp + gcse5eq + fmpr + livboth,
    data=mvad, R=10, pval=0.1, diss=mvad.dhd)
print(seqt)


### Following commands only work if GraphViz is properly installed
## Not run: 
seqtreedisplay(seqt, type="d", border=NA)
seqtreedisplay(seqt, type="I", sortv=cmdscale(mvad.dhd, k=1))

## End(Not run)

</code></pre>

<hr>
<h2 id='seqtreedisplay'>Graphical rendering of a sequence regression tree</h2><span id='topic+seqtreedisplay'></span><span id='topic+disstreedisplay'></span>

<h3>Description</h3>

<p>Generate a graphical representation of a regression tree of state sequence data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqtreedisplay(tree, filename = NULL, seqdata = tree$info$object,
  only.leaf = FALSE, sortv = NULL, diss = NULL, cex.main = 3,
  with.legend = "auto", cex.legend = cex.main, xaxis = FALSE,
  image.format = "png", with.quality = TRUE, cex.quality = cex.main,
  legend.text = NULL, show.tree = TRUE, show.depth = FALSE,
  imgLeafOnly, dist.matrix, title.cex, withlegend, legend.fontsize,
  imageformat, withquality, quality.fontsize, legendtext, showtree,
  showdepth, axes, ...)

disstreedisplay(tree, filename = NULL, image.data= NULL, image.fun = plot,
  only.leaf = FALSE, cex.main = 3, image.format = "png",
  with.quality = TRUE, cex.quality = cex.main,
  legend.text = NULL, show.tree = TRUE, show.depth = FALSE,
  imagedata, imagefunc, imgLeafOnly, title.cex, imageformat,
  withquality, quality.fontsize, legendtext, showtree, showdepth, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqtreedisplay_+3A_tree">tree</code></td>
<td>
<p>A <code>seqtree</code> object (as produced by <code><a href="#topic+seqtree">seqtree</a></code>) for <code>seqtreedisplay</code>. A <code>disstree</code> object (as produced by <code><a href="#topic+disstree">disstree</a></code>) for <code>disstreedisplay</code>.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_filename">filename</code></td>
<td>
<p>The name of a file where to save the plot (overwritting existing file). If <code>NULL</code>, a temporary file is created.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_seqdata">seqdata</code></td>
<td>
<p>The sequence object containing the state sequences plotted in the nodes.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_only.leaf">only.leaf</code></td>
<td>
<p>Logical. If <code>TRUE</code> sequences are plotted only in terminal nodes.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_sortv">sortv</code></td>
<td>
<p>Argument passed to <code><a href="#topic+seqplot">seqplot</a></code></p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_diss">diss</code></td>
<td>
<p>Argument passed to <code><a href="#topic+seqplot">seqplot</a></code></p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_cex.main">cex.main</code></td>
<td>
<p>Node title magnification. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_with.legend">with.legend</code></td>
<td>
<p>Logical. Should the color legend be displayed on the plot?</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_cex.legend">cex.legend</code></td>
<td>

<p>Legend magnification. See <code><a href="graphics.html#topic+par">par</a></code>. If not specified, use the
value of <code>cex.main</code>.
</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_xaxis">xaxis</code></td>
<td>
<p>Logical. Should the x-axis be displayed on the plots? (argument passed to <code><a href="#topic+seqplot">seqplot</a></code>)</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_image.format">image.format</code></td>
<td>
<p>Image format of the output file (<code>filename</code>)</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_with.quality">with.quality</code></td>
<td>
<p>If <code>TRUE</code>, a node displaying fitting measures of the tree is added to the plot.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_cex.quality">cex.quality</code></td>
<td>

<p>Fitting measure text magnification. See <code><a href="graphics.html#topic+par">par</a></code>. If not specified,
use the value of <code>cex.main</code>.
</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_legend.text">legend.text</code></td>
<td>
<p>Character. Optional text information that should be added.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_show.tree">show.tree</code></td>
<td>
<p>Logical. Should the tree be shown on the screen?</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_show.depth">show.depth</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the splits are ordered according to their global pseudo-R2.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_image.fun">image.fun</code></td>
<td>
<p>A function to plot the individuals in a node, see details.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_image.data">image.data</code></td>
<td>
<p>a <code>data.frame</code> that will be passed to <code>image.fun</code>.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_imgleafonly">imgLeafOnly</code></td>
<td>
<p>Deprecated. Use <code>only.leaf</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_dist.matrix">dist.matrix</code></td>
<td>
<p>Deprecated. Use <code>diss</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_title.cex">title.cex</code></td>
<td>
<p>Deprecated. Use <code>cex.main</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_withlegend">withlegend</code></td>
<td>
<p>Deprecated. Use <code>with.legend</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_legend.fontsize">legend.fontsize</code></td>
<td>
<p>Deprecated. Use <code>cex.legend</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_imageformat">imageformat</code></td>
<td>
<p>Deprecated. Use <code>image.format</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_withquality">withquality</code></td>
<td>
<p>Deprecated. Use <code>with.quality</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_quality.fontsize">quality.fontsize</code></td>
<td>
<p>Deprecated. Use <code>cex.quality</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_legendtext">legendtext</code></td>
<td>
<p>Deprecated. Use <code>legend.text</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_showtree">showtree</code></td>
<td>
<p>Deprecated. Use <code>show.tree</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_showdepth">showdepth</code></td>
<td>
<p>Deprecated. Use <code>show.depth</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_imagedata">imagedata</code></td>
<td>
<p>Deprecated. Use <code>image.data</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_imagefunc">imagefunc</code></td>
<td>
<p>Deprecated. Use <code>image.fun</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_axes">axes</code></td>
<td>
<p>Deprecated. Use <code>xaxis</code> instead.</p>
</td></tr>
<tr><td><code id="seqtreedisplay_+3A_...">...</code></td>
<td>
<p>additional arguments passed to seqplot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a tree image. For each node, it invokes <code><a href="#topic+seqplot">seqplot</a></code> for the selected lines of <code>seqdata</code> as argument.
You should at least specify the <code>type</code> of the plot to use (<code>type="d"</code> for instance, see <code><a href="#topic+seqplot">seqplot</a></code> for more details).
</p>
<p>The plot is actually not generated as an R plot, but with GraphViz (www.graphviz.org). Hence, <code>seqtreedisplay</code> only works when GraphViz is correctly installed. If the path to GraphViz is not found, pass the path as a <code>gvpath</code> argument among the ... list.
</p>
<p>Conversion to image formats other than &quot;jpeg&quot; or &quot;png&quot; is done using ImageMagick (www.imagemagick.org). To use this feature,  ImageMagick (www.imagemagick.org) should hence also be installed.
</p>


<h3>Value</h3>

<p>None</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+seqtree">seqtree</a></code> and <code><a href="#topic+disstree">disstree</a></code> for examples, and <code><a href="#topic+disstree2dot">disstree2dot</a></code> for generating &quot;dot&quot; files.
</p>

<hr>
<h2 id='stlab'>Get or set the state labels of a sequence object</h2><span id='topic+stlab'></span><span id='topic+stlab+3C-'></span>

<h3>Description</h3>

<p>This function gets or sets the state labels of a sequence object, that is, the long labels used when displaying the state legend in plotting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stlab(seqdata)
stlab(seqdata) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stlab_+3A_seqdata">seqdata</code></td>
<td>
<p>a state sequence object as defined by the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="stlab_+3A_value">value</code></td>
<td>
<p>a vector of character strings containing the labels, of length equal to the number of states in the alphabet. Each string is attributed to the corresponding state in the alphabet, the order being the one returned by the <code><a href="#topic+alphabet">alphabet</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state legend is plotted either automatically by the plot functions provided for visualizing sequence objects or with the <code><a href="#topic+seqlegend">seqlegend</a></code> function. A long label is associated to each state of the alphabet and displayed in the legend. The state labels are defined when creating the sequence object, either automatically using the values found in the data or by specifying a user defined vector of labels. The <code>stlab</code> function can be used to get or set the state labels of a previously defined sequence object.</p>


<h3>Value</h3>

<p>For 'stlab' a vector containing the labels.
</p>
<p>For 'stlab&lt;-' the updated sequence object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdef">seqdef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a sequence object with the columns 13 to 24
## in the 'actcal' example data set
## The color palette is automatically set
data(actcal)
actcal.seq &lt;- seqdef(actcal,13:24)

## Retrieving the color palette
stlab(actcal.seq)
seqiplot(actcal.seq)

## Changing the state labels
stlab(actcal.seq) &lt;- c("Full time","Part time (19-36 hours)",
    "Part time (1-18 hours)", "No work")
seqiplot(actcal.seq)
</code></pre>

<hr>
<h2 id='str.eseq'>String representation of an event sequence object</h2><span id='topic+str.eseq'></span><span id='topic+str.seqelist'></span><span id='topic+as.character.eseq'></span><span id='topic+as.character.seqelist'></span>

<h3>Description</h3>

<p>Methods to get a string representation of an event sequence or event subsequence object.
These are the generic <code>str</code> and <code>as.character</code> methods for objects of class <code>eseq</code> (single event sequence) and <code>seqelist</code> (list of event sequences).
</p>


<h3>Details</h3>

<p>String representations have the following form:
<code>time-(e1,e2,...)-elapsedtime-(e3,...)...</code>
where <code>time</code> is the time elapsed from start to the first set of simultaneous events <code>(e1,e2,...)</code> and <code>elapsedtime</code> the time between two consecutive sets of simultaneous events. Time is only displayed when events are time stamped.
Use <code>str</code> (<code>str.seqelist</code>) to get a single string for a whole list, and <code>as.charcater</code> (<code>as.character.seqelist</code>) to get a vector of strings.
<code>str.eseq</code> and <code>as.character.eseq</code> have mainly an internal purpose (invoked by print methods for example).
</p>


<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqecreate">seqecreate</a></code> for a full example </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(actcal.tse)
actcal.eseq &lt;- seqecreate(actcal.tse)
head(as.character(actcal.eseq))
</code></pre>

<hr>
<h2 id='TraMineR.check.depr.args'>
Checking and managing deprecated arguments
</h2><span id='topic+TraMineR.check.depr.args'></span>

<h3>Description</h3>

<p>Checks the presence of deprecated arguments, assigns value of a deprecated argument to the corresponding new argument name, and issues warning messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TraMineR.check.depr.args(arg.pairs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TraMineR.check.depr.args_+3A_arg.pairs">arg.pairs</code></td>
<td>
<p>List of pairs of old and new argument names
<br />(e.g. <code>alist(newname1 = oldname1, newname2 = oldname2)</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To be used inside functions. For developers only.
</p>
<p>For each specified pair of new and old argument names, the function checks if the old
argument name is specified. If so and the new one is not, a warning message is raised
and the argument value is assigned to the new argument name. If one of the names declared in check.depr.args() arguments si not an argument of the parent function
or if both the new and old argument names are specified an error is raised.
</p>
<p>The function does not detect when the new and the old argument names are specified
together and the new argument value is its default value. In this case,
the value associated with the old argument name is assigned to the new name and a warning
message is raised.
</p>
<p>The function works whether the argument names are explicitly declared or not in the call to the checked function.
</p>
<p>The only requirement for the function to work is that the deprecated arguments should be listed WITHOUT default values in the definition of the checked function.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Fonta, Gilbert Ritschard</p>

<hr>
<h2 id='TraMineRInternal'>Access to TraMineR internal functions</h2><span id='topic+TraMineRInternalLayout'></span><span id='topic+TraMineRInternalLegend'></span><span id='topic+TraMineRInternalNodeInit'></span><span id='topic+TraMineRInternalSeqeage'></span><span id='topic+TraMineRInternalSeqgbar'></span><span id='topic+TraMineRInternalSplitInit'></span><span id='topic+TraMineRInternalWeightedInertiaDist'></span>

<h3>Description</h3>

<p>Functions allowing other packages to access some TraMineR internal functions.
Corresponding functions are respectively <code>TraMineR.setlayout</code>,
<code>TraMineR.Legend</code>, <code>DTNInit</code>, <code>seqeage</code>, <code>seqgbar</code>,
<code>DTNsplit</code>, and <code>tmrWeightedInertiaDist</code>. For experts only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TraMineRInternalLayout(...)
TraMineRInternalLegend(...)
TraMineRInternalNodeInit(...)
TraMineRInternalSeqeage(...)
TraMineRInternalSeqgbar(...)
TraMineRInternalSplitInit(...)
TraMineRInternalWeightedInertiaDist(diss, diss.size, is.dist, individuals, sweights, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TraMineRInternal_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="TraMineRInternal_+3A_diss">diss</code></td>
<td>
<p>See tmrWeightedInertiaDist().</p>
</td></tr>
<tr><td><code id="TraMineRInternal_+3A_diss.size">diss.size</code></td>
<td>
<p>See tmrWeightedInertiaDist().</p>
</td></tr>
<tr><td><code id="TraMineRInternal_+3A_is.dist">is.dist</code></td>
<td>
<p>See tmrWeightedInertiaDist().</p>
</td></tr>
<tr><td><code id="TraMineRInternal_+3A_individuals">individuals</code></td>
<td>
<p>See tmrWeightedInertiaDist().</p>
</td></tr>
<tr><td><code id="TraMineRInternal_+3A_sweights">sweights</code></td>
<td>
<p>See tmrWeightedInertiaDist().</p>
</td></tr>
<tr><td><code id="TraMineRInternal_+3A_var">var</code></td>
<td>
<p>See tmrWeightedInertiaDist().</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
