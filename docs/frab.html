<!DOCTYPE html><html><head><title>Help for package frab</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {frab}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#frab-package'><p>How to Add Two R Tables</p></a></li>
<li><a href='#Arith'><p>Arithmetic methods for class <code>"frab"</code></p></a></li>
<li><a href='#Compare-methods'><p>Comparison methods</p></a></li>
<li><a href='#dataframe'><p>Coerce a data frame to a frab</p></a></li>
<li><a href='#Extract'><p>Extraction and replacement methods for class <code>"frab"</code></p></a></li>
<li><a href='#frab'><p>Creating <code>frab</code> objects</p></a></li>
<li><a href='#frab-class'><p>Class &ldquo;frab&rdquo;</p></a></li>
<li><a href='#misc'><p>Miscellaneous functions</p></a></li>
<li><a href='#namedvector'><p>Named vectors and the frab package</p></a></li>
<li><a href='#pmax'><p>Parallel maxima and minima for frabs</p></a></li>
<li><a href='#print'><p>Methods for printing frabs</p></a></li>
<li><a href='#rfrab'><p>Random frabs</p></a></li>
<li><a href='#sparsetable'><p>Generalized sparse tables: <code>sparsetable</code> objects</p></a></li>
<li><a href='#Summary-methods'><p>Methods for Function <code>Summary</code></p></a></li>
<li><a href='#table'><p>Tables and frab objects</p></a></li>
<li><a href='#zero'><p>The zero frab object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>How to Add Two R Tables</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0-5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to "add" two R tables; also an alternative
     interpretation of named vectors as generalized R tables, so that
     c(a=1,b=2,c=3) + c(b=3,a=-1) will return c(b=5,c=3).  Uses
     'disordR' discipline (Hankin, 2022,
     &lt;<a href="https://doi.org/10.48550%2FarXiv.2210.03856">doi:10.48550/arXiv.2210.03856</a>&gt;).  Extraction and replacement
     methods are provided.  The underlying mathematical structure is
     the Free Abelian group, hence the name.  To cite in publications
     please use Hankin (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2307.13184">doi:10.48550/arXiv.2307.13184</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown, testthat, mvtnorm, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0-7), mathjaxr, disordR (&ge; 0.9-8-2), methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/frab">https://github.com/RobinHankin/frab</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/frab">https://github.com/RobinHankin/frab</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-21 07:05:24 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-21 08:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='frab-package'>How to Add Two R Tables</h2><span id='topic+frab-package'></span>

<h3>Description</h3>

<p>Methods to &quot;add&quot; two R tables; also an alternative
     interpretation of named vectors as generalized R tables, so that
     c(a=1,b=2,c=3) + c(b=3,a=-1) will return c(b=5,c=3).  Uses
     'disordR' discipline (Hankin, 2022,
     &lt;doi:10.48550/arXiv.2210.03856&gt;).  Extraction and replacement
     methods are provided.  The underlying mathematical structure is
     the Free Abelian group, hence the name.  To cite in publications
     please use Hankin (2023) &lt;doi:10.48550/arXiv.2307.13184&gt;.</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> frab</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> How to Add Two R Tables</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.0-5</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Methods to "add" two R tables; also an alternative
     interpretation of named vectors as generalized R tables, so that
     c(a=1,b=2,c=3) + c(b=3,a=-1) will return c(b=5,c=3).  Uses
     'disordR' discipline (Hankin, 2022,
     &lt;doi:10.48550/arXiv.2210.03856&gt;).  Extraction and replacement
     methods are provided.  The underlying mathematical structure is
     the Free Abelian group, hence the name.  To cite in publications
     please use Hankin (2023) &lt;doi:10.48550/arXiv.2307.13184&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, markdown, rmarkdown, testthat, mvtnorm, covr</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 1.0-7), mathjaxr, disordR (&gt;= 0.9-8-2), methods</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/frab</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/frab</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Compare-methods         Comparison methods
Summary-methods         Methods for Function 'Summary'
arith                   Arithmetic methods for class '"frab"'
dataframe               Coerce a data frame to a frab
extract                 Extraction and replacement methods for class
                        '"frab"'
frab                    Creating 'frab' objects
frab-class              Class "frab"
frab-package            How to Add Two R Tables
is.namedvector          Named vectors and the frab package
misc                    Miscellaneous functions
pmax                    Parallel maxima and minima for frabs
print                   Methods for printing frabs
rfrab                   Random frabs
sparsetable             Generalized sparse tables: 'sparsetable'
                        objects
table                   Tables and frab objects
zero                    The zero frab object
</pre>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- frab(c(a=1, b=2, c=5))
y &lt;- frab(c(b=-2, c=1, d=8))

x+y

</code></pre>

<hr>
<h2 id='Arith'>Arithmetic methods for class <code>"frab"</code></h2><span id='topic+arith'></span><span id='topic+Arith+2Cfrab+2Cmissing-method'></span><span id='topic+Arith+2Cfrab+2Cfrab-method'></span><span id='topic+Arith+2Cfrab+2Cfrab-method'></span><span id='topic+Arith+2Cfrab+2Cnumeric-method'></span><span id='topic+Arith+2CANY+2Cfrab-method'></span><span id='topic+Arith+2Cfrab+2CANY-method'></span><span id='topic+frab_multiply_numeric'></span><span id='topic+frab_power_numeric'></span><span id='topic+numeric_multiply_frab'></span><span id='topic+numeric_power_frab'></span><span id='topic+frab_negative'></span><span id='topic+frab_reciprocal'></span><span id='topic+frab_plus_frab'></span><span id='topic+frab_plus_numeric'></span><span id='topic+frab_multiply_frab'></span><span id='topic+frab_unary'></span><span id='topic+frab_arith_frab'></span><span id='topic+frab_arith_numeric'></span><span id='topic+numeric_arith_frab'></span><span id='topic+c_frab_add'></span><span id='topic+c_frab_multiply'></span><span id='topic+c_frab_pmax'></span><span id='topic+c_frab_identity'></span>

<h3>Description</h3>

<p>The <code>frab</code> class provides basic arithmetic methods for frab
objects.  Arithmetic operations are generally dispatched to one of
self-describing functions in the following list:
</p>

<ul>
<li><p><code>frab_negative()</code>
</p>
</li>
<li><p><code>frab_reciprocal()</code>
</p>
</li>
<li><p><code>frab_plus_frab()</code>
</p>
</li>
<li><p><code>frab_multiply_frab()</code>
</p>
</li>
<li><p><code>frab_plus_numeric()</code>
</p>
</li>
<li><p><code>frab_multiply_numeric()</code>
</p>
</li>
<li><p><code>frab_power_numeric()</code>
</p>
</li>
<li><p><code>numeric_power_frab()</code>
</p>
</li></ul>

<p>The most important one is, of course, <code>frab_plus_frab()</code> which is
the <em>sine qua non</em> for the whole package.  But these functions
are not intended for user and are somewhat unfriendly.  Use the
arithmetic operators, as in &ldquo;<code>a + 2*b</code>&rdquo; instead.
</p>
<p>Low-level helper functions <code>c_frab_add()</code> and
<code>c_frab_multiply()</code> etc. are generated by
<code>compileAttributes()</code>.  They call the C routines in
the <code>src</code> directory.  Low-level helper function
<code>c_frab_pmax()</code> is documented here for consistency; but
technically <code>c_frab_pmax()</code> is an &ldquo;Extremes&rdquo; function.
They are documented at <a href="#topic+Compare">Compare</a> and <a href="#topic+pmax">pmax</a> respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frab_negative(x)
frab_reciprocal(x)
frab_plus_frab(F1,F2)
frab_multiply_numeric(e1,e2)
frab_power_numeric(e1,e2)
numeric_power_frab(e1,e2)
frab_unary(e1,e2)
frab_arith_frab(e1,e2)
frab_plus_numeric(e1,e2)
frab_arith_numeric(e1,e2)
numeric_arith_frab(e1,e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arith_+3A_e1">e1</code>, <code id="Arith_+3A_e2">e2</code>, <code id="Arith_+3A_x">x</code>, <code id="Arith_+3A_f1">F1</code>, <code id="Arith_+3A_f2">F2</code></td>
<td>
<p>Objects of class <code>frab</code>, coerced if needed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return <code>frab</code> objects</p>


<h3>Methods</h3>


<dl>
<dt>Arith</dt><dd><p><code>signature(e1="frab"   , e2="missing")</code>: blah blah
blah</p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1="frab"   , e2="frab"   )</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1="frab"   , e2="numeric")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1="numeric", e2="frab"   )</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1="ANY"    , e2="frab"   )</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1="frab"   , e2="ANY"    )</code>: ... </p>
</dd>
</dl>



<h3>Note</h3>

<p>There are a few peculiarities in the methods.  Function
<code>frab_plus_numeric(e1,e2)</code> assumes <code>e1</code> is a <code>frab</code> and
<code>e2</code> is numeric.  But if <code>e2</code> is a named vector, it is
coerced to a frab; if not, a [simulated] <a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> violation
is raised.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+Compare">Compare</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- frab(c(a=1,b=2,c=3)))
(y &lt;- frab(c(b=-2,d=8,x=1,y=7)))
(z &lt;- frab(c(c=2,x=5,b=1,a=6)))


x+y
x+y+z

x*y


</code></pre>

<hr>
<h2 id='Compare-methods'>Comparison methods</h2><span id='topic+Compare-methods'></span><span id='topic+Compare+2Cfrab+2Cfrab-method'></span><span id='topic+Compare+2Cfrab+2Cnumeric-method'></span><span id='topic+Compare+2Cnumeric+2Cfrab-method'></span><span id='topic+frab_eq'></span><span id='topic+frab_eq_num'></span><span id='topic+frab_ne_num'></span><span id='topic+frab_gt_num'></span><span id='topic+frab_ge_num'></span><span id='topic+frab_lt_num'></span><span id='topic+frab_le_num'></span><span id='topic+num_eq_frab'></span><span id='topic+num_ne_frab'></span><span id='topic+num_gt_frab'></span><span id='topic+num_ge_frab'></span><span id='topic+num_lt_frab'></span><span id='topic+num_le_frab'></span><span id='topic+numeric_compare_frab'></span><span id='topic+frab_compare_frab'></span><span id='topic+frab_compare_numeric'></span><span id='topic+c_frab_eq'></span><span id='topic+Compare'></span>

<h3>Description</h3>

<p>Methods for comparison (greater than, etc) in the <span class="pkg">frab</span> package.
</p>
<p>Frabs and sparsetables may be compared with length-one numeric
vectors.  Functions <code>frab_gt_num()</code> etc follow a consistent
naming convention; the mnemonic is the old Fortran <code>.GT.</code> scheme
[for &ldquo;greater than&rdquo;].  This allows one to use idiom such as
<code>f &gt;= 3</code>.  For sparsetables, comparison with scalars is possible:
but the result is flattened to a <code>disord</code> object (this can be
confusing for two dimensional tables when the default matrix-like
print method is used, because zero entries are not &ldquo;real&rdquo;.  For
example, if <code>s</code> is a sparsetable, then <code>s==0</code> will return
all <code>FALSE</code>).
</p>
<p>Comparing a <code>frab</code> with another <code>frab</code> is generally
meaningless.  Idiom like &ldquo;<code>e1 &gt;= e2</code>&rdquo;, for example,
returns an error.  The only comparison that makes any sense is whether
two frabs are identical: this is detected by &ldquo;<code>e1 == e2</code>&rdquo;
and its negation &ldquo;<code>e1 != e2</code>&rdquo;.  Internally, equality is
tested in C using a routine written for speed
(specifically, returning <code>FALSE</code> as soon as it spots a difference
between its two arguments); this is modelled on its equivalent in the
<a href="https://CRAN.R-project.org/package=spray"><span class="pkg">spray</span></a> package.  If any value is <code>NA</code>, equality checks
will return <code>FALSE</code>.  Functions <code>frab_eq()</code> and
<code>c_frab_eq()</code> are just R wrappers for the C
routine <code>equal()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frab_eq(e1,e2)
frab_eq_num(e1,e2)
frab_ne_num(e1,e2)
frab_gt_num(e1,e2)
frab_ge_num(e1,e2)
frab_lt_num(e1,e2)
frab_le_num(e1,e2)
num_eq_frab(e1,e2)
num_ne_frab(e1,e2)
num_gt_frab(e1,e2)
num_ge_frab(e1,e2)
num_lt_frab(e1,e2)
num_le_frab(e1,e2)
numeric_compare_frab(e1,e2)
frab_compare_frab(e1,e2)
frab_compare_numeric(e1,e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Compare-methods_+3A_e1">e1</code>, <code id="Compare-methods_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>frab</code></p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Generally, return a <code>frab</code> or a logical</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+Arith">Arith</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rfrab()
a &lt;- rfrab(26,sym=letters)
a[a&lt;4] &lt;- 100
</code></pre>

<hr>
<h2 id='dataframe'>Coerce a data frame to a frab</h2><span id='topic+dataframe'></span><span id='topic+data.frame'></span><span id='topic+df_to_frab'></span><span id='topic+as.data.frame'></span><span id='topic+as.data.frame+2Cfrab-method'></span><span id='topic+as.frab+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Coerce a data frame to a frab</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_to_frab(from)
## S4 method for signature 'data.frame'
as.frab(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataframe_+3A_x">x</code>, <code id="dataframe_+3A_from">from</code></td>
<td>
<p>Frab objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces a data frame, with columns <code>key</code> and <code>value</code>, to the
appropriate frab object.  Repeated <code>key</code>s are summed.
</p>


<h3>Value</h3>

<p>Returns a frab object or a dataframe.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.frab(data.frame(key=letters[1:5],value=1:5))

</code></pre>

<hr>
<h2 id='Extract'>Extraction and replacement methods for class <code>"frab"</code></h2><span id='topic+extract'></span><span id='topic+values+2Cfrab-method'></span><span id='topic+values'></span><span id='topic+values+3C-'></span><span id='topic+values+3C-+2Cfrab+2Cnumeric-method'></span><span id='topic+values+3C-+2Cfrab+2Cdisord-method'></span><span id='topic+names'></span><span id='topic+names+2Cfrab-method'></span><span id='topic+names+3C-+2Cfrab+2Cdisord-method'></span><span id='topic+names+3C-+2Cfrab+2Ccharacter-method'></span><span id='topic++5B'></span><span id='topic++5B.frab'></span><span id='topic++5B+2Cfrab-method'></span><span id='topic++5B+2CANY+2Cfrab+2CANY-method'></span><span id='topic++5B+2Cfrab+2CANY+2CANY-method'></span><span id='topic++5B+2Cfrab+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cfrab+2Ccharacter+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cfrab+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+2Cfrab+2Cdisindex+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cfrab+2Cdisord+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cfrab+2Cdisord+2Cmissing-method'></span><span id='topic++5B+2Cfrab+2Cfrab+2Cmissing-method'></span><span id='topic++5B+2Cfrab+2Cfrab+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cfrab+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cfrab+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cfrab+2Cmissing+2Cindex-method'></span><span id='topic++5B+3C-'></span><span id='topic++5B+3C-+2Cfrab+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cfrab+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+3C-+2Cfrab+2Ccharacter+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cfrab+2Ccharacter+2Cmissing+2Clogical-method'></span><span id='topic++5B+3C-+2Cfrab+2Cdisord+2Cmissing-method'></span><span id='topic++5B+3C-+2Cfrab+2Cdisord+2Cmissing+2Cfrab-method'></span><span id='topic++5B+3C-+2Cfrab+2Cdisord+2Cmissing+2Clogical-method'></span><span id='topic++5B+3C-+2Cfrab+2Cdisord+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cfrab+2Cdisindex+2Cmissing+2Cnumeric+2CANY-method'></span><span id='topic++5B+3C-+2Cfrab+2Cdisindex+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cfrab+2Cmissing+2Cmissing+2Cfrab-method'></span><span id='topic++5B+3C-+2Cfrab+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cfrab+2Cmissing+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>The <code>frab</code> class provides basic arithmetic and extract/replace
methods for frab objects.
</p>
<p>Class <dfn>index</dfn> is taken from the excellent <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a> package
and is a <code>setClassUnion()</code> of classes <code>numeric</code>,
<code>logical</code>, and <code>character</code>.
</p>


<h3>Value</h3>

<p>Generally, return a <code>frab</code> object.</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "frab", i = "character", j =
	"missing")</code>: <code>x["a"] &lt;- 33</code></p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "frab", i = "disord", j = "missing")</code>: <code>x[x&gt;3]</code></p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "frab", i = "missing", j = "missing")</code>: <code>x[]</code></p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "frab", i = "character",j =
	"missing", value = "ANY")</code>: <code>x["a"] &lt;- 3</code></p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "frab", i = "disord", j = "missing",
	value="frab")</code>: <code>x[x&lt;0] &lt;- -x[x&lt;0]</code>; not implemented</p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "frab", i = "disord", j = "missing",
	value="logical")</code>: <code>x[x&lt;0] &lt;- NA</code></p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "frab", i = "ANY",j = "ANY", value =
	"ANY")</code>: not implemented</p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "frab", i = "disindex",j = "missing",
	value = "numeric")</code>: <code>x[x&gt;0] &lt;- 3</code></p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "frab", i = "character", j =
	"missing", value = "logical")</code>: <code>x["c"] &lt;- NA</code></p>
</dd>
</dl>

<p>Double square extraction, as in <code>x[[i]]</code> and <code>x[[i]] &lt;-
 value</code>, is not currently defined.  In replacement methods, if
<code>value</code> is logical it is coerced to numeric (this includes
<code>NA</code>).
</p>
<p>Special dispensation is given for extraction of a <code>frab</code> with a
length zero index, as in <code>x[NULL]</code>, which returns the empty
<code>frab</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
frab(setNames(seq_len(0),letters[seq_len(0)]))

a &lt;- rfrab(26,sym=letters)
a&lt;4
a[a&lt;4]
a[a&lt;4] &lt;- 100
a

x &lt;- rfrab()
values(x) &lt;- values(x) + 66

x &lt;- rfrabb()
v &lt;-  values(x)
v[v&lt;0] &lt;- abs(v[v&lt;0]) + 50
values(x) &lt;- v

names(x) &lt;- toupper(names(x))
x

</code></pre>

<hr>
<h2 id='frab'>Creating <code>frab</code> objects</h2><span id='topic+frab'></span><span id='topic+as.frab'></span><span id='topic+is.frab'></span><span id='topic+list_to_frab'></span>

<h3>Description</h3>

<p>Package idiom for creating <code>frab</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>frab(x)
as.frab(x)
is.frab(x)
list_to_frab(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frab_+3A_x">x</code></td>
<td>
<p>object coerced to, or tested for, <code>frab</code></p>
</td></tr>
<tr><td><code id="frab_+3A_l">L</code></td>
<td>
<p>List of two elements, a numeric vector named <code>values</code> and
a character vector named <code>names</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>frab()</code> is the creation method, taking a named numeric
vector as its argument; it is the only function in the package that
actually calls <code>new("frab", ...)</code>.
</p>
<p>Function <code>as.frab()</code> tries a bit harder to be useful and can coerce
different types of object to a <code>frab</code>.  If given a list it
dispatches to <code>list_to_frab()</code>.  If given a table it dispatches to
<code>table_to_frab()</code>, documented at <code>table.Rd</code>; and if given a
data frame it dispatches to <code>df_to_frab()</code>, documented at
<code>dataframe.Rd</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>frab</code>, or a boolean</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+frab-class">frab-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
frab(c(x=6,y=6,z=-4,u=0,x=3))

as.frab(c(a=2,b=1,c=77))

as.frab(list(names=letters[5:2],values=1:4))

x &lt;- rfrab()
y &lt;- rfrab()
x+y

</code></pre>

<hr>
<h2 id='frab-class'>Class &ldquo;frab&rdquo;</h2><span id='topic+frab-class'></span><span id='topic+namedvector'></span><span id='topic+namedvector+2Cfrab-method'></span>

<h3>Description</h3>

<p>The formal S4 class for frab objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'frab'
namedvector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frab-class_+3A_x">x</code></td>
<td>
<p>Object of class <code>frab</code></p>
</td></tr></table>


<h3>Objects from the Class</h3>

<p>Formal class <dfn>frab</dfn> has a single slot <code>x</code> which is a named
numeric vector.
</p>
<p>The class has three accessor methods: <code>names()</code>, <code>values()</code>,
and <code>namedvector()</code>. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
new("frab",x=c(a=6,b=4,c=1))   # formal creation method (discouraged)


frab(c(a=4,b=1,c=5))   # use frab() in day-to-day work

frab(c(a=4,b=0,c=5))   # zero entries are discarded

frab(c(a=4,b=3,b=5))   # repeted entries are summed

frab(c(apple=4,orange=3,cherry=5))   # any names are OK

x &lt;- frab(c(d=1,y=3,a=2,b=5,rug=7,c=2))
(y &lt;- rfrab())

x+y          # addition works as expected
x + 2*y      # arithmetic
x&gt;2          # extraction
x[x&gt;3] &lt;- 99 # replacement


# sum(x)       # some summary methods implemented
# max(x) 

</code></pre>

<hr>
<h2 id='misc'>Miscellaneous functions</h2><span id='topic+misc'></span><span id='topic+length'></span><span id='topic+length.frab'></span><span id='topic+length+2Cfrab-method'></span><span id='topic+lapply'></span><span id='topic+lapply+2Cdisord-method'></span><span id='topic+lapply.disord'></span><span id='topic+is.na'></span><span id='topic+is.na.frab'></span><span id='topic+is.na+2Cfrab-method'></span><span id='topic+is.notna'></span><span id='topic+is.notna.frab'></span><span id='topic+is.notna+2Cfrab-method'></span><span id='topic+is.na+3C-'></span><span id='topic+is.na+3C-.frab'></span><span id='topic+is.na+3C-.frab'></span><span id='topic+is.na+3C-.frab'></span><span id='topic+is.na+3C-+2Cfrab+2Cdisord-method'></span><span id='topic++21+2Cfrab-method'></span><span id='topic+which+2Cfrab-method'></span><span id='topic+which+2Cdisindex-method'></span>

<h3>Description</h3>

<p>This page documents various functions that work for frabs, and I will
add to these from time to time as I add new functions that make sense
for frab objects.  To use functions like <code>sin()</code> and <code>abs()</code>
on <code>frab</code> object <code>x</code>, work with <code>values(x)</code> (which is a
<code>disord</code> object).  However, there are a few functions that are a
little more involved:
</p>

<ul>
<li><p><code>length()</code> returns the length of the data component of the
object.
</p>
</li>
<li><p><code>which()</code> returns an error when called with a <code>frab</code>
object, but is useful here because it returns a <code>disind</code> when
given a Boolean <code>disord</code> object.  This is useful for idiom such
as <code>x[x&gt;0]</code>
</p>
</li>
<li><p> Functions <code>is.na()</code> and <code>is.notna()</code> return a
<code>disind</code> object</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'frab'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="misc_+3A_x">x</code></td>
<td>
<p>Object of class <code>frab</code></p>
</td></tr></table>


<h3>Value</h3>

<p>Generally return frabs</p>


<h3>Note</h3>

<p>Constructions such as <code>!is.na(x)</code> do not work if <code>x</code> is a
<code>frab</code> object: this is because <code>is.na()</code> returns a
<code>disind</code> object, not a logical.  Use <code>is.notna()</code> to
identify elements that are not <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract">extract</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

(a &lt;- frab(c(a=1,b=NA,c=44,x=NA,h=4)))
is.na(a)

(x &lt;- frab(c(x=5,y=2,z=3,a=7,b=6)))
which(x&gt;3)
x[which(x&gt;3)]
x[which(x&gt;3)] &lt;- 4
x

is.na(x) &lt;- x&lt;3
x
x[is.na(x)] &lt;- 100
x

y &lt;- frab(c(a=5,b=NA,c=3,d=NA))
y[is.notna(y)] &lt;- 199
y
</code></pre>

<hr>
<h2 id='namedvector'>Named vectors and the frab package</h2><span id='topic+is.namedvector'></span><span id='topic+as.namedvector'></span><span id='topic+is.namedlogical'></span><span id='topic+is.unnamedlogical'></span><span id='topic+is.unnamedvector'></span>

<h3>Description</h3>

<p>Named vectors are closely related to <code>frab</code> objects, but are not
the same.  However, there is a natural coercion from one to the other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.namedvector(v)
is.namedvector(v)
is.namedlogical(v)
is.unnamedlogical(v)
is.unnamedvector(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="namedvector_+3A_v">v</code></td>
<td>
<p>Argument to be tested or coerced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coercion and testing for named vectors.
Function <code>nv_to_frab()</code>, documented at <code>frab.Rd</code>, coerces a
named vector to a <code>frab</code>.
</p>


<h3>Value</h3>

<p>Function <code>is.namedvector()</code> returns a boolean, function
<code>as.namedvector()</code> returns a named vector.
</p>


<h3>Note</h3>

<p>The issue of named logical vectors in the 'frab' package is discussed
briefly at 'inst/wittgenstein.Rmd'.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(a=5, b=3, c=-2,b=-3, x=33)
is.namedvector(x)
as.namedvector(frab(x))

x &lt;- c(a=5, b=3, c=-2)
y &lt;- c(p=1, c=2, d= 6)

x
y
x+y

frab(x) + frab(y)

</code></pre>

<hr>
<h2 id='pmax'>Parallel maxima and minima for frabs</h2><span id='topic+pmax'></span><span id='topic+pmin'></span><span id='topic+pmax.frab'></span><span id='topic+pmin.frab'></span><span id='topic+pmax+2Cfrab-method'></span><span id='topic+pmin+2Cfrab-method'></span><span id='topic+pmax+2CANY-method'></span><span id='topic+pmin+2CANY-method'></span><span id='topic+pmax_pair'></span><span id='topic+pmin_pair'></span><span id='topic+pmax_dots'></span><span id='topic+pmin_dots'></span>

<h3>Description</h3>

<p>Parallel (pairwise) maxima and minima for frabs. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmax_pair(F1,F2)
pmin_pair(F1,F2)
pmax_dots(x, ...)
pmin_dots(x, ...)
## S4 method for signature 'frab'
pmax(...)
## S4 method for signature 'frab'
pmin(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmax_+3A_f1">F1</code>, <code id="pmax_+3A_f2">F2</code>, <code id="pmax_+3A_x">x</code>, <code id="pmax_+3A_...">...</code></td>
<td>
<p>Frab objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pairwise minima and maxima for frabs, using names as the primary key.
</p>
<p>Functions <code>pmax_pair()</code> calls <code>c_frab_pmax()</code> and <code>pmin_pair()</code> use 
</p>
<p>Functions <code>pmax()</code> and <code>pmin()</code> use the same mechanism as
<code>cbrob()</code> of the <a href="https://CRAN.R-project.org/package=Brobdingnag"><span class="pkg">Brobdingnag</span></a> package, originally due to
John Chambers (pers. comm.)
</p>


<h3>Value</h3>

<p>Returns a frab object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rfrab()
y &lt;- rfrab()

</code></pre>

<hr>
<h2 id='print'>Methods for printing frabs</h2><span id='topic+print'></span><span id='topic+print.frab'></span><span id='topic+frab_print'></span><span id='topic+show+2Cfrab-method'></span>

<h3>Description</h3>

<p>Methods for printing frabs nicely</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'frab'
show(object)
frab_print(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_object">object</code></td>
<td>
<p>An object of class <code>frab</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is sensitive to option <code>frab_print_hash</code>.  If
<code>TRUE</code>, the hash code is printed; otherwise it is not.
</p>
<p>Function <code>frab_print()</code> returns its argument, invisibly.
</p>
<p>There is special dispensation for the empty <code>frab</code> object.
</p>


<h3>Value</h3>

<p>Returns its argument, invisibly</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
print(rfrab())  # default

options(frab_print_hash = TRUE)
print(rfrab())  # prints hash code

options(frab_print_hash = NULL)  # restore default

</code></pre>

<hr>
<h2 id='rfrab'>Random frabs</h2><span id='topic+rfrab'></span><span id='topic+rfrabb'></span><span id='topic+rfrabbb'></span>

<h3>Description</h3>

<p>Random <code>frab</code> objects, intended as quick
&ldquo;get you going&rdquo; examples</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfrab(n = 9, v = seq_len(5), symb = letters[seq_len(9)])
rfrabb(n = 100, v = -5:5, symb = letters)
rfrabbb(n = 5000, v = -10:10, symb = letters, i=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfrab_+3A_n">n</code></td>
<td>
<p>Length of object to return</p>
</td></tr>
<tr><td><code id="rfrab_+3A_v">v</code></td>
<td>
<p>Values to assign to symbols (see details)</p>
</td></tr>
<tr><td><code id="rfrab_+3A_symb">symb</code></td>
<td>
<p>Symbols to use</p>
</td></tr>
<tr><td><code id="rfrab_+3A_i">i</code></td>
<td>
<p>Exponentiating index for <code>rfrabbb()</code>.  Symbols in
returned value will be <code>i</code> concatenated elements of <code>symb</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>What you see is what you get, basically.  If a symbol is chosen more
than once, as in, <code>c(a=1,b=2,a=3)</code>, then the value for <code>a</code>
will be summed.
</p>
<p>Use function <code>rfrab()</code> for a small, easily-managed object;
<code>rfrabb()</code> and <code>rfrabbb()</code> give successively larger objects.
</p>


<h3>Value</h3>

<p>Returns a frab object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rfrab()
</code></pre>

<hr>
<h2 id='sparsetable'>Generalized sparse tables: <code>sparsetable</code> objects</h2><span id='topic+sparsetable'></span><span id='topic+as.sparsetable'></span><span id='topic+is.sparsetable'></span><span id='topic+sparsetable-class'></span><span id='topic+index'></span><span id='topic+index+2Csparsetable-method'></span><span id='topic+values+2Csparsetable-method'></span><span id='topic+names+2Csparsetable-method'></span><span id='topic+dimnames+2Csparsetable-method'></span><span id='topic+dimnames+3C-+2Csparsetable-method'></span><span id='topic+dimnames+3C-+2Csparsetable+2CANY-method'></span><span id='topic+is.empty+2Csparsetable-method'></span><span id='topic+arity'></span><span id='topic+arity+2Csparsetable-method'></span><span id='topic+dim'></span><span id='topic+dim+2Csparsetable-method'></span><span id='topic+asum'></span><span id='topic+asum.sparsetable'></span><span id='topic+asum+2Csparsetable-method'></span><span id='topic+asum_sparsetable'></span><span id='topic+asum_exclude_sparsetable'></span><span id='topic+as.array+2Csparsetable-method'></span><span id='topic+nterms'></span><span id='topic+nterms+2Csparsetable-method'></span><span id='topic+show+2Csparsetable-method'></span><span id='topic+print_sparsetable_matrixform'></span><span id='topic+sparsetable_to_table'></span><span id='topic+sparsetable_to_frab'></span><span id='topic+sparsetable_asum_include'></span><span id='topic+sparsetable_asum_exclude'></span><span id='topic+table_to_sparsetable'></span><span id='topic+sparsetable'></span><span id='topic+array_to_sparsetable'></span><span id='topic+sparsetable_to_array'></span><span id='topic+sparsetable_pmax'></span><span id='topic+sparsetable_pmin'></span><span id='topic+sparsetable_negative'></span><span id='topic+sparsetable_times_scalar'></span><span id='topic+sparsetable_eq_sparsetable'></span><span id='topic+sparsetable_equality'></span><span id='topic+sparsetable_maker'></span><span id='topic+rspar'></span><span id='topic+rspar2'></span><span id='topic+rsparr'></span><span id='topic+sparsetable_add'></span><span id='topic+sparsetable_negative'></span><span id='topic+sparsetable_reciprocal'></span><span id='topic+sparsetable_plus_sparsetable'></span><span id='topic+sparsetable_multiply_sparsetable'></span><span id='topic+sparsetable_multiply_numeric'></span><span id='topic+sparsetable_power_numeric'></span><span id='topic+numeric_compare_sparsetable'></span><span id='topic+numeric_multiply_sparsetable'></span><span id='topic+numeric_power_sparsetable'></span><span id='topic+sparsetable_accessor'></span><span id='topic+sparsetable_unary'></span><span id='topic+sparsetable_arith_sparsetable'></span><span id='topic+sparsetable_arith_numeric'></span><span id='topic+numeric_arith_sparsetable'></span><span id='topic+sparsetable_overwrite'></span><span id='topic+sparsetable_setter'></span><span id='topic+sparsetable_eq'></span><span id='topic+sparsetable_compare_sparsetable'></span><span id='topic+sparsetable_eq_num'></span><span id='topic+sparsetable_gt_num'></span><span id='topic+sparsetable_ge_num'></span><span id='topic+sparsetable_lt_num'></span><span id='topic+sparsetable_le_num'></span><span id='topic+sparsetable_compare_numeric'></span><span id='topic+num_eq_sparsetable'></span><span id='topic+num_gt_sparsetable'></span><span id='topic+num_ge_sparsetable'></span><span id='topic+num_lt_sparsetable'></span><span id='topic+num_le_sparsetable'></span><span id='topic+drop'></span><span id='topic+drop+2Csparsetable-method'></span><span id='topic++5B+2Csparsetable-method'></span><span id='topic++5B+2Csparsetable+2Cdisord+2Cmissing-method'></span><span id='topic++5B+2Csparsetable+2Cdisindex+2Cmissing+2CANY-method'></span><span id='topic++5B+2Csparsetable+2Cdisord+2Cmissing+2CANY-method'></span><span id='topic++5B+2Csparsetable+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Csparsetable-method'></span><span id='topic++5B+3C-+2Csparsetable+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Csparsetable+2Cdisindex+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Csparsetable+2Cdisord+2Cmissing+2Cnumeric-method'></span><span id='topic+pmax_sparsetable'></span><span id='topic+pmin_sparsetable'></span><span id='topic+pmax.sparsetable'></span><span id='topic+pmin.sparsetable'></span><span id='topic+pmax+2Csparsetable-method'></span><span id='topic+pmin+2Csparsetable-method'></span><span id='topic+pmax_pair_sparsetable'></span><span id='topic+pmin_pair_sparsetable'></span><span id='topic+pmax_dots_sparsetable'></span><span id='topic+pmin_dots_sparsetable'></span>

<h3>Description</h3>

<p>Package idiom for creating and manipulating
<code>sparsetable</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsetable(i,v=1)
rspar(n=15,l=3,d=3)
rspar2(n=15,l=6)
rsparr(n=20,d=6,l=5,s=4)
sparsetable_to_array(x)
array_to_sparsetable(x)
sparsetable_to_frab(x)
## S4 method for signature 'sparsetable'
index(x)
## S4 method for signature 'sparsetable'
values(x)
## S4 method for signature 'sparsetable'
dimnames(x)
## S4 method for signature 'sparsetable'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsetable_+3A_x">x</code></td>
<td>
<p>In functions like <code>index()</code>, an object of class <code>sparsetable</code></p>
</td></tr>
<tr><td><code id="sparsetable_+3A_i">i</code>, <code id="sparsetable_+3A_v">v</code></td>
<td>
<p>In standard constructor function <code>sparsetable()</code>,
argument <code>i</code> is the index matrix of strings, and <code>v</code> a
numeric vector of values</p>
</td></tr>
<tr><td><code id="sparsetable_+3A_n">n</code>, <code id="sparsetable_+3A_l">l</code>, <code id="sparsetable_+3A_d">d</code>, <code id="sparsetable_+3A_s">s</code></td>
<td>
<p>In functions <code>rspar()</code>, <code>rspar2()</code>, and
<code>rsparr()</code>, <code>n</code> is the number of terms, <code>l</code> the
number of letters, <code>d</code> the dimensionality and <code>s</code> the
number of distinct marginal values to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most functions here mirror their equivalent in the <a href="https://CRAN.R-project.org/package=spray"><span class="pkg">spray</span></a>
package [which the C code is largely copied from] or the
<code>frab</code> functionality.  So, for example, <code>num_eq_sparsetable()</code>
is the equivalent of <code>num_eq_spray()</code>.
</p>
<p>The print method treats arity-2 <code>sparsetable</code> objects differently
from other arities.  By default, arity-2 <code>sparsetable</code> objects are
displayed as two-dimensional tables.  Control this behaviour with option
<code>print_2dsparsetables_as_matrices</code>:
</p>
<pre>
  options("print_2dsparsetables_as_matrices" = FALSE)
</pre>
<p>The default value for this option, non-<code>FALSE</code> (including its
out-of-the-box status of &ldquo;unset&rdquo;), directs the print method to
coerce arity-2 <code>sparsetable</code> objects to two-dimensional tables
before printing.  If this option is <code>FALSE</code>, arity-2 sparsetables
are printed using matrix index form, just the same as any other arity.
</p>
<p>Functions <code>rspar()</code>, <code>rspar2()</code>, and <code>rsparr()</code> create
random <code>sparsetable</code> objects of increasing complexity.  The
defaults are chosen so that the returned frabs are of sensible sizes.
</p>
<p>Function <code>drop()</code> takes a sparsetable object of arity one and
coerces to a <code>frab</code> object.
</p>
<p>Function <code>dim()</code> returns a named vector, with names being the
<code>dimnames</code> of its argument.
</p>
<p>Extraction and replacement methods are a subset of <a href="https://CRAN.R-project.org/package=spray"><span class="pkg">spray</span></a>
methods, but most should work.  There is special dispensation so that
standard idiom for arrays [e.g. <code>x['a','b','a']</code> and
<code>x['a','b','a'] &lt;- 55</code>] should work as expected, although the
general expectation is that access and replacement use (character)
matrices and an index object.  However, indexing by <code>disord</code> and
<code>disindex</code> objects should also work [e.g. <code>x[x&gt;7]</code>].
</p>
<p>The <a href="https://CRAN.R-project.org/package=spray"><span class="pkg">spray</span></a> source code and the <code>sparsetable</code> functionality
have about 90% overlap; there were enough small differences between the
codes to make it worth maintaining two sets of source code, IMO.
</p>
<p>There is a discussion of package idiom in the vignette,
<code>vignette("frab")</code>.
</p>


<h3>Note</h3>

<p>The pronunciation of &ldquo;sparsetable&rdquo; has the emphasis on the
first syllable, so it rhymes with [British river-port town]
&ldquo;Barnstaple&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+frab-class">frab-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
sparsetable(matrix(sample(letters[1:4],36,replace=TRUE),ncol=2),1:18)
sparsetable(matrix(sample(letters[1:4],39,replace=TRUE),ncol=3),1:13)

(x &lt;- rspar2(9))
(y &lt;- rspar2(9))
x + y

x["KT","FF"] &lt;- 100
x

rsparr()

a &lt;- rspar(d=4)
asum(a,"Feb")

</code></pre>

<hr>
<h2 id='Summary-methods'>Methods for Function <code>Summary</code></h2><span id='topic+Summary-methods'></span><span id='topic+Summary+2Cfrab-method'></span>

<h3>Description</h3>

<p>Methods for S4 function <code>Summary</code> in the <span class="pkg">frab</span>
package.  Currently, only <code>max()</code>, <code>min()</code>, <code>range()</code>
and <code>sum()</code> are defined, and these operate in the natural way on
the elements of a <code>frab</code>.  Note that these functions are not
susceptible to <a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> violations.
</p>


<h3>Methods</h3>

<dl>
<dt><code>signature(x = "frab")</code></dt><dd><p>Dispatches to
<code>max(values(x))</code> etc.</p>
</dd></dl>



<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rfrab()
a
max(a)
min(a)
range(a)
</code></pre>

<hr>
<h2 id='table'>Tables and frab objects</h2><span id='topic+table'></span><span id='topic+is.1dtable'></span><span id='topic+table_to_frab'></span><span id='topic+as.table'></span><span id='topic+as.table+2Cfrab-method'></span>

<h3>Description</h3>

<p>Various methods and functions to deal with tables in the <span class="pkg">frab</span>
package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'frab'
as.table(x,...)
table_to_frab(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_+3A_x">x</code></td>
<td>
<p>Object of class <code>frab</code> or <code>table</code></p>
</td></tr>
<tr><td><code id="table_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a <code>frab</code> object has non-negative entries it may be interpreted
as a table.  However, in base <span class="rlang"><b>R</b></span>, <code>table</code> objects do not have
sensible addition methods which is why the <span class="pkg">frab</span> package is
needed.
</p>
<p>Function <code>is.1dtable()</code> checks for its argument being a
one-dimensional table.  The idea is that a table like
<code>table(sample(letters,30,TRUE))</code>, being a table of a single
observation, is accepted but a table like
<code>table(data.frame(rnorm(20)&gt;0,rnorm(20)&gt;0))</code> is not acceptable
because it is a <em>two</em>-dimensional contingency table.
</p>


<h3>Value</h3>

<p>Generally return a table or frab.</p>


<h3>Note</h3>

<p>The order of the entries may be changed during the coercion, as per
<a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> discipline.  Function <code>as.frab()</code> takes a
table, dispatching to <code>table_to_frab()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- table(letters[c(1,1,1,1,2,3,3)])
Y &lt;- table(letters[c(1,1,1,1,3,4,4)])
Z &lt;- table(letters[c(1,1,2,3,4,5,5)])

X+Y  # defined but nonsense

# X+Z  # returns an error


as.frab(X) + as.frab(Y)  # correct answer

plot(as.table(rfrab()))
</code></pre>

<hr>
<h2 id='zero'>The zero frab object</h2><span id='topic+zero'></span><span id='topic+is.zero'></span><span id='topic+empty'></span><span id='topic+is.empty'></span>

<h3>Description</h3>

<p>Test for a <code>frab</code> object's being zero (empty).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero(...)
is.zero(x)
is.empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_+3A_x">x</code></td>
<td>
<p>Object of class <code>frab</code></p>
</td></tr>
<tr><td><code id="zero_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>zero()</code> returns the empty <code>frab</code> object; this is
the additive identity <code class="reqn">0</code> with property <code class="reqn">x+0=0+x=x</code>.
</p>
<p>Function <code>is.zero()</code> returns <code>TRUE</code> if its argument is
indeed the zero object.
</p>
<p>Function <code>is.empty()</code> is a synonym for <code>is.zero()</code>.
Sometimes one is thinking about the free Abelian group, in which case
<code>is.zero()</code> makes more sense, and sometimes one is thinking about
maps and tables, in which case <code>is.empty()</code> is more appropriate.
</p>


<h3>Value</h3>

<p>Function <code>zero()</code> returns the zero frab object, function
<code>is.zero()</code> a Boolean</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zero()
zero() + zero()

x &lt;- rfrab()

x+zero() == x

is.zero(zero())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
