<!DOCTYPE html><html><head><title>Help for package mppR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mppR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#create.mppData'><p>Create a multi-parent population data object</p></a></li>
<li><a href='#CV_partition'><p>Cross validation partition</p></a></li>
<li><a href='#design_connectivity'><p>Connected parts of a MPP design</p></a></li>
<li><a href='#EC_effect'><p>Determine EC effects</p></a></li>
<li><a href='#IBD.mppData'><p>IBD coding for <code>mppData</code> objects</p></a></li>
<li><a href='#IBS.mppData'><p>IBS coding for <code>mppData</code> objects</p></a></li>
<li><a href='#inc_mat_QTL'><p>QTL incidence matrix</p></a></li>
<li><a href='#mpp_back_elim'><p>Backward elimination on QTL candidates</p></a></li>
<li><a href='#mpp_CIM'><p>MPP Composite Interval Mapping</p></a></li>
<li><a href='#mpp_CV'><p>MPP cross-validation</p></a></li>
<li><a href='#mpp_forward'><p>MPP QTL analysis using forward regression</p></a></li>
<li><a href='#mpp_perm'><p>QTL significance threshold by permutation</p></a></li>
<li><a href='#mpp_proc'><p>MPP QTL analysis</p></a></li>
<li><a href='#mpp_SIM'><p>MPP Simple Interval Mapping</p></a></li>
<li><a href='#mppData'>
<p>Complete <code>mppData</code> object</p></a></li>
<li><a href='#mppData_add_pheno'><p>Add new phenotypic values to a mppData object</p></a></li>
<li><a href='#mppData_GE'>
<p>Example <code>mppData</code> object</p></a></li>
<li><a href='#mppData_init'>
<p><code>mppData</code> object with raw data</p></a></li>
<li><a href='#mppData_mdf_pheno'><p>Modify the phenotypic values of a mppData object</p></a></li>
<li><a href='#mppGE_CIM'><p>MPP GxE Composite Interval Mapping</p></a></li>
<li><a href='#mppGE_proc'><p>MPP GxE QTL analysis</p></a></li>
<li><a href='#mppGE_SIM'><p>MPP GxE Simple Interval Mapping</p></a></li>
<li><a href='#MQE_gen_effects'><p>QTL genetic effects multi-QTL effect model</p></a></li>
<li><a href='#MQE_proc'><p>Multi-QTL effect MPP analysis</p></a></li>
<li><a href='#par_clu'>
<p>Parental clustering</p></a></li>
<li><a href='#parent_cluster.mppData'><p>Parent clustering for <code>mppData</code> objects</p></a></li>
<li><a href='#plot_allele_eff_GE'><p>plot of genome wide QTL allelic effect significance</p></a></li>
<li><a href='#plot_QxEC'><p>plot QTLxEC effect</p></a></li>
<li><a href='#plot.QTLprof'><p>plot QTL profile</p></a></li>
<li><a href='#print.summary.mppData'><p>Print summary.mppData object</p></a></li>
<li><a href='#print.summary.QeffRes'><p>Print summary.QeffRes object</p></a></li>
<li><a href='#print.summary.QR2Res'><p>Print summary.QR2Res object</p></a></li>
<li><a href='#QC.mppData'><p>Quality control for <code>mppData</code> objects</p></a></li>
<li><a href='#QTL_effect_GE'><p>MPP GxE QTL genetic effects</p></a></li>
<li><a href='#QTL_effect_main_QEI'><p>Main and QTL by environment interaction model</p></a></li>
<li><a href='#QTL_effect_main_QxEC'><p>Estimation of a model with main and QTL by environmental sensitivity terms</p></a></li>
<li><a href='#QTL_forward'><p>Forward regression QTL model</p></a></li>
<li><a href='#QTL_gen_effects'><p>QTL genetic effects</p></a></li>
<li><a href='#QTL_pred_R2'><p>Predicted QTL global and partial R squared</p></a></li>
<li><a href='#QTL_R2'><p>QTL global and partial R squared</p></a></li>
<li><a href='#QTL_R2_GE'><p>MPP GxE QTL R2</p></a></li>
<li><a href='#QTL_select'><p>QTL candidates selection</p></a></li>
<li><a href='#subset.mppData'><p>Subset <code>mppData</code> object</p></a></li>
<li><a href='#summary.mppData'><p>Summary of <code>mppData</code> object</p></a></li>
<li><a href='#summary.QeffRes'><p>Summary of <code>QeffRes</code> object</p></a></li>
<li><a href='#summary.QR2Res'><p>Summary of <code>QR2Res</code> object</p></a></li>
<li><a href='#USNAM_geno'>
<p>Reduced genotype data maize US-NAM population</p></a></li>
<li><a href='#USNAM_map'>
<p>Reduced map maize US-NAM population</p></a></li>
<li><a href='#USNAM_pheno'>
<p>Reduced phenotype data from Maize US-NAM population</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Parent Population QTL Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of experimental multi-parent populations to detect regions
             of the genome (called quantitative trait loci, QTLs) influencing
             phenotypic traits measured in unique and multiple environments.
             The population must be composed of crosses between a set of at
             least three parents (e.g. factorial design, 'diallel', or nested
             association mapping). The functions cover data processing,
             QTL detection, and results visualization. The implemented methodology
             is described in Garin, Wimmer, Mezmouk, Malosetti and van Eeuwijk (2017)
             &lt;<a href="https://doi.org/10.1007%2Fs00122-017-2923-3">doi:10.1007/s00122-017-2923-3</a>&gt;, in Garin, Malosetti
             and van Eeuwijk (2020) &lt;<a href="https://doi.org/10.1007%2Fs00122-020-03621-0">doi:10.1007/s00122-020-03621-0</a>&gt;,
             and in Garin, Diallo, Tekete, Thera, ..., and Rami (2024) &lt;<a href="https://doi.org/10.1093%2Fgenetics%2Fiyae003">doi:10.1093/genetics/iyae003</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, graphics, grDevices, igraph, Matrix, methods,
nlme, parallel, qtl, stats, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vincentgarin/mppR">https://github.com/vincentgarin/mppR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vincentgarin/mppR/issues">https://github.com/vincentgarin/mppR/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-22 15:33:08 UTC; garin</td>
</tr>
<tr>
<td>Author:</td>
<td>Vincent Garin <a href="https://orcid.org/0000-0002-5571-1841"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Valentin Wimmer [aut],
  Dietrich Borchardt [ctb, dtc],
  Fred van Eeuwijk [ctb, ths],
  Marcos Malosetti [ctb, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vincent Garin &lt;vincent.garin6@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-22 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='create.mppData'>Create a multi-parent population data object</h2><span id='topic+create.mppData'></span>

<h3>Description</h3>

<p>This function combines all raw data sources in a single data object of class
<code>mppData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.mppData(
  geno.off = NULL,
  geno.par = NULL,
  map = NULL,
  pheno = NULL,
  cross.ind = NULL,
  par.per.cross = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.mppData_+3A_geno.off">geno.off</code></td>
<td>
<p><code>Character</code> marker score <code>matrix</code> of the offspring
with genotypes as row and markers as column.
<strong>Rows names must be the offspring genotypes identifiers similar to
the one used in <code>pheno</code>. The columns names must be the marker names
similar to the one used in <code>map</code>. Marker scores must be coded using one
letter per allele. For example, AA, CC, GG, etc. Missing values must be coded
<code>NA</code>.</strong></p>
</td></tr>
<tr><td><code id="create.mppData_+3A_geno.par">geno.par</code></td>
<td>
<p><code>Character</code> marker score <code>matrix</code> of the parents
with genotypes as row and markers as column.
<strong>Rows names must be the parents genotypes identifiers similar to
the one used in <code>par.per.cross</code>. The columns names must be the marker
names similar to the one used in <code>map</code>. Marker scores must be coded
using one letter per allele. For example, AA, CC, GG, etc. Missing values
must be coded <code>NA</code>.</strong></p>
</td></tr>
<tr><td><code id="create.mppData_+3A_map">map</code></td>
<td>
<p>Three columns <code>data.frame</code> with: 1) <code>character</code> marker
identifiers; 2) <code>numeric</code> chromosome; 3) <code>numeric</code> positions in
centi-Morgan.<strong>The marker identifiers must be identical to the column
names of the maker matrices (<code>geno.off</code> and <code>geno.par</code>).
The chromosome identifiers must start by 1 and increase by 1 unit,
e.g. 1, 2, 3, ...</strong></p>
</td></tr>
<tr><td><code id="create.mppData_+3A_pheno">pheno</code></td>
<td>
<p><code>Numeric matrix</code> with one column per trait and rownames
as genotypes identifiers. <strong>The genotypes identifiers must be identical
to the rownames of the offspring marker matrix (<code>geno.off</code>).</strong></p>
</td></tr>
<tr><td><code id="create.mppData_+3A_cross.ind">cross.ind</code></td>
<td>
<p><code>Character</code> vector indicating to which cross each
genotype belongs.</p>
</td></tr>
<tr><td><code id="create.mppData_+3A_par.per.cross">par.per.cross</code></td>
<td>
<p>Three columns <code>Character matrix</code> specifying :
1) the cross indicators; 2) the parents 1 identifiers
of the crosses; 3) the parents 2 identifiers of the crosses.
<strong>The list of crosses must contain the same cross indicators as in
<code>cross.ind</code> and they must appear in the same order.
The list of parent identifiers must be the same to the rownames of
the argument <code>geno.par</code></strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of class <code>mppData</code> which contains the following elements
</p>
<table>
<tr><td><code>geno.off</code></td>
<td>
<p><code>Matrix</code> with offspring marker scores.</p>
</td></tr>
<tr><td><code>geno.par</code></td>
<td>
<p><code>Matrix</code> with parents marker scores.</p>
</td></tr>
<tr><td><code>pheno</code></td>
<td>
<p><code>Matrix</code> with phenotypic trait values.</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p><code>Data.frame</code> with genetic marker information.</p>
</td></tr>
<tr><td><code>cross.ind</code></td>
<td>
<p>Cross indicator.</p>
</td></tr>
<tr><td><code>par.per.cross</code></td>
<td>
<p><code>Character matrix</code> information about cross and
the parents of the crosses.</p>
</td></tr>
</table>
<p>The <code>list</code> also contain other arguments that will be filled later in
the data processing.
</p>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USNAM_geno)
data(USNAM_map)
data(USNAM_pheno)

geno.off &lt;- USNAM_geno[7:506, ]
geno.par &lt;- USNAM_geno[1:6, ]
map &lt;- USNAM_map
pheno &lt;-  USNAM_pheno
cross.ind &lt;- substr(rownames(pheno), 1, 4)
par.per.cross &lt;- cbind(unique(cross.ind), rep("B73", 5),
                       rownames(geno.par)[2:6])

mppData &lt;- create.mppData(geno.off = geno.off, geno.par = geno.par,
                          map = map, pheno = pheno, cross.ind = cross.ind,
                          par.per.cross = par.per.cross)
                          
</code></pre>

<hr>
<h2 id='CV_partition'>Cross validation partition</h2><span id='topic+CV_partition'></span>

<h3>Description</h3>

<p>Partition the genotype indices into training and validation sets for
cross-validation (CV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CV_partition(cross.ind, k = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CV_partition_+3A_cross.ind">cross.ind</code></td>
<td>
<p><code>Character</code> vector with the same length as the number
of genotypes which specifies to which cross each genotype belongs.</p>
</td></tr>
<tr><td><code id="CV_partition_+3A_k">k</code></td>
<td>
<p><code>Numeric</code> value representing the number of subsets (fold) into
which data are spread within cross. Default = 5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genotype indices are randomly assigned within cross to k subsets (folds).
Then each subset is used once as validation set, the remaining data go in the
training set.
</p>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>fold</code></td>
<td>
<p><code>List</code> of k lists (one for each fold). Each fold list
contains two vectors with genotypes indices of the training (<code>$train.set</code>) and
the validation set (<code>$val.set</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_CV">mpp_CV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

part.cv &lt;- CV_partition(cross.ind = mppData$cross.ind, k = 5)

part.cv[[1]]$train.set
part.cv[[1]]$val.set

</code></pre>

<hr>
<h2 id='design_connectivity'>Connected parts of a MPP design</h2><span id='topic+design_connectivity'></span>

<h3>Description</h3>

<p>Determine the connected parts of a MPP design using the method of Weeks and
Williams (1964) and the package igraph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_connectivity(par_per_cross, plot_des = TRUE, output_loc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_connectivity_+3A_par_per_cross">par_per_cross</code></td>
<td>
<p>Three columns <code>character matrix</code> specifying :
1) the cross indicators ; 2) the parents 1 identifiers of the crosses;
3) the parents 2 identifiers of the crosses.</p>
</td></tr>
<tr><td><code id="design_connectivity_+3A_plot_des">plot_des</code></td>
<td>
<p><code>Logical</code> value indicating if connected part of the
design should be plotted. Default = TRUE.</p>
</td></tr>
<tr><td><code id="design_connectivity_+3A_output_loc">output_loc</code></td>
<td>
<p>Path where the plot of the design will be saved if the
argument is given. Default = NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with each element representing one connected part of the design
and the list of parents contained in this part.
</p>
<p>If <code>plot_des = TRUE</code> and <code>output_loc</code> has been specified. A plot
of the graph (con_plot.pdf) will be saved at the specified location.
</p>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Weeks, D. L., &amp; Williams, D. R. (1964). A note on the determination of
connectedness in an N-way cross classification. Technometrics, 6(3), 319-324.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

par_per_cross &lt;- mppData$par.per.cross

con.part &lt;- design_connectivity(par_per_cross)

</code></pre>

<hr>
<h2 id='EC_effect'>Determine EC effects</h2><span id='topic+EC_effect'></span>

<h3>Description</h3>

<p>Determine the effect of environmental covariates (EC) on the mean of a
trait across environments and the time range where this effect is the
strongest. The procedure was originally proposed by Li et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EC_effect(
  trait_env_mean,
  crop_duration,
  EC_list,
  type,
  min_win = 20,
  sel_criteria = "global",
  plot = TRUE,
  plot_dir = NULL,
  p_title = "EC_plot",
  env_nm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EC_effect_+3A_trait_env_mean">trait_env_mean</code></td>
<td>
<p>vector of trait mean over environment.</p>
</td></tr>
<tr><td><code id="EC_effect_+3A_crop_duration">crop_duration</code></td>
<td>
<p>numerical value indicating the crop duration.</p>
</td></tr>
<tr><td><code id="EC_effect_+3A_ec_list">EC_list</code></td>
<td>
<p>list EC parameter matrix. one per environment. The
order of the environment must be the same as the one of the trait
mean.</p>
</td></tr>
<tr><td><code id="EC_effect_+3A_type">type</code></td>
<td>
<p>character string vector indicating the type of statistic
that correspond to the EC. Either the cumulated sum ('sum') or the
average ('mean').</p>
</td></tr>
<tr><td><code id="EC_effect_+3A_min_win">min_win</code></td>
<td>
<p>Numerical value indicating the minimum size of the range
between start and end day when the EC values are measured. Default = 20</p>
</td></tr>
<tr><td><code id="EC_effect_+3A_sel_criteria">sel_criteria</code></td>
<td>
<p>Character specifying the selection criteria.
Default = 'global'</p>
</td></tr>
<tr><td><code id="EC_effect_+3A_plot">plot</code></td>
<td>
<p>Logical value indicating if a plot of the EC effects over time
should be returned. Default = FALSE,</p>
</td></tr>
<tr><td><code id="EC_effect_+3A_plot_dir">plot_dir</code></td>
<td>
<p>Directory where the plot should be returned. Default = NULL</p>
</td></tr>
<tr><td><code id="EC_effect_+3A_p_title">p_title</code></td>
<td>
<p>Title of the plot. Default = 'EC_plot'</p>
</td></tr>
<tr><td><code id="EC_effect_+3A_env_nm">env_nm</code></td>
<td>
<p>Optional vector of environment name. Default = NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return:
</p>
<p><code>data.frame</code> that contains the following elements for each EC (line).
The first line is the value of the EC in the different environments:
</p>

<ol>
<li><p>Start and end date of the optimal window
</p>
</li>
<li><p>R2 of correlation between trait and EC
</p>
</li>
<li><p>Direction of the correlation
</p>
</li>
<li><p>Average R2 value over all tested windows
</p>
</li>
<li><p>EC value in the different environments for the optimal time window
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Li, X., Guo, T., Mu, Q., Li, X., &amp; Yu, J. (2018). Genomic and environmental
determinants and their interplay underlying phenotypic plasticity.
Proceedings of the National Academy of Sciences, 115(26), 6679-6684.
</p>

<hr>
<h2 id='IBD.mppData'>IBD coding for <code>mppData</code> objects</h2><span id='topic+IBD.mppData'></span>

<h3>Description</h3>

<p>The function first converts genotype data into ABH format. Then it calculates
within cross identical by descent (IBD) probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBD.mppData(
  mppData,
  het.miss.par = TRUE,
  subcross.ind = NULL,
  par.per.subcross = NULL,
  type,
  F.gen = NULL,
  BC.gen = NULL,
  type.mating = NULL,
  error.prob = 1e-04,
  map.function = "haldane"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBD.mppData_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>. the <code>mppData</code> must
have been processed using: <code><a href="#topic+create.mppData">create.mppData</a></code>,
<code><a href="#topic+QC.mppData">QC.mppData</a></code>, and <code><a href="#topic+IBS.mppData">IBS.mppData</a></code>.</p>
</td></tr>
<tr><td><code id="IBD.mppData_+3A_het.miss.par">het.miss.par</code></td>
<td>
<p><code>Logical</code> value. if <code>het.miss.par = TRUE</code>,
the function will use the offspring segregation to try to infer the allele
that was transmitted by the heterozygous or missing parent at a particular
locus to make the ABH conversion. Default = TRUE.</p>
</td></tr>
<tr><td><code id="IBD.mppData_+3A_subcross.ind">subcross.ind</code></td>
<td>
<p>Optional <code>character</code> vector specifying to which
sub-cross each genotype belong. Default = NULL.</p>
</td></tr>
<tr><td><code id="IBD.mppData_+3A_par.per.subcross">par.per.subcross</code></td>
<td>
<p>Optional three columns <code>Character matrix</code>
specifying : 1) the sub-cross indicators; 2) the parents 1 identifiers
of the sub-crosses; 3) the parents 2 identifiers of the sub-crosses.
Default = NULL.</p>
</td></tr>
<tr><td><code id="IBD.mppData_+3A_type">type</code></td>
<td>
<p><code>Character</code> indicator for the type of population analyzed:
type = &quot;F&quot; for Fn (F cross n generations); type = &quot;BC&quot; for BCn (backcross
n generations); type = &quot;BCsFt&quot; for backcross followed by selfing;
type = &quot;DH&quot; for double haploids; and type = &quot;RIL&quot;
for recombinant inbred lines. For RIL type specify if the population was
obtain using selfing or sibling mating using <code>type.mating</code>.
If type = &quot;RIL&quot; or &quot;DH&quot;, the function does not assume heterozygous marker
scores for these populations and convert them into missing (NA).</p>
</td></tr>
<tr><td><code id="IBD.mppData_+3A_f.gen">F.gen</code></td>
<td>
<p><code>Numeric</code> integer representing the number of F generations.
For example F.gen = 2 for F2. Default = NULL.</p>
</td></tr>
<tr><td><code id="IBD.mppData_+3A_bc.gen">BC.gen</code></td>
<td>
<p><code>Numeric</code> integer representing the number of
backcross generations. For example BC.gen = 1 for single backcross.
Default = NULL.</p>
</td></tr>
<tr><td><code id="IBD.mppData_+3A_type.mating">type.mating</code></td>
<td>
<p><code>Character</code> specifying for a RIL population if it was
obtained by selfing (&quot;selfing&quot;) or by sibling mating (&quot;sib.mat&quot;).
Default = NULL.</p>
</td></tr>
<tr><td><code id="IBD.mppData_+3A_error.prob">error.prob</code></td>
<td>
<p><code>Numeric</code> value for assumed genotyping error rate
used in the calculation of the penetrance Pr(observed genotype | true genotype).
Default = 0.0001.</p>
</td></tr>
<tr><td><code id="IBD.mppData_+3A_map.function">map.function</code></td>
<td>
<p><code>Character</code> expression specifying the type of map
function used to infer the IBD probabilities. possibility to choose
between &quot;haldane&quot;, &quot;kosambi&quot;,&quot;c-f&quot;,&quot;morgan&quot;. Default = &quot;haldane&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first transforms genotype data into within cross ABH format.
The function takes the parents of the different cross as
reference and assigns the following scores: &quot;A&quot; if the offspring score is
equivalent to parent 1; &quot;B&quot; if it is equivalent to parent 2; &quot;H&quot; if it is
heterozygous. The function attributes NA for missing when: 1) the offspring
score is missing; 2) the two parents have the same score; or
3) when at least one parental score is missing.
</p>
<p>If a parent score is heterozygous or missing (<code>het.miss.par = TRUE</code>),
the assignment rules are the following. If the two parents are
heterozygous or one parent is heterozygous and the other missing, the
offspring get NA since the parental origin can not be inferred with certainty.
If one parent is heterozygous or missing and the second parent is
homozygous, the function looks at offspring segregating pattern to
infer which allele was transmitted by the heterozygous parent. If this is
possible we consider the heteroxzygous parent as homozygous for the
transmitted allele and use this allele score for ABH assignment.
</p>
<p>The ABH assignment can be performed using sub-cross structure providing
information about sub-cross in arguments <code>subcross.ind</code> and
<code>par.per.subcross</code>. 
</p>
<p>Then the function calculates the IBD probabilities using <code>read.cross()</code>
and <code>calc.genoprob()</code> functions from the R/qtl package
(Broman et al. 2009).
</p>
<p>The type of population must be specified in argument <cite>type</cite>. Different
population types are possible: F-type ('F'), back-cross ('BC'), backcross
followed by selfing ('BCsFt'), double haploid ('DH'), and recombinant imbred
lines ('RIL'). The number of F and BC generations can be specified using
<code>F.gen</code> and <code>BC.gen</code>. The argument <code>type.mating</code> specifies if
F and RIL populations were obtained by selfing or by sibling mating.
</p>
<p>DH and RIL populations are read as back-cross by R/qtl. For these two
population types, heterozygous scores will be treated as missing values.
</p>


<h3>Value</h3>

<p>an increased <code>mppData</code> object containing the the same elements
as the <code>mppData</code> object provided as argument and the
following new elements:
</p>
<table>
<tr><td><code>geno.IBD</code></td>
<td>
<p>A R/qtl <code>cross.object</code> containing the IBD probabilities.</p>
</td></tr>
<tr><td><code>n.zigo</code></td>
<td>
<p><code>Numeric</code> value Indicating the number of different
genotypes: 2 (AA/BB) or 3 (AA/AB/BB)</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p><code>Character</code> expression indicating the type of population.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Broman KW, Wu H, Sen S, Churchill GA (2003) R/qtl: QTL mapping
in experimental crosses. Bioinformatics 19:889-890.
</p>
<p>Broman, K. W., &amp; Sen, S. (2009). A Guide to QTL Mapping with R/qtl (Vol. 46).
New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.mppData">create.mppData</a></code>, <code><a href="#topic+QC.mppData">QC.mppData</a></code>,
<code><a href="#topic+IBS.mppData">IBS.mppData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData_init)

mppData &lt;- QC.mppData(mppData_init)
mppData &lt;- IBS.mppData(mppData = mppData)

mppData &lt;- IBD.mppData(mppData = mppData, het.miss.par = TRUE, type = 'RIL',
                       type.mating = 'selfing')


</code></pre>

<hr>
<h2 id='IBS.mppData'>IBS coding for <code>mppData</code> objects</h2><span id='topic+IBS.mppData'></span>

<h3>Description</h3>

<p>Transform the genotype marker matrix of a <code>mppData</code> object into
Identical by state (IBS) 0, 1, 2 format. The IBS score represent the number
of copies of the minor allele.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBS.mppData(mppData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBS.mppData_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>. The <code>mppData</code> must
have been processed using: <code><a href="#topic+create.mppData">create.mppData</a></code> and
<code><a href="#topic+QC.mppData">QC.mppData</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an increased <code>mppData</code> object containing the the same elements
as the <code>mppData</code> object provided as argument and the
following new elements:
</p>
<table>
<tr><td><code>geno.IBS</code></td>
<td>
<p>Marker <code>matrix</code> with marker scores coded as 0, 1, 2
corresponding to the number of copies of the least frequent SNP allele.</p>
</td></tr>
<tr><td><code>allele.ref</code></td>
<td>
<p><code>matrix</code> with reference allele scores. The first row
represents the minor allele (lowest frequency), the second the one represent
the major allele (largest frequency) and the two others the heterozygous
scores.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.mppData">create.mppData</a></code>, <code><a href="#topic+QC.mppData">QC.mppData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData_init)

mppData &lt;- QC.mppData(mppData_init)

mppData &lt;- IBS.mppData(mppData = mppData)
      

</code></pre>

<hr>
<h2 id='inc_mat_QTL'>QTL incidence matrix</h2><span id='topic+inc_mat_QTL'></span>

<h3>Description</h3>

<p>Build a single position QTL incidences matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inc_mat_QTL(x, mppData, Q.eff, order.MAF = FALSE, ref_par = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inc_mat_QTL_+3A_x">x</code></td>
<td>
<p><code>Integer</code> value indicating the genetic position on the map
(<code>mppData$map</code>) of the QTL incidence matrix.</p>
</td></tr>
<tr><td><code id="inc_mat_QTL_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="inc_mat_QTL_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effects: 1) &quot;cr&quot; for cross-specific; 2) &quot;par&quot; for parental; 3) &quot;anc&quot;
for ancestral; 4) &quot;biall&quot; for a bi-allelic. For more details see
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="inc_mat_QTL_+3A_order.maf">order.MAF</code></td>
<td>
<p><code>Logical</code> value specifying if the QTL incidence matrix
should be ordered by allele frequency for a parental and ancestral QTL
incidence matrix. The colum will be ordred from the least to the most frequent
allele. Default = FALSE.</p>
</td></tr>
<tr><td><code id="inc_mat_QTL_+3A_ref_par">ref_par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference for the parental model. Default = NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>QTL.mat</code></td>
<td>
<p>QTL incidence matrix. For the
cross-specific model, it represents the difference between the
number of allele from parent 2 or B and parent 1 or A divided by two. For
parental (ancestral) model it represents the expected number of parental
(ancestral) allele copies. For the bi-allelic model, it represents the number
of copies of the least frequent allele.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

QTLmatCr &lt;- inc_mat_QTL(x = 2, mppData = mppData, Q.eff = "cr")

QTLmatPar &lt;- inc_mat_QTL(x = 2, mppData = mppData, Q.eff = "par")

QTLmatAnc &lt;- inc_mat_QTL(x = 2, mppData = mppData, Q.eff = "anc")

QTLmatBi &lt;- inc_mat_QTL(x = 2, mppData = mppData, Q.eff = "biall")


</code></pre>

<hr>
<h2 id='mpp_back_elim'>Backward elimination on QTL candidates</h2><span id='topic+mpp_back_elim'></span>

<h3>Description</h3>

<p>Performs a backward elimination using a list of given QTLs positions. The
positions with a p-value above the significance level <code>alpha</code>, are
successively removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpp_back_elim(mppData, trait = 1, QTL = NULL, Q.eff = "cr", alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpp_back_elim_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mpp_back_elim_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_back_elim_+3A_qtl">QTL</code></td>
<td>
<p>Object of class <code>QTLlist</code> representing a list of
selected position obtained with the function <code><a href="#topic+QTL_select">QTL_select</a></code> or
vector of <code>character</code> marker positions names.
Default = NULL.</p>
</td></tr>
<tr><td><code id="mpp_back_elim_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effects: 1) &quot;cr&quot; for cross-specific; 2) &quot;par&quot; for parental; 3) &quot;anc&quot;
for ancestral; 4) &quot;biall&quot; for a bi-allelic. For more details see
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="mpp_back_elim_+3A_alpha">alpha</code></td>
<td>
<p><code>Numeric</code> value indicating the level of significance for
the backward elimination. Default = 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function starts with all QTL positions in the model and test the inclusion
of each position as the last in the model. If all position p-values are below
<code>alpha</code> the procedure stop. If not the position with the highest p-value
is remove and the procedure continue until there is no more unsignificant
position.
</p>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>QTL</code></td>
<td>
<p><code>Data.frame</code> of class <code>QTLlist</code> with five columns :
1) QTL marker names; 2) chromosomes;
3) interger position indicators on the chromosome;
4) positions in centi-Morgan; and 5) -log10(p-values).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_SIM">mpp_SIM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

SIM &lt;- mpp_SIM(mppData)

QTL &lt;- QTL_select(SIM)

QTL.sel &lt;- mpp_back_elim(mppData = mppData, QTL = QTL)

</code></pre>

<hr>
<h2 id='mpp_CIM'>MPP Composite Interval Mapping</h2><span id='topic+mpp_CIM'></span>

<h3>Description</h3>

<p>Compute QTL models along the genome using cofactors representing other
genetic positions for control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpp_CIM(
  mppData,
  trait = 1,
  Q.eff = "cr",
  cofactors = NULL,
  window = 20,
  plot.gen.eff = FALSE,
  n.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpp_CIM_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mpp_CIM_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_CIM_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effects: 1) &quot;cr&quot; for cross-specific; 2) &quot;par&quot; for parental; 3) &quot;anc&quot;
for ancestral; 4) &quot;biall&quot; for a bi-allelic. For more details see
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="mpp_CIM_+3A_cofactors">cofactors</code></td>
<td>
<p>Object of class <code>QTLlist</code> representing a list of
selected position obtained with the function <code><a href="#topic+QTL_select">QTL_select</a></code> or
vector of <code>character</code> marker positions names.
Default = NULL.</p>
</td></tr>
<tr><td><code id="mpp_CIM_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> distance (cM) on the left and the right of a
cofactor position where it is not included in the model. Default = 20.</p>
</td></tr>
<tr><td><code id="mpp_CIM_+3A_plot.gen.eff">plot.gen.eff</code></td>
<td>
<p><code>Logical</code> value. If <code>plot.gen.eff = TRUE</code>,
the function will save the decomposed genetic effects per cross/parent.
These results can be plotted with the function <code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>
to visualize a genome-wide decomposition of the genetic effects.
<strong>This functionality is only available for the cross-specific,
parental and ancestral models.</strong>
Default value = FALSE.</p>
</td></tr>
<tr><td><code id="mpp_CIM_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details about the different models, see documentation of the
function <code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. The function returns a -log10(p-value) QTL
profile.
</p>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>CIM</code></td>
<td>
<p><code>Data.frame</code> of class <code>QTLprof</code>. with five columns :
1) QTL marker names; 2) chromosomes;
3) interger position indicators on the chromosome;
4) positions in centi-Morgan; and 5) -log10(p-val). And if
<code>plot.gen.eff = TRUE</code>, p-values of the cross or parental QTL effects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_SIM">mpp_SIM</a></code>, <code><a href="#topic+QTL_select">QTL_select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Cross-specific effect model
#############################

data(mppData)

SIM &lt;- mpp_SIM(mppData = mppData, Q.eff = "cr")

cofactors &lt;- QTL_select(Qprof = SIM, threshold = 3, window = 20)

CIM &lt;- mpp_CIM(mppData = mppData, Q.eff = "cr", cofactors = cofactors,
               window = 20, plot.gen.eff = TRUE)

plot(x = CIM)
plot(x = CIM, gen.eff = TRUE, mppData = mppData, Q.eff = "cr")

# Bi-allelic model
##################

cofactors &lt;- mppData$map[c(15, 63), 1]

CIM &lt;- mpp_CIM(mppData = mppData, Q.eff = "biall", cofactors = cofactors,
               window = 20)

plot(x = CIM, type = "h")
                               
</code></pre>

<hr>
<h2 id='mpp_CV'>MPP cross-validation</h2><span id='topic+mpp_CV'></span>

<h3>Description</h3>

<p>Evaluation of MPP QTL detection procedure by cross-validation (CV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpp_CV(
  pop.name = "MPP_CV",
  trait.name = "trait1",
  mppData,
  trait = 1,
  her = 1,
  Rep = 10,
  k = 5,
  Q.eff = "cr",
  thre.cof = 3,
  win.cof = 50,
  N.cim = 1,
  window = 20,
  thre.QTL = 3,
  win.QTL = 20,
  backward = TRUE,
  alpha.bk = 0.05,
  n.cores = 1,
  verbose = TRUE,
  output.loc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpp_CV_+3A_pop.name">pop.name</code></td>
<td>
<p><code>Character</code> name of the studied population.
Default = &quot;MPP_CV&quot;.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_trait.name">trait.name</code></td>
<td>
<p><code>Character</code> name of the studied trait.
Default = &quot;trait1&quot;.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_her">her</code></td>
<td>
<p><code>Numeric</code> value between 0 and 1 representing the heritability
of the trait. <code>her</code> can be a single value or a vector specifying each
within cross heritability. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_rep">Rep</code></td>
<td>
<p><code>Numeric</code> value representing the number of repetition of the
k-fold procedure. Default = 10.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_k">k</code></td>
<td>
<p><code>Numeric</code> value representing the number of folds for the within
cross partition of the population. Default = 5.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effects: 1) &quot;cr&quot; for cross-specific; 2) &quot;par&quot; for parental; 3) &quot;anc&quot;
for ancestral; 4) &quot;biall&quot; for a bi-allelic. For more details see
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_thre.cof">thre.cof</code></td>
<td>
<p><code>Numeric</code> value representing the -log10(p-value)
threshold above which a position can be peaked as a cofactor. Default = 3.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_win.cof">win.cof</code></td>
<td>
<p><code>Numeric</code> value in centi-Morgan representing the minimum
distance between two selected cofactors. Default = 50.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_n.cim">N.cim</code></td>
<td>
<p><code>Numeric</code> value specifying the number of time the CIM
analysis is repeated. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> distance (cM) on the left and the right of a
cofactor position where it is not included in the model. Default = 20.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_thre.qtl">thre.QTL</code></td>
<td>
<p><code>Numeric</code> value representing the -log10(p-value)
threshold above which a position can be selected as QTL. Default = 3.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_win.qtl">win.QTL</code></td>
<td>
<p><code>Numeric</code> value in centi-Morgan representing the minimum
distance between two selected QTLs. Default = 20.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_backward">backward</code></td>
<td>
<p><code>Logical</code> value. If <code>backward = TRUE</code>,
the function performs a backward elimination on the list of selected QTLs.
Default = TRUE.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_alpha.bk">alpha.bk</code></td>
<td>
<p><code>Numeric</code> value indicating the significance level for
the backward elimination. Terms with p-values above this value will
iteratively be removed. Default = 0.05.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value indicating if the progresses of the CV
should be printed. Default = TRUE.</p>
</td></tr>
<tr><td><code id="mpp_CV_+3A_output.loc">output.loc</code></td>
<td>
<p>Path where a folder will be created to save the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the MPP QTL detection models see <code><a href="#topic+mpp_SIM">mpp_SIM</a></code>
documentation. The CV scheme is adapted from Utz et al. (2000) to the MPP
context. A single CV run works like that:
</p>

<ol>
<li><p>Generation of a k-fold partition of the data. The partition is done
within crosses. Each cross is divided into k subsets. Then for the kth
repetition, the kth subset is used as validation set, the rest goes into the
training set.
</p>
</li>
<li><p>For the kth repetition, utilization of the training set for cofactor
selection and multi-QTL model determination (<code><a href="#topic+mpp_SIM">mpp_SIM</a></code> and
<code><a href="#topic+mpp_CIM">mpp_CIM</a></code>). If <code>backward = TRUE</code>, the final list of QTLs is
tested simultaneously using a backward elimination
(<code><a href="#topic+mpp_back_elim">mpp_back_elim</a></code>).
</p>
</li>
<li><p>Use the list of detected QTLs in the training set to calculate
the proportion of genetic variance explained by all detected QTLs in the
training set (p.ts = R2.ts/h2). Where R2.ts is the adjusted
R squared and h2 is the average within cross heritability (<code>her</code>). By
default, her = 1, which mean that
</p>
<p>For each single QTL effect, difference partial R squared are also
calculated. Difference R squared are computed by doing the difference between
a model with all QTLs and a model without the ith position. For details about R
squared computation and adjustment look at <code><a href="#topic+QTL_R2">QTL_R2</a></code>.
</p>
</li>
<li><p>Use the estimates of the QTL effects in the training set (B.ts) to
predict the phenotypic values of the validation set. y.pred.vs = X.vs*B.ts.
Computes the predicted R squared  in the validation set using the squared
Pearson correlation coefficient between the real values (y.vs) and the
predicted values (y.pred.vs). R2.vs = cor(y.ts,y.pred.ts)^2. Then
the predicted genetic variance in the validation set (p.vs) is equal to
p.vs = R2.vs/h2. For heritability correction, the user can provide a single
value for the average within cross heritability or a vector specifying each
within cross heritability. By default, <code>her = 1</code>, which means that the
results represent the proportion of phenotypic variance explained (predicted)
in the training (validation) sets.
</p>
<p>The predicted R squared is computed per cross and then averaged
at the population level (p.ts). Both results are returned. Partial QTL
predicted R squared are also calculated using the difference between the
predicted R squared using all QTL and the predicted R squared without QTL i.
The bias between p.ts and p.vs is calculated as bias = 1 - (p.vs/p.ts).
</p>

</li></ol>



<h3>Value</h3>

<p><code>List</code> containing the following results items:
</p>
<table>
<tr><td><code>CV_res</code></td>
<td>
<p><code>Data.frame</code> containing for each CV run: 1) the number
of detected QTL; 2) the proportion of explained genetic variance in the TS
(p.ts); 3) the proportion of predicted genetic variance in the VS (p.vs) at
the population level (average of within cross prediction); the bias between
p.ts and p.vs (bias = 1-(p.vs/p.ts)).</p>
</td></tr>
<tr><td><code>p.vs.cr</code></td>
<td>
<p><code>Matrix</code> containing the within cross p.vs for each CV run.</p>
</td></tr>
<tr><td><code>QTL</code></td>
<td>
<p><code>Data.frame</code> containing: 1) the list of QTL position detected
at least one time during the entire CV process; 2) the number of times
the position has been detected; 3) the average partial p.ts of the QTL
position; 4) the average partial p.vs of the QTL position; 5) the average
partial bias of the QTL position.</p>
</td></tr>
<tr><td><code>QTL.profiles</code></td>
<td>
<p><code>Data.frame</code> -log10(p-value) QTL profiles of the
different CV runs.</p>
</td></tr>
</table>
<p>The results elements return as R object are also saved as text
files at the specified output location (<code>output.loc</code>). A transparency
plot of the CV results (plot.pdf) is also saved.
</p>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Utz, H. F., Melchinger, A. E., &amp; Schon, C. C. (2000). Bias and sampling error
of the estimated proportion of genotypic variance explained by quantitative
trait loci determined from experimental data in maize using cross validation
and validation with independent samples. Genetics, 154(4), 1839-1849.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_back_elim">mpp_back_elim</a></code>,
<code><a href="#topic+mpp_CIM">mpp_CIM</a></code>,
<code><a href="#topic+mpp_perm">mpp_perm</a></code>,
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>,
<code><a href="#topic+QTL_R2">QTL_R2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(mppData)

# Specify a location where your results will be saved
my.loc &lt;- tempdir()

CV &lt;- mpp_CV(pop.name = "USNAM", trait.name = "ULA", mppData = mppData,
her = .4, Rep = 1, k = 3, verbose = FALSE, output.loc = my.loc)


## End(Not run)

</code></pre>

<hr>
<h2 id='mpp_forward'>MPP QTL analysis using forward regression</h2><span id='topic+mpp_forward'></span>

<h3>Description</h3>

<p>Multi-parent population QTL analysis model using a forward regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpp_forward(
  pop.name = "MPP",
  trait.name = "trait1",
  mppData,
  trait = 1,
  Q.eff = "cr",
  ref.par = NULL,
  sum_zero = FALSE,
  threshold = 4,
  window = 30,
  backward = TRUE,
  alpha.bk = 0.05,
  plot.Qprof = FALSE,
  plot.gen.eff = FALSE,
  CI = FALSE,
  drop = 1.5,
  text.size = 18,
  n.cores = 1,
  verbose = TRUE,
  output.loc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpp_forward_+3A_pop.name">pop.name</code></td>
<td>
<p><code>Character</code> name of the studied population.
Default = &quot;MPP&quot;.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_trait.name">trait.name</code></td>
<td>
<p><code>Character</code> name of the studied trait.
Default = &quot;trait1&quot;.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effect: 1) &quot;cr&quot; for cross-specific effects; 2) &quot;par&quot; parental
effects; 3) &quot;anc&quot; for an ancestral effects; 4) &quot;biall&quot; for a bi-allelic
effects. For more details see <code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_ref.par">ref.par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference to calculate the allelic effects of 
the parental model. For the ancestral model, the ancestral class containing
the reference parent will be set as reference. <strong>This option can only
be used if the MPP design is composed of a unique connected part</strong>.
Default = NULL.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_sum_zero">sum_zero</code></td>
<td>
<p>Optional <code>Logical</code> value specifying if the QTL effect of
a parental or an ancestral model should be caculated using the sum to zero
constraint. Default = FALSE.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_threshold">threshold</code></td>
<td>
<p><code>Numeric</code> value representing the -log10(p-value)
threshold above which a position can be considered as significant.
Default = 4.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> distance (cM) on the left and the right of a
cofactor position where it is not included in the model. Default = 30.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_backward">backward</code></td>
<td>
<p><code>Logical</code> value. If <code>backward = TRUE</code>,
the function performs
a backward elimination on the list of selected QTLs. Default = TRUE.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_alpha.bk">alpha.bk</code></td>
<td>
<p><code>Numeric</code> value indicating the significance level for
the backward elimination. Default = 0.05.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_plot.qprof">plot.Qprof</code></td>
<td>
<p><code>Logical</code> value. If <code>plot = TRUE</code>,
the function will plot the QTL profile last run of the forward regression.
Default = FALSE.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_plot.gen.eff">plot.gen.eff</code></td>
<td>
<p><code>Logical</code> value. If <code>plot.gen.eff = TRUE</code>,
the function will save the decomposed genetic effects per cross/parent.
These results can be ploted with the function <code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>
to visualize a genome-wide decomposition of the genetic effects. This
plot will be realized on the last run of the forward regression.
<strong>This functionality is ony available for the cross-specific,
parental and ancestral models.</strong>
Default value = FALSE.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_ci">CI</code></td>
<td>
<p><code>Logical</code> value. If <code>CI = TRUE</code>, the function will
compute a -log10(pval) drop confidence interval for each QTL using
the QTL profile of the last iteration. Default = FALSE.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_drop">drop</code></td>
<td>
<p><code>Numeric</code> -log10(p-value) drop value at the limits of the
interval. Default = 1.5.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_text.size">text.size</code></td>
<td>
<p><code>Numeric</code> value specifying the size of graph axis text
elements. Default = 18.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value indicating if the steps of the procedure
should be printed. Default = TRUE.</p>
</td></tr>
<tr><td><code id="mpp_forward_+3A_output.loc">output.loc</code></td>
<td>
<p>Path where a folder will be created to save the results.
By default the function uses the current working directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function run a full MPP QTL detection using models with different possible
assumptions concerning the number of alleles at the QTL position. For more details about
the different models, see documentation of the function <code><a href="#topic+mpp_SIM">mpp_SIM</a></code>.
The procedure is the following:
</p>

<ol>
<li><p>Forward regression to determine the a multi-QTL model. The function
selects successively QTL positions with -log10(pval) above the threshold.
Those positions are added as cofactors for following detection run.
The procedure stop when no more position has a -log10(pval) above the
threshold (<code><a href="#topic+QTL_forward">QTL_forward</a></code>).
</p>
</li>
<li><p>If <code>backward = TRUE</code>, backward elimination  on the final
list of detected QTLs. 
</p>
</li>
<li><p>Estimation of the QTL genetic effects and R squared statistics
(<code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code> and <code><a href="#topic+QTL_R2">QTL_R2</a></code>).
</p>
</li>
<li><p>If <code>CI = TRUE</code>, confidence interval calculation  
based on a CIM- (composite interval mapping removing all cofactors on the
scanned chromosome) of the last run of the forward regression.
</p>
</li>
<li><p>If <code>plot.Qprof = TRUE</code>, plot  of the last run of the forward
regression using <code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>.
</p>
</li>
<li><p>If <code>plot.gen.eff = TRUE</code>, plot of the genetic effect distribution
along the genome of the last run of the forward regression using
<code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>.
</p>
</li></ol>



<h3>Value</h3>

<p>Return:
</p>
<p>List containing the following items:
</p>
<table>
<tr><td><code>n.QTL</code></td>
<td>
<p>Number of detected QTLs.</p>
</td></tr>
<tr><td><code>QTL</code></td>
<td>
<p><code>Data.frame</code> with QTL positions.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p><code>List</code> containing R squared statistics of the QTL effects.
For details see <code><a href="#topic+QTL_R2">QTL_R2</a></code> output section.</p>
</td></tr>
<tr><td><code>QTL.effects</code></td>
<td>
<p><code>List</code> of QTLs genetic effects. For details see
<code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code> output section.</p>
</td></tr>
<tr><td><code>QTL.CI</code></td>
<td>
<p>If <code>CI = TRUE</code>, confidence interval information of
the QTLs.</p>
</td></tr>
</table>
<p>Some output files are also saved at the specified location
(<code>output.loc</code>):
</p>

<ol>
<li><p>A QTL report (QTL_REPORT.txt) with: 1) the number of detected QTLs;
2) the global R squared statistics; 3) for each QTL, position information
(plus confidence interval if <code>CI = TRUE</code>) and estimated QTL genetic
effects per cross or parents (for details see <code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code>).
</p>
</li>
<li><p>The list of QTL (QTL.txt).
</p>
</li>
<li><p>The QTL R squared statistics (QTL_R2.txt) (for details see
<code><a href="#topic+QTL_R2">QTL_R2</a></code>).
</p>
</li>
<li><p>If <code>CI = TRUE</code>, the QTL confidence intervals (QTL_CI.txt).
</p>
</li>
<li><p>General results of the QTL detection process: number of QTLs and
global adjusted and non-adjusted R squared statistics (QTL_genResults.txt).
</p>
</li>
<li><p>If <code>plot.Qprof = TRUE</code>, the plot of the last regression run
(QTL_profile.pdf). If <code>plot.gen.eff = TRUE</code>, plot of the genetic
effects per cross or parents (gen_eff.pdf) with dashed lines representing
the QTL positions. For more details see <code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_SIM">mpp_SIM</a></code>, <code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>,
<code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code>, <code><a href="#topic+QTL_forward">QTL_forward</a></code>, <code><a href="#topic+QTL_R2">QTL_R2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(mppData)

# Specify a location where your results will be saved
my.loc &lt;- "C:/.../..."

# Cross-specific model

USNAM_cr &lt;- mpp_forward(pop.name = "USNAM", trait.name = "ULA",
                        mppData = mppData, plot.gen.eff = TRUE,
                        plot.Qprof = TRUE, CI = TRUE, output.loc = my.loc)



## End(Not run)

</code></pre>

<hr>
<h2 id='mpp_perm'>QTL significance threshold by permutation</h2><span id='topic+mpp_perm'></span>

<h3>Description</h3>

<p>Determination of an empirical null distribution of the QTL significance
threshold for a MPP QTL analysis using permutation test
(Churchill and Doerge, 1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpp_perm(
  mppData,
  trait = 1,
  Q.eff = "cr",
  N = 1000,
  q.val = 0.95,
  verbose = TRUE,
  n.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpp_perm_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mpp_perm_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_perm_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effects: 1) &quot;cr&quot; for cross-specific; 2) &quot;par&quot; for parental; 3) &quot;anc&quot;
for ancestral; 4) &quot;biall&quot; for a bi-allelic. For more details see
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="mpp_perm_+3A_n">N</code></td>
<td>
<p>Number of permutations. Default = 1000.</p>
</td></tr>
<tr><td><code id="mpp_perm_+3A_q.val">q.val</code></td>
<td>
<p>Single <code>numeric</code> value or vector of desired quantiles from
the null distribution. Default = 0.95.</p>
</td></tr>
<tr><td><code id="mpp_perm_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value indicating if progression of the function
should be printed. It will not affect the printing of the other functions
called by <code>mpp_perm()</code>, especially the printing of <code>asreml()</code>.
Default = TRUE.</p>
</td></tr>
<tr><td><code id="mpp_perm_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs N permutations of the trait data and
computes each time a genome-wide QTL profile. For every run, it stores the
highest -log10(p-val). These values can be used to build a null distribution
for the QTL significance threshold. Quantile values can be determined from
the previous distribution. For more details about the different possible
models and their assumptions see <code><a href="#topic+mpp_SIM">mpp_SIM</a></code> documentation.
</p>


<h3>Value</h3>

<p>Return:
</p>
<p><code>List</code> with the following object:
</p>
<table>
<tr><td><code>max.pval</code></td>
<td>
<p>Vector of the highest genome-wide -log10(p-values).</p>
</td></tr>
<tr><td><code>q.val</code></td>
<td>
<p>Quantile values from the QTL significance threshold null
distribution.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p><code>Numeric</code> vector of random generated seed values for each
permutation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Churchill, G. A., &amp; Doerge, R. W. (1994). Empirical threshold values for
quantitative trait mapping. Genetics, 138(3), 963-971.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_SIM">mpp_SIM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

Perm &lt;- mpp_perm(mppData = mppData, Q.eff = "cr", N = 5)


</code></pre>

<hr>
<h2 id='mpp_proc'>MPP QTL analysis</h2><span id='topic+mpp_proc'></span>

<h3>Description</h3>

<p>Multi-parent population QTL analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpp_proc(
  pop.name = "MPP",
  trait.name = "trait1",
  mppData,
  trait = 1,
  Q.eff = "cr",
  plot.gen.eff = FALSE,
  thre.cof = 3,
  win.cof = 50,
  N.cim = 1,
  window = 20,
  thre.QTL = 3,
  win.QTL = 20,
  backward = TRUE,
  alpha.bk = 0.05,
  ref.par = NULL,
  sum_zero = FALSE,
  CI = FALSE,
  drop = 1.5,
  text.size = 18,
  n.cores = 1,
  verbose = TRUE,
  output.loc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpp_proc_+3A_pop.name">pop.name</code></td>
<td>
<p><code>Character</code> name of the studied population.
Default = &quot;MPP&quot;.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_trait.name">trait.name</code></td>
<td>
<p><code>Character</code> name of the studied trait.
Default = &quot;trait1&quot;.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effect: 1) &quot;cr&quot; for cross-specific effects; 2) &quot;par&quot; parental
effects; 3) &quot;anc&quot; for an ancestral effects; 4) &quot;biall&quot; for a bi-allelic
effects. For more details see <code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_plot.gen.eff">plot.gen.eff</code></td>
<td>
<p><code>Logical</code> value. If <code>plot.gen.eff = TRUE</code>,
the function will save the decomposed genetic effects per cross/parent.
These results can be plotted with the function <code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>
to visualize a genome-wide decomposition of the genetic effects.
<strong>This functionality is ony available for the cross-specific,
parental and ancestral models.</strong>
Default value = FALSE.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_thre.cof">thre.cof</code></td>
<td>
<p><code>Numeric</code> value representing the -log10(p-value)
threshold above which a position can be peaked as a cofactor. Default = 3.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_win.cof">win.cof</code></td>
<td>
<p><code>Numeric</code> value in centi-Morgan representing the minimum
distance between two selected cofactors. Default = 50.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_n.cim">N.cim</code></td>
<td>
<p><code>Numeric</code> value specifying the number of time the CIM
analysis is repeated. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> distance (cM) on the left and the right of a
cofactor position where it is not included in the model. Default = 20.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_thre.qtl">thre.QTL</code></td>
<td>
<p><code>Numeric</code> value representing the -log10(p-value)
threshold above which a position can be selected as QTL. Default = 3.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_win.qtl">win.QTL</code></td>
<td>
<p><code>Numeric</code> value in centi-Morgan representing the minimum
distance between two selected QTLs. Default = 20.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_backward">backward</code></td>
<td>
<p><code>Logical</code> value. If <code>backward = TRUE</code>,
the function performs a backward elimination on the list of selected QTLs.
Default = TRUE.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_alpha.bk">alpha.bk</code></td>
<td>
<p><code>Numeric</code> value indicating the significance level for
the backward elimination. Terms with p-values above this value will
iteratively be removed. Default = 0.05.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_ref.par">ref.par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference to compute QTL effects for the parental
model. For the ancestral model, the ancestral class containing the reference
parent will be set as reference. <strong>This option can only be used if
the MPP design is composed of a unique connected part</strong>. Default = NULL.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_sum_zero">sum_zero</code></td>
<td>
<p>Optional <code>Logical</code> value specifying if the QTL effect of
a parental or an ancestral model should be calculated using the sum to zero
constraint. Default = FALSE.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_ci">CI</code></td>
<td>
<p><code>Logical</code> value. If <code>CI = TRUE</code>, the function will
compute a -log10(pval) drop confidence interval for each QTL after
calculating a CIM- profile (without cofactors on the scanned chromosome).
Default = FALSE.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_drop">drop</code></td>
<td>
<p><code>Numeric</code> -log10(p-value) drop value at the limits of the
interval. Default = 1.5.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_text.size">text.size</code></td>
<td>
<p><code>Numeric</code> value specifying the size of graph axis text
elements. Default = 18.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value indicating if the steps of mpp_proc should
be printed. Default = TRUE.</p>
</td></tr>
<tr><td><code id="mpp_proc_+3A_output.loc">output.loc</code></td>
<td>
<p>Path where a folder will be created to save the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function run a full MPP QTL detection using models with different possible
assumptions concerning the number of alleles at the QTL position. For more
details about the different models, see documentation of the function
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. The procedure is the following:
</p>

<ol>
<li><p>Simple interval mapping (SIM) to select cofactor
(<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>).
</p>
</li>
<li><p>Composite interval mapping (CIM) with selected cofactors
(<code><a href="#topic+mpp_CIM">mpp_CIM</a></code>).
</p>
</li>
<li><p>Optional backward elimination on the list of QTL
candidates (<code>backward = TRUE</code>) (<code><a href="#topic+mpp_back_elim">mpp_back_elim</a></code>).
</p>
</li>
<li><p>Computation of the QTL genetic effects (<code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code>)
and proportion of the phenotypic variation explained by the QTLs (R squared)
(<code><a href="#topic+QTL_R2">QTL_R2</a></code>).
</p>
</li>
<li><p>Optional QTL confidence interval computation from a CIM- profile
(excluding cofactors on the scanned chromosome) (<code>argument CI=TRUE</code>).
</p>
</li></ol>



<h3>Value</h3>

<p>Return:
</p>
<p>List containing the following items:
</p>
<table>
<tr><td><code>n.QTL</code></td>
<td>
<p>Number of detected QTLs.</p>
</td></tr>
<tr><td><code>cofactors</code></td>
<td>
<p><code>Data.frame</code> with cofactors positions.</p>
</td></tr>
<tr><td><code>QTL</code></td>
<td>
<p><code>Data.frame</code> with QTL positions.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p><code>List</code> containing R squared statistics of the QTL effects.
For details see <code><a href="#topic+QTL_R2">QTL_R2</a></code> output section.</p>
</td></tr>
<tr><td><code>QTL.effects</code></td>
<td>
<p><code>List</code> of QTLs genetic effects. For details see
<code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code> output section.</p>
</td></tr>
<tr><td><code>QTL.CI</code></td>
<td>
<p>If <code>CI = TRUE</code>, confidence interval information of
the QTLs.</p>
</td></tr>
</table>
<p>Some output files are also saved at the specified location
(<code>output.loc</code>):
</p>

<ol>
<li><p>A QTL report (QTL_REPORT.txt) with: 1) the number of detected QTLs;
2) the global R squared statistics; 3) for each QTL, position information
(plus confidence interval if <code>CI = TRUE</code>) and estimated QTL genetic
effects per cross or parents (for details see <code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code>).
</p>
</li>
<li><p>The SIM and CIM results in a text file (SIM.txt, CIM.txt).
</p>
</li>
<li><p>The list of cofactors (cofactors.txt).
</p>
</li>
<li><p>The list of QTL (QTL.txt).
</p>
</li>
<li><p>The QTL R squared statistics (QTL_R2.txt) (for details see
<code><a href="#topic+QTL_R2">QTL_R2</a></code>).
</p>
</li>
<li><p>If <code>CI = TRUE</code>, the QTL confidence intervals (QTL_CI.txt).
</p>
</li>
<li><p>General results of the QTL detection process: number of QTLs and
global adjusted and non-adjusted R squared statistics (QTL_genResults.txt).
</p>
</li>
<li><p>The plot of the CIM profile (QTL_profile.pdf) with dotted vertical
lines representing the cofactors positions. If <code>plot.gen.eff = TRUE</code>,
plot of the genetic effects per cross or parents (gen_eff.pdf) with dashed
lines representing the QTL positions. For more details see
<code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_back_elim">mpp_back_elim</a></code>,
<code><a href="#topic+mpp_CIM">mpp_CIM</a></code>,
<code><a href="#topic+mpp_perm">mpp_perm</a></code>,
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>,
<code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>,
<code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code>,
<code><a href="#topic+QTL_R2">QTL_R2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

data(mppData)

# Specify a location where your results will be saved
my.loc &lt;- tempdir()

# Cross-specific model

USNAM_cr &lt;- mpp_proc(pop.name = "USNAM", trait.name = "ULA",
                     mppData = mppData, plot.gen.eff = TRUE, CI = TRUE,
                     verbose = FALSE, output.loc = my.loc)




</code></pre>

<hr>
<h2 id='mpp_SIM'>MPP Simple Interval Mapping</h2><span id='topic+mpp_SIM'></span>

<h3>Description</h3>

<p>Computes single QTL models along the genome using different models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpp_SIM(mppData, trait = 1, Q.eff = "cr", plot.gen.eff = FALSE, n.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpp_SIM_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mpp_SIM_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="mpp_SIM_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effects: 1) &quot;cr&quot; for cross-specific; 2) &quot;par&quot; for parental; 3) &quot;anc&quot;
for ancestral; 4) &quot;biall&quot; for a bi-allelic. For more details see
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="mpp_SIM_+3A_plot.gen.eff">plot.gen.eff</code></td>
<td>
<p><code>Logical</code> value. If <code>plot.gen.eff = TRUE</code>,
the function will save the decomposed genetic effects per cross/parent.
These results can be plotted with the function <code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>
to visualize a genome-wide decomposition of the genetic effects.
<strong>This functionality is ony available for the cross-specific,
parental and ancestral models.</strong>
Default value = FALSE.</p>
</td></tr>
<tr><td><code id="mpp_SIM_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented models vary according to the number of alleles assumed at the
QTL position and their origin. Four assumptions for the QTL effect are
possible.
</p>
<p>Concerning the type of QTL effect, the first option is a cross-specific QTL
effects model (<code>Q.eff = "cr"</code>). In this model, the QTL effects are
assumed to be nested within cross which leads to the estimation of one
parameter per cross. The cross-specific model corresponds to the
disconnected model described in Blanc et al. 2006.
</p>
<p>A second possibility is the parental model (<code>Q.eff = "par"</code>). The
parental model assumes one QTL effect (allele) per parent that are independent
from the genetic background. This means that QTL coming form parent i has the
same effect in all crosses where this parent is used. This model is supposed
to produce better estimates of the QTL due to larger sample size when parents
are shared between crosses.
</p>
<p>In a connected MPP (<code><a href="#topic+design_connectivity">design_connectivity</a></code>), if np - 1 &lt; nc, where
np is the number of parents and nc the number of crosses, the parental model
should be more powerful than the cross-specific model because it estimate
a reduced number of QTL parameters. This gain in power will be only true if
the assumption of constant parental effect through crosses holds. Calculated
with HRT assumption, the parental model corresponds to the connected model
presented in Blanc et al. (2006).
</p>
<p>The third type of model is the ancestral model (<code>Q.eff = "anc"</code>). This
model tries to use genetic relatedness that could exist between parents.
Indeed, the parental model assumes that parent are independent which is not
the case. Using genetic relatedness between the parents, it is possible group
these parents into a reduced number of ancestral cluster. Parents belonging
to the same ancestral group are assumed to transmit the same allele
(Jansen et al. 2003; Leroux et al. 2014). The ancestral model estimate
therefore one QTL effect
per ancestral class. Once again, the theoretical expectation is a gain of
QTL detection power by the reduction of the number of parameters to estimate.
The HRT ancestral model correspond to the linkage desequilibrium
linkage analysis (LDLA) models used by Bardol et al. (2013) or
Giraud et al. (2014).
</p>
<p>The final possibility is the bi-allelic model (<code>Q.eff = "biall"</code>).
Bi-allelic genetic predictor are a single vector with value 0, 1 or 2
corresponding to the number of allele copy of the least frequent SNP allele.
Relatedness between lines is therefore defined via identical by state (IBS)
measurement. This model corresponds to models used for association mapping.
For example, it is similar to model B in Wurschum et al. (2012) or
association mapping model in Liu et al. (2012).
</p>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>SIM</code></td>
<td>
<p><code>Data.frame</code> of class <code>QTLprof</code>. with five columns :
1) QTL marker names; 2) chromosomes;
3) interger position indicators on the chromosome;
4) positions in centi-Morgan; and 5) -log10(p-val). And if
<code>plot.gen.eff = TRUE</code>, p-values of the cross or parental QTL effects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Bardol, N., Ventelon, M., Mangin, B., Jasson, S., Loywick, V., Couton, F., ...
&amp; Moreau, L. (2013). Combined linkage and linkage disequilibrium QTL mapping 
in multiple families of maize (Zea mays L.) line crosses highlights
complementarities between models based on parental haplotype and single locus
polymorphism. Theoretical and applied genetics, 126(11), 2717-2736.
</p>
<p>Blanc, G., Charcosset, A., Mangin, B., Gallais, A., &amp; Moreau, L. (2006).
Connected populations for detecting quantitative trait loci and testing for
epistasis: an application in maize. Theoretical and Applied Genetics,
113(2), 206-224. 
</p>
<p>Giraud, H., Lehermeier, C., Bauer, E., Falque, M., Segura, V., Bauland,
C., ... &amp; Moreau, L. (2014). Linkage Disequilibrium with Linkage Analysis
of Multiline Crosses Reveals Different Multiallelic QTL for Hybrid
Performance in the Flint and Dent Heterotic Groups of Maize. Genetics,
198(4), 1717-1734.
</p>
<p>Jansen, R. C., Jannink, J. L., &amp; Beavis, W. D. (2003). Mapping quantitative
trait loci in plant breeding populations. Crop Science, 43(3), 829-834.
</p>
<p>Leroux, D., Rahmani, A., Jasson, S., Ventelon, M., Louis, F., Moreau, L.,
&amp; Mangin, B. (2014). Clusthaplo: a plug-in for MCQTL to enhance QTL detection
using ancestral alleles in multi-cross design. Theoretical and Applied
Genetics, 127(4), 921-933.
</p>
<p>Liu, W., Reif, J. C., Ranc, N., Della Porta, G., &amp; Wurschum, T. (2012).
Comparison of biometrical approaches for QTL detection in multiple
segregating families. Theoretical and Applied Genetics, 125(5), 987-998.
</p>
<p>Meuwissen T and Luo, Z. (1992). Computing inbreeding coefficients in large
populations. Genetics Selection Evolution, 24(4), 305-313.
</p>
<p>Wurschum, T., Liu, W., Gowda, M., Maurer, H. P., Fischer, S., Schechert, A.,
&amp; Reif, J. C. (2012). Comparison of biometrical models for joint linkage
association mapping. Heredity, 108(3), 332-340.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.QTLprof">plot.QTLprof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Cross-specific model
######################

data(mppData)

SIM &lt;- mpp_SIM(mppData = mppData, Q.eff = "cr", plot.gen.eff = TRUE)

plot(x = SIM)  
plot(x = SIM, gen.eff = TRUE, mppData = mppData, Q.eff = "cr")


# Bi-allelic model
##################

SIM &lt;- mpp_SIM(mppData = mppData, Q.eff = "biall")

plot(x = SIM, type = "h")

</code></pre>

<hr>
<h2 id='mppData'>
Complete <code>mppData</code> object
</h2><span id='topic+mppData'></span>

<h3>Description</h3>

<p>Complete <code>mppData</code> object made from a sample data of the maize US nested
association mapping (NAM) population. This mppData object went through all
the steps of the data processing: <code><a href="#topic+create.mppData">create.mppData</a></code>,
<code><a href="#topic+QC.mppData">QC.mppData</a></code>, <code><a href="#topic+IBS.mppData">IBS.mppData</a></code>, <code><a href="#topic+IBD.mppData">IBD.mppData</a></code>, <code><a href="#topic+parent_cluster.mppData">parent_cluster.mppData</a></code>. The mppData contain all the data
necessary for the QTL analysis procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mppData)</code></pre>


<h3>Format</h3>

<p><code>mppData</code>
</p>


<h3>Details</h3>

<p>The complete <code>mppData</code> object is a <code>list</code> containing the following
elements:
</p>

<ol>
<li><p>geno.IBS: IBS genotype marker matrix.
</p>
</li>
<li><p>geno.IBD: R/qtl cross.object containing the genotype within cross IBD probabilities.
</p>
</li>
<li><p>geno.id: List of genotypes.
</p>
</li>
<li><p>allele.ref: Matrix containing for each marker the most and least frequent marker scores and the two heterozygous scores.
</p>
</li>
<li><p>geno.par: Parents marker matrix.
</p>
</li>
<li><p>geno.par.clu: Parent marker data used to cluster the parents.
</p>
</li>
<li><p>par.clu: Parent clustering results.
</p>
</li>
<li><p>mono.anc: Positions for which the ancestral clustering was monomorphic.
</p>
</li>
<li><p>pheno: Phenotypic trait matrix.
</p>
</li>
<li><p>map: Genetic map corresponding to the geno (IBS, IBD, par) arguments.
</p>
</li>
<li><p>haplo.map: Genetic map corresponding to geno.par.clu.
</p>
</li>
<li><p>cross.ind: Vector indicating to which cross each genotype belongs.
</p>
</li>
<li><p>par.per.cross: Matrix with for each cross the parent 1 and 2.
</p>
</li>
<li><p>parents: Vector of parents.
</p>
</li>
<li><p>type: Type of population.
</p>
</li>
<li><p>n.cr: Number of crosses.
</p>
</li>
<li><p>n.par: Number of parents.
</p>
</li>
<li><p>n.anc: Average number of ancestral group along the genome.
</p>
</li>
<li><p>n.zigo: Number of possible allelic computations 2 (AA/BB) or 3 (AA/AB/BB).
</p>
</li>
<li><p>rem.mk: Removed markers in the data processing.
</p>
</li>
<li><p>rem.gen: Removed genotypes in the data processing.
</p>
</li>
<li><p>status: Indicates the level of progression in the data processing.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+create.mppData">create.mppData</a></code>, <code><a href="#topic+QC.mppData">QC.mppData</a></code>,
<code><a href="#topic+IBS.mppData">IBS.mppData</a></code>, <code><a href="#topic+IBD.mppData">IBD.mppData</a></code>,
<code><a href="#topic+parent_cluster.mppData">parent_cluster.mppData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mppData)
</code></pre>

<hr>
<h2 id='mppData_add_pheno'>Add new phenotypic values to a mppData object</h2><span id='topic+mppData_add_pheno'></span>

<h3>Description</h3>

<p>Add the new phenotypic values contained in 'pheno' to a <code>mppData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mppData_add_pheno(mppData, pheno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mppData_add_pheno_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mppData_add_pheno_+3A_pheno">pheno</code></td>
<td>
<p><code>data.frame</code> with : 1) <code>character</code>
genotypes identifiers; 2) <code>numeric</code> trait values. <strong>The genotypes
identifiers must be identical to <code>mppData$geno.id</code>.</strong></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>mppData</code></td>
<td>
<p>New <code>mppData</code> object with new phenotypic values added.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppData_mdf_pheno">mppData_mdf_pheno</a></code>, <code><a href="#topic+subset.mppData">subset.mppData</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)
pheno_new &lt;- data.frame(geno.id = mppData$geno.id, ph1 = rnorm(498))

mppData &lt;- mppData_add_pheno(mppData = mppData, pheno = pheno_new)

</code></pre>

<hr>
<h2 id='mppData_GE'>
Example <code>mppData</code> object
</h2><span id='topic+mppData_GE'></span>

<h3>Description</h3>

<p>Example <code>mppData</code> object representing a subset from the maize EU-NAM Flint
population (Bauer et al. 2013, Lehermeier et al. 2014, Giraud et al. 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mppData_GE)</code></pre>


<h3>Format</h3>

<p><code>mppData</code>
</p>


<h3>Details</h3>

<p>Sample data from the maize EU-NAM Flint population. The genotype data were
obtained from http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE50558.
The genotypes come from the five following crosses: (UH007 x D152),
(UH007 x F03802), (UH007 x F2), (UH007 x F283), and (UH007 x DK105). We selected
100 markers randomly spread on chromosomes five and six. The genetic map was
downloaded here http://maizegdb.org/data_center/reference?id=9024747.
</p>
<p>The phenotypic data represent the within environment adjusted means for dry
matter yield (DMY) calculated at La Coruna (CIAM), at Roggenstein (TUM), at
Einbeck (KWS), and at Ploudaniel (INRA_P). The raw plot data were obtained
here: http://www.genetics.org/content/198/1/3/suppl/DC1.
</p>


<h3>References</h3>

<p>Bauer, E., Falque, M., Walter, H., Bauland, C., Camisan, C., Campo, L., ...
&amp; Altmann, T. (2013). Intraspecific variation of recombination rate in maize.
Genome biology, 14(9), R103.
</p>
<p>Giraud, H., Lehermeier, C., Bauer, E., Falque, M., Segura, V., Bauland, C., ... &amp; Schipprack, W. (2014). Linkage disequilibrium with linkage analysis of multiline
crosses reveals different multiallelic QTL for hybrid performance in the flint
and dent heterotic groups of maize. Genetics, 198(4), 1717-1734.
</p>
<p>Lehermeier, C., Krämer, N., Bauer, E., Bauland, C., Camisan, C., Campo, L.,
... &amp; Moreau, L. (2014). Usefulness of multiparental populations of maize
(Zea mays L.) for genome-based prediction. Genetics, 198(1), 3-16.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mppData_GE)
</code></pre>

<hr>
<h2 id='mppData_init'>
<code>mppData</code> object with raw data
</h2><span id='topic+mppData_init'></span>

<h3>Description</h3>

<p><code>mppData</code> object with raw genotypic and phenotypic data of a sample of the maize US nested association mapping (NAM) population. Different operations
of quality control and data processing still need to be performed before
the QTL detection analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mppData_init)</code></pre>


<h3>Format</h3>

<p><code>mppData</code>
</p>


<h3>Details</h3>

<p>see examples of the <code><a href="#topic+create.mppData">create.mppData</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.mppData">create.mppData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mppData_init)
</code></pre>

<hr>
<h2 id='mppData_mdf_pheno'>Modify the phenotypic values of a mppData object</h2><span id='topic+mppData_mdf_pheno'></span>

<h3>Description</h3>

<p>Modify the phenotypic values of a <code>mppData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mppData_mdf_pheno(mppData, pheno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mppData_mdf_pheno_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mppData_mdf_pheno_+3A_pheno">pheno</code></td>
<td>
<p>Two columns <code>data.frame</code> with : 1) <code>character</code>
genotypes identifiers; 2) <code>numeric</code> trait values. <strong>The genotypes
identifiers must be identical to <code>mppData$geno.id</code>. The trait value identifiers
must correspond to a trait already in the mppData object.</strong></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>mppData</code></td>
<td>
<p>New <code>mppData</code> object with modified phenotypic values added.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppData_add_pheno">mppData_add_pheno</a></code>, <code><a href="#topic+subset.mppData">subset.mppData</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)
pheno_new &lt;- data.frame(geno.id = mppData$geno.id, ULA = rnorm(498))

mppData &lt;- mppData_mdf_pheno(mppData = mppData, pheno = pheno_new)

</code></pre>

<hr>
<h2 id='mppGE_CIM'>MPP GxE Composite Interval Mapping</h2><span id='topic+mppGE_CIM'></span>

<h3>Description</h3>

<p>Computes multi-QTL models with cofactors along the genome using an approximate
mixed model computation. An initial variance covariance (VCOV) structure is
calculated using function from the <code>nlme</code> package. Then, this information
is used to estimate the QTL global and within parental effect significance using a
Wald test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mppGE_CIM(
  mppData,
  trait,
  VCOV = "UN",
  VCOV_data = "unique",
  cofactors = NULL,
  cof_red = FALSE,
  cof_pval_sign = 0.1,
  window = 20,
  ref_par = NULL,
  n.cores = 1,
  maxIter = 100,
  msMaxIter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mppGE_CIM_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_trait">trait</code></td>
<td>
<p><code>Character vector</code> specifying which traits (environments) should be used.</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_vcov">VCOV</code></td>
<td>
<p>VCOV <code>Character</code> expression defining the type of variance
covariance structure used. 'CS' for compound symmetry assuming a unique
genetic covariance between environments. 'CSE' for cross-specific within
environment error term. 'CS_CSE' for both compound symmetry plus
cross-specific within environment error term. 'UN' for unstructured
environmental variance covariance structure allowing a specific genotypic
covariance for each pair of environments. Default = 'UN'</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_vcov_data">VCOV_data</code></td>
<td>
<p><code>Character</code> specifying if the reference VCOV should
be formed  taking all cofactors into consideration (&quot;unique&quot;) or if different
VCOVs should be formed by removing the cofactor information that is too close
of a tested QTL position (&quot;minus_cof&quot;). Default = &quot;unique&quot;</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_cofactors">cofactors</code></td>
<td>
<p>Object of class <code>QTLlist</code> representing a list of
selected marker positions obtained with the function <code>QTL_select()</code> or
a vector of <code>character</code> marker positions names.
Default = NULL.</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_cof_red">cof_red</code></td>
<td>
<p><code>Logical</code> value specifying if the cofactor matrix should
be reduced by only keeping the significant allele by environment interaction.
Default = FALSE</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_cof_pval_sign">cof_pval_sign</code></td>
<td>
<p><code>Numeric</code> value specifying the p-value significance
of an allele by environment term to be kept in the model. Default = 0.1</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> distance (cM) on the left and the right of a
cofactor position where it is not included in the model. Default = 20.</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_ref_par">ref_par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference for the parental model. Default = NULL</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for the lme optimization algorithm.
Default = 100.</p>
</td></tr>
<tr><td><code id="mppGE_CIM_+3A_msmaxiter">msMaxIter</code></td>
<td>
<p>maximum number of iterations for the optimization step inside
the lme optimization. Default = 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated model is the following:
</p>
<p><code class="reqn">\underline{y}_{icj} = E_{j} + C_{cj} + \sum_{qc=1}^{n_{cof}} x_{i_{qc}p} + \beta_{pj} + x_{i_{q}p} * \beta_{pj} + \underline{GE}_{icj} + \underline{e}_{icj}</code>
</p>
<p>For further details see the vignette.
</p>
<p>It is possible to calculate one initial VCOV using a null model with all
the cofactors (<code>VCOV_data = "unique"</code>) or one VCOV per combination of
cofactors (<code>VCOV_data = "minus_cof"</code>). In the later case, the cofactor
that fall witin a distance of <code>window</code> on the left and right of a QTL
position is removed for the calculation of the initial VCOV. Therefore,
N_cof + 1 VCOV are calculated.
</p>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>CIM</code></td>
<td>
<p><code>Data.frame</code> of class <code>QTLprof</code>. with five columns :
1) QTL marker or in between position names; 2) chromosomes;
3) integer position indicators on the chromosome;
4) positions in centi-Morgan; and 5) -log10(p-val) of the global QTL effect
across environments 6) p-values of the within environment QTL effects
(one column per environment); and p-values of the within environment parental
QTL allelic effects (one column per parent environment combination).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Pinheiro J, Bates D, DebRoy S, Sarkar D, R Core Team (2021). nlme: Linear
and Nonlinear Mixed Effects Models_. R package version 3.1-152,
&lt;URL: https://CRAN.R-project.org/package=nlme&gt;.
</p>
<p><code><a href="#topic+mppGE_SIM">mppGE_SIM</a></code>,
<code><a href="#topic+mppGE_proc">mppGE_proc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData_GE)

cofactors &lt;- mppData_GE$map$mk.names[c(35, 61)]

CIM &lt;- mppGE_CIM(mppData = mppData_GE, trait = c('DMY_CIAM', 'DMY_TUM'),
                     cofactors = cofactors, window = 20)
                     
Qpos &lt;- QTL_select(CIM)
                      
plot(CIM)

plot_allele_eff_GE(mppData = mppData_GE, nEnv = 2, EnvNames = c('CIAM', 'TUM'),
                   Qprof = CIM, Q.eff = 'par', QTL = Qpos, text.size = 14)

</code></pre>

<hr>
<h2 id='mppGE_proc'>MPP GxE QTL analysis</h2><span id='topic+mppGE_proc'></span>

<h3>Description</h3>

<p>QTL detection in MPP characterized in multiple environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mppGE_proc(
  pop.name = "MPP",
  trait.name = "trait1",
  mppData,
  trait,
  EnvNames = NULL,
  VCOV = "UN",
  ref_par = NULL,
  VCOV_data = "unique",
  SIM_only = FALSE,
  thre.cof = 4,
  win.cof = 50,
  cof_red = FALSE,
  cof_pval_sign = 0.1,
  window = 20,
  thre.QTL = 4,
  win.QTL = 20,
  text.size = 18,
  n.cores = 1,
  maxIter = 100,
  msMaxIter = 100,
  verbose = TRUE,
  output.loc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mppGE_proc_+3A_pop.name">pop.name</code></td>
<td>
<p><code>Character</code> name of the studied population.
Default = &quot;MPP&quot;.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_trait.name">trait.name</code></td>
<td>
<p><code>Character</code> name of the studied trait.
Default = &quot;trait1&quot;.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_trait">trait</code></td>
<td>
<p><code>Character vector</code> specifying which traits (environments) should be used.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_envnames">EnvNames</code></td>
<td>
<p><code>character</code> expression indicating the environment or trait
labels. By default: Env_1, 2, 3, etc.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_vcov">VCOV</code></td>
<td>
<p>VCOV <code>Character</code> expression defining the type of variance
covariance structure used. 'CS' for compound symmetry assuming a unique
genetic covariance between environments. 'CSE' for cross-specific within
environment error term. 'CS_CSE' for both compound symmetry plus
cross-specific within environment error term. 'UN' for unstructured
environmental variance covariance structure allowing a specific genotypic
covariance for each pair of environments. Default = 'UN'</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_ref_par">ref_par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference for the parental model. Default = NULL</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_vcov_data">VCOV_data</code></td>
<td>
<p><code>Character</code> specifying if the reference VCOV of the
CIM profile computation should be formed  taking all cofactors into
consideration (&quot;unique&quot;) or if different VCOVs should be formed by removing
the cofactor information that is too close of a tested cofactor position
(&quot;minus_cof&quot;). Default = &quot;unique&quot;</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_sim_only">SIM_only</code></td>
<td>
<p><code>Logical</code> value specifying if the procedure should
only calculate a SIM profile (no CIM). This option can be used with
large dataset to save time. Default = FALSE</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_thre.cof">thre.cof</code></td>
<td>
<p><code>Numeric</code> value representing the -log10(p-value)
threshold above which a position can be selected as cofactor. Default = 4.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_win.cof">win.cof</code></td>
<td>
<p><code>Numeric</code> value in centi-Morgan representing the minimum
distance between two selected cofactors. Default = 50.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_cof_red">cof_red</code></td>
<td>
<p><code>Logical</code> value specifying if the cofactor matrix should
be reduced by only keeping the significant allele by environment interaction.
Default = FALSE</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_cof_pval_sign">cof_pval_sign</code></td>
<td>
<p><code>Numeric</code> value specifying the p-value significance
of an allele by environment term to be kept in the model. Default = 0.1</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> distance (cM) on the left and the right of a
cofactor position where it is not included in the model. Default = 20.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_thre.qtl">thre.QTL</code></td>
<td>
<p><code>Numeric</code> value representing the -log10(p-value)
threshold above which a position can be selected as QTL. Default = 4.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_win.qtl">win.QTL</code></td>
<td>
<p><code>Numeric</code> value in centi-Morgan representing the minimum
distance between two selected QTLs. Default = 20.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_text.size">text.size</code></td>
<td>
<p><code>Numeric</code> value specifying the size of graph axis text
elements. Default = 18.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for the lme optimization algorithm.
Default = 100.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_msmaxiter">msMaxIter</code></td>
<td>
<p>maximum number of iterations for the optimization step inside
the lme optimization. Default = 100.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value indicating if the steps of mpp_proc should
be printed. Default = TRUE.</p>
</td></tr>
<tr><td><code id="mppGE_proc_+3A_output.loc">output.loc</code></td>
<td>
<p>Path where a folder will be created to save the results.
Default = NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure is the following:
</p>

<ol>
<li><p>Simple interval mapping (SIM) to select cofactors
(<code><a href="#topic+mppGE_SIM">mppGE_SIM</a></code>).
</p>
</li>
<li><p>Composite interval mapping (CIM) with selected cofactors
(<code><a href="#topic+mppGE_CIM">mppGE_CIM</a></code>).
</p>
</li>
<li><p>Estimation of QTLs additive allelic effect
(<code><a href="#topic+QTL_effect_GE">QTL_effect_GE</a></code>).
</p>
</li>
<li><p>Estimation of the global QTLs effect R squared and individual QTL effect
R squared (<code><a href="#topic+QTL_R2_GE">QTL_R2_GE</a></code>).
</p>
</li></ol>



<h3>Value</h3>

<p>Return:
</p>
<p>List containing the following items:
</p>
<table>
<tr><td><code>n.QTL</code></td>
<td>
<p>Number of detected QTLs.</p>
</td></tr>
<tr><td><code>cofactors</code></td>
<td>
<p><code>Data.frame</code> with cofactors positions.</p>
</td></tr>
<tr><td><code>QTL</code></td>
<td>
<p><code>Data.frame</code> with QTL positions.</p>
</td></tr>
<tr><td><code>Q_eff</code></td>
<td>
<p><code>list</code> containing the estimated QTL allelic effects.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p><code>List</code> containing R squared statistics of the QTL effects</p>
</td></tr>
</table>
<p>Some output files are also saved at the specified location
(<code>output.loc</code>):
</p>

<ol>
<li><p>The SIM and CIM results in a RData file (SIM.RData, CIM.RData).
</p>
</li>
<li><p>The list of cofactors (cofactors.RData).
</p>
</li>
<li><p>The list of QTL (QTLs.RData).
</p>
</li>
<li><p>The list of QTL allelic effects (QTL_effects.RData).
</p>
</li>
<li><p>The QTL R squared statistics (QTL_R2.RData)
</p>
</li>
<li><p>The number of detected QTLs and adjusted R2 (Glb_res.RData)
</p>
</li>
<li><p>The plot of the CIM profile (QTL_profile.pdf) with dotted vertical
lines representing the cofactors positions and the
plot of the genetic effects per cross or parents obtained with
<code><a href="#topic+plot_allele_eff_GE">plot_allele_eff_GE</a></code> (gen_eff.pdf) with dashed
lines representing the QTL positions.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppGE_CIM">mppGE_CIM</a></code>,
<code><a href="#topic+mppGE_SIM">mppGE_SIM</a></code>,
<code><a href="#topic+QTL_effect_GE">QTL_effect_GE</a></code>,
<code><a href="#topic+QTL_R2_GE">QTL_R2_GE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(mppData_GE)

MPP_GE_QTL &lt;- mppGE_proc(pop.name = 'EUNAM', trait.name = 'DMY',
mppData = mppData_GE, trait = c('DMY_CIAM', 'DMY_TUM'),
n.cores = 1, output.loc = tempdir())


## End(Not run)

</code></pre>

<hr>
<h2 id='mppGE_SIM'>MPP GxE Simple Interval Mapping</h2><span id='topic+mppGE_SIM'></span>

<h3>Description</h3>

<p>Computes single QTL models along the genome using an approximate mixed model
computation. An initial variance covariance (VCOV) structure is calculated
using function from the <code>nlme</code> package. Then, this information is used
to estimate the QTL global and within parental effect significance using a
Wald test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mppGE_SIM(
  mppData,
  trait,
  VCOV = "UN",
  ref_par = NULL,
  n.cores = 1,
  maxIter = 100,
  msMaxIter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mppGE_SIM_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="mppGE_SIM_+3A_trait">trait</code></td>
<td>
<p><code>Character vector</code> specifying which traits (environments)
should be used.</p>
</td></tr>
<tr><td><code id="mppGE_SIM_+3A_vcov">VCOV</code></td>
<td>
<p>VCOV <code>Character</code> expression defining the type of variance
covariance structure used. 'CS' for compound symmetry assuming a unique
genetic covariance between environments. 'CSE' for cross-specific within
environment error term. 'CS_CSE' for both compound symmetry plus
cross-specific within environment error term. 'UN' for unstructured
environmental variance covariance structure allowing a specific genotypic
covariance for each pair of environments. Default = 'UN'</p>
</td></tr>
<tr><td><code id="mppGE_SIM_+3A_ref_par">ref_par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference for the parental model. Default = NULL</p>
</td></tr>
<tr><td><code id="mppGE_SIM_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
<tr><td><code id="mppGE_SIM_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for the lme optimization algorithm.
Default = 100.</p>
</td></tr>
<tr><td><code id="mppGE_SIM_+3A_msmaxiter">msMaxIter</code></td>
<td>
<p>maximum number of iterations for the optimization step inside
the lme optimization. Default = 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated model is the following:
</p>
<p><code class="reqn">\underline{y}_{icj} = E_{j} + C_{cj} + x_{i_{q}p} * \beta_{pj} + \underline{GE}_{icj} + \underline{e}_{icj}</code>
</p>
<p>For further details see the vignette.
</p>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>SIM</code></td>
<td>
<p><code>Data.frame</code> of class <code>QTLprof</code>. with five columns :
1) QTL marker or in between position names; 2) chromosomes;
3) integer position indicators on the chromosome;
4) positions in centi-Morgan; and 5) -log10(p-val) of the global QTL effect
across environments 6) p-values of the within environment QTL effects
(one column per environment); and p-values of the within environment parental
QTL allelic effects (one column per parent environment combination).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Pinheiro J, Bates D, DebRoy S, Sarkar D, R Core Team (2021). nlme: Linear
and Nonlinear Mixed Effects Models_. R package version 3.1-152,
&lt;URL: https://CRAN.R-project.org/package=nlme&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppGE_CIM">mppGE_CIM</a></code>,
<code><a href="#topic+mppGE_proc">mppGE_proc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData_GE)

SIM &lt;- mppGE_SIM(mppData = mppData_GE, trait = c('DMY_CIAM', 'DMY_TUM'))

Qpos &lt;- QTL_select(Qprof = SIM, threshold = 3, window = 50)

plot(x = SIM, QTL = Qpos)

plot_allele_eff_GE(mppData = mppData_GE, nEnv = 2, EnvNames = c('CIAM', 'TUM'),
                   Qprof = SIM, Q.eff = 'par', QTL = Qpos, text.size = 14)

</code></pre>

<hr>
<h2 id='MQE_gen_effects'>QTL genetic effects multi-QTL effect model</h2><span id='topic+MQE_gen_effects'></span>

<h3>Description</h3>

<p>Compute a multi-QTL model with a list of QTL candidates (<code>QTL</code>) and return
the decomposed QTL genetic effects per cross or per parents. The list of QTL
can be of different types (cross-specific, parental, ancestral or bi-allelic).
The type of QTL effects are specified in the vector <code>Q.eff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MQE_gen_effects(mppData = NULL, trait = 1, QTL = NULL, Q.eff, ref.par = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MQE_gen_effects_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code></p>
</td></tr>
<tr><td><code id="MQE_gen_effects_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="MQE_gen_effects_+3A_qtl">QTL</code></td>
<td>
<p>Vector of <code>character</code> markers positions
names. Default = NULL.</p>
</td></tr>
<tr><td><code id="MQE_gen_effects_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> vector indicating for each QTL position the
type of QTL effect among: &quot;cr&quot;, &quot;par&quot;, &quot;anc&quot; and &quot;biall&quot;. For details look at
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>.</p>
</td></tr>
<tr><td><code id="MQE_gen_effects_+3A_ref.par">ref.par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference for the parental model. For the
ancestral model, the ancestral class containing the reference parent will be
set as reference. <strong>This option can only be used if the MPP design is
composed of a unique connected part</strong>. Default = NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes for each QTL position the genetic effects of the
cross, parental, ancestral or SNP allele components. For the cross-specific
model (<code>Q.eff = "cr"</code>), the genetics effects represent the substitution
effect of an single allele from the parent 2 (or B) with respect to an allele
coming from the parent 1 or A. All effects are given in absolute value with
the parent that cary the positive allele.
</p>
<p>For the parental and the ancestral model (<code>Q.eff = "par" or "anc"</code>), the
reference allele is defined per interconneted part. The most frequent
parental (ancestral) allele is set as reference. Effects of the other alleles
are estimated as deviation with respect to the reference. For more details
about reference definition see <code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code> and
<code><a href="#topic+design_connectivity">design_connectivity</a></code>.
</p>
<p>For the bi-allelic model (<code>Q.eff = "biall"</code>), the genetic effects
represent the effects of a single allele copy of the least frequent allele.
</p>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p><code>List</code> of <code>data.frame</code> (one per QTL) containing the
following information:
</p>

<ol>
<li><p>QTL genetic effects per cross or parent.
</p>
</li>
<li><p>Standard error of the QTL effects.
</p>
</li>
<li><p>Test statistics of the effects (t-test or Wald statistic).
</p>
</li>
<li><p>P-value of the test statistics.
</p>
</li>
<li><p>Significance of the QTL effects.
</p>
</li>
<li><p>For cross-specific model, parent with the positive additive effects.
</p>
</li>
<li><p>For parental and ancestral model, indicator of connected part of the
design and reference.
</p>
</li>
<li><p>Allele scores of the parents if <code>geno.par</code> is non NULL
in the <code>mppData</code> object.
</p>
</li></ol>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MQE_proc">MQE_proc</a></code>, <code><a href="#topic+mpp_SIM">mpp_SIM</a></code>,
<code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code>, <code><a href="#topic+design_connectivity">design_connectivity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

SIM &lt;- mpp_SIM(mppData = mppData)
QTL &lt;- QTL_select(SIM)

QTL.eff &lt;- MQE_gen_effects(mppData = mppData, QTL = QTL[, 1],
                          Q.eff = c("anc", "par", "biall"))

</code></pre>

<hr>
<h2 id='MQE_proc'>Multi-QTL effect MPP analysis</h2><span id='topic+MQE_proc'></span>

<h3>Description</h3>

<p>Build multi-QTL effects (MQE) models in which different QTL effects
(cross-specific, parental, ancestral or bi-allelic) can be assumed at
different loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MQE_proc(
  pop.name = "MPP_MQE",
  trait.name = "trait1",
  mppData = NULL,
  trait = 1,
  Q.eff,
  ref.par = NULL,
  threshold = 4,
  window = 30,
  backward = TRUE,
  alpha.bk = 0.05,
  plot.MQE = FALSE,
  CI = FALSE,
  drop = 1.5,
  n.cores = 1,
  verbose = TRUE,
  output.loc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MQE_proc_+3A_pop.name">pop.name</code></td>
<td>
<p><code>Character</code> name of the studied population.
Default = &quot;MPP_MQE&quot;.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_trait.name">trait.name</code></td>
<td>
<p><code>Character</code> name of the studied trait.
Default = &quot;trait1&quot;.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> vector of possible QTL effects the user want to
test. Elements of <code>Q.eff</code> can be &quot;cr&quot;, &quot;par&quot;, &quot;anc&quot; or &quot;biall&quot;.
For details look at <code><a href="#topic+mpp_SIM">mpp_SIM</a></code>.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_ref.par">ref.par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference to calculate the allelic effects of 
the parental model. For the ancestral model, the ancestral class containing
the reference parent will be set as reference. <strong>This option can only
be used if the MPP design is composed of a unique connected part</strong>.
Default = NULL.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_threshold">threshold</code></td>
<td>
<p><code>Numeric</code> value representing the -log10(p-value)
threshold above which a position can be considered as significant.
Default = 4.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> distance (cM) on the left and the right of a
cofactor position where it is not included in the model. Default = 30.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_backward">backward</code></td>
<td>
<p><code>Logical</code> value. If <code>backward = TRUE</code>,
the function performs
a backward elimination on the list of selected QTLs. Default = TRUE.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_alpha.bk">alpha.bk</code></td>
<td>
<p><code>Numeric</code> value indicating the significance level for
the backward elimination. Default = 0.05.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_plot.mqe">plot.MQE</code></td>
<td>
<p><code>Logical</code> value. If <code>plot.MQE = TRUE</code>,
the function will plot the last run of the MQE model determination.
Default = FALSE.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_ci">CI</code></td>
<td>
<p><code>Logical</code> value. If <code>CI = TRUE</code>, the function will
compute a -log10(pval) drop confidence interval for each QTL using
the QTL profile of the last iteration. Default = FALSE.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_drop">drop</code></td>
<td>
<p><code>Numeric</code> -log10(p-value) drop value at the limits of the
interval. Default = 1.5.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value indicating if the steps of MQE_proc should
be printed. Default = TRUE.</p>
</td></tr>
<tr><td><code id="MQE_proc_+3A_output.loc">output.loc</code></td>
<td>
<p>Path where a folder will be created to save the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible QTL effect that the user wants to allow must be
specified in <code>Q.eff</code>. The procedure is the following:
</p>

<ol>
<li><p>Forward regression to determine a MQE model with different
possible assumptions for the QTL effect at different loci. The function
use.
</p>
</li>
<li><p>Optional backward elimination (<code>backward = TRUE</code>) on the final
list of detected QTLs. 
</p>
</li>
<li><p>Estimation of the QTL genetic effects and R squared statistics.
</p>
</li>
<li><p>If <code>plot.MQE = TRUE</code>, plot of the last CIM run of the
forward regression.
</p>
</li>
<li><p>If <code>CI = TRUE</code>, confidence interval calculation based on a
CIM- (CIM without cofactor on the selected chromosome) of the last run of the
forward regression.
</p>
</li></ol>



<h3>Value</h3>

<p>Return:
</p>
<p><code>List</code> containing the following items:
</p>
<table>
<tr><td><code>n.QTL</code></td>
<td>
<p>Number of detected QTLs.</p>
</td></tr>
<tr><td><code>QTL</code></td>
<td>
<p><code>Data.frame</code> with QTL positions.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p><code>list</code> containing R squared statistics of the QTL effects.
for details see <code><a href="#topic+QTL_R2">QTL_R2</a></code>.</p>
</td></tr>
<tr><td><code>QTL.effects</code></td>
<td>
<p><code>List</code> of genetic effects per QTL.</p>
</td></tr>
<tr><td><code>QTL.CI</code></td>
<td>
<p>If <code>CI = TRUE</code>, confidence interval information of
the QTLs.</p>
</td></tr>
</table>
<p>Some output files are also saved at the location specified
(<code>output.loc</code>):
</p>

<ol>
<li><p>A QTL report (QTL_REPORT.txt) with: 1) the number of detected QTLs;
2) the global R squared statistics; 3) for each QTL, position information
and estimated QTL genetic effect per cross or parents.
</p>
</li>
<li><p>The list of QTLs (QTL.txt).
</p>
</li>
<li><p>The QTL R squared statistics (QTL_R2.txt) (for details see
<code><a href="#topic+QTL_R2">QTL_R2</a></code>).
</p>
</li>
<li><p>General results of the QTL detection process: Number of QTL and
global adjusted and non-adjusted R squared statistics. (QTL_genResults.txt).
</p>
</li>
<li><p>if <code>plot.MQE = TRUE</code>, a plot of the last QTL detection run profile
(plot_MQE.pdf).
</p>
</li>
<li><p>If <code>CI = TRUE</code>, the QTL confidence intervals (QTL_CI.txt).
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_SIM">mpp_SIM</a></code>, <code><a href="#topic+MQE_gen_effects">MQE_gen_effects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(mppData)

# Specify a location where your results will be saved
my.loc &lt;- tempdir()

MQE &lt;- MQE_proc(pop.name = "USNAM", trait.name = "ULA", mppData = mppData,
                Q.eff = c("par", "biall"), verbose = FALSE,
                output.loc = my.loc)
                 

## End(Not run)

</code></pre>

<hr>
<h2 id='par_clu'>
Parental clustering
</h2><span id='topic+par_clu'></span>

<h3>Description</h3>

<p>Example of parental clustering object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(par_clu)</code></pre>


<h3>Details</h3>

<p>The parent clustering matrix specifies at each genome position the results
of a parent clustering into ancestral groups. The matrix rows
represent the position and the columns correspond to each parent. For example,
if we have at the ith row (1, 2, 3, 2, 1), this means that parents 1
and 5 are in the same group, that 2 and 4 are in another one and that the
third parent was assigned to any group.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parent_cluster.mppData">parent_cluster.mppData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(par_clu)
</code></pre>

<hr>
<h2 id='parent_cluster.mppData'>Parent clustering for <code>mppData</code> objects</h2><span id='topic+parent_cluster.mppData'></span>

<h3>Description</h3>

<p>Integrate the parent clustering information to the mppData
object. The parent clustering is necessary to compute the ancestral model.
If the parent clustering step is skipped, the ancestral model can not be
used but the other models (cross-specific, parental, and bi-allelic) can
still be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parent_cluster.mppData(mppData, par.clu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parent_cluster.mppData_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>. the <code>mppData</code> must
have been processed using: <code><a href="#topic+create.mppData">create.mppData</a></code>,
<code><a href="#topic+QC.mppData">QC.mppData</a></code>, <code><a href="#topic+IBS.mppData">IBS.mppData</a></code>,
and <code><a href="#topic+IBD.mppData">IBD.mppData</a></code>.</p>
</td></tr>
<tr><td><code id="parent_cluster.mppData_+3A_par.clu">par.clu</code></td>
<td>
<p><code>Interger matrix</code> representing the results of a
parents genotypes clustering. The columns represent the parental lines and
the rows the markers. The columns names must be the same as the parents
list of the mppData object. The rownames must be the same as the map marker
list of the mppData object. At a particular position, parents with the same
value are assumed to inherit from the same ancestor. for more details,
see <code><a href="#topic+par_clu">par_clu</a></code>. Default = NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At a single marker position, two parents can be grouped into a similar
ancestral classes if we assume that they receive there allele from a common
ancestor. The parent clustering information (<code>par.clu</code>) describe parental
relatedness and which parent belong to which ancestral group. For example,
at marker i, we could have five parents (pA, pB, pC, pD, pE) and the following
clustering information (1, 2, 1, 2, 3). This means that pA and pC received
their allele from the same ancestor (A1). pB and pD also have a shared
ancestor (A2) who is different from (A1). And pE was not included in any
group and can be seen as an independent ancestral group (A3).
</p>
<p>The parent clustering information is provided via <code>par.clu</code>. It is an
<code>interger matrix</code> with markers in row and parents in columns.
At a particular marker position, parents with the same value are assumed to
inherit from the same ancestor. for more details, see <code><a href="#topic+par_clu">par_clu</a></code>.
</p>
<p>The marker positions that are considered as monomorphic given the parent
clustering information are set back to one allele per parent to still allow
the computation of the QTL allelic effect at those positions later.
</p>
<p>The parent clustering can be performed using the R package
'clusthaplo' that can be found there:
<a href="https://cran.r-project.org/src/contrib/Archive/clusthaplo/">https://cran.r-project.org/src/contrib/Archive/clusthaplo/</a>.
The 'clusthaplo' option is not integrated in this version of mppR. However,
a version of mppR with function calling clusthaplo can be found on github
<a href="https://github.com/vincentgarin/mppR">https://github.com/vincentgarin/mppR</a> (branch master).
</p>


<h3>Value</h3>

<p>An increased <code>mppData</code> object containing the the same elements
as the <code>mppData</code> object provided as argument and the
following new elements:
</p>
<table>
<tr><td><code>par.clu</code></td>
<td>
<p><code>Integer matrix</code> with rows representing markers and
columns corresponding to the parents. At a single marker position, parents
with the same value were clustered in the same ancestral group.</p>
</td></tr>
<tr><td><code>n.anc</code></td>
<td>
<p>Average number of ancestral clusters along the genome.</p>
</td></tr>
<tr><td><code>mono.anc</code></td>
<td>
<p>Positions for which the ancestral clustering was monomorphic.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.mppData">create.mppData</a></code>, <code><a href="#topic+QC.mppData">QC.mppData</a></code>,
<code><a href="#topic+IBS.mppData">IBS.mppData</a></code>, <code><a href="#topic+IBD.mppData">IBD.mppData</a></code>, <code><a href="#topic+par_clu">par_clu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData_init)
data(par_clu)

mppData &lt;- QC.mppData(mppData_init)
mppData &lt;- IBS.mppData(mppData = mppData)

mppData &lt;- IBD.mppData(mppData = mppData, type = 'RIL',
                       type.mating = 'selfing')
                       
mppData &lt;- parent_cluster.mppData(mppData = mppData, par.clu  = par_clu)                         
                       

</code></pre>

<hr>
<h2 id='plot_allele_eff_GE'>plot of genome wide QTL allelic effect significance</h2><span id='topic+plot_allele_eff_GE'></span>

<h3>Description</h3>

<p>Plot of the genome wide significance of the QTL allelic effects in multiple
environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_allele_eff_GE(
  mppData,
  nEnv,
  EnvNames,
  Qprof,
  Q.eff = "par",
  QTL = NULL,
  ref_par = NULL,
  main = "QTL genetic effects plot",
  text.size = 18
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_allele_eff_GE_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="plot_allele_eff_GE_+3A_nenv">nEnv</code></td>
<td>
<p><code>Numeric</code> number of environment or trait.</p>
</td></tr>
<tr><td><code id="plot_allele_eff_GE_+3A_envnames">EnvNames</code></td>
<td>
<p><code>character</code> expression indicating the environment or trait
labels.</p>
</td></tr>
<tr><td><code id="plot_allele_eff_GE_+3A_qprof">Qprof</code></td>
<td>
<p>object obtained with function <code><a href="#topic+mppGE_SIM">mppGE_SIM</a></code>,
<code><a href="#topic+mppGE_CIM">mppGE_CIM</a></code>,</p>
</td></tr>
<tr><td><code id="plot_allele_eff_GE_+3A_q.eff">Q.eff</code></td>
<td>
<p>one of &quot;cr&quot;, &quot;par&quot;, &quot;anc&quot; or &quot;biall&quot;. For the moment only &quot;par&quot;
is available.</p>
</td></tr>
<tr><td><code id="plot_allele_eff_GE_+3A_qtl">QTL</code></td>
<td>
<p>Optional argument. Object of class <code>QTLlist</code> representing a
list of selected position obtained with the function <code><a href="#topic+QTL_select">QTL_select</a></code>
or a vector of <code>character</code> marker or in between marker positions names.
These positions will be plotted on the graph. Default = NULL.</p>
</td></tr>
<tr><td><code id="plot_allele_eff_GE_+3A_ref_par">ref_par</code></td>
<td>
<p><code>Charater</code> specifying the reference parent. Default = NULL.</p>
</td></tr>
<tr><td><code id="plot_allele_eff_GE_+3A_main">main</code></td>
<td>
<p>Title of the graph. Default = &quot;QTL genetic effects plot&quot;.</p>
</td></tr>
<tr><td><code id="plot_allele_eff_GE_+3A_text.size">text.size</code></td>
<td>
<p><code>Numeric</code> value specifying the size of graph axis text
elements. Default = 18.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppGE_CIM">mppGE_CIM</a></code>, <code><a href="#topic+mppGE_SIM">mppGE_SIM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData_GE)

SIM &lt;- mppGE_SIM(mppData = mppData_GE, trait = c('DMY_CIAM', 'DMY_TUM'))

Qpos &lt;- QTL_select(Qprof = SIM, threshold = 3, window = 50)

plot_allele_eff_GE(mppData = mppData_GE, nEnv = 2, EnvNames = c('CIAM', 'TUM'),
                   Qprof = SIM, Q.eff = 'par', QTL = Qpos, text.size = 14)

</code></pre>

<hr>
<h2 id='plot_QxEC'>plot QTLxEC effect</h2><span id='topic+plot_QxEC'></span>

<h3>Description</h3>

<p>Plot allowing the visualization of the QTL parental allelic effect variation
given an environmental covariate (EC). The function plot the sensitivity
curve of the parent allelic effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_QxEC(
  Qeff,
  EC,
  env_id = NULL,
  QTL,
  sign_thre = 0.05,
  EC_id = "EC",
  trait_id = "trait",
  main = "QTLxEC",
  col_vec = NULL,
  text_size = 14
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_QxEC_+3A_qeff">Qeff</code></td>
<td>
<p>output from the function <code><a href="#topic+QTL_effect_main_QxEC">QTL_effect_main_QxEC</a></code>.</p>
</td></tr>
<tr><td><code id="plot_QxEC_+3A_ec">EC</code></td>
<td>
<p><code>Numeric</code> matrix containing the EC values of a single covariate
with environments as row and EC as column.</p>
</td></tr>
<tr><td><code id="plot_QxEC_+3A_env_id">env_id</code></td>
<td>
<p><code>Character</code> vector specifying the environment names.
By default, E1, ... En</p>
</td></tr>
<tr><td><code id="plot_QxEC_+3A_qtl">QTL</code></td>
<td>
<p><code>Numeric value</code> indicating which QTL to plot</p>
</td></tr>
<tr><td><code id="plot_QxEC_+3A_sign_thre">sign_thre</code></td>
<td>
<p><code>Numeric value</code> indicating the significance threshold for a
parent sensitivity slope to be ploted. Default = 0.05</p>
</td></tr>
<tr><td><code id="plot_QxEC_+3A_ec_id">EC_id</code></td>
<td>
<p><code>Character</code> string indicating the name of the environmental covariate.
Default = 'EC'.</p>
</td></tr>
<tr><td><code id="plot_QxEC_+3A_trait_id">trait_id</code></td>
<td>
<p><code>Character</code> string indicating the name of the trait.
Default = 'trait'.</p>
</td></tr>
<tr><td><code id="plot_QxEC_+3A_main">main</code></td>
<td>
<p><code>Character</code> string title of the plot. Default = 'QTLxEC'</p>
</td></tr>
<tr><td><code id="plot_QxEC_+3A_col_vec">col_vec</code></td>
<td>
<p><code>Character</code> vector specifying colors for the parent sensitivity lines.
Default = NULL</p>
</td></tr>
<tr><td><code id="plot_QxEC_+3A_text_size">text_size</code></td>
<td>
<p><code>Numerical</code> value specifying the size of the text in the plot.
Default = 14.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QTLxEC sensitivity plot
</p>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(mppData_GE)

Qpos &lt;- c("PZE.105068880", "PZE.106098900")

EC &lt;- matrix(c(180, 310, 240, 280), 4, 1)
rownames(EC) &lt;- c('CIAM', 'TUM', 'INRA', 'KWS')
colnames(EC) &lt;- 'cum_rain'

Qeff &lt;- QTL_effect_main_QxEC(mppData = mppData_GE,
                         trait = c('DMY_CIAM', 'DMY_TUM', 'DMY_INRA_P', 'DMY_KWS'),
                         env_id = c('CIAM', 'TUM', 'INRA', 'KWS'),
                         QTL = Qpos, EC = EC)

pl &lt;- plot_QxEC(Qeff, EC = EC, env_id = c('CIAM', 'TUM', 'INRA', 'KWS'), 
                QTL = 2, EC_id = 'cum rain', trait_id = 'DMY')


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.QTLprof'>plot QTL profile</h2><span id='topic+plot.QTLprof'></span>

<h3>Description</h3>

<p>Plots the -log10(p-val) profile of a QTL analysis or a genome-wide
genetic effect plot using package ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'QTLprof'
plot(
  x,
  gen.eff = FALSE,
  mppData,
  Q.eff,
  QTL = NULL,
  type = "l",
  main = "QTL profile",
  threshold = 3,
  text.size = 18,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.QTLprof_+3A_x">x</code></td>
<td>
<p>Object of class <code>QTLprof</code> returned by the function
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code> or <code><a href="#topic+mpp_CIM">mpp_CIM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.QTLprof_+3A_gen.eff">gen.eff</code></td>
<td>
<p><code>Logical</code>. Specify the type of plot.
If <code>gen.eff = FALSE</code>, standard QTL profile. If <code>gen.eff = TRUE</code>,
genome-wide genetic effect plot. In that case, the <code>QTLprof</code> object in
<code>x</code> must have been calculated with argument <code>plot.gen.eff = TRUE</code>.
Default = FALSE.</p>
</td></tr>
<tr><td><code id="plot.QTLprof_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>. Only required if
<code>gen.eff = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.QTLprof_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effects: 1) &quot;cr&quot; for cross-specific; 2) &quot;par&quot; for parental
effects; 3) &quot;anc&quot; for ancestral effects. Only required if
<code>gen.eff = TRUE</code></p>
</td></tr>
<tr><td><code id="plot.QTLprof_+3A_qtl">QTL</code></td>
<td>
<p>Optional argument. List of QTL positions. Object of class
<code>QTLlist</code> representing a list of selected position obtained with the
function <code><a href="#topic+QTL_select">QTL_select</a></code> or two columns numeric matrix with the
chromosome and the position in cM. These positions will be drawn on the
graph. Default = NULL.</p>
</td></tr>
<tr><td><code id="plot.QTLprof_+3A_type">type</code></td>
<td>
<p><code>Character</code> expression indicating the type of plot should be
drawn: &quot;l&quot; for lines , &quot;h&quot; for vertical bar. Default = &quot;l&quot;.</p>
</td></tr>
<tr><td><code id="plot.QTLprof_+3A_main">main</code></td>
<td>
<p>Title of the graph. Default = &quot;QTL profile&quot;.</p>
</td></tr>
<tr><td><code id="plot.QTLprof_+3A_threshold">threshold</code></td>
<td>
<p><code>Numeric</code> QTL significance threshold value draw on
the plot. Default = 3.</p>
</td></tr>
<tr><td><code id="plot.QTLprof_+3A_text.size">text.size</code></td>
<td>
<p><code>Numeric</code> value specifying the size of graph axis text
elements. Default = 18.</p>
</td></tr>
<tr><td><code id="plot.QTLprof_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can plot regular QTL profiles (<code>gen.eff = FALSE</code>) with
-log10(p-val) plotted against genetic position or genome-wide genetic
effects plots (<code>gen.eff = TRUE</code>). To plot the genome-wide genetic
effects, the SIM and CIM QTL profile must have been computed with
<code>plot.gen.eff = TRUE</code>.
</p>
<p>The genome-wide genetic effects plots is a visualisation of the significance
of the QTL effect per cross or per parents along the genome. For a
cross-specific QTL profile (<code>Q.eff = "cr"</code>): Blue color means
that the allele coming from parent A(1) increases the phenotypic value and
parent B(2) decreases it and red that parent A(1) decreases the trait and
parent B(2) increases it.
</p>
<p>For a parental (<code>Q.eff = "par"</code>) or an ancestral model
(<code>Q.eff = "anc"</code>), the results are given per parents. The significance
of the effect must be interpreted as a deviation with respect to the
reference of each connected part. The reference allele is always defined as
the most frequent one. Blue (Red) colour means a signicative negative
(positive) effect with respect to the reference of the connected part.
</p>
<p>The reference parental allele can change at each position according to the
segregation rate. The parent are plotted from the top to the bottom according
to the number of time their allele is set as reference.  Therefore
interpretation of the genetic effect plot should be done with caution.
In that case, the plot should be taken as a rough indication of the signal
distribution.
</p>
<p>The colour intensity increase with the significance of the effect (p-val).
The p-val are transformed into a color code (z). If p-val c [0.00001; 0.05]:
z = -log10(p-val). If p-val &lt; 0.00001: z=6. This scale allows to plot
only the significant effects (p-val &lt;= 0.05) and prevent the color scale to
be determine by highly significant values (p-val &lt; 0.00001). The colours red
(positive) and blue (negative) correspond to the sign of the QTL effect.
</p>
<p>For both type of plot, the user can pass a list of cofactors or QTL position
to the argument <code>QTL</code>. These positions will be drawn on the graph using
dotted lines.
</p>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_SIM">mpp_SIM</a></code>, <code><a href="#topic+mpp_CIM">mpp_CIM</a></code>, <code><a href="#topic+QTL_select">QTL_select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

SIM &lt;- mpp_SIM(mppData = mppData)
QTL &lt;- QTL_select(SIM)
plot(x = SIM, QTL = QTL)

SIM &lt;- mpp_SIM(mppData = mppData, Q.eff = "cr", plot.gen.eff = TRUE)
QTL &lt;- QTL_select(SIM)
plot(x = SIM, gen.eff = TRUE, mppData = mppData, Q.eff = "cr", QTL = QTL)

</code></pre>

<hr>
<h2 id='print.summary.mppData'>Print summary.mppData object</h2><span id='topic+print.summary.mppData'></span>

<h3>Description</h3>

<p>Print summary.mppData object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.mppData'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.mppData_+3A_x">x</code></td>
<td>
<p>object of class <code>summary.mppData</code></p>
</td></tr>
<tr><td><code id="print.summary.mppData_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)
sum.mppData &lt;- summary(mppData)
print(sum.mppData)

</code></pre>

<hr>
<h2 id='print.summary.QeffRes'>Print summary.QeffRes object</h2><span id='topic+print.summary.QeffRes'></span>

<h3>Description</h3>

<p>Print summary.QeffRes object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.QeffRes'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.QeffRes_+3A_x">x</code></td>
<td>
<p>object of class <code>summary.QeffRes</code></p>
</td></tr>
<tr><td><code id="print.summary.QeffRes_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)
SIM &lt;- mpp_SIM(mppData)
QTL &lt;- QTL_select(SIM)
QTL.effects &lt;- QTL_gen_effects(mppData = mppData, QTL = QTL, Q.eff = "cr")
sum.QeffRes &lt;- summary(QTL.effects)
print(sum.QeffRes)

</code></pre>

<hr>
<h2 id='print.summary.QR2Res'>Print summary.QR2Res object</h2><span id='topic+print.summary.QR2Res'></span>

<h3>Description</h3>

<p>Print summary.QR2Res object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.QR2Res'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.QR2Res_+3A_x">x</code></td>
<td>
<p>object of class <code>summary.QR2Res</code></p>
</td></tr>
<tr><td><code id="print.summary.QR2Res_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)
SIM &lt;- mpp_SIM(mppData)
QTL &lt;- QTL_select(SIM)
Q_R2 &lt;- QTL_R2(mppData = mppData, QTL = QTL, Q.eff = "cr")
sum.QR2Res &lt;- summary(Q_R2)
print(sum.QR2Res)

</code></pre>

<hr>
<h2 id='QC.mppData'>Quality control for <code>mppData</code> objects</h2><span id='topic+QC.mppData'></span>

<h3>Description</h3>

<p>Perform different operations of quality control (QC) on the marker data of an
<code>mppData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QC.mppData(
  mppData,
  mk.miss = 0.1,
  gen.miss = 0.25,
  n.lim = 15,
  MAF.pop.lim = 0.05,
  MAF.cr.lim = NULL,
  MAF.cr.miss = TRUE,
  MAF.cr.lim2 = NULL,
  verbose = TRUE,
  n.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QC.mppData_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code> formed with
<code><a href="#topic+create.mppData">create.mppData</a></code>.</p>
</td></tr>
<tr><td><code id="QC.mppData_+3A_mk.miss">mk.miss</code></td>
<td>
<p><code>Numeric</code> maximum marker missing rate at the whole
population level comprised between 0 and 1. Default = 0.1.</p>
</td></tr>
<tr><td><code id="QC.mppData_+3A_gen.miss">gen.miss</code></td>
<td>
<p><code>Numeric</code> maximum genotype missing rate at the whole
population level comprised between 0 and 1. Default = 0.25.</p>
</td></tr>
<tr><td><code id="QC.mppData_+3A_n.lim">n.lim</code></td>
<td>
<p><code>Numeric</code> value specifying the minimum cross size.
Default = 15.</p>
</td></tr>
<tr><td><code id="QC.mppData_+3A_maf.pop.lim">MAF.pop.lim</code></td>
<td>
<p><code>Numeric</code> minimum marker minor allele frequency at
the population level. Default = 0.05.</p>
</td></tr>
<tr><td><code id="QC.mppData_+3A_maf.cr.lim">MAF.cr.lim</code></td>
<td>
<p><code>Numeric vector</code> specifying the critical within cross
MAF. Marker with a problematic segregation rate in at least
one cross is either set as missing within the problematic cross
(<code>MAF.cr.miss = TRUE</code>), or remove from the marker matrix
(<code>MAF.cr.miss = FALSE</code>). For default value see details.</p>
</td></tr>
<tr><td><code id="QC.mppData_+3A_maf.cr.miss">MAF.cr.miss</code></td>
<td>
<p><code>Logical</code> value specifying if maker with a too low
segregation rate within cross (<code>MAF.cr.lim</code>) should be put as missing
(<code>MAF.cr.miss = TRUE</code>) or discarded (<code>MAF.cr.miss = FALSE</code>).
Default = TRUE.</p>
</td></tr>
<tr><td><code id="QC.mppData_+3A_maf.cr.lim2">MAF.cr.lim2</code></td>
<td>
<p><code>Numeric</code>. Alternative option for marker MAF
filtering. Only markers segregating with a MAF larger than <code>MAF.cr.lim2</code>
in at least one cross will be kept for the analysis. Default = NULL.</p>
</td></tr>
<tr><td><code id="QC.mppData_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value indicating if the steps of the QC should
be printed. Default = TRUE.</p>
</td></tr>
<tr><td><code id="QC.mppData_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different operations of the quality control are the following:
</p>

<ol>
<li><p>Remove markers with more than two alleles.
</p>
</li>
<li><p>Remove markers that are monomorphic or fully missing in the parents.
</p>
</li>
<li><p>Remove markers with a missing rate higher than <code>mk.miss</code>.
</p>
</li>
<li><p>Remove genotypes with more missing markers than <code>gen.miss</code>.
</p>
</li>
<li><p>Remove crosses with less than <code>n.lim</code> genotypes.
</p>
</li>
<li><p>Keep only the most polymorphic marker when multiple markers map at the
same position. 
</p>
</li>
<li><p>Check marker minor allele frequency (MAF). Different strategy can be
used to control marker MAF:
</p>
<p>A) A first possibility is to filter marker based on MAF at the whole population
level using <code>MAF.pop.lim</code>, and/or on MAF within crosses using
<code>MAF.cr.lim</code>.
</p>
<p>The user can give the its own vector of critical values for MAF within cross
using <code>MAF.cr.lim</code>. By default, the within cross MAF values are defined
by the following function of the cross-size n.ci: MAF(n.ci) = 0.5 if n.ci c
[0, 10] and MAF(n.ci) = (4.5/n.ci) + 0.05 if n.ci &gt; 10. This means that up
to 10 genotypes, the critical within cross MAF is set to 50
decreases when the number of genotype increases until 5
</p>
<p>If the within cross MAF is below the limit in at least one cross, then marker
scores of the problematic cross are either put as missing
(<code>MAF.cr.miss = TRUE</code>) or the whole marker is discarded
(<code>MAF.cr.miss = FALSE</code>). By default, <code>MAF.cr.miss = TRUE</code> which
allows to include a larger number of markers and to cover a wider genetic
diversity.
</p>
<p>B) An alternative is to select only markers that segregate in at least
on cross at the <code>MAF.cr.lim2</code> rate.
</p>

</li></ol>



<h3>Value</h3>

<p>a filtered <code>mppData</code> object containing the the same elements
as <code><a href="#topic+create.mppData">create.mppData</a></code> after filtering. It contains also the
following new elements:
</p>
<table>
<tr><td><code>geno.id</code></td>
<td>
 <p><code>Character</code> vector of genotpes identifiers.</p>
</td></tr>
<tr><td><code>ped.mat</code></td>
<td>
<p>Four columns <code>data.frame</code>: 1) the type of genotype:
&quot;offspring&quot; for the last genration and &quot;founder&quot; for the genotypes above
the offspring in the pedigree; 2) the genotype indicator; 3-4) the parent 1
(2) of each line.</p>
</td></tr>
<tr><td><code>geno.par.clu</code></td>
<td>
<p>Parent marker matrix without monomorphic or completely
missing markers.</p>
</td></tr>
<tr><td><code>haplo.map</code></td>
<td>
<p>Genetic map corresponding to the list of marker of the
<code>geno.par.clu</code> object.</p>
</td></tr>
<tr><td><code>parents</code></td>
<td>
<p>List of parents.</p>
</td></tr>
<tr><td><code>n.cr</code></td>
<td>
<p>Number of crosses.</p>
</td></tr>
<tr><td><code>n.par</code></td>
<td>
<p>Number of parents.</p>
</td></tr>
<tr><td><code>rem.mk</code></td>
<td>
<p>Vector of markers that have been removed.</p>
</td></tr>
<tr><td><code>rem.geno</code></td>
<td>
<p>Vector of genotypes that have been removed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.mppData">create.mppData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData_init)

mppData &lt;- QC.mppData(mppData = mppData_init, n.lim = 15, MAF.pop.lim = 0.05,
                      MAF.cr.miss = TRUE, mk.miss = 0.1,
                      gen.miss = 0.25, verbose = TRUE)      

</code></pre>

<hr>
<h2 id='QTL_effect_GE'>MPP GxE QTL genetic effects</h2><span id='topic+QTL_effect_GE'></span>

<h3>Description</h3>

<p>Estimate the QTL parental allelic effects within environment. The estimation
is performed using an exact mixed model with function from R package
<code>nlme</code>. The significance of the allele effect is assessed using a 
Wald test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTL_effect_GE(
  mppData,
  trait,
  VCOV = "UN",
  ref_par = NULL,
  QTL = NULL,
  maxIter = 100,
  msMaxIter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTL_effect_GE_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="QTL_effect_GE_+3A_trait">trait</code></td>
<td>
<p><code>Character vector</code> specifying which traits (environments) should be used.</p>
</td></tr>
<tr><td><code id="QTL_effect_GE_+3A_vcov">VCOV</code></td>
<td>
<p>VCOV <code>Character</code> expression defining the type of variance
covariance structure used. 'CS' for compound symmetry assuming a unique
genetic covariance between environments. 'CSE' for cross-specific within
environment error term. 'CS_CSE' for both compound symmetry plus
cross-specific within environment error term. 'UN' for unstructured
environmental variance covariance structure allowing a specific genotypic
covariance for each pair of environments. Default = 'UN'</p>
</td></tr>
<tr><td><code id="QTL_effect_GE_+3A_ref_par">ref_par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference for the parental model. Default = NULL</p>
</td></tr>
<tr><td><code id="QTL_effect_GE_+3A_qtl">QTL</code></td>
<td>
<p>Object of class <code>QTLlist</code> representing a list of
selected marker positions obtained with the function QTL_select() or
a vector of <code>character</code> marker positions names. Default = NULL.</p>
</td></tr>
<tr><td><code id="QTL_effect_GE_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for the lme optimization algorithm.
Default = 100.</p>
</td></tr>
<tr><td><code id="QTL_effect_GE_+3A_msmaxiter">msMaxIter</code></td>
<td>
<p>maximum number of iterations for the optimization step inside
the lme optimization. Default = 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated model is the following:
</p>
<p><code class="reqn">\underline{y}_{icj} = E_{j} + C_{cj} + \sum_{q=1}^{n_{QTL}} x_{i_{q}p} * \beta_{pj} + \underline{GE}_{icj} + \underline{e}_{icj}</code>
</p>
<p>For further details see the vignette.
</p>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>Qeff</code></td>
<td>
<p><code>List</code> of <code>data.frame</code> (one per QTL) containing the
following information:
</p>

<ol>
<li><p>QTL genetic effects
</p>
</li>
<li><p>Standard error of the QTL effects.
</p>
</li>
<li><p>Wald statistics of the effects.
</p>
</li>
<li><p>P-value of the test statistics.
</p>
</li>
<li><p>Significance of the QTL effects.
</p>
</li></ol>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Pinheiro J, Bates D, DebRoy S, Sarkar D, R Core Team (2021). nlme: Linear
and Nonlinear Mixed Effects Models_. R package version 3.1-152,
&lt;URL: https://CRAN.R-project.org/package=nlme&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData_GE)

Qpos &lt;- c("PZE.105068880", "PZE.106098900")

Qeff &lt;- QTL_effect_GE(mppData = mppData_GE, trait = c('DMY_CIAM', 'DMY_TUM'),
                      QTL = Qpos)

Qeff

</code></pre>

<hr>
<h2 id='QTL_effect_main_QEI'>Main and QTL by environment interaction model</h2><span id='topic+QTL_effect_main_QEI'></span>

<h3>Description</h3>

<p>The function estimate a QTL model where each parental QTL allelic effect is
decomposed into a main effect and a QTL by environment effect (QEI). It allows
the user to determine which parental allelic effects have a significant
interaction with the environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTL_effect_main_QEI(
  mppData,
  trait,
  env_id = NULL,
  ref_env = NULL,
  ref_par = NULL,
  VCOV = "UN",
  QTL = NULL,
  maxIter = 100,
  msMaxIter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTL_effect_main_QEI_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QEI_+3A_trait">trait</code></td>
<td>
<p><code>Character vector</code> specifying which traits (environments) should be used.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QEI_+3A_env_id">env_id</code></td>
<td>
<p><code>Character</code> vector specifying the environment names.
By default, E1, ... En</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QEI_+3A_ref_env">ref_env</code></td>
<td>
<p>Optional <code>Character</code> expression defining the environment
that will be used as reference for the parental model. By default, the last
environment is set as reference.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QEI_+3A_ref_par">ref_par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference for the parental model. Default = NULL</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QEI_+3A_vcov">VCOV</code></td>
<td>
<p>VCOV <code>Character</code> expression defining the type of variance
covariance structure used. 'CS' for compound symmetry assuming a unique
genetic covariance between environments. 'CSE' for cross-specific within
environment error term. 'CS_CSE' for both compound symmetry plus
cross-specific within environment error term. 'UN' for unstructured
environmental variance covariance structure allowing a specific genotypic
covariance for each pair of environments. Default = 'UN'</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QEI_+3A_qtl">QTL</code></td>
<td>
<p>Object of class <code>QTLlist</code> representing a list of
selected marker positions obtained with the function QTL_select() or
a vector of <code>character</code> marker positions names. Default = NULL.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QEI_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for the lme optimization algorithm.
Default = 100.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QEI_+3A_msmaxiter">msMaxIter</code></td>
<td>
<p>maximum number of iterations for the optimization step inside
the lme optimization. Default = 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimate the following model
</p>
<p><code class="reqn">y_{icj} = E_j + C_{c_j} + \sum_{q=1}^{n_{QTL}}{x_{i_{q}p}*(\alpha_{p} + \beta_{pj})} + GE_{ijc} + e_{ijc}</code>
</p>
<p>where the QTL effect is decomposed into <code class="reqn">\alpha_{p}</code> that represent the
main parental allelic effect across environments and <code class="reqn">\beta_{pj}</code> which is
the QEI effect. allelic effects must be interpreted as deviation with respect
to the reference parent ('ref_par') in the reference environment ('ref_env').
By default the reference parent is the one with the highest allelic frequency
(e.g. central parent in a NAM population).
</p>
<p>The estimation is performed using an exact mixed model with function from R
package <code>nlme</code>. The significance of the allele effect is assessed using a 
Wald test.
</p>


<h3>Value</h3>

<p>Return:
</p>
<p><code>List</code> with one <code>data.frame</code> per QTL that contains the following
elements:
</p>

<ol>
<li><p>To be filled
</p>
</li>
<li><p>To be filled
</p>
</li>
<li><p>Significance of the parent main effect expressed as the -log10(p-val)
</p>
</li>
<li><p>Significance of the parent QTLxE effect expressed as the -log10(p-val)
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Pinheiro J, Bates D, DebRoy S, Sarkar D, R Core Team (2021). nlme: Linear
and Nonlinear Mixed Effects Models_. R package version 3.1-152,
&lt;URL: https://CRAN.R-project.org/package=nlme&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(mppData_GE)

Qpos &lt;- c("PZE.105068880", "PZE.106098900")

Qeff &lt;- QTL_effect_main_QEI(mppData = mppData_GE,
                            trait = c('DMY_CIAM', 'DMY_TUM', 'DMY_INRA_P', 'DMY_KWS'),
                            env_id = c('CIAM', 'TUM', 'INRA', 'KWS'),
                            QTL = Qpos)

Qeff


## End(Not run)

</code></pre>

<hr>
<h2 id='QTL_effect_main_QxEC'>Estimation of a model with main and QTL by environmental sensitivity terms</h2><span id='topic+QTL_effect_main_QxEC'></span>

<h3>Description</h3>

<p>After estimating which parental allelic effects have a significant interaction
with the environment (QEI), the function extends the model for the allelic
effect with a significant QEI to characterize this interaction in terms of
sensitivity to (a) specific environmental covariate(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTL_effect_main_QxEC(
  mppData,
  trait,
  env_id = NULL,
  ref_env = NULL,
  ref_par = NULL,
  VCOV = "UN",
  QTL = NULL,
  thre_QTL = 2,
  EC,
  Qmain_QEI = NULL,
  maxIter = 100,
  msMaxIter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTL_effect_main_QxEC_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_trait">trait</code></td>
<td>
<p><code>Character vector</code> specifying which traits (environments) should be used.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_env_id">env_id</code></td>
<td>
<p><code>Character</code> vector specifying the environment names.
By default, E1, ... En</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_ref_env">ref_env</code></td>
<td>
<p>Optional <code>Character</code> expression defining the environment
that will be used as reference for the parental model. By default, the last
environment is set as reference.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_ref_par">ref_par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference for the parental model. By default,
the parent with the largest MAF is set as reference.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_vcov">VCOV</code></td>
<td>
<p>VCOV <code>Character</code> expression defining the type of variance
covariance structure used. 'CS' for compound symmetry assuming a unique
genetic covariance between environments. 'CSE' for cross-specific within
environment error term. 'CS_CSE' for both compound symmetry plus
cross-specific within environment error term. 'UN' for unstructured
environmental variance covariance structure allowing a specific genotypic
covariance for each pair of environments. Default = 'UN'</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_qtl">QTL</code></td>
<td>
<p>Object of class <code>QTLlist</code> representing a list of
selected marker positions obtained with the function QTL_select() or
a vector of <code>character</code> marker positions names. Default = NULL.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_thre_qtl">thre_QTL</code></td>
<td>
<p><code>Numerical</code> value specifying the -log10(p-val) threshold
for a parental QTL allele to be considered as significant. By default,
thre_QTL = 2, which correspond to a p-value of 0.01.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_ec">EC</code></td>
<td>
<p><code>Numeric</code> matrix with environments as row and environmental
covariates (EC) as column. The cell i, j of EC specify the value of the
jth EC in environment i.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_qmain_qei">Qmain_QEI</code></td>
<td>
<p>results from <code><a href="#topic+QTL_effect_main_QEI">QTL_effect_main_QEI</a></code></p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for the lme optimization algorithm.
Default = 100.</p>
</td></tr>
<tr><td><code id="QTL_effect_main_QxEC_+3A_msmaxiter">msMaxIter</code></td>
<td>
<p>maximum number of iterations for the optimization step inside
the lme optimization. Default = 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first estimate the parental QTL allele main and QTLxE effect
using the function <code><a href="#topic+QTL_effect_main_QEI">QTL_effect_main_QEI</a></code>. Optionally the output
of <code><a href="#topic+QTL_effect_main_QEI">QTL_effect_main_QEI</a></code> can be passed through the 'Qmain_QEI'
argument. The function consider that a parental QTL allele significantly
interacts with the environment if its QTLxE term is significant at the
'thre_QTL' level. Thre_QTL is expressed in terms of -log10(p-val).
For example, for p-val = 0.01, thre_QTL = -log10(p-val) = 2. Given this
information, the effect of the parental QTL allele with a significant QEI
are extended like that <code class="reqn">\beta_{pj} = EC_j*S_p+l_{p\epsilon}</code> where
<code class="reqn">EC_j</code> represents the EC value in environment j associated with the
sensitivity term <code class="reqn">S_p</code>. The <code class="reqn">S_{p}</code> determines the rate of change of
the parental QTL allelic additive effect given an extra unit of EC. Finally,
<code class="reqn">l_{p\epsilon}</code> is a residual effect. The fitted model becomes:
</p>
<p><code class="reqn">\underline{y}_{icj} = E_{j} + C_{cj} + \sum_{q=1}^{n_{QTL}} x_{i_{q}p} (\alpha_p + \beta_{pj}) + x_{i_{q}pxE} (\alpha_p + EC_j*S_p+l_{p\epsilon}) + \underline{GE}_{icj} + \underline{e}_{icj}</code>
</p>
<p>The estimation is performed using an exact mixed model with function from R
package <code>nlme</code>. The significance of <code class="reqn">S_{p}</code> is assessed using a 
Wald test.
</p>


<h3>Value</h3>

<p>Return:
</p>
<p><code>List</code> with one <code>data.frame</code> per QTL that contains the following
elements:
</p>

<ol>
<li><p>QTL parent allele main effect expressed as deviation with respect to
the reference parent
</p>
</li>
<li><p>QTL parent allele effect in environment j expressed as deviation with
respect to the reference parent
</p>
</li>
<li><p>Significance of the parent main effect expressed as the -log10(p-val)
</p>
</li>
<li><p>Significance of the parent QTLxE effect expressed as the -log10(p-val)
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Pinheiro J, Bates D, DebRoy S, Sarkar D, R Core Team (2021). nlme: Linear
and Nonlinear Mixed Effects Models_. R package version 3.1-152,
&lt;URL: https://CRAN.R-project.org/package=nlme&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QTL_effect_main_QEI">QTL_effect_main_QEI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(mppData_GE)

Qpos &lt;- c("PZE.105068880", "PZE.106098900")

EC &lt;- matrix(c(180, 310, 240, 280), 4, 1)
rownames(EC) &lt;- c('CIAM', 'TUM', 'INRA', 'KWS')
colnames(EC) &lt;- 'cum_rain'

Qeff &lt;- QTL_effect_main_QxEC(mppData = mppData_GE,
                         trait = c('DMY_CIAM', 'DMY_TUM', 'DMY_INRA_P', 'DMY_KWS'),
                         env_id = c('CIAM', 'TUM', 'INRA', 'KWS'),
                         QTL = Qpos, EC = EC)

Qeff


## End(Not run)

</code></pre>

<hr>
<h2 id='QTL_forward'>Forward regression QTL model</h2><span id='topic+QTL_forward'></span>

<h3>Description</h3>

<p>Determines a multi-QTL model using a forward regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTL_forward(
  mppData = NULL,
  trait = 1,
  Q.eff,
  threshold = 4,
  window = 30,
  n.cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTL_forward_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code></p>
</td></tr>
<tr><td><code id="QTL_forward_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="QTL_forward_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> vector of possible QTL effects the user want to
test. Elements of Q.eff can be &quot;cr&quot;, &quot;par&quot;, &quot;anc&quot; or &quot;biall&quot;. For details
look at <code><a href="#topic+mpp_SIM">mpp_SIM</a></code>.</p>
</td></tr>
<tr><td><code id="QTL_forward_+3A_threshold">threshold</code></td>
<td>
<p><code>Numeric</code> value representing the -log10(p-value) threshold
above which a position can be considered as significant. Default = 4.</p>
</td></tr>
<tr><td><code id="QTL_forward_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> distance (cM) on the left and the right of a
cofactor position where it is not included in the model. Default = 30.</p>
</td></tr>
<tr><td><code id="QTL_forward_+3A_n.cores">n.cores</code></td>
<td>
<p><code>Numeric</code>. Specify here the number of cores you like to
use. Default = 1.</p>
</td></tr>
<tr><td><code id="QTL_forward_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value indicating if the steps of the
forward regression should be printed. Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forward regression to determine the a multi-QTL model. The function
selects successively QTL positions with -log10(pval) above the threshold.
Those positions are added as cofactors for following detection run.
The procedure stop when no more position has a -log10(pval) above the
threshold.
</p>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>QTL</code></td>
<td>
<p><code>Data.frame</code> of class <code>QTLlist</code> with five columns :
1) QTL marker names; 2) chromosomes;
3) interger position indicators on the chromosome;
4) positions in centi-Morgan; and 5) -log10(p-values).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_SIM">mpp_SIM</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

QTL &lt;- QTL_forward(mppData = mppData, Q.eff = "par")

</code></pre>

<hr>
<h2 id='QTL_gen_effects'>QTL genetic effects</h2><span id='topic+QTL_gen_effects'></span>

<h3>Description</h3>

<p>Computes a multi-QTL model with a list of QTL candidates (<code>QTL</code>) and
return the decomposed QTL effects per cross or per parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTL_gen_effects(
  mppData,
  trait = 1,
  QTL = NULL,
  Q.eff = "cr",
  ref.par = NULL,
  sum_zero = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTL_gen_effects_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="QTL_gen_effects_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="QTL_gen_effects_+3A_qtl">QTL</code></td>
<td>
<p>Object of class <code>QTLlist</code> representing a list of
selected position obtained with the function <code><a href="#topic+QTL_select">QTL_select</a></code> or
vector of <code>character</code> marker positions names.
Default = NULL.</p>
</td></tr>
<tr><td><code id="QTL_gen_effects_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effects: 1) &quot;cr&quot; for cross-specific; 2) &quot;par&quot; for parental; 3) &quot;anc&quot;
for ancestral; 4) &quot;biall&quot; for a bi-allelic. For more details see
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="QTL_gen_effects_+3A_ref.par">ref.par</code></td>
<td>
<p>Optional <code>Character</code> expression defining the parental
allele that will be used as reference for the parental model. For the
ancestral model, the ancestral class containing the reference parent will be
set as reference. <strong>This option can only be used if the MPP design is
composed of a unique connected part</strong>. Default = NULL.</p>
</td></tr>
<tr><td><code id="QTL_gen_effects_+3A_sum_zero">sum_zero</code></td>
<td>
<p>Optional <code>Logical</code> value specifying if the QTL effect of
a parental or an ancestral model should be calculated using the sum to zero
constraint. Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes for each QTL position the genetic effects of the
cross, parental, ancestral or SNP allele components. For the cross-specific
model (<code>Q.eff = "cr"</code>), the genetics effects represent the substitution
effect of an single allele from the parent 2 (or B) with respect to an allele
coming from the parent 1 or A. All effects are given in absolute value with
the parent that carries the positive allele.
</p>
<p>For the parental and the ancestral model (<code>Q.eff = "par" or "anc"</code>), it
is possible to estimate maximum n-1 parental or ancestral alleles per
interconnected part of the design. For these two models, one
parental (ancestral) allele is set as reference per interconnected part of the
design. Effects of the other alleles are estimated as deviation with respect
to the reference. Connected parts of the design can be determined using Weeks
and Williams (1964) method (<code><a href="#topic+design_connectivity">design_connectivity</a></code>). By default,
the reference allele is the most frequent one. The user can also specify a
parental allele that will be used as reference using the argument
<code>ref.par</code>. This option is only available if the MPP design is composed
of a unique connected part.
</p>
<p>For the parental and ancestral model it is also possible to estimate the QTL
effects using a sum to zero constraint <code>sum_zero = TRUE</code>. In that case,
the effects of the different parental (ancestral) allele will represent the
deviation with respect to the average trait value.
</p>
<p>For the bi-allelic model (<code>Q.eff = "biall"</code>), the genetic effects
represent the effects of a single allele copy of the least frequent allele.
</p>


<h3>Value</h3>

<p>Return:
</p>
<p>Object of class <code>QeffRes</code> containing the following elements:
</p>
<table>
<tr><td><code>Qeff</code></td>
<td>
<p><code>List</code> of <code>data.frame</code> (one per QTL) containing the
following information:
</p>

<ol>
<li><p>QTL genetic effects per cross or parent.
</p>
</li>
<li><p>Standard error of the QTL effects.
</p>
</li>
<li><p>Test statistics of the effects (t-test or Wald statistic).
</p>
</li>
<li><p>P-value of the test statistics.
</p>
</li>
<li><p>Significance of the QTL effects.
</p>
</li>
<li><p>For cross-specific model, parent with the positive additive effects.
</p>
</li>
<li><p>For parental and ancestral model, indicator of connected part of the
design and reference.
</p>
</li>
<li><p>Allele scores of the parents if <code>geno.par</code> is non NULL
in the <code>mppData</code> object.
</p>
</li></ol>

</td></tr>
<tr><td><code>tab.Qeff</code></td>
<td>
<p><code>data.frame</code> with one column per QTL giving the
QTL genetic effects per cross or per parent with its significance. The
first two rows indicate the chromosome and the position in cM of each
QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Weeks, D. L., &amp; Williams, D. R. (1964). A note on the determination of
connectedness in an N-way cross classification. Technometrics, 6(3), 319-324.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QTL_select">QTL_select</a></code>, <code><a href="#topic+summary.QeffRes">summary.QeffRes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

# QTL candidates

SIM &lt;- mpp_SIM(mppData)
QTL &lt;- QTL_select(SIM)

# Cross-specific model

QTL.effects &lt;- QTL_gen_effects(mppData = mppData, QTL = QTL, Q.eff = "cr")
summary(QTL.effects)

# Parental model

QTL.effects &lt;- QTL_gen_effects(mppData = mppData, QTL = QTL, Q.eff = "par")
summary(QTL.effects)

# Ancestral model

QTL.effects &lt;- QTL_gen_effects(mppData = mppData, QTL = QTL, Q.eff = "anc")
summary(QTL.effects)

# Bi-allelic model

QTL.effects &lt;- QTL_gen_effects(mppData = mppData, QTL = QTL, Q.eff = "biall")
summary(QTL.effects)

</code></pre>

<hr>
<h2 id='QTL_pred_R2'>Predicted QTL global and partial R squared</h2><span id='topic+QTL_pred_R2'></span>

<h3>Description</h3>

<p>Compute predicted R squared in a validation set using QTLs detected in a
training set. These values are corrected by the heritability <code>her</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTL_pred_R2(
  mppData.ts,
  mppData.vs,
  trait = 1,
  Q.eff = "cr",
  QTL = NULL,
  her = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTL_pred_R2_+3A_mppdata.ts">mppData.ts</code></td>
<td>
<p>An object of class <code>mppData</code> for the training set.</p>
</td></tr>
<tr><td><code id="QTL_pred_R2_+3A_mppdata.vs">mppData.vs</code></td>
<td>
<p>An object of class <code>mppData</code> for the validation set.</p>
</td></tr>
<tr><td><code id="QTL_pred_R2_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="QTL_pred_R2_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effects: 1) &quot;cr&quot; for cross-specific; 2) &quot;par&quot; for parental; 3) &quot;anc&quot;
for ancestral; 4) &quot;biall&quot; for a bi-allelic. For more details see
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="QTL_pred_R2_+3A_qtl">QTL</code></td>
<td>
<p>Object of class <code>QTLlist</code> representing a list of
selected position obtained with the function <code><a href="#topic+QTL_select">QTL_select</a></code> or
vector of <code>character</code> marker positions names.
Default = NULL.</p>
</td></tr>
<tr><td><code id="QTL_pred_R2_+3A_her">her</code></td>
<td>
<p><code>Numeric</code> value between 0 and 1 representing the heritability
of the trait. <code>her</code> can be a single value or a vector specifying each
within cross heritability. Default = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute QTLs predicted R squared in a validation set  (<code>mppData.vs</code>).
These QTLs have been previously detected in a training set
(<code>mppData.ts</code>). The global R squared (R2 = cor(y.ts,y.pred.ts)^2) is
obtained using the Pearson squared correlation between the observed trait
values in the validation set (y.vs) and predicted values using estimated QTL
effects in the training set (y.pred.vs = X.vs * B.ts).
</p>
<p>After that the values are corrected by the general or within cross
heritability <code>her</code>. By default <code>her = 1</code> which means that the
R squared represent the proportion of explained phenotypic variance. The
values are returned per cross (<code>R2.cr</code>) or averaged at the population
level (<code>glb.R2</code>).
</p>
<p>Partial R squared statistics are also calculated for each individual position.
The partial R squared are computed by making the difference between the
global R squared and the R squared computed without the ith position.
</p>


<h3>Value</h3>

<p>Return:
</p>
<p><code>List</code> containing the following objects:
</p>
<table>
<tr><td><code>glb.R2</code></td>
<td>
<p>Global predicted R squared corrected for the heritability
of all QTL terms. Doing the average of the within cross predicted R squared
(R2.cr)</p>
</td></tr>
<tr><td><code>R2.cr</code></td>
<td>
<p>Within cross predicted R squared corrected for the heritability</p>
</td></tr>
<tr><td><code>part.R2.diff</code></td>
<td>
<p> Vector of predicted partial R squared corrected
for the heritability doing the difference between the full model and a model
minus the ith QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QTL_R2">QTL_R2</a></code>, <code><a href="#topic+QTL_select">QTL_select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

folds &lt;- CV_partition(cross.ind = mppData$cross.ind, k = 5)

mppData.ts &lt;- subset(x = mppData, gen.list = folds[[1]]$train.set)

mppData.vs &lt;- subset(x = mppData, gen.list = folds[[1]]$val.set)

SIM &lt;- mpp_SIM(mppData = mppData)
QTL &lt;- QTL_select(SIM)

QTL_pred_R2(mppData.ts = mppData.ts, mppData.vs = mppData.vs, QTL = QTL)

</code></pre>

<hr>
<h2 id='QTL_R2'>QTL global and partial R squared</h2><span id='topic+QTL_R2'></span>

<h3>Description</h3>

<p>Computes the global and partial (adjusted) R squared of a  list of QTLs using
a linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTL_R2(mppData, trait = 1, QTL = NULL, Q.eff = "cr", glb.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTL_R2_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="QTL_R2_+3A_trait">trait</code></td>
<td>
<p><code>Numerical</code> or <code>character</code> indicator to specify which
trait of the <code>mppData</code> object should be used. Default = 1.</p>
</td></tr>
<tr><td><code id="QTL_R2_+3A_qtl">QTL</code></td>
<td>
<p>Object of class <code>QTLlist</code> representing a list of
selected position obtained with the function <code><a href="#topic+QTL_select">QTL_select</a></code> or
vector of <code>character</code> marker positions names.
Default = NULL.</p>
</td></tr>
<tr><td><code id="QTL_R2_+3A_q.eff">Q.eff</code></td>
<td>
<p><code>Character</code> expression indicating the assumption concerning
the QTL effects: 1) &quot;cr&quot; for cross-specific; 2) &quot;par&quot; for parental; 3) &quot;anc&quot;
for ancestral; 4) &quot;biall&quot; for a bi-allelic. For more details see
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code>. Default = &quot;cr&quot;.</p>
</td></tr>
<tr><td><code id="QTL_R2_+3A_glb.only">glb.only</code></td>
<td>
<p><code>Logical</code> value. If glb.only = TRUE, only the global and 
global adjusted R squared will be returned. Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes R squared statistics using a linear model. The extra
variance explained by a full model containing the QTL terms with respect
to a reduced model containing only the cross intercept terms and uses the
ratio between the residual sum of square of these two models:
R2 = 1-(RSS(f))/(RSS(r)).
</p>
<p>Partial R squared for each individual QTL position can also be calculated.
Two types of partial R squared are returned. The first one
uses the difference between the R squared obtained with all QTL
positions and the R squared obtain with all position minus the ith one
(difference R squared). The second method used only the ith QTL position
in the model (single R squared).
</p>
<p>For both global and partial R squared, it is possible to obtained adjusted
measurements taking the number of degrees of freedom into consideration using
an adaptation of the formula given by Utz et al. (2000):
R.adj = R-(z/(N-z-n.cr))*(1-R) where z is the total
number of estimated components of the genetic effect. N is the total number
of phenotypic information, and n.cr is the number of intercept (cross) terms.
</p>


<h3>Value</h3>

<p>Return:
</p>
<p>object of class <code>QR2Res</code> containing the following objects:
</p>
<table>
<tr><td><code>glb.R2</code></td>
<td>
<p> Global R squared of all QTL terms.</p>
</td></tr>
<tr><td><code>glb.adj.R2</code></td>
<td>
<p> Global adjusted R squared of all QTL terms.</p>
</td></tr>
<tr><td><code>part.R2.diff</code></td>
<td>
<p> Vector of partial R squared doing
the difference between the full model and a model minus the ith QTL.</p>
</td></tr>
<tr><td><code>part.adj.R2.diff</code></td>
<td>
<p> Vector of partial adjusted R squared doing
the difference between the full model and a model minus the ith QTL.</p>
</td></tr>
<tr><td><code>part.R2.sg</code></td>
<td>
<p> Vector of partial R squared using only the ith QTL.</p>
</td></tr>
<tr><td><code>part.adj.R2.sg</code></td>
<td>
<p> Vector of partial adjusted R squared using only the
ith QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>References</h3>

<p>Utz, H. F., Melchinger, A. E., &amp; Schon, C. C. (2000). Bias and sampling error
of the estimated proportion of genotypic variance explained by quantitative
trait loci determined from experimental data in maize using cross validation
and validation with independent samples. Genetics, 154(4), 1839-1849.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QTL_select">QTL_select</a></code>, <code><a href="#topic+summary.QR2Res">summary.QR2Res</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

SIM &lt;- mpp_SIM(mppData)
QTL &lt;- QTL_select(Qprof = SIM, threshold = 3, window = 20)
Q_R2 &lt;- QTL_R2(mppData = mppData, QTL = QTL, Q.eff = "cr")
summary(Q_R2)


</code></pre>

<hr>
<h2 id='QTL_R2_GE'>MPP GxE QTL R2</h2><span id='topic+QTL_R2_GE'></span>

<h3>Description</h3>

<p>Compute global and partial R2 statistics for MPP GxE QTL using a linear model.
The global R2 is the contribution of all QTL positions while the partial R2
is the specific contribution of an individual QTL position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTL_R2_GE(mppData, trait, QTL = NULL, glb.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTL_R2_GE_+3A_mppdata">mppData</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="QTL_R2_GE_+3A_trait">trait</code></td>
<td>
<p><code>Character vector</code> specifying which traits (environments) should be used.</p>
</td></tr>
<tr><td><code id="QTL_R2_GE_+3A_qtl">QTL</code></td>
<td>
<p>Object of class <code>QTLlist</code> representing a list of
selected marker positions obtained with the function QTL_select() or
a vector of <code>character</code> marker positions names. Default = NULL.</p>
</td></tr>
<tr><td><code id="QTL_R2_GE_+3A_glb.only">glb.only</code></td>
<td>
<p><code>Logical</code> value. If glb.only = TRUE, only the global and
global adjusted R squared will be returned. Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return:
</p>
<p><code>List</code> containing the global unadjusted R2, the global adjusted R2,
the partial unadjusted R2, and the partial adjusted R2.
</p>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData_GE)

Qpos &lt;- c("PZE.105068880", "PZE.106098900")

R2 &lt;- QTL_R2_GE(mppData = mppData_GE, trait = c('DMY_CIAM', 'DMY_TUM'),
                QTL = Qpos)

</code></pre>

<hr>
<h2 id='QTL_select'>QTL candidates selection</h2><span id='topic+QTL_select'></span>

<h3>Description</h3>

<p>Selection of QTL candidate positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTL_select(Qprof, threshold = 3, window = 50, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTL_select_+3A_qprof">Qprof</code></td>
<td>
<p>Object of class <code>QTLprof</code> returned by the function 
<code><a href="#topic+mpp_SIM">mpp_SIM</a></code> or <code><a href="#topic+mpp_CIM">mpp_CIM</a></code>.</p>
</td></tr>
<tr><td><code id="QTL_select_+3A_threshold">threshold</code></td>
<td>
<p><code>Numeric</code> value representing -log10(p-value) threshold
above which a position can be considered as a QTL candidate. Default = 3.</p>
</td></tr>
<tr><td><code id="QTL_select_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> value in centi-Morgan representing the minimum
distance between two selected positions. Default = 50.</p>
</td></tr>
<tr><td><code id="QTL_select_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value specifying if the detection of no QTL
should be printed. Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function select QTL positions that are above the given
<code>threshold</code> per chromosome. Once a position has been selected, and
exclusion <code>window</code> is set around that position. Positions falling into
that region will not be candidate anymore. The search continue until there
is no more candidate position above the <code>threshold</code>.
</p>


<h3>Value</h3>

<p>Return:
</p>
<table>
<tr><td><code>QTL</code></td>
<td>
<p><code>Data.frame</code> of class <code>QTLlist</code> with five columns :
1) QTL marker names; 2) chromosomes;
3) interger position indicators on the chromosome;
4) positions in centi-Morgan; and 5) -log10(p-values).</p>
</td></tr>
</table>


<h3>References</h3>

<p>This function is a modification of the QTL.reduce function
coming from the Biometris pipepline.
</p>
<p>RAP (R Analytical Pipeline) (V0.9.1) May 2011
</p>
<p>Authors: Paul Eilers (1), Gerrit Gort (1), Sabine Schnabel (1), Lucia
Gutierrez(1, 2), Marcos Malosetti(1), Joost van Heerwaarden, and Fred van
Eeuwijk(1)
</p>
<p>(1) Wageningen University and Research Center, Netherlands (2) Facultad de
Agronomia, UDELAR, Uruguay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpp_SIM">mpp_SIM</a></code>, <code><a href="#topic+mpp_CIM">mpp_CIM</a></code>, <code><a href="#topic+mpp_perm">mpp_perm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)

SIM &lt;- mpp_SIM(mppData)

QTL &lt;- QTL_select(Qprof = SIM, threshold = 3)

</code></pre>

<hr>
<h2 id='subset.mppData'>Subset <code>mppData</code> object</h2><span id='topic+subset.mppData'></span>

<h3>Description</h3>

<p>Pull out a specified set of markers and/or genotypes from a <code>mppData</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mppData'
subset(x, mk.list = NULL, gen.list = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.mppData_+3A_x">x</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="subset.mppData_+3A_mk.list">mk.list</code></td>
<td>
<p>Optional <code>character</code> vector, <code>numeric</code> position
vector or <code>logical</code> vector representing marker to keep. Default = NULL.</p>
</td></tr>
<tr><td><code id="subset.mppData_+3A_gen.list">gen.list</code></td>
<td>
<p>Optional <code>character</code> vector, <code>numeric</code> position
vector or <code>logical</code> vector representing genotypes to keep.
Default = NULL.</p>
</td></tr>
<tr><td><code id="subset.mppData_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return:
</p>
<p>The mppData object but with only the specified subset of data.
</p>


<h3>Author(s)</h3>

<p>Vincent Garin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Marker subset

data(mppData)

# Random selection of markers
mk.list &lt;-  sample(mppData$map[, 1], 50)
mppData_sub &lt;- subset(x = mppData, mk.list = mk.list)

# Selection of chromosome 1 marker
mk.list &lt;-  (mppData$map[, 2] == 1)
mppData_sub &lt;- subset(x = mppData, mk.list = mk.list)

### Genotype subset

# Random selection of genotypes
gen.list &lt;-  sample(mppData$geno.id, 200)
mppData_sub &lt;- subset(x = mppData, gen.list = gen.list)

# Selection of genotype from cross 2 and 5
crosses &lt;- unique(mppData$cross.ind)
gen.list &lt;-  mppData$geno.id[mppData$cross.ind %in% crosses[c(2, 5)]]
mppData_sub &lt;- subset(x = mppData, gen.list = gen.list)

### Marker and genotype subset

mk.list &lt;-  sample(mppData$map[, 1], 50)
gen.list &lt;-  sample(mppData$geno.id, 200)
mppData_sub &lt;- subset(x = mppData, mk.list = mk.list,
gen.list = gen.list)

</code></pre>

<hr>
<h2 id='summary.mppData'>Summary of <code>mppData</code> object</h2><span id='topic+summary.mppData'></span>

<h3>Description</h3>

<p><code>summary</code> for object of class <code>mppData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mppData'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mppData_+3A_object">object</code></td>
<td>
<p>An object of class <code>mppData</code>.</p>
</td></tr>
<tr><td><code id="summary.mppData_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)
summary(mppData)

</code></pre>

<hr>
<h2 id='summary.QeffRes'>Summary of <code>QeffRes</code> object</h2><span id='topic+summary.QeffRes'></span>

<h3>Description</h3>

<p><code>summary</code> for object of class <code>QeffRes</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'QeffRes'
summary(object, QTL = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.QeffRes_+3A_object">object</code></td>
<td>
<p>An object of class <code>QeffRes</code> obtained with
function <code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code>.</p>
</td></tr>
<tr><td><code id="summary.QeffRes_+3A_qtl">QTL</code></td>
<td>
<p><code>Numeric</code> vector indicating the QTL positions for which the
QTL effect must be printed. Default = NULL.</p>
</td></tr>
<tr><td><code id="summary.QeffRes_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+QTL_gen_effects">QTL_gen_effects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)
SIM &lt;- mpp_SIM(mppData)
QTL &lt;- QTL_select(SIM)
QTL.effects &lt;- QTL_gen_effects(mppData = mppData, QTL = QTL, Q.eff = "cr")
summary(QTL.effects)

</code></pre>

<hr>
<h2 id='summary.QR2Res'>Summary of <code>QR2Res</code> object</h2><span id='topic+summary.QR2Res'></span>

<h3>Description</h3>

<p><code>summary</code> for object of class <code>QR2Res</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'QR2Res'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.QR2Res_+3A_object">object</code></td>
<td>
<p>An object of class <code>QR2Res</code> obtained with
function <code><a href="#topic+QTL_R2">QTL_R2</a></code>.</p>
</td></tr>
<tr><td><code id="summary.QR2Res_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+QTL_R2">QTL_R2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mppData)
SIM &lt;- mpp_SIM(mppData)
QTL &lt;- QTL_select(SIM)
Q_R2 &lt;- QTL_R2(mppData = mppData, QTL = QTL, Q.eff = "cr")
summary(Q_R2)

</code></pre>

<hr>
<h2 id='USNAM_geno'>
Reduced genotype data maize US-NAM population
</h2><span id='topic+USNAM_geno'></span>

<h3>Description</h3>

<p>Selection of markers and genotypes from the maize US nested association mapping
(NAM) population (McMullen et al., 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USNAM_geno)</code></pre>


<h3>Format</h3>

<p><code>data.frame</code>
</p>


<h3>Details</h3>

<p>Sample of the marker matrix of the US-NAM population. The selection correspond
to 102 markers coming from the two first
chromosomes present in <code><a href="#topic+USNAM_map">USNAM_map</a></code> and the 506 genotypes. These
genotypes correspond to the selected phenotypic values in
<code><a href="#topic+USNAM_pheno">USNAM_pheno</a></code>. The selected genotypes come from
the following crosses: (B73 x CML103), (B73 x CML322), (B73 x CML52),
(B73 x Hp301), (B73 x M37W). The data of the 6 parental lines are
also included. The data are available on www.panzea.org.
</p>


<h3>Source</h3>

<p><a href="https://www.panzea.org/">https://www.panzea.org/</a>
</p>


<h3>References</h3>

<p>McMullen, M. D., Kresovich, S., Villeda, H. S., Bradbury, P., Li, H., Sun, Q.,
... &amp; Buckler, E. S. (2009). Genetic properties of the maize nested association
mapping population. Science, 325(5941), 737-740.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+USNAM_pheno">USNAM_pheno</a></code>, <code><a href="#topic+USNAM_map">USNAM_map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USNAM_geno)
</code></pre>

<hr>
<h2 id='USNAM_map'>
Reduced map maize US-NAM population
</h2><span id='topic+USNAM_map'></span>

<h3>Description</h3>

<p>Reduced map of the maize US nested association mapping (NAM) population
(McMullen et al., 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USNAM_map)</code></pre>


<h3>Format</h3>

<p><code>data.frame</code>
</p>


<h3>Details</h3>

<p>Selection of 102 markers from the two first chromosomes of the Maize US-NAM
population (McCullen et al., 2009). The data are available on www.panzea.org.
</p>


<h3>Source</h3>

<p><a href="https://www.panzea.org">https://www.panzea.org</a>
</p>


<h3>References</h3>

<p>McMullen, M. D., Kresovich, S., Villeda, H. S., Bradbury, P., Li, H., Sun,
Q., ... &amp; Buckler, E. S. (2009). Genetic properties of the maize nested
association mapping population. Science, 325(5941), 737-740.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+USNAM_geno">USNAM_geno</a></code>, <code><a href="#topic+USNAM_pheno">USNAM_pheno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(USNAM_map)
</code></pre>

<hr>
<h2 id='USNAM_pheno'>
Reduced phenotype data from Maize US-NAM population
</h2><span id='topic+USNAM_pheno'></span>

<h3>Description</h3>

<p>Reduced phenotype data from the Maize US nested association mapping (NAM)
population (McMullen et al., 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USNAM_pheno)</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Details</h3>

<p>Upper leaf angle (ULA) trait values with genotypes identifiers as rownames. These genotypes correspond to the 500 offspring genotypes of the marker matrix <code><a href="#topic+USNAM_geno">USNAM_geno</a></code>. The data are available on www.panzea.org.
</p>


<h3>Source</h3>

<p><a href="https://www.panzea.org">https://www.panzea.org</a>
</p>


<h3>References</h3>

<p>McMullen, M. D., Kresovich, S., Villeda, H. S., Bradbury, P., Li, H., Sun, Q.,
... &amp; Buckler, E. S. (2009). Genetic properties of the maize nested
association mapping population. Science, 325(5941), 737-740.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+USNAM_geno">USNAM_geno</a></code>, <code><a href="#topic+USNAM_map">USNAM_map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USNAM_pheno)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
