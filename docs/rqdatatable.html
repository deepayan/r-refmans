<!DOCTYPE html><html lang="en"><head><title>Help for package rqdatatable</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rqdatatable}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rqdatatable-package'><p><code>rqdatatable</code>: Relational Query Generator for Data Manipulation Implemented by data.table</p></a></li>
<li><a href='#ex_data_table'><p>Execute an <code>rquery</code> pipeline with <code>data.table</code> sources.</p></a></li>
<li><a href='#ex_data_table_parallel'><p>Execute an <code>rquery</code> pipeline with <code>data.table</code> in parallel.</p></a></li>
<li><a href='#ex_data_table_step'><p>Execute an <code>rquery</code> pipeline with <code>data.table</code> sources.</p></a></li>
<li><a href='#ex_data_table_step.default'><p>default non-impementation.</p></a></li>
<li><a href='#ex_data_table_step.relop_drop_columns'><p>Implement drop columns.</p></a></li>
<li><a href='#ex_data_table_step.relop_extend'><p>Implement extend/assign operator.</p></a></li>
<li><a href='#ex_data_table_step.relop_natural_join'><p>Natural join.</p></a></li>
<li><a href='#ex_data_table_step.relop_non_sql'><p>Direct non-sql (function) node, not implemented for <code>data.table</code> case.</p></a></li>
<li><a href='#ex_data_table_step.relop_null_replace'><p>Replace NAs.</p></a></li>
<li><a href='#ex_data_table_step.relop_order_expr'><p>Order rows by expression.</p></a></li>
<li><a href='#ex_data_table_step.relop_orderby'><p>Reorder rows.</p></a></li>
<li><a href='#ex_data_table_step.relop_project'><p>Implement projection operator.</p></a></li>
<li><a href='#ex_data_table_step.relop_rename_columns'><p>Rename columns.</p></a></li>
<li><a href='#ex_data_table_step.relop_select_columns'><p>Implement drop columns.</p></a></li>
<li><a href='#ex_data_table_step.relop_select_rows'><p>Select rows by condition.</p></a></li>
<li><a href='#ex_data_table_step.relop_set_indicator'><p>Implement set_indicatoroperator.</p></a></li>
<li><a href='#ex_data_table_step.relop_sql'><p>Direct sql node.</p></a></li>
<li><a href='#ex_data_table_step.relop_table_source'><p>Build a data source description.</p></a></li>
<li><a href='#ex_data_table_step.relop_theta_join'><p>Theta join (database implementation).</p></a></li>
<li><a href='#ex_data_table_step.relop_unionall'><p>Bind tables together by rows.</p></a></li>
<li><a href='#layout_to_blocks_data_table'><p>Map a data records from row records to block records with one record row per columnsToTakeFrom value.</p></a></li>
<li><a href='#layout_to_rowrecs_data_table'><p>Map data records from block records that have one row per measurement value to row records.</p></a></li>
<li><a href='#make_dt_lookup_by_column'><p>Lookup by column function factory.</p></a></li>
<li><a href='#rbindlist_data_table'><p>rbindlist</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rq_df_funciton_node'><p>Helper to build data.table capable non-sql nodes.</p></a></li>
<li><a href='#rq_df_grouped_funciton_node'><p>Helper to build data.table capable non-sql nodes.</p></a></li>
<li><a href='#set_rqdatatable_as_executor'><p>Set rqdatatable package as default rquery executor</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'rquery' for 'data.table'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Mount &lt;jmount@win-vector.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the 'rquery' piped Codd-style query algebra using 'data.table'.  This allows
   for a high-speed in memory implementation of Codd-style data manipulation tools.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/WinVector/rqdatatable/">https://github.com/WinVector/rqdatatable/</a>,
<a href="https://winvector.github.io/rqdatatable/">https://winvector.github.io/rqdatatable/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/WinVector/rqdatatable/issues">https://github.com/WinVector/rqdatatable/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), wrapr (&ge; 2.0.9), rquery (&ge; 1.4.9)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.12.2)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, DBI, RSQLite, parallel, tinytest</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 05:23:02 UTC; johnmount</td>
</tr>
<tr>
<td>Author:</td>
<td>John Mount [aut, cre],
  Win-Vector LLC [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rqdatatable-package'><code>rqdatatable</code>: Relational Query Generator for Data Manipulation Implemented by data.table</h2><span id='topic+rqdatatable'></span><span id='topic+rqdatatable-package'></span>

<h3>Description</h3>

<p>Implements the <code>rquery</code> piped query algebra using <code>data.table</code>.  This allows
for a high-speed in memory implementation of Codd-style data manipulation tools.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Mount <a href="mailto:jmount@win-vector.com">jmount@win-vector.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p>  Win-Vector LLC [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/WinVector/rqdatatable/">https://github.com/WinVector/rqdatatable/</a>
</p>
</li>
<li> <p><a href="https://winvector.github.io/rqdatatable/">https://winvector.github.io/rqdatatable/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/WinVector/rqdatatable/issues">https://github.com/WinVector/rqdatatable/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ex_data_table'>Execute an <code>rquery</code> pipeline with <code>data.table</code> sources.</h2><span id='topic+ex_data_table'></span>

<h3>Description</h3>

<p><code>data.table</code>s are looked for by name in the <code>tables</code> argument and in the execution environment.
Main external execution interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_data_table(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+ex_data_table_step.relop_drop_columns">ex_data_table_step.relop_drop_columns</a></code>: implement drop columns
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_extend">ex_data_table_step.relop_extend</a></code>: implement extend/assign operator
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_natural_join">ex_data_table_step.relop_natural_join</a></code>: implement natural join
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_non_sql">ex_data_table_step.relop_non_sql</a></code>: direct function (non-sql) operator (not implemented for <code>data.table</code>)
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_null_replace">ex_data_table_step.relop_null_replace</a></code>: implement NA/NULL replacement
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_orderby">ex_data_table_step.relop_orderby</a></code>: implement row ordering
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_project">ex_data_table_step.relop_project</a></code>: implement row ordering
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_rename_columns">ex_data_table_step.relop_rename_columns</a></code>: implement column renaming
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_select_columns">ex_data_table_step.relop_select_columns</a></code>: implement select columns
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_select_rows">ex_data_table_step.relop_select_rows</a></code>: implement select rows
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_sql">ex_data_table_step.relop_sql</a></code>: direct sql operator (not implemented for <code>data.table</code>)
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_table_source">ex_data_table_step.relop_table_source</a></code>: implement data source
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_theta_join">ex_data_table_step.relop_theta_join</a></code>: implement theta join  (not implemented for <code>data.table</code>)
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_unionall">ex_data_table_step.relop_unionall</a></code>: implement row binding
</p>
</li></ul>



<h3>Value</h3>

<p>resulting data.table (intermediate tables can somtimes be mutated as is practice with data.table).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  a &lt;- data.table::data.table(x = c(1, 2) , y = c(20, 30), z = c(300, 400))
  optree &lt;- local_td(a) %.&gt;%
     select_columns(., c("x", "y")) %.&gt;%
     select_rows_nse(., x&lt;2 &amp; y&lt;30)
  cat(format(optree))
  ex_data_table(optree)

  # other ways to execute the pipeline include
  data.frame(x = 0, y = 4, z = 400) %.&gt;% optree


</code></pre>

<hr>
<h2 id='ex_data_table_parallel'>Execute an <code>rquery</code> pipeline with <code>data.table</code> in parallel.</h2><span id='topic+ex_data_table_parallel'></span>

<h3>Description</h3>

<p>Execute an <code>rquery</code> pipeline with <code>data.table</code> in parallel, partitioned by a given column.
Note: usually the overhead of partitioning and distributing the work will by far overwhelm any parallel speedup.
Also <code>data.table</code> itself already seems to exploit some thread-level parallelism (one often sees user time &gt; elapsed time).
Requires the <code>parallel</code> package.  For a worked example with significant speedup please see <a href="https://github.com/WinVector/rqdatatable/blob/master/extras/Parallel_rqdatatable.md">https://github.com/WinVector/rqdatatable/blob/master/extras/Parallel_rqdatatable.md</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_data_table_parallel(
  optree,
  partition_column,
  cl = NULL,
  ...,
  tables = list(),
  source_limit = NULL,
  debug = FALSE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_parallel_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_parallel_+3A_partition_column">partition_column</code></td>
<td>
<p>character name of column to partition work by.</p>
</td></tr>
<tr><td><code id="ex_data_table_parallel_+3A_cl">cl</code></td>
<td>
<p>a cluster object, created by package parallel or by package snow. If NULL, use the registered default cluster.</p>
</td></tr>
<tr><td><code id="ex_data_table_parallel_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_parallel_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_parallel_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_parallel_+3A_debug">debug</code></td>
<td>
<p>logical if TRUE use lapply instead of parallel::clusterApplyLB.</p>
</td></tr>
<tr><td><code id="ex_data_table_parallel_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Care must be taken that the calculation partitioning is course enough to ensure a correct calculation.  For example: anything
one is joining on, aggregating over, or ranking over must be grouped so that all elements affecting a given result row are
in the same level of the partition.
</p>


<h3>Value</h3>

<p>resulting data.table (intermediate tables can sometimes be mutated as is practice with data.table).
</p>

<hr>
<h2 id='ex_data_table_step'>Execute an <code>rquery</code> pipeline with <code>data.table</code> sources.</h2><span id='topic+ex_data_table_step'></span>

<h3>Description</h3>

<p><code>data.table</code>s are looked for by name in the <code>tables</code> argument and in the execution environment.
Internal execution interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+ex_data_table_step.relop_drop_columns">ex_data_table_step.relop_drop_columns</a></code>: implement drop columns
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_extend">ex_data_table_step.relop_extend</a></code>: implement extend/assign operator
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_natural_join">ex_data_table_step.relop_natural_join</a></code>: implement natural join
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_non_sql">ex_data_table_step.relop_non_sql</a></code>: direct function (non-sql) operator (not implemented for <code>data.table</code>)
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_null_replace">ex_data_table_step.relop_null_replace</a></code>: implement NA/NULL replacement
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_orderby">ex_data_table_step.relop_orderby</a></code>: implement row ordering
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_project">ex_data_table_step.relop_project</a></code>: implement row ordering
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_rename_columns">ex_data_table_step.relop_rename_columns</a></code>: implement column renaming
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_select_columns">ex_data_table_step.relop_select_columns</a></code>: implement select columns
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_select_rows">ex_data_table_step.relop_select_rows</a></code>: implement select rows
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_sql">ex_data_table_step.relop_sql</a></code>: direct sql operator (not implemented for <code>data.table</code>)
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_table_source">ex_data_table_step.relop_table_source</a></code>: implement data source
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_theta_join">ex_data_table_step.relop_theta_join</a></code>: implement theta join  (not implemented for <code>data.table</code>)
</p>
</li>
<li> <p><code><a href="#topic+ex_data_table_step.relop_unionall">ex_data_table_step.relop_unionall</a></code>: implement row binding
</p>
</li></ul>



<h3>Value</h3>

<p>resulting data.table (intermediate tables can somtimes be mutated as is practice with data.table).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  a &lt;- data.table::data.table(x = c(1, 2) , y = c(20, 30), z = c(300, 400))
  optree &lt;- local_td(a) %.&gt;%
     select_columns(., c("x", "y")) %.&gt;%
     select_rows_nse(., x&lt;2 &amp; y&lt;30)
  cat(format(optree))
  ex_data_table_step(optree)

  # other ways to execute the pipeline include
  ex_data_table(optree)
  data.frame(x = 0, y = 4, z = 400) %.&gt;% optree


</code></pre>

<hr>
<h2 id='ex_data_table_step.default'>default non-impementation.</h2><span id='topic+ex_data_table_step.default'></span>

<h3>Description</h3>

<p>Throw on error if this method is called, signalling that a specific <code>data.table</code> implemetation is needed for this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.default_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.default_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.default_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.default_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.default_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.default_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>

<hr>
<h2 id='ex_data_table_step.relop_drop_columns'>Implement drop columns.</h2><span id='topic+ex_data_table_step.relop_drop_columns'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_drop_columns'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_limit = NULL,
  source_usage = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_drop_columns_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_drop_columns_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_drop_columns_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_drop_columns_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_drop_columns_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_drop_columns_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- data.frame(x = 1, y = 2, z = 3)
rquery_pipeline &lt;- local_td(dL) %.&gt;%
  drop_columns(., "y")
dL %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_extend'>Implement extend/assign operator.</h2><span id='topic+ex_data_table_step.relop_extend'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_extend'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_extend_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_extend_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_extend_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_extend_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_extend_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_extend_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Will re-order columns if there are ordering terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- build_frame(
    "subjectID", "surveyCategory"     , "assessmentTotal", "one" |
    1          , "withdrawal behavior", 5                , 1     |
    1          , "positive re-framing", 2                , 1     |
    2          , "withdrawal behavior", 3                , 1     |
    2          , "positive re-framing", 4                , 1     )
rquery_pipeline &lt;- local_td(dL) %.&gt;%
  extend_nse(.,
             probability %:=%
               exp(assessmentTotal * 0.237)/
               sum(exp(assessmentTotal * 0.237)),
             count %:=% sum(one),
             rank %:=% rank(),
             orderby = c("assessmentTotal", "surveyCategory"),
             reverse = c("assessmentTotal"),
             partitionby = 'subjectID') %.&gt;%
  orderby(., c("subjectID", "probability"))
dL %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_natural_join'>Natural join.</h2><span id='topic+ex_data_table_step.relop_natural_join'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_natural_join'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_natural_join_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_natural_join_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_natural_join_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_natural_join_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_natural_join_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_natural_join_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
d1 &lt;- build_frame(
    "key", "val", "val1" |
      "a"  , 1  ,  10    |
      "b"  , 2  ,  11    |
      "c"  , 3  ,  12    )
d2 &lt;- build_frame(
    "key", "val", "val2" |
      "a"  , 5  ,  13    |
      "b"  , 6  ,  14    |
      "d"  , 7  ,  15    )

# key matching join
optree &lt;- natural_join(local_td(d1), local_td(d2),
                       jointype = "FULL", by = 'key')
ex_data_table(optree)

# full cross-product join
# (usually with jointype = "FULL", but "LEFT" is more
# compatible with rquery field merge semantics).
optree2 &lt;- natural_join(local_td(d1), local_td(d2),
                        jointype = "LEFT", by = NULL)
ex_data_table(optree2)
# notice ALL non-"by" fields take coalese to left table.

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_non_sql'>Direct non-sql (function) node, not implemented for <code>data.table</code> case.</h2><span id='topic+ex_data_table_step.relop_non_sql'></span>

<h3>Description</h3>

<p>Passes a single table to a function that takes a single data.frame as its argument, and returns a single data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_non_sql'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_non_sql_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_non_sql_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_non_sql_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_non_sql_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_non_sql_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_non_sql_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rq_df_funciton_node">rq_df_funciton_node</a></code>, <code><a href="#topic+rq_df_grouped_funciton_node">rq_df_grouped_funciton_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(3252)
d &lt;- data.frame(a = rnorm(1000), b = rnorm(1000))

optree &lt;- local_td(d) %.&gt;%
  quantile_node(.)
d %.&gt;% optree

p2 &lt;- local_td(d) %.&gt;%
  rsummary_node(.)
d %.&gt;% p2

summary(d)

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_null_replace'>Replace NAs.</h2><span id='topic+ex_data_table_step.relop_null_replace'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_null_replace'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_null_replace_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_null_replace_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_null_replace_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_null_replace_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_null_replace_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_null_replace_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- build_frame(
    "x", "y" |
    2L ,  5  |
    NA ,  7  |
    NA , NA )
rquery_pipeline &lt;- local_td(dL) %.&gt;%
  null_replace(., c("x", "y"), 0, note_col = "nna")
dL %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_order_expr'>Order rows by expression.</h2><span id='topic+ex_data_table_step.relop_order_expr'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_order_expr'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_order_expr_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_order_expr_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_order_expr_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_order_expr_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_order_expr_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_order_expr_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- build_frame(
    "x", "y" |
    2L , "b" |
   -4L , "a" |
    3L , "c" )
rquery_pipeline &lt;- local_td(dL) %.&gt;%
  order_expr(., abs(x))
dL %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_orderby'>Reorder rows.</h2><span id='topic+ex_data_table_step.relop_orderby'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_orderby'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_orderby_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_orderby_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_orderby_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_orderby_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_orderby_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_orderby_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- build_frame(
    "x", "y" |
    2L , "b" |
    1L , "a" |
    3L , "c" )
rquery_pipeline &lt;- local_td(dL) %.&gt;%
  orderby(., "y")
dL %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_project'>Implement projection operator.</h2><span id='topic+ex_data_table_step.relop_project'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_project'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_project_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_project_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_project_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_project_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_project_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_project_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- build_frame(
  "subjectID", "surveyCategory"     , "assessmentTotal" |
    1          , "withdrawal behavior", 5                 |
    1          , "positive re-framing", 2                 |
    2          , "withdrawal behavior", 3                 |
    2          , "positive re-framing", 4                 )
test_p &lt;- local_td(dL) %.&gt;%
  project(.,
          maxscore := max(assessmentTotal),
          count := n(),
          groupby = 'subjectID')
cat(format(test_p))
dL %.&gt;% test_p

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_rename_columns'>Rename columns.</h2><span id='topic+ex_data_table_step.relop_rename_columns'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_rename_columns'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_rename_columns_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_rename_columns_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_rename_columns_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_rename_columns_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_rename_columns_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_rename_columns_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- build_frame(
    "x", "y" |
    2L , "b" |
    1L , "a" |
    3L , "c" )
rquery_pipeline &lt;- local_td(dL) %.&gt;%
  rename_columns(., c("x" = "y", "y" = "x"))
dL %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_select_columns'>Implement drop columns.</h2><span id='topic+ex_data_table_step.relop_select_columns'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_select_columns'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_select_columns_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_select_columns_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_select_columns_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_select_columns_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_select_columns_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_select_columns_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- data.frame(x = 1, y = 2, z = 3)
rquery_pipeline &lt;- local_td(dL) %.&gt;%
  select_columns(., "y")
dL %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_select_rows'>Select rows by condition.</h2><span id='topic+ex_data_table_step.relop_select_rows'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_select_rows'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_select_rows_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_select_rows_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_select_rows_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_select_rows_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_select_rows_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_select_rows_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- build_frame(
    "x", "y" |
    2L , "b" |
    1L , "a" |
    3L , "c" )
rquery_pipeline &lt;- local_td(dL) %.&gt;%
  select_rows_nse(., x &lt;= 2)
dL %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_set_indicator'>Implement set_indicatoroperator.</h2><span id='topic+ex_data_table_step.relop_set_indicator'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_set_indicator'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_set_indicator_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_set_indicator_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_set_indicator_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_set_indicator_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_set_indicator_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_set_indicator_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(a = c("1", "2", "1", "3"),
                b = c("1", "1", "3", "2"),
                q = 1,
                stringsAsFactors = FALSE)
set &lt;- c("1", "2")
op_tree &lt;- local_td(d) %.&gt;%
  set_indicator(., "one_two", "a", set) %.&gt;%
  set_indicator(., "z", "a", c())
d %.&gt;% op_tree


</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_sql'>Direct sql node.</h2><span id='topic+ex_data_table_step.relop_sql'></span>

<h3>Description</h3>

<p>Execute one step using the rquery.rquery_db_executor SQL supplier.  Note: it is not
a good practice to use SQL nodes in data.table intended pipelines (loss of class information and
cost of data transfer).  This implementation is only here for completeness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_sql'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_sql_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_sql_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_sql_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_sql_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_sql_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_sql_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# WARNING: example tries to change rquery.rquery_db_executor option to RSQLite and back.
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
    requireNamespace("RSQLite", quietly = TRUE)) {
  # example database connection
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(),
                          ":memory:")
  old_o &lt;- options(list("rquery.rquery_db_executor" = list(db = my_db)))

  # example data
  d &lt;- data.frame(v1 = c(1, 2, NA, 3),
                  v2 = c(NA, "b", NA, "c"),
                  v3 = c(NA, NA, 7, 8),
                  stringsAsFactors = FALSE)

  # example xform
  vars &lt;- column_names(d)
  # build a NA/NULLs per-row counting expression.
  # names are "quoted" by wrapping them with as.name().
  # constants can be quoted by an additional list wrapping.
  expr &lt;- lapply(vars,
                 function(vi) {
                   list("+ (CASE WHEN (",
                        as.name(vi),
                        "IS NULL ) THEN 1.0 ELSE 0.0 END)")
                 })
  expr &lt;- unlist(expr, recursive = FALSE)
  expr &lt;- c(list(0.0), expr)

  # instantiate the operator node
  op_tree &lt;- local_td(d) %.&gt;%
    sql_node(., "num_missing" %:=% list(expr))
  cat(format(op_tree))

  d %.&gt;% op_tree

  options(old_o)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_table_source'>Build a data source description.</h2><span id='topic+ex_data_table_step.relop_table_source'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
Looks for tables first in <code>tables</code> and then in <code>env</code>.
Will accept any <code>data.frame</code> that can
be converted to <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_table_source'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_table_source_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_table_source_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_table_source_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_table_source_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_table_source_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_table_source_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- build_frame(
    "x", "y" |
    2L , "b" |
    1L , "a" |
    3L , "c" )
rquery_pipeline &lt;- local_td(dL)
dL %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_theta_join'>Theta join (database implementation).</h2><span id='topic+ex_data_table_step.relop_theta_join'></span>

<h3>Description</h3>

<p>Limited implementation.  All terms must be of the form: &quot;(table1.col CMP table2.col) (, (table1.col CMP table2.col) )&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_theta_join'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_theta_join_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_theta_join_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_theta_join_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_theta_join_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_theta_join_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_theta_join_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
 d1 &lt;- data.frame(AUC = 0.6, R2 = 0.2)
 d2 &lt;- data.frame(AUC2 = 0.4, R2 = 0.3)

 optree &lt;- theta_join_se(local_td(d1), local_td(d2), "AUC &gt;= AUC2")

 ex_data_table(optree, tables = list(d1 = d1, d2 = d2)) %.&gt;%
   print(.)

</code></pre>

<hr>
<h2 id='ex_data_table_step.relop_unionall'>Bind tables together by rows.</h2><span id='topic+ex_data_table_step.relop_unionall'></span>

<h3>Description</h3>

<p><code>data.table</code> based implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop_unionall'
ex_data_table_step(
  optree,
  ...,
  tables = list(),
  source_usage = NULL,
  source_limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_data_table_step.relop_unionall_+3A_optree">optree</code></td>
<td>
<p>relop operations tree.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_unionall_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_unionall_+3A_tables">tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_unionall_+3A_source_usage">source_usage</code></td>
<td>
<p>list mapping source table names to vectors of columns used.</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_unionall_+3A_source_limit">source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td></tr>
<tr><td><code id="ex_data_table_step.relop_unionall_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dL &lt;- build_frame(
    "x", "y" |
    2L , "b" |
    1L , "a" |
    3L , "c" )
rquery_pipeline &lt;- unionall(list(local_td(dL), local_td(dL)))
dL %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='layout_to_blocks_data_table'>Map a data records from row records to block records with one record row per columnsToTakeFrom value.</h2><span id='topic+layout_to_blocks_data_table'></span>

<h3>Description</h3>

<p>Map a data records from row records (records that are exactly single rows) to block records
(records that may be more than one row).  All columns not named in columnsToTakeFrom are copied to each
record row in the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_to_blocks_data_table(
  data,
  ...,
  nameForNewKeyColumn,
  nameForNewValueColumn,
  columnsToTakeFrom,
  columnsToCopy = setdiff(colnames(data), columnsToTakeFrom)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_to_blocks_data_table_+3A_data">data</code></td>
<td>
<p>data.frame to work with.</p>
</td></tr>
<tr><td><code id="layout_to_blocks_data_table_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="layout_to_blocks_data_table_+3A_namefornewkeycolumn">nameForNewKeyColumn</code></td>
<td>
<p>character name of column to write new keys in.</p>
</td></tr>
<tr><td><code id="layout_to_blocks_data_table_+3A_namefornewvaluecolumn">nameForNewValueColumn</code></td>
<td>
<p>character name of column to write new values in.</p>
</td></tr>
<tr><td><code id="layout_to_blocks_data_table_+3A_columnstotakefrom">columnsToTakeFrom</code></td>
<td>
<p>character array names of columns to take values from.</p>
</td></tr>
<tr><td><code id="layout_to_blocks_data_table_+3A_columnstocopy">columnsToCopy</code></td>
<td>
<p>character array names of columns to copy.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new data.frame with values moved to rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(d &lt;- wrapr::build_frame(
  "id"  , "id2", "AUC", "R2" |
    1   , "a"  , 0.7  , 0.4  |
    2   , "b"  , 0.8  , 0.5  ))

(layout_to_blocks_data_table(
  d,
  nameForNewKeyColumn = "measure",
  nameForNewValueColumn = "value",
  columnsToTakeFrom = c("AUC", "R2"),
  columnsToCopy = c("id", "id2")))


</code></pre>

<hr>
<h2 id='layout_to_rowrecs_data_table'>Map data records from block records that have one row per measurement value to row records.</h2><span id='topic+layout_to_rowrecs_data_table'></span>

<h3>Description</h3>

<p>Map data records from block records (where each record may be more than one row) to
row records (where each record is a single row).  Values specified in rowKeyColumns
determine which sets of rows build up records and are copied into the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_to_rowrecs_data_table(
  data,
  ...,
  columnToTakeKeysFrom,
  columnToTakeValuesFrom,
  rowKeyColumns,
  sep = "_"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_to_rowrecs_data_table_+3A_data">data</code></td>
<td>
<p>data.frame to work with (must be local, for remote please try <code>moveValuesToColumns*</code>).</p>
</td></tr>
<tr><td><code id="layout_to_rowrecs_data_table_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="layout_to_rowrecs_data_table_+3A_columntotakekeysfrom">columnToTakeKeysFrom</code></td>
<td>
<p>character name of column build new column names from.</p>
</td></tr>
<tr><td><code id="layout_to_rowrecs_data_table_+3A_columntotakevaluesfrom">columnToTakeValuesFrom</code></td>
<td>
<p>character name of column to get values from.</p>
</td></tr>
<tr><td><code id="layout_to_rowrecs_data_table_+3A_rowkeycolumns">rowKeyColumns</code></td>
<td>
<p>character array names columns that should be table keys.</p>
</td></tr>
<tr><td><code id="layout_to_rowrecs_data_table_+3A_sep">sep</code></td>
<td>
<p>character if not null build more detailed column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new data.frame with values moved to columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(d2 &lt;- wrapr::build_frame(
  "id"  , "id2", "measure", "value" |
    1   , "a"  , "AUC"    , 0.7     |
    2   , "b"  , "AUC"    , 0.8     |
    1   , "a"  , "R2"     , 0.4     |
    2   , "b"  , "R2"     , 0.5     ))

(layout_to_rowrecs_data_table(d2,
                             columnToTakeKeysFrom = "measure",
                             columnToTakeValuesFrom = "value",
                             rowKeyColumns = c("id", "id2")))

</code></pre>

<hr>
<h2 id='make_dt_lookup_by_column'>Lookup by column function factory.</h2><span id='topic+make_dt_lookup_by_column'></span>

<h3>Description</h3>

<p>Build data.table implementation of lookup_by_column.  We do this here as rqdatatable is
a data.table aware package (and rquery is not).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dt_lookup_by_column(pick, result)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_dt_lookup_by_column_+3A_pick">pick</code></td>
<td>
<p>character scalar, name of column to control value choices.</p>
</td></tr>
<tr><td><code id="make_dt_lookup_by_column_+3A_result">result</code></td>
<td>
<p>character scalar, name of column to place values in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>f_dt() function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df = data.frame(x = c(1, 2, 3, 4),
                y = c(5, 6, 7, 8),
                choice = c("x", "y", "x", "z"),
                stringsAsFactors = FALSE)
make_dt_lookup_by_column("choice", "derived")(df)

# # base-R implementation
# df %.&gt;% lookup_by_column(., "choice", "derived")
# # # data.table implementation (requies rquery 1.1.0, or newer)
# # df %.&gt;% lookup_by_column(., "choice", "derived",
# #                          f_dt_factory = rqdatatable::make_dt_lookup_by_column)

</code></pre>

<hr>
<h2 id='rbindlist_data_table'>rbindlist</h2><span id='topic+rbindlist_data_table'></span>

<h3>Description</h3>

<p>Note: different argument defaults than data.table::rbindlist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbindlist_data_table(l, use.names = TRUE, fill = TRUE, idcol = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbindlist_data_table_+3A_l">l</code></td>
<td>
<p>list of data.frames to rbind.</p>
</td></tr>
<tr><td><code id="rbindlist_data_table_+3A_use.names">use.names</code></td>
<td>
<p>passed to data.table</p>
</td></tr>
<tr><td><code id="rbindlist_data_table_+3A_fill">fill</code></td>
<td>
<p>passed to data.table</p>
</td></tr>
<tr><td><code id="rbindlist_data_table_+3A_idcol">idcol</code></td>
<td>
<p>passed to data.table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rbindlist_data_table(list(
  data.frame(x = 1, y = 2),
  data.frame(x = c(2, 3), y = c(NA, 4))))

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+as.data.table'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+as.data.table">as.data.table</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rq_df_funciton_node'>Helper to build data.table capable non-sql nodes.</h2><span id='topic+rq_df_funciton_node'></span>

<h3>Description</h3>

<p>Helper to build data.table capable non-sql nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_df_funciton_node(
  .,
  f,
  ...,
  f_db = NULL,
  columns_produced,
  display_form,
  orig_columns = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rq_df_funciton_node_+3A_.">.</code></td>
<td>
<p>or data.frame input.</p>
</td></tr>
<tr><td><code id="rq_df_funciton_node_+3A_f">f</code></td>
<td>
<p>function that takes a data.table to a data.frame (or data.table).</p>
</td></tr>
<tr><td><code id="rq_df_funciton_node_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="rq_df_funciton_node_+3A_f_db">f_db</code></td>
<td>
<p>implementation signature: f_db(db, incoming_table_name, outgoing_table_name, nd, ...) (db being a database handle). NULL defaults to using f.</p>
</td></tr>
<tr><td><code id="rq_df_funciton_node_+3A_columns_produced">columns_produced</code></td>
<td>
<p>character columns produces by f.</p>
</td></tr>
<tr><td><code id="rq_df_funciton_node_+3A_display_form">display_form</code></td>
<td>
<p>display form for node.</p>
</td></tr>
<tr><td><code id="rq_df_funciton_node_+3A_orig_columns">orig_columns</code></td>
<td>
<p>orig_columns, if TRUE assume all input columns are present in derived table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>relop non-sql node implementation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ex_data_table_step.relop_non_sql">ex_data_table_step.relop_non_sql</a></code>, <code><a href="#topic+rq_df_grouped_funciton_node">rq_df_grouped_funciton_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a node generator is something an expert can
# write and part-time R users can use.
grouped_regression_node &lt;- function(., group_col = "group", xvar = "x", yvar = "y") {
  force(group_col)
  formula_str &lt;- paste(yvar, "~", xvar)
  f &lt;- function(df, nd = NULL) {
    dlist &lt;- split(df, df[[group_col]])
    clist &lt;- lapply(dlist,
                    function(di) {
                      mi &lt;- lm(as.formula(formula_str), data = di)
                      ci &lt;- as.data.frame(summary(mi)$coefficients)
                      ci$Variable &lt;- rownames(ci)
                      rownames(ci) &lt;- NULL
                      ci[[group_col]] &lt;- di[[group_col]][[1]]
                      ci
                    })
    data.table::rbindlist(clist)
  }
  columns_produced =
     c("Variable", "Estimate", "Std. Error", "t value", "Pr(&gt;|t|)", group_col)
  rq_df_funciton_node(
    ., f,
    columns_produced = columns_produced,
    display_form = paste0(yvar, "~", xvar, " grouped by ", group_col))
}

# work an example
set.seed(3265)
d &lt;- data.frame(x = rnorm(1000),
                y = rnorm(1000),
                group = sample(letters[1:5], 1000, replace = TRUE),
                stringsAsFactors = FALSE)

rquery_pipeline &lt;- local_td(d) %.&gt;%
  grouped_regression_node(.)

cat(format(rquery_pipeline))

d %.&gt;% rquery_pipeline

</code></pre>

<hr>
<h2 id='rq_df_grouped_funciton_node'>Helper to build data.table capable non-sql nodes.</h2><span id='topic+rq_df_grouped_funciton_node'></span>

<h3>Description</h3>

<p>Helper to build data.table capable non-sql nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_df_grouped_funciton_node(
  .,
  f,
  ...,
  f_db = NULL,
  columns_produced,
  group_col,
  display_form
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rq_df_grouped_funciton_node_+3A_.">.</code></td>
<td>
<p>or data.frame input.</p>
</td></tr>
<tr><td><code id="rq_df_grouped_funciton_node_+3A_f">f</code></td>
<td>
<p>function that takes a data.table to a data.frame (or data.table).</p>
</td></tr>
<tr><td><code id="rq_df_grouped_funciton_node_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="rq_df_grouped_funciton_node_+3A_f_db">f_db</code></td>
<td>
<p>implementation signature: f_db(db, incoming_table_name, outgoing_table_name) (db being a database handle). NULL defaults to using f.</p>
</td></tr>
<tr><td><code id="rq_df_grouped_funciton_node_+3A_columns_produced">columns_produced</code></td>
<td>
<p>character columns produces by f.</p>
</td></tr>
<tr><td><code id="rq_df_grouped_funciton_node_+3A_group_col">group_col</code></td>
<td>
<p>character, column to split by.</p>
</td></tr>
<tr><td><code id="rq_df_grouped_funciton_node_+3A_display_form">display_form</code></td>
<td>
<p>display form for node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>relop non-sql node implementation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ex_data_table_step.relop_non_sql">ex_data_table_step.relop_non_sql</a></code>, <code><a href="#topic+rq_df_funciton_node">rq_df_funciton_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a node generator is something an expert can
# write and part-time R users can use.
grouped_regression_node &lt;- function(., group_col = "group", xvar = "x", yvar = "y") {
  force(group_col)
  formula_str &lt;- paste(yvar, "~", xvar)
  f &lt;- function(di) {
    mi &lt;- lm(as.formula(formula_str), data = di)
    ci &lt;- as.data.frame(summary(mi)$coefficients)
    ci$Variable &lt;- rownames(ci)
    rownames(ci) &lt;- NULL
    colnames(ci) &lt;- c("Estimate", "Std_Error", "t_value", "p_value", "Variable")
    ci
  }
  columns_produced =
    c("Estimate", "Std_Error", "t_value", "p_value", "Variable", group_col)
  rq_df_grouped_funciton_node(
    ., f,
    columns_produced = columns_produced,
    group_col = group_col,
    display_form = paste0(yvar, "~", xvar, " grouped by ", group_col))
}

# work an example
set.seed(3265)
d &lt;- data.frame(x = rnorm(1000),
                y = rnorm(1000),
                group = sample(letters[1:5], 1000, replace = TRUE),
                stringsAsFactors = FALSE)

rquery_pipeline &lt;- local_td(d) %.&gt;%
  grouped_regression_node(.)

cat(format(rquery_pipeline))

d %.&gt;% rquery_pipeline


</code></pre>

<hr>
<h2 id='set_rqdatatable_as_executor'>Set rqdatatable package as default rquery executor</h2><span id='topic+set_rqdatatable_as_executor'></span>

<h3>Description</h3>

<p>Sets rqdatatable (and hence data.table) as the default executor for rquery).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_rqdatatable_as_executor()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
