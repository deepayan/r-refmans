<!DOCTYPE html><html lang="en"><head><title>Help for package eiopt2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eiopt2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#eiopt2'><p>Ecological Inference for RxC Tables via Simultaneous Minimization of Euclidean Row-Standardized Unit-to-Global Distances</p></a></li>
<li><a href='#plot.eiopt2'><p>Graphical representation of a RxC ecological inference (vote transfer) matrix</p></a></li>
<li><a href='#print.eiopt2'><p>Print a summary of an output of the eiopt2 function</p></a></li>
<li><a href='#print.summary.eiopt2'><p>Print a summary of a summary.eiopt2 object</p></a></li>
<li><a href='#summary.eiopt2'><p>Summarize an eiopt2 output object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ecological Inference for RxC Tables via Nonlinear Quadratic
Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1-6</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates RxC (R by C) vote transfer matrices (ecological contingency tables) 
             from aggregate data by simultaneously minimizing Euclidean row-standardized 
             unit-to-global distances.
             Acknowledgements:
             The authors wish to thank Generalitat Valenciana, Consellería de Educación, Cultura, Universidades y Empleo (grant CIAICO/2023/031) for supporting this research.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>alabama, quadprog</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, scales</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-26 19:58:38 UTC; mariaamparo</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose M. Pavía <a href="https://orcid.org/0000-0002-0129-726X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Fernández Victor <a href="https://orcid.org/0000-0002-0595-516X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose M. Pavía &lt;jose.m.pavia@uv.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-27 17:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='eiopt2'>Ecological Inference for RxC Tables via Simultaneous Minimization of Euclidean Row-Standardized Unit-to-Global Distances</h2><span id='topic+eiopt2'></span>

<h3>Description</h3>

<p>Estimates RxC vote transfer matrices (ecological contingency tables) from aggregate data by simultaneously minimizing Euclidean row-standardized unit-to-global distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eiopt2(
  votes.election1,
  votes.election2,
  weights = "row",
  census.changes = c("adjust2", "raw", "simultaneous", "regular", "ordinary", "enriched",
    "adjust1", "semifull", "full", "fullreverse", "gold"),
  weights.init = "constant",
  eps = 1e-04,
  ilack.max = 1,
  trace = FALSE,
  kkt2.check = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eiopt2_+3A_votes.election1">votes.election1</code></td>
<td>
<p>data.frame (or matrix) of order NxR1 with the votes gained by
(or the counts corresponding to) the R1 (row options) political options competing
(available) on election 1 (or origin) in the N units considered. In general, the row margins
of the N tables corresponding to the units.</p>
</td></tr>
<tr><td><code id="eiopt2_+3A_votes.election2">votes.election2</code></td>
<td>
<p>data.frame (or matrix) of order NxC2 with the votes gained by
(or the counts corresponding to) the C2 (column options) political options competing
(available) on election 2 (or destination) in the N units considered.
In general, the column margins of the N tables corresponding to the units.</p>
</td></tr>
<tr><td><code id="eiopt2_+3A_weights">weights</code></td>
<td>
<p>Weights to be used to ponder in the restricted minimization problem the distances between
row-standardized proportions of individual units and the global row-standardized proportions.
<code>weights</code> can be provided as a vector of length <code>N</code>, a matrix of order <code>NxR</code> (or order <code>NxR1</code>),
or a character string from the set {<code>"constant"</code>, <code>"size"</code>, <code>"row"</code>}. When <code>weights</code> is a vector
of length <code>N</code>, all the proportions of unit i are weighted by the ith coordinate of <code>weights</code>.
For instance, <code>weights = "size"</code> assigns the number of votes in each unit as <code>weight</code>.
When <code>weights</code> is a matrix of size <code>NxR</code>, the rth row of the ith unit receives as weight the
(i,r) cell of the matrix. For instance, weights = &quot;row&quot; is equivalent to defining <code>weights</code>
as the matrix <code>votes.election1</code>. When <code>weights = "constant"</code> all the proportions are assigned
equal weight. Default, <code>"row"</code>.</p>
</td></tr>
<tr><td><code id="eiopt2_+3A_census.changes">census.changes</code></td>
<td>
<p>A character string informing about the level of information available
in <code>votes.election1</code> and <code>votes.election2</code> regarding new entries
and exits of the election censuses between the two elections or
indicating how their sum discrepancies should be handled.
This argument allows eleven options; the eight options discussed in Pavia (2023)
as well as two adjusting options and the mirror option of <code>full</code>. The options are:
<code>adjust2</code>, <code>raw</code>, <code>simultaneous</code>, <code>regular</code>, <code>ordinary</code>, <code>adjust1</code>,
<code>enriched</code>, <code>semifull</code>, <code>full</code>, <code>fullreverse</code> and <code>gold</code>. See <strong>Details</strong>.
Default, <code>adjust2</code>.</p>
</td></tr>
<tr><td><code id="eiopt2_+3A_weights.init">weights.init</code></td>
<td>
<p>Weights to be used to estimate the initial crude table of global proportions
using quadratic programming. These weights ponder the unit residuals between the
observed column margin votes and the expected column margin votes when the estimated
global row-standardized proportions are applied to the observed row margins.
The value of this argument is typically a character string chosen from the set
{<code>"constant"</code>, <code>"size"</code>, <code>"row"</code>}. Default, <code>weights.init = "constant"</code>.
When <code>weights.init = "constant"</code>, unit residuals are not weighted. When
<code>weights.init = "size"</code>, each unit residual is weighted with the number of eligible
voters of the unit. When <code>weights.init = "row"</code>, global row-standardized proportions
are estimated using absolute number of votes without any weight.
<code>weights.init = "size"</code> is used when <code>weights.init</code> is the vector defined in <code>weights</code>
and <code>weights.init = "row"</code> when <code>weights.init</code> is the matrix defined in <code>weights</code>.</p>
</td></tr>
<tr><td><code id="eiopt2_+3A_eps">eps</code></td>
<td>
<p>A positive real number indicating the tolerance for convergence of outer iterations of the barrier
and/or augmented Lagrangian algorithm to be used for the function <code>auglag</code> of the package <code>alabama</code>
on which this function relies on. Default, <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="eiopt2_+3A_ilack.max">ilack.max</code></td>
<td>
<p>A positive integer number indicating the maximum number of outer iterations where no change in
parameters is tolerated to be used for the function <code>auglag</code> of the package <code>alabama</code> on which
this function relies on. The larger this number the most computational cost. Default, <code>1</code>.</p>
</td></tr>
<tr><td><code id="eiopt2_+3A_trace">trace</code></td>
<td>
<p>A TRUE/FALSE logical variable indicating whether information on outer iterations should be printed out.
to be used for the function auglag of the package alabama on which this function relies on.
If TRUE, at each outer iteration information is displayed on: (i) how well the equality constraints
are satisfied, (ii) current parameter values, and (iii) current objective function value.
Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="eiopt2_+3A_kkt2.check">kkt2.check</code></td>
<td>
<p>A TRUE/FALSE logical variable indicating whether the second-order Karush-Kuhn-Tucker conditions
should be checked. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="eiopt2_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description of the <code>census.changes</code> argument in more detail.
</p>

<ul>
<li> <p><code>adjust2</code>: The default value. This is one of the simplest and the most popular solution for handling
discrepancies between the sums of the margins (the total number of counts) of the first and
second elections. With this value the column-aggregations of the counts of the first election
in <code>votes.election1</code> are proportionally adjusted to equal the aggregation of the counts in
<code>votes.election2</code> of the second election. In this scenario, R is equal to R1 and C equal to C2.
</p>
</li>
<li> <p><code>raw</code>: This value defines a scenario with two elections elapsed at least
some months where only the raw election data recorded in the N (territorial) units,
in which the electoral space under study is divided, and census changes are not
adjusted but estimated. Net entries and net exits are approached from the available information.
In this scenario, net exits and net entries are estimated according to
Pavia (2023). When both net entries and exits are no
null, constraint (15) of Pavia (2022) applies: no transfer between entries and
exits are allowed. In this scenario, R could be equal to R1 or R1 + 1 and C equal to
C2 or C2 + 1.
</p>
</li>
<li> <p><code>simultaneous</code>: This is the value to be used in classical ecological inference problems,
such as in ecological studies of social or racial voting, and in scenarios with two simultaneous elections.
In this scenario, the sum by rows of <code>votes.election1</code> and <code>votes.election2</code> must coincide.
</p>
</li>
<li> <p><code>regular</code>: This value accounts for a scenario with
two elections elapsed at least some months where (i) the column R1
of <code>votes.election1</code> corresponds to new (young) electors who have the right
to vote for the first time, (ii) net exits and maybe other additional
net entries are computed according to Pavia (2023). When both net entries and exits
are no null, constraints (13) and (15) of Pavia (2023) apply. In this scenario, R
could be equal to R1 or R1 + 1 and C equal to C2 or C2 + 1.
</p>
</li>
<li> <p><code>ordinary</code>: This value accounts for a scenario
with two elections elapsed at least some months where (i) the column C1
of <code>votes.election2</code> corresponds to electors who died in the interperiod
election, (ii) net entries and maybe other additional net exits are
computed according to Pavia (2023). When both net entries and net exits are no null,
constraints (14) and (15) of Pavia (2023) apply.
In this scenario, R could be equal to R1 or R1 + 1 and C equal to C2 or C2 + 1.
</p>
</li>
<li> <p><code>enriched</code>: This value accounts for a scenario that somewhat combine <code>regular</code> and
<code>ordinary</code> scenarios. It considers two elections elapsed at least some months where
(i) the column R1 of <code>votes.election1</code> corresponds to new (young) electors
who have the right to vote for the first time, (ii) the column C2 of
<code>votes.election2</code> corresponds to electors who died in the interperiod
election, (iii) other (net) entries and (net) exits are computed according
to Pavia (2023). When both net entries and net exits are no null, constraints (12) to
(15) of Pavia (2022) apply. In this scenario, R could be equal
to R1 or R1 + 1 and C equal to C2 or C2 + 1.
</p>
</li>
<li> <p><code>adjust1</code>: This value accounts for a scenario with two elections elapsed at least some months
where the census in each of the N polling units of the second election (the row-sums of
<code>votes_election2</code>) are proportionally adjusted to match the corresponding census of the
polling units in the first election (the row-sums of <code>votes_election1</code>).
</p>
</li>
<li> <p><code>semifull</code>: This value accounts for a scenario with two elections elapsed at least some
months, where: (i) the column R1 = R of <code>votes.election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time in each polling unit and
(ii) the column C2 = C of <code>votes.election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes.election1</code> and <code>votes.election2</code> must agree and constraint (15)
of Pavia (2023) apply.
</p>
</li>
<li> <p><code>full</code>: This value accounts for a scenario with two elections elapsed at least some
months, where R = R1, C = C2 and (i) the column R - 1 of <code>votes.election1</code> totals new (young)
electors that have the right to vote for the first time, (ii) the column R
of <code>votes.election1</code> measures new immigrants that have the right to vote and
(iii) the column C of <code>votes.election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes.election1</code> and <code>votes.election2</code> must agree and constraints (13)
and (15) of Pavia (2023) apply.
</p>
</li>
<li> <p><code>fullreverse</code>: This value is somehow the mirror version of <code>full</code>.
It accounts for a scenario with two elections elapsed at least some
months, where (i) the column R (= R1) of <code>votes_election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time and
(ii) total exits are separated out between exits due to emigration
(column C - 1 of <code>votes_election2</code>) and deaths (column C of <code>votes_election2</code>).
In this scenario, the sum by rows of <code>votes_election1</code> and <code>votes_election2</code> must
agree and constraints (14) and (15) of Pavia (2023) apply.
</p>
</li>
<li> <p><code>gold</code>: This value accounts for a scenario similar to <code>full</code>, where R = R1, C = C2 and
where (i) the column R - 1 of <code>votes_election1</code> totals new young
electors that have the right to vote for the first time, (ii) the column R
of <code>votes_election1</code> measures new immigrants that have the right to vote and
total exits are separated out between (iii) exits due to emigration
(column C - 1 of <code>votes.election2</code>) and (iv) deaths (column C of <code>votes.election2</code>).
In this scenario, the sum by rows of <code>votes.election1</code> and <code>votes.election2</code> must agree.
Constraints (12) to (15) of Pavia (2023) apply.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following components
</p>
<table role = "presentation">
<tr><td><code>VTM</code></td>
<td>
<p> A matrix of order RxC with the estimated proportions of the row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order RxC with the estimated vote transfers from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.units</code></td>
<td>
<p> An array of order RxCxN with the estimated proportions of the row-standardized vote transitions from election 1 to election 2
attained for each unit. In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, each unit matrix includes the row and the
column corresponding to net entries and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.votes.units</code></td>
<td>
<p> An array of order RxCxN with the estimated transfer of votes from election 1 to election 2
attained for each unit. In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, each unit matrix
includes the row and the column corresponding to net entries and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.initial.global</code></td>
<td>
<p> The matrix of order RxC obtained by aggregating across units the initial estimated matrix
of row-standardized vote transitions from election 1 to election 2 used
as starting points of the iterative process. In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code>
scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.crude.global</code></td>
<td>
<p> The matrix of order RxC of estimated proportions for the row-standardized
vote transitions from election 1 to election 2 in the whole space attained using quadratic programming.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the
column corresponding to net entries and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.initial.units</code></td>
<td>
<p> An array of order RxCxN with, by layer, the initial estimated matrices of row-standardized vote transitions
from election 1 to election 2 used as starting points of the iterative process. In <code>raw</code>, <code>regular</code>,
<code>ordinary</code> and <code>enriched</code> scenarios, each unit matrix includes the row and the column
corresponding to net entries and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.initial.votes.units</code></td>
<td>
<p> An array of order RxCxN with, by layer, the initial estimated matrices of vote transfers
from election 1 to election 2. In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios,
this matrix includes the row and the column corresponding to net entries
and net exits (when they are present).</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p> The number of iterations employed.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>
<p>Victor Fernandez <a href="mailto:victor.fernandez@uv.es">victor.fernandez@uv.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
votes1 &lt;- structure(list(P1 = c(16L, 4L, 13L, 6L, 1L, 16L, 6L, 17L, 48L, 14L),
                         P2 = c(8L, 3L, 0L, 5L, 1L, 4L, 7L, 6L, 28L, 8L),
                         P3 = c(38L, 11L, 11L, 3L, 13L, 39L, 14L, 34L, 280L, 84L),
                         P4 = c(66L, 5L, 18L, 39L, 30L, 57L, 35L, 65L, 180L, 78L),
                         P5 = c(14L, 0L, 5L, 2L, 4L, 21L, 6L, 11L, 54L, 9L),
                         P6 = c(8L, 2L, 5L, 3L, 0L, 7L, 7L, 11L, 45L, 17L),
                         P7 = c(7L, 3L, 5L, 2L, 3L, 17L, 7L, 13L, 40L, 8L)),
                         row.names = c(NA, 10L), class = "data.frame")
votes2 &lt;- structure(list(C1 = c(2L, 1L, 2L, 2L, 0L, 4L, 0L, 4L, 19L, 14L),
                         C2 = c(7L, 3L, 1L, 7L, 2L, 5L, 3L, 10L, 21L, 6L),
                         C3 = c(78L, 7L, 28L, 42L, 28L, 84L, 49L, 85L, 260L, 100L),
                         C4 = c(56L, 14L, 20L, 7L, 19L, 54L, 22L, 50L, 330L, 91L),
                         C5 = c(14L, 3L, 6L, 2L, 3L, 14L, 8L, 8L, 45L, 7L)),
                         row.names = c(NA, 10L), class = "data.frame")
example &lt;- eiopt2(votes1, votes2)$VTM


votes1b &lt;- structure(list(P1 = c(16L, 4L),
                          P2 = c(8L, 3L)),
                     row.names = c(NA, 2L),
                     class = "data.frame")
votes2b &lt;- structure(list(C1 = c(10L, 10L),
                          C2 = c(7L, 4L)),
                     row.names = c(NA, 2L),
                     class = "data.frame")
example2 &lt;- eiopt2(votes1b, votes2b)$VTM

</code></pre>

<hr>
<h2 id='plot.eiopt2'>Graphical representation of a RxC ecological inference (vote transfer) matrix</h2><span id='topic+plot.eiopt2'></span>

<h3>Description</h3>

<p>Plot method for objects obtained with eiopt2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eiopt2'
plot(
  x,
  margins = TRUE,
  digits = 2,
  row.names = NULL,
  col.names = NULL,
  size.numbers = 6,
  size.labels = 4,
  size.margins = 4,
  colour.cells = "steelblue4",
  colour.grid = "bisque3",
  alpha = 0.5,
  which = NULL,
  ...,
  show.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.eiopt2_+3A_x">x</code></td>
<td>
<p>An object output of the <strong>eiopt2</strong> function.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_margins">margins</code></td>
<td>
<p>A TRUE/FALSE argument informing if the margins of the matrix should be displayed. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be shown. Default, <code>2</code>.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_row.names">row.names</code></td>
<td>
<p>Names to be used for the rows of the matrix.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_col.names">col.names</code></td>
<td>
<p>Names to be used for the columns of the matrix.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_size.numbers">size.numbers</code></td>
<td>
<p>A reference number indicating the average font size to be used for the transfer numbers. Default, <code>6</code>.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_size.labels">size.labels</code></td>
<td>
<p>A number indicating the font size to be used for labels. Default, <code>4</code>.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_size.margins">size.margins</code></td>
<td>
<p>A number indicating the font size to be used for margin numbers. Default, <code>4</code>.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_colour.cells">colour.cells</code></td>
<td>
<p>Background base colour for cells.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_colour.grid">colour.grid</code></td>
<td>
<p>Colour to be used for grid lines.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_alpha">alpha</code></td>
<td>
<p>A [0,1] number of colour transparency.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_which">which</code></td>
<td>
<p>A vector of integers informing the units for which the aggregate transfer matrix should be plotted. Default, NULL, the global matrix is shown.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="plot.eiopt2_+3A_show.plot">show.plot</code></td>
<td>
<p>A TRUE/FALSE indicating if the plot should be displayed as a side-effect. By default, <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the (ggplot) description of the plot, which is a list with components that contain the plot itself, the data, information about the scales, panels etc.
</p>


<h3>Note</h3>

<p>ggplot2 is needed to be installed for this function to work.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
votes1 &lt;- structure(list(P1 = c(16L, 4L, 13L, 6L, 1L, 16L, 6L, 17L, 48L, 14L),
                         P2 = c(8L, 3L, 0L, 5L, 1L, 4L, 7L, 6L, 28L, 8L),
                         P3 = c(38L, 11L, 11L, 3L, 13L, 39L, 14L, 34L, 280L, 84L),
                         P4 = c(66L, 5L, 18L, 39L, 30L, 57L, 35L, 65L, 180L, 78L),
                         P5 = c(14L, 0L, 5L, 2L, 4L, 21L, 6L, 11L, 54L, 9L),
                         P6 = c(8L, 2L, 5L, 3L, 0L, 7L, 7L, 11L, 45L, 17L),
                         P7 = c(7L, 3L, 5L, 2L, 3L, 17L, 7L, 13L, 40L, 8L)),
                         row.names = c(NA, 10L), class = "data.frame")
votes2 &lt;- structure(list(C1 = c(2L, 1L, 2L, 2L, 0L, 4L, 0L, 4L, 19L, 14L),
                         C2 = c(7L, 3L, 1L, 7L, 2L, 5L, 3L, 10L, 21L, 6L),
                         C3 = c(78L, 7L, 28L, 42L, 28L, 84L, 49L, 85L, 260L, 100L),
                         C4 = c(56L, 14L, 20L, 7L, 19L, 54L, 22L, 50L, 330L, 91L),
                         C5 = c(14L, 3L, 6L, 2L, 3L, 14L, 8L, 8L, 45L, 7L)),
                         row.names = c(NA, 10L), class = "data.frame")
example &lt;- eiopt2(votes1, votes2, method = "IPF")
p &lt;- plot(example, show.plot = FALSE)
p


votes1b &lt;- structure(list(P1 = c(16L, 4L),
                          P2 = c(8L, 3L)),
                     row.names = c(NA, 2L),
                     class = "data.frame")
votes2b &lt;- structure(list(C1 = c(10L, 10L),
                          C2 = c(7L, 4L)),
                     row.names = c(NA, 2L),
                     class = "data.frame")
example2 &lt;- eiopt2(votes1b, votes2b)$VTM
p2 &lt;- plot(example2, show.plot = FALSE)
p2

</code></pre>

<hr>
<h2 id='print.eiopt2'>Print a summary of an output of the eiopt2 function</h2><span id='topic+print.eiopt2'></span>

<h3>Description</h3>

<p>Print method for objects obtained with the eiopt2 function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eiopt2'
print(x, ..., margins = TRUE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.eiopt2_+3A_x">x</code></td>
<td>
<p>An object output of the <strong>eiopt2</strong> function.</p>
</td></tr>
<tr><td><code id="print.eiopt2_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="print.eiopt2_+3A_margins">margins</code></td>
<td>
<p>A TRUE/FALSE argument informing if the margins of the transition matrix should be displayed. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.eiopt2_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be shown. Default, <code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
votes1 &lt;- structure(list(P1 = c(16L, 4L, 13L, 6L, 1L, 16L, 6L, 17L, 48L, 14L),
                         P2 = c(8L, 3L, 0L, 5L, 1L, 4L, 7L, 6L, 28L, 8L),
                         P3 = c(38L, 11L, 11L, 3L, 13L, 39L, 14L, 34L, 280L, 84L),
                         P4 = c(66L, 5L, 18L, 39L, 30L, 57L, 35L, 65L, 180L, 78L),
                         P5 = c(14L, 0L, 5L, 2L, 4L, 21L, 6L, 11L, 54L, 9L),
                         P6 = c(8L, 2L, 5L, 3L, 0L, 7L, 7L, 11L, 45L, 17L),
                         P7 = c(7L, 3L, 5L, 2L, 3L, 17L, 7L, 13L, 40L, 8L)),
                         row.names = c(NA, 10L), class = "data.frame")
votes2 &lt;- structure(list(C1 = c(2L, 1L, 2L, 2L, 0L, 4L, 0L, 4L, 19L, 14L),
                         C2 = c(7L, 3L, 1L, 7L, 2L, 5L, 3L, 10L, 21L, 6L),
                         C3 = c(78L, 7L, 28L, 42L, 28L, 84L, 49L, 85L, 260L, 100L),
                         C4 = c(56L, 14L, 20L, 7L, 19L, 54L, 22L, 50L, 330L, 91L),
                         C5 = c(14L, 3L, 6L, 2L, 3L, 14L, 8L, 8L, 45L, 7L)),
                         row.names = c(NA, 10L), class = "data.frame")
example &lt;- eiopt2(votes1, votes2, method = "IPF")
print(example, digits = 1, margins = TRUE)


votes1b &lt;- structure(list(P1 = c(16L, 4L),
                          P2 = c(8L, 3L)),
                     row.names = c(NA, 2L),
                     class = "data.frame")
votes2b &lt;- structure(list(C1 = c(10L, 10L),
                          C2 = c(7L, 4L)),
                     row.names = c(NA, 2L),
                     class = "data.frame")
example2 &lt;- eiopt2(votes1b, votes2b)$VTM

print(example2, digits = 1, margins = TRUE)

</code></pre>

<hr>
<h2 id='print.summary.eiopt2'>Print a summary of a summary.eiopt2 object</h2><span id='topic+print.summary.eiopt2'></span>

<h3>Description</h3>

<p>Print method for <code>summary.eiopt2</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.eiopt2'
print(x, ..., margins = TRUE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.eiopt2_+3A_x">x</code></td>
<td>
<p>An <code>summary.eiopt2</code> class object.</p>
</td></tr>
<tr><td><code id="print.summary.eiopt2_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="print.summary.eiopt2_+3A_margins">margins</code></td>
<td>
<p>A TRUE/FALSE argument informing if the margins of the transition matrix should be displayed. Default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.summary.eiopt2_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be shown. Default, <code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='summary.eiopt2'>Summarize an eiopt2 output object</h2><span id='topic+summary.eiopt2'></span>

<h3>Description</h3>

<p>Summary method for objects obtained with the eiopt2 function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eiopt2'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.eiopt2_+3A_object">object</code></td>
<td>
<p>An object output of the <strong>eiopt2</strong> function.</p>
</td></tr>
<tr><td><code id="summary.eiopt2_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"summary.eiopt2"</code>.
A list with four components:
</p>
<table role = "presentation">
<tr><td><code>prop.matrix</code></td>
<td>
<p> A matrix of order RxC with the estimated proportions of the row-standardized vote transitions from election 1 to election 2.</p>
</td></tr>
<tr><td><code>counts.matrix</code></td>
<td>
<p> A matrix of order RxC with the estimated vote transfers from election 1 to election 2.</p>
</td></tr>
<tr><td><code>row.margins</code></td>
<td>
<p> A vector of length R with aggregate observed distribution of votes in election 1.</p>
</td></tr>
<tr><td><code>col.margins</code></td>
<td>
<p> A vector of length C with aggregate observed distribution of votes in election 2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
votes1 &lt;- structure(list(P1 = c(16L, 4L, 13L, 6L, 1L, 16L, 6L, 17L, 48L, 14L),
                         P2 = c(8L, 3L, 0L, 5L, 1L, 4L, 7L, 6L, 28L, 8L),
                         P3 = c(38L, 11L, 11L, 3L, 13L, 39L, 14L, 34L, 280L, 84L),
                         P4 = c(66L, 5L, 18L, 39L, 30L, 57L, 35L, 65L, 180L, 78L),
                         P5 = c(14L, 0L, 5L, 2L, 4L, 21L, 6L, 11L, 54L, 9L),
                         P6 = c(8L, 2L, 5L, 3L, 0L, 7L, 7L, 11L, 45L, 17L),
                         P7 = c(7L, 3L, 5L, 2L, 3L, 17L, 7L, 13L, 40L, 8L)),
                         row.names = c(NA, 10L), class = "data.frame")
votes2 &lt;- structure(list(C1 = c(2L, 1L, 2L, 2L, 0L, 4L, 0L, 4L, 19L, 14L),
                         C2 = c(7L, 3L, 1L, 7L, 2L, 5L, 3L, 10L, 21L, 6L),
                         C3 = c(78L, 7L, 28L, 42L, 28L, 84L, 49L, 85L, 260L, 100L),
                         C4 = c(56L, 14L, 20L, 7L, 19L, 54L, 22L, 50L, 330L, 91L),
                         C5 = c(14L, 3L, 6L, 2L, 3L, 14L, 8L, 8L, 45L, 7L)),
                         row.names = c(NA, 10L), class = "data.frame")
example &lt;- eiopt2(votes1, votes2)
summary(example)


votes1b &lt;- structure(list(P1 = c(16L, 4L),
                          P2 = c(8L, 3L)),
                     row.names = c(NA, 2L),
                     class = "data.frame")
votes2b &lt;- structure(list(C1 = c(10L, 10L),
                          C2 = c(7L, 4L)),
                     row.names = c(NA, 2L),
                     class = "data.frame")
example2 &lt;- eiopt2(votes1b, votes2b)$VTM

summary(example2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
