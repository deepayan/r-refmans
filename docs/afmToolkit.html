<!DOCTYPE html><html><head><title>Help for package afmToolkit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {afmToolkit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#afmAdhesionEnergy'><p>Adhesion Energy</p></a></li>
<li><a href='#afmBaselineCorrection'><p>Performs a baseline correction to an AFM F-z curve</p></a></li>
<li><a href='#afmContactPoint'><p>Contact point</p></a></li>
<li><a href='#afmdata'><p>AFM data</p></a></li>
<li><a href='#afmDetachPoint'><p>Detach point</p></a></li>
<li><a href='#afmExpDecay'><p>Exponential decay fit</p></a></li>
<li><a href='#afmexperiment'><p>AFM experiment</p></a></li>
<li><a href='#afmExtract'><p>Extract computed parameters from an afmexperiment</p></a></li>
<li><a href='#afmIndentation'><p>afmIndentation</p></a></li>
<li><a href='#afmReadJPK'><p>Read Nanowizard JPK ascii file</p></a></li>
<li><a href='#afmReadJPKFolder'><p>Read all Nanowizard JPK ascii files in a folder</p></a></li>
<li><a href='#afmReadVeeco'><p>Read Bruke Nanoscope Veeco ascii file</p></a></li>
<li><a href='#afmReadVeecoFolder'><p>Read all Bruke Nanoscope Veeco ascii files in a folder</p></a></li>
<li><a href='#afmYoungModulus'><p>afmYoungModulus</p></a></li>
<li><a href='#afmZeroPointSlope'><p>Zero Force Point and Slope</p></a></li>
<li><a href='#append.afmdata'><p>Append to an <code>afmdata</code> list.</p></a></li>
<li><a href='#batchExperiment'><p>Example of an afmexperiment data class.</p></a></li>
<li><a href='#is.afmdata'><p>Afmdata check.</p></a></li>
<li><a href='#is.afmexperiment'><p>Afmexperiment check.</p></a></li>
<li><a href='#plot.afmdata'><p>Plot an afmdata object</p></a></li>
<li><a href='#summary.afmdata'><p>Summary of an <code>afmdata</code> class object.</p></a></li>
<li><a href='#windowedFit'><p>Linear fit in a running window</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functions for Atomic Force Microscope Force-Distance Curves
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Rafael Benitez &lt;rabesua@uv.es&gt;, Vicente Jose Bolos, Jose-Luis Toca-Herrera</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rafael Benitez &lt;rabesua@uv.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of functions for analyzing Atomic Force Microscope (AFM) force-distance curves. It allows to obtain the contact and unbinding points, perform the baseline correction, estimate the Young's modulus, fit up to two exponential decay function to a stress-relaxation / creep experiment, obtain adhesion energies. These operations can be done either over a single F-d curve or over a set of F-d curves in batch  mode.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2), ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, minpack.lm, grid, gridExtra, scales, dplyr, DBI,
assertthat, tibble</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-04-03 08:49:04 UTC; rabesua</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-04-03 15:30:48 UTC</td>
</tr>
</table>
<hr>
<h2 id='afmAdhesionEnergy'>Adhesion Energy</h2><span id='topic+afmAdhesionEnergy'></span>

<h3>Description</h3>

<p>Finds the adhesion and the full detach energies from the retract segment of the AFM 
F-d curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmAdhesionEnergy(afmdata, width = 1, lagdiff = width, mul, mdj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmAdhesionEnergy_+3A_afmdata">afmdata</code></td>
<td>
<p>An afmdata or afmexperiment class variables. Baseline correction should
have been done already.</p>
</td></tr>
<tr><td><code id="afmAdhesionEnergy_+3A_width">width</code></td>
<td>
<p>Width of the window for the local regression (in vector position units)</p>
</td></tr>
<tr><td><code id="afmAdhesionEnergy_+3A_lagdiff">lagdiff</code></td>
<td>
<p>Lag for estimating the differences in Delta (or slopes) signal. 
By default it takes the same value as the window with.</p>
</td></tr>
<tr><td><code id="afmAdhesionEnergy_+3A_mul">mul</code></td>
<td>
<p>Multiplier for the calculating the threshold inthe estimation of jumps 
and peaks in the Delta signal</p>
</td></tr>
<tr><td><code id="afmAdhesionEnergy_+3A_mdj">mdj</code></td>
<td>
<p>Minimum distance between jumps. If none is given then it will be set equal 
to <code>width</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>afmdata</code> class variable which will consist on the original 
input <code>afmdata</code> variable plus a new list named <code>AdhEner</code> with the 
following fields:
</p>
<p><code>Points</code> Array containing the indices of the retract segment where the adhesion 
begins, the unbinding event takes place and the adhesion ends.
</p>
<p><code>Energies</code> Data frame with three columns: <code>E1adh</code>, <code>E2adh</code> and 
<code>Etotal</code>, being the first one the energy from the begining of the adhesion until
the unbinding event, then second one the energy from the unbinding event until the full
detachment of the tip, and the third one, the sum of them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- path.package("afmToolkit")
data &lt;- afmReadJPK("force-save-JPK-3h.txt.gz", path = path)
data &lt;- afmContactPoint(data, width = 20, mul1 = 1, mul2 = 10)
data &lt;- afmDetachPoint(data, width = 20, mul1 = 2, mul2 = 30)
data &lt;- afmBaselineCorrection(data)
data &lt;- afmAdhesionEnergy(data, width = 20, mul = 10)
str(data$AdhEner)
</code></pre>

<hr>
<h2 id='afmBaselineCorrection'>Performs a baseline correction to an AFM F-z curve</h2><span id='topic+afmBaselineCorrection'></span>

<h3>Description</h3>

<p>This function performs the baseline correction to an AFM F-z curve within an
<code>afmdata</code> structure.
</p>
<p>It substracts a best fit line to the cuve: for the approach and contact 
segments, it fits a line to the approach curve
points where for which |z|&gt;ZPointApp and for the retract segment,
it fits a line to the retract curve where |z|&gt; ZpointRet.
</p>
<p>If no ZPointApp is given and the contact point has been already estimated 
(via <code>afmContactPoint()</code> function), then it is found as
</p>
<p style="text-align: center;"><code class="reqn">
ZPointApp = 0.7 ContactPoint + 0.3 max(Z)
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>afmBaselineCorrection(afmdata, ZPointApp = NULL, ZPointRet = NULL,
fitpause = c("approach","retract","none"), vsTime = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmBaselineCorrection_+3A_afmdata">afmdata</code></td>
<td>
<p>An <code>afmdata</code> structure.</p>
</td></tr>
<tr><td><code id="afmBaselineCorrection_+3A_zpointapp">ZPointApp</code></td>
<td>
<p>Point in the approach segment of the curve
that defines the approach baseline</p>
</td></tr>
<tr><td><code id="afmBaselineCorrection_+3A_zpointret">ZPointRet</code></td>
<td>
<p>Point in the retract segment of the curves that 
defines the retract baseline</p>
</td></tr>
<tr><td><code id="afmBaselineCorrection_+3A_fitpause">fitpause</code></td>
<td>
<p>Behaviour for the baseline correction at the pause segment: if &quot;approach&quot; (default), 
the pause segment is correted using the best line fit done on the approach segment, 
if &quot;retract&quot; the best line fit of the retract segment is used, if &quot;none&quot;, no baseline correction 
is done on the pause segment.</p>
</td></tr>
<tr><td><code id="afmBaselineCorrection_+3A_vstime">vsTime</code></td>
<td>
<p>Logical. If TRUE then the baseline correction is performed following the Force vs time approach 
described by S. Moreno-Flores (<cite>Moreno Flores (2016)</cite>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>afmdata</code> An <code>afmdata</code> structure identical to the one in 
the input, but with an additional <code>ForceCorrected</code> column in the
<code>data</code> dataframe of the <code>afmdata</code> structure.
</p>


<h3>References</h3>

<p>Moreno Flores (2016). 
Baseline correction of AFM force curves in the force-time representation.
Microscopy Research and Technique, 79, (11), pp. 1045-1049.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AFMcurve &lt;- afmReadJPK("force-save-JPK-2h.txt.gz", path = path.package("afmToolkit"))
ZPointApp &lt;- 6.43e-6
ZPointRet &lt;- 6.45e-6
AFMcurve &lt;- afmBaselineCorrection(AFMcurve,ZPointApp = ZPointApp,ZPointRet = ZPointRet)
plot(AFMcurve)

# Without providing ZPointApp
AFMcurve &lt;- afmReadJPK("force-save-JPK-3h.txt.gz", path = path.package("afmToolkit"))
AFMcurve &lt;- afmContactPoint(AFMcurve,width = 10,mul1 = 1,mul2 = 20, 
                             loessSmooth = FALSE)
AFMcurve &lt;- afmBaselineCorrection(AFMcurve)
plot(AFMcurve)

</code></pre>

<hr>
<h2 id='afmContactPoint'>Contact point</h2><span id='topic+afmContactPoint'></span>

<h3>Description</h3>

<p>Find the contact point in for the Force-Distance curve
following the local regression and two thresholds methods described 
in Microscopy Research and Technique 2013 (see reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmContactPoint(afmdata, width = 1, mul1, mul2, lagdiff = width, Delta = TRUE,
  loessSmooth = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmContactPoint_+3A_afmdata">afmdata</code></td>
<td>
<p>A Force-Distance curve with the afmdata structure. It should be a list
with at least the 'data' field with a data frame of at least 4 columns.</p>
</td></tr>
<tr><td><code id="afmContactPoint_+3A_width">width</code></td>
<td>
<p>Width of the window for the local regression (in vector position units)</p>
</td></tr>
<tr><td><code id="afmContactPoint_+3A_mul1">mul1</code></td>
<td>
<p>First multiplier for the first alarm threshold</p>
</td></tr>
<tr><td><code id="afmContactPoint_+3A_mul2">mul2</code></td>
<td>
<p>Second multiplier for the second alarm threshold</p>
</td></tr>
<tr><td><code id="afmContactPoint_+3A_lagdiff">lagdiff</code></td>
<td>
<p>Lag for estimating the differences in Delta (or slopes) signal. By
default it takes the same value as the window with.</p>
</td></tr>
<tr><td><code id="afmContactPoint_+3A_delta">Delta</code></td>
<td>
<p>Logical. If TRUE, then the statistic for determining the contact point is
the differences between two consecutive values of the slope of the local regression
line. If FALSE then the slope itself is used.</p>
</td></tr>
<tr><td><code id="afmContactPoint_+3A_loesssmooth">loessSmooth</code></td>
<td>
<p>Logical If TRUE, a loess smoothing (via loess.smooth()) is done
prior to the determination of the contact point. The span of the  smoothing is 0.05
(5
approach segment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>afmdata</code> class variable which will consist on the original input
<code>afmdata</code> variable plus a new list named <code>CP</code> with the following fields:
</p>
<p><code>CP</code> The contact point value.
</p>
<p><code>iCP</code> The position in the array for the contact point value.
</p>
<p><code>delta</code> The delta signal.
</p>
<p><code>noise</code> The noise of the delta signal
</p>


<h3>References</h3>

<p>Benitez R., Moreno-Flores S., Bolos V. J. and Toca-Herrera J.L. (2013). &quot;A 
new automatic contact point detection algorithm for AFM force curves&quot;. 
Microscopy research and technique, <strong>76</strong> (8), pp. 870-876.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+afmDetachPoint">afmDetachPoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- path.package("afmToolkit")
data &lt;- afmReadJPK("force-save-JPK-3h.txt.gz", path = path)
width &lt;- 20
mul1 &lt;- 1
mul2 &lt;- 10
data &lt;- afmContactPoint(data, width = width, mul1 = mul1, mul2 = mul2)
## Not run: 
plot(data, segment = "approach") + geom_vline(xintercept = data$CP$CP, lty = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='afmdata'>AFM data</h2><span id='topic+afmdata'></span>

<h3>Description</h3>

<p>This function creates an <code>afmdata</code> structure, which is as list with at
least one field called <code>data</code> which is a data frame with a valid AFM data, that is,
at least 3 variables called &quot;Z&quot;, &quot;Force&quot;, and &quot;Segment&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmdata(data, dstr = "Z", Fstr = "Force", Segstr = "Segment", tstr = "Time", 
 params = list(SpringConstant = numeric(), curvename = NULL ))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmdata_+3A_data">data</code></td>
<td>
<p>A data frame consisting in 3 or 4 columns. A minimum of &quot;Z&quot; (or &quot;distance&quot;),
&quot;Force&quot; and &quot;Segment&quot;. Optionally a fourth column with &quot;Time&quot; could be added.</p>
</td></tr>
<tr><td><code id="afmdata_+3A_dstr">dstr</code></td>
<td>
<p>Character string with the posible names for the distance variable.</p>
</td></tr>
<tr><td><code id="afmdata_+3A_fstr">Fstr</code></td>
<td>
<p>Character string with the posible names for the force variable.</p>
</td></tr>
<tr><td><code id="afmdata_+3A_segstr">Segstr</code></td>
<td>
<p>Character string with the posible names for the Segment variable.</p>
</td></tr>
<tr><td><code id="afmdata_+3A_tstr">tstr</code></td>
<td>
<p>Character string with the posible names for the time variable.</p>
</td></tr>
<tr><td><code id="afmdata_+3A_params">params</code></td>
<td>
<p>A list that may contain parameters describing the F-d curve. At least will
contain the <code>SpringConstant</code> and the <code>curvename</code>, being the former the
cantilever spring constant and the latter  a F-d curve ID. Function <code>afmReadJPK</code>
will try to obtain the spring constant from the file header and the curvename from the
data file name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>afmdata</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+afmexperiment">afmexperiment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Making some artifical data following a L-J 12-6 potential
n &lt;- 1000
z &lt;- seq(from = 9e-3, to = 1e-1, length.out = n )
u0 &lt;- 1e-5
z0 &lt;- 1e-2
Force &lt;- -u0*(12*z0^6/z^7-12*z0^12/z^13)
Segment &lt;- rep("approach",n)
AFMcurve &lt;- afmdata(data.frame(Z = z, Force = Force, Segment  = Segment))
plot(AFMcurve)
</code></pre>

<hr>
<h2 id='afmDetachPoint'>Detach point</h2><span id='topic+afmDetachPoint'></span>

<h3>Description</h3>

<p>Find the detach point (or unbinding point) for the Force-Distance curve 
following the local regression and two thresholds methods described in Microscopy
Research and Technique 2013 (see reference).
</p>
<p>The procedure is similar to the one used by the <code>afmContactPoint()</code> function for
obtaining the contact point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmDetachPoint(afmdata,width=1,mul1,mul2, lagdiff = width, Delta=TRUE,
  loessSmooth = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmDetachPoint_+3A_afmdata">afmdata</code></td>
<td>
<p>A Force-Distance curve with the afmdata structure. It should be a list
with at least the 'data' field with a data frame of at least 4 columns.</p>
</td></tr>
<tr><td><code id="afmDetachPoint_+3A_width">width</code></td>
<td>
<p>Width of the window for the local regression (in vector position units)</p>
</td></tr>
<tr><td><code id="afmDetachPoint_+3A_mul1">mul1</code></td>
<td>
<p>First multiplier for the first alarm threshold</p>
</td></tr>
<tr><td><code id="afmDetachPoint_+3A_mul2">mul2</code></td>
<td>
<p>Second multiplier for the second alarm threshold</p>
</td></tr>
<tr><td><code id="afmDetachPoint_+3A_lagdiff">lagdiff</code></td>
<td>
<p>Lag for estimating the differences in Delta (or slopes) signal. By
default it takes the same value as the window with.</p>
</td></tr>
<tr><td><code id="afmDetachPoint_+3A_delta">Delta</code></td>
<td>
<p>Logical. If TRUE, then the statistic for determining the contact point is
the differences between two consecutive values of the slope of the local regression
line. If FALSE then the slope itself is used.</p>
</td></tr>
<tr><td><code id="afmDetachPoint_+3A_loesssmooth">loessSmooth</code></td>
<td>
<p>Logical If TRUE, a loess smoothing (via loess.smooth()) is done
prior to the determination of the contact point. The span of the  smoothing is 0.05
(5
approach segment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>afmdata</code> class variable which will consist on the original input
<code>afmdata</code> variable plus a new list named <code>DP</code> with the following fields:
</p>
<p><code>DP</code> The detach point value.
</p>
<p><code>iDP</code> The position in the array for the detach point value.
</p>
<p><code>delta</code> The delta signal.
</p>
<p><code>noise</code> The noise of the delta signal
</p>


<h3>References</h3>

<p>Benitez R., Moreno-Flores S., Bolos V. J. and Toca-Herrera J.L. (2013). &quot;A 
new automatic contact point detection algorithm for AFM force curves&quot;. Microscopy
research and technique, <strong>76</strong> (8), pp. 870-876.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+afmContactPoint">afmContactPoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- afmReadJPK("force-save-JPK-3h.txt.gz", path = path.package("afmToolkit"))
width &lt;- 10
mul1 &lt;- 2
mul2 &lt;- 40
data &lt;- afmDetachPoint(data, width = width, mul1 = mul1, mul2 = mul2)
## Not run: 
plot(data, segment = "retract") + geom_vline(xintercept = data$DP$DP, lty = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='afmExpDecay'>Exponential decay fit</h2><span id='topic+afmExpDecay'></span>

<h3>Description</h3>

<p>Fits a viscoelastic exponential decay in a Force-Relaxation or Creep
experiments as described in Nanotechnology 2010 (see references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmExpDecay(afmdata, nexp = 2, tmax = NULL, type = c("CH","CF"), plt = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmExpDecay_+3A_afmdata">afmdata</code></td>
<td>
<p>An object of <code>afmdata</code> class with a <b>pause</b> segment and a
<b>Time</b> column in the <code>data</code> dataframe.</p>
</td></tr>
<tr><td><code id="afmExpDecay_+3A_nexp">nexp</code></td>
<td>
<p>Number of expontials in the Prony series to be fitted. Currently only one
or two exponentials are supported. Default is 2.</p>
</td></tr>
<tr><td><code id="afmExpDecay_+3A_tmax">tmax</code></td>
<td>
<p>Maximum time considered in the relaxation curve. It defaults to <code>Inf</code>,
meaning that the whole pause segment is considered.</p>
</td></tr>
<tr><td><code id="afmExpDecay_+3A_type">type</code></td>
<td>
<p>Type of the experiment. Can be either &quot;CH&quot; (Constant Height) for a
force-relaxation experiment or &quot;CF&quot; (Constant Force) for a creep experiment. Default
is <code>type = "CH"</code>.</p>
</td></tr>
<tr><td><code id="afmExpDecay_+3A_plt">plt</code></td>
<td>
<p>Logical. If TRUE (default) then a plot of the pause segment with the overlay
of the fit is shown.</p>
</td></tr>
<tr><td><code id="afmExpDecay_+3A_...">...</code></td>
<td>
<p>Options passed to the <code>nlsM()</code> function from the <code>minpack.lm</code>
package. At least should contain the starting values (<code>start = list(...)</code>) for
the Levenberg-Mardquart nonlinear least square method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>afmdata</code> class variable which will consist on the original input
<code>afmdata</code> variable plus a new list named <code>ExpFit</code> with the following
fields:
</p>
<p><code>expdecayModel</code>: A nls object returned from  <code>nlsM()</code> function.
</p>
<p><code>expdecayFit</code>: The values predicted by the fit, returned from the 
<code>predict()</code> function.
</p>


<h3>References</h3>

<p>Susana Moreno-Flores, Rafael Benitez, Maria dM Vivanco and Jose Luis 
Toca-Herrera (2010). &quot;Stress relaxation and creep on living cells with the atomic force
microscope: a means to calculate elastic moduli and viscosities of cell components&quot;.
Nanotechnology, <strong>21</strong> (44), pp. 445101.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- afmReadJPK("force-save-JPK-3h.txt.gz", path = path.package("afmToolkit"))
width &lt;- 20
mul1 &lt;- 1
mul2 &lt;- 10
data &lt;- afmContactPoint(data, width = width, mul1 = mul1, mul2 = mul2)
data &lt;- afmDetachPoint(data, width = width, mul1 = mul1, mul2 = mul2)
data &lt;- afmBaselineCorrection(data)
data &lt;- afmExpDecay(data, nexp = 2, type = "CH")
</code></pre>

<hr>
<h2 id='afmexperiment'>AFM experiment</h2><span id='topic+afmexperiment'></span>

<h3>Description</h3>

<p>This function creates an <code>afmexperiment</code> structure, which is as list 
(or an array) of elements of <code>afmdata</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmexperiment(data, ID=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmexperiment_+3A_data">data</code></td>
<td>
<p>A variable of  <code>afmdata</code> class, or a list of elements of
<code>afmdata</code> class.</p>
</td></tr>
<tr><td><code id="afmexperiment_+3A_id">ID</code></td>
<td>
<p>Character string with the identifier of the <code>data</code> variable or a string
array in case <code>data</code> is a list of <code>afmdata</code> variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>afmexp</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+afmdata">afmdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataFolder &lt;- paste(path.package("afmToolkit"), "afmexperiment",sep = "/")
dataFiles &lt;- list.files(dataFolder, pattern = "force", full.names = FALSE)
data &lt;- lapply(dataFiles, afmReadJPK, path = dataFolder)
names(data) &lt;- dataFiles
data &lt;- afmexperiment(data)
plot(data[[1]])
</code></pre>

<hr>
<h2 id='afmExtract'>Extract computed parameters from an afmexperiment</h2><span id='topic+afmExtract'></span>

<h3>Description</h3>

<p>Extracts some parameters from an afmexperiment for an easy further
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmExtract(afmexperiment, params = list("YM", "AE", "ED"), opt.param = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmExtract_+3A_afmexperiment">afmexperiment</code></td>
<td>
<p>Data of afmexperiment class.</p>
</td></tr>
<tr><td><code id="afmExtract_+3A_params">params</code></td>
<td>
<p>List of parameters to extract from the data.</p>
</td></tr>
<tr><td><code id="afmExtract_+3A_opt.param">opt.param</code></td>
<td>
<p>Optional parameter or factor in the params field of the afmdata list 
to add to the data extraction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the name of the curve and the corresponding values of the 
parameters extacted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(dplyr) # Not really necessary

# Load the data
data(batchExperiment)

# Process the afmexperiment
data &lt;- afmContactPoint(batchExperiment, width = 50, mul1 = 1, mul2 = 10)
data &lt;- afmDetachPoint(data, width = 50, mul1 = 1, mul2 = 10)
data &lt;- afmBaselineCorrection(data)
data &lt;- afmZeroPointSlope(data)
data &lt;- afmIndentation(data)
data &lt;- afmYoungModulus(data, thickness = 2e-7, params = list(alpha = 22))
data &lt;- afmExpDecay(data, plt = FALSE)
data &lt;- afmAdhesionEnergy(data, mul = 7)

# Extract the values of the parameters obtained in the analysis
afmExpParams &lt;- afmExtract(data, opt.param = "type")

# Plotting the Young's Modulus
afmExpParams[[1]] %&gt;% ggplot(aes(x = type, y = YM)) + geom_boxplot() 
ylab("Young's Modulus  (Pa)")

## End(Not run)
</code></pre>

<hr>
<h2 id='afmIndentation'>afmIndentation</h2><span id='topic+afmIndentation'></span>

<h3>Description</h3>

<p>This function computes the deformation of the sample from the 
calibrated Force-Distance curve, by substracting Z to the Zero Force Point 
calculated with afmZeroPointSlope function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmIndentation(afmdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmIndentation_+3A_afmdata">afmdata</code></td>
<td>
<p>An <code>afmdata</code> object. It should be a valid afmdata
object upon which the Contact Point, the baseline correction and the Zero 
Force Point must have been calculated first (using functions 
<code>afmContactPoint()</code>, <code>afmBaselineCorrection()</code>) and
<code>afmZeroPointSlope()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with one field:
</p>
<p><code>afmdata</code>: An afmdata class in which a <code>Indentation</code> column is added 
in the <code>data</code> field.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- afmReadJPK("force-save-JPK-3h.txt.gz", path = path.package("afmToolkit"))
data &lt;- afmContactPoint(data, width = 20, mul1 = 1, mul2 = 20)
data &lt;- afmDetachPoint(data, width = 40, mul1 = 3, mul2 = 40)
data &lt;- afmBaselineCorrection(data)
data &lt;- afmZeroPointSlope(data, segment = "approach")
data &lt;- afmIndentation(data)
head(data$data)
</code></pre>

<hr>
<h2 id='afmReadJPK'>Read Nanowizard JPK ascii file</h2><span id='topic+afmReadJPK'></span>

<h3>Description</h3>

<p>Read an ascii JPK file.
</p>
<p>Reads an ascii JPK file with one to three headers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmReadJPK(filename, path = "", FColStr = "Vertical", 
ZColStr = "Height (measured &amp; smoothed)", tColStr = "Segment Time")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmReadJPK_+3A_filename">filename</code></td>
<td>
<p>String with the name of the jpk file.</p>
</td></tr>
<tr><td><code id="afmReadJPK_+3A_path">path</code></td>
<td>
<p>Path to the folder where the file is.</p>
</td></tr>
<tr><td><code id="afmReadJPK_+3A_fcolstr">FColStr</code></td>
<td>
<p>String with a pattern identifying the Force column.</p>
</td></tr>
<tr><td><code id="afmReadJPK_+3A_zcolstr">ZColStr</code></td>
<td>
<p>String with a pattern identifying the Z column.</p>
</td></tr>
<tr><td><code id="afmReadJPK_+3A_tcolstr">tColStr</code></td>
<td>
<p>String with a pattern identifying the Time column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a field 'data' which is a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- afmReadJPK("force-save-JPK-3h.txt.gz",path = path.package("afmToolkit"))
str(data)
</code></pre>

<hr>
<h2 id='afmReadJPKFolder'>Read all Nanowizard JPK ascii files in a folder</h2><span id='topic+afmReadJPKFolder'></span>

<h3>Description</h3>

<p>Read all JPK ascii files in a given folder. It searches for all files containing a 
given patter (&quot;.txt&quot; by default) and uses the <code>afmReadJPJ</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmReadJPKFolder(folder, pattern = ".txt", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmReadJPKFolder_+3A_folder">folder</code></td>
<td>
<p>Name of the  folder containing the jpk files.</p>
</td></tr>
<tr><td><code id="afmReadJPKFolder_+3A_pattern">pattern</code></td>
<td>
<p>Pattern that will identify the jok files (&quot;.txt&quot; by default).</p>
</td></tr>
<tr><td><code id="afmReadJPKFolder_+3A_...">...</code></td>
<td>
<p>Other parameters passed to afmReadJPK function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>afmexperiment</code> class data structure with all F-d curves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folder &lt;- paste(path.package("afmToolkit"), "afmexperiment",sep = "/")
data &lt;- afmReadJPKFolder(folder = folder)
str(data)
</code></pre>

<hr>
<h2 id='afmReadVeeco'>Read Bruke Nanoscope Veeco ascii file</h2><span id='topic+afmReadVeeco'></span>

<h3>Description</h3>

<p>Read an ascii Veeco file.
</p>
<p>Reads an ascii Veeco file with one or two segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmReadVeeco(filename, path = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmReadVeeco_+3A_filename">filename</code></td>
<td>
<p>String with the name of the jpk file.</p>
</td></tr>
<tr><td><code id="afmReadVeeco_+3A_path">path</code></td>
<td>
<p>Path to the folder where the file is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a field 'data' which is a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- afmReadVeeco("veeco_file.txt.gz",path = path.package("afmToolkit"))
str(data)
</code></pre>

<hr>
<h2 id='afmReadVeecoFolder'>Read all Bruke Nanoscope Veeco ascii files in a folder</h2><span id='topic+afmReadVeecoFolder'></span>

<h3>Description</h3>

<p>Read all Veeco ascii files in a given folder. It searches for all files containing a 
given patter (&quot;.txt&quot; by default) and uses the <code>afmReadVeeco</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmReadVeecoFolder(folder, pattern = ".txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmReadVeecoFolder_+3A_folder">folder</code></td>
<td>
<p>Name of the  folder containing the Veeco files.</p>
</td></tr>
<tr><td><code id="afmReadVeecoFolder_+3A_pattern">pattern</code></td>
<td>
<p>Pattern that will identify the Veeco files (&quot;.txt&quot; by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>afmexperiment</code> class data structure with all F-d curves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folder &lt;- paste(path.package("afmToolkit"), "veecoFolder",sep = "/")
data &lt;- afmReadVeecoFolder(folder = folder)
str(data)
</code></pre>

<hr>
<h2 id='afmYoungModulus'>afmYoungModulus</h2><span id='topic+afmYoungModulus'></span>

<h3>Description</h3>

<p>This function computes the Young's Modulus of the sample from the approach
curve using Hertz's  contact model  for a pyramidal tip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmYoungModulus(afmdata, thickness = NULL, model = "Hertz", geometry =
  c("pyramid","paraboloid"), silent = TRUE, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmYoungModulus_+3A_afmdata">afmdata</code></td>
<td>
<p>An <code>afmdata</code> object. It should be a valid afmdata object upon which
the Contact Point, the baseline correction and the Zero Force Point and the 
Indentation must have been calculated first (using functions 
<code>afmContactPoint()</code>, <code>afmBaselineCorrection()</code>, <code>afmZeroPointSlope()</code>,
and <code>afmIndentation()</code>)</p>
</td></tr>
<tr><td><code id="afmYoungModulus_+3A_thickness">thickness</code></td>
<td>
<p>Thickness (in m) of the surface. The Force - Indentation fit will be 
done for values of the Indentation variable smaller than the thickness. If no value 
is given, it will be done for all values in the curve for which the Indentation is 
negative.</p>
</td></tr>
<tr><td><code id="afmYoungModulus_+3A_model">model</code></td>
<td>
<p>Contact mechanics model to be used. Currently only Hertz's pure elastic 
model is available.</p>
</td></tr>
<tr><td><code id="afmYoungModulus_+3A_geometry">geometry</code></td>
<td>
<p>Geometry of the tip. Currently only pyramidal (default) and paraboloid
geometries are implemented.</p>
</td></tr>
<tr><td><code id="afmYoungModulus_+3A_silent">silent</code></td>
<td>
<p>Logical value. If FALSE it prints the fit model summary (via 
<code>summary.lm()</code>). Default value is TRUE</p>
</td></tr>
<tr><td><code id="afmYoungModulus_+3A_params">params</code></td>
<td>
<p>A list containing different parameters of the model: e.g. nu (Poisson's 
ratio) or alpha (internal angle, in degrees, of the pyramidal tip) or R (tip radius, 
in the paraboloid geometry)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>afmdata</code> class variable which will consist on the original input 
<code>afmdata</code> variable plus a new list named <code>YoungModulus</code> with the following 
fields:
</p>
<p><code>YoungModulus</code> The Young's modulus value (in Pa).
</p>
<p><code>fitYM</code> The Force vs Indentation^2 fit as an <code>lm</code> object.
</p>
<p><code>fitdata</code> The subset of the data used in the fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- afmReadJPK("force-save-JPK-2h.txt.gz", path = path.package("afmToolkit"))
data &lt;- afmContactPoint(data, width = 20, mul1 = 1, mul2 = 20)
data &lt;- afmDetachPoint(data, width = 40, mul1 = 3, mul2 = 40)
data &lt;- afmBaselineCorrection(data)
data &lt;- afmZeroPointSlope(data, segment = "approach")
data &lt;- afmIndentation(data)
data &lt;- afmYoungModulus(data, thickness = 1e-8, params = list(alpha = 22),
                        silent = TRUE)
print(data$YoungModulus$YoungModulus)
</code></pre>

<hr>
<h2 id='afmZeroPointSlope'>Zero Force Point and Slope</h2><span id='topic+afmZeroPointSlope'></span>

<h3>Description</h3>

<p>This function finds the point of zero force (real contact point) and the
slope of the contact part of the Force-Distance curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afmZeroPointSlope(afmdata, fstar = 0, segment = c("approach", "retract"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afmZeroPointSlope_+3A_afmdata">afmdata</code></td>
<td>
<p>An <code>afmdata</code> object. It should be a valid afmdata object upon which
the Contact Point and the baseline correction must have been calculated first (using
functions <code>afmContactPoint()</code> and <code>afmBaselineCorrection()</code>)</p>
</td></tr>
<tr><td><code id="afmZeroPointSlope_+3A_fstar">fstar</code></td>
<td>
<p>Value such that fstar * sd is to be considered as zero Force, where sd is
the standard deviation of Force at the basline. It takes fstar = 0 as default value,
meaning that zero force is actually zero.</p>
</td></tr>
<tr><td><code id="afmZeroPointSlope_+3A_segment">segment</code></td>
<td>
<p>The segment on which everything is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>afmdata</code> class variable which will consist on the original input
<code>afmdata</code> variable plus a new list named <code>Slopes</code> with the following
fields: <code>Z0Point</code>: Point of zero force. <code>Slope</code>: Slope of the best fit line
in the contact part of the Force-Distance curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- afmReadJPK("force-save-JPK-2h.txt.gz", path = path.package("afmToolkit"))
data &lt;- afmContactPoint(data, width = 20, mul1 = 1, mul2 = 20)
data &lt;- afmDetachPoint(data, width = 40, mul1 = 3, mul2 = 40)
data &lt;- afmBaselineCorrection(data)
data &lt;- afmZeroPointSlope(data, segment = "approach")
## Not run: 
plot(data, segment = "approach") + geom_vline(xintercept = data$Slopes$Z0Point, lty = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='append.afmdata'>Append to an <code>afmdata</code> list.</h2><span id='topic+append.afmdata'></span>

<h3>Description</h3>

<p>This function appends a list to an existing afmdata structure. It is used
internally by several afm* functions when attaching the results to the input afmdata
variable. This function should not be used directly unless by experienced users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append.afmdata(afmdata, x, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append.afmdata_+3A_afmdata">afmdata</code></td>
<td>
<p>The afmdata to which the new list is going to be joined.</p>
</td></tr>
<tr><td><code id="append.afmdata_+3A_x">x</code></td>
<td>
<p>A list to be appended.</p>
</td></tr>
<tr><td><code id="append.afmdata_+3A_name">name</code></td>
<td>
<p>The name of new field of the resulting afmdata object. If none is given, it
is the same as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new list of class <code>afmdata</code>
</p>

<hr>
<h2 id='batchExperiment'>Example of an afmexperiment data class.</h2><span id='topic+batchExperiment'></span>

<h3>Description</h3>

<p>An afmexperiment list containing 14 afmdata Force-distance experiments. Each experiment
has three segments (&quot;approach&quot;, &quot;pause&quot; and &quot;retract&quot;) and they are divided in two groups
depending on the  covering of the sample (&quot;CHI&quot; for Chitosan, and &quot;PAH&quot; for 
Polyallylamine hydrochloride).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchExperiment
</code></pre>


<h3>Format</h3>

<p>An afmexperiment class consisting on a list of 14 afmdata class elements each 
one having the following fields:
</p>

<dl>
<dt>data</dt><dd><p>Data frame with the data itself with a variable number of rows (between 4692 and 6142)
and 4 variables:
</p>

<dl>
<dt>Z</dt><dd><p>Distance (in meters)</p>
</dd>
<dt>Force</dt><dd><p>Force (in Newtons)</p>
</dd>
<dt>Time</dt><dd><p>Time starting at the begining of each segment (in seconds)</p>
</dd>
<dt>Segment</dt><dd><p>Segment of the Force-distance curve (factor: &quot;approach&quot;, &quot;pause&quot;, &quot;retract&quot;)</p>
</dd>
</dl>
</dd>
<dt>params</dt><dd><p>List with the following fields describing the experiment:
</p>

<dl>
<dt>SpringConstant</dt><dd><p>Cantilever spring constant (in N/m)</p>
</dd>
<dt>curvename</dt><dd><p>Name of the original AFM data file from which the data was obtained</p>
</dd>
<dt>type</dt><dd><p>Type of sample covering: &quot;CHI&quot; for Chitosan, and &quot;PAH&quot; for 
Polyallylamine hydrochloride</p>
</dd>
</dl>

</dd>
</dl>

<hr>
<h2 id='is.afmdata'>Afmdata check.</h2><span id='topic+is.afmdata'></span>

<h3>Description</h3>

<p>Checks wether an R object is an afmdata or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.afmdata(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.afmdata_+3A_x">x</code></td>
<td>
<p>Any <b>R</b> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if its argument is an afmdata (that is, has &quot;afmdata&quot; 
amongst its classes) and <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.afmexperiment'>Afmexperiment check.</h2><span id='topic+is.afmexperiment'></span>

<h3>Description</h3>

<p>Checks wether an R object is an afmexperiment or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.afmexperiment(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.afmexperiment_+3A_x">x</code></td>
<td>
<p>Any <b>R</b> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if its argument is an afmdata (that is, has &quot;afmexperiment&quot;
amongst its classes) and <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='plot.afmdata'>Plot an afmdata object</h2><span id='topic+plot.afmdata'></span>

<h3>Description</h3>

<p>Plots an afmdata object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'afmdata'
plot(x, y = NULL, vs = "Z", segment = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.afmdata_+3A_x">x</code></td>
<td>
<p>An object of <code>afmdata</code> class.</p>
</td></tr>
<tr><td><code id="plot.afmdata_+3A_y">y</code></td>
<td>
<p>Variable added for compatibility with <code>plot</code>.</p>
</td></tr>
<tr><td><code id="plot.afmdata_+3A_vs">vs</code></td>
<td>
<p>The variable for the x-axis. May take the values &quot;Time&quot; or &quot;Z&quot;. It defaults
to &quot;Z&quot;, plotting thus a Force-Distance curve. If <code>vs</code> is set to &quot;Time&quot;, then it
plots  a Force-Time curve.</p>
</td></tr>
<tr><td><code id="plot.afmdata_+3A_segment">segment</code></td>
<td>
<p>The segment of the curve to be plotted. If <code>segment = "all"</code> then
all segments of the curve are plotted. Possible values are: <code>"approach"</code>,
<code>"pause"</code>, <code>"retract"</code> and <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="plot.afmdata_+3A_...">...</code></td>
<td>
<p>Additional parameters to be pased to the ggplot functions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Loading the data
path &lt;- path.package("afmToolkit")
data &lt;- afmReadJPK("force-save-JPK-3h.txt.gz", path = path)
# Standard plot (out of the box)
plot(data)
# Computing the contact and detach points
data &lt;- afmContactPoint(data, width = 20, mul1 = 1, mul2 = 10)
data &lt;- afmDetachPoint(data, width = 40, mul1 = 3, mul2 = 20)
# Making the baseline correction
data &lt;- afmBaselineCorrection(data)
# Plot once the baseline correction is done
plot(data)
# Plotting only retract segment
plot(data, segment = "retract")
# Plotting the pause segment: Force vs Time
plot(data, segment = "pause", vs = "Time")
</code></pre>

<hr>
<h2 id='summary.afmdata'>Summary of an <code>afmdata</code> class object.</h2><span id='topic+summary.afmdata'></span>

<h3>Description</h3>

<p>This function sumarizes the main features of an afmdata object and,
optionnaly plots all segments available with all parameters estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'afmdata'
summary(object, plt = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.afmdata_+3A_object">object</code></td>
<td>
<p>An object of <code>afmdata</code> class.</p>
</td></tr>
<tr><td><code id="summary.afmdata_+3A_plt">plt</code></td>
<td>
<p>Logical variable. If TRUE plots all available segments with all available
data.</p>
</td></tr>
<tr><td><code id="summary.afmdata_+3A_...">...</code></td>
<td>
<p>Additional arguments (for compatibility with <code>summary</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: path &lt;- path.package("afmToolkit")
data &lt;- afmReadJPK("force-save-JPK-3h.txt.gz", path = path)
data &lt;- afmContactPoint(data, width = 20, mul1 = 1, mul2 = 10)
data &lt;- afmDetachPoint(data, width = 20, mul1 = 2, mul2 = 30)
data &lt;- afmBaselineCorrection(data)
data &lt;- afmAdhesionEnergy(data, width = 20, mul = 10)
data &lt;- afmZeroPointSlope(data, segment = "approach")
data &lt;- afmIndentation(data)
data &lt;- afmYoungModulus(data, thickness = 1e-7, params = list(alpha = 22),
                        silent = TRUE)
data &lt;- afmExpDecay(data, nexp = 2, type = "CH")
summary(data)
## End(Not run)                        
</code></pre>

<hr>
<h2 id='windowedFit'>Linear fit in a running window</h2><span id='topic+windowedFit'></span>

<h3>Description</h3>

<p>This is an internal function used by the <code>afmContactPoint</code> 
and <code>afmDetachPoint</code> functions. 
It computes the slopes of a linear fit to the data in a window of a given radius.
This function should not be used directly unless by experienced users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>windowedFit(X, width)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="windowedFit_+3A_x">X</code></td>
<td>
<p>Least squares matrix on the form [1 z Force], 
according to input parameters in function <code>lm.fit</code></p>
</td></tr>
<tr><td><code id="windowedFit_+3A_width">width</code></td>
<td>
<p>Width of the window for the local regression (in vector position units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>OUT</code> A vector of length <code>nrow(X)-2*width</code>, 
containing with the slopes of the fits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
x &lt;- seq(0,2*pi,length.out = n)
y = sin(x)+0.1*rnorm(n)
X &lt;- matrix(c(rep(1,n),x,y),nrow = n,ncol = 3)
width &lt;- 5
b &lt;- windowedFit(X,width)
plot(x[(width+1):(n-width)],b,xlab = "x",ylab = "y",type = "l")
lines(x,y,col = "red")
legend("bottomleft",c("Slopes","Signal"),col = c(1,2),lty = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
