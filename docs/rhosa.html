<!DOCTYPE html><html lang="en"><head><title>Help for package rhosa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rhosa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.blackman_window'><p>Blackman window function</p></a></li>
<li><a href='#.hamming_window'><p>Hamming window function</p></a></li>
<li><a href='#.hann_window'><p>Hann window function</p></a></li>
<li><a href='#bicoherence'><p>Estimate bicoherence from given time series data.</p></a></li>
<li><a href='#biperiodogram'><p>Calculate biperiodogram</p></a></li>
<li><a href='#bispectrum'><p>Estimate bispectrum from time series data.</p></a></li>
<li><a href='#cross_bicoherence'><p>Estimate cross-bicoherence from time series data.</p></a></li>
<li><a href='#cross_bispectrum'><p>Estimate cross-bispectrum from time series data.</p></a></li>
<li><a href='#kim_and_powers_model'><p>A test signal of the phase coherence between three oscillators</p></a></li>
<li><a href='#mode_matching'><p>Estimate cross-bicoherence's empirical null distribution by a mode matching method</p></a></li>
<li><a href='#three_channel_model'><p>A three-channel model of quadratic phase coupling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Higher-Order Spectral Analysis</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-17</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Higher-order spectra or polyspectra of time series, such as bispectrum and bicoherence, have been investigated in abundant literature and applied to problems of signal detection in a wide range of fields. This package aims to provide a simple API to estimate and analyze them. The current implementation is based on Brillinger and Irizarry (1998) &lt;<a href="https://doi.org/10.1016%2FS0165-1684%2897%2900217-X">doi:10.1016/S0165-1684(97)00217-X</a>&gt; for estimating bispectrum or bicoherence, Lii and Helland (1981) &lt;<a href="https://doi.org/10.1145%2F355958.355961">doi:10.1145/355958.355961</a>&gt; for cross-bispectrum, and Kim and Powers (1979) &lt;<a href="https://doi.org/10.1109%2FTPS.1979.4317207">doi:10.1109/TPS.1979.4317207</a>&gt; for cross-bicoherence.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tabe.github.io/rhosa/">https://tabe.github.io/rhosa/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tabe/rhosa/issues">https://github.com/tabe/rhosa/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-17 08:39:31 UTC; abe</td>
</tr>
<tr>
<td>Author:</td>
<td>Takeshi Abe <a href="https://orcid.org/0000-0002-7074-4561"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Takeshi Abe &lt;tabe@fixedpoint.jp&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-17 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.blackman_window'>Blackman window function</h2><span id='topic+.blackman_window'></span>

<h3>Description</h3>

<p>Calculate
</p>
<p style="text-align: center;"><code class="reqn">\frac{42}{100} - \frac{\cos(2 \pi x)}{2} + \frac{8 \cos(4 \pi x)}{100}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>.blackman_window(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".blackman_window_+3A_x">x</code></td>
<td>
<p>A real number in [0, 1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number in [0, 1].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.hamming_window">.hamming_window</a></code> and <code><a href="#topic+.hann_window">.hann_window</a></code>.
</p>

<hr>
<h2 id='.hamming_window'>Hamming window function</h2><span id='topic+.hamming_window'></span>

<h3>Description</h3>

<p>Calculate
</p>
<p style="text-align: center;"><code class="reqn">\frac{25}{46} - \frac{21}{46} \cos(2 \pi x).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>.hamming_window(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".hamming_window_+3A_x">x</code></td>
<td>
<p>A real number in [0, 1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number in [0, 1].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.hann_window">.hann_window</a></code> and <code><a href="#topic+.blackman_window">.blackman_window</a></code>.
</p>

<hr>
<h2 id='.hann_window'>Hann window function</h2><span id='topic+.hann_window'></span>

<h3>Description</h3>

<p>Calculate
</p>
<p style="text-align: center;"><code class="reqn">\frac{1 - \cos(2 * \pi * x)}{2}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>.hann_window(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".hann_window_+3A_x">x</code></td>
<td>
<p>A real number in [0, 1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number in [0, 1].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.hamming_window">.hamming_window</a></code> and <code><a href="#topic+.blackman_window">.blackman_window</a></code>.
</p>

<hr>
<h2 id='bicoherence'>Estimate bicoherence from given time series data.</h2><span id='topic+bicoherence'></span>

<h3>Description</h3>

<p>Estimate magnitude-squared bicoherence from given real- or complex-valued
time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicoherence(
  data,
  window_function = NULL,
  mc = FALSE,
  mc_cores = getOption("mc.cores", 2L),
  alpha = 0.05,
  p_adjust_method = "BH"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bicoherence_+3A_data">data</code></td>
<td>
<p>Given time series, as a data frame or matrix with which columns
correspond to sampled stretches.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_window_function">window_function</code></td>
<td>
<p>A window function's name for tapering. Defaults to
<code>NULL</code> (&quot;no tapering&quot;).
</p>
<p>Currently the following window functions are available: Hamming window (&quot;hamming&quot;),
Hann window (&quot;hann&quot;), and Blackman window (&quot;blackman&quot;).</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_mc">mc</code></td>
<td>
<p>If <code>TRUE</code>, calculation is done in parallel computation.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_mc_cores">mc_cores</code></td>
<td>
<p>The number of cores in use for parallel computation, passed
<code><a href="parallel.html#topic+mclapply">parallel::mcmapply</a>()</code> etc. as <code>mc.cores</code>.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level of the hypotesis test. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p>The correction method for p-values, given to
<code><a href="stats.html#topic+p.adjust">p.adjust</a>()</code>. Defaults to &quot;BH&quot; (Benjamini and Hochberg).
No correction if a non-character is given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame including the following columns:
</p>

<dl>
<dt>f1:</dt><dd>
<p>The first elements of frequency pairs.
</p>
</dd>
<dt>f2:</dt><dd>
<p>The second elements of frequency pairs.
</p>
</dd>
<dt>value:</dt><dd>
<p>The estimate of magnitude-squared bicoherence at the respective frequency
pair.
</p>
</dd>
<dt>p_value:</dt><dd>
<p>The (corrected, if requested) p-value for hypothesis testing under null
hypothesis that bicoherence is 0.
</p>
</dd>
<dt>significance:</dt><dd>
<p>TRUE if the null hypothesis of the above hypothesis test is rejected
with given <code>alpha</code> level.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Brillinger, D.R. and Irizarry, R.A.
&quot;An investigation of the second- and higher-order spectra of music.&quot;
Signal Processing, Volume 65, Issue 2, 30 March 1998, Pages 161-179.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) {
    sin(2 * x) + sin(3 * x + 1) + sin(2 * x) * sin(3 * x + 1)
}
v &lt;- sapply(seq_len(1280), f) + rnorm(1280)
m &lt;- matrix(v, nrow = 128)
bc1 &lt;- bicoherence(m)
bc2 &lt;- bicoherence(m, "hamming")
bc3 &lt;- bicoherence(m, "hann", mc = TRUE, mc_cores = 1L)

</code></pre>

<hr>
<h2 id='biperiodogram'>Calculate biperiodogram</h2><span id='topic+biperiodogram'></span>

<h3>Description</h3>

<p>Calculate the biperiodogram of real-valued time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biperiodogram(
  x,
  dft_given = FALSE,
  mc = FALSE,
  mc_cores = getOption("mc.cores", 2L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biperiodogram_+3A_x">x</code></td>
<td>
<p>Given time series (or its DFT), as a data frame or matrix with
which columns correspond to sampled stretches</p>
</td></tr>
<tr><td><code id="biperiodogram_+3A_dft_given">dft_given</code></td>
<td>
<p>If TRUE, suppose that DFTs are given instead of time series
data and skip the fast fourier transform. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="biperiodogram_+3A_mc">mc</code></td>
<td>
<p>If <code>TRUE</code>, calculation is done in parallel computation.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="biperiodogram_+3A_mc_cores">mc_cores</code></td>
<td>
<p>The number of cores in use for parallel computation, passed
<code><a href="parallel.html#topic+mclapply">parallel::mcmapply</a>()</code> etc. as <code>mc.cores</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with names
</p>

<dl>
<dt>f1:</dt><dd>
<p>The first elements of frequency pairs.
</p>
</dd>
<dt>f2:</dt><dd>
<p>The second elements of frequency pairs.
</p>
</dd>
<dt>value:</dt><dd>
<p>The biperiodogram as a matrix.
Each of its rows is for a frequency pair; its columns correspond to stretches.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Hinich, M.J., 1994. Higher order cumulants and cumulant spectra. Circuits Systems and Signal Process 13, 391–402. doi:10.1007/BF01183737
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) {
    sin(2 * x) + sin(3 * x + 1) + sin(2 * x) * sin(3 * x + 1)
}
v &lt;- sapply(seq_len(1280), f) + rnorm(1280)
m &lt;- matrix(v, nrow = 128)
bp &lt;- biperiodogram(m)

m2 &lt;- stats::mvfft(m)
bp2 &lt;- biperiodogram(m2, dft_given = TRUE)

</code></pre>

<hr>
<h2 id='bispectrum'>Estimate bispectrum from time series data.</h2><span id='topic+bispectrum'></span>

<h3>Description</h3>

<p>Estimate bispectrum from real- or complex-valued time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bispectrum(
  data,
  window_function = NULL,
  mc = FALSE,
  mc_cores = getOption("mc.cores", 2L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bispectrum_+3A_data">data</code></td>
<td>
<p>Given time series, as a data frame or matrix with which columns
correspond to sampled stretches.</p>
</td></tr>
<tr><td><code id="bispectrum_+3A_window_function">window_function</code></td>
<td>
<p>A window function's name for tapering. Defaults to
<code>NULL</code> (&quot;no tapering&quot;).
</p>
<p>Currently the following window functions are available: Hamming window (&quot;hamming&quot;),
Hann window (&quot;hann&quot;), and Blackman window (&quot;blackman&quot;).</p>
</td></tr>
<tr><td><code id="bispectrum_+3A_mc">mc</code></td>
<td>
<p>If <code>TRUE</code>, calculation is done in parallel computation.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bispectrum_+3A_mc_cores">mc_cores</code></td>
<td>
<p>The number of cores in use for parallel computation, passed
<code><a href="parallel.html#topic+mclapply">parallel::mcmapply</a>()</code> etc. as <code>mc.cores</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame including the following columns:
</p>

<dl>
<dt>f1:</dt><dd>
<p>The first elements of frequency pairs.
</p>
</dd>
<dt>f2:</dt><dd>
<p>The second elements of frequency pairs.
</p>
</dd>
<dt>value:</dt><dd>
<p>The estimated bispectrum at each frequency pair.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Brillinger, D.R. and Irizarry, R.A.
&quot;An investigation of the second- and higher-order spectra of music.&quot;
Signal Processing, Volume 65, Issue 2, 30 March 1998, Pages 161-179.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) {
    sin(2 * x) + sin(3 * x + 1) + sin(2 * x) * sin(3 * x + 1)
}
v &lt;- sapply(seq_len(1280), f) + rnorm(1280)
m &lt;- matrix(v, nrow = 128)
bs1 &lt;- bispectrum(m)
bs2 &lt;- bispectrum(m, "hamming")
bs3 &lt;- bispectrum(m, "blackman", mc = TRUE, mc_cores = 1L)

</code></pre>

<hr>
<h2 id='cross_bicoherence'>Estimate cross-bicoherence from time series data.</h2><span id='topic+cross_bicoherence'></span>

<h3>Description</h3>

<p>Estimate cross-bicoherence from three real-valued time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_bicoherence(
  x,
  y,
  z = y,
  dft_given = FALSE,
  mc = FALSE,
  mc_cores = getOption("mc.cores", 2L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_bicoherence_+3A_x">x</code></td>
<td>
<p>Given 1st time series, as a data frame or matrix with which columns
correspond to sampled stretches.</p>
</td></tr>
<tr><td><code id="cross_bicoherence_+3A_y">y</code></td>
<td>
<p>Given 2nd time series, with the same dimension as x.</p>
</td></tr>
<tr><td><code id="cross_bicoherence_+3A_z">z</code></td>
<td>
<p>Optional 3rd time series, with the same dimension as x (and thus as y).
If omitted, <code>y</code> is used instead.</p>
</td></tr>
<tr><td><code id="cross_bicoherence_+3A_dft_given">dft_given</code></td>
<td>
<p>If TRUE, suppose that DFTs are given instead of time series
data and skip the fast fourier transform. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cross_bicoherence_+3A_mc">mc</code></td>
<td>
<p>If <code>TRUE</code>, calculation is done in parallel computation.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cross_bicoherence_+3A_mc_cores">mc_cores</code></td>
<td>
<p>The number of cores in use for parallel computation, passed
<code><a href="parallel.html#topic+mclapply">parallel::mclapply</a>()</code> etc. as <code>mc.cores</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame including the following columns:
</p>

<dl>
<dt>f1:</dt><dd>
<p>The first elements of frequency pairs.
</p>
</dd>
<dt>f2:</dt><dd>
<p>The second elements of frequency pairs.
</p>
</dd>
<dt>value:</dt><dd>
<p>The estimated value of magnitude-squared cross-bicoherence at the respective
frequency pair.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Kim, Y.C., Powers, E.J., 1979. Digital Bispectral Analysis and Its Applications to Nonlinear Wave Interactions. IEEE Trans. Plasma Sci. 7, 120–131. https://doi.org/10.1109/TPS.1979.4317207
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq_len(1280)
v1 &lt;- sapply(x, function(x) {sin(2 * x)}) + rnorm(1280)
v2 &lt;- sapply(x, function(x) {sin(3 * x + 1)}) + rnorm(1280)
v3 &lt;- sapply(x, function(x) {cos(2 * x) * cos(3 * x + 1)}) + rnorm(1280)
m1 &lt;- matrix(v1, nrow = 128)
m2 &lt;- matrix(v2, nrow = 128)
m3 &lt;- matrix(v3, nrow = 128)
xbc1 &lt;- cross_bicoherence(m1, m2, m3)

d1 &lt;- stats::mvfft(m1)
d2 &lt;- stats::mvfft(m2)
d3 &lt;- stats::mvfft(m3)
xbc2 &lt;- cross_bicoherence(d1, d2, d3, dft_given = TRUE)

xbc3 &lt;- cross_bicoherence(d1, d2, d3, dft_given = TRUE, mc = TRUE, mc_cores = 1L)

</code></pre>

<hr>
<h2 id='cross_bispectrum'>Estimate cross-bispectrum from time series data.</h2><span id='topic+cross_bispectrum'></span>

<h3>Description</h3>

<p>Estimate cross-bispectrum from three real-valued time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_bispectrum(
  x,
  y,
  z = y,
  dft_given = FALSE,
  mc = FALSE,
  mc_cores = getOption("mc.cores", 2L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_bispectrum_+3A_x">x</code></td>
<td>
<p>Given 1st time series, as a data frame or matrix with which columns
correspond to sampled stretches.</p>
</td></tr>
<tr><td><code id="cross_bispectrum_+3A_y">y</code></td>
<td>
<p>Given 2nd time series, with the same dimension as x.</p>
</td></tr>
<tr><td><code id="cross_bispectrum_+3A_z">z</code></td>
<td>
<p>Optional 3rd time series, with the same dimension as x (and thus as y).
If omitted, <code>y</code> is used instead.</p>
</td></tr>
<tr><td><code id="cross_bispectrum_+3A_dft_given">dft_given</code></td>
<td>
<p>If TRUE, suppose that DFTs are given instead of time series
data and skip the fast fourier transform. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cross_bispectrum_+3A_mc">mc</code></td>
<td>
<p>If <code>TRUE</code>, calculation is done in parallel computation.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cross_bispectrum_+3A_mc_cores">mc_cores</code></td>
<td>
<p>The number of cores in use for parallel computation, passed
<code><a href="parallel.html#topic+mclapply">parallel::mclapply</a>()</code> etc. as <code>mc.cores</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame including the following columns:
</p>

<dl>
<dt>f1:</dt><dd>
<p>The first elements of frequency pairs.
</p>
</dd>
<dt>f2:</dt><dd>
<p>The second elements of frequency pairs.
</p>
</dd>
<dt>value:</dt><dd>
<p>The estimated cross-bispectrum at each frequency pair.
</p>
</dd>
</dl>



<h3>References</h3>

<p>K. S. Lii and K. N. Helland. 1981. Cross-Bispectrum Computation and Variance Estimation. ACM Trans. Math. Softw. 7, 3 (September 1981), 284–294. DOI:https://doi.org/10.1145/355958.355961
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq_len(1280)
v1 &lt;- sapply(x, function(x) {sin(2 * x)}) + rnorm(1280)
v2 &lt;- sapply(x, function(x) {sin(3 * x + 1)}) + rnorm(1280)
v3 &lt;- sapply(x, function(x) {cos(2 * x) * cos(3 * x + 1)}) + rnorm(1280)
m1 &lt;- matrix(v1, nrow = 128)
m2 &lt;- matrix(v2, nrow = 128)
m3 &lt;- matrix(v3, nrow = 128)
xbs1 &lt;- cross_bispectrum(m1, m2, m3)

d1 &lt;- stats::mvfft(m1)
d2 &lt;- stats::mvfft(m2)
d3 &lt;- stats::mvfft(m3)
xbs2 &lt;- cross_bispectrum(d1, d2, d3, dft_given = TRUE)

xbs3 &lt;- cross_bispectrum(d1, d2, d3, dft_given = TRUE, mc = TRUE, mc_cores = 1L)

</code></pre>

<hr>
<h2 id='kim_and_powers_model'>A test signal of the phase coherence between three oscillators</h2><span id='topic+kim_and_powers_model'></span>

<h3>Description</h3>

<p>Generate test signals which involve three oscillators described in Kim and Powers (1979).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kim_and_powers_model(
  fbfN = 0.22,
  fcfN = 0.375,
  fdfN = fbfN + fcfN,
  num_points = 128,
  num_records = 64,
  noise_sd = 0.1,
  phase_coherence = TRUE,
  product_term = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kim_and_powers_model_+3A_fbfn">fbfN</code></td>
<td>
<p>b's frequency divided by the Nyquist frequency; <code>0.220</code> by default.</p>
</td></tr>
<tr><td><code id="kim_and_powers_model_+3A_fcfn">fcfN</code></td>
<td>
<p>c's frequency divided by the Nyquist frequency; <code>0.375</code> by default.</p>
</td></tr>
<tr><td><code id="kim_and_powers_model_+3A_fdfn">fdfN</code></td>
<td>
<p>d's frequency divided by the Nyquist frequency; <code>fbfN + fcfN</code> by default.</p>
</td></tr>
<tr><td><code id="kim_and_powers_model_+3A_num_points">num_points</code></td>
<td>
<p>The number of sampling points in a record; 128 by default.</p>
</td></tr>
<tr><td><code id="kim_and_powers_model_+3A_num_records">num_records</code></td>
<td>
<p>The number of records; 64 by default.</p>
</td></tr>
<tr><td><code id="kim_and_powers_model_+3A_noise_sd">noise_sd</code></td>
<td>
<p>The standard deviation of a Gaussian noise perturbing samples; 0.1 (-20dB) by default.</p>
</td></tr>
<tr><td><code id="kim_and_powers_model_+3A_phase_coherence">phase_coherence</code></td>
<td>
<p>If TRUE (default), the phase coherence in the signal d is on; otherwise off.</p>
</td></tr>
<tr><td><code id="kim_and_powers_model_+3A_product_term">product_term</code></td>
<td>
<p>If TRUE, the product of b and c is included in the model; FALSE by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a list of numeric vectors; its each element represents
a test signal in which three oscillators b, c, and d are superimposed.
The ratio of the frequency of b (f1) to the Nyquist frequency is 0.220 and
the ratio of the frequency of c (f2) to the Nyquist frequency is 0.375, by default.
The d's frequency f3 is equal to f1 + f2 unless specified otherwise.
Optionally the product of b and c is also added to signals.
</p>


<h3>Value</h3>

<p>A matrix of <code>num_points</code> rows x <code>num_records</code> columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- kim_and_powers_model()

</code></pre>

<hr>
<h2 id='mode_matching'>Estimate cross-bicoherence's empirical null distribution by a mode matching method</h2><span id='topic+mode_matching'></span>

<h3>Description</h3>

<p>Estimate false discovery rate by fitting scaled chi-squared distribution as an empirical null of cross-bicoherence with Schwartzman's mode matching method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_matching(xbc, t_max = NULL, d = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mode_matching_+3A_xbc">xbc</code></td>
<td>
<p>cross-bicoherence, returned from <code>cross_bicoherence</code>.</p>
</td></tr>
<tr><td><code id="mode_matching_+3A_t_max">t_max</code></td>
<td>
<p>the upper limit of interval </p>
<p style="text-align: center;"><code class="reqn">S_0</code>
</p>
<p>, see the reference.</p>
</td></tr>
<tr><td><code id="mode_matching_+3A_d">d</code></td>
<td>
<p>the bin width of the tuning parameter.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schwartzman, Armin. “Empirical Null and False Discovery Rate Inference for Exponential Families.” Annals of Applied Statistics 2, no. 4 (December 2008): 1332–59. https://doi.org/10.1214/08-AOAS184.
</p>

<hr>
<h2 id='three_channel_model'>A three-channel model of quadratic phase coupling</h2><span id='topic+three_channel_model'></span>

<h3>Description</h3>

<p>Simulate observations by a three-channel model of quadratic phase coupling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>three_channel_model(
  f1,
  f2,
  f3,
  num_samples = 256,
  num_observations = 100,
  input_freq = c(1.2, 0.7, 0.8),
  noise_sd = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="three_channel_model_+3A_f1">f1</code></td>
<td>
<p>A function of period <code class="reqn">2 \pi</code> for the first channel.</p>
</td></tr>
<tr><td><code id="three_channel_model_+3A_f2">f2</code></td>
<td>
<p>A function of period <code class="reqn">2 \pi</code> for the second channel.</p>
</td></tr>
<tr><td><code id="three_channel_model_+3A_f3">f3</code></td>
<td>
<p>A function of period <code class="reqn">2 \pi</code> for the third channel.</p>
</td></tr>
<tr><td><code id="three_channel_model_+3A_num_samples">num_samples</code></td>
<td>
<p>The number of sampling points in an observation.</p>
</td></tr>
<tr><td><code id="three_channel_model_+3A_num_observations">num_observations</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="three_channel_model_+3A_input_freq">input_freq</code></td>
<td>
<p>The scaling factor for the frequencies of input periodic functions.
It can be a scalar or a vector of length three.
If a scalar is given, the same frequency is used for all of inputs.</p>
</td></tr>
<tr><td><code id="three_channel_model_+3A_noise_sd">noise_sd</code></td>
<td>
<p>The standard deviation of a Gaussian noise perturbing samples.
It can be a scalar or a vector of length three.
If a scalar is given, the same value is used for all of noises.
Giving 0 is possible and specifies no noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given three periodic functions, this function generates a list of three data
frames in which each column represents a simulated observation at a channel.
The phase is chosen at random from <code class="reqn">[0, 2 \pi]</code> for each
observation and each channel.
</p>


<h3>Value</h3>

<p>A list of six data frames:
<code>i1</code>, <code>i2</code>, <code>i3</code>, <code>o1</code>, <code>o2</code>, and <code>o3</code>.
Each element has <code>num_observations</code> columns and <code>num_samples</code> rows.
<code>i1</code>, <code>i2</code>, and <code>i3</code> are observations of input signals;
<code>o1</code>, <code>o2</code>, and <code>o3</code> are of output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sawtooth &lt;- function(r) {
    x &lt;- r/(2*pi)
    x - floor(x) - 0.5
}
data &lt;- three_channel_model(cos, sin, sawtooth,
                            input_freq = c(0.2, 0.3, 0.4),
                            noise_sd = 0.9)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
