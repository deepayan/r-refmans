<!DOCTYPE html><html lang="en"><head><title>Help for package SparseFunClust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SparseFunClust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cer'><p>CER function</p></a></li>
<li><a href='#generate.data.FV17'><p>Data generation: no-misalignment case</p></a></li>
<li><a href='#SparseFunClust'><p>Compute Sparse Functional Clustering &amp; Alignment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Sparse Functional Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a general framework for performing sparse functional
    clustering as originally described in Floriello and Vitelli (2017)
    &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2016.10.008">doi:10.1016/j.jmva.2016.10.008</a>&gt;, with the possibility of jointly handling
    data misalignment (see Vitelli, 2019, &lt;<a href="https://doi.org/10.48550%2FarXiv.1912.00687">doi:10.48550/arXiv.1912.00687</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-28 12:29:15 UTC; waldir</td>
</tr>
<tr>
<td>Author:</td>
<td>Valeria Vitelli [aut],
  Waldir Leoncio [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Waldir Leoncio &lt;w.l.netto@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-28 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cer'>CER function</h2><span id='topic+cer'></span>

<h3>Description</h3>

<p>Given two partitions P and Q, <code>cer(P, Q)</code> measures how well
they agree,
the lower the better. It is rigorously defined as the proportion of pairwise
disagreements in the two partitions (i.e., how many, out of all the possible
couples of elements in the sample, are localized in the same cluster in one
partition and in a different one in the other partition).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cer(P, Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cer_+3A_p">P</code></td>
<td>
<p>first vector of cluster assignments (length n)</p>
</td></tr>
<tr><td><code id="cer_+3A_q">Q</code></td>
<td>
<p>second vector of cluster assignments (length n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The CER index, which is a number between 0 and 1, and also equal to
1 - Rand index (Rand, 1971), a popular measure of the goodness of a
clustering.
</p>


<h3>References</h3>

<p>Rand, W. M. (1971). Objective criteria for the evaluation of
clustering methods. Journal of the American Statistical association, 66(336),
846-850.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(8988327)
x &lt;- seq(0, 1, len = 500)
out &lt;- generate.data.FV17(50, x)
result &lt;- SparseFunClust(out$data, x, K = 2, do.alignment = FALSE)
cer(out$true.partition, result$labels)
</code></pre>

<hr>
<h2 id='generate.data.FV17'>Data generation: no-misalignment case</h2><span id='topic+generate.data.FV17'></span>

<h3>Description</h3>

<p>this function generates a set of simulated functional data in
2 clusters that reproduce the examples in Simulations 2A and 2B in
Floriello &amp; Vitelli (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.data.FV17(n, x, paramC = 0.5, plots = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate.data.FV17_+3A_n">n</code></td>
<td>
<p>number of curves</p>
</td></tr>
<tr><td><code id="generate.data.FV17_+3A_x">x</code></td>
<td>
<p>curves' domain</p>
</td></tr>
<tr><td><code id="generate.data.FV17_+3A_paramc">paramC</code></td>
<td>
<p>proportion of cluster overlap (default 0.5, as in Simulation 2A)</p>
</td></tr>
<tr><td><code id="generate.data.FV17_+3A_plots">plots</code></td>
<td>
<p>boolean; should plots be drawn (<code>FALSE</code> default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including:
</p>

<ul>
<li><p><code>$data</code> matrix (n x <code>length(x)</code>) with the simulated data
</p>
</li>
<li><p><code>$true.partition</code> vector (length = n) with the true cluster assignments
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>generate.data.FV17(5, seq(0, 1, len = 3))
</code></pre>

<hr>
<h2 id='SparseFunClust'>Compute Sparse Functional Clustering &amp; Alignment</h2><span id='topic+SparseFunClust'></span>

<h3>Description</h3>

<p>Compute Sparse Functional Clustering &amp; Alignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseFunClust(
  data,
  x,
  K,
  do.alignment,
  funct.measure = "L2",
  clust.method = "kmea",
  m.prop = 0.3,
  tuning.m = FALSE,
  tuning.par = list(mbound = NULL, nperm = 20),
  perc = 0.03,
  tol = 0.01,
  template.est = "raw",
  n.out = 500,
  iter.max = 50,
  vignette = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SparseFunClust_+3A_data">data</code></td>
<td>
<p>matrix representing the functions (n x p)</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_x">x</code></td>
<td>
<p>matrix giving the domain of each function (n x p), or a
p-dimensional vector giving the common domain</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_k">K</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_do.alignment">do.alignment</code></td>
<td>
<p>boolean (should alignment be performed?)</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_funct.measure">funct.measure</code></td>
<td>
<p>the functional measure to be used to compare the
functions in both the clustering and alignment procedures;
can be 'L2' or 'H1' (default 'L2'); see Vitelli (2019) for details</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_clust.method">clust.method</code></td>
<td>
<p>the clustering method to be used; can be:
'kmea' for k-means clustering,'pam','hier' for hierarchical clustering</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_m.prop">m.prop</code></td>
<td>
<p>the sparsity parameter (proportion of unrelevant domain
where w(x) = 0); default 30%</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_tuning.m">tuning.m</code></td>
<td>
<p>boolean (should the sparsity parameter be tuned via a
permutation-based approach?)</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_tuning.par">tuning.par</code></td>
<td>
<p>list of settings for the tuning of the sparsity parameter
(defaults to <code>list(mbound = NULL, nperm = 20)</code>: mbound = max value of
the sparsity parameter to be tested, default 60%; nperm = number of
permutations to be performed in the tuning, default 20</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_perc">perc</code></td>
<td>
<p>alignment parameter (max proportion of shift / dilation at each iter
of the warping procedure) &ndash;&gt; (default 3%)</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_tol">tol</code></td>
<td>
<p>tolerance criterion on the weighting function to exit the loop (default 1%)</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_template.est">template.est</code></td>
<td>
<p>text string giving choices for the template estimation method</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_n.out">n.out</code></td>
<td>
<p>number of abscissa points on which w(x) is estimated (default 500)</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_iter.max">iter.max</code></td>
<td>
<p>maximum number of iterations of the clustering loop (default 50)</p>
</td></tr>
<tr><td><code id="SparseFunClust_+3A_vignette">vignette</code></td>
<td>
<p>boolean (should the algorithm progress be reported?)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, with elements:
</p>

<dl>
<dt>template</dt><dd><p>matrix (dim=K x n.out) with the final cluster templates</p>
</dd>
<dt>temp.abscissa</dt><dd><p>vector (length=n.out) of the abscissa values on which the template is defined</p>
</dd>
<dt>labels</dt><dd><p>vector (length=n) of the cluster assignments</p>
</dd>
<dt>warping</dt><dd><p>matrix (dim=n x 2) with the intercept (1st column) and slope (2nd column)
of the estimated warping function for each of the n curves</p>
</dd>
<dt>reg.abscissa</dt><dd><p>matrix (dim=n x n.out) of each of the n curves registered abscissa</p>
</dd>
<dt>distance</dt><dd><p>vector (length=n) of each curve's final distance to the assigned cluster template</p>
</dd>
<dt>w</dt><dd><p>vector (length=n.out) of the estimated weighting function w(x)</p>
</dd>
<dt>x.bcss</dt><dd><p>vector (length=n.out) of the final point-wise between-cluster sum-of-squares</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>data</code>:
</p>

<ol>
<li><p> assumed to be a vectorized version of the functional data AFTER smoothing
</p>
</li>
<li><p> when using the H1 functional measure, assumed to include the
functions FIRST DERIVATIVES
</p>
</li>
<li><p> when using the H1 functional measure, it supports multidimensional
functions R -&gt; R^d, then data can be an array (n x p x d)]
</p>
</li></ol>

<p><code>funct.measure</code>: 'H1' only supported with alignment
</p>
<p><code>clust.method</code>: 'pam' and 'hier' only supported for the case of
NO ALIGNMENT
</p>
<p><code>m.prop</code>: needs to be a proportion for compatibility with alignment,
values &gt; 1 not supported
</p>
<p><code>tuning.m</code>: tuning only supported for the case of NO ALIGNMENT
</p>
<p><code>tuning.par</code>:
</p>

<ul>
<li> <p><code>mbound</code> must be lower than 1; the minimal value tested is 0
</p>
</li>
<li> <p><code>nperm</code> &gt; 50 is unadvisable for computational reasons
</p>
</li></ul>

<p><code>perc</code>: 5% is already extreme; don't set this above 8-10%
</p>
<p><code>template.est</code>:
</p>

<ol>
<li><p> only supported with H1 measure + ALIGNMENT
</p>
</li>
<li><p> currently 2 choices are supported:'raw' or 'loess'. 'raw' just
computes the vector means across functions (default choice); 'loess'
estimates the template via the R loess function
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(8988327)
x &lt;- seq(0, 1, len = 500)
out &lt;- generate.data.FV17(50, x)
result &lt;- SparseFunClust(out$data, x, K = 2, do.alignment = FALSE)
str(result)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
