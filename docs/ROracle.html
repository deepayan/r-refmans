<!DOCTYPE html><html><head><title>Help for package ROracle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ROracle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dbCommit-methods'>
<p>DBMS Transaction Management</p></a></li>
<li><a href='#dbConnect-methods'>
<p>Create a Connection Object to an Oracle DBMS</p></a></li>
<li><a href='#dbDriver-methods'>
<p>Oracle Implementation of the Database Interface (DBI) Classes and Drivers</p></a></li>
<li><a href='#dbGetInfo-methods'>
<p>Database interface Metadata</p></a></li>
<li><a href='#dbListConnections-methods'>
<p>List items from Oracle objects</p></a></li>
<li><a href='#dbReadTable-methods'>
<p>Convenience Functions for Manipulating DBMS Tables</p></a></li>
<li><a href='#dbSendQuery-methods'>
<p>Execute a Statement on a Given Database Connection</p></a></li>
<li><a href='#ExtDriver-class'><p>Class ExtDriver</p></a></li>
<li><a href='#fetch-methods'>
<p>Fetch records from a previously executed query</p></a></li>
<li><a href='#Oracle'>
<p>Instantiate an Oracle client from the current <span class="rlang"><b>R</b></span> session</p></a></li>
<li><a href='#OraConnection-class'><p>Class OraConnection</p></a></li>
<li><a href='#OraDriver-class'><p>Class OraDriver</p></a></li>
<li><a href='#OraResult-class'><p>Class OraResult</p></a></li>
<li><a href='#summary-methods'>
<p>Summarize an Oracle object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3-1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-10-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Denis Mukhin, David A. James and Jake Luciani</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rajendra S. Pingte &lt;rajendra.pingte@oracle.com&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>OCI Based Oracle Database Interface for R</td>
</tr>
<tr>
<td>Description:</td>
<td>Oracle Database interface (DBI) driver for R.
   This is a DBI-compliant Oracle driver based on the OCI.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Oracle Instant Client or Oracle Database Client</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, DBI (&ge; 0.2-5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.oracle.com">http://www.oracle.com</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>dbi.R oci.R zzz.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-10 11:43:18 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-10 12:22:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='dbCommit-methods'>
DBMS Transaction Management
</h2><span id='topic+dbCommit'></span><span id='topic+dbRollback'></span><span id='topic+dbCommit+2COraConnection-method'></span><span id='topic+dbRollback+2COraConnection-method'></span>

<h3>Description</h3>

<p>Commits or roll backs the current transaction 
in an Oracle connection 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OraConnection'
dbCommit(conn, ...)
## S4 method for signature 'OraConnection'
dbRollback(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbCommit-methods_+3A_conn">conn</code></td>
<td>

<p>a <code>OraConnection</code> object, as produced by the function <code>dbConnect</code>
</p>
</td></tr>
<tr><td><code id="dbCommit-methods_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>dbCommit</dt><dd>
<p>implementation saves all changes done on that connection. 
Changes can not be undone once saved permanently.
</p>
</dd>
<dt>dbRollback</dt><dd>
<p>implementation undo all chnages done after last savepoint.
</p>
</dd>
</dl>



<h3>Side Effects</h3>


<dl>
<dt>dbCommit</dt><dd>
<p>saves changes permanently.
</p>
</dd>
<dt>dbRollback</dt><dd>
<p>undo all changes done after last save point.
</p>
</dd>
</dl>



<h3>References</h3>

<p>For the Oracle Database documentaion see 
<a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">http://www.oracle.com/technetwork/indexes/documentation/index.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Oracle">Oracle</a></code>,
<code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>,
<code><a href="DBI.html#topic+dbSendQuery">dbSendQuery</a></code>,
<code><a href="DBI.html#topic+dbGetQuery">dbGetQuery</a></code>,
<code><a href="DBI.html#topic+fetch">fetch</a></code>,
<code><a href="DBI.html#topic+dbCommit">dbCommit</a></code>,
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>,
<code><a href="DBI.html#topic+dbReadTable">dbReadTable</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    drv &lt;- dbDriver("Oracle")
    con &lt;- dbConnect(drv, "scott", "tiger")
    dbReadTable(con, "EMP")
    rs &lt;- dbSendQuery(con, "delete from emp where deptno = 10")
    dbReadTable(con, "EMP")
    if(dbGetInfo(rs, what = "rowsAffected") &gt; 1)
    {
      warning("dubious deletion -- rolling back transaction")
      dbRollback(con)
    }
    dbReadTable(con, "EMP")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='dbConnect-methods'>
Create a Connection Object to an Oracle DBMS
</h2><span id='topic+dbConnect'></span><span id='topic+dbDisconnect'></span><span id='topic+dbConnect+2COraDriver-method'></span><span id='topic+dbConnect+2CExtDriver-method'></span><span id='topic+dbDisconnect+2COraConnection-method'></span>

<h3>Description</h3>

<p>These methods are straightforward implementations of the corresponding
generic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OraDriver'
dbConnect(drv, username = "", password = "", dbname = "", prefetch = FALSE,
          bulk_read = 1000L, bulk_write = 1000L, stmt_cache = 0L,
          external_credentials = FALSE, sysdba = FALSE, ...)
## S4 method for signature 'ExtDriver'
dbConnect(drv, prefetch = FALSE, bulk_read = 1000L,
          bulk_write = 1000L, stmt_cache = 0L,
          external_credentials = FALSE, sysdba = FALSE, ...)
## S4 method for signature 'OraConnection'
dbDisconnect(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbConnect-methods_+3A_drv">drv</code></td>
<td>

<p>An object of class <code>OraDriver</code> or <code>ExtDriver</code>.
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_conn">conn</code></td>
<td>

<p>An <code>OraConnection</code> object as produced by <code>dbConnect</code>.
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_username">username</code></td>
<td>

<p>A character string specifying a user name.
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_password">password</code></td>
<td>

<p>A character string specifying a password.
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_dbname">dbname</code></td>
<td>

<p>A character string specifying a connect identifier (for more
information refer to Chapter 8, Configuring Naming Methods, of Oracle
Database Net Services Administrator's Guide). This is the same as part
of the SQL*Plus connect string that follows the '@' sign. 
If you are using Oracle Wallet to store username and password, 
then this string should be the connect string used to create the 
wallet mapping (for more information, refer to Configuring Clients to Use
the External Password Store in Chapter 3 of Oracle Database Security Guide).
Connect identifiers for an Oracle TimesTen IMDB instance are supported via
the OCI tnsnames or easy connect naming methods. For additional information
on TimesTen connections for OCI see chapter 3, TimesTen Support for OCI, of
TimesTen In-Memory C Developer's Guide.
Examples below show various ways to specify the connect identifier.
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_prefetch">prefetch</code></td>
<td>

<p>A logical value indicating TRUE or FALSE. When set to TRUE, ROracle will use
OCI prefetch buffers to retrieve additional data from the server thus saving
memory required in RODBI/ROOCI by allocating a single row buffer to fetch 
the data from OCI. Using prefetch results in a fetch call for every row. By
default, prefetch is FALSE and array fetch is used to retrieve the data from
the server.
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_bulk_read">bulk_read</code></td>
<td>

<p>An integer value indicating the number of rows to fetch at a time. The
default value is 1000L. When the prefetch option is selected, memory is
allocated for prefetch buffers and OCI will fetch that many rows at a time.
When prefetch is not used (the default), memory is allocated in RODBI/ROOCI
define buffers. Setting this to a large value will result in more memory
allocated based on the number of columns in the select list and the types
of columns. For a column of type character, define buffers are allocated
using the maximum width times the NLS maximum width. Applications should
adjust this value based on the query result and a larger value will benefit
queries that return a large result. An application can tune this value as
needed.
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_bulk_write">bulk_write</code></td>
<td>

<p>An integer value indicating the number of rows to insert, update or delete
at a time. The default value is 1000L. When the bulk_write value is given
in argument, memory is allocated for buffers and OCI will write that many
rows at a time. When bulk_write argument is not given, the default value
1000 is used to allocate memory for the bind buffers. Setting this to a
large value will result in more memory allocated based on the number of
columns in the insert list and the types of columns.
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_stmt_cache">stmt_cache</code></td>
<td>

<p>An integer value indicating the number of statements to cache. It means 
that cursors are ready to be used without the need to parse the statements 
again. The default value is 0L. If stmt_cache value is greater than 0L then
<code>prefetch</code> value must be set to TRUE. 
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_external_credentials">external_credentials</code></td>
<td>

<p>A logical value indicating TRUE or FALSE. When set to TRUE, ROracle will
begin OCI session authenticated with external credentials on the connection.
The default value is FALSE.
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_sysdba">sysdba</code></td>
<td>

<p>A logical value indicating TRUE or FALSE. When set to TRUE, ROracle will
begin OCI session with SYSDBA privileges on the connection. The default
value is FALSE.
</p>
</td></tr>
<tr><td><code id="dbConnect-methods_+3A_...">...</code></td>
<td>

<p>Currently unused.
</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>dbConnect</dt><dd>
<p>This connection object is used to execute operations on the database.
</p>
<p>When <code>prefetch</code> is set to TRUE, it allows the use of the OCI
prefetch buffer to retrieve additional data from the server.
</p>
<p>The <code>bulk_read</code> argument is used to set an integer value indicating
the number of rows to fetch at a time.
</p>
<p>The <code>bulk_write</code> argument is used to set an integer value
indicating the number of rows to write at a time.
</p>
<p>The <code>stmt_cache</code> argument is used to enable or disable the statement
caching feature. Its value specifies the statement cache size.
</p>
<p>The <code>external_credentials</code> argument is used to begin OCI session
authenticated with external credentials on the connection.
</p>
<p>The <code>sysdba</code> argument is used to begin OCI session with SYSDBA
privileges on the connection.
</p>
<p>When establishing a connection with an <code>ExtDriver</code> driver, none
of the arguments specifying credentials are used. A connection in this
mode is a singleton object, that is, all calls to <code>dbConnect</code>
return the same connection object.
</p>
</dd>
<dt>dbDisconnect</dt><dd>
<p>This implementation disconnects the connection between R and the database
server.  It frees all resources used by the connection object. It frees
all result sets associated with this connection object.
</p>
</dd>
</dl>



<h3>Value</h3>

<table>
<tr><td><code>dbConnect</code></td>
<td>

<p>An object <code>OraConnection</code> whose class extends <code>DBIConnection</code>. 
This object is used to execute SQL queries on the database.
</p>
</td></tr>
<tr><td><code>dbDisconnect</code></td>
<td>

<p>A logical value indicating whether the operation succeeded or not.
</p>
</td></tr>
</table>


<h3>Side Effects</h3>


<dl>
<dt>dbConnect</dt><dd>
<p>Establishes a connection between R and an Oracle Database server.
</p>
</dd>
<dt>dbDisconnect</dt><dd>
<p>Frees resources used by the connection object.
</p>
</dd>
</dl>



<h3>References</h3>

<p>For the Oracle Database documentation see
<a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">http://www.oracle.com/technetwork/indexes/documentation/index.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Oracle">Oracle</a></code>,
<code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>,
<code><a href="DBI.html#topic+dbSendQuery">dbSendQuery</a></code>,
<code><a href="DBI.html#topic+dbGetQuery">dbGetQuery</a></code>,
<code><a href="DBI.html#topic+fetch">fetch</a></code>,
<code><a href="DBI.html#topic+dbCommit">dbCommit</a></code>,
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>,
<code><a href="DBI.html#topic+dbReadTable">dbReadTable</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    ## Create an Oracle Database instance and create one connection on the
    ## same machine.
    drv &lt;- dbDriver("Oracle")

    ## Use username/password authentication.
    con &lt;- dbConnect(drv, username = "scott", password = "tiger")

    ## Run a SQL statement by creating first a resultSet object.
    rs &lt;- dbSendQuery(con, "select * from emp where deptno = 10")

    ## We now fetch records from the resultSet into a data.frame.
    data &lt;- fetch(rs)       ## extract all rows
    dim(data)
  
## End(Not run)
  ## Not run: 
    ## Create an Oracle Database instance and create one connection to a
    ## remote database using the SID in the connect string. 
    drv &lt;- dbDriver("Oracle")

    ## Refer to Oracle Database Net Services Administator's Guide for
    ## details on connect string specification.
    host &lt;- "myhost"
    port &lt;- 1521
    sid &lt;- "mysid"
    connect.string &lt;- paste(
      "(DESCRIPTION=",
      "(ADDRESS=(PROTOCOL=tcp)(HOST=", host, ")(PORT=", port, "))",
        "(CONNECT_DATA=(SID=", sid, ")))", sep = "")

    ## Use username/password authentication.
    con &lt;- dbConnect(drv, username = "scott", password = "tiger",
                     dbname = connect.string)

    ## Run a SQL statement by creating first a resultSet object.
    rs &lt;- dbSendQuery(con, "select * from emp where deptno = 10")

    ## We now fetch records from the resultSet into a data.frame.
    data &lt;- fetch(rs)       ## extract all rows
    dim(data)
  
## End(Not run)
  ## Not run: 
    ## Create an Oracle Database instance and create one connection to a
    ## remote database using the service name.
    drv &lt;- dbDriver("Oracle")

    ## Refer to Oracle Database Net Services Administator's Guide for
    ## details on connect string specification.

    host &lt;- "myhost"
    port &lt;- 1521
    svc &lt;- "mydb.example.com"
    connect.string &lt;- paste(
      "(DESCRIPTION=",
      "(ADDRESS=(PROTOCOL=tcp)(HOST=", host, ")(PORT=", port, "))",
      "(CONNECT_DATA=(SERVICE_NAME=", svc, ")))", sep = "")
    ## Use username/password authentication.
    con &lt;- dbConnect(drv, username = "scott", password = "tiger",
                     dbname = connect.string)

    ## Run a SQL statement by creating first a resultSet object.
    rs &lt;- dbSendQuery(con, "select * from emp where deptno = 10")

    ## We now fetch records from the resultSet into a data.frame.
    data &lt;- fetch(rs)       ## extract all rows
    dim(data)
  
## End(Not run)
  ## Not run: 
    ## Create an Oracle Database instance and create one connection.
    drv &lt;- dbDriver("Oracle")

    ## Use Oracle Wallet authentication.
    con &lt;- dbConnect(drv, username ="", password="", 
    dbname = "&lt;wallet_connect_string&gt;")

    ## Run a SQL statement by creating first a resultSet object.
    rs &lt;- dbSendQuery(con, "select * from emp where deptno = 10")

    ## We now fetch records from the resultSet into a data.frame.
    data &lt;- fetch(rs)       ## extract all rows
    dim(data)
  
## End(Not run)
  ## Not run: 
    ## Create an Oracle Database instance and create one connection.
    drv &lt;- dbDriver("Oracle")

    ## Connect to a TimesTen IMDB instance using the easy connect 
    ## naming method where SampleDb is a direct driver TimesTen DSN.
    con &lt;- dbConnect(drv, username ="scott", password="tiger", 
                     dbname = "localhost/SampleDb:timesten_direct")

    ## Run a SQL statement by creating first a resultSet object.
    rs &lt;- dbSendQuery(con, "select * from dual")

    ## We now fetch records from the resultSet into a data.frame.
    data &lt;- fetch(rs)       ## extract all rows
    dim(data)
  
## End(Not run)
  ## Not run: 
    ## Connect to an extproc (this assumes that the driver has already
    ## been initialized in the embedded R code by passing an external
    ## pointer representing the extproc context).
    con &lt;- dbConnect(Extproc())

    ## Run a SQL statement by creating first a resultSet object.
    rs &lt;- dbSendQuery(con, "select * from dual")

    ## We now fetch records from the resultSet into a data.frame.
    data &lt;- fetch(rs)       ## extract all rows
    dim(data)
  
## End(Not run)
  ## Not run: 
    ## Create an Oracle Database instance and create one connection.
    drv &lt;- dbDriver("Oracle")

    ## Create connection with SYSDBA privileges.
    con &lt;- dbConnect(drv, username ="scott", password="tiger",
                     sysdba = TRUE)

    ## Run a SQL statement by creating first a resultSet object.
    rs &lt;- dbSendQuery(con, "select * from emp where deptno = 10")

    ## We now fetch records from the resultSet into a data.frame.
    data &lt;- fetch(rs)       ## extract all rows
    dim(data)
  
## End(Not run)
  ## Not run: 
    ## Create an Oracle Database instance and create one connection.
    drv &lt;- dbDriver("Oracle")
    
    ## Use OS authentication as an example of external authentication
    ## Make sure that databse user exist to allow an OS authentication

    ## Create connection authenticated with external credentials.
    con &lt;- dbConnect(drv, username ="", password="",
                     external_credentials = TRUE)
    
    ## Above dbConnect() used OS credentials to connect with database.

    ## Run a SQL statement by creating first a resultSet object.
    rs &lt;- dbSendQuery(con, "select * from emp where deptno = 10")

    ## We now fetch records from the resultSet into a data.frame.
    data &lt;- fetch(rs)       ## extract all rows
    dim(data)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='dbDriver-methods'>
Oracle Implementation of the Database Interface (DBI) Classes and Drivers
</h2><span id='topic+dbUnloadDriver'></span><span id='topic+dbUnloadDriver+2COraDriver-method'></span><span id='topic+dbUnloadDriver+2CExtDriver-method'></span>

<h3>Description</h3>

<p>Oracle driver initialization and closing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OraDriver'
dbUnloadDriver(drv, ...)
## S4 method for signature 'ExtDriver'
dbUnloadDriver(drv, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbDriver-methods_+3A_drv">drv</code></td>
<td>

<p>An object that inherits from <code>OraDriver</code> or <code>ExtDriver</code>
as created by <code>dbDriver</code>.
</p>
</td></tr>
<tr><td><code id="dbDriver-methods_+3A_...">...</code></td>
<td>

<p>Any other arguments to pass to the driver <code>drvName</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>dbDriver</dt><dd>
<p>This object is a singleton, that is, subsequent invocations of
<code>dbDriver</code> return the same initialized object.
</p>
<p>This implementation allows you to connect to multiple host servers and
run multiple connections on each server simultaneously.
</p>
<p>When <code>interruptible</code> is set to TRUE, it allows for interrupting
long-running queries on the server by executing the query in a thread.
Main thread checks for Ctrl-C and issues OCIBreak/OCIReset to cancel the
operation on the server. By default, <code>interruptible</code> is FALSE.
</p>
<p>When <code>unicode_as_utf8</code> is set to FALSE, NCHAR, NVARCHAR and NCLOB
data is fetched using the character set specified by the NLS_LANG
setting. By default, <code>unicode_as_utf8</code> is set to TRUE.
</p>
<p>When <code>ora.attributes</code> is set to TRUE, the result set from
<code>dbGetQuery</code> and <code>fetch</code> contains DBMS-specific attributes like
<code>ora.encoding</code>, <code>ora.type</code>, and <code>ora.maxlength</code> for the
corresponding column.
</p>
</dd>
<dt>dbUnloadDriver</dt><dd>
<p>This implementation removes communication links between the <span class="rlang"><b>R</b></span> client and
the database. It frees all connections and all result sets associated
with those connection objects.
</p>
</dd>
</dl>



<h3>Value</h3>

<table>
<tr><td><code>dbDriver</code></td>
<td>

<p>An object <code>OraDriver</code> or <code>ExtDriver</code> whose class extends
<code>DBIDriver</code>. This object is used to create connections, using the
function <code>dbConnect</code>, to one or more Oracle Database engines.
</p>
</td></tr>
<tr><td><code>dbUnloadDriver</code></td>
<td>

<p>Free all resources occupied by the driver object.
</p>
</td></tr>
</table>


<h3>Side Effects</h3>


<dl>
<dt>dbDriver</dt><dd>
<p>The <span class="rlang"><b>R</b></span> client part of the database communication is initialized,
but note that connecting to the database engine needs to be done through
calls to <code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>.
</p>
</dd>
<dt>dbUnloadDriver</dt><dd>
<p>Remove the communication link between the <span class="rlang"><b>R</b></span> client and the database.
</p>
</dd>
</dl>



<h3>References</h3>

<p>For Oracle Database documentation, see
<a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">http://www.oracle.com/technetwork/indexes/documentation/index.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Oracle">Oracle</a></code>,
<code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>,
<code><a href="DBI.html#topic+dbSendQuery">dbSendQuery</a></code>,
<code><a href="DBI.html#topic+dbGetQuery">dbGetQuery</a></code>,
<code><a href="DBI.html#topic+fetch">fetch</a></code>,
<code><a href="DBI.html#topic+dbCommit">dbCommit</a></code>,
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>,
<code><a href="DBI.html#topic+dbListTables">dbListTables</a></code>,
<code><a href="DBI.html#topic+dbReadTable">dbReadTable</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    # first load the library
    library("ROracle")

    # create an Oracle instance
    drv &lt;- dbDriver("Oracle")

    con &lt;- dbConnect(drv, "scott", "tiger")
    dbListTables(con)

    # fetch all results from the emp table
    res &lt;- dbGetQuery(con, "select * from emp")

    # dbSendQuery can be used to fetch data in chunks 
    # as well as all of data at once
    res &lt;- dbSendQuery(con, "select * from emp")

    # fetch all results
    fetch(res)

    # or a chunk at a time
    fetch(res, n = 5)

    # describing the schema for the emp table using dbGetInfo
    dbGetInfo(res, what = 'fields')

    # clear the result
    dbClearResult(res)

    # disconnect from the database
    dbDisconnect(con)

    # free the driver object
    dbUnloadDriver(drv)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='dbGetInfo-methods'>
Database interface Metadata
</h2><span id='topic+dbGetInfo'></span><span id='topic+dbGetStatement'></span><span id='topic+dbGetRowCount'></span><span id='topic+dbGetRowsAffected'></span><span id='topic+dbColumnInfo'></span><span id='topic+dbHasCompleted'></span><span id='topic+dbGetInfo+2COraDriver-method'></span><span id='topic+dbGetInfo+2CExtDriver-method'></span><span id='topic+dbGetInfo+2COraConnection-method'></span><span id='topic+dbGetInfo+2COraResult-method'></span><span id='topic+dbGetStatement+2COraResult-method'></span><span id='topic+dbGetRowCount+2COraResult-method'></span><span id='topic+dbGetRowsAffected+2COraResult-method'></span><span id='topic+dbColumnInfo+2COraResult-method'></span><span id='topic+dbHasCompleted+2COraResult-method'></span>

<h3>Description</h3>

<p>These methods are straight-forward implementations of the corresponding
generic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OraDriver'
dbGetInfo(dbObj, ...)
## S4 method for signature 'ExtDriver'
dbGetInfo(dbObj, ...)
## S4 method for signature 'OraConnection'
dbGetInfo(dbObj, what, ...)
## S4 method for signature 'OraResult'
dbGetInfo(dbObj, what, ...)
## S4 method for signature 'OraResult'
dbGetStatement(res, ...)
## S4 method for signature 'OraResult'
dbGetRowCount(res, ...)
## S4 method for signature 'OraResult'
dbGetRowsAffected(res, ...)
## S4 method for signature 'OraResult'
dbColumnInfo(res, ...)
## S4 method for signature 'OraResult'
dbHasCompleted(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbGetInfo-methods_+3A_dbobj">dbObj</code></td>
<td>

<p>Any object that implements some functionality in the R
interface to databases (a driver, a connection, or a result set).
</p>
</td></tr>
<tr><td><code id="dbGetInfo-methods_+3A_what">what</code></td>
<td>
<p>A character string specifying an element of the output list.</p>
</td></tr>
<tr><td><code id="dbGetInfo-methods_+3A_res">res</code></td>
<td>
<p>An <code>OraResult</code>.</p>
</td></tr>
<tr><td><code id="dbGetInfo-methods_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Table, schema, and column names are case sensitive, for example, table
names <code>ABC</code> and <code>abc</code> are not the same. All database schema
object names should not include double quotes as they are enclosed in
double quotes when the corresponding SQL statement is generated.
</p>
<p>The <span class="pkg">ROracle</span> method <code>dbGetInfo</code> provides following details about
the driver object:
</p>

<ul>
<li> <p>\$driverName The name of the driver, &quot;Oracle (OCI)&quot;
</p>
</li>
<li> <p>\$driverVersion The version of the ROracle driver used
</p>
</li>
<li> <p>\$clientVersion The version of the Oracle Client library used
</p>
</li>
<li> <p>\$conTotal The number of connections instantiated by the driver
</p>
</li>
<li> <p>\$conOpen The number of connections open currently
</p>
</li>
<li> <p>\$interruptible TRUE when a long-running query can be interrupted
</p>
</li>
<li> <p>\$unicode_as_utf8 TRUE when character data is to be fetched in UTF8
encoded format
</p>
</li>
<li> <p>\$ora_attributes TRUE when each column in a result set data frame
has corresponding Oracle DBMS attributes
</p>
</li>
<li> <p>\$connections Information about each connection currently open, see
<code>dbGetInfo</code> of connection object for details
</p>
</li></ul>

<p>The <span class="pkg">ROracle</span> method <code>dbGetInfo</code> provides following the details
about the connection object:
</p>

<ul>
<li> <p>\$username The name of the user on this connection
</p>
</li>
<li> <p>\$dbname The connect alias or the connect string used
</p>
</li>
<li> <p>\$serverVersion The version of the Oracle Database server
</p>
</li>
<li> <p>\$serverType The value &quot;Oracle RDBMS&quot;
</p>
</li>
<li> <p>\$resTotal The number of result sets on this connection
</p>
</li>
<li> <p>\$resOpen The number of result sets open on this connection
</p>
</li>
<li> <p>\$prefetch TRUE when prefetch mechanism is used to fetch data
</p>
</li>
<li> <p>\$bulk_read The number of rows to fetch at a time from DBMS
</p>
</li>
<li> <p>\$bulk_write The number of rows to write at a time to DBMS
</p>
</li>
<li> <p>\$stmt_cache TRUE when the statement cache is used
</p>
</li>
<li> <p>\$results Information about each result set currently open, see
<code>dbGetInfo</code> of result set for details
</p>
</li></ul>

<p>The <span class="pkg">ROracle</span> method <code>dbGetInfo</code> provides the following details
about the result set object:
</p>

<ul>
<li> <p>\$statement SQL statement used to produce the result set object
</p>
</li>
<li> <p>\$isSelect TRUE when a select statement is specified
</p>
</li>
<li> <p>\$rowsAffected The number of rows affected by DML statment
</p>
</li>
<li> <p>\$rowCount The number of rows in result set currently
</p>
</li>
<li> <p>\$completed TRUE if there are no more rows in the result set
</p>
</li>
<li> <p>\$prefetch TRUE when the prefetch mechanism used to fetch data
</p>
</li>
<li> <p>\$bulk_read The number of rows to fetch at a time from DBMS
</p>
</li>
<li> <p>\$bulk_write The number of rows to write at a time to DBMS
</p>
</li>
<li> <p>\$fields Information about each column in the the result set, see
<code>dbColumnInfo</code> for details
</p>
</li></ul>

<p>The <span class="pkg">ROracle</span> method  <code>dbColumnInfo</code> provides following details
about each column in the result set:
</p>

<ul>
<li> <p>\$name The name of the column
</p>
</li>
<li> <p>\$Sclass The R type of the object containing the data returned by
the Oracle RDBMS
</p>
</li>
<li> <p>\$type The type of column as created in Oracle RDBMS
</p>
</li>
<li> <p>\$len Length of VARCHAR, CHAR and RAW column type in Oracle RDBMS.
All other columns will have NA.
</p>
</li>
<li> <p>\$precision The precision of number column
</p>
</li>
<li> <p>\$scale The scale of number column
</p>
</li>
<li> <p>\$nullOK TRUE when a NULL value can be present in the column
</p>
</li></ul>

<p>The example below shows the driver, connection, result set, and column
information for a table containing:
</p>
<pre>
   create table foo(
     a number(21),
     b number,
     c char(20),
     d varchar(300),
     e binary_double,
     f binary_float,
     g clob,
     h blob,
     i bfile,
     j date,
     m timestamp,
     n timestamp with time zone,
     o timestamp with local time zone,
     r interval day to second,
     s raw(234)
   );
 </pre>
<pre>   library(ROracle)
Loading required package: DBI
&gt; # instantiate ROracle driver object
&gt; drv &lt;- Oracle()
&gt; con &lt;- dbConnect(drv, "scott", "tiger")
&gt; rs &lt;- dbSendQuery(con, "select * from foo")
&gt; dbGetInfo(drv)
$driverName
[1] "Oracle (OCI)"

$driverVersion
[1] "1.1-12"

$clientVersion
[1] "11.2.0.4.0"

$conTotal
[1] 1

$conOpen
[1] 1

$interruptible
[1] FALSE

$unicode_as_utf8
[1] TRUE

$ora_attributes
[1] TRUE

$connections
$connections[[1]]
User name:             scott 
Connect string:         
Server version:        11.2.0.4.0 
Server type:           Oracle RDBMS 
Results processed:     1 
OCI prefetch:          FALSE 
Bulk read:             1000 
Bulk write:            1000 
Statement cache size:  0 
Open results:          1 


&gt; dbGetInfo(con)
$username
[1] "scott"

$dbname
[1] ""

$serverVersion
[1] "11.2.0.4.0"

$serverType
[1] "Oracle RDBMS"

$resTotal
[1] 1

$resOpen
[1] 1

$prefetch
[1] FALSE

$bulk_read
[1] 1000

$bulk_write
[1] 1000

$stmt_cache
[1] 0

$results
$results[[1]]
Statement:            select * from foo 
Rows affected:        0 
Row count:            0 
Select statement:     TRUE 
Statement completed:  FALSE 
OCI prefetch:         FALSE 
Bulk read:            1000 
Bulk write:           1000 


&gt; dbGetInfo(rs)
$statement
[1] "select * from foo"

$isSelect
[1] TRUE

$rowsAffected
[1] 0

$rowCount
[1] 0

$completed
[1] FALSE

$prefetch
[1] FALSE

$bulk_read
[1] 1000

$bulk_write
[1] 1000

$fields
   name    Sclass                           type len precision scale nullOK
1     A   numeric                         NUMBER  NA        21     0   TRUE
2     B   numeric                         NUMBER  NA         0  -127   TRUE
3     C character                           CHAR  20         0     0   TRUE
4     D character                       VARCHAR2 300         0     0   TRUE
5     E   numeric                  BINARY_DOUBLE  NA         0     0   TRUE
6     F   numeric                   BINARY_FLOAT  NA         0     0   TRUE
7     G character                           CLOB  NA         0     0   TRUE
8     H       raw                           BLOB  NA         0     0   TRUE
9     I       raw                          BFILE  NA         0     0   TRUE
10    J   POSIXct                           DATE  NA         0     0   TRUE
11    M   POSIXct                      TIMESTAMP  NA         0     6   TRUE
12    N   POSIXct       TIMESTAMP WITH TIME ZONE  NA         0     6   TRUE
13    O   POSIXct TIMESTAMP WITH LOCAL TIME ZONE  NA         0     6   TRUE
14    R  difftime         INTERVAL DAY TO SECOND  NA         2     6   TRUE
15    S       raw                            RAW 234         0     0   TRUE

   </pre>


<h3>Value</h3>

<p>Information about driver, connection or a result set object.
</p>


<h3>References</h3>

<p>For the Oracle Database documentaion see
<a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">http://www.oracle.com/technetwork/indexes/documentation/index.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Oracle">Oracle</a></code>,
<code><a href="DBI.html#topic+dbDriver">dbDriver</a></code>,
<code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>,
<code><a href="DBI.html#topic+dbSendQuery">dbSendQuery</a></code>,
<code><a href="DBI.html#topic+dbGetQuery">dbGetQuery</a></code>,
<code><a href="DBI.html#topic+fetch">fetch</a></code>,
<code><a href="DBI.html#topic+dbCommit">dbCommit</a></code>,
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>,
<code><a href="DBI.html#topic+dbListTables">dbListTables</a></code>,
<code><a href="DBI.html#topic+dbReadTable">dbReadTable</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    drv &lt;- dbDriver("Oracle")
    con &lt;- dbConnect(drv, "scott", "tiger")

    rs &lt;- dbSendQuery(con, "select * from emp")

    # Get the SQL statement for the result set object rs
    dbGetStatement(rs)

    # Are there any more rows in result set?
    dbHasCompleted(rs)

    # Information about columns in result set rs object
    dbColumnInfo(rs)

    # DBIDriver info
    names(dbGetInfo(drv))

    # DBIConnection info
    names(dbGetInfo(con))

    # DBIResult info
    names(dbGetInfo(rs)) 
  
## End(Not run)
</code></pre>

<hr>
<h2 id='dbListConnections-methods'>
List items from Oracle objects 
</h2><span id='topic+dbListConnections'></span><span id='topic+dbListResults'></span><span id='topic+dbListConnections+2COraDriver-method'></span><span id='topic+dbListConnections+2CExtDriver-method'></span><span id='topic+dbListResults+2COraConnection-method'></span>

<h3>Description</h3>

<p>These methods are straight-forward implementations of the corresponding
generic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OraDriver'
dbListConnections(drv, ...)
## S4 method for signature 'ExtDriver'
dbListConnections(drv, ...)
## S4 method for signature 'OraConnection'
dbListResults(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbListConnections-methods_+3A_drv">drv</code></td>
<td>
<p>an <code>OraDriver</code> or <code>ExtDriver</code>.</p>
</td></tr>
<tr><td><code id="dbListConnections-methods_+3A_conn">conn</code></td>
<td>
<p>an <code>OraConnection</code>.</p>
</td></tr>
<tr><td><code id="dbListConnections-methods_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>dbListConnections</dt><dd>
<p>implementation return a list of all associated connections.
It shows information about all associated connections.
</p>
</dd>
<dt>dbListResults</dt><dd>
<p>implementation return a list of all associated result sets.
It shows information about all associated result sets.
</p>
</dd>
</dl>



<h3>Value</h3>

<table>
<tr><td><code>dbListConnections</code></td>
<td>

<p>A list of all connections associated with driver.
</p>
</td></tr>
<tr><td><code>dbListResults</code></td>
<td>

<p>A list of all result sets associated with connection.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>For the Oracle Database documentaion see
<a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">http://www.oracle.com/technetwork/indexes/documentation/index.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Oracle">Oracle</a></code>,
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>,
<code><a href="DBI.html#topic+dbColumnInfo">dbColumnInfo</a></code>,
<code><a href="DBI.html#topic+dbDriver">dbDriver</a></code>,
<code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>,
<code><a href="DBI.html#topic+dbSendQuery">dbSendQuery</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    drv &lt;- dbDriver("Oracle")
    con1 &lt;- dbConnect(drv, "scott", "tiger")
    res1 &lt;- dbSendQuery(con1, "select * from emp where deptno = 10")
    res2 &lt;- dbSendQuery(con1, "select * from emp where deptno = 20")
    con2 &lt;- dbConnect(drv, "scott", "tiger")
    res3 &lt;- dbSendQuery(con2, "select * from dept")

    ## get all active statements
    for(con in dbListConnections(drv))
      for (res in dbListResults(con))
        print(dbGetStatement(res))
  
## End(Not run)
</code></pre>

<hr>
<h2 id='dbReadTable-methods'>
Convenience Functions for Manipulating DBMS Tables
</h2><span id='topic+dbReadTable'></span><span id='topic+dbWriteTable'></span><span id='topic+dbExistsTable'></span><span id='topic+dbRemoveTable'></span><span id='topic+dbListTables'></span><span id='topic+dbListFields'></span><span id='topic+dbReadTable+2COraConnection+2Ccharacter-method'></span><span id='topic+dbWriteTable+2COraConnection+2Ccharacter+2Cdata.frame-method'></span><span id='topic+dbExistsTable+2COraConnection+2Ccharacter-method'></span><span id='topic+dbRemoveTable+2COraConnection+2Ccharacter-method'></span><span id='topic+dbListTables+2COraConnection-method'></span><span id='topic+dbListFields+2COraConnection+2Ccharacter-method'></span>

<h3>Description</h3>

<p>These functions mimic their R counterparts except that they generate
code that gets remotely executed in a database engine:
<code>get</code>,
<code>assign</code>,
<code>exists</code>, 
<code>remove</code>,
<code>objects</code>, and
<code>names</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OraConnection,character'
dbReadTable(conn, name, schema = NULL, row.names = NULL, ...)
## S4 method for signature 'OraConnection,character,data.frame'
dbWriteTable(conn, name, value, row.names = FALSE, overwrite = FALSE,
             append = FALSE, ora.number = TRUE, schema = NULL, date = FALSE, ...)
## S4 method for signature 'OraConnection,character'
dbExistsTable(conn, name, schema = NULL, ...)
## S4 method for signature 'OraConnection,character'
dbRemoveTable(conn, name, purge = FALSE, schema = NULL, ...)
## S4 method for signature 'OraConnection'
dbListTables(conn, schema = NULL, all = FALSE, full = FALSE, ...)
## S4 method for signature 'OraConnection,character'
dbListFields(conn, name, schema = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbReadTable-methods_+3A_conn">conn</code></td>
<td>

<p>An <code>OraConnection</code> database connection object.
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_name">name</code></td>
<td>

<p>A case-sensitive character string specifying a table name.
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_schema">schema</code></td>
<td>

<p>A case-sensitive character string specifying a schema name (or a
vector of character strings for <code>dbListTables</code>).
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_date">date</code></td>
<td>

<p>A boolean flag to indicate whether to use date or DateTimep.
By default, DateTime will be used instead of timestamp.
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_row.names">row.names</code></td>
<td>

<p>In the case of <code>dbReadTable</code>, this argument can be a string, an
index or a logical vector specifying the column in the DBMS table to
be used as <code>row.names</code> in the output data.frame (a <code>NULL</code>
specifies that no column should be used as <code>row.names</code> in the
output). The default is <code>NULL</code>.
</p>
<p>In the case of <code>dbWriteTable</code>, this argument should be a logical
value specifying whether the <code>row.names</code> should be output to the
output DBMS table; if <code>TRUE</code>, an extra column whose name is 
<code>"row.names"</code> will be added to the output. The default is
<code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_value">value</code></td>
<td>

<p>A <code>data.frame</code> containing the data to write to a table. (See
Details section for supported column types.)
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_overwrite">overwrite</code></td>
<td>

<p>A logical value specifying whether to overwrite an existing table
or not. The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_append">append</code></td>
<td>

<p>A logical value specifying whether to append to an existing table
in the DBMS. The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_ora.number">ora.number</code></td>
<td>

<p>A logical value specifying whether to create a table with Oracle
<code>NUMBER</code> or <code>BINARY_DOUBLE</code> columns while writing numeric
data. Specify <code>TRUE</code> to create a table with Oracle <code>NUMBER</code> 
values or specify <code>FALSE</code> to create a table with Oracle
<code>BINARY_DOUBLE</code> values. The default value is <code>TRUE</code>.
Specify <code>FALSE</code> if one or more of the numeric data values are
<code>NaN</code>.
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_purge">purge</code></td>
<td>

<p>A logical value specifying whether to add the <code>PURGE</code> option to the
SQL <code>DROP TABLE</code> statement.
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_all">all</code></td>
<td>

<p>A logical value specifying whether to look at all schemas.
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_full">full</code></td>
<td>

<p>A logical value specifying whether to generate schema names. When argument
<code>all</code> is <code>TRUE</code>, the output is a vector containing schema
names followed by the table names. Using <code>matrix(..., ncol = 2)</code>
on the output produces a matrix where each row corresponds to a
table and the columns represent the schema names and table names
respectively.
</p>
</td></tr>
<tr><td><code id="dbReadTable-methods_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Table, schema, and column names are case sensitive, e.g., table
names <code>ABC</code> and <code>abc</code> are not the same. All database schema
object names should not include double quotes as they are enclosed in
double quotes when the corresponding SQL statement is generated.
</p>
<p>The following attributes are used for mapping BLOB, CLOB, NCLOB, NCHAR, VARCHAR2,
NVARCHAR2, CHAR, TIMESTAMP WITH TIME ZONE and TIMESTAMP WITH LOCAL TIME ZONE
columns correctly in <code>dbWriteTable</code>:
1) Attribute Name: <code>ora.type</code>
This attribute indicates the type of the underlying column and can be
&quot;CLOB&quot;, &quot;BLOB&quot;, &quot;CHAR&quot;, &quot;VARCHAR2&quot;, or &quot;RAW&quot;. The user can specify
TIMESTAMP, DATE, TIMESTAMP WITH TIME ZONE or any other column types
supported by Oracle Database. ROacle does not parse the value; it is
validated by the database. The user can provide one of the following
values for <code>ora.type</code>: CLOB, BLOB, CHAR, TIMESTAMP WITH TIME
ZONE, TIMESTAMP WITH LOCAL TIME ZONE and fractional_seconds_precision.
2) Attribute Name: <code>ora.encoding</code>
When UTF-8 is specified, the database uses NCLOB, NCHAR or NVARCHAR based on
<code>ora.type</code>.
3) Attribute Name: <code>ora.maxlength</code>
One can specify the maximum length of CHAR, VARCHAR, NCHAR, NVARCHAR2, or
RAW columns. For other data types, <code>ora.maxlength</code> does not
apply and is ignored. The following default values are used for
certain data types when <code>ora.maxlength</code> is not specified.
CHAR                                       2000
NCHAR                                      1000
VARCHAR2                                   4000
NVARCHAR2                                  2000
RAW                                        2000
4) Attribute Name: <code>ora.fractional_seconds_precision</code>
One can specify the fractional part of the SECOND datetime field of
TIMESTAMP, TIMESTAMP WITH TIME ZONE and TIMESTAMP WITH LOCAL TIME ZONE
columns. It can be a number in the range 0 to 9. The default value is 6.
</p>
<p><span class="pkg">ROracle</span> methods such as <code>dbReadTable</code>, <code>dbGetQuery</code>,
<code>fetch</code>, and <code>dbWriteTable</code> use the following mapping
between <span class="rlang"><b>R</b></span> and Oracle data types:
</p>

<ul>
<li> <p><code>logical</code> and <code>integer</code> map to Oracle <code>INTEGER</code>
</p>
</li>
<li> <p><code>numeric</code> maps to Oracle <code>NUMBER</code> if argument
<code>ora.number</code> is <code>TRUE</code> or Oracle  <code>BINARY_DOUBLE</code> if
<code>FALSE</code>
</p>
</li>
<li> <p><code>character</code> maps to Oracle <code>CLOB</code> if attribute 
<code>ora.type</code> is <code>"CLOB"</code> or Oracle <code>NCLOB</code> if attribute
<code>ora.type</code> is <code>"CLOB"</code> and <code>ora.encoding</code> is <code>"UTF-8"</code>
or Oracle <code>CHAR(ora.maxlength)</code> if attribute <code>ora.type</code> is 
<code>"CHAR"</code> or Oracle <code>NCHAR(ora.maxlength)</code> if attribute 
<code>ora.type</code> is <code>"CHAR"</code> and <code>ora.encoding</code> is <code>"UTF-8"</code>
or Oracle <code>NVARCHAR2(ora.maxlength)</code> if attribute <code>ora.encoding</code>
is <code>"UTF-8"</code> or Oracle <code>VARCHAR2(ora.maxlength)</code>
</p>
</li>
<li> <p><code>Date</code> and <code>POSIXct</code> map to Oracle <code>DATE</code>
<span class="pkg">ROracle</span> - the ROracle package
<span class="rlang"><b>R</b></span> - the R application
</p>
</li>
<li> <p><code>POSIXct</code> maps to Oracle 
<code>TIMESTAMP WITH TIME ZONE(ora.fractional_seconds_precision)</code> if 
attribute <code>ora.type</code> is <code>"TIMESTAMP WITH TIME ZONE"</code> or Oracle 
<code>TIMESTAMP WITH LOCAL TIME ZONE(ora.fractional_seconds_precision)</code> if
attribute <code>ora.type</code> is <code>"TIMESTAMP WITH LOCAL TIME ZONE"</code> or
Oracle <code>TIMESTAMP(ora.fractional_seconds_precision)</code> and if 
<code>Date</code> is <code>FALSE</code> 
</p>
</li>
<li> <p><code>difftime</code> maps to Oracle <code>INTERVAL DAY TO SECOND</code>
</p>
</li>
<li> <p><code>list</code> of <code>raw</code> vectors map to Oracle <code>BLOB</code> if 
attribute <code>ora.type</code> is <code>"BLOB"</code> or Oracle 
<code>RAW(ora.maxlength)</code>
</p>
</li>
<li><p> other <span class="rlang"><b>R</b></span> types such as <code>factor</code> are converted to
<code>character</code>
</p>
</li></ul>

<p>ROracle returns values from database columns that are of data type: date,
time stamp, time stamp with time zone and time stamp with local time zone
data types in R's POSIXct format. POSIXct refers to a
time that is internally stored as the number of seconds since the start of
1970 in UTC. Number of seconds are exchanged from R and ROracle driver in
floating point double format. In POSIXct representation R uses the TZ
environment variable or maps the OS time zone environment variable to its
own, therefore the date will be displayed in this time zone format.
</p>
<p>One can insert data into columns of the four data types listed above using a
string with the correct format or POSIXct representation. String data is
passed to the database directly and ROracle relies on databse to convert it
to date time representation. ROracle driver converts the POSIXct
representation to a string representation using the format
&quot;%Y-%m-%d %H:%M:%OS6&quot; in a data frame that is used for DML operations.
Data in this format corresponds to NLS_TIMESTAMP_TZ_FORMAT
&quot;YYYY-MM-DD HH24:MI:SSXFF&quot; and is converted to SQLT_TIMESTAMP_LTZ to be
bound to the Oracle database. An intermediate class &quot;datetime&quot; is created
that represents character data to the ROracle driver internally.
</p>
<p>Columns having a date and time stamp data type are fetched by ROracle using
the SQLT_TIMESTAMP data type. Columns having a time stamp with time zone or
a time stamp with local time zone data types are fetched using
SQLT_TIMESTAMP_LTZ data type. Columns of data type time stamp with local time
zone undergo conversion to the session time zone that the R application runs
in, therefore setting the time zone environment TZ in R will affect the data
values in this column. ROracle driver maps the TZ environment variable to
the session time zone and issues an alter DDL to set the session time zone
when the connection is made to the database.
</p>
<p>To fetch data from columns with a timestamp with time zone or a timestamp
with local time zone, the client and server must have the same time zone
data file else an error will be reported.
</p>
<p>When these data types are selected from the database, they are converted to
string representation using the NLS_TIMESTAMP_TZ_FORMAT
&quot;YYYY-MM-DD HH24:MI:SSXFF&quot; that corresponds to &quot;%Y-%m-%d %H:%M:%OS6&quot;
in R. An intermediate class &quot;datetime&quot; is created
to represent this character data in ROracle driver. ROracle driver then
converts it to POSIXct using the as.POSIXct() function. An R application
sees the data in POSIXct form in the data frame.
</p>
<pre>
R session time zone:
 R has the concept of a time zone in which the R engine operates. The time
 zone can be set to a string such as 'PST8PDT', 'America/Los_Angeles' and so on.
 These strings are self-explanatory and specify the time zone in which the
 session is operating.
 The R session time zone can be set in one of two ways:
 1. By entering the following on the Linux or Unix command line before starting
    R:
    setenv TZ = America/Los_Angeles on Linux/UNIX
    NOTE: Do not use this option on Windows as it does not allow one to
          set Oracle compatible timezone names for the environment variable TZ.
 2. By entering the following at the R prompt:
    Sys.setenv(TZ = "PST8PDT")

 We recommend using the option 2 as the R script works without any
 porting issues on Linux/Unix as well as Windows. Option 2 also allows you
 to specify Oracle compatible timezone names even on Windows.

 The R session time zone determines the time zone for all POSIXct time
 zone unqualified date-time types. It is also the time zone to which all
 qualified date-time types are converted when they are displayed by R.

 The following example demonstrates this.
 Sys.setenv(TZ = "PST8PDT")
 dt &lt;- c(as.POSIXct("2010/3/13", tz = "PST8PDT"),
         as.POSIXct("2010/3/13 3:47:30.123456", tz = "PST8PDT"),
         as.POSIXct("2010/3/22", tz = "PST8PDT"),
         as.POSIXct("2010/3/22 7:02:30", tz = "PST8PDT"),
         as.POSIXct("2010/3/13"),
         as.POSIXct("2010/3/13 3:47:30.123456"),
         as.POSIXct("2010/3/22"),
         as.POSIXct("2010/3/22 7:02:30"))
 dt
 [1] "2010-03-13 00:00:00.000000 PST" "2010-03-13 03:47:30.123456 PST"
 [3] "2010-03-22 00:00:00.000000 PDT" "2010-03-22 07:02:30.000000 PDT"
 [5] "2010-03-13 00:00:00.000000 PST" "2010-03-13 03:47:30.123456 PST"
 [7] "2010-03-22 00:00:00.000000 PDT" "2010-03-22 07:02:30.000000 PDT"

Note that the unqualified timestamps are also assumed to be in the R's
session time zone when they are displayed by R. Of course, R is also smart
enough to make the determination of whether the time falls into PST or PDT
based on when US Daylight savings begins, and displays PST or PDT
accordingly.

The following example makes this more obvious.
&gt; Sys.setenv(TZ = "EST5EDT")
&gt; dt &lt;- c(as.POSIXct("2010/3/13", tz = "PST8PDT"),
+         as.POSIXct("2010/3/13 3:47:30.123456", tz = "PST8PDT"),
+         as.POSIXct("2010/3/22", tz = "PST8PDT"),
+         as.POSIXct("2010/3/22 7:02:30", tz = "PST8PDT"),
+         as.POSIXct("2010/3/13"),
+         as.POSIXct("2010/3/13 3:47:30.123456"),
+         as.POSIXct("2010/3/22"),
+         as.POSIXct("2010/3/22 7:02:30"))

&gt; dt
[1] "2010-03-13 03:00:00.000000 EST" "2010-03-13 06:47:30.123456 EST"
[3] "2010-03-22 03:00:00.000000 EDT" "2010-03-22 10:02:30.000000 EDT"
[5] "2010-03-13 00:00:00.000000 EST" "2010-03-13 03:47:30.123456 EST"
[7] "2010-03-22 00:00:00.000000 EDT" "2010-03-22 07:02:30.000000 EDT"

Note that all the time zone unqualified timestamps are assumed to be in
the session time zone. However, even the time zone qualified timestamps
are converted to session time zone and displayed. Note that all the
values are displayed by R in the R session's time zone (with the
timezone name also modified to EST or EDT to account for
daylight savings as applicable). Refer to Date-Time Classes at
http://stat.ethz.ch/R-manual/R-devel/library/base/html/DateTimeClasses.html
and timezones at:
http://stat.ethz.ch/R-manual/R-devel/library/base/html/timezones.html
for details on how R handles dates and times and time zones)
Let's take an example where we use a longer time zone name
(often referred to as an 'Olson Name') as opposed to an abbreviation.
&gt; Sys.setenv(TZ = "America/Los_Angeles")
&gt; dt &lt;- c(as.POSIXct("2010/3/13", tz = "PST8PDT"),
+         as.POSIXct("2010/3/13 3:47:30.123456", tz = "PST8PDT"),
+         as.POSIXct("2010/3/22", tz = "PST8PDT"),
+         as.POSIXct("2010/3/22 7:02:30", tz = "PST8PDT"),
+         as.POSIXct("2010/3/13"),
+         as.POSIXct("2010/3/13 3:47:30.123456"),
+         as.POSIXct("2010/3/22"),
+         as.POSIXct("2010/3/22 7:02:30"))
&gt; dt
[1] "2010-03-13 00:00:00.000000 PST" "2010-03-13 03:47:30.123456 PST"
[3] "2010-03-22 00:00:00.000000 PDT" "2010-03-22 07:02:30.000000 PDT"
[5] "2010-03-13 00:00:00.000000 PST" "2010-03-13 03:47:30.123456 PST"
[7] "2010-03-22 00:00:00.000000 PDT" "2010-03-22 07:02:30.000000 PDT"

Note that in such a case, R doesn't use the long name when the
values are displayed, but instead still displays the values using
the abbreviations "PST" and "PDT". This is significant because Oracle
doesn't necessarily like these abbreviations. For example, an Oracle
databse doesn't recognize "PDT" as a valid time zone. See "R Time zone
and Oracle session time zone" for details on valid time zones.
</pre>
<p>The example below shows the effect of changing the time zone in R
environment:
</p>
<pre>   R&gt; Sys.timezone()
   [1] "PST8PDT"
   # Selecting data and displaying it
   res &lt;- dbGetQuery(con, selStr)
   R&gt;     res[,1]
   [1] 1 2 3 4 5 6
   R&gt;     res[,2]
   [1] "2012-06-05 00:00:00 PDT" "2012-01-05 07:15:02 PST"
       "2012-01-05 00:00:00 PST" "2011-01-05 00:00:00 PST"
   [5] "2013-01-05 00:00:00 PST" "2020-01-05 00:00:00 PST"
   R&gt;     res[,3]
   [1] "2012-06-05 00:00:00 PDT" "2012-01-05 07:15:03 PST"
       "2012-01-05 00:00:00 PST" "2011-01-05 00:00:00 PST"
   [5] "2013-01-05 00:00:00 PST" "2020-01-05 00:00:00 PST"
   R&gt;     res[,4]
   [1] "2012-06-05 00:00:00 PDT" "2012-01-05 07:15:03 PST"
       "2012-01-05 00:00:00 PST" "2011-01-05 00:00:00 PST"
   [5] "2013-01-05 00:00:00 PST" "2020-01-05 00:00:00 PST"
   R&gt;     res[,5]
   [1] "2012-06-05 00:00:00 PDT" "2012-01-05 07:15:03 PST"
       "2012-01-05 00:00:00 PST" "2011-01-05 00:00:00 PST"
   [5] "2013-01-05 00:00:00 PST" "2020-01-05 00:00:00 PST"
   R&gt; Sys.setenv(TZ='EST5EDT')
   R&gt;     res[,1]
   [1] 1 2 3 4 5 6
   R&gt;     res[,2]
   [1] "2012-06-05 03:00:00 EDT" "2012-01-05 10:15:02 EST"
       "2012-01-05 03:00:00 EST" "2011-01-05 03:00:00 EST"
   [5] "2013-01-05 03:00:00 EST" "2020-01-05 03:00:00 EST"
   R&gt;     res[,3]
   [1] "2012-06-05 03:00:00 EDT" "2012-01-05 10:15:03 EST"
       "2012-01-05 03:00:00 EST" "2011-01-05 03:00:00 EST"
   [5] "2013-01-05 03:00:00 EST" "2020-01-05 03:00:00 EST"
   R&gt;     res[,4]
   [1] "2012-06-05 03:00:00 EDT" "2012-01-05 10:15:03 EST"
       "2012-01-05 03:00:00 EST" "2011-01-05 03:00:00 EST"
   [5] "2013-01-05 03:00:00 EST" "2020-01-05 03:00:00 EST"
   R&gt;     res[,5]
   [1] "2012-06-05 03:00:00 EDT" "2012-01-05 10:15:03 EST"
       "2012-01-05 03:00:00 EST" "2011-01-05 03:00:00 EST"
   [5] "2013-01-05 03:00:00 EST" "2020-01-05 03:00:00 EST"</pre>
<p>Also <code>dbWriteTable</code> always auto commits a current transaction as
well as the data it inserts, i.e. it acts as a DDL statement even if
appends rows to an already existing table.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> in the case of <code>dbReadTable</code>;
a <code>vector</code> in the case of <code>dbListTables</code> and
<code>dbListFields</code>;
a <code>logical</code> in the case of <code>dbExistsTable</code> indicating
whether the table exists;
otherwise <code>TRUE</code> when the operation was successful or an
exception.
</p>


<h3>References</h3>

<p>For the Oracle Database documentation see 
<a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">http://www.oracle.com/technetwork/indexes/documentation/index.html</a>.
For Datetime Data Types and Time Zone Support in Oracle see
<a href="http://docs.oracle.com/cd/E11882_01/server.112/e10729/ch4datetime.htm">http://docs.oracle.com/cd/E11882_01/server.112/e10729/ch4datetime.htm</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Oracle">Oracle</a></code>,
<code><a href="DBI.html#topic+dbDriver">dbDriver</a></code>,
<code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>,
<code><a href="DBI.html#topic+dbSendQuery">dbSendQuery</a></code>,
<code><a href="DBI.html#topic+dbGetQuery">dbGetQuery</a></code>,
<code><a href="DBI.html#topic+fetch">fetch</a></code>,
<code><a href="DBI.html#topic+dbCommit">dbCommit</a></code>,
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    con &lt;- dbConnect(Oracle(), "scott", "tiger")
    if (dbExistsTable(con, "FOO", "SCOTT"))
      dbRemoveTable(con, "FOO")

    foo &lt;- dbReadTable(con, "EMP")
    row.names(foo) &lt;- foo$EMPNO
    foo &lt;- foo[,-1]

    dbWriteTable(con, "FOO", foo, row.names = TRUE)
    dbWriteTable(con, "FOO", foo, row.names = TRUE, overwrite = TRUE)
    dbReadTable(con, "FOO", row.names = 1)

    dbGetQuery(con, "delete from foo")
    dbWriteTable(con, "FOO", foo, row.names = TRUE, append = TRUE)
    dbReadTable(con, "FOO", row.names = 1)
    dbRemoveTable(con, "FOO")

    dbListTables(con)
    dbListFields(con, "EMP")

    if (dbExistsTable(con, "RORACLE_TEST", "SCOTT"))
      dbRemoveTable(con, "RORACLE_TEST")

    # Example of POSIXct usage.
    # A table is created using:
    createTab &lt;- "create table RORACLE_TEST(row_num number, id1 date,
                 id2 timestamp, id3 timestamp with time zone, 
                 id4 timestamp with local time zone )"

    dbGetQuery(con, createTab)
    # Insert statement.
    insStr &lt;- "insert into RORACLE_TEST values(:1, :2, :3, :4, :5)";

    # Select statement.
    selStr &lt;- "select * from RORACLE_TEST";

    # Insert time stamp without time values in POSIXct form.
    x &lt;- 1; 
    y &lt;- "2012-06-05";
    y &lt;- as.POSIXct(y);
    dbGetQuery(con, insStr, data.frame(x, y, y, y, y));

    # Insert date &amp; times stamp with time values in POSIXct form.
    x &lt;- 2;
    y &lt;- "2012-01-05 07:15:02";
    y &lt;- as.POSIXct(y);
    z &lt;- "2012-01-05 07:15:03.123";
    z &lt;- as.POSIXct(z);
    dbGetQuery(con, insStr, data.frame(x, y, z,  z, z));

    # Insert list of date objects in POSIXct form.
    x &lt;- c(3, 4, 5, 6);
    y &lt;- c('2012-01-05', '2011-01-05', '2013-01-05', '2020-01-05');
    y &lt;- as.POSIXct(y);
    dbGetQuery(con, insStr, data.frame(x, y, y, y, y));

    dbCommit (con)

    # Selecting data and displaying it.
    res &lt;- dbGetQuery(con, selStr)
    res[,1]
    res[,2]
    res[,3]
    res[,4]
    res[,5]

    # insert data in Date format
    a&lt;-as.Date("2014-01-01")
    dbWriteTable(con, 'TEMP', data.frame(a), date = TRUE)

    # using attribute to map NCHAR, CLOB, BLOB, NCLOB columns correctly in 
    # dbWriteTable
    str1 &lt;- paste(letters, collapse="")
    lstr1 &lt;- paste(rep(str1, 200), collapse="")
    raw.lst &lt;- vector("list",1)
    lraw.lst &lt;- vector("list",1)
    raw.lst[[1L]] &lt;- charToRaw(str1)
    lraw.lst[[1L]] &lt;- rep(charToRaw(str1), 200)
    a &lt;- as.POSIXct("2014-01-01 14:12:09.0194733")
    b &lt;- as.POSIXct("2014-01-01 14:12:09.01947")
    test.df &lt;- data.frame(char=str1, nchar=str1, varchar=str1, clob=lstr1,
                      nclob=lstr1, stringsAsFactors=FALSE)
    test.df$raw.typ &lt;- raw.lst
    test.df$blob &lt;- lraw.lst
    test.df$char_max &lt;- str1 
    test.df$raw_max.typ &lt;- raw.lst
    test.df$nvchar &lt;- str1
    test.df$nvchar_max &lt;- str1
    test.df$date_tz &lt;- a
    test.df$date_ltz &lt;- b

    # adding attributes
    attr(test.df$clob, "ora.type") &lt;- "CLOB"
    attr(test.df$blob, "ora.type") &lt;- "BLOB"
    attr(test.df$nclob, "ora.type") &lt;- "CLOB"
    attr(test.df$nclob, "ora.encoding") &lt;- "UTF-8"
    attr(test.df$char_max, "ora.maxlength") &lt;- 3000
    attr(test.df$raw_max.typ, "ora.maxlength") &lt;- 1000
    attr(test.df$nvchar, "ora.encoding") &lt;- "UTF-8"
    attr(test.df$nvchar_max, "ora.encoding") &lt;- "UTF-8"
    attr(test.df$nvchar_max, "ora.maxlength") &lt;- 1500
    attr(test.df$char, "ora.type") &lt;- "CHAR"
    attr(test.df$date_tz, "ora.type") &lt;- "timestamp with time zone"
    attr(test.df$date_ltz, "ora.type") &lt;- "timestamp with local time zone"
    attr(test.df$nchar, "ora.type") &lt;- "CHAR"
    attr(test.df$nchar, "ora.encoding") &lt;- "UTF-8"
    attr(test.df$date_tz, "ora.fractional_seconds_precision") &lt;- 9
R&gt; # displaying the data frame
R&gt; test.df
char                         nchar
1 abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz
varchar
1 abcdefghijklmnopqrstuvwxyz
clob
1 abcdefghijklmnopqrstuvwxyz...
nclob
1 abcdefghijklmnopqrstuvwxyz...
raw.typ
1 61, 62, 63, 64, 65, 66, 67, 68, 69, 6a, 6b, 6c, 6d, 6e, 6f, 70, 71, 72, 73,
  74, 75, 76, 77, 78, 79, 7a
blob
1 61, 62, 63, 64, 65, 66, 67, 68, 69, 6a, 6b, 6c, 6d, 6e, 6f, 70, 71, 72, 73,
  74, 75, 76, 77, 78, 79, 7a,...
char_max
1 abcdefghijklmnopqrstuvwxyz
raw_max.typ
1 61, 62, 63, 64, 65, 66, 67, 68, 69, 6a, 6b, 6c, 6d, 6e, 6f, 70, 71, 72, 73,
  74, 75, 76, 77, 78, 79, 7a
nvchar                       nvchar_max
1 abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz
date_tz                      date_ltz
1 2014-01-01 14:12:09.019473 2014-01-01 14:12:09.01946

    dbWriteTable(con, name="TEST_TAB", value=test.df)
    res &lt;- dbReadTable(con, name="TEST_TAB")
R&gt; res
char
1 abcdefghijklmnopqrstuvwxyz
nchar
1 abcdefghijklmnopqrstuvwxyz
varchar
1 abcdefghijklmnopqrstuvwxyz
clob
1 abcdefghijklmnopqrstuvwxyz...
nclob
1 abcdefghijklmnopqrstuvwxyz...
raw.typ
1 61, 62, 63, 64, 65, 66, 67, 68, 69, 6a, 6b, 6c, 6d, 6e, 6f, 70, 71, 72, 73,
  74, 75, 76, 77, 78, 79, 7a
blob
1 61, 62, 63, 64, 65, 66, 67, 68, 69, 6a, 6b, 6c, 6d, 6e, 6f, 70, 71, 72, 73,
  74, 75, 76, 77, 78, 79, 7a,...
char_max                                                                                           
1 abcdefghijklmnopqrstuvwxyz
raw_max.typ
1 61, 62, 63, 64, 65, 66, 67, 68, 69, 6a, 6b, 6c, 6d, 6e, 6f, 70, 71, 72, 73,
  74, 75, 76, 77, 78, 79, 7a
nvchar                       nvchar_max
1 abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz
date_tz                      date_ltz
1 2014-01-01 14:12:09.019473 2014-01-01 14:12:09.01946
  
## End(Not run)
  ## Not run: 
    df &lt;- data.frame(A=c(0,1,NaN,4), B=c(NA, 2,3,NaN))
    con &lt;- dbConnect(Oracle(), "scott", "tiger")
    dbWriteTable(con,"TEST", df, row.names = FALSE, ora.number=FALSE)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='dbSendQuery-methods'>
Execute a Statement on a Given Database Connection
</h2><span id='topic+dbSendQuery'></span><span id='topic+dbGetQuery'></span><span id='topic+oracleProc'></span><span id='topic+dbClearResult'></span><span id='topic+dbGetException'></span><span id='topic+execute'></span><span id='topic+dbSendQuery+2COraConnection+2Ccharacter-method'></span><span id='topic+dbGetQuery+2COraConnection+2Ccharacter-method'></span><span id='topic+dbClearResult+2COraResult-method'></span><span id='topic+oracleProc+2COraConnection+2Ccharacter-method'></span><span id='topic+dbGetException+2COraConnection-method'></span><span id='topic+execute+2COraResult-method'></span>

<h3>Description</h3>

<p>These methods are straight-forward implementations of the corresponding
generic functions except for the <code>execute</code> method, which is an
ROracle specific DBI extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OraConnection,character'
dbSendQuery(conn, statement, data = NULL,
          prefetch = FALSE, bulk_read = 1000L, bulk_write = 1000L, ...)
## S4 method for signature 'OraConnection,character'
dbGetQuery(conn, statement, data = NULL,
          prefetch = FALSE, bulk_read = 1000L, bulk_write = 1000L, ...)
## S4 method for signature 'OraConnection,character'
oracleProc(conn, statement, data = NULL, 
          prefetch = FALSE, bulk_read = 1000L, bulk_write = 1000L, ...)
## S4 method for signature 'OraResult'
dbClearResult(res, ...)
## S4 method for signature 'OraConnection'
dbGetException(conn, ...)

execute(res, ...)
## S4 method for signature 'OraResult'
execute(res, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbSendQuery-methods_+3A_conn">conn</code></td>
<td>
<p>An <code>OraConnection</code> object.</p>
</td></tr>
<tr><td><code id="dbSendQuery-methods_+3A_statement">statement</code></td>
<td>
<p>A character vector of length 1 with the SQL statement.</p>
</td></tr>
<tr><td><code id="dbSendQuery-methods_+3A_res">res</code></td>
<td>
<p>An <code>OraResult</code> object.</p>
</td></tr>
<tr><td><code id="dbSendQuery-methods_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> specifying bind data</p>
</td></tr>
<tr><td><code id="dbSendQuery-methods_+3A_prefetch">prefetch</code></td>
<td>

<p>A logical value that specifies whether ROracle uses prefetch buffers or an
array fetch to retrieve data from the server. If <code>TRUE</code>, then ROracle 
uses OCI prefetch buffers to retrieve additional data from the server thus 
saving the memory required in RODBI/ROOCI by allocating a single row buffer 
to fetch the data from OCI. Using prefetch results in a fetch call for every
row. If <code>FALSE</code> (the default), then ROracle uses an array fetch to 
retrieve the data.
</p>
</td></tr>
<tr><td><code id="dbSendQuery-methods_+3A_bulk_read">bulk_read</code></td>
<td>

<p>An integer value indicating the number of rows to fetch at a time. The 
default value is 1000L. When the prefetch option is selected, memory is 
allocated for prefetch buffers and OCI fetches the specified number of rows 
at a time. When prefetch is not used, which is the default, memory is 
allocated in RODBI/ROOCI define buffers. Setting this to a large value 
results in more memory being allocated based on the number of columns in 
the select list and the types of columns. For a column of type character, 
define buffers are allocated using the maximum width times the NLS maximum 
width. An application should adjust this value based on the query result.
A larger value benefits queries that return a large result. The 
application can tune this value as needed.
</p>
</td></tr>
<tr><td><code id="dbSendQuery-methods_+3A_bulk_write">bulk_write</code></td>
<td>

<p>An integer value indicating the number of rows to write at a time. The
default value is 1000L. When a bulk_write value is specified, memory is 
allocated for buffers and OCI writes that many rows at a time. If the
bulk_write argument is not used, then the default value is used to 
allocate memory for the bind buffers. Setting <code>bulk_write</code> to a large
value results in more memory being allocated based on the number of columns
in the insert list and the types of columns.
</p>
</td></tr>
<tr><td><code id="dbSendQuery-methods_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>dbGetQuery</dt><dd>
<p>This function executes a query statement and fetches the result data
from the database. It should not be used for calling PL/SQL queries.
</p>
</dd>
<dt>dbSendQuery</dt><dd>
<p>This function executes a query statement and returns a result set to the 
application. The application can then perform operations on the result set.
It should not be used for calling PL/SQL queries.
</p>
</dd>
<dt>oracleProc</dt><dd>
<p>This function executes a PL/SQL stored procedure or function query
statement and returns the result.
</p>
</dd>
<dt>dbClearResult</dt><dd>
<p>This function frees resources used by result set.
</p>
</dd>
<dt>dbGetException</dt><dd>
<p>This function retrieves error information.
</p>
</dd>
<dt>execute</dt><dd>
<p>This function executes the specified query statement.
</p>
</dd>
</dl>



<h3>Value</h3>

<table>
<tr><td><code>dbSendQuery</code></td>
<td>

<p>An <code>OraResult</code> object whose class extends <code>DBIResult</code>. This 
object is used to fetch data from a database, using the function 
<code>fetch</code>.
</p>
</td></tr>
</table>


<h3>Side Effects</h3>


<dl>
<dt>dbGetQuery</dt><dd>
<p>Query statement is executed and data is fetched from database.
</p>
</dd>
<dt>dbSendQuery</dt><dd>
<p>Query statement is executed, but data needs to be fetched through
calls to <code><a href="DBI.html#topic+fetch">fetch</a></code>.
</p>
</dd>
<dt>oracleProc</dt><dd>
<p>PL/SQL stored procedure or function query statement is executed and 
result is returned.
</p>
</dd>
<dt>dbClearResult</dt><dd>
<p>Resources acquired by the result set are freed.
</p>
</dd>
<dt>dbGetException</dt><dd>
<p>Error information is retrieved and then cleaned from the driver.
</p>
</dd>
<dt>execute</dt><dd>
<p>Query statement is executed.
</p>
</dd>
</dl>



<h3>References</h3>

<p>For the Oracle Database documentation see 
<a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">http://www.oracle.com/technetwork/indexes/documentation/index.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Oracle">Oracle</a></code>,
<code><a href="DBI.html#topic+dbDriver">dbDriver</a></code>,
<code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>,
<code><a href="DBI.html#topic+fetch">fetch</a></code>,
<code><a href="DBI.html#topic+dbCommit">dbCommit</a></code>,
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>,
<code><a href="DBI.html#topic+dbReadTable">dbReadTable</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    drv &lt;- dbDriver("Oracle")
    con &lt;- dbConnect(drv, "scott", "tiger")
    res &lt;- dbSendQuery(con, "select * from emp where deptno = :1",
                       data = data.frame(deptno = 10))
    data &lt;- fetch(res, n = -1)
    res2 &lt;- dbSendQuery(con, "select * from emp where deptno = :1",
                        data1 &lt;- data.frame(deptno = 10), prefetch=TRUE,
                        bulk_read=2L)
    data1 &lt;- fetch(res2, n = -1)
    data1

    res3 &lt;- dbSendQuery(con, "select * from emp where deptno = :1",
                        data2 &lt;- data.frame(deptno = 10), bulk_read=10L)
    data2 &lt;- fetch(res3, n = -1)
    data2

    res4 &lt;- dbSendQuery(con, "select * from emp where deptno = :1",
                        data3 &lt;- data.frame(deptno = 10), bulk_write=10L)
    data3 &lt;- fetch(res4, n = -1)
    data3

    res5 &lt;- dbSendQuery(con, "select * from emp where ename = :1",
                        data4 &lt;- data.frame(ename = 'SMITH')) 
    data4 &lt;- fetch(res5, n = -1)
    data4
  
## End(Not run)
</code></pre>

<hr>
<h2 id='ExtDriver-class'>Class ExtDriver</h2><span id='topic+ExtDriver-class'></span>

<h3>Description</h3>

<p>An Oracle extproc driver class implementing the R database interface
(DBI) API.
</p>


<h3>Generators</h3>

<p>The main generators are <code><a href="DBI.html#topic+dbDriver">dbDriver</a></code> and 
<code><a href="#topic+Extproc">Extproc</a></code>.
</p>


<h3>Extends</h3>

<p>Class <code>"DBIDriver"</code>, directly.
Class <code>"DBIObject"</code>, by class <code>"DBIDriver"</code>, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>dbConnect</dt><dd><p><code>signature(drv = "ExtDriver")</code>: ... </p>
</dd>
<dt>dbGetInfo</dt><dd><p><code>signature(dbObj = "ExtDriver")</code>: ... </p>
</dd>
<dt>dbListConnections</dt><dd><p><code>signature(drv = "ExtDriver")</code>: ... </p>
</dd>
<dt>dbUnloadDriver</dt><dd><p><code>signature(drv = "ExtDriver")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "ExtDriver")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ExtDriver")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p>DBI classes:
<code><a href="#topic+OraConnection-class">OraConnection-class</a></code>
<code><a href="#topic+OraResult-class">OraResult-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- dbConnect(Extproc())

## End(Not run)
</code></pre>

<hr>
<h2 id='fetch-methods'>
Fetch records from a previously executed query
</h2><span id='topic+fetch'></span><span id='topic+fetch+2COraResult-method'></span>

<h3>Description</h3>

<p>This method is a straight-forward implementation of the corresponding
generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OraResult'
fetch(res, n = -1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetch-methods_+3A_res">res</code></td>
<td>

<p>an <code>OraResult</code> object.
</p>
</td></tr>
<tr><td><code id="fetch-methods_+3A_n">n</code></td>
<td>

<p>maximum number of records to retrieve per fetch.
Use <code>n = -1</code> to retrieve all pending records.
</p>
</td></tr>
<tr><td><code id="fetch-methods_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ROracle</code> implementations retrieves only <code>n</code> records,
and if <code>n</code> is missing it returns all records.
</p>


<h3>Value</h3>

<p>number of records fetched from database.
</p>


<h3>References</h3>

<p>For the Oracle Database documentaion see
<a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">http://www.oracle.com/technetwork/indexes/documentation/index.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Oracle">Oracle</a></code>,
<code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>,
<code><a href="DBI.html#topic+dbSendQuery">dbSendQuery</a></code>,
<code><a href="DBI.html#topic+dbGetQuery">dbGetQuery</a></code>,
<code><a href="DBI.html#topic+dbClearResult">dbClearResult</a></code>,
<code><a href="DBI.html#topic+dbCommit">dbCommit</a></code>,
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>,
<code><a href="DBI.html#topic+dbReadTable">dbReadTable</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    drv &lt;- dbDriver("Oracle")
    con &lt;- dbConnect(drv, "scott", "tiger")
    res &lt;- dbSendQuery(con, "select * from emp")

    # we now fetch the first 10 records from the resultSet into a data.frame
    data1 &lt;- fetch(res, n = 10)   
    dim(data1)

    dbHasCompleted(res)

    # let's get all remaining records
    data2 &lt;- fetch(res, n = -1)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='Oracle'>
Instantiate an Oracle client from the current <span class="rlang"><b>R</b></span> session
</h2><span id='topic+Oracle'></span><span id='topic+Extproc'></span>

<h3>Description</h3>

<p>This function creates and initializes an Oracle client from the
current <span class="rlang"><b>R</b></span> session. It returns an object that allows you to connect to
one or more Oracle servers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Oracle(interruptible = FALSE, unicode_as_utf8 = TRUE,
         ora.attributes = FALSE)
  Extproc(extproc.ctx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Oracle_+3A_interruptible">interruptible</code></td>
<td>

<p>A logical indicating whether to allow user interrupts on long-running
queries.
</p>
</td></tr>
<tr><td><code id="Oracle_+3A_extproc.ctx">extproc.ctx</code></td>
<td>

<p>An external pointer wrapping extproc context.
</p>
</td></tr>
<tr><td><code id="Oracle_+3A_unicode_as_utf8">unicode_as_utf8</code></td>
<td>

<p>A logical indicating whether to fetch NCHAR, NVARCHAR and NCLOB data
encoded in UTF8.
</p>
</td></tr>
<tr><td><code id="Oracle_+3A_ora.attributes">ora.attributes</code></td>
<td>

<p>A logical indicating whether to include the attributes <code>ora.encoding</code>,
<code>ora.type</code>, and <code>ora.maxlength</code> in the data frames returned by
<code>dbGetQuery</code> and <code>fetch</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This object is a singleton, that is, on subsequent invocations
it returns the same initialized object. 
</p>
<p>This implementation allows you to connect to multiple host servers and
run multiple connections on each server simultaneously.
</p>
<p>When <code>interruptible</code> is set to TRUE, it allows for interrupting
long-running queries on the server by executing the query in a thread. Main
thread checks for Ctrl-C and issues OCIBreak/OCIReset to cancel the operation
on the server. By default <code>interruptible</code> is FALSE.
</p>
<p>When <code>unicode_as_utf8</code> is set to FALSE, NCHAR, NVARCHAR and NCLOB data
is fetched using the character set using the NLS_LANG setting. By default
<code>unicode_as_utf8</code> is set to TRUE.
</p>
<p>When <code>ora.attributes</code> is set to TRUE attributes <code>ora.encoding</code>,
<code>ora.type</code> and <code>ora.maxlength</code> are added in result data frame
returned from dbGetQuery and fetch. It should be used with dbWriteTable to
create the same data types as in the Oracle DBMS as fetched from the source
table.
</p>


<h3>Value</h3>

<p>An object of class <code>OraDriver</code> for <code>Oracle</code> or
<code>ExtDriver</code> for <code>Extproc</code> whose class extends <code>DBIDriver</code>.
This object is used to create connections, using the function
<code>dbConnect</code>, to one or more Oracle database engines.
</p>


<h3>Side Effects</h3>

<p>The <span class="rlang"><b>R</b></span> client part of the database communication is initialized,
but note that connecting to the database engine needs to be done through
calls to <code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>.
</p>


<h3>Oracle user authentication</h3>

<p>In order to establish a connection to an Oracle server users need to provide
a user name, a password, and possibly a connect identifier (for more
information refer to chapter 8 (Configuring Naming Methods) of Oracle
Database Net Services Administrator's Guide). This is the same as the part
of the SQL*Plus connect string that follows the '@' sign.
</p>
<p>Connections to an Oracle TimesTen IMDB instance are established using the OCI
tnsnames or easy connect naming methods. For additional information on 
TimesTen connections for OCI see chapter 3 
(TimesTen Support for Oracle Call Interface) of the Oracle TimesTen In-Memory
C Developer's Guide.
</p>


<h3>Transactions</h3>

 
<p>The current implementation directly supports transaction
commits and rollbacks on a connection-wide basis through calls
to <code><a href="DBI.html#topic+dbCommit">dbCommit</a></code> and <code><a href="DBI.html#topic+dbRollback">dbRollback</a></code>.
Save points are not yet directly implemented, but you may be able
to define them and rollback to them through calls to dynamic SQL
with <code><a href="DBI.html#topic+dbGetQuery">dbGetQuery</a></code>.
</p>
<p>Notice that Oracle (and ANSI/ISO compliant DBMS) transactions are 
implicitly started when data definition SQL statements are executed (create
table, etc.), which helper functions like <code><a href="DBI.html#topic+dbWriteTable">dbWriteTable</a></code>
may execute behind the scenes. You may want or need to commit
or roll back your work before issuing any of these helper functions.
</p>


<h3>References</h3>

<p>For Oracle Database documentation, see
<a href="http://docs.oracle.com/en/database/">http://docs.oracle.com/en/database/</a>.
</p>


<h3>Author(s)</h3>

<p>David A. James and Denis Mukhin</p>


<h3>See Also</h3>

<p>On database managers:
</p>
<p><code><a href="DBI.html#topic+dbDriver">dbDriver</a></code>
<code><a href="DBI.html#topic+dbUnloadDriver">dbUnloadDriver</a></code>
<code><a href="DBI.html#topic+dbListConnections">dbListConnections</a></code>
</p>
<p>On connections:
</p>
<p><code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>
<code><a href="DBI.html#topic+dbDisconnect">dbDisconnect</a></code>
<code><a href="DBI.html#topic+dbSendQuery">dbSendQuery</a></code>
<code><a href="DBI.html#topic+dbGetQuery">dbGetQuery</a></code>
<code><a href="DBI.html#topic+dbGetException">dbGetException</a></code>
<code><a href="DBI.html#topic+dbListResults">dbListResults</a></code>
</p>
<p>Convenience methods:
<code><a href="DBI.html#topic+dbListTables">dbListTables</a></code>
<code><a href="DBI.html#topic+dbReadTable">dbReadTable</a></code>
<code><a href="DBI.html#topic+dbWriteTable">dbWriteTable</a></code>
<code><a href="DBI.html#topic+dbExistsTable">dbExistsTable</a></code>
<code><a href="DBI.html#topic+dbRemoveTable">dbRemoveTable</a></code>
<code><a href="DBI.html#topic+dbListFields">dbListFields</a></code>
</p>
<p>On transaction management:
</p>
<p><code><a href="DBI.html#topic+dbCommit">dbCommit</a></code>
<code><a href="DBI.html#topic+dbRollback">dbRollback</a></code>
</p>
<p>On queries and result objects:
</p>
<p><code><a href="DBI.html#topic+fetch">fetch</a></code>
<code><a href="DBI.html#topic+dbClearResult">dbClearResult</a></code>
<code><a href="DBI.html#topic+dbColumnInfo">dbColumnInfo</a></code>
<code><a href="DBI.html#topic+dbGetStatement">dbGetStatement</a></code>
<code><a href="DBI.html#topic+dbHasCompleted">dbHasCompleted</a></code>
<code><a href="DBI.html#topic+dbGetRowsAffected">dbGetRowsAffected</a></code>
<code><a href="DBI.html#topic+dbGetRowCount">dbGetRowCount</a></code>
</p>
<p>On meta-data:
</p>
<p><code><a href="methods.html#topic+show">show</a></code>
<code><a href="base.html#topic+summary">summary</a></code>
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    ## create a Oracle instance and create one connection.
    ora &lt;- Oracle()         ## or dbDriver("Oracle")
    con &lt;- dbConnect(ora, username = "scott", password = "tiger", 
                     dbname = "inst1")

    ## if you are connecting to a local database
    con &lt;- dbConnect(ora, username = "scott", password = "tiger")

    ## execute a statement and fetch its output in chunks of no more
    ## than 5000 rows at a time
    rs   &lt;- dbSendQuery(con, "select * from emp where deptno = 10")
    while (!dbHasCompleted(rs)) {
      df &lt;- fetch(rs, n = 5000)
      ## process df
    }
    dbClearResult(rs)       ## done with this query

    ## execute and fetch a statement with bind data
    df &lt;- dbGetQuery(con, "select * from emp where deptno = :1",
                     data = data.frame(depno = 10))

    ## create a copy of emp table
    dbGetQuery(con, "create table foo as select * from emp")

    ## execute and bind an INSERT statement
    my.data = data.frame(empno = c(8001, 8002), ename = c('MUKHIN', 'ABOYOUN'))
    more.data = data.frame(empno = c(8003), ename = c('JAMES'))
    rs &lt;- dbSendQuery(con, "insert into foo (empno, ename) values (:1, :2)",
                      data = my.data)

    ## execute with more data
    execute(rs, data = more.data)
    dbClearResult(rs)       ## done with this query

    ## ok, everything looks fine
    dbCommit(con)           

    ## a concise description of the driver 
    summary(ora)

    ## done with this connection
    dbDisconnect(con)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='OraConnection-class'>Class OraConnection</h2><span id='topic+OraConnection-class'></span>

<h3>Description</h3>

<p>An Oracle connection class implementing the R database interface (DBI) API.</p>


<h3>Generators</h3>

<p>The method <code><a href="DBI.html#topic+dbConnect">dbConnect</a></code> is the main generator.
</p>


<h3>Extends</h3>

<p>Class <code>"DBIConnection"</code>, directly.
Class <code>"DBIObject"</code>, by class <code>"DBIConnection"</code>, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>dbDisconnect</dt><dd><p><code>signature(conn = "OraConnection")</code>: ... </p>
</dd>
<dt>dbSendQuery</dt><dd><p><code>signature(conn = "OraConnection", statement = "character", prefetch = FALSE, bulk_read = 1000L, bulk_write = 1000L)</code>: ... </p>
</dd>
<dt>dbGetQuery</dt><dd><p><code>signature(conn = "OraConnection", statement = "character", prefetch = FALSE, bulk_read = 1000L, bulk_write = 1000L)</code>: ... </p>
</dd>
<dt>dbGetException</dt><dd><p><code>signature(conn = "OraConnection")</code>: ... </p>
</dd>
<dt>dbListResults</dt><dd><p><code>signature(conn = "OraConnection")</code>: ... </p>
</dd>
<dt>dbListTables</dt><dd><p><code>signature(conn = "OraConnection")</code>: ... </p>
</dd>
<dt>dbReadTable</dt><dd><p><code>signature(conn = "OraConnection", name = "character")</code>: ... </p>
</dd>
<dt>dbWriteTable</dt><dd><p><code>signature(conn = "OraConnection", name = "character", value = "data.frame")</code>: ... </p>
</dd>
<dt>dbExistsTable</dt><dd><p><code>signature(conn = "OraConnection", name = "character")</code>: ... </p>
</dd>
<dt>dbRemoveTable</dt><dd><p><code>signature(conn = "OraConnection", name = "character")</code>: ... </p>
</dd>
<dt>dbListFields</dt><dd><p><code>signature(conn = "OraConnection", name = "character")</code>: ... </p>
</dd>
<dt>dbCommit</dt><dd><p><code>signature(conn = "OraConnection")</code>: ... </p>
</dd>
<dt>dbRollback</dt><dd><p><code>signature(conn = "OraConnection")</code>: ... </p>
</dd>
<dt>dbGetInfo</dt><dd><p><code>signature(dbObj = "OraConnection")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "OraConnection")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "OraConnection")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p>DBI classes:
<code><a href="#topic+OraDriver-class">OraDriver-class</a></code>
<code><a href="#topic+OraConnection-class">OraConnection-class</a></code>
<code><a href="#topic+OraResult-class">OraResult-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ora &lt;- dbDriver("Oracle")
## connecting without a connect string
con &lt;- dbConnect(ora, "scott", "tiger")

## connecting with a connection string with SID
host &lt;- "myhost"
port &lt;- 1521
sid &lt;- "mysid"
connect.string &lt;- paste(
  "(DESCRIPTION=",
  "(ADDRESS=(PROTOCOL=tcp)(HOST=", host, ")(PORT=", port, "))",
  "(CONNECT_DATA=(SID=", sid, ")))", sep = "")

## use username/password authentication
con &lt;- dbConnect(drv, username = "scott", password = "tiger",
                 dbname = connect.string)

## connecting with a connection string with service name
host &lt;- "myhost"
port &lt;- 1521
svc &lt;- "mydb.example.com"
connect.string &lt;- paste(
  "(DESCRIPTION=",
  "(ADDRESS=(PROTOCOL=tcp)(HOST=", host, ")(PORT=", port, "))",
  "(CONNECT_DATA=(SERVICE_NAME=", svc, ")))", sep = "")
## use username/password authentication
con &lt;- dbConnect(drv, username = "scott", password = "tiger",
                 dbname = connect.string)

## Please refer to "Oracle Database Net Services Administator's Guide", which
## has the topic "Connect Identifier and Connect Descriptor Syntax
## Characteristics"

dbListTables(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='OraDriver-class'>Class OraDriver</h2><span id='topic+OraDriver-class'></span>

<h3>Description</h3>

<p>An Oracle driver class implementing the R database interface (DBI) API.
</p>


<h3>Generators</h3>

<p>The main generators are <code><a href="DBI.html#topic+dbDriver">dbDriver</a></code> and 
<code><a href="#topic+Oracle">Oracle</a></code>.
</p>


<h3>Extends</h3>

<p>Class <code>"DBIDriver"</code>, directly.
Class <code>"DBIObject"</code>, by class <code>"DBIDriver"</code>, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>dbConnect</dt><dd><p><code>signature(drv = "OraDriver")</code>: ... </p>
</dd>
<dt>dbGetInfo</dt><dd><p><code>signature(dbObj = "OraDriver")</code>: ... </p>
</dd>
<dt>dbListConnections</dt><dd><p><code>signature(drv = "OraDriver")</code>: ... </p>
</dd>
<dt>dbUnloadDriver</dt><dd><p><code>signature(drv = "OraDriver")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "OraDriver")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "OraDriver")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p>DBI classes:
<code><a href="#topic+OraConnection-class">OraConnection-class</a></code>
<code><a href="#topic+OraResult-class">OraResult-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# first load the library
library("ROracle")
ora &lt;- dbDriver("Oracle")
con &lt;- dbConnect(ora, "scott", "tiger")

## End(Not run)
</code></pre>

<hr>
<h2 id='OraResult-class'>Class OraResult</h2><span id='topic+OraResult-class'></span>

<h3>Description</h3>

<p>An Oracle query results class.  This class encapsulates the result of
a SQL statement.
</p>


<h3>Generators</h3>

<p>The main generator is <code><a href="DBI.html#topic+dbSendQuery">dbSendQuery</a></code>.
</p>


<h3>Extends</h3>

<p>Class <code>"DBIResult"</code>, directly.
Class <code>"DBIObject"</code>, by class <code>"DBIResult"</code>, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>dbClearResult</dt><dd><p><code>signature(res = "OraResult")</code>: ... </p>
</dd>
<dt>dbColumnInfo</dt><dd><p><code>signature(res = "OraResult")</code>: ... </p>
</dd>
<dt>dbGetInfo</dt><dd><p><code>signature(dbObj = "OraResult")</code>: ... </p>
</dd>
<dt>dbGetStatement</dt><dd><p><code>signature(res = "OraResult")</code>: ... </p>
</dd>
<dt>dbGetRowCount</dt><dd><p><code>signature(res = "OraResult")</code>: ... </p>
</dd>
<dt>dbGetRowsAffected</dt><dd><p><code>signature(res = "OraResult")</code>: ... </p>
</dd>
<dt>dbHasCompleted</dt><dd><p><code>signature(res = "OraResult")</code>: ... </p>
</dd>
<dt>fetch</dt><dd><p><code>signature(res = "OraResult", n = "numeric")</code>: ... </p>
</dd>
<dt>fetch</dt><dd><p><code>signature(res = "OraResult", n = "missing")</code>: ... </p>
</dd>
<dt>execute</dt><dd><p><code>signature(res = "OraResult")</code>: ...</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "OraResult")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "OraResult")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p>DBI classes:
<code><a href="#topic+OraDriver-class">OraDriver-class</a></code>
<code><a href="#topic+OraConnection-class">OraConnection-class</a></code>
<code><a href="#topic+OraResult-class">OraResult-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ora &lt;- dbDriver("Oracle")
con &lt;- dbConnect(ora, "scott", "tiger")
res &lt;- dbSendQuery(con, "select * from emp")
fetch(res, n = 2)
fetch(res)
dbColumnInfo(res)
dbClearResult(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary-methods'>
Summarize an Oracle object
</h2><span id='topic+show+2COraDriver-method'></span><span id='topic+show+2CExtDriver-method'></span><span id='topic+show+2COraConnection-method'></span><span id='topic+show+2COraResult-method'></span><span id='topic+summary+2COraDriver-method'></span><span id='topic+summary+2CExtDriver-method'></span><span id='topic+summary+2COraConnection-method'></span><span id='topic+summary+2COraResult-method'></span>

<h3>Description</h3>

<p>These methods are straight-forward implementations of the corresponding
generic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OraDriver'
summary(object, ...)
## S4 method for signature 'ExtDriver'
summary(object, ...)
## S4 method for signature 'OraConnection'
summary(object, ...)
## S4 method for signature 'OraResult'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>

<p>a driver, connection or result set object.
</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>description of object.
</p>


<h3>References</h3>

<p>For the Oracle Database documentaion see
<a href="http://www.oracle.com/technetwork/indexes/documentation/index.html">http://www.oracle.com/technetwork/indexes/documentation/index.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Oracle">Oracle</a></code>,
<code><a href="DBI.html#topic+dbConnect">dbConnect</a></code>,
<code><a href="DBI.html#topic+dbSendQuery">dbSendQuery</a></code>,
<code><a href="DBI.html#topic+dbGetQuery">dbGetQuery</a></code>,
<code><a href="DBI.html#topic+dbClearResult">dbClearResult</a></code>,
<code><a href="DBI.html#topic+dbCommit">dbCommit</a></code>,
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>,
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    drv &lt;- dbDriver("Oracle")
    con &lt;- dbConnect(drv, "scott", "tiger")
    res &lt;- dbSendQuery(con, "select * from emp")

    summary(drv)
    summary(con)
    summary(res)
    show(drv)
    show(con)
    show(res)   
  
## End(Not run) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
