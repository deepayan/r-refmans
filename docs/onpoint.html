<!DOCTYPE html><html><head><title>Help for package onpoint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {onpoint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#onpoint'><p>onpoint</p></a></li>
<li><a href='#balance_points'><p>balance_points</p></a></li>
<li><a href='#calc_area'><p>calc_area</p></a></li>
<li><a href='#center_l_function'><p>center_l_function</p></a></li>
<li><a href='#estimate_o_ring'><p>estimate_o_ring</p></a></li>
<li><a href='#estimate_pcf_fast'><p>estimate_pcf_fast</p></a></li>
<li><a href='#plot_quantums'><p>plot_quantums</p></a></li>
<li><a href='#plot.env_summarized'><p>plot.env_summarized</p></a></li>
<li><a href='#print.env_summarized'><p>print.env_summarized</p></a></li>
<li><a href='#rlabel_local'><p>rlabel_local</p></a></li>
<li><a href='#simulate_antecedent_conditions'><p>simulate_antecedent_conditions</p></a></li>
<li><a href='#simulate_heterogenous_pattern'><p>simulate_heterogenous_pattern</p></a></li>
<li><a href='#split_at'><p>split_at</p></a></li>
<li><a href='#summarize_envelope'><p>summarize_envelope</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Helper Functions for Point Pattern Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian H.K. Hesselbarth &lt;mhk.hesselbarth@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Growing collection of helper functions for point pattern analysis. Most functions
  are designed to work with the 'spatstat' (<a href="http://spatstat.org">http://spatstat.org</a>) package. The focus of 
  most functions are either null models or summary functions for spatial point patterns. 
  For a detailed description of all null models and summary functions, see 
  Wiegand and Moloney (2014, ISBN:9781420082548).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-spatialecology.github.io/onpoint/">https://r-spatialecology.github.io/onpoint/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatialecology/onpoint/issues">https://github.com/r-spatialecology/onpoint/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, spatstat.explore, spatstat.geom, spatstat.random,
stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, spatstat (&ge; 2.0.0), testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-10 13:26:02 UTC; hesselbarth</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian H.K. Hesselbarth
    <a href="https://orcid.org/0000-0003-1125-9918"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 14:03:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='onpoint'>onpoint</h2><span id='topic+onpoint'></span><span id='topic+onpoint-package'></span>

<h3>Description</h3>

<p>Growing collection of small helper functions for point pattern analysis. Most functions
are designed to work with the spatstat package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Maximilian H.K. Hesselbarth <a href="mailto:mhk.hesselbarth@gmail.com">mhk.hesselbarth@gmail.com</a> (<a href="https://orcid.org/0000-0003-1125-9918">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://r-spatialecology.github.io/onpoint/">https://r-spatialecology.github.io/onpoint/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-spatialecology/onpoint/issues">https://github.com/r-spatialecology/onpoint/issues</a>
</p>
</li></ul>


<hr>
<h2 id='balance_points'>balance_points</h2><span id='topic+balance_points'></span>

<h3>Description</h3>

<p>Balance number of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance_points(pattern, n, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance_points_+3A_pattern">pattern</code></td>
<td>
<p>ppp object.</p>
</td></tr>
<tr><td><code id="balance_points_+3A_n">n</code></td>
<td>
<p>Either an integer or a ppp object.</p>
</td></tr>
<tr><td><code id="balance_points_+3A_verbose">verbose</code></td>
<td>
<p>Print messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function balances out the number of points in the input pattern to either
the provided number of points as integer or the same number of points if a <code>ppp</code>
object is provided.
</p>


<h3>Value</h3>

<p>ppp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
input &lt;- spatstat.random::rpoispp(lambda = 100)
input_b &lt;- spatstat.random::rpoispp(lambda = 100)

balance_points(pattern = input, n = 110)
balance_points(pattern = input, n = input_b)

</code></pre>

<hr>
<h2 id='calc_area'>calc_area</h2><span id='topic+calc_area'></span>

<h3>Description</h3>

<p>Calculate area of polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_area(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_area_+3A_x">x</code></td>
<td>
<p>matrix with x,y coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate area of polygon in input units. If the polygon is not closed, the first
coordinate is used as last coordinate to close it.
</p>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- matrix(data = c(0, 0, 0, 10, 10, 10, 10, 0), ncol = 2, byrow = TRUE)
calc_area(x = dat)

## End(Not run)

</code></pre>

<hr>
<h2 id='center_l_function'>center_l_function</h2><span id='topic+center_l_function'></span>

<h3>Description</h3>

<p>Centered L-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_l_function(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_l_function_+3A_x">x</code></td>
<td>
<p>ppp</p>
</td></tr>
<tr><td><code id="center_l_function_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>spatstat.explore::Lest()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Centers Besag's L-function to zero by calculating L(r) -r. Centering the L-function
allows an easier interpretation and plotting of the results (Haase 1995).
</p>
<p>Returns an 'Function value object' of the <code>spatstat</code> package.
</p>


<h3>Value</h3>

<p>fv.object
</p>


<h3>References</h3>

<p>Besag, J.E., 1977. Discussion on Dr. Ripley’s paper. Journal of the Royal Statistical
Society. Series B (Methodological) 39, 193–195.
&lt;https://doi.org/10.1111/j.2517-6161.1977.tb01616.x&gt;
</p>
<p>Ripley, B.D., 1977. Modelling spatial patterns. Journal of the Royal Statistical Society.
Series B (Methodological) 39, 172–192. &lt;https://doi.org/10.1111/j.2517-6161.1977.tb01615.x&gt;
</p>
<p>Haase, P., 1995. Spatial pattern analysis in ecology based on Ripley’s K-function:
Introduction and methods of edge correction. Journal of Vegetation Science 6, 575–582.
&lt;https://doi.org/10.2307/3236356&gt;
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Lest">Lest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_pattern &lt;- spatstat.random::runifpoint(n = 100)
center_l_function(input_pattern, correction = "Ripley")

lest &lt;- spatstat.explore::Lest(input_pattern)
center_l_function(lest)

</code></pre>

<hr>
<h2 id='estimate_o_ring'>estimate_o_ring</h2><span id='topic+estimate_o_ring'></span>

<h3>Description</h3>

<p>O-ring function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_o_ring(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_o_ring_+3A_x">x</code></td>
<td>
<p>ppp</p>
</td></tr>
<tr><td><code id="estimate_o_ring_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>spatstat.explore::pcf.ppp()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the O-ring function proposed by Wiegand and Moloney (2004). The
O-ring statistic is defined as:
</p>
<p style="text-align: center;"><code class="reqn">O(r) = \lambda * g(r)</code>
</p>

<p>Generally speaking, O(r) scales the pair correlation g(r) function with help
of the intensity <code class="reqn">\lambda</code>. One advantage of the O-ring statistic is that
it can be interpreted as a neighborhood density because it is a probability density
function (Wiegand &amp; Moloney 2004, 2014).
</p>
<p>Returns an 'Function value object' of the <code>spatstat</code> package.
</p>


<h3>Value</h3>

<p>fv.object
</p>


<h3>References</h3>

<p>Wiegand, T., Moloney, K.A., 2004. Rings, circles, and null models for point pattern
analysis in ecology. Oikos 104, 209–229. &lt;https://doi.org/10.1111/j.0030-1299.2004.12497.x&gt;
</p>
<p>Wiegand, T., Moloney, K.A., 2014. Handbook of spatial point-pattern analysis in
ecology. Chapman and Hall/CRC Press, Boca Raton, USA. &lt;isbn:978-1-4200-8254-8&gt;
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> <br />
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_pattern &lt;- spatstat.random::runifpoint(n = 100)
estimate_o_ring(input_pattern)

</code></pre>

<hr>
<h2 id='estimate_pcf_fast'>estimate_pcf_fast</h2><span id='topic+estimate_pcf_fast'></span>

<h3>Description</h3>

<p>Fast estimation of the pair correlation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_pcf_fast(pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_pcf_fast_+3A_pattern">pattern</code></td>
<td>
<p>Point pattern.</p>
</td></tr>
<tr><td><code id="estimate_pcf_fast_+3A_...">...</code></td>
<td>
<p>Arguments passed down to 'Kest' or 'pcf.fv'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions estimates the pair correlation functions based on an estimation
of Ripley's K-function. This makes it computationally faster than estimating the
pair correlation function directly.
</p>
<p>It is a wrapper around <code>Kest</code> and <code>pcf.fv</code> and returns a 'Function value
object' of the <code>spatstat</code> package.
</p>


<h3>Value</h3>

<p>fv.object
</p>


<h3>References</h3>

<p>Ripley, B.D., 1977. Modelling spatial patterns. Journal of the Royal Statistical Society.
Series B (Methodological) 39, 172–192. &lt;https://doi.org/10.1111/j.2517-6161.1977.tb01615.x&gt;
</p>
<p>Stoyan, D., Stoyan, H., 1994. Fractals, random shapes and point fields.
John Wiley &amp; Sons, Chichester, UK. &lt;isbn:978-0-471-93757-9&gt;
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> <br />
<code><a href="spatstat.explore.html#topic+pcf.fv">pcf.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
pattern &lt;- spatstat.random::runifpoint(n = 100)
pcf_fast &lt;- estimate_pcf_fast(pattern)

</code></pre>

<hr>
<h2 id='plot_quantums'>plot_quantums</h2><span id='topic+plot_quantums'></span>

<h3>Description</h3>

<p>Plot simulation envelopes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_quantums(
  input,
  labels = NULL,
  color_scale = NULL,
  legend_position = "bottom",
  quantum_position = NULL,
  title = NULL,
  xlab = NULL,
  ylab = NULL,
  line_size = 0.5,
  base_size = 15,
  full_fun = TRUE,
  quantum = TRUE,
  standarized = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_quantums_+3A_input">input</code></td>
<td>
<p>envelope.</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_labels">labels</code></td>
<td>
<p>Name of the labels. See details for more information.</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_color_scale">color_scale</code></td>
<td>
<p>Colors used with labels.</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_legend_position">legend_position</code></td>
<td>
<p>The position of legends (&quot;none&quot;, &quot;left&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;top&quot;, or two-element numeric vector)</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_quantum_position">quantum_position</code></td>
<td>
<p>Vector with minimum and maximum y value of the quantum bar.</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_title">title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_xlab">xlab</code>, <code id="plot_quantums_+3A_ylab">ylab</code></td>
<td>
<p>axis labels.</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_line_size">line_size</code></td>
<td>
<p>Size of the lines.</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_base_size">base_size</code></td>
<td>
<p>Base font size.</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_full_fun">full_fun</code></td>
<td>
<p>If true observed value and envelope is plotted.</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_quantum">quantum</code></td>
<td>
<p>If true quantums bars are plotted.</p>
</td></tr>
<tr><td><code id="plot_quantums_+3A_standarized">standarized</code></td>
<td>
<p>If true observed value is standardized. See details for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions provides a plotting style for envelope objects of the spatstat
package (for more information please see <code>spatstat.explore::envelope</code>). The location of the
observed value in relation to the simulation envelope of the null model input is
indicated by an additional colour bar at the bottom of the plot. If <code>standarized = TRUE</code>,
all values are standarized by subtracting the theoretical value for CSR
</p>
<p>Labels must be a vector including labels for the following three cases. The color
scale vector is used in the same order.
<br /> 1 = observed &gt; high
<br /> 2 = low &lt; observed &lt; high
<br /> 3 = observed &lt; low
</p>
<p>To adjust the position of the quantum bar, use <code>quantum_position</code>.
</p>
<p>Returns a <code>ggplot</code> object.
</p>


<h3>Value</h3>

<p>ggplot
</p>


<h3>References</h3>

<p>Esser, D.S., Leveau, J.H.J., Meyer, K.M., Wiegand, K., 2015. Spatial scales of
interactions among bacteria and between bacteria and the leaf surface.
FEMS Microbiology Ecology 91, 1–13. &lt;https://doi.org/10.1093/femsec/fiu034&gt;
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
pattern &lt;- spatstat.random::rThomas(kappa = 50, scale = 0.025, mu = 5)
csr_envelope &lt;- spatstat.explore::envelope(pattern, fun = spatstat.explore::pcf, nsim = 19)
plot_quantums(csr_envelope, ylab = "g(r)")

</code></pre>

<hr>
<h2 id='plot.env_summarized'>plot.env_summarized</h2><span id='topic+plot.env_summarized'></span>

<h3>Description</h3>

<p>Plotting method for <code>env_summarized</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'env_summarized'
plot(
  x,
  col = c("#97CBDE", "#E1B0B5"),
  x_lab = NULL,
  y_lab = NULL,
  base_size = 10,
  label = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.env_summarized_+3A_x">x</code></td>
<td>
<p>Random patterns.</p>
</td></tr>
<tr><td><code id="plot.env_summarized_+3A_col">col</code></td>
<td>
<p>Colors for areas above and below envelope.</p>
</td></tr>
<tr><td><code id="plot.env_summarized_+3A_x_lab">x_lab</code>, <code id="plot.env_summarized_+3A_y_lab">y_lab</code></td>
<td>
<p>Labels of x- and y-axis.</p>
</td></tr>
<tr><td><code id="plot.env_summarized_+3A_base_size">base_size</code></td>
<td>
<p>Base size of plot</p>
</td></tr>
<tr><td><code id="plot.env_summarized_+3A_label">label</code></td>
<td>
<p>If TRUE the ratios of the area above and below are added to the plot.</p>
</td></tr>
<tr><td><code id="plot.env_summarized_+3A_...">...</code></td>
<td>
<p>To be generic for plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting method for summarized envelope created with <code><a href="#topic+summarize_envelope">summarize_envelope</a></code>.
</p>
<p>Returns a <code>ggplot</code> object.
</p>


<h3>Value</h3>

<p>ggplot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summarize_envelope">summarize_envelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
input_pattern &lt;- spatstat.random::rThomas(kappa = 15, scale = 0.05, mu = 5)

cluster_env &lt;- spatstat.explore::envelope(input_pattern, fun = "pcf", nsim = 39,
funargs = list(divisor = "d", correction = "Ripley", stoyan = 0.25))

x &lt;- summarize_envelope(cluster_env)
plot(x)

</code></pre>

<hr>
<h2 id='print.env_summarized'>print.env_summarized</h2><span id='topic+print.env_summarized'></span>

<h3>Description</h3>

<p>Print method for env_summarized object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'env_summarized'
print(x, return_area = FALSE, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.env_summarized_+3A_x">x</code></td>
<td>
<p>Random patterns.</p>
</td></tr>
<tr><td><code id="print.env_summarized_+3A_return_area">return_area</code></td>
<td>
<p>If true, not the ratio but the area is returned.</p>
</td></tr>
<tr><td><code id="print.env_summarized_+3A_digits">digits</code></td>
<td>
<p>Number of decimal places (round).</p>
</td></tr>
<tr><td><code id="print.env_summarized_+3A_...">...</code></td>
<td>
<p>Arguments passed to cat</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Printing method for summarized envelope created with <code><a href="#topic+summarize_envelope">summarize_envelope</a></code>.
</p>


<h3>Value</h3>

<p>No return value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summarize_envelope">summarize_envelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
input_pattern &lt;- spatstat.random::rThomas(kappa = 15, scale = 0.05, mu = 5)

cluster_env &lt;- spatstat.explore::envelope(input_pattern, fun = "pcf", nsim = 39,
funargs = list(divisor = "d", correction = "Ripley", stoyan = 0.25))

x &lt;- summarize_envelope(cluster_env)
print(x)

</code></pre>

<hr>
<h2 id='rlabel_local'>rlabel_local</h2><span id='topic+rlabel_local'></span>

<h3>Description</h3>

<p>Local random labelling of marked point pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlabel_local(X, distance, nsim = 19, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlabel_local_+3A_x">X</code></td>
<td>
<p>ppp</p>
</td></tr>
<tr><td><code id="rlabel_local_+3A_distance">distance</code></td>
<td>
<p>Mark of points that do not change.</p>
</td></tr>
<tr><td><code id="rlabel_local_+3A_nsim">nsim</code></td>
<td>
<p>Number of patterns to simulate.</p>
</td></tr>
<tr><td><code id="rlabel_local_+3A_drop">drop</code></td>
<td>
<p>If nsim = 1 and drop = TRUE , the result will be a point pattern,
rather than a list containing a point pattern.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Local random labelling function, i.e. marks will be shuffeld only across points
within the specified local distance. Technically, this is achived by sampling the
mark of a neighbouring point j within the distance d for the focal point i. Thus,
the distance d must be selected in a way that each point has at least one neighbour
within d.
</p>
<p>Returns a <code>list</code> with <code>ppp</code> objects.
</p>


<h3>Value</h3>

<p>list
</p>


<h3>References</h3>

<p>Velázquez, E., Martínez, I., Getzin, S., Moloney, K.A., Wiegand, T., 2016. An evaluation
of the state of spatial point pattern analysis in ecology. Ecography 39, 1–14.
&lt;https://doi.org/10.1111/ecog.01579&gt;
</p>
<p>Wiegand, T., Moloney, K.A., 2014. Handbook of spatial point-pattern analysis in
ecology. Chapman and Hall/CRC Press, Boca Raton, USA. &lt;isbn:978-1-4200-8254-8&gt;
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.random.html#topic+rlabel">rlabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
pattern &lt;- spatstat.random::runifpoint(n = 250, win = spatstat.geom::owin(c(0, 100), c(0, 100)))
spatstat.geom::marks(pattern) &lt;- runif(n = 250, min = 10, max = 120)

rlabel_local(X = pattern, distance = 25, nsim = 19)

</code></pre>

<hr>
<h2 id='simulate_antecedent_conditions'>simulate_antecedent_conditions</h2><span id='topic+simulate_antecedent_conditions'></span>

<h3>Description</h3>

<p>Simulate heterogenous pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_antecedent_conditions(x, i, j, nsim, heterogenous = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_antecedent_conditions_+3A_x">x</code></td>
<td>
<p>ppp</p>
</td></tr>
<tr><td><code id="simulate_antecedent_conditions_+3A_i">i</code></td>
<td>
<p>Mark of points that are randomized.</p>
</td></tr>
<tr><td><code id="simulate_antecedent_conditions_+3A_j">j</code></td>
<td>
<p>Mark of points that do not change.</p>
</td></tr>
<tr><td><code id="simulate_antecedent_conditions_+3A_nsim">nsim</code></td>
<td>
<p>Number of patterns to simulate.</p>
</td></tr>
<tr><td><code id="simulate_antecedent_conditions_+3A_heterogenous">heterogenous</code></td>
<td>
<p>If TRUE, points with the mark i are randomized using a heterogeneous
Poisson process.</p>
</td></tr>
<tr><td><code id="simulate_antecedent_conditions_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>spatstat.explore::density.ppp()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulate point patterns as null model data for <code>spatstat.explore::envelope()</code> using
antecedent conditions as null model. <code>x</code> must be marked point pattern.
Antecedent conditions are suitable as a null model if points of type j may influence
points of type i, but not the other way around (Velazquez et al 2016). One example are
the positions of seedlings that may be influenced by the position of mature trees.
</p>
<p>Returns a <code>list</code> with <code>ppp</code> objects.
</p>


<h3>Value</h3>

<p>list
</p>


<h3>References</h3>

<p>Velázquez, E., Martínez, I., Getzin, S., Moloney, K.A., Wiegand, T., 2016. An evaluation
of the state of spatial point pattern analysis in ecology. Ecography 39, 1–14.
&lt;https://doi.org/10.1111/ecog.01579&gt;
</p>
<p>Wiegand, T., Moloney, K.A., 2014. Handbook of spatial point-pattern analysis in
ecology. Chapman and Hall/CRC Press, Boca Raton, USA. &lt;isbn:978-1-4200-8254-8&gt;
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
pattern_a &lt;- spatstat.random::runifpoint(n = 20)
spatstat.geom::marks(pattern_a) &lt;- "a"
pattern_b &lt;- spatstat.random::runifpoint(n = 100)
spatstat.geom::marks(pattern_b) &lt;- "b"
pattern &lt;- spatstat.geom::superimpose(pattern_a, pattern_b)

null_model &lt;- simulate_antecedent_conditions(x = pattern, i = "b", j = "a", nsim = 19)
spatstat.explore::envelope(Y = pattern, fun = spatstat.explore::pcf,
nsim = 19, simulate = null_model)

</code></pre>

<hr>
<h2 id='simulate_heterogenous_pattern'>simulate_heterogenous_pattern</h2><span id='topic+simulate_heterogenous_pattern'></span>

<h3>Description</h3>

<p>Simulate heterogeneous pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_heterogenous_pattern(x, nsim, fix_n = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_heterogenous_pattern_+3A_x">x</code></td>
<td>
<p>ppp</p>
</td></tr>
<tr><td><code id="simulate_heterogenous_pattern_+3A_nsim">nsim</code></td>
<td>
<p>Number of patterns to simulate.</p>
</td></tr>
<tr><td><code id="simulate_heterogenous_pattern_+3A_fix_n">fix_n</code></td>
<td>
<p>Logical if true the null model patterns have exactly the same number of points ais input.</p>
</td></tr>
<tr><td><code id="simulate_heterogenous_pattern_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>spatstat.explore::density.ppp()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulate heterogeneous point patterns as null model data for <code>spatstat.explore::envelope()</code>.
A heterogeneous Poisson process is used, meaning that there are no interaction between points,
however, the simulated coordinates depend on the intensity <code class="reqn">\lambda</code> of the input pattern.
</p>
<p>Returns a <code>list</code> with <code>ppp</code> objects.
</p>


<h3>Value</h3>

<p>list
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E., Turner, R., 2015. Spatial point patterns: Methodology
and applications with R. Chapman and Hall/CRC Press, London, UK. &lt;isbn:978-1-4822-1020-0&gt;
</p>
<p>Wiegand, T., Moloney, K.A., 2014. Handbook of spatial point-pattern analysis in
ecology. Chapman and Hall/CRC Press, Boca Raton, USA. &lt;isbn:978-1-4200-8254-8&gt;
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+envelope">envelope</a></code> <br />
<code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
input_pattern &lt;- spatstat.random::rpoispp(lambda = function(x , y) {100 * exp(-3 * x)}, nsim = 1)
null_model &lt;- simulate_heterogenous_pattern(input_pattern, nsim = 19)
spatstat.explore::envelope(Y = input_pattern, fun = spatstat.explore::pcf, nsim = 19,
simulate = null_model)

</code></pre>

<hr>
<h2 id='split_at'>split_at</h2><span id='topic+split_at'></span>

<h3>Description</h3>

<p>Split vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_at(x, pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_at_+3A_x">x</code></td>
<td>
<p>vector with positions to split.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Split vector at position(s). Returns a <code>list</code> with all elements before and
after the split position.
</p>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(42)
x &lt;- sample(x = 1:10, size = 5)
split_at(x = x, pos = 3)

## End(Not run)

</code></pre>

<hr>
<h2 id='summarize_envelope'>summarize_envelope</h2><span id='topic+summarize_envelope'></span>

<h3>Description</h3>

<p>Summarize simulation envelope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_envelope(x, plot_result = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_envelope_+3A_x">x</code></td>
<td>
<p>fv</p>
</td></tr>
<tr><td><code id="summarize_envelope_+3A_plot_result">plot_result</code></td>
<td>
<p>A plot is drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The area above and below the null model envelope is divided by the total area
under the curve. If <code>seperated = TRUE</code>, the first returning value is the
relative area above, the second value the relative value below the envelope.
If <code>seperated = FALSE</code> the value is the absolute sum of both ratio. If the
value is positive, the area above the envelope is larger than the value below
the envelope. If the value is negative, the area under the envelope is larger than
the value above the envelope.
</p>
<p>The returned <code>env_summarized</code> object includes information about the area
under the curve where the summary function observed pattern is above or below
the null model envelopes.
</p>


<h3>Value</h3>

<p>env_summarized
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
input_pattern &lt;- spatstat.random::rThomas(kappa = 15, scale = 0.05, mu = 5)

cluster_env &lt;- spatstat.explore::envelope(input_pattern, fun = "pcf", nsim = 39,
funargs = list(divisor = "d", correction = "Ripley", stoyan = 0.25))

summarize_envelope(cluster_env)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
