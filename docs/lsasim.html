<!DOCTYPE html><html><head><title>Help for package lsasim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lsasim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lsasim'><p>lsasim: A package for simulating large scale assessment data</p></a></li>
<li><a href='#.onAttach'><p>Prints welcome message on package load</p></a></li>
<li><a href='#anova.lsasimcluster'><p>Generate an ANOVA table for LSASIM clusters</p></a></li>
<li><a href='#attribute_cluster_labels'><p>Attribute Labels in Hierarchical Structure</p></a></li>
<li><a href='#beta_gen'><p>Generate regression coefficients</p></a></li>
<li><a href='#block_design'><p>Assignment of test items to blocks</p></a></li>
<li><a href='#booklet_design'><p>Assignment of item blocks to test booklets</p></a></li>
<li><a href='#booklet_sample'><p>Assignment of test booklets to test takers</p></a></li>
<li><a href='#brr'><p>Generate replicates of a dataset using Balanced Repeated Replication</p></a></li>
<li><a href='#calc_n_tilde'><p>Calculate ñ</p></a></li>
<li><a href='#calc_replicate_weights'><p>Calculate replicate weights and summary statistics</p></a></li>
<li><a href='#calc_se_rho'><p>Calculate Standard Error of Intraclass Correlation</p></a></li>
<li><a href='#calc_var_between'><p>Calculate variance between classes</p></a></li>
<li><a href='#calc_var_tot'><p>Calculate the total variance</p></a></li>
<li><a href='#calc_var_within'><p>Calculate variance within classes</p></a></li>
<li><a href='#check_condition'><p>Check if an error condition is satisfied</p></a></li>
<li><a href='#check_ignored_parameters'><p>Checks if provided parameters are ignored</p></a></li>
<li><a href='#check_n_N_class'><p>Check class of n or N</p></a></li>
<li><a href='#check_valid_structure'><p>Check if List is Valid</p></a></li>
<li><a href='#cluster_gen'><p>Generate cluster sample</p></a></li>
<li><a href='#cluster_gen_separate'><p>Generate cluster samples with individual questionnaires</p></a></li>
<li><a href='#cluster_gen_together'><p>Generate cluster samples with lowest-level questionnaires</p></a></li>
<li><a href='#cluster_message'><p>Print messages about clusters</p></a></li>
<li><a href='#convert_vector_to_list'><p>Convert Vector to Expanded List</p></a></li>
<li><a href='#cor_gen'><p>Generation of random correlation matrix</p></a></li>
<li><a href='#cov_gen'><p>Generation of covariance matrices</p></a></li>
<li><a href='#cov_yfz_gen'><p>Generate latent regression covariance matrix</p></a></li>
<li><a href='#cov_yxw_gen'><p>Setup full YXW covariance matrix</p></a></li>
<li><a href='#cov_yxz_gen'><p>Generate analytical covariance matrix</p></a></li>
<li><a href='#customize_summary'><p>Customize Summary</p></a></li>
<li><a href='#draw_cluster_structure'><p>Draw Cluster Structure</p></a></li>
<li><a href='#gen_cat_prop'><p>Generates cat_prop for questionnaire_gen</p></a></li>
<li><a href='#gen_variable_n'><p>Randomly generate the quantity of background variables</p></a></li>
<li><a href='#gen_X_W_cluster'><p>Generate n_X and n_W for clusters</p></a></li>
<li><a href='#intraclass_cor'><p>Intraclass correlation</p></a></li>
<li><a href='#irt_gen'><p>Simulate item responses from an item response model</p></a></li>
<li><a href='#item_gen'><p>Generation of item parameters from uniform distributions</p></a></li>
<li><a href='#jackknife'><p>Generate replicates of a dataset using Jackknife</p></a></li>
<li><a href='#label_respondents'><p>Label respondents</p></a></li>
<li><a href='#lambda_gen'><p>Randomly generate a matrix of factor loadings</p></a></li>
<li><a href='#pisa2012_math_block'><p>PISA 2012 mathematics item - item block indicator matrix</p></a></li>
<li><a href='#pisa2012_math_booklet'><p>PISA 2012 mathematics item block - test booklet indicator matrix</p></a></li>
<li><a href='#pisa2012_math_item'><p>Item parameter estimates for 2012 PISA mathematics assessment</p></a></li>
<li><a href='#pisa2012_q_cormat'><p>Correlation matrix from the PISA 2012 background questionnaire</p></a></li>
<li><a href='#pisa2012_q_marginal'><p>Marginal proportions from the PISA 2012 background questionnaire</p></a></li>
<li><a href='#pluralize'><p>Pluralize words</p></a></li>
<li><a href='#print_anova'><p>Print the ANOVA table</p></a></li>
<li><a href='#proportion_gen'><p>Generation of random cumulative proportions</p></a></li>
<li><a href='#pt_bis_conversion'><p>Analytical point-biserial conversion</p></a></li>
<li><a href='#questionnaire_gen'><p>Generation of ordinal and continuous variables</p></a></li>
<li><a href='#questionnaire_gen_family'><p>Generation of ordinal and continuous variables</p></a></li>
<li><a href='#questionnaire_gen_polychoric'><p>Generation of ordinal and continuous variables</p></a></li>
<li><a href='#ranges'><p>Defines vector as range</p></a></li>
<li><a href='#recalc_final_weights'><p>Recalculate final weights</p></a></li>
<li><a href='#replicate_var'><p>Sampling variance of the mean for replications</p></a></li>
<li><a href='#response_gen'><p>Generation of item response data using a rotated block design</p></a></li>
<li><a href='#rzeropois'><p>Generate data from a Zero-truncated Poisson</p></a></li>
<li><a href='#sample_from'><p>Sample from population structure</p></a></li>
<li><a href='#sample_within_range'><p>Sample from range</p></a></li>
<li><a href='#select'><p>Transform regular vector into selection vector</p></a></li>
<li><a href='#split_cat_prop'><p>Split variables in cat_prop</p></a></li>
<li><a href='#summary_2'><p>Dataset summary statistics</p></a></li>
<li><a href='#summary.lsasimcluster'><p>Summarizes clusters</p></a></li>
<li><a href='#trim_sample'><p>Trim sample</p></a></li>
<li><a href='#validate_questionnaire_gen'><p>Wrapper-functions for check_condition</p></a></li>
<li><a href='#weight_responses'><p>Weight responses</p></a></li>
<li><a href='#whitelist_message'><p>Whitelist message</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functions to Facilitate the Simulation of Large Scale Assessment
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.4</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tmatta/lsasim/issues">https://github.com/tmatta/lsasim/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to simulate data from large-scale educational
  assessments, including background questionnaire data and cognitive item
  responses that adhere to a multiple-matrix sampled design. The theoretical
  foundation can be found on
  Matta, T.H., Rutkowski, L., Rutkowski, D. et al. (2018)
  &lt;<a href="https://doi.org/10.1186%2Fs40536-018-0068-8">doi:10.1186/s40536-018-0068-8</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, cli, methods, polycor</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, formatR, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 08:48:56 UTC; waldir</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Matta [aut],
  Leslie Rutkowski [aut],
  David Rutkowski [aut],
  Yuan-Ling Linda Liaw [aut],
  Kondwani Kajera Mughogho [ctb],
  Waldir Leoncio [aut, cre],
  Sinan Yavuz [ctb],
  Paul Bailey [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Waldir Leoncio &lt;w.l.netto@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lsasim'>lsasim: A package for simulating large scale assessment data</h2><span id='topic+lsasim'></span><span id='topic+lsasim-package'></span>

<h3>Description</h3>

<p>lsasim simulates data that mimics large-scale assessments (LSAs), including background questionnaire data and cognitive item responses that adhere to a multiple-matrix sampled design
</p>
<p>Functions to Facilitate the Simulation of Large Scale Assessment Data
</p>


<h3>Core functions</h3>


<ul>
<li> <p><code>block_design</code> Assignment of test items to blocks.
</p>
</li>
<li> <p><code>booklet_design</code> Assignment of item blocks to test booklets.
</p>
</li>
<li> <p><code>booklet_sample</code> Assignment of test booklets to test takers.
</p>
</li>
<li> <p><code>item_gen</code> Generation of random correlation matrix.
</p>
</li>
<li> <p><code>proportion_gen</code> Generation of random cumulative proportions.
</p>
</li>
<li> <p><code>questionnaire_gen</code> Generation of ordinal and continuous variables.
</p>
</li>
<li> <p><code>response_gen</code> Generation of item response data using a rotated block design.
</p>
</li>
<li> <p><code>cluster_gen</code> Generation of background questionnaires from a cluster sampling scheme.
</p>
</li></ul>



<h3>Useful ancillary functions</h3>


<ul>
<li> <p><code>irt_gen</code> Generate item responses from an IRT model.  Used by
<code>response_gen</code>.
</p>
</li>
<li> <p><code>beta_gen</code> Calculates analytical and numeric regression
coefficients for the background questionnaire responses as functions of the
latent variable. Used by <code>questionnaire_gen</code>
</p>
</li></ul>



<h3>Note</h3>

<p>This package contains vignettes. If you are installing lsasim from GitHub, remember to use 'build_vignettes=TRUE' in your 'remotes::install_github()' call. Afterwards, you can browse the vignettes by issuing 'browseVignettes(&quot;lsasim&quot;)' in your R terminal.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Waldir Leoncio <a href="mailto:w.l.netto@medisin.uio.no">w.l.netto@medisin.uio.no</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Tyler Matta <a href="mailto:tyler.matta@gmail.com">tyler.matta@gmail.com</a>
</p>
</li>
<li><p> Leslie Rutkowski <a href="mailto:leslie.rutkowski@cemo.uio.no">leslie.rutkowski@cemo.uio.no</a>
</p>
</li>
<li><p> David Rutkowski <a href="mailto:david.rutkowski@cemo.uio.no">david.rutkowski@cemo.uio.no</a>
</p>
</li>
<li><p> Yuan-Ling Linda Liaw <a href="mailto:y.l.liaw@cemo.uio.no">y.l.liaw@cemo.uio.no</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Kondwani Kajera Mughogho <a href="mailto:k.k.mughogho@cemo.uio.no">k.k.mughogho@cemo.uio.no</a> [contributor]
</p>
</li>
<li><p> Sinan Yavuz [contributor]
</p>
</li>
<li><p> Paul Bailey [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/tmatta/lsasim/issues">https://github.com/tmatta/lsasim/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.onAttach'>Prints welcome message on package load</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>Prints &quot;This is lsasim &lt;version number&gt;&quot; on package load
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_libname">libname</code></td>
<td>
<p>no idea, but will break devtools::document() if removed</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkgname">pkgname</code></td>
<td>
<p>name of the package</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was adapted from the lavaan package, so credit for it goes to lavaan's creator, Yves Rosseel
</p>


<h3>References</h3>

<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36. URL
http://www.jstatsoft.org/v48/i02/.
</p>

<hr>
<h2 id='anova.lsasimcluster'>Generate an ANOVA table for LSASIM clusters</h2><span id='topic+anova.lsasimcluster'></span>

<h3>Description</h3>

<p>Prints Analysis of Variance table for 'cluster_gen' output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsasimcluster'
anova(object, print = TRUE, calc.se = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.lsasimcluster_+3A_object">object</code></td>
<td>
<p>list output of 'cluster_gen'</p>
</td></tr>
<tr><td><code id="anova.lsasimcluster_+3A_print">print</code></td>
<td>
<p>if 'TRUE', output will be a list containing estimators; if 'FALSE' (default), output are formatted tables of this information</p>
</td></tr>
<tr><td><code id="anova.lsasimcluster_+3A_calc.se">calc.se</code></td>
<td>
<p>if 'TRUE', will try to calculate the standard error of the intreaclass correlation</p>
</td></tr>
<tr><td><code id="anova.lsasimcluster_+3A_...">...</code></td>
<td>
<p>additional objects of the same type (see 'help(&quot;anova&quot;)' for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed ANOVA table or list of parameters
</p>


<h3>Note</h3>

<p>If the rhos for different levels are varied in scale, the generated rho will be less accurate.
</p>


<h3>References</h3>

<p>Snijders, T. A. B., &amp; Bosker, R. J. (1999). Multilevel Analysis. Sage Publications.
</p>

<hr>
<h2 id='attribute_cluster_labels'>Attribute Labels in Hierarchical Structure</h2><span id='topic+attribute_cluster_labels'></span>

<h3>Description</h3>

<p>Attributes cluster and respondent labels in the context of 'cluster_gen'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attribute_cluster_labels(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attribute_cluster_labels_+3A_n">n</code></td>
<td>
<p>numeric vector or list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing appropriate labels for the clusters and their respondents
</p>


<h3>See Also</h3>

<p>cluster_gen
</p>

<hr>
<h2 id='beta_gen'>Generate regression coefficients</h2><span id='topic+beta_gen'></span>

<h3>Description</h3>

<p>Uses the output from questionnaire_gen to generate linear
regression coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_gen(
  data,
  MC = FALSE,
  MC_replications = 100,
  CI = c(0.005, 0.995),
  output_cov = FALSE,
  rename_to_q = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_gen_+3A_data">data</code></td>
<td>
<p>output from the <code>questionnaire_gen</code> function with
<code>full_output = TRUE</code> and <code>theta = TRUE</code></p>
</td></tr>
<tr><td><code id="beta_gen_+3A_mc">MC</code></td>
<td>
<p>if <code>TRUE</code>, performs Monte Carlo simulation to estimate
regression coefficients</p>
</td></tr>
<tr><td><code id="beta_gen_+3A_mc_replications">MC_replications</code></td>
<td>
<p>for <code>MC = TRUE</code>, this represents the number of
Monte Carlo subsamples calculated</p>
</td></tr>
<tr><td><code id="beta_gen_+3A_ci">CI</code></td>
<td>
<p>confidence interval for Monte Carlo simulations</p>
</td></tr>
<tr><td><code id="beta_gen_+3A_output_cov">output_cov</code></td>
<td>
<p>if <code>TRUE</code>, will also output the covariance matrix of
YXW</p>
</td></tr>
<tr><td><code id="beta_gen_+3A_rename_to_q">rename_to_q</code></td>
<td>
<p>if <code>TRUE</code>, renames the variables from &quot;x&quot; and &quot;w&quot; to
&quot;q&quot;</p>
</td></tr>
<tr><td><code id="beta_gen_+3A_verbose">verbose</code></td>
<td>
<p>if 'FALSE', output messages will be suppressed (useful for simulations). Defaults to 'TRUE'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was primarily conceived as a subfunction of
<code>questionnaire_gen</code>, when <code>family = "gaussian"</code>, <code>theta =
  TRUE</code>, and <code>full_output = TRUE</code>. However, it can also be directly
called by the user so they can perform further analysis.
</p>
<p>This function primarily calculates the true regression coefficients
(<code class="reqn">\beta</code>) for the linear influence of the background questionnaire
variables in <code class="reqn">\theta</code>. From a statistical perspective, this
relationship can be modeled as follows, where <code class="reqn">E(\theta | \boldsymbol{X}, \boldsymbol{W})</code> is the expectation of <code class="reqn">\theta</code> given <code class="reqn">\boldsymbol{X} = \{X_1, \ldots, X_P\}</code> and <code class="reqn">\boldsymbol{W} = \{W_1, \ldots, W_Q\}</code>:
</p>
<p style="text-align: center;"><code class="reqn">E(\theta | \boldsymbol{X}, \boldsymbol{W}) = \beta_0 + \sum_{p = 1}^P \beta_p X_p + \sum_{q = 1}^Q \beta_{P + q} W_q</code>
</p>

<p>The regression coefficients are calculated using the true covariance matrix
either provided by the user upon calling of <code>questionnaire_gen</code> or
randomly generated by that function if none was provided. In any case, that
matrix is not sample-dependent, though it should be similar to the one
observed in the generated data (especially for larger samples). One
convenient way to check for this similarity is by running the function with
<code>MC = TRUE</code>, which will generate a numeric estimate; the
<code>MC_replications</code> argument can be then increased to improve the
estimates at a often-noticeable cost in processing time. If <code>MC =
  FALSE</code>, the <code>MC_replications</code> will have no effect on the results. In
any case, each subsample will always have the same size as the original
sample.
</p>
<p>If the background questionnaire contains categorical variables (<code class="reqn">W</code>),
the original covariance matrix cannot be used because it contains the
covariances involving <code class="reqn">Z ~ N(0, 1)</code>, which is the random variable that
gets categorized into <code class="reqn">W</code>. The case where <code class="reqn">W</code> is always binomial is
trivial, but if at least one <code class="reqn">W</code> has more than two categories, the
structure of the covariance matrix changes drastically. In this case, this
function recalculates all covariances between <code class="reqn">\theta</code>, <code class="reqn">X</code> and
each category of <code class="reqn">W</code> using some auxiliary internal functions which rely
on the appropriate distribution (either multivariate normal or truncated
normal). To avoid multicollinearity, the first categories of each <code class="reqn">W</code>
are dropped before the regression coefficients are calculated.
</p>


<h3>Value</h3>

<p>By default, this function will output a vector of the regression
coefficients, including intercept. If <code>MC == TRUE</code>, the output will
instead be a matrix comparing the true regression coefficients obtained
from the covariance matrix with expected values obtained from a Monte Carlo
simulation, complete with 99% confidence interval.
</p>
<p>If <code>output_cov = TRUE</code>, the output will be a list with two elements:
the first one, <code>betas</code>, will contain the same output described in the
previous paragraph. The second one, called <code>vcov_YXW</code>, contains
the covariance matrix of the regression coefficients.
</p>


<h3>Note</h3>

<p>The equation in this page is best formatted in PDF. We recommend issuing 'help(&quot;beta_gen&quot;, help_type = &quot;PDF&quot;)' in your terminal and opening the 'beta_gen.pdf' file generated in your working directly. You may also set 'help_type = &quot;HTML&quot;', but the equations will have degraded formatting.
</p>


<h3>See Also</h3>

<p>questionnaire_gen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- questionnaire_gen(100, family="gaussian", theta = TRUE,
                           full_output = TRUE, n_X = 2, n_W = list(2, 2, 4))
beta_gen(data, MC = TRUE)

</code></pre>

<hr>
<h2 id='block_design'>Assignment of test items to blocks</h2><span id='topic+block_design'></span>

<h3>Description</h3>

<p><code>block_design</code> creates a length-2 list containing: 
</p>

<ul>
<li><p> a matrix that identifies which items correspond to which blocks and
</p>
</li>
<li><p> a table of block descriptive statisics.    
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>block_design(n_blocks = NULL, item_parameters, item_block_matrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_design_+3A_n_blocks">n_blocks</code></td>
<td>
<p>an integer indicating how many blocks to create.</p>
</td></tr>
<tr><td><code id="block_design_+3A_item_parameters">item_parameters</code></td>
<td>
<p>a data frame of item parameters.</p>
</td></tr>
<tr><td><code id="block_design_+3A_item_block_matrix">item_block_matrix</code></td>
<td>
<p>a matrix of indicators to assign items to blocks.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The default <code>item_block_matrix</code> spirals the items across the <code>n_blocks</code> and requires <code>n_blocks</code> &gt;= 3. 
If <code>n_blocks</code> &lt; 3, <code>item_block_matrix</code> must be specified.
</p>
<p>The columns of <code>item_block_matrix</code> represent each block while the rows
represent the total number of items. <code>item_block_matrix[1, 1] = 1</code> indicates
that block 1 contains item 1 while <code>item_block_matrix[1, 2] = 0</code> indicates that
block 2 does not contain item 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>item_param &lt;- data.frame(item = seq(1:25), b = runif(25, -2, 2))
ib_matrix &lt;- matrix(nrow = 25, ncol = 5, byrow = FALSE, 
  c(1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1))
block_design(n_blocks = 5, item_parameters = item_param, item_block_matrix = ib_matrix)
block_design(n_blocks = 5, item_parameters = item_param)

</code></pre>

<hr>
<h2 id='booklet_design'>Assignment of item blocks to test booklets</h2><span id='topic+booklet_design'></span>

<h3>Description</h3>

<p><code>block_design</code> creates a data frame that identifies which items corresponds to which booklets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booklet_design(item_block_assignment, book_design = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="booklet_design_+3A_item_block_assignment">item_block_assignment</code></td>
<td>
<p>a matrix that identifies which items correspond to which block.</p>
</td></tr>
<tr><td><code id="booklet_design_+3A_book_design">book_design</code></td>
<td>
<p>a matrix of indicators to assign blocks to booklets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If using <code>booklet_design</code> in tandem with <code>block_design</code>, <code>item_block_assignment</code>
is the the first element of the returned list of <code>block_design</code>.
</p>
<p>The columns of <code>item_block_assignment</code> represent each block while the rows
represent the number of items in each block.  Becuase the number of items per
block can vary, the number of rows represents the block with the most items. The 
contets of <code>item_block_assignment</code> is the actual item numbers. The remainer of 
shorter blocks are filled with zeros.    
</p>
<p>The columns of <code>book_design</code> represent each book while the rows
represent each block.
</p>
<p>The default <code>book_design</code> assigns two blocks to every booklet in a spiral design.
The number of default booklets is equal to the number of blocks and must be &gt;= 3. 
If <code>ncol(item_block_assignment)</code> &lt; 3, <code>book_design</code> must be specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i_blk_mat &lt;- matrix(seq(1:40), ncol = 5) 
blk_book &lt;- matrix(c(1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1,
                     0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0), 
                     ncol = 5, byrow = TRUE)
booklet_design(item_block_assignment = i_blk_mat, book_design = blk_book)
booklet_design(item_block_assignment = i_blk_mat)

</code></pre>

<hr>
<h2 id='booklet_sample'>Assignment of test booklets to test takers</h2><span id='topic+booklet_sample'></span>

<h3>Description</h3>

<p><code>booklet_sample</code> randomly assigns test booklets to test takers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booklet_sample(
  n_subj,
  book_item_design,
  book_prob = NULL,
  resample = FALSE,
  e = 0.1,
  iter = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="booklet_sample_+3A_n_subj">n_subj</code></td>
<td>
<p>an integer, the number of subjects (test takers).</p>
</td></tr>
<tr><td><code id="booklet_sample_+3A_book_item_design">book_item_design</code></td>
<td>
<p>a data frame containing the items that belong to each 
booklet with booklets as columns and booklet item numbers as rows.  See 'Details'.</p>
</td></tr>
<tr><td><code id="booklet_sample_+3A_book_prob">book_prob</code></td>
<td>
<p>a vector of probability weights for obtaining the booklets being sampled.
The default equally weights all books.</p>
</td></tr>
<tr><td><code id="booklet_sample_+3A_resample">resample</code></td>
<td>
<p>logical indicating if booklets should be re-sampled to minimize differences.
Can only be used when <code>book_prob = NULL</code>.</p>
</td></tr>
<tr><td><code id="booklet_sample_+3A_e">e</code></td>
<td>
<p>a number between 0 and 1 exclusive, re-sampling stopping criteria, 
the difference between the most sampled and least sampled booklets.</p>
</td></tr>
<tr><td><code id="booklet_sample_+3A_iter">iter</code></td>
<td>
<p>an integer defining the number of iterations to reach e.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If using <code>booklet_sample</code> in tandem with <code>booklet_design</code>, <code>book_item_design</code>
is the the first element of the returned list of <code>block_design</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it_bk &lt;- matrix(c(1, 2, 1, 4, 5, 4, 7, 8, 7, 10, 3, 10, 2, 6, 3, 5, 9, 6, 8, 0, 9), 
           ncol = 3, byrow = TRUE)
booklet_sample(n_subj = 10, book_item_design = it_bk, book_prob = c(.2, .5, .3))

</code></pre>

<hr>
<h2 id='brr'>Generate replicates of a dataset using Balanced Repeated Replication</h2><span id='topic+brr'></span>

<h3>Description</h3>

<p>Generate replicates of a dataset using Balanced Repeated Replication
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brr(
  data,
  k = 0,
  pseudo_strata = ceiling(nrow(data)/2),
  reps = NULL,
  max_reps = 80,
  weight_cols = "none",
  id_col = 1,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brr_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="brr_+3A_k">k</code></td>
<td>
<p>deflating weight factor. <code class="reqn">0 \leq k \leq 1</code>.</p>
</td></tr>
<tr><td><code id="brr_+3A_pseudo_strata">pseudo_strata</code></td>
<td>
<p>number of pseudo-strata</p>
</td></tr>
<tr><td><code id="brr_+3A_reps">reps</code></td>
<td>
<p>number of replicates</p>
</td></tr>
<tr><td><code id="brr_+3A_max_reps">max_reps</code></td>
<td>
<p>maximum number of replicates (only functional if 'reps = NULL')</p>
</td></tr>
<tr><td><code id="brr_+3A_weight_cols">weight_cols</code></td>
<td>
<p>vector of weight columns</p>
</td></tr>
<tr><td><code id="brr_+3A_id_col">id_col</code></td>
<td>
<p>number of column in dataset containing subject IDs. Set 0 to use the row names as ID</p>
</td></tr>
<tr><td><code id="brr_+3A_drop">drop</code></td>
<td>
<p>if 'TRUE', the observation that will not be part of the subsample is dropped from the dataset. Otherwise, it stays in the dataset but a new weight column is created to differentiate the selected observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing all the BRR replicates of 'data'
</p>


<h3>Note</h3>

<p>PISA uses the BRR Fay method with <code class="reqn">k = 0.5</code>.
</p>


<h3>References</h3>

<p>OECD (2015). Pisa Data Analysis Manual.
Adams, R., &amp; Wu, M. (2002). PISA 2000 Technical Report. Paris: Organisation for Economic Co-operation and Development (OECD).
Rust, K. F., &amp; Rao, J. N. K. (1996). Variance estimation for complex surveys using replication techniques. Statistical methods in medical research, 5(3), 283-310.
</p>


<h3>See Also</h3>

<p>jackknife
</p>

<hr>
<h2 id='calc_n_tilde'>Calculate ñ</h2><span id='topic+calc_n_tilde'></span>

<h3>Description</h3>

<p>Calculates n tilde
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_n_tilde(M, N, n_j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_n_tilde_+3A_m">M</code></td>
<td>
<p>total number of population (i.e., sum of n_j over all j)</p>
</td></tr>
<tr><td><code id="calc_n_tilde_+3A_n">N</code></td>
<td>
<p>number of each class j</p>
</td></tr>
<tr><td><code id="calc_n_tilde_+3A_n_j">n_j</code></td>
<td>
<p>vector with size of each class j</p>
</td></tr>
</table>


<h3>References</h3>

<p>Snijders, T. A. B., &amp; Bosker, R. J. (1999). Multilevel Analysis. Sage Publications.
</p>


<h3>See Also</h3>

<p>?lsasim:::summary.lsasimcluster
</p>

<hr>
<h2 id='calc_replicate_weights'>Calculate replicate weights and summary statistics</h2><span id='topic+calc_replicate_weights'></span>

<h3>Description</h3>

<p>Takes the output of 'cluster_gen' to calculate the replicate weights as well as some summary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_replicate_weights(data, method, k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_replicate_weights_+3A_data">data</code></td>
<td>
<p>list of background questionnaire data (typically generated by 'cluster_gen')</p>
</td></tr>
<tr><td><code id="calc_replicate_weights_+3A_method">method</code></td>
<td>
<p>replication method. Can be &quot;Jackknife&quot;, &quot;BRR&quot; or &quot;BRR Fay&quot;</p>
</td></tr>
<tr><td><code id="calc_replicate_weights_+3A_k">k</code></td>
<td>
<p>deflating weight factor (used only when 'method = &quot;BRR Fay&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Replicate weights can be calculated using the Jackknife for unstratified two-stage sample designs or Balanced Repeated Replication (BRR) with or without Fay's modification.
According to OECD (2015), PISA uses the Fay method with a factor of 0.5. This is why 'k = .5' by default.
</p>


<h3>Value</h3>

<p>list with data and, if requeted, some statistics
</p>


<h3>Note</h3>

<p>This function is essentially a big wrapper for 'replicate_var', applying that function on each element of an output of 'cluster_gen'.
</p>


<h3>References</h3>

<p>OECD (2015). Pisa Data Analysis Manual.
Rust, K. F., &amp; Rao, J. N. K. (1996). Variance estimation for complex surveys using replication techniques. Statistical methods in medical research, 5(3), 283-310.
</p>


<h3>See Also</h3>

<p>cluster_gen jackknife, jackknife_var
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- cluster_gen(c(3, 50))
calc_replicate_weights(data, "Jackknife")
calc_replicate_weights(data, "BRR")
calc_replicate_weights(data, "BRR Fay")
</code></pre>

<hr>
<h2 id='calc_se_rho'>Calculate Standard Error of Intraclass Correlation</h2><span id='topic+calc_se_rho'></span>

<h3>Description</h3>

<p>Calculate Standard Error of Intraclass Correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_se_rho(rho, n_j, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_se_rho_+3A_rho">rho</code></td>
<td>
<p>intraclass correlation</p>
</td></tr>
<tr><td><code id="calc_se_rho_+3A_n_j">n_j</code></td>
<td>
<p>number of elements in class j</p>
</td></tr>
<tr><td><code id="calc_se_rho_+3A_n">N</code></td>
<td>
<p>number of classes j</p>
</td></tr>
</table>


<h3>References</h3>

<p>Snijders, T. A. B., &amp; Bosker, R. J. (1999). Multilevel Analysis. Sage Publications.
</p>


<h3>See Also</h3>

<p>anova.lsasimcluster
</p>

<hr>
<h2 id='calc_var_between'>Calculate variance between classes</h2><span id='topic+calc_var_between'></span>

<h3>Description</h3>

<p>Calculate variance between classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_var_between(n_j, y_bar_j, y_bar, n_tilde, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_var_between_+3A_n_j">n_j</code></td>
<td>
<p>number of elements in class j</p>
</td></tr>
<tr><td><code id="calc_var_between_+3A_y_bar_j">y_bar_j</code></td>
<td>
<p>mean of variable of interest per class j</p>
</td></tr>
<tr><td><code id="calc_var_between_+3A_y_bar">y_bar</code></td>
<td>
<p>mean of variable of interest across classes</p>
</td></tr>
<tr><td><code id="calc_var_between_+3A_n_tilde">n_tilde</code></td>
<td>
<p>function of the variance of n_N, M and N. See documentation and code of <code>lsasim:::summary.lsasimcluster</code> for details</p>
</td></tr>
<tr><td><code id="calc_var_between_+3A_n">N</code></td>
<td>
<p>number of classes j</p>
</td></tr>
</table>


<h3>References</h3>

<p>Snijders, T. A. B., &amp; Bosker, R. J. (1999). Multilevel Analysis. Sage Publications.
</p>


<h3>See Also</h3>

<p>anova.lsasimcluster
</p>

<hr>
<h2 id='calc_var_tot'>Calculate the total variance</h2><span id='topic+calc_var_tot'></span>

<h3>Description</h3>

<p>Calculate the total variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_var_tot(M, N, n_tilde, s2_within, s2_between)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_var_tot_+3A_m">M</code></td>
<td>
<p>total sample size</p>
</td></tr>
<tr><td><code id="calc_var_tot_+3A_n">N</code></td>
<td>
<p>number of classes j</p>
</td></tr>
<tr><td><code id="calc_var_tot_+3A_n_tilde">n_tilde</code></td>
<td>
<p>function of the variance of n_N, M and N. See documentation and code of <code>lsasim:::summary.lsasimcluster</code> for details</p>
</td></tr>
<tr><td><code id="calc_var_tot_+3A_s2_within">s2_within</code></td>
<td>
<p>Within-class variance</p>
</td></tr>
<tr><td><code id="calc_var_tot_+3A_s2_between">s2_between</code></td>
<td>
<p>Between-class variance</p>
</td></tr>
</table>


<h3>References</h3>

<p>Snijders, T. A. B., &amp; Bosker, R. J. (1999). Multilevel Analysis. Sage Publications.
</p>


<h3>See Also</h3>

<p>anova.lsasimcluster
</p>

<hr>
<h2 id='calc_var_within'>Calculate variance within classes</h2><span id='topic+calc_var_within'></span>

<h3>Description</h3>

<p>Calculate variance within classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_var_within(n_j, s2_j, M, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_var_within_+3A_n_j">n_j</code></td>
<td>
<p>number of elements in class j</p>
</td></tr>
<tr><td><code id="calc_var_within_+3A_s2_j">s2_j</code></td>
<td>
<p>variance of all elements in class j</p>
</td></tr>
<tr><td><code id="calc_var_within_+3A_m">M</code></td>
<td>
<p>total sample size</p>
</td></tr>
<tr><td><code id="calc_var_within_+3A_n">N</code></td>
<td>
<p>number of classes j</p>
</td></tr>
</table>


<h3>References</h3>

<p>Snijders, T. A. B., &amp; Bosker, R. J. (1999). Multilevel Analysis. Sage Publications.
</p>


<h3>See Also</h3>

<p>anova.lsasimcluster
</p>

<hr>
<h2 id='check_condition'>Check if an error condition is satisfied</h2><span id='topic+check_condition'></span>

<h3>Description</h3>

<p>Check if an error condition is satisfied
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_condition(condition, message, fatal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_condition_+3A_condition">condition</code></td>
<td>
<p>logical test which if <code>TRUE</code> will cause the function to
return an error message</p>
</td></tr>
<tr><td><code id="check_condition_+3A_message">message</code></td>
<td>
<p>error message to be displayed if condition is met.</p>
</td></tr>
<tr><td><code id="check_condition_+3A_fatal">fatal</code></td>
<td>
<p>if <code>TRUE</code>, error message is fatal, i.e., it will abort the
parent function which called <code>check_condition</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='check_ignored_parameters'>Checks if provided parameters are ignored</h2><span id='topic+check_ignored_parameters'></span>

<h3>Description</h3>

<p>Internal function to match non-null parameters with a vector of ignored
parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ignored_parameters(provided_parameters, ignored_parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ignored_parameters_+3A_provided_parameters">provided_parameters</code></td>
<td>
<p>vector of provided parameters</p>
</td></tr>
<tr><td><code id="check_ignored_parameters_+3A_ignored_parameters">ignored_parameters</code></td>
<td>
<p>vector of ignored parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Warning message listing ignored parameters
</p>

<hr>
<h2 id='check_n_N_class'>Check class of n or N</h2><span id='topic+check_n_N_class'></span>

<h3>Description</h3>

<p>Check the class of an object (usually n and N from 'cluster_gen')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_n_N_class(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_n_N_class_+3A_x">x</code></td>
<td>
<p>either n or N from 'cluster_gen'</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is primarily used as a way to simplify the classification of n and N in the 'cluster_gen' function.
</p>


<h3>See Also</h3>

<p>cluster_gen
</p>

<hr>
<h2 id='check_valid_structure'>Check if List is Valid</h2><span id='topic+check_valid_structure'></span>

<h3>Description</h3>

<p>Checks if a list has a proper structure to be transformed into a hierarchical structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_valid_structure(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_valid_structure_+3A_n">n</code></td>
<td>
<p>list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Error if the structure is improper. Otherwise, there's no output.
</p>


<h3>See Also</h3>

<p>check_condition
</p>

<hr>
<h2 id='cluster_gen'>Generate cluster sample</h2><span id='topic+cluster_gen'></span>

<h3>Description</h3>

<p>Generate cluster sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_gen(
  n,
  N = 1,
  cluster_labels = NULL,
  resp_labels = NULL,
  cat_prop = NULL,
  n_X = NULL,
  n_W = NULL,
  c_mean = NULL,
  sigma = NULL,
  cor_matrix = NULL,
  separate_questionnaires = TRUE,
  collapse = "none",
  sum_pop = sapply(N, sum),
  calc_weights = TRUE,
  sampling_method = "mixed",
  rho = NULL,
  theta = FALSE,
  verbose = TRUE,
  print_pop_structure = verbose,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_gen_+3A_n">n</code></td>
<td>
<p>numeric vector with the number of sampled observations (clusters or subjects) on each level</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_n">N</code></td>
<td>
<p>list of numeric vector with the population size of each *sampled* cluster element on each level</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_cluster_labels">cluster_labels</code></td>
<td>
<p>character vector with the names of each cluster level</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_resp_labels">resp_labels</code></td>
<td>
<p>character vector with the names of the questionnaire respondents on each level</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_cat_prop">cat_prop</code></td>
<td>
<p>list of cumulative proportions for each item. If <code>theta
= TRUE</code>, the first element of <code>cat_prop</code> must be a scalar 1, which
corresponds to the <code>theta</code>.</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_n_x">n_X</code></td>
<td>
<p>list of 'n_X' per cluster level</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_n_w">n_W</code></td>
<td>
<p>list of 'n_W' per cluster level</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_c_mean">c_mean</code></td>
<td>
<p>vector of means for the continuous variables or list of vectors for the continuous variables for each level. Defaults to 0, but can change if 'rho' is set.</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_sigma">sigma</code></td>
<td>
<p>vector of standard deviations for the continuous variables or list of vectors for the continuous variables for each level. Defaults to 1, but can change if 'rho' is set.</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_cor_matrix">cor_matrix</code></td>
<td>
<p>Correlation matrix between all variables (except weights). By default, correlations are randomly generated.</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_separate_questionnaires">separate_questionnaires</code></td>
<td>
<p>if 'TRUE', each level will have its own questionnaire</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_collapse">collapse</code></td>
<td>
<p>if 'TRUE', function output contains only one data frame with all answers. It can also be &quot;none&quot;, &quot;partial&quot; and &quot;full&quot; for finer control on 3+ levels</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_sum_pop">sum_pop</code></td>
<td>
<p>total population at each level (sampled or not)</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_calc_weights">calc_weights</code></td>
<td>
<p>if 'TRUE', sampling weights are calculated</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_sampling_method">sampling_method</code></td>
<td>
<p>can be &quot;SRS&quot; for Simple Random Sampling or &quot;PPS&quot; for Probabilities Proportional to Size</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_rho">rho</code></td>
<td>
<p>estimated intraclass correlation</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_theta">theta</code></td>
<td>
<p>if <code>TRUE</code>, the first continuous variable will be labeled
'theta'. Otherwise, it will be labeled 'q1'.</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_verbose">verbose</code></td>
<td>
<p>if 'TRUE', prints output messages</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_print_pop_structure">print_pop_structure</code></td>
<td>
<p>if 'TRUE', prints the population hierarchical structure (as long as it differs from the sample structure)</p>
</td></tr>
<tr><td><code id="cluster_gen_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to 'questionnaire_gen()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies heavily in two subfunctions&mdash;'cluster_gen_separate' and 'cluster_gen_together'&mdash;which can be called independently. This does not make 'cluster_gen' a simple wrapper function, as it performs several operations prior to calling its subfunctions, such as randomly generating 'n_X' and 'n_W' if they are not determined by user.
'n' can have unitary length, in which case all clusters will have the same size.
'N' is *not* the population size across all elements of a level, but the population size for each element of one level.
Regarding the additional parameters to be passed to 'questionnaire_gen()', they can be passed either in the same format as 'questionnaire_gen()' or as more complex objects that contain information for each cluster level.
</p>


<h3>Value</h3>

<p>list with background questionnaire data, grouped by level or not
</p>


<h3>Note</h3>

<p>For the purpose of this function, levels are counted starting from the top nesting/clustering level. This means that, for example, schools are the first cluster level, classes are the second, and students are the third and final level. This behavior can be customized by naming the 'n' argument or providing custom labels in 'cluster_labels' and 'resp_labels'.
</p>
<p>Manually setting both 'c_mean' and 'rho', while possible, may yield unexpected results due to how those parameters work together. A high intraclass correlation ('rho') teoretically means that each group will end up with different means so they can be better separated. If 'c_mean' is left untouched (i.e., at the default value of zero), then 'c_mean' will freely change between clusters in order to result in the expected intraclass correlation. For large samples, 'c_mean' will in practice correspond to the grand mean across that level, as the means of each element will be different no matter the sample size.
</p>
<p>Moreover, if 'c_mean', 'sigma' and 'rho' are passed to the function, the means will be recalculated as a function of the other two parameters. The three are interdependent and cannot be passed simultaneously.
</p>
<p>If in addition to 'rho' the user also determine different means for each level, the only way the math can check out is if the variance in each group becomes very high. For examples of this scenario and the one described in the previous paragraph, check out the final section of this page.
</p>
<p>The 'ranges()' function should always be put inside a 'list()',as putting it inside a vector ('c()') will cancel its effect. For more details, please read the documentation of the 'ranges()' function.
</p>
<p>The only arguments that can be used to label each level are 'n', 'N', 'cluster_labels' and 'resp_labels'. Labeling other arguments such as 'c_mean' and 'cat_prop' has no effect on the final results, but it is a recommended way for users to keep track of which value corresponds to which element in a complex hierarchical structure.
</p>
<p>One of the extra arguments that can be passed by this function is 'family'.
If <code>family == "gaussian"</code>, the questionnaire will be generated
assuming that all the variables are jointly-distributed as a multivariate
normal. The default behavior is <code>family == NULL</code>, where the data is
generated using the polychoric correlation matrix, with no distributional
assumptions.
</p>


<h3>See Also</h3>

<p>cluster_estimates cluster_gen_separate cluster_gen_together questionnaire_gen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple structure of 3 schools with 5 students each
cluster_gen(c(3, 5))

# Complex structure of 2 schools with different number of students,
# sampling weights and custom number of questions
n &lt;- list(3, c(20, 15, 25))
N &lt;- list(5, c(200, 500, 400, 100, 100))
cluster_gen(n, N, n_X = 5, n_W = 2)

# Condensing the output
set.seed(0); cluster_gen(c(2, 4))
set.seed(0); cluster_gen(c(2, 4), collapse=TRUE) # same, but in one dataset

# Condensing the output: 3 levels
str(cluster_gen(c(2, 2, 1), collapse="none"))
str(cluster_gen(c(2, 2, 1), collapse="partial"))
str(cluster_gen(c(2, 2, 1), collapse="full"))

# Controlling the intra-class correlation and the grand mean
x &lt;- cluster_gen(c(5, 1000), rho = .9, n_X = 2, n_W = 0, c_mean = 10)
sapply(1:5, function(s) mean(x$school[[s]]$q1))  # means per school != 10
mean(sapply(1:5, function(s) mean(x$school[[s]]$q1))) # closer to c_mean

# Making the intraclass variance explode by forcing "incompatible" rho and c_mean
x &lt;- cluster_gen(c(5, 1000), rho = .5, n_X = 2, n_W = 0, c_mean = 1:5)
anova(x)
</code></pre>

<hr>
<h2 id='cluster_gen_separate'>Generate cluster samples with individual questionnaires</h2><span id='topic+cluster_gen_separate'></span>

<h3>Description</h3>

<p>This is a subfunction of 'cluster_gen' that performs cluster sampling, with the twist that each cluster level has its own questionnaire.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_gen_separate(
  n_levels,
  n,
  N,
  sum_pop,
  calc_weights,
  sampling_method,
  cluster_labels,
  resp_labels,
  collapse,
  n_X,
  n_W,
  cat_prop,
  c_mean,
  sigma,
  cor_matrix,
  rho,
  theta,
  whitelist,
  verbose,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_gen_separate_+3A_n_levels">n_levels</code></td>
<td>
<p>number of cluster levels</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_n">n</code></td>
<td>
<p>numeric vector with the number of sampled observations (clusters or subjects) on each level</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_n">N</code></td>
<td>
<p>list of numeric vector with the population size of each *sampled* cluster element on each level</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_sum_pop">sum_pop</code></td>
<td>
<p>total population at the lowest level (sampled or not)</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_calc_weights">calc_weights</code></td>
<td>
<p>if 'TRUE', sampling weights are calculated</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_sampling_method">sampling_method</code></td>
<td>
<p>can be &quot;SRS&quot; for Simple Random Sampling or &quot;PPS&quot; for Probabilities Proportional to Size, &quot;mixed&quot; to use SRS for students and PPS otherwise or a vector with the sampling method for each level</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_cluster_labels">cluster_labels</code></td>
<td>
<p>character vector with the names of each cluster level</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_resp_labels">resp_labels</code></td>
<td>
<p>character vector with the names of the questionnaire respondents on each level</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_collapse">collapse</code></td>
<td>
<p>if 'TRUE', function output contains only one data frame with all answers</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_n_x">n_X</code></td>
<td>
<p>list of 'n_X' per cluster level</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_n_w">n_W</code></td>
<td>
<p>list of 'n_W' per cluster level</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_cat_prop">cat_prop</code></td>
<td>
<p>list of cumulative proportions for each item. If <code>theta
= TRUE</code>, the first element of <code>cat_prop</code> must be a scalar 1, which
corresponds to the <code>theta</code>.</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_c_mean">c_mean</code></td>
<td>
<p>vector of means for the continuous variables or list of vectors for the continuous variables for each level</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_sigma">sigma</code></td>
<td>
<p>vector of standard deviations for the continuous variables or list of vectors for the continuous variables for each level</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_cor_matrix">cor_matrix</code></td>
<td>
<p>Correlation matrix between all variables (except weights)</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_rho">rho</code></td>
<td>
<p>estimated intraclass correlation</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_theta">theta</code></td>
<td>
<p>if <code>TRUE</code>, the first continuous variable will be labeled
'theta'. Otherwise, it will be labeled 'q1'.</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_whitelist">whitelist</code></td>
<td>
<p>used when 'n = select(...)', determines which PSUs get to generate questionnaires</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_verbose">verbose</code></td>
<td>
<p>if 'TRUE', prints output messages</p>
</td></tr>
<tr><td><code id="cluster_gen_separate_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to 'questionnaire_gen()'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>cluster_gen cluster_gen_together
</p>

<hr>
<h2 id='cluster_gen_together'>Generate cluster samples with lowest-level questionnaires</h2><span id='topic+cluster_gen_together'></span>

<h3>Description</h3>

<p>This is a subfunction of 'cluster_gen' that performs cluster sampling where only the lowest-level individuals (e.g. students) fill out questionnaires.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_gen_together(
  n_levels,
  n,
  N,
  sum_pop,
  calc_weights,
  sampling_method,
  cluster_labels,
  resp_labels,
  collapse,
  n_X,
  n_W,
  cat_prop,
  c_mean,
  sigma,
  cor_matrix,
  rho,
  verbose,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_gen_together_+3A_n_levels">n_levels</code></td>
<td>
<p>number of cluster levels</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_n">n</code></td>
<td>
<p>numeric vector with the number of sampled observations (clusters or subjects) on each level</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_n">N</code></td>
<td>
<p>list of numeric vector with the population size of each *sampled* cluster element on each level</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_sum_pop">sum_pop</code></td>
<td>
<p>total population at the lowest level (sampled or not)</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_calc_weights">calc_weights</code></td>
<td>
<p>if 'TRUE', sampling weights are calculated</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_sampling_method">sampling_method</code></td>
<td>
<p>can be &quot;SRS&quot; for Simple Random Sampling or &quot;PPS&quot; for Probabilities Proportional to Size</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_cluster_labels">cluster_labels</code></td>
<td>
<p>character vector with the names of each cluster level</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_resp_labels">resp_labels</code></td>
<td>
<p>character vector with the names of the questionnaire respondents on each level</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_collapse">collapse</code></td>
<td>
<p>if 'TRUE', function output contains only one data frame with all answers</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_n_x">n_X</code></td>
<td>
<p>list of 'n_X' per cluster level</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_n_w">n_W</code></td>
<td>
<p>list of 'n_W' per cluster level</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_cat_prop">cat_prop</code></td>
<td>
<p>list of cumulative proportions for each item. If <code>theta
= TRUE</code>, the first element of <code>cat_prop</code> must be a scalar 1, which
corresponds to the <code>theta</code>.</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_c_mean">c_mean</code></td>
<td>
<p>vector of means for the continuous variables or list of vectors for the continuous variables for each level</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_sigma">sigma</code></td>
<td>
<p>vector of standard deviations for the continuous variables or list of vectors for the continuous variables for each level</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_cor_matrix">cor_matrix</code></td>
<td>
<p>correlation matrix or list of correlation matrices per PSU</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_rho">rho</code></td>
<td>
<p>intraclass correlation (scalar, vector or list)</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_verbose">verbose</code></td>
<td>
<p>if 'TRUE', prints output messages</p>
</td></tr>
<tr><td><code id="cluster_gen_together_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to 'questionnaire_gen()'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>cluster_gen cluster_gen_separate cluster_gen_together
</p>

<hr>
<h2 id='cluster_message'>Print messages about clusters</h2><span id='topic+cluster_message'></span>

<h3>Description</h3>

<p>Prints messages about the cluster scheme before generating questionnaire responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_message(
  n_obs,
  resp_labels,
  cluster_labels,
  n_levels,
  separate_questionnaires,
  type,
  detail = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_message_+3A_n_obs">n_obs</code></td>
<td>
<p>list with the number of elements per level</p>
</td></tr>
<tr><td><code id="cluster_message_+3A_resp_labels">resp_labels</code></td>
<td>
<p>character vector with the names of the questionnaire respondents on each level</p>
</td></tr>
<tr><td><code id="cluster_message_+3A_cluster_labels">cluster_labels</code></td>
<td>
<p>character vector with the names of each cluster level</p>
</td></tr>
<tr><td><code id="cluster_message_+3A_n_levels">n_levels</code></td>
<td>
<p>number of cluster levels</p>
</td></tr>
<tr><td><code id="cluster_message_+3A_separate_questionnaires">separate_questionnaires</code></td>
<td>
<p>if 'TRUE', each level will have its own questionnaire</p>
</td></tr>
<tr><td><code id="cluster_message_+3A_type">type</code></td>
<td>
<p>Type of top-level message</p>
</td></tr>
<tr><td><code id="cluster_message_+3A_detail">detail</code></td>
<td>
<p>if 'TRUE', prints further details about each level composition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Messages.
</p>

<hr>
<h2 id='convert_vector_to_list'>Convert Vector to Expanded List</h2><span id='topic+convert_vector_to_list'></span>

<h3>Description</h3>

<p>Converts a vector to list where each element is replicated a certain number of times depending on the previous vector. Also work for ranged lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_vector_to_list(x, x_max = x, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_vector_to_list_+3A_x">x</code></td>
<td>
<p>vector or ranged list to be converted</p>
</td></tr>
<tr><td><code id="convert_vector_to_list_+3A_x_max">x_max</code></td>
<td>
<p>reference vector or ranged list with max values for x</p>
</td></tr>
<tr><td><code id="convert_vector_to_list_+3A_verbose">verbose</code></td>
<td>
<p>if &lsquo;TRUE', sends messages to user about what&rsquo;s being done</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expanded/replicated version of x
</p>

<hr>
<h2 id='cor_gen'>Generation of random correlation matrix</h2><span id='topic+cor_gen'></span>

<h3>Description</h3>

<p>Creates a random correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_gen(n_var, cov_bounds = c(-1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_gen_+3A_n_var">n_var</code></td>
<td>
<p>integer number of variables.</p>
</td></tr>
<tr><td><code id="cor_gen_+3A_cov_bounds">cov_bounds</code></td>
<td>
<p>a vector containing the bounds of the covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result from <code>cor_gen</code> can be used directly with the <code>cor_matrix</code>
argument of <code>questionnaire_gen</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor_gen(n_var = 10)

</code></pre>

<hr>
<h2 id='cov_gen'>Generation of covariance matrices</h2><span id='topic+cov_gen'></span>

<h3>Description</h3>

<p>Construct covariance matrices for the generation of simulated test data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_gen(pr_grp_1, n_fac, n_ind, Lambda = 0:1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_gen_+3A_pr_grp_1">pr_grp_1</code></td>
<td>
<p>proportion of observations in group 1. Can be a scalar or a
vector</p>
</td></tr>
<tr><td><code id="cov_gen_+3A_n_fac">n_fac</code></td>
<td>
<p>number of factors</p>
</td></tr>
<tr><td><code id="cov_gen_+3A_n_ind">n_ind</code></td>
<td>
<p>number of indicators per factor</p>
</td></tr>
<tr><td><code id="cov_gen_+3A_lambda">Lambda</code></td>
<td>
<p>either a matrix containing the factor loadings or a vector
containing the lower and upper limits for a randomly-generated Lambda
matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three covariance matrices: vcov_yxw, vcov_yxz and
vcov_yfz
</p>


<h3>Examples</h3>

<pre><code class='language-R'> vcov &lt;- cov_gen(pr_grp_1 = .5, n_fac = 3, n_ind = 2)
 str(vcov)
</code></pre>

<hr>
<h2 id='cov_yfz_gen'>Generate latent regression covariance matrix</h2><span id='topic+cov_yfz_gen'></span>

<h3>Description</h3>

<p>Generates covariance matrix between Y, F and Z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_yfz_gen(n_ind, n_fac, Phi, n_z, sd_z, w_names, pr_grp_1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_yfz_gen_+3A_n_ind">n_ind</code></td>
<td>
<p>number of indicator variables</p>
</td></tr>
<tr><td><code id="cov_yfz_gen_+3A_n_fac">n_fac</code></td>
<td>
<p>number of factors</p>
</td></tr>
<tr><td><code id="cov_yfz_gen_+3A_phi">Phi</code></td>
<td>
<p>latent regression correlation matrix</p>
</td></tr>
<tr><td><code id="cov_yfz_gen_+3A_n_z">n_z</code></td>
<td>
<p>number of background variables</p>
</td></tr>
<tr><td><code id="cov_yfz_gen_+3A_sd_z">sd_z</code></td>
<td>
<p>standard deviation of background variables</p>
</td></tr>
<tr><td><code id="cov_yfz_gen_+3A_w_names">w_names</code></td>
<td>
<p>names of W variables</p>
</td></tr>
<tr><td><code id="cov_yfz_gen_+3A_pr_grp_1">pr_grp_1</code></td>
<td>
<p>scalar or list of proportions of the first group</p>
</td></tr>
</table>

<hr>
<h2 id='cov_yxw_gen'>Setup full YXW covariance matrix</h2><span id='topic+cov_yxw_gen'></span>

<h3>Description</h3>

<p>Setup full YXW covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_yxw_gen(n_ind, n_z, Phi, n_fac, Lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_yxw_gen_+3A_n_ind">n_ind</code></td>
<td>
<p>number of indicator variables</p>
</td></tr>
<tr><td><code id="cov_yxw_gen_+3A_n_z">n_z</code></td>
<td>
<p>number of background variables</p>
</td></tr>
<tr><td><code id="cov_yxw_gen_+3A_phi">Phi</code></td>
<td>
<p>latent regression correlation matrix</p>
</td></tr>
<tr><td><code id="cov_yxw_gen_+3A_n_fac">n_fac</code></td>
<td>
<p>number of factor variables</p>
</td></tr>
<tr><td><code id="cov_yxw_gen_+3A_lambda">Lambda</code></td>
<td>
<p>matrix containing the factor loadings</p>
</td></tr>
</table>

<hr>
<h2 id='cov_yxz_gen'>Generate analytical covariance matrix</h2><span id='topic+cov_yxz_gen'></span>

<h3>Description</h3>

<p>Generate analytical covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_yxz_gen(vcov_yxw, w_names, Phi, pr_grp_1, n_ind, n_fac, Lambda, var_z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_yxz_gen_+3A_vcov_yxw">vcov_yxw</code></td>
<td>
<p>covariance matrix between Y, X and W</p>
</td></tr>
<tr><td><code id="cov_yxz_gen_+3A_w_names">w_names</code></td>
<td>
<p>name of the W variables</p>
</td></tr>
<tr><td><code id="cov_yxz_gen_+3A_phi">Phi</code></td>
<td>
<p>latent regression correlation matrix</p>
</td></tr>
<tr><td><code id="cov_yxz_gen_+3A_pr_grp_1">pr_grp_1</code></td>
<td>
<p>scalar or list of proportions of the first group</p>
</td></tr>
<tr><td><code id="cov_yxz_gen_+3A_n_ind">n_ind</code></td>
<td>
<p>number of indicator variables</p>
</td></tr>
<tr><td><code id="cov_yxz_gen_+3A_n_fac">n_fac</code></td>
<td>
<p>number of factors</p>
</td></tr>
<tr><td><code id="cov_yxz_gen_+3A_lambda">Lambda</code></td>
<td>
<p>matrix containing the factor loadings</p>
</td></tr>
<tr><td><code id="cov_yxz_gen_+3A_var_z">var_z</code></td>
<td>
<p>vector of variances of the background variables</p>
</td></tr>
</table>

<hr>
<h2 id='customize_summary'>Customize Summary</h2><span id='topic+customize_summary'></span>

<h3>Description</h3>

<p>Adds standard deviations and removes quantiles from a 'summary()' output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>customize_summary(df_summary, df, numeric_cols, factor_cols, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="customize_summary_+3A_df_summary">df_summary</code></td>
<td>
<p>dataframe containing summary statistics</p>
</td></tr>
<tr><td><code id="customize_summary_+3A_df">df</code></td>
<td>
<p>original data frame</p>
</td></tr>
<tr><td><code id="customize_summary_+3A_numeric_cols">numeric_cols</code></td>
<td>
<p>indices of the numeric columns</p>
</td></tr>
<tr><td><code id="customize_summary_+3A_factor_cols">factor_cols</code></td>
<td>
<p>indices of the factor columns</p>
</td></tr>
<tr><td><code id="customize_summary_+3A_digits">digits</code></td>
<td>
<p>controls the number of digits in the output</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>summary ?lsasim:::summary.lsasimcluster
</p>

<hr>
<h2 id='draw_cluster_structure'>Draw Cluster Structure</h2><span id='topic+draw_cluster_structure'></span>

<h3>Description</h3>

<p>This function creates a visual representation of the hierarchical structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_cluster_structure(n, labels = NULL, resp = NULL, output = "tree")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_cluster_structure_+3A_n">n</code></td>
<td>
<p>same from cluster_gen</p>
</td></tr>
<tr><td><code id="draw_cluster_structure_+3A_labels">labels</code></td>
<td>
<p>corresponds to cluster_labels from cluster_gen</p>
</td></tr>
<tr><td><code id="draw_cluster_structure_+3A_resp">resp</code></td>
<td>
<p>corresponds to resp_labels from cluster_gen</p>
</td></tr>
<tr><td><code id="draw_cluster_structure_+3A_output">output</code></td>
<td>
<p>&quot;tree&quot; draws a tree-like structure on the console, &quot;text&quot; prints the structure as a character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints structure to console.
</p>


<h3>Note</h3>

<p>This function is useful for checking how a 'list()' object looks as a hierarchical structure, usually to be used as the  'n' and/or 'N' arguments of the 'cluster_gen' function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(2, 4, 3)
draw_cluster_structure(n)
draw_cluster_structure(n, output="text")
</code></pre>

<hr>
<h2 id='gen_cat_prop'>Generates cat_prop for questionnaire_gen</h2><span id='topic+gen_cat_prop'></span>

<h3>Description</h3>

<p>Generates cat_prop for questionnaire_gen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_cat_prop(n_X, n_W, n_cat_W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_cat_prop_+3A_n_x">n_X</code></td>
<td>
<p>number of continuous variables</p>
</td></tr>
<tr><td><code id="gen_cat_prop_+3A_n_w">n_W</code></td>
<td>
<p>number of categorical variables</p>
</td></tr>
<tr><td><code id="gen_cat_prop_+3A_n_cat_w">n_cat_W</code></td>
<td>
<p>number of categories per categorical variable</p>
</td></tr>
</table>

<hr>
<h2 id='gen_variable_n'>Randomly generate the quantity of background variables</h2><span id='topic+gen_variable_n'></span>

<h3>Description</h3>

<p>Randomly generate the quantity of background variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_variable_n(n_vars, n_X, n_W, theta = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_variable_n_+3A_n_vars">n_vars</code></td>
<td>
<p>number of variables in total (<code>n_X + n_W + theta</code>)</p>
</td></tr>
<tr><td><code id="gen_variable_n_+3A_n_x">n_X</code></td>
<td>
<p>number of continuous variables</p>
</td></tr>
<tr><td><code id="gen_variable_n_+3A_n_w">n_W</code></td>
<td>
<p>number of categorical variables</p>
</td></tr>
<tr><td><code id="gen_variable_n_+3A_theta">theta</code></td>
<td>
<p>number of latent variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with n_vars, n_X and n_W
</p>

<hr>
<h2 id='gen_X_W_cluster'>Generate n_X and n_W for clusters</h2><span id='topic+gen_X_W_cluster'></span>

<h3>Description</h3>

<p>Generates n_X and n_W for 'cluster_gen' based on a correlation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_X_W_cluster(n_levels, separate, class_cor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_X_W_cluster_+3A_n_levels">n_levels</code></td>
<td>
<p>number of levels</p>
</td></tr>
<tr><td><code id="gen_X_W_cluster_+3A_separate">separate</code></td>
<td>
<p>to the 'separate_questionnaires' argument of 'cluster_gen'</p>
</td></tr>
<tr><td><code id="gen_X_W_cluster_+3A_class_cor">class_cor</code></td>
<td>
<p>corresponds to the 'class_cor' argument of 'cluster_gen'</p>
</td></tr>
</table>

<hr>
<h2 id='intraclass_cor'>Intraclass correlation</h2><span id='topic+intraclass_cor'></span>

<h3>Description</h3>

<p>Calculates the intraclass correlation of clustered data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intraclass_cor(tau2_hat, sigma2_hat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intraclass_cor_+3A_tau2_hat">tau2_hat</code></td>
<td>
<p>estimate of the true between-class correlation</p>
</td></tr>
<tr><td><code id="intraclass_cor_+3A_sigma2_hat">sigma2_hat</code></td>
<td>
<p>estimate of the true within-class correlation</p>
</td></tr>
</table>


<h3>References</h3>

<p>Snijders, T. A. B., &amp; Bosker, R. J. (1999). Multilevel Analysis. Sage Publications.
</p>


<h3>See Also</h3>

<p>cluster_gen ?lsasim:::summary.lsasimcluster
</p>

<hr>
<h2 id='irt_gen'>Simulate item responses from an item response model</h2><span id='topic+irt_gen'></span>

<h3>Description</h3>

<p>Creates a data frame of item parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irt_gen(theta, a_par = 1, b_par, c_par = 0, D = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irt_gen_+3A_theta">theta</code></td>
<td>
<p>numeric ability estimate.</p>
</td></tr>
<tr><td><code id="irt_gen_+3A_a_par">a_par</code></td>
<td>
<p>numeric discrimination parameter.</p>
</td></tr>
<tr><td><code id="irt_gen_+3A_b_par">b_par</code></td>
<td>
<p>numeric or vector of numerics difficulty parameter(s).</p>
</td></tr>
<tr><td><code id="irt_gen_+3A_c_par">c_par</code></td>
<td>
<p>numeric guessing parameter.</p>
</td></tr>
<tr><td><code id="irt_gen_+3A_d">D</code></td>
<td>
<p>numeric parameter to specify logisitic (1) or normal (1.7).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>irt_gen(theta = 0.2, b_par = 0.6)
irt_gen(theta = 0.2, a_par = 1.15, b_par = 0.6)
irt_gen(theta = 0.2, a_par = 1.15, b_par = 0.6, c_par = 0.2)

</code></pre>

<hr>
<h2 id='item_gen'>Generation of item parameters from uniform distributions</h2><span id='topic+item_gen'></span>

<h3>Description</h3>

<p>Creates a data frame of item parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>item_gen(
  b_bounds,
  a_bounds = NULL,
  c_bounds = NULL,
  thresholds = 1,
  n_1pl = NULL,
  n_2pl = NULL,
  n_3pl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="item_gen_+3A_b_bounds">b_bounds</code></td>
<td>
<p>a vector containing the bounds of the the uniform distribution for sampling the difficulty parameters.</p>
</td></tr>
<tr><td><code id="item_gen_+3A_a_bounds">a_bounds</code></td>
<td>
<p>a vector containing the bounds of the the uniform distribution for sampling the discrimination parameters.</p>
</td></tr>
<tr><td><code id="item_gen_+3A_c_bounds">c_bounds</code></td>
<td>
<p>a vector containing the bounds of the the uniform distribution for sampling the guessing parameters.</p>
</td></tr>
<tr><td><code id="item_gen_+3A_thresholds">thresholds</code></td>
<td>
<p>if numeric, number of thresholds for 1- and/or 2- parameter dichotomous items, if vector,
each element is the number of thresholds corresponding to the vector of n_1pl and/or n_2pl.</p>
</td></tr>
<tr><td><code id="item_gen_+3A_n_1pl">n_1pl</code></td>
<td>
<p>if integer, number of 1-parameter dichotomous items, if vector,
each element is the number of partial credit items corresponding to thresholds number.</p>
</td></tr>
<tr><td><code id="item_gen_+3A_n_2pl">n_2pl</code></td>
<td>
<p>if integer, number of 2-parameter dichotomous items, if vector,
each element is the number of generalized partial credit items corresponding to thresholds number.</p>
</td></tr>
<tr><td><code id="item_gen_+3A_n_3pl">n_3pl</code></td>
<td>
<p>integer, number of 3-parameter items.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame includes two variables <code>p</code> and <code>k</code> which indicate the
number of parameters and the number of thresholds, respectively
</p>


<h3>Examples</h3>

<pre><code class='language-R'>item_gen(b_bounds = c(-2, 2), a_bounds = c(.75, 1.25),
  thresholds = c(1, 2, 3), n_1pl = c(5, 5, 5), n_2pl = c(0, 0, 5))
item_gen(b_bounds = c(-2, 2), a_bounds = c(.75, 1.25), c_bounds = c(0, .25),
  n_2pl = 5, n_3pl = 5)

</code></pre>

<hr>
<h2 id='jackknife'>Generate replicates of a dataset using Jackknife</h2><span id='topic+jackknife'></span>

<h3>Description</h3>

<p>Generate replicates of a dataset using Jackknife
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jackknife(data, weight_cols = "none", drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jackknife_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="jackknife_+3A_weight_cols">weight_cols</code></td>
<td>
<p>vector of weight columns</p>
</td></tr>
<tr><td><code id="jackknife_+3A_drop">drop</code></td>
<td>
<p>if 'TRUE', the observation that will not be part of the subsample is dropped from the dataset. Otherwise, it stays in the dataset but a new weight column is created to differentiate the selected observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing all the Jackknife replicates of 'data'
</p>


<h3>See Also</h3>

<p>brr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
    number = 1:5,
    letter = LETTERS[1:5],
    stringsAsFactors = FALSE
)
jackknife(x)
jackknife(x, drop = FALSE)
</code></pre>

<hr>
<h2 id='label_respondents'>Label respondents</h2><span id='topic+label_respondents'></span>

<h3>Description</h3>

<p>This function nerated level label combinations for each respondent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_respondents(
  n_obs,
  cluster_labels = names(n_obs),
  add_last_level = FALSE,
  apply_labels = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_respondents_+3A_n_obs">n_obs</code></td>
<td>
<p>list with the number of elements per level</p>
</td></tr>
<tr><td><code id="label_respondents_+3A_cluster_labels">cluster_labels</code></td>
<td>
<p>character vector with the names of each cluster level</p>
</td></tr>
<tr><td><code id="label_respondents_+3A_add_last_level">add_last_level</code></td>
<td>
<p>if 'TRUE' (not default), adds the last level to the output table</p>
</td></tr>
<tr><td><code id="label_respondents_+3A_apply_labels">apply_labels</code></td>
<td>
<p>if 'TRUE', applies labels (column names) to data cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the combinations of IDs from all levels
</p>

<hr>
<h2 id='lambda_gen'>Randomly generate a matrix of factor loadings</h2><span id='topic+lambda_gen'></span>

<h3>Description</h3>

<p>Randomly generate a matrix of factor loadings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_gen(n_ind, n_fac, limits, row_names, col_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_gen_+3A_n_ind">n_ind</code></td>
<td>
<p>number of indicators per factor</p>
</td></tr>
<tr><td><code id="lambda_gen_+3A_n_fac">n_fac</code></td>
<td>
<p>number of factors</p>
</td></tr>
<tr><td><code id="lambda_gen_+3A_limits">limits</code></td>
<td>
<p>vector with lower and upper limits for the uniformly-generated
Lambdas</p>
</td></tr>
<tr><td><code id="lambda_gen_+3A_row_names">row_names</code></td>
<td>
<p>vector with row names</p>
</td></tr>
<tr><td><code id="lambda_gen_+3A_col_names">col_names</code></td>
<td>
<p>vector with col names</p>
</td></tr>
</table>

<hr>
<h2 id='pisa2012_math_block'>PISA 2012 mathematics item - item block indicator matrix</h2><span id='topic+pisa2012_math_block'></span>

<h3>Description</h3>

<p>A dataset containing indicators associating those PISA 2012 mathematics items 
to the PISA 2012 mathematics item blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pisa2012_math_block
</code></pre>


<h3>Format</h3>

<p>A data frame with 109 rows and 12 variables:
</p>

<dl>
<dt>item_name</dt><dd><p>Item name.</p>
</dd>
<dt>item_no</dt><dd><p>Item numbers.</p>
</dd>
<dt>block1</dt><dd><p>Indicator specifying those items in block 1.</p>
</dd>
<dt>block2</dt><dd><p>Indicator specifying those items in block 2.</p>
</dd>
<dt>block3</dt><dd><p>Indicator specifying those items in block 3.</p>
</dd>
<dt>block4</dt><dd><p>Indicator specifying those items in block 4.</p>
</dd>
<dt>block5</dt><dd><p>Indicator specifying those items in block 5.</p>
</dd>
<dt>block6</dt><dd><p>Indicator specifying those items in block 6.</p>
</dd>
<dt>block7</dt><dd><p>Indicator specifying those items in block 7.</p>
</dd>
<dt>block8</dt><dd><p>Indicator specifying those items in block 8.</p>
</dd>
<dt>block9</dt><dd><p>Indicator specifying those items in block 9.</p>
</dd>
<dt>block10</dt><dd><p>Indicator specifying those items in block 10.</p>
</dd>
</dl>



<h3>Source</h3>

<p>PISA 2012 Technical Report, ANNEX A.
Table A.1: PISA 2012 Main Survey mathematics item classification. 
Pages 406 - 409.
<a href="https://www.oecd.org/pisa/pisaproducts/PISA-2012-technical-report-final.pdf">https://www.oecd.org/pisa/pisaproducts/PISA-2012-technical-report-final.pdf</a>
</p>

<hr>
<h2 id='pisa2012_math_booklet'>PISA 2012 mathematics item block - test booklet indicator matrix</h2><span id='topic+pisa2012_math_booklet'></span>

<h3>Description</h3>

<p>A dataset containing indicators associating those PISA 2012 mathematics item 
blocks to the PISA 2012 mathematics standard test booklet set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pisa2012_math_booklet
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 rows and 10 variables:
</p>

<dl>
<dt>booklet</dt><dd><p>Booklet name.</p>
</dd>
<dt>b1</dt><dd><p>Indicator specifying those test booklets that use item block 1.</p>
</dd>
<dt>b2</dt><dd><p>Indicator specifying those test booklets that use item block 2.</p>
</dd>
<dt>b3</dt><dd><p>Indicator specifying those test booklets that use item block 3.</p>
</dd>
<dt>b4</dt><dd><p>Indicator specifying those test booklets that use item block 4.</p>
</dd>
<dt>b5</dt><dd><p>Indicator specifying those test booklets that use item block 5.</p>
</dd>
<dt>b6</dt><dd><p>Indicator specifying those test booklets that use item block 6.</p>
</dd>
<dt>b7</dt><dd><p>Indicator specifying those test booklets that use item block 7.</p>
</dd>
<dt>b8</dt><dd><p>Indicator specifying those test booklets that use item block 8.</p>
</dd>
<dt>b9</dt><dd><p>Indicator specifying those test booklets that use item block 9.</p>
</dd>
</dl>



<h3>Source</h3>

<p>PISA 2012 Technical Report, Chapter 2: Test Design and Test Development.
Figure 2.1: Cluster rotation design used to form standard test booklets for PISA 2012. 
Page 31. 
<a href="https://www.oecd.org/pisa/pisaproducts/PISA-2012-technical-report-final.pdf">https://www.oecd.org/pisa/pisaproducts/PISA-2012-technical-report-final.pdf</a>
</p>

<hr>
<h2 id='pisa2012_math_item'>Item parameter estimates for 2012 PISA mathematics assessment</h2><span id='topic+pisa2012_math_item'></span>

<h3>Description</h3>

<p>A dataset containing the estimated item parameters for the PISA 2012 
mathematics assessment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pisa2012_math_item
</code></pre>


<h3>Format</h3>

<p>A data frame with 109 rows and 5 variables:
</p>

<dl>
<dt>item_name</dt><dd><p>Item name.</p>
</dd>
<dt>item</dt><dd><p>Item number.</p>
</dd>
<dt>b</dt><dd><p>b parameter estimate.</p>
</dd>
<dt>d1</dt><dd><p>d1 parameter estimate (for partial credit items).</p>
</dd>
<dt>d2</dt><dd><p>d2 parameter estimate (for partial credit items).</p>
</dd>
</dl>



<h3>Source</h3>

<p>PISA 2012 Technical Report, ANNEX A.
Table A.1: PISA 2012 Main Survey mathematics item classification. 
Pages 406 - 409.
<a href="https://www.oecd.org/pisa/pisaproducts/PISA-2012-technical-report-final.pdf">https://www.oecd.org/pisa/pisaproducts/PISA-2012-technical-report-final.pdf</a>
</p>

<hr>
<h2 id='pisa2012_q_cormat'>Correlation matrix from the PISA 2012 background questionnaire</h2><span id='topic+pisa2012_q_cormat'></span>

<h3>Description</h3>

<p>A correlation matrix for the selected background questionnaires and 
mathematics plausible value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pisa2012_q_cormat
</code></pre>


<h3>Format</h3>

<p>An 19 by 19 matrix.
</p>


<h3>Details</h3>

<p>A heterogenous correlation matrix, consisting of polyserial correlations 
between numeric and ordinal variables, and polychoric correlations between 
ordinal variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
 <strong>Row/Col</strong> </td><td style="text-align: left;">   <strong>Name</strong>  </td><td style="text-align: left;">  <strong>Label</strong>                 </td><td style="text-align: left;">  <strong>Type</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
  1               </td><td style="text-align: left;">   ST93Q01        </td><td style="text-align: left;">  Perseverance                   </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">  
  2               </td><td style="text-align: left;">   ST93Q03        </td><td style="text-align: left;">  Perseverance                   </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">  
  3               </td><td style="text-align: left;">   ST93Q04        </td><td style="text-align: left;">  Perseverance                   </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">  
  4               </td><td style="text-align: left;">   ST93Q06        </td><td style="text-align: left;">  Perseverance                   </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">  
  5               </td><td style="text-align: left;">   ST93Q07        </td><td style="text-align: left;">  Perseverance                   </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">  
  6               </td><td style="text-align: left;">   ST94Q05        </td><td style="text-align: left;">  Openness for Problem Solving   </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">
  7               </td><td style="text-align: left;">   ST94Q06        </td><td style="text-align: left;">  Openness for Problem Solving   </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">
  8               </td><td style="text-align: left;">   ST94Q09        </td><td style="text-align: left;">  Openness for Problem Solving   </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">
  9               </td><td style="text-align: left;">   ST94Q10        </td><td style="text-align: left;">  Openness for Problem Solving   </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">
  10              </td><td style="text-align: left;">   ST94Q14        </td><td style="text-align: left;">  Openness for Problem Solving   </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">  
  11              </td><td style="text-align: left;">   ST88Q01        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">     
  12              </td><td style="text-align: left;">   ST88Q02        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">     
  13              </td><td style="text-align: left;">   ST88Q03        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">     
  14              </td><td style="text-align: left;">   ST88Q04        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">     
  15              </td><td style="text-align: left;">   ST89Q02        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">   
  16              </td><td style="text-align: left;">   ST89Q03        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">      
  17              </td><td style="text-align: left;">   ST89Q04        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">     
  18              </td><td style="text-align: left;">   ST89Q05        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  Ordinal       </td>
</tr>
<tr>
 <td style="text-align: left;">     
  19              </td><td style="text-align: left;">   1PV1MATH       </td><td style="text-align: left;">  Mathematics Plausible Value 1  </td><td style="text-align: left;">  Continuous    </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>



<h3>Warning</h3>

<p>These data are for illustration purposes only.  Handling of missing data may not be suitable for valid inferences.
</p>


<h3>Source</h3>

<p>Raw data can be found at <a href="https://www.oecd.org/pisa/pisaproducts/pisa2012database-downloadabledata.htm">https://www.oecd.org/pisa/pisaproducts/pisa2012database-downloadabledata.htm</a>
Codebook can be found at <a href="https://www.oecd.org/pisa/pisaproducts/PISA12_stu_codebook.pdf">https://www.oecd.org/pisa/pisaproducts/PISA12_stu_codebook.pdf</a>
</p>

<hr>
<h2 id='pisa2012_q_marginal'>Marginal proportions from the PISA 2012 background questionnaire</h2><span id='topic+pisa2012_q_marginal'></span>

<h3>Description</h3>

<p>Marginal proportions from the PISA 2012 background questionnaire
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pisa2012_q_marginal
</code></pre>


<h3>Format</h3>

<p>A list of 19 named numeric vectors.
</p>


<h3>Details</h3>

<p>A list containing the marginal cumulative proportions for each response category from the PISA 2012 background questionnaire.
Elements 1 - 18 are the marginal proportions for the selected items from the background questionnaire.
Element 19 is the marginal proportion for the selected mathematics plausible value.
</p>

<table>
<tr>
 <td style="text-align: left;">
 <strong>Row/Col</strong> </td><td style="text-align: left;">   <strong>Name</strong>  </td><td style="text-align: left;">  <strong>Label</strong>                 </td><td style="text-align: left;">  <strong>Length</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
  1               </td><td style="text-align: left;">   ST93Q01        </td><td style="text-align: left;">  Perseverance                   </td><td style="text-align: left;">  5    </td>
</tr>
<tr>
 <td style="text-align: left;">  
  2               </td><td style="text-align: left;">   ST93Q03        </td><td style="text-align: left;">  Perseverance                   </td><td style="text-align: left;">  5    </td>
</tr>
<tr>
 <td style="text-align: left;">  
  3               </td><td style="text-align: left;">   ST93Q04        </td><td style="text-align: left;">  Perseverance                   </td><td style="text-align: left;">  5    </td>
</tr>
<tr>
 <td style="text-align: left;">  
  4               </td><td style="text-align: left;">   ST93Q06        </td><td style="text-align: left;">  Perseverance                   </td><td style="text-align: left;">  5    </td>
</tr>
<tr>
 <td style="text-align: left;">  
  5               </td><td style="text-align: left;">   ST93Q07        </td><td style="text-align: left;">  Perseverance                   </td><td style="text-align: left;">  5    </td>
</tr>
<tr>
 <td style="text-align: left;">  
  6               </td><td style="text-align: left;">   ST94Q05        </td><td style="text-align: left;">  Openness for Problem Solving   </td><td style="text-align: left;">  5    </td>
</tr>
<tr>
 <td style="text-align: left;">
  7               </td><td style="text-align: left;">   ST94Q06        </td><td style="text-align: left;">  Openness for Problem Solving   </td><td style="text-align: left;">  5    </td>
</tr>
<tr>
 <td style="text-align: left;">
  8               </td><td style="text-align: left;">   ST94Q09        </td><td style="text-align: left;">  Openness for Problem Solving   </td><td style="text-align: left;">  5    </td>
</tr>
<tr>
 <td style="text-align: left;">
  9               </td><td style="text-align: left;">   ST94Q10        </td><td style="text-align: left;">  Openness for Problem Solving   </td><td style="text-align: left;">  5    </td>
</tr>
<tr>
 <td style="text-align: left;">
  10              </td><td style="text-align: left;">   ST94Q14        </td><td style="text-align: left;">  Openness for Problem Solving   </td><td style="text-align: left;">  5    </td>
</tr>
<tr>
 <td style="text-align: left;">  
  11              </td><td style="text-align: left;">   ST88Q01        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  4    </td>
</tr>
<tr>
 <td style="text-align: left;">     
  12              </td><td style="text-align: left;">   ST88Q02        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  4    </td>
</tr>
<tr>
 <td style="text-align: left;">     
  13              </td><td style="text-align: left;">   ST88Q03        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  4    </td>
</tr>
<tr>
 <td style="text-align: left;">     
  14              </td><td style="text-align: left;">   ST88Q04        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  4    </td>
</tr>
<tr>
 <td style="text-align: left;">     
  15              </td><td style="text-align: left;">   ST89Q02        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  4    </td>
</tr>
<tr>
 <td style="text-align: left;">   
  16              </td><td style="text-align: left;">   ST89Q03        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  4    </td>
</tr>
<tr>
 <td style="text-align: left;">      
  17              </td><td style="text-align: left;">   ST89Q04        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  4    </td>
</tr>
<tr>
 <td style="text-align: left;">     
  18              </td><td style="text-align: left;">   ST89Q05        </td><td style="text-align: left;">  Attitude toward School         </td><td style="text-align: left;">  4    </td>
</tr>
<tr>
 <td style="text-align: left;">     
  19              </td><td style="text-align: left;">   1PV1MATH       </td><td style="text-align: left;">  Mathematics Plausible Value 1  </td><td style="text-align: left;">  1    </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>



<h3>Warning</h3>

<p>These data are for illustration purposes only.  Handling of missing data may not be suitable for valid inferences.
</p>


<h3>Source</h3>

<p>Raw data can be found at <a href="https://www.oecd.org/pisa/pisaproducts/pisa2012database-downloadabledata.htm">https://www.oecd.org/pisa/pisaproducts/pisa2012database-downloadabledata.htm</a>
Codebook can be found at <a href="https://www.oecd.org/pisa/pisaproducts/PISA12_stu_codebook.pdf">https://www.oecd.org/pisa/pisaproducts/PISA12_stu_codebook.pdf</a>
</p>

<hr>
<h2 id='pluralize'>Pluralize words</h2><span id='topic+pluralize'></span>

<h3>Description</h3>

<p>Pluralize a word
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pluralize(word, n = rep(2, length(word)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pluralize_+3A_word">word</code></td>
<td>
<p>vector of characters to be pluralized</p>
</td></tr>
<tr><td><code id="pluralize_+3A_n">n</code></td>
<td>
<p>vector of number of times each word appears (to determine if the plural or single form will be returned)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'word', either pluralized or not (depending on 'n')
</p>

<hr>
<h2 id='print_anova'>Print the ANOVA table</h2><span id='topic+print_anova'></span>

<h3>Description</h3>

<p>Print the ANOVA table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_anova(
  s2_within,
  s2_between,
  s2_total,
  sigma2_hat,
  tau2_hat,
  rho_hat,
  se_rho,
  n_tilde,
  M,
  N
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_anova_+3A_s2_within">s2_within</code></td>
<td>
<p>Within-class variance</p>
</td></tr>
<tr><td><code id="print_anova_+3A_s2_between">s2_between</code></td>
<td>
<p>Between-class variance</p>
</td></tr>
<tr><td><code id="print_anova_+3A_s2_total">s2_total</code></td>
<td>
<p>Total variance</p>
</td></tr>
<tr><td><code id="print_anova_+3A_sigma2_hat">sigma2_hat</code></td>
<td>
<p>estimate of the true within-class correlation</p>
</td></tr>
<tr><td><code id="print_anova_+3A_tau2_hat">tau2_hat</code></td>
<td>
<p>estimate of the true between-class correlation</p>
</td></tr>
<tr><td><code id="print_anova_+3A_rho_hat">rho_hat</code></td>
<td>
<p>estimated intraclass correlation</p>
</td></tr>
<tr><td><code id="print_anova_+3A_se_rho">se_rho</code></td>
<td>
<p>standard errors of 'rho_hat'</p>
</td></tr>
<tr><td><code id="print_anova_+3A_n_tilde">n_tilde</code></td>
<td>
<p>function of the variance of n_N, M and N. See documentation and code of <code>lsasim:::summary.lsasimcluster</code> for details</p>
</td></tr>
<tr><td><code id="print_anova_+3A_m">M</code></td>
<td>
<p>total sample size</p>
</td></tr>
<tr><td><code id="print_anova_+3A_n">N</code></td>
<td>
<p>number of classes j</p>
</td></tr>
</table>


<h3>References</h3>

<p>Snijders, T. A. B., &amp; Bosker, R. J. (1999). Multilevel Analysis. Sage Publications.
</p>


<h3>See Also</h3>

<p>anova
</p>

<hr>
<h2 id='proportion_gen'>Generation of random cumulative proportions</h2><span id='topic+proportion_gen'></span>

<h3>Description</h3>

<p>Creates a list of vectors, each containing the randomly generated cumulative 
proportions of a discrete variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proportion_gen(cat_options, n_cat_options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proportion_gen_+3A_cat_options">cat_options</code></td>
<td>
<p>vector of response types.</p>
</td></tr>
<tr><td><code id="proportion_gen_+3A_n_cat_options">n_cat_options</code></td>
<td>
<p>vector of number of items of the corresponding response 
type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cat_options</code> and <code>n_cat_options</code> must be the same length.  
<code>cat_options = 1</code> is a continuous variable.
</p>
<p>The result from <code>proportion_gen</code> can be used directly with the <code>cat_prop</code>
argument of <code>questionnaire_gen</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proportion_gen(cat_options = c(1, 2, 3), n_cat_options = c(2, 2, 2))
proportion_gen(cat_options = c(1, 3), n_cat_options = c(4, 5))

</code></pre>

<hr>
<h2 id='pt_bis_conversion'>Analytical point-biserial conversion</h2><span id='topic+pt_bis_conversion'></span>

<h3>Description</h3>

<p>Analytical point-biserial conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pt_bis_conversion(bis_cor, pr_group1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pt_bis_conversion_+3A_bis_cor">bis_cor</code></td>
<td>
<p>biserial correlations</p>
</td></tr>
<tr><td><code id="pt_bis_conversion_+3A_pr_group1">pr_group1</code></td>
<td>
<p>probability of group 1</p>
</td></tr>
</table>

<hr>
<h2 id='questionnaire_gen'>Generation of ordinal and continuous variables</h2><span id='topic+questionnaire_gen'></span>

<h3>Description</h3>

<p>Creates a data frame of discrete and continuous variables based on several
arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>questionnaire_gen(
  n_obs,
  cat_prop = NULL,
  n_vars = NULL,
  n_X = NULL,
  n_W = NULL,
  cor_matrix = NULL,
  cov_matrix = NULL,
  c_mean = NULL,
  c_sd = NULL,
  theta = FALSE,
  family = NULL,
  full_output = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="questionnaire_gen_+3A_n_obs">n_obs</code></td>
<td>
<p>number of observations to generate.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_cat_prop">cat_prop</code></td>
<td>
<p>list of cumulative proportions for each item. If <code>theta
= TRUE</code>, the first element of <code>cat_prop</code> must be a scalar 1, which
corresponds to the <code>theta</code>.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_n_vars">n_vars</code></td>
<td>
<p>total number of variables in the questionnaire, including the
continuous and the discrete covariates (<code class="reqn">X</code> and <code class="reqn">W</code>, respectively),
as well as the latent trait (<code class="reqn">Y</code>, which is equivalent to <code class="reqn">\theta</code>).</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_n_x">n_X</code></td>
<td>
<p>number of continuous background variables. If not provided, a
random number of continuous variables will be generated.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_n_w">n_W</code></td>
<td>
<p>either a scalar corresponding to the number of categorical
background variables or a list of scalars representing the number of
categories for each categorical variable. If not provided, a random number
of categorical variables will be generated.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_cor_matrix">cor_matrix</code></td>
<td>
<p>latent correlation matrix. The first row/column corresponds
to the latent trait (<code class="reqn">Y</code>). The other rows/columns correspond to the
continuous (<code class="reqn">X</code> or <code class="reqn">Z</code>) or the discrete (<code class="reqn">W</code>) background
variables, in the same order as <code>cat_prop</code>.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_cov_matrix">cov_matrix</code></td>
<td>
<p>latent covariance matrix, formatted as <code>cor_matrix</code>.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_c_mean">c_mean</code></td>
<td>
<p>is a vector of population means for each continuous variable
(<code class="reqn">Y</code> and <code class="reqn">X</code>). Defaults to 0.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_c_sd">c_sd</code></td>
<td>
<p>is a vector of population standard deviations for each continuous
variable  (<code class="reqn">Y</code> and <code class="reqn">X</code>). Defaults to 1.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_theta">theta</code></td>
<td>
<p>if <code>TRUE</code>, the first continuous variable will be labeled
'theta'. Otherwise, it will be labeled 'q1'.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_family">family</code></td>
<td>
<p>distribution of the background variables. Can be NULL (default)
or 'gaussian'.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_full_output">full_output</code></td>
<td>
<p>if <code>TRUE</code>, output will be a list containing the
questionnaire data as well as several objects that might be of interest for
further analysis of the data.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_+3A_verbose">verbose</code></td>
<td>
<p>if 'FALSE', output messages will be suppressed (useful for
simulations). Defaults to 'TRUE'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In essence, this function begins by checking the validity of the
arguments provided and randomly generating those that are not. Then, it
will call one of two internal functions,
<code>questionnaire_gen_polychoric</code> or <code>questionnaire_gen_family</code>. The
former corresponds to the exact functionality of questionnaire_gen on
lsasim 1.0.1, where the polychoric correlations are used to generate the
background questionnaire data. If <code>family != NULL</code>, however,
<code>questionnaire_gen_family</code> is called to generate data based on a joint
probability distribution. Additionally, if <code>full_output == TRUE</code>, the
external function <code>beta_gen</code> is called to generate the correlation
coefficients based on the true covariance matrix. The latter argument also
changes the class of the output of this function.
</p>
<p>What follows are some notes on the input parameters.
</p>
<p><code>cat_prop</code> is a list where <code>length(cat_prop)</code> is the number of
items to be generated.  Each element of the list is a vector containing the
marginal cumulative proportions for each category, summing to 1.  For
continuous items, the associated element in the list should be 1.
</p>
<p><code>cor_matrix</code> and <code>cov_matrix</code> are the correlation and covariance
matrices that are the same size as <code>length(cat_prop)</code>.  The
correlations related to the correlation between variables on the latent
scale.
</p>
<p><code>c_mean and c_sd</code> are each vectors whose length is equal to the number
of continuous variables as specified by <code>cat_prop</code>.  The default is to
keep the continuous variables with mean zero and standard deviation of one.
</p>
<p><code>theta</code> is a logical indicator that determines if the first continuous
item should be labeled <em>theta</em>. If <code>theta == TRUE</code> but there are
no continuous variables generated, a random number of background variables
will be generated.
</p>
<p>If <code>cat_prop</code> is a named list, those names will be used as variable
names for the returned <code>data.frame</code>.  Generic names will be provided
to the variables if <code>cat_prop</code> is not named.
</p>
<p>As an alternative to providing <code>cat_prop</code>, the user can call this
function by specifying the total number of variables using <code>n_vars</code> or
the specific number of continuous and categorical variables through
<code>n_X</code> and <code>n_W</code>. All three arguments should be provided as
scalars; <code>n_W</code> may also be provided as a list, where each element
contains the number of categories for one background variable.
Alternatively, <code>n_W</code> may be provided as a one-element list, in which
case it will be interpreted as all the categorical variables having the
same number of categories.
</p>
<p>If <code>family == "gaussian"</code>, the questionnaire will be generated
assuming that all the variables are jointly-distributed as a multivariate
normal. The default behavior is <code>family == NULL</code>, where the data is
generated using the polychoric correlation matrix, with no distributional
assumptions.
</p>
<p>When data is generated using the Gaussian distribution, the matrices
provided correspond to the relations between the latent variable
<code class="reqn">\theta</code>, the continuous covariates <code class="reqn">X</code> and the continuous
covariates&mdash;<code class="reqn">Z ~ N(0, 1)</code>&mdash;that will later be discretized into
categorical covariates <code class="reqn">W</code>. That is why there will be a difference
between labels and lengths between <code>cov_matrix</code> and <code>vcov_YXW</code>.
For more information, check the references cited later in this document.
</p>


<h3>Value</h3>

<p>By default, the function returns a <code>data.frame</code> object where the
first column (&quot;subject&quot;) is a <code class="reqn">1,\ldots,n</code> ordered list of the <code class="reqn">n</code>
observations and the other columns correspond to the questionnaire answers.
If <code>theta = TRUE</code>, the first column after &quot;subject&quot; will be the latent
variable <code class="reqn">\theta</code>; in any case, the continuous variables always come
before the categorical ones.
</p>
<p>If <code>full_output = TRUE</code>, the output will be a list containing the
following objects:
</p>
<table>
<tr><td><code>bg</code></td>
<td>
<p>a data frame containing the background questionnaire answers
(i.e., the same object as described above).</p>
</td></tr>
<tr><td><code>c_mean</code></td>
<td>
<p>identical to the input argument of the same name. Read the
Details section for more information.</p>
</td></tr>
<tr><td><code>c_sd</code></td>
<td>
<p>identical to the input argument of the same name. Read the
Details section for more information.</p>
</td></tr>
<tr><td><code>cat_prop</code></td>
<td>
<p>identical to the input argument of the same name. Read the
Details section for more information.</p>
</td></tr>
<tr><td><code>cat_prop_W_p</code></td>
<td>
<p>a list containing the probabilities for each category
of the categorical variables (<code>cat_prop_W</code> contains the cumulative
probabilities).</p>
</td></tr>
<tr><td><code>cor_matrix</code></td>
<td>
<p>identical to the input argument of the same name. Read
the Details section for more information.</p>
</td></tr>
<tr><td><code>cov_matrix</code></td>
<td>
<p>identical to the input argument of the same name. Read
the Details section for more information.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>identical to the input argument of the same name.</p>
</td></tr>
<tr><td><code>n_obs</code></td>
<td>
<p>identical to the input argument of the same name.</p>
</td></tr>
<tr><td><code>n_tot</code></td>
<td>
<p>named vector containing the number of total variables, the
number of continuous background variables (i.e., the total number of
background variables except <code class="reqn">\theta</code>) and the number of categorical
variables.</p>
</td></tr>
<tr><td><code>n_W</code></td>
<td>
<p>vector containing the number of categorical variables.</p>
</td></tr>
<tr><td><code>n_X</code></td>
<td>
<p>vector containing the number of continuous variables (except
<code class="reqn">\theta</code>).</p>
</td></tr>
<tr><td><code>sd_YXW</code></td>
<td>
<p>vector with the standard deviations of all the variables</p>
</td></tr>
<tr><td><code>sd_YXZ</code></td>
<td>
<p>vector containing the standard deviations of <code class="reqn">\theta</code>,
the background continuous variables (<code class="reqn">X</code>) and the Normally-distributed
variables <code class="reqn">Z</code> which will generate the background categorical variables
(<code class="reqn">W</code>).</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>identical to the input argument of the same name.</p>
</td></tr>
<tr><td><code>var_W</code></td>
<td>
<p>list containing the variances of the categorical variables.</p>
</td></tr>
<tr><td><code>var_YX</code></td>
<td>
<p>list containing the variances of the continuous variables
(including <code class="reqn">\theta</code>)</p>
</td></tr>
<tr><td><code>linear_regression</code></td>
<td>
<p>This list is printed only if 'theta = TRUE',
'family = &quot;gaussian&quot;' and 'full_output = TRUE'. It contains one vector
named 'betas' and one tabled named 'cov_YXW'. The former displays the true
linear regression coefficients of <code class="reqn">theta</code> on the background
questionnaire answers; the latter contains the covariance matrix between
all these variables.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If <code>family == NULL</code>, the number of levels for each categorical
variables will be determined by the number of categories observed in the
generated data. This means it might be smaller than the number of
categories determined by <code>cat_prop</code>, which is more likely to happen
with small values of <code>n_obs</code>. If <code>family == "gaussian"</code>, however,
the number of levels for the categorical variables will always be
equivalent to the number of possible categories, even if they are not
observed in the data.
</p>
<p>It is important to note that all arguments directly related to variable
parameters (e.g. 'cat_prop', 'cov_matrix', 'cor_matrix', 'c_mean', 'c_sd')
have the following order: Y, X, W (missing variables are skipped). This
must be kept in mind when using real-life data as input to
'questionnaire_gen', as the input might need to be reordered to fit the
expectations of the function.
</p>
<p>By definition, the expected order of the variables is <code class="reqn">theta</code>,
followed by <code class="reqn">X</code> and then <code class="reqn">W</code>. The reference category of the
categorical variables <code class="reqn">W</code> is always the first one.
</p>
<p>For very small means/sigmas (e.g. 0.005) and multiple levels, estimates
may have differing levels of accuracy (e.g. school level estimates will not
be as accurate as the student levels ones). In general, one should expect
naturally worse estimation on higher hierarchical setups.
</p>


<h3>References</h3>

<p>Matta, T. H., Rutkowski, L., Rutkowski, D., &amp; Liaw, Y. L. (2018).
lsasim: an R package for simulating large-scale assessment data.
Large-scale Assessments in Education, 6(1), 15.
</p>


<h3>See Also</h3>

<p>beta_gen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using polychoric correlations
props &lt;- list(c(1), c(.25, .6, 1))  # one continuous, one with 3 categories
questionnaire_gen(n_obs = 10, cat_prop = props,
                  cor_matrix = matrix(c(1, .6, .6, 1), nrow = 2),
                  c_mean = 2, c_sd = 1.5, theta = TRUE)

# Using the multinomial distribution
# two categorical variables W: one has 2 categories, the other has 3
props &lt;- list(1, c(.25, 1), c(.2, .8, 1))
yw_cov &lt;- matrix(c(1, .5, .5, .5, 1, .8, .5, .8, 1), nrow = 3)
questionnaire_gen(n_obs = 10, cat_prop = props, cov_matrix = yw_cov,
                  family = "gaussian")

# Not providing covariance matrix
questionnaire_gen(n_obs = 10,
                  cat_prop = list(c(.25, 1), c(.6, 1), c(.2, 1)),
                  family = "gaussian")
</code></pre>

<hr>
<h2 id='questionnaire_gen_family'>Generation of ordinal and continuous variables</h2><span id='topic+questionnaire_gen_family'></span>

<h3>Description</h3>

<p>Creates a data frame of discrete and continuous variables based on a latent
correlation matrix and marginal proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>questionnaire_gen_family(
  n_obs,
  cat_prop,
  cov_matrix,
  family = "gaussian",
  theta = FALSE,
  mean_yx = NULL,
  n_cats
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="questionnaire_gen_family_+3A_n_obs">n_obs</code></td>
<td>
<p>number of observations to generate.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_family_+3A_cat_prop">cat_prop</code></td>
<td>
<p>list of cumulative proportions for each item.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_family_+3A_cov_matrix">cov_matrix</code></td>
<td>
<p>covariance matrix. between the latent trait (Y) and the
background variables (X and Z).</p>
</td></tr>
<tr><td><code id="questionnaire_gen_family_+3A_family">family</code></td>
<td>
<p>distribution of the background variables. Can be NULL or
'gaussian'.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_family_+3A_theta">theta</code></td>
<td>
<p>if <code>TRUE</code> will label the first continuous variable 'theta'.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_family_+3A_mean_yx">mean_yx</code></td>
<td>
<p>vector with the means of the latent trait (Y) and the
continuous background variables with flexible variance (X).</p>
</td></tr>
<tr><td><code id="questionnaire_gen_family_+3A_n_cats">n_cats</code></td>
<td>
<p>vector with number of categories for each W.</p>
</td></tr>
</table>

<hr>
<h2 id='questionnaire_gen_polychoric'>Generation of ordinal and continuous variables</h2><span id='topic+questionnaire_gen_polychoric'></span>

<h3>Description</h3>

<p>Creates a data frame of discrete and continuous variables based on a latent
correlation matrix and marginal proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>questionnaire_gen_polychoric(n_obs, cat_prop, cor_matrix, c_mean, c_sd, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="questionnaire_gen_polychoric_+3A_n_obs">n_obs</code></td>
<td>
<p>number of observations to generate.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_polychoric_+3A_cat_prop">cat_prop</code></td>
<td>
<p>list of cumulative proportions for each item.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_polychoric_+3A_cor_matrix">cor_matrix</code></td>
<td>
<p>latent correlation matrix.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_polychoric_+3A_c_mean">c_mean</code></td>
<td>
<p>is a vector of population means for each continuous variable.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_polychoric_+3A_c_sd">c_sd</code></td>
<td>
<p>is a vector of population standard deviations for each continuous
variable.</p>
</td></tr>
<tr><td><code id="questionnaire_gen_polychoric_+3A_theta">theta</code></td>
<td>
<p>if <code>TRUE</code> will label the first continuous variable 'theta'.</p>
</td></tr>
</table>

<hr>
<h2 id='ranges'>Defines vector as range</h2><span id='topic+ranges'></span>

<h3>Description</h3>

<p>Redefines the class of a vector as &quot;range&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranges(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranges_+3A_x">x</code></td>
<td>
<p>first element</p>
</td></tr>
<tr><td><code id="ranges_+3A_y">y</code></td>
<td>
<p>second element</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'c(x, y)', but with the &quot;range&quot; class
</p>


<h3>Note</h3>

<p>This function was created to be used as an element in the 'N' argument of 'cluster_gen'. The name was chosen to avoid conflict with 'base::range()'.
</p>
<p>'ranges()' should always be used within a 'list()'. Inserting a &quot;range&quot; vector inside a common vector ('c()') will result in a common vector. For example, 'c(3, ranges(8, 10))' is the same as 'c(3, 8, 10)', because when faced with conflicting classes in the same element, R will resolve to the simpler case (&quot;numeric&quot;, in this case). An easier way to understand this concept is by checking 'class(c(3, &quot;a&quot;))' is &quot;character&quot;, meaning the number 3 was devolved into a character &quot;3&quot;.
</p>

<hr>
<h2 id='recalc_final_weights'>Recalculate final weights</h2><span id='topic+recalc_final_weights'></span>

<h3>Description</h3>

<p>Recalculate final weights given the replicate weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recalc_final_weights(data, w_cols, replicate_weight = 1, reorder = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recalc_final_weights_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="recalc_final_weights_+3A_w_cols">w_cols</code></td>
<td>
<p>columns containing the weights</p>
</td></tr>
<tr><td><code id="recalc_final_weights_+3A_replicate_weight">replicate_weight</code></td>
<td>
<p>scalar with the replicate weights</p>
</td></tr>
<tr><td><code id="recalc_final_weights_+3A_reorder">reorder</code></td>
<td>
<p>if 'TRUE', reorders the dataset so that the replicate weights appear before the final weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>input data with recalculated final weights, incorporating the replicate weights
</p>

<hr>
<h2 id='replicate_var'>Sampling variance of the mean for replications</h2><span id='topic+replicate_var'></span>

<h3>Description</h3>

<p>Estimates the mean variance for Jackknife, BRR and BRR Fay replication methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replicate_var(
  data_whole,
  data_rep,
  method,
  k = 0,
  weight_var = NULL,
  stat = weighted.mean,
  vars = NULL,
  full_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replicate_var_+3A_data_whole">data_whole</code></td>
<td>
<p>full, original dataset (the one that generated the replications)</p>
</td></tr>
<tr><td><code id="replicate_var_+3A_data_rep">data_rep</code></td>
<td>
<p>list with replications of 'data_whole'</p>
</td></tr>
<tr><td><code id="replicate_var_+3A_method">method</code></td>
<td>
<p>replication method. Can be &quot;Jackknife&quot;, &quot;BRR&quot; or &quot;BRR Fay&quot;</p>
</td></tr>
<tr><td><code id="replicate_var_+3A_k">k</code></td>
<td>
<p>deflating weight factor (used only when 'method = &quot;BRR Fay&quot;)</p>
</td></tr>
<tr><td><code id="replicate_var_+3A_weight_var">weight_var</code></td>
<td>
<p>variables containing the weights</p>
</td></tr>
<tr><td><code id="replicate_var_+3A_stat">stat</code></td>
<td>
<p>statistic of interest to calculate (must be a base R function)</p>
</td></tr>
<tr><td><code id="replicate_var_+3A_vars">vars</code></td>
<td>
<p>vector containing the variables of interest</p>
</td></tr>
<tr><td><code id="replicate_var_+3A_full_output">full_output</code></td>
<td>
<p>if 'TRUE', returns all intermediate objects created</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'data_rep' can be obtained from
</p>


<h3>See Also</h3>

<p>jackknife brr
</p>

<hr>
<h2 id='response_gen'>Generation of item response data using a rotated block design</h2><span id='topic+response_gen'></span>

<h3>Description</h3>

<p>Creates a data frame of discrete item responses based on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response_gen(
  subject,
  item,
  theta,
  a_par = NULL,
  b_par,
  c_par = NULL,
  d_par = NULL,
  item_no = NULL,
  ogive = "Logistic"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_gen_+3A_subject">subject</code></td>
<td>
<p>integer vector of test taker IDs.</p>
</td></tr>
<tr><td><code id="response_gen_+3A_item">item</code></td>
<td>
<p>integer vector of item IDs.</p>
</td></tr>
<tr><td><code id="response_gen_+3A_theta">theta</code></td>
<td>
<p>numeric vector of latent test taker abilities.</p>
</td></tr>
<tr><td><code id="response_gen_+3A_a_par">a_par</code></td>
<td>
<p>numeric vector of item a parameters for each item.</p>
</td></tr>
<tr><td><code id="response_gen_+3A_b_par">b_par</code></td>
<td>
<p>numeric vector of item b parameters for each item.</p>
</td></tr>
<tr><td><code id="response_gen_+3A_c_par">c_par</code></td>
<td>
<p>numeric vector of item c parameters for each item.</p>
</td></tr>
<tr><td><code id="response_gen_+3A_d_par">d_par</code></td>
<td>
<p>list of numeric vectors of item threshold parameters for each item.</p>
</td></tr>
<tr><td><code id="response_gen_+3A_item_no">item_no</code></td>
<td>
<p>vector of item numbers the correspond the item parameters</p>
</td></tr>
<tr><td><code id="response_gen_+3A_ogive">ogive</code></td>
<td>
<p>can be &quot;Normal&quot; or &quot;Logistic&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>subject</code> and <code>item</code> must be equal lengths.
</p>
<p>Generalized partial credit models (<code>!is.null(d_par)</code>) uses threshold parameterization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
s_id &lt;- c(1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4,
          4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7,
          7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10,
          10, 11, 11, 11, 11, 11, 11, 12,12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
          13, 13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 16,16, 16, 16,
          16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 19, 19,
          19, 19, 19, 19,19, 20, 20, 20, 20, 20, 20, 20)
i_id&lt;- c(1, 4, 7, 10, 3, 6, 9, 1, 4, 7, 10, 2, 5, 8, 1, 4, 7, 10, 3, 6, 9, 1, 4,
         7, 10, 3, 6, 9, 1, 4, 7, 10, 3, 6, 9, 2, 5, 8, 3, 6, 9, 1, 4, 7, 10, 2,
         5, 8, 2, 5, 8, 3, 6, 9, 1, 4, 7, 10, 2, 5, 8, 1, 4, 7, 10, 3, 6, 9, 2,
         5, 8, 3, 6, 9, 1, 4, 7, 10, 3, 6, 9, 2, 5, 8, 3, 6, 9, 2, 5, 8, 3, 6, 9,
         2, 5, 8, 3, 6, 9, 2, 5, 8, 3, 6, 9, 1, 4, 7, 10, 2, 5, 8, 1, 4, 7, 10,
         2, 5, 8, 1, 4, 7, 10, 2, 5, 8, 1, 4, 7, 10, 3, 6, 9)
bb &lt;- c(-1.72, -1.85, 0.98, 0.07, 1.00, 0.13, -0.43, -0.29, 0.86, 1.26)
aa &lt;- c(1.28, 0.78, 0.98, 1.21, 0.83, 1.01, 0.92, 0.76, 0.88, 1.11)
cc &lt;- rep(0, 10)
dd &lt;- list(c(0, 0, -0.13, 0, -0.19, 0, 0, 0, 0, 0),
           c(0, 0,  0.13, 0,  0.19, 0, 0, 0, 0, 0))
response_gen(subject = s_id, item = i_id, theta = rnorm(20, 0, 1),
             b_par = bb, a_par = aa, c_par = cc, d_par = dd)

</code></pre>

<hr>
<h2 id='rzeropois'>Generate data from a Zero-truncated Poisson</h2><span id='topic+rzeropois'></span>

<h3>Description</h3>

<p>Random generation of one observation of a random variable distributed as a Zero-truncated Poisson
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rzeropois(lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rzeropois_+3A_lambda">lambda</code></td>
<td>
<p>corresponds to the lambda parameter of a Poisson</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-truncated Poisson (a.k.a. conditional Poisson or positive Poisson) distribution is a discrete probability distribution whose support is the set of positive integers.
</p>

<hr>
<h2 id='sample_from'>Sample from population structure</h2><span id='topic+sample_from'></span>

<h3>Description</h3>

<p>Generates a sample from a population structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_from(N, n, labels = names(N), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_from_+3A_n">N</code></td>
<td>
<p>list containing the population sampling structure</p>
</td></tr>
<tr><td><code id="sample_from_+3A_n">n</code></td>
<td>
<p>numeric vector with the number of sampled observations (clusters or subjects) on each level</p>
</td></tr>
<tr><td><code id="sample_from_+3A_labels">labels</code></td>
<td>
<p>character vector with the names of the questionnaire respondents on each level</p>
</td></tr>
<tr><td><code id="sample_from_+3A_verbose">verbose</code></td>
<td>
<p>if 'TRUE', prints output messages</p>
</td></tr>
</table>

<hr>
<h2 id='sample_within_range'>Sample from range</h2><span id='topic+sample_within_range'></span>

<h3>Description</h3>

<p>Creates a uniformly-distributed sample from a 2-length vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_within_range(rg, sample_size = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_within_range_+3A_rg">rg</code></td>
<td>
<p>a &quot;range&quot;-class vector</p>
</td></tr>
<tr><td><code id="sample_within_range_+3A_sample_size">sample_size</code></td>
<td>
<p>the size of the sample to be generated</p>
</td></tr>
<tr><td><code id="sample_within_range_+3A_seed">seed</code></td>
<td>
<p>pseudo-random number generator seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the generated sample
</p>


<h3>Note</h3>

<p>This function was created primarily to be used to expand an object with the &quot;range&quot; class.
</p>

<hr>
<h2 id='select'>Transform regular vector into selection vector</h2><span id='topic+select'></span>

<h3>Description</h3>

<p>Attaches a &quot;select&quot; class to a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>parameters to be passed to 'c()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>same as 'x', but with a class attribute that classifies 'x' as &quot;select&quot;
</p>


<h3>Note</h3>

<p>This function was created to be used instead of 'c()' in the 'n' argument of 'cluster_gen'.
</p>

<hr>
<h2 id='split_cat_prop'>Split variables in cat_prop</h2><span id='topic+split_cat_prop'></span>

<h3>Description</h3>

<p>Split variables in cat_prop
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_cat_prop(cat_prop, keepYX = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_cat_prop_+3A_cat_prop">cat_prop</code></td>
<td>
<p>list corresponding to <code>cat_prop</code> from
<code>questionnaire_gen</code></p>
</td></tr>
<tr><td><code id="split_cat_prop_+3A_keepyx">keepYX</code></td>
<td>
<p>if <code>TRUE</code>, output will be a list separating cat_prop_YX
and cat_prop_W. IF <code>FALSE</code>, it will be a list with these objects
combined (just like <code>cat_prop</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='summary_2'>Dataset summary statistics</h2><span id='topic+summary_2'></span>

<h3>Description</h3>

<p>Creates summary statistics of a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_2(data, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_2_+3A_data">data</code></td>
<td>
<p>Data frame</p>
</td></tr>
<tr><td><code id="summary_2_+3A_digits">digits</code></td>
<td>
<p>number of digits for the output</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is inspired by base::summary(), but outputs content more relevant to the context of cluster_gen() and summary()
</p>


<h3>See Also</h3>

<p>summary()
</p>

<hr>
<h2 id='summary.lsasimcluster'>Summarizes clusters</h2><span id='topic+summary.lsasimcluster'></span>

<h3>Description</h3>

<p>Takes the output of 'cluster_gen' and creates summary statistics of the questionnaire variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsasimcluster'
summary(
  object,
  digits = 4,
  print = "partial",
  print_hetcor = TRUE,
  force_matrix = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lsasimcluster_+3A_object">object</code></td>
<td>
<p>output of 'cluster_gen'</p>
</td></tr>
<tr><td><code id="summary.lsasimcluster_+3A_digits">digits</code></td>
<td>
<p>loosely controls the number of digits (significant or not) in the output (for 'print = TRUE')</p>
</td></tr>
<tr><td><code id="summary.lsasimcluster_+3A_print">print</code></td>
<td>
<p>&quot;all&quot; will pretty-print a summary of statistics, &quot;partial&quot; will only print cluster-level sumamrizes; &quot;none&quot; outputs statistics as a list</p>
</td></tr>
<tr><td><code id="summary.lsasimcluster_+3A_print_hetcor">print_hetcor</code></td>
<td>
<p>if 'TRUE' (default), prints the heterogeneous correlation matrix</p>
</td></tr>
<tr><td><code id="summary.lsasimcluster_+3A_force_matrix">force_matrix</code></td>
<td>
<p>if 'TRUE', prints the heterogeneous correlation matrix even if warnings are generated</p>
</td></tr>
<tr><td><code id="summary.lsasimcluster_+3A_...">...</code></td>
<td>
<p>additional arguments (unused; added for compatibility with generic)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of summaries
</p>


<h3>Note</h3>

<p>Setting 'print=&quot;none&quot;' allows for saving the results as an R object (list). Otherwise, the results will be simply printed and not saveable.
</p>
<p>Changing 'digits' may yield unexpected results for the estimates of continuous variables, given how most of them are printed using the number of significant digits (for more information, see 'help(&quot;summary&quot;)').
</p>
<p>Please note that datasets containing large values for the coefficient of variation (sigma / mu) should yield imprecise results.
</p>


<h3>See Also</h3>

<p>anova.lsasimcluster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(3, 30)
cls &lt;- cluster_gen(n, n_X = 3, n_W = 5)
summary(cls)
summary(cls, print="none") # allows saving results
</code></pre>

<hr>
<h2 id='trim_sample'>Trim sample</h2><span id='topic+trim_sample'></span>

<h3>Description</h3>

<p>Makes sure n &lt;= N
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_sample(n, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_sample_+3A_n">n</code></td>
<td>
<p>vector or unranged list corresponding to sample structure</p>
</td></tr>
<tr><td><code id="trim_sample_+3A_n">N</code></td>
<td>
<p>vector or unranged list corresponding to population structure</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>cluster_gen
</p>

<hr>
<h2 id='validate_questionnaire_gen'>Wrapper-functions for check_condition</h2><span id='topic+validate_questionnaire_gen'></span>

<h3>Description</h3>

<p>functions to save space in ther parent functions by moving the validation checks here
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_questionnaire_gen(
  n_cats,
  n_vars,
  n_X,
  n_W,
  theta,
  cat_prop,
  cor_matrix,
  cov_matrix,
  c_mean,
  c_sd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_questionnaire_gen_+3A_n_cats">n_cats</code></td>
<td>
<p>vector with number of categories for each categorical variable
(W)</p>
</td></tr>
<tr><td><code id="validate_questionnaire_gen_+3A_n_vars">n_vars</code></td>
<td>
<p>number of variables (Y, X and W)</p>
</td></tr>
<tr><td><code id="validate_questionnaire_gen_+3A_n_x">n_X</code></td>
<td>
<p>number of continuous background variables (X)</p>
</td></tr>
<tr><td><code id="validate_questionnaire_gen_+3A_n_w">n_W</code></td>
<td>
<p>number of categorical variables (W)</p>
</td></tr>
<tr><td><code id="validate_questionnaire_gen_+3A_theta">theta</code></td>
<td>
<p>is there a latent variable (Y)?</p>
</td></tr>
<tr><td><code id="validate_questionnaire_gen_+3A_cat_prop">cat_prop</code></td>
<td>
<p>list of vectors with the cumulative proportions of the
background variables</p>
</td></tr>
<tr><td><code id="validate_questionnaire_gen_+3A_cor_matrix">cor_matrix</code></td>
<td>
<p>correlation matrix of YXW</p>
</td></tr>
<tr><td><code id="validate_questionnaire_gen_+3A_cov_matrix">cov_matrix</code></td>
<td>
<p>covariance matrix of YXW</p>
</td></tr>
<tr><td><code id="validate_questionnaire_gen_+3A_c_mean">c_mean</code></td>
<td>
<p>vector of means of all variables (YXW)</p>
</td></tr>
<tr><td><code id="validate_questionnaire_gen_+3A_c_sd">c_sd</code></td>
<td>
<p>vector of standard deviations of all variables (YXW)</p>
</td></tr>
</table>

<hr>
<h2 id='weight_responses'>Weight responses</h2><span id='topic+weight_responses'></span>

<h3>Description</h3>

<p>calculates sampling weights for the questionnaire responses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_responses(
  cluster_bg,
  n_obs,
  N,
  lvl,
  sublvl,
  previous_sublvl,
  sampling_method,
  cluster_labels,
  resp_labels,
  sum_pop,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_responses_+3A_cluster_bg">cluster_bg</code></td>
<td>
<p>dataset with background questionnaire</p>
</td></tr>
<tr><td><code id="weight_responses_+3A_n_obs">n_obs</code></td>
<td>
<p>list with the number of elements per level</p>
</td></tr>
<tr><td><code id="weight_responses_+3A_n">N</code></td>
<td>
<p>list of numeric vector with the population size of each *sampled* cluster element on each level</p>
</td></tr>
<tr><td><code id="weight_responses_+3A_lvl">lvl</code></td>
<td>
<p>number of the current level</p>
</td></tr>
<tr><td><code id="weight_responses_+3A_sublvl">sublvl</code></td>
<td>
<p>number of the current sublevel (element within level)</p>
</td></tr>
<tr><td><code id="weight_responses_+3A_previous_sublvl">previous_sublvl</code></td>
<td>
<p>number of the sublevel of the parent level</p>
</td></tr>
<tr><td><code id="weight_responses_+3A_sampling_method">sampling_method</code></td>
<td>
<p>can be &quot;SRS&quot; for Simple Random Sampling or &quot;PPS&quot; for Probabilities Proportional to Size</p>
</td></tr>
<tr><td><code id="weight_responses_+3A_cluster_labels">cluster_labels</code></td>
<td>
<p>character vector with the names of each cluster level</p>
</td></tr>
<tr><td><code id="weight_responses_+3A_resp_labels">resp_labels</code></td>
<td>
<p>character vector with the names of the questionnaire respondents on each level</p>
</td></tr>
<tr><td><code id="weight_responses_+3A_sum_pop">sum_pop</code></td>
<td>
<p>total population at each level (sampled or not)</p>
</td></tr>
<tr><td><code id="weight_responses_+3A_verbose">verbose</code></td>
<td>
<p>if 'TRUE', prints output messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input data frame ('cluster_bg') with three new columns for the sampling weights.
</p>

<hr>
<h2 id='whitelist_message'>Whitelist message</h2><span id='topic+whitelist_message'></span>

<h3>Description</h3>

<p>Prints out the sampled elements when cluster_gen is called with select. This function is analogous to cluster_message, but is more proper for random sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whitelist_message(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whitelist_message_+3A_w">w</code></td>
<td>
<p>whitelist</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
