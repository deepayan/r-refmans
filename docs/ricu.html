<!DOCTYPE html><html><head><title>Help for package ricu</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ricu}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_concept'><p>Internal item callback utilities</p></a></li>
<li><a href='#attach_src'><p>Data attach utilities</p></a></li>
<li><a href='#cbind_id_tbl'><p>ICU class data reshaping</p></a></li>
<li><a href='#change_id'><p>Switch between id types</p></a></li>
<li><a href='#col_renamer'><p>Internal utilities for ICU data classes</p></a></li>
<li><a href='#data'><p>ICU datasets</p></a></li>
<li><a href='#data_dir'><p>File system utilities</p></a></li>
<li><a href='#download_src'><p>Data download utilities</p></a></li>
<li><a href='#expand'><p>Time series utility functions</p></a></li>
<li><a href='#id_origin'><p>Data loading utilities</p></a></li>
<li><a href='#id_tbl'><p>Tabular ICU data classes</p></a></li>
<li><a href='#id_vars'><p>ICU class meta data utilities</p></a></li>
<li><a href='#import_src'><p>Data import utilities</p></a></li>
<li><a href='#load_concepts'><p>Load concept data</p></a></li>
<li><a href='#load_dictionary'><p>Load concept dictionaries</p></a></li>
<li><a href='#load_id'><p>Load data as <code>id_tbl</code> or <code>ts_tbl</code> objects</p></a></li>
<li><a href='#load_src'><p>Low level functions for loading data</p></a></li>
<li><a href='#load_src_cfg'><p>Load configuration for a data source</p></a></li>
<li><a href='#min_or_na'><p>Utility functions</p></a></li>
<li><a href='#msg_progress'><p>Message signaling nested with progress reporting</p></a></li>
<li><a href='#new_cncpt'><p>Data Concepts</p></a></li>
<li><a href='#new_itm'><p>Data items</p></a></li>
<li><a href='#new_src_cfg'><p>Internal utilities for working with data source configurations</p></a></li>
<li><a href='#new_src_tbl'><p>Data source environments</p></a></li>
<li><a href='#pafi'><p>Concept callback functions</p></a></li>
<li><a href='#prepare_query'><p>Internal utilities for <code>item</code>/<code>concept</code> objects</p></a></li>
<li><a href='#rename_cols'><p>ICU class data utilities</p></a></li>
<li><a href='#ricu-package'><p>ricu: Intensive Care Unit Data with R</p></a></li>
<li><a href='#secs'><p>Utilities for <code>difftime</code></p></a></li>
<li><a href='#sep3'><p>Sepsis 3 label</p></a></li>
<li><a href='#setup_src_data'><p>Data setup</p></a></li>
<li><a href='#sirs_score'><p>SIRS score label</p></a></li>
<li><a href='#sofa_score'><p>SOFA score label</p></a></li>
<li><a href='#stay_windows'><p>Stays</p></a></li>
<li><a href='#susp_inf'><p>Suspicion of infection label</p></a></li>
<li><a href='#transform_fun'><p>Item callback utilities</p></a></li>
<li><a href='#unclass_tbl'><p>Internal utilities for ICU data objects</p></a></li>
<li><a href='#write_psv'><p>Read and write utilities</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Intensive Care Unit Data with R</td>
</tr>
<tr>
<td>Description:</td>
<td>Focused on (but not exclusive to) data sets hosted on PhysioNet
    (<a href="https://physionet.org">https://physionet.org</a>), 'ricu' provides utilities for download, setup
    and access of intensive care unit (ICU) data sets. In addition to
    functions for running arbitrary queries against available data sets, a
    system for defining clinical concepts and encoding their representations
    in tabular ICU data is presented.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.6</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/eth-mds/ricu">https://github.com/eth-mds/ricu</a>, <a href="https://physionet.org">https://physionet.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eth-mds/ricu/issues">https://github.com/eth-mds/ricu/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, curl, assertthat, fst, readr, jsonlite, methods,
stats, prt (&ge; 0.1.2), tibble, backports, rlang, vctrs, cli (&ge;
2.1.0), fansi, openssl, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xml2, covr, testthat (&ge; 3.0.0), withr, mockthat, pkgload,
mimic.demo, eicu.demo, progress, knitr, rmarkdown, ggplot2,
cowplot, survival, forestmodel, rticles, kableExtra, units,
pdftools, magick, pillar</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://eth-mds.github.io/physionet-demo">https://eth-mds.github.io/physionet-demo</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-04 13:46:08 UTC; nbennett</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicolas Bennett [aut, cre],
  Drago Plecko [aut],
  Ida-Fong Ukor [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Bennett &lt;r@nbenn.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-04 18:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_concept'>Internal item callback utilities</h2><span id='topic+add_concept'></span><span id='topic+add_weight'></span><span id='topic+calc_dur'></span><span id='topic+combine_callbacks'></span>

<h3>Description</h3>

<p>The utility function <code>add_concept()</code> is exported for convenience when adding
external datasets and integrating concepts that require other concepts.
While this could be solves by defining a <code>rec_concpt</code>, in some scenarios
this might not be ideal, as it might be only required that <code>itm</code>
implementations for certain data sources require additional information.
Examples for this include vasopressor rates which might rely on patient
weight, and blood cell counts when expressed as ratio. For performance
reasons, the pulled in concept is internally cached, as this might be used
unchanged many times, when loading several concepts that need to pull in
the given concept. Persistence of cache is session-level and therefore this
utility is intended to be used somewhat sparingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_concept(x, env, concept, var_name = concept, aggregate = NULL)

add_weight(x, env, var_name = "weight")

calc_dur(x, val_var, min_var, max_var, grp_var = NULL)

combine_callbacks(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_concept_+3A_x">x</code></td>
<td>
<p>Object in loading</p>
</td></tr>
<tr><td><code id="add_concept_+3A_env">env</code></td>
<td>
<p>Data source environment as available as <code>env</code> in callback
functions</p>
</td></tr>
<tr><td><code id="add_concept_+3A_concept">concept</code></td>
<td>
<p>String valued concept name that will be loaded from the
default dictionary</p>
</td></tr>
<tr><td><code id="add_concept_+3A_var_name">var_name</code></td>
<td>
<p>String valued variable name</p>
</td></tr>
<tr><td><code id="add_concept_+3A_aggregate">aggregate</code></td>
<td>
<p>Forwarded to <code><a href="#topic+load_concepts">load_concepts()</a></code></p>
</td></tr>
<tr><td><code id="add_concept_+3A_val_var">val_var</code></td>
<td>
<p>String valued column name corresponding to the value variable</p>
</td></tr>
<tr><td><code id="add_concept_+3A_min_var">min_var</code>, <code id="add_concept_+3A_max_var">max_var</code></td>
<td>
<p>Column names denoting start and end times</p>
</td></tr>
<tr><td><code id="add_concept_+3A_grp_var">grp_var</code></td>
<td>
<p>Optional grouping variable (for example linking infusions)</p>
</td></tr>
<tr><td><code id="add_concept_+3A_...">...</code></td>
<td>
<p>Functions which will be successively applied</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> with the requested concept merged in.
</p>

<hr>
<h2 id='attach_src'>Data attach utilities</h2><span id='topic+attach_src'></span><span id='topic+attach_src.src_cfg'></span><span id='topic+attach_src.character'></span><span id='topic+detach_src'></span><span id='topic+setup_src_env'></span><span id='topic+setup_src_env.src_cfg'></span>

<h3>Description</h3>

<p>Making a dataset available to <code>ricu</code> consists of 3 steps: downloading
(<code><a href="#topic+download_src">download_src()</a></code>), importing (<code><a href="#topic+import_src">import_src()</a></code>) and attaching
(<code><a href="#topic+attach_src">attach_src()</a></code>). While downloading and importing are one-time procedures,
attaching of the dataset is repeated every time the package is loaded.
Briefly, downloading loads the raw dataset from the internet (most likely
in <code>.csv</code> format), importing consists of some preprocessing to make the
data available more efficiently and attaching sets up the data for use by
the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_src(x, ...)

## S3 method for class 'src_cfg'
attach_src(x, assign_env = NULL, data_dir = src_data_dir(x), ...)

## S3 method for class 'character'
attach_src(x, assign_env = NULL, data_dir = src_data_dir(x), ...)

detach_src(x)

setup_src_env(x, ...)

## S3 method for class 'src_cfg'
setup_src_env(x, data_dir = src_data_dir(x), link_env = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attach_src_+3A_x">x</code></td>
<td>
<p>Data source to attach</p>
</td></tr>
<tr><td><code id="attach_src_+3A_...">...</code></td>
<td>
<p>Forwarded to further calls to <code>attach_src()</code></p>
</td></tr>
<tr><td><code id="attach_src_+3A_assign_env">assign_env</code>, <code id="attach_src_+3A_link_env">link_env</code></td>
<td>
<p>Environment in which the data source will become
available</p>
</td></tr>
<tr><td><code id="attach_src_+3A_data_dir">data_dir</code></td>
<td>
<p>Directory used to look for <code><a href="fst.html#topic+fst">fst::fst()</a></code> files; <code>NULL</code> calls
<code><a href="#topic+data_dir">data_dir()</a></code> using the source name as <code>subdir</code> argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attaching a dataset sets up two types of S3 classes: a single <code>src_env</code>
object, containing as many <code>src_tbl</code> objects as tables are associated with
the dataset. A <code>src_env</code> is an environment with an <code>id_cfg</code> attribute, as
well as sub-classes as specified by the data source <code>class_prefix</code>
configuration setting (see <code><a href="#topic+load_src_cfg">load_src_cfg()</a></code>). All <code>src_env</code> objects created
by calling <code>attach_src()</code> represent environments that are direct
descendants of the <code>data</code> environment and are bound to the respective
dataset name within that environment. For more information on <code>src_env</code> and
<code>src_tbl</code> objects, refer to <code><a href="#topic+new_src_tbl">new_src_tbl()</a></code>.
</p>
<p>If set up correctly, it is not necessary for the user to directly call
<code>attach_src()</code>. When the package is loaded, the default data sources (see
<code><a href="#topic+auto_attach_srcs">auto_attach_srcs()</a></code>) are attached automatically. This default can be
controlled by setting as environment variable <code>RICU_SRC_LOAD</code> a comma
separated list of data source names before loading the library. Setting
this environment variable as
</p>
<div class="sourceCode"><pre>Sys.setenv(RICU_SRC_LOAD = "mimic_demo,eicu_demo")
</pre></div>
<p>will change the default of loading both MIMIC-III and eICU, alongside the
respective demo datasets, as well as HiRID and AUMC, to just the two demo
datasets. For setting an environment variable upon startup of the R
session, refer to <code><a href="base.html#topic+Startup">base::.First.sys()</a></code>.
</p>
<p>Attaching a dataset during package namespace loading will both instantiate
a corresponding <code>src_env</code> in the <code>data</code> environment and for convenience
also assign this object into the package namespace, such that for example
the MIMIC-III demo dataset not only is available as
<code style="white-space: pre;">&#8288;ricu::data::mimic_demo&#8288;</code>, but also as <code>ricu::mimic_demo</code> (or if the package
namespace is attached, simply as <code>mimic_demo</code>). Dataset attaching using
<code>attach_src()</code> does not need to happen during namespace loading, but can be
triggered by the user at any time. If such a convenience link as described
above is desired by the user, an environment such as <code>.GlobalEnv</code> has to be
passed as <code>assign_env</code> to <code>attach_src()</code>.
</p>
<p>Data sets are set up as <code>src_env</code> objects irrespective of whether all (or
any) of the required data is available. If some (or all) data is missing,
the user is asked for permission to download in interactive sessions and an
error is thrown in non-interactive sessions. Downloading demo datasets
requires no further information but access to full-scale datasets (even
though they are publicly available) is guarded by access credentials (see
<code><a href="#topic+download_src">download_src()</a></code>).
</p>
<p>While <code>attach_src()</code> provides the main entry point, <code>src_env</code> objects are
instantiated by the S3 generic function <code>setup_src_env()</code> and the wrapping
function serves to catch errors that might be caused by config file parsing
issues as to not break attaching of the package namespace. Apart form this,
<code>attach_src()</code> also provides the convenience linking into the package
namespace (or a user-specified environment) described above.
</p>
<p>A <code>src_env</code> object created by <code>setup_src_env()</code> does not directly contain
<code>src_tbl</code> objects bound to names, but rather an active binding (see
<code><a href="base.html#topic+bindenv">base::makeActiveBinding()</a></code>) per table. These active bindings check for
availability of required files and evaluate to corresponding <code>src_tbl</code>
objects if these checks are passed and ask for user input otherwise. As
<code>src_tbl</code> objects are intended to be read-only, assignment is not possible
except for the value <code>NULL</code> which resets the internally cached <code>src_tbl</code>
that is created on first successful access.
</p>


<h3>Value</h3>

<p>Both <code>attach_src()</code> and <code>setup_src_env()</code> are called for side
effects and therefore return invisibly. While <code>attach_src()</code> returns <code>NULL</code>,
<code>setup_src_env()</code> returns the newly created <code>src_env</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

Sys.setenv(RICU_SRC_LOAD = "")
library(ricu)

ls(envir = data)
exists("mimic_demo")

attach_src("mimic_demo", assign_env = .GlobalEnv)

ls(envir = data)
exists("mimic_demo")

mimic_demo


## End(Not run)

</code></pre>

<hr>
<h2 id='cbind_id_tbl'>ICU class data reshaping</h2><span id='topic+cbind_id_tbl'></span><span id='topic+rbind_id_tbl'></span><span id='topic+merge.id_tbl'></span><span id='topic+split.id_tbl'></span><span id='topic+rbind_lst'></span><span id='topic+merge_lst'></span><span id='topic+unmerge'></span>

<h3>Description</h3>

<p>Utilities for reshaping <code>id_tbl</code> and <code>ts_tbl</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind_id_tbl(
  ...,
  keep.rownames = FALSE,
  check.names = FALSE,
  key = NULL,
  stringsAsFactors = FALSE
)

rbind_id_tbl(..., use.names = TRUE, fill = FALSE, idcol = NULL)

## S3 method for class 'id_tbl'
merge(x, y, by = NULL, by.x = NULL, by.y = NULL, ...)

## S3 method for class 'id_tbl'
split(x, ...)

rbind_lst(x, ...)

merge_lst(x)

unmerge(x, col_groups = as.list(data_vars(x)), by = meta_vars(x), na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind_id_tbl_+3A_...">...</code></td>
<td>
<p>Objects to combine</p>
</td></tr>
<tr><td><code id="cbind_id_tbl_+3A_keep.rownames">keep.rownames</code>, <code id="cbind_id_tbl_+3A_check.names">check.names</code>, <code id="cbind_id_tbl_+3A_key">key</code>, <code id="cbind_id_tbl_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Forwarded to
<a href="data.table.html#topic+data.table">data.table::data.table</a></p>
</td></tr>
<tr><td><code id="cbind_id_tbl_+3A_use.names">use.names</code>, <code id="cbind_id_tbl_+3A_fill">fill</code>, <code id="cbind_id_tbl_+3A_idcol">idcol</code></td>
<td>
<p>Forwarded to <a href="data.table.html#topic+rbindlist">data.table::rbindlist</a></p>
</td></tr>
<tr><td><code id="cbind_id_tbl_+3A_x">x</code>, <code id="cbind_id_tbl_+3A_y">y</code></td>
<td>
<p>Objects to combine</p>
</td></tr>
<tr><td><code id="cbind_id_tbl_+3A_by">by</code>, <code id="cbind_id_tbl_+3A_by.x">by.x</code>, <code id="cbind_id_tbl_+3A_by.y">by.y</code></td>
<td>
<p>Column names used for combining data</p>
</td></tr>
<tr><td><code id="cbind_id_tbl_+3A_col_groups">col_groups</code></td>
<td>
<p>A list of character vectors defining the grouping of
non-by columns</p>
</td></tr>
<tr><td><code id="cbind_id_tbl_+3A_na_rm">na_rm</code></td>
<td>
<p>Logical flag indicating whether to remove rows that have all
missing entries in the respective <code>col_groups</code> group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <code>id_tbl</code> or <code>ts_tbl</code> objects (depending on inputs) or lists
thereof in case of <code>split()</code> and <code>unmerge()</code>.
</p>

<hr>
<h2 id='change_id'>Switch between id types</h2><span id='topic+change_id'></span><span id='topic+upgrade_id'></span><span id='topic+downgrade_id'></span><span id='topic+upgrade_id.ts_tbl'></span><span id='topic+upgrade_id.id_tbl'></span><span id='topic+downgrade_id.ts_tbl'></span><span id='topic+downgrade_id.id_tbl'></span>

<h3>Description</h3>

<p>ICU datasets such as MIMIC-III or eICU typically represent patients by
multiple ID systems such as patient IDs, hospital stay IDs and ICU
admission IDs. Even if the raw data is available in only one such ID
system, given a mapping of IDs alongside start and end times, it is
possible to convert data from one ID system to another. The function
<code>change_id()</code> provides such a conversion utility, internally either
calling <code>upgrade_id()</code> when moving to an ID system with higher cardinality
and <code>downgrade_id()</code> when the target ID system is of lower cardinality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_id(x, target_id, src, ..., keep_old_id = TRUE, id_type = FALSE)

upgrade_id(x, target_id, src, cols = time_vars(x), ...)

downgrade_id(x, target_id, src, cols = time_vars(x), ...)

## S3 method for class 'ts_tbl'
upgrade_id(x, target_id, src, cols = time_vars(x), ...)

## S3 method for class 'id_tbl'
upgrade_id(x, target_id, src, cols = time_vars(x), ...)

## S3 method for class 'ts_tbl'
downgrade_id(x, target_id, src, cols = time_vars(x), ...)

## S3 method for class 'id_tbl'
downgrade_id(x, target_id, src, cols = time_vars(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_id_+3A_x">x</code></td>
<td>
<p><code>icu_tbl</code> object for which to make the id change</p>
</td></tr>
<tr><td><code id="change_id_+3A_target_id">target_id</code></td>
<td>
<p>The destination id name</p>
</td></tr>
<tr><td><code id="change_id_+3A_src">src</code></td>
<td>
<p>Passed to <code><a href="#topic+as_id_cfg">as_id_cfg()</a></code> and <code><a href="#topic+as_src_env">as_src_env()</a></code></p>
</td></tr>
<tr><td><code id="change_id_+3A_...">...</code></td>
<td>
<p>Passed to <code>upgrade_id()</code>/<code>downgrade_id()</code></p>
</td></tr>
<tr><td><code id="change_id_+3A_keep_old_id">keep_old_id</code></td>
<td>
<p>Logical flag indicating whether to keep the previous ID
column</p>
</td></tr>
<tr><td><code id="change_id_+3A_id_type">id_type</code></td>
<td>
<p>Logical flag indicating whether <code>target_id</code> is specified as
ID name (e.g. <code>icustay_id</code> on MIMIC) or ID type (e.g. <code>icustay</code>)</p>
</td></tr>
<tr><td><code id="change_id_+3A_cols">cols</code></td>
<td>
<p>Column names that require time-adjustment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to provide ID system conversion for a data source, the (internal)
function <code><a href="#topic+id_map">id_map()</a></code> must be able to construct an ID mapping for that data
source. Constructing such a mapping can be expensive w.r.t. the frequency
it might be re-used and therefore, <code><a href="#topic+id_map">id_map()</a></code> provides caching
infrastructure. The mapping itself is constructed by the (internal)
function <code><a href="#topic+id_map_helper">id_map_helper()</a></code>, which is expected to provide source and
destination ID columns as well as start and end columns corresponding to
the destination ID, relative to the source ID system. In the following
example, we request for <code>mimic_demo</code>, with ICU stay IDs as source and
hospital admissions as destination IDs.
</p>
<div class="sourceCode r"><pre>id_map_helper(mimic_demo, "icustay_id", "hadm_id")
#&gt; # An `id_tbl`: 136 x 4
#&gt; # Id var:      `icustay_id`
#&gt;     icustay_id hadm_id hadm_id_start hadm_id_end
#&gt;          &lt;int&gt;   &lt;int&gt; &lt;drtn&gt;        &lt;drtn&gt;
#&gt; 1       201006  198503  -3290 mins    9114 mins
#&gt; 2       201204  114648     -2 mins    6949 mins
#&gt; 3       203766  126949  -1336 mins    8818 mins
#&gt; 4       204132  157609     -1 mins   10103 mins
#&gt; 5       204201  177678   -368 mins    9445 mins
#&gt; ...
#&gt; 132     295043  170883 -10413 mins   31258 mins
#&gt; 133     295741  176805     -1 mins    3153 mins
#&gt; 134     296804  110244  -1294 mins    4599 mins
#&gt; 135     297782  167612     -1 mins     207 mins
#&gt; 136     298685  151323     -1 mins   19082 mins
#&gt; # i 131 more rows
</pre></div>
<p>Both start and end columns encode the hospital admission windows relative
to each corresponding ICU stay start time. It therefore comes as no
surprise that most start times are negative (hospital admission typically
occurs before ICU stay start time), while end times are often days in the
future (as hospital discharge typically occurs several days after ICU
admission).
</p>
<p>In order to use the ID conversion infrastructure offered by <code>ricu</code> for a
new dataset, it typically suffices to provide an <code>id_cfg</code> entry in the
source configuration (see <code><a href="#topic+load_src_cfg">load_src_cfg()</a></code>), outlining the available ID
systems alongside an ordering, as well as potentially a class specific
implementation of <code><a href="#topic+id_map_helper">id_map_helper()</a></code> for the given source class, specifying
the corresponding time windows in 1 minute resolution (for every possible
pair of IDs).
</p>
<p>While both up- and downgrades for <code>id_tbl</code> objects, as well as downgrades
for <code>ts_tbl</code> objects are simple merge operations based on the ID mapping
provided by <code><a href="#topic+id_map">id_map()</a></code>, ID upgrades for <code>ts_tbl</code> objects are slightly more
involved. As an example, consider the following setting: we have <code>data</code>
associated with <code>hadm_id</code> IDs and times relative to hospital admission:
</p>
<div class="sourceCode"><pre>               1      2       3        4       5       6        7      8
data        ---*------*-------*--------*-------*-------*--------*------*---
               3h    10h     18h      27h     35h     43h      52h    59h

                                         HADM_1
            0h     7h                26h        37h             53h      62h
hadm_id     |-------------------------------------------------------------|
icustay_id         |------------------|          |---------------|
                   0h                19h         0h             16h
                           ICU_1                       ICU_2
</pre></div>
<p>The mapping of data points from <code>hadm_id</code> to <code>icustay_id</code> is created as
follows: ICU stay end times mark boundaries and all data that is recorded
after the last ICU stay ended is assigned to the last ICU stay. Therefore
data points 1-3 are assigned to <code>ICU_1</code>, while 4-8 are assigned to <code>ICU_2</code>.
Times have to be shifted as well, as timestamps are expected to be relative
to the current ID system. Data points 1-3 therefore are assigned to time
stamps -4h, 3h and 11h, while data points 4-8 are assigned to -10h, -2h,
6h, 15h and 22h. Implementation-wise, the mapping is computed using an
efficient <code>data.table</code> rolling join.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>x</code> with modified IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mimic.demo)) {
tbl &lt;- mimic_demo$labevents
dat &lt;- load_difftime(tbl, itemid == 50809, c("charttime", "valuenum"))
dat

change_id(dat, "icustay_id", tbl, keep_old_id = FALSE)
}

</code></pre>

<hr>
<h2 id='col_renamer'>Internal utilities for ICU data classes</h2><span id='topic+col_renamer'></span>

<h3>Description</h3>

<p>Internal utilities for ICU data classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_renamer(x, new, old = colnames(x), skip_absent = FALSE, by_ref = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_renamer_+3A_x">x</code></td>
<td>
<p>Object to query</p>
</td></tr>
<tr><td><code id="col_renamer_+3A_new">new</code>, <code id="col_renamer_+3A_old">old</code></td>
<td>
<p>Replacement names and existing column names for renaming
columns</p>
</td></tr>
<tr><td><code id="col_renamer_+3A_skip_absent">skip_absent</code></td>
<td>
<p>Logical flag for ignoring non-existent column names</p>
</td></tr>
<tr><td><code id="col_renamer_+3A_by_ref">by_ref</code></td>
<td>
<p>Logical flag indicating whether to perform the operation by
reference</p>
</td></tr>
</table>

<hr>
<h2 id='data'>ICU datasets</h2><span id='topic+data'></span><span id='topic+mimic'></span><span id='topic+mimic_demo'></span><span id='topic+eicu'></span><span id='topic+eicu_demo'></span><span id='topic+hirid'></span><span id='topic+aumc'></span><span id='topic+miiv'></span>

<h3>Description</h3>

<p>The <a href="https://lcp.mit.edu/index.html">Laboratory for Computational Physiology </a> (LCP) at MIT hosts several large-scale
databases of hospital intensive care units (ICUs), two of which can be
either downloaded in full (<a href="https://physionet.org/content/mimiciii/1.4/">MIMIC-III </a> and <a href="https://physionet.org/content/eicu-crd/2.0/">eICU </a>) or as demo subsets
(<a href="https://physionet.org/content/mimiciii-demo/1.4/">MIMIC-III demo</a> and
<a href="https://physionet.org/content/eicu-crd-demo/2.0/">eICU demo</a>), while a
third data set is available only in full (<a href="https://physionet.org/content/hirid/1.0/">HiRID </a>). While demo data sets are
freely available, full download requires credentialed access which can be
gained by applying for an account with <a href="https://physionet.org/register/">PhysioNet </a>. Even though registration is required,
the described datasets are all publicly available. With <a href="https://amsterdammedicaldatascience.nl/#amsterdamumcdb">AmsterdamUMCdb </a>, a non-PhysioNet
hosted data source is available as well. As with the PhysioNet datasets,
access is public but has to be granted by the data collectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data
</code></pre>


<h3>Format</h3>

<p>The exported <code>data</code> environment contains all datasets that have been made
available to <code>ricu</code>. For datasets that are attached during package loading
(see <code><a href="#topic+attach_src">attach_src()</a></code>), shortcuts to the datasets are set up in the package
namespace, allowing the object <code style="white-space: pre;">&#8288;ricu::data::mimic_demo&#8288;</code> to be accessed as
<code>ricu::mimic_demo</code> (or in case the package namespace has been attached,
simply as <code>mimic_demo</code>). Datasets that are made available after the package
namespace has been sealed will have their proxy object by default located
in <code>.GlobalEnv</code>. Datasets are represented by <code><a href="#topic+new_src_env">src_env</a></code>
objects, while individual tables are <code><a href="#topic+new_src_tbl">src_tbl</a></code> and do not
represent in-memory data, but rather data stored on disk, subsets of which
can be loaded into memory.
</p>


<h3>Details</h3>

<p>Setting up a dataset for use with <code>ricu</code> requires a configuration object.
For the included datasets, configuration can be loaded from
</p>
<div class="sourceCode"><pre>system.file("extdata", "config", "data-sources.json", package = "ricu")
</pre></div>
<p>by calling <code><a href="#topic+load_src_cfg">load_src_cfg()</a></code> and for dataset that are external to <code>ricu</code>,
additional configuration can be made available by setting the environment
variable <code>RICU_CONFIG_PATH</code> (for more information, refer to
<code><a href="#topic+load_src_cfg">load_src_cfg()</a></code>). Using the dataset configuration object, data can be
downloaded (<code><a href="#topic+download_src">download_src()</a></code>), imported (<code><a href="#topic+import_src">import_src()</a></code>) and attached
(<code><a href="#topic+attach_src">attach_src()</a></code>). While downloading and importing are one-time procedures,
attaching of the dataset is repeated every time the package is loaded.
Briefly, downloading loads the raw dataset from the internet (most likely
in <code>.csv</code> format), importing consists of some preprocessing to make the
data available more efficiently (by converting it to <code><a href="fst.html#topic+fst">.fst</a></code>
format) and attaching sets up the data for use by the package. For more
information on the individual steps, refer to the respective documentation
pages.
</p>
<p>A dataset that has been successfully made available can interactively be
explored by typing its name into the console and individual tables can be
inspected using the <code>$</code> function. For example for the MIMIC-III demo
dataset and the <code>icustays</code> table, this gives
</p>
<div class="sourceCode r"><pre>mimic_demo
#&gt; &lt;mimic_demo_env[25]&gt;
#&gt;         admissions            callout         caregivers        chartevents 
#&gt;         [129 x 19]          [77 x 24]        [7,567 x 4]     [758,355 x 15] 
#&gt;          cptevents              d_cpt    d_icd_diagnoses   d_icd_procedures 
#&gt;       [1,579 x 12]          [134 x 9]       [14,567 x 4]        [3,882 x 4] 
#&gt;            d_items         d_labitems     datetimeevents      diagnoses_icd 
#&gt;      [12,487 x 10]          [753 x 6]      [15,551 x 14]        [1,761 x 5] 
#&gt;           drgcodes           icustays     inputevents_cv     inputevents_mv 
#&gt;          [297 x 8]         [136 x 12]      [34,799 x 22]      [13,224 x 31] 
#&gt;          labevents microbiologyevents       outputevents           patients 
#&gt;       [76,074 x 9]       [2,003 x 16]      [11,320 x 13]          [100 x 8] 
#&gt;      prescriptions procedureevents_mv     procedures_icd           services 
#&gt;      [10,398 x 19]         [753 x 25]          [506 x 5]          [163 x 6] 
#&gt;          transfers 
#&gt;         [524 x 13]
mimic_demo$icustays
#&gt; # &lt;mimic_tbl&gt;: [136 x 12]
#&gt; # ID options:  subject_id (patient) &lt; hadm_id (hadm) &lt; icustay_id (icustay)
#&gt; # Defaults:    `intime` (index), `last_careunit` (val)
#&gt; # Time vars:   `intime`, `outtime`
#&gt;     row_id subject_id hadm_id icustay_id dbsource   first_careunit last_careunit
#&gt;      &lt;int&gt;      &lt;int&gt;   &lt;int&gt;      &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;          &lt;chr&gt;
#&gt; 1    12742      10006  142345     206504 carevue    MICU           MICU
#&gt; 2    12747      10011  105331     232110 carevue    MICU           MICU
#&gt; 3    12749      10013  165520     264446 carevue    MICU           MICU
#&gt; 4    12754      10017  199207     204881 carevue    CCU            CCU
#&gt; 5    12755      10019  177759     228977 carevue    MICU           MICU
#&gt; ...
#&gt; 132  42676      44083  198330     286428 metavision CCU            CCU
#&gt; 133  42691      44154  174245     217724 metavision MICU           MICU
#&gt; 134  42709      44212  163189     239396 metavision MICU           MICU
#&gt; 135  42712      44222  192189     238186 metavision CCU            CCU
#&gt; 136  42714      44228  103379     217992 metavision SICU           SICU
#&gt; # i 131 more rows
#&gt; # i 5 more variables: first_wardid &lt;int&gt;, last_wardid &lt;int&gt;, intime &lt;dttm&gt;,
#&gt; #   outtime &lt;dttm&gt;, los &lt;dbl&gt;
</pre></div>
<p>Table subsets can be loaded into memory for example using the
<code><a href="base.html#topic+subset">base::subset()</a></code> function, which uses non-standard evaluation (NSE) to
determine a row-subsetting. This design choice stems form the fact that
some tables can have on the order of 10^8 rows, which makes loading full
tables into memory an expensive operation. Table subsets loaded into
memory are represented as <code><a href="data.table.html#topic+data.table">data.table</a></code> objects.
Extending the above example, if only ICU stays corresponding to the patient
with <code>subject_id == 10124</code> are of interest, the respective data can be
loaded as
</p>
<div class="sourceCode r"><pre>subset(mimic_demo$icustays, subject_id == 10124)
#&gt;    row_id subject_id hadm_id icustay_id dbsource first_careunit last_careunit
#&gt; 1:  12863      10124  182664     261764  carevue           MICU          MICU
#&gt; 2:  12864      10124  170883     222779  carevue           MICU          MICU
#&gt; 3:  12865      10124  170883     295043  carevue            CCU           CCU
#&gt; 4:  12866      10124  170883     237528  carevue           MICU          MICU
#&gt;    first_wardid last_wardid              intime             outtime     los
#&gt; 1:           23          23 2192-03-29 10:46:51 2192-04-01 06:36:00  2.8258
#&gt; 2:           50          50 2192-04-16 20:58:32 2192-04-20 08:51:28  3.4951
#&gt; 3:            7           7 2192-04-24 02:29:49 2192-04-26 23:59:45  2.8958
#&gt; 4:           23          23 2192-04-30 14:50:44 2192-05-15 23:34:21 15.3636
</pre></div>
<p>Much care has been taken to make <code>ricu</code> extensible to new datasets. For
example the publicly available ICU database <a href="https://amsterdammedicaldatascience.nl/amsterdamumcdb/">AmsterdamUMCdb </a>
provided by the Amsterdam University Medical Center, currently is not part
of the core datasets of <code>ricu</code>, but code for integrating this dataset is
available on <a href="https://github.com/eth-mds/aumc">github</a>.
</p>


<h3>MIMIC-III</h3>

<p>The Medical Information Mart for Intensive Care
(<a href="https://physionet.org/content/mimiciii/">MIMIC</a>) database holds
detailed clinical data from roughly 60,000 patient stays in Beth Israel
Deaconess Medical Center (BIDMC) intensive care units between 2001 and 2012.
The database includes information such as demographics, vital sign
measurements made at the bedside (~1 data point per hour), laboratory test
results, procedures, medications, caregiver notes, imaging reports, and
mortality (both in and out of hospital). For further information, please
refer to the <a href="https://mimic.mit.edu/docs/iii/">MIMIC-III documentation</a>.
</p>
<p>The corresponding
<a href="https://physionet.org/content/mimiciii-demo/">demo dataset</a>
contains the full data of a randomly selected subset of 100 patients from
the patient cohort with conformed in-hospital mortality. The only notable
data omission is the <code>noteevents</code> table, which contains unstructured text
reports on patients.
</p>


<h3>eICU</h3>

<p>More recently, Philips Healthcare and LCP began assembling the <a href="https://physionet.org/content/eicu-crd/2.0/">eICU Collaborative Research Database </a> as a multi-center resource
for ICU data. Combining data of several critical care units throughout the
continental United States from the years 2014 and 2015, this database
contains de-identified health data associated with over 200,000 admissions,
including vital sign measurements, care plan documentation, severity of
illness measures, diagnosis information, and treatment information. For
further information, please refer to the <a href="https://eicu-crd.mit.edu/about/eicu/">eICU documentation </a>.
</p>
<p>For the <a href="https://physionet.org/content/eicu-crd-demo/2.0/">demo subset</a>,
data associated with ICU stays for over 2,500 unit stays selected from 20
of the larger hospitals is included. An important caveat that applied to the
eICU-based datasets is considerable variability among the large number of
hospitals in terms of data availability.
</p>


<h3>HiRID</h3>

<p>Moving to higher time-resolution, <a href="https://physionet.org/content/hirid/1.0/">HiRID </a> is a freely accessible critical
care dataset containing data relating to almost 34,000 patient admissions
to the Department of Intensive Care Medicine of the Bern University
Hospital, Switzerland. The dataset contains de-identified demographic
information and a total of 681 routinely collected physiological variables,
diagnostic test results and treatment parameters, collected during the
period from January 2008 to June 2016. Dependent on the type of measurement,
time resolution can be on the order of 2 minutes.
</p>


<h3>AmsterdamUMCdb</h3>

<p>With similar time-resolution (for vital-sign measurements) as HiRID,
<a href="https://amsterdammedicaldatascience.nl/#amsterdamumcdb">AmsterdamUMCdb</a>
contains data from 23,000 admissions of adult patients from 2003-2016 to
the department of Intensive Care, of Amsterdam University Medical Center.
In total, nearly 10^9^ individual observations consisting of vitals signs,
clinical scoring systems, device data and lab results data, as well as
nearly 5*10^6^ million medication entries, alongside de-identified
demographic information corresponding to the 20,000 individual patients
is spread over 7 tables.
</p>


<h3>MIMIC-IV</h3>

<p>With the recent v1.0 release of MIMIC-IV, experimental support has been
added in <code>ricu</code>. Building on the success of MIMIC-III, this next iteration
contains data on patients admitted to an ICU or the emergency department
between 2008 - 2019 at BIDMC. Therefore, relative to MIMIC-III, patients
admitted prior to 2008 (whose data is stored in a CareVue-based system) has
been removed, while data onward of 2012 has been added. This simplifies
data queries considerably, as the CareVue/MetaVision data split in MIMIC-III
no longer applies. While addition of ED data is planned, this is not part
of the initial v1.0 release and currently is not supported by <code>ricu</code>. For
further information, please refer to the <a href="https://mimic.mit.edu/docs/iii/">MIMIC-III documentation </a>.
</p>


<h3>References</h3>

<p>Johnson, A., Pollard, T., &amp; Mark, R. (2016). MIMIC-III Clinical Database
(version 1.4). PhysioNet. https://doi.org/10.13026/C2XW26.
</p>
<p>MIMIC-III, a freely accessible critical care database. Johnson AEW, Pollard
TJ, Shen L, Lehman L, Feng M, Ghassemi M, Moody B, Szolovits P, Celi LA,
and Mark RG. Scientific Data (2016). DOI: 10.1038/sdata.2016.35.
</p>
<p>Johnson, A., Pollard, T., Badawi, O., &amp; Raffa, J. (2019). eICU
Collaborative Research Database Demo (version 2.0). PhysioNet.
https://doi.org/10.13026/gxmm-es70.
</p>
<p>The eICU Collaborative Research Database, a freely available multi-center
database for critical care research. Pollard TJ, Johnson AEW, Raffa JD,
Celi LA, Mark RG and Badawi O. Scientific Data (2018). DOI:
http://dx.doi.org/10.1038/sdata.2018.178.
</p>
<p>Faltys, M., Zimmermann, M., Lyu, X., Hüser, M., Hyland, S., Rätsch, G., &amp;
Merz, T. (2020). HiRID, a high time-resolution ICU dataset (version 1.0).
PhysioNet. https://doi.org/10.13026/hz5m-md48.
</p>
<p>Hyland, S.L., Faltys, M., Hüser, M. et al. Early prediction of circulatory
failure in the intensive care unit using machine learning. Nat Med 26,
364–373 (2020). https://doi.org/10.1038/s41591-020-0789-4
</p>
<p>Thoral PJ, Peppink JM, Driessen RH, et al (2020) AmsterdamUMCdb: The First
Freely Accessible European Intensive Care Database from the ESICM Data
Sharing Initiative. https://www.amsterdammedicaldatascience.nl.
</p>
<p>Elbers, Dr. P.W.G. (Amsterdam UMC) (2019): AmsterdamUMCdb v1.0.2. DANS.
https://doi.org/10.17026/dans-22u-f8vd
</p>
<p>Johnson, A., Bulgarelli, L., Pollard, T., Horng, S., Celi, L. A., &amp; Mark, R.
(2021). MIMIC-IV (version 1.0). PhysioNet.
https://doi.org/10.13026/s6n6-xd98.
</p>
<p>Goldberger, A., Amaral, L., Glass, L., Hausdorff, J., Ivanov, P. C., Mark,
R., ... &amp; Stanley, H. E. (2000). PhysioBank, PhysioToolkit, and PhysioNet:
Components of a new research resource for complex physiologic signals.
Circulation (Online). 101 (23), pp. e215–e220.
</p>

<hr>
<h2 id='data_dir'>File system utilities</h2><span id='topic+data_dir'></span><span id='topic+src_data_dir'></span><span id='topic+auto_attach_srcs'></span><span id='topic+config_paths'></span><span id='topic+get_config'></span><span id='topic+set_config'></span>

<h3>Description</h3>

<p>Determine the location where to place data meant to persist between
individual sessions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_dir(subdir = NULL, create = TRUE)

src_data_dir(srcs)

auto_attach_srcs()

config_paths()

get_config(name, cfg_dirs = config_paths(), combine_fun = c, ...)

set_config(x, name, dir = file.path("inst", "extdata", "config"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_dir_+3A_subdir">subdir</code></td>
<td>
<p>A string specifying a directory that will be made sure to
exist below the data directory.</p>
</td></tr>
<tr><td><code id="data_dir_+3A_create">create</code></td>
<td>
<p>Logical flag indicating whether to create the specified
directory</p>
</td></tr>
<tr><td><code id="data_dir_+3A_srcs">srcs</code></td>
<td>
<p>Character vector of data source names, an object for which an
<code>src_name()</code> method is defined or an arbitrary-length list thereof.</p>
</td></tr>
<tr><td><code id="data_dir_+3A_name">name</code></td>
<td>
<p>File name of the configuration file (<code>.json</code> will be appended)</p>
</td></tr>
<tr><td><code id="data_dir_+3A_cfg_dirs">cfg_dirs</code></td>
<td>
<p>Character vector of directories searched for config files</p>
</td></tr>
<tr><td><code id="data_dir_+3A_combine_fun">combine_fun</code></td>
<td>
<p>If multiple files are found, a function for combining
returned lists</p>
</td></tr>
<tr><td><code id="data_dir_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="jsonlite.html#topic+read_json">jsonlite::read_json()</a></code> or <code><a href="jsonlite.html#topic+read_json">jsonlite::write_json()</a></code></p>
</td></tr>
<tr><td><code id="data_dir_+3A_x">x</code></td>
<td>
<p>Object to be written</p>
</td></tr>
<tr><td><code id="data_dir_+3A_dir">dir</code></td>
<td>
<p>Directory to write the file to (created if non-existent)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For data, the default location depends on the operating system as</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Platform</strong> </td><td style="text-align: left;"> <strong>Location</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Linux </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;~/.local/share/ricu&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   macOS </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;~/Library/Application Support/ricu&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Windows </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;%LOCALAPPDATA%/ricu&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If the default storage directory does not exists, it will only be created
upon user consent (requiring an interactive session).
</p>
<p>The environment variable <code>RICU_DATA_PATH</code> can be used to overwrite the
default location. If desired, this variable can be set in an R startup file
to make it apply to all R sessions. For example, it could be set within:
</p>

<ul>
<li><p> A project-local <code>.Renviron</code>;
</p>
</li>
<li><p> The user-level <code>.Renviron</code>;
</p>
</li>
<li><p> A file at <code style="white-space: pre;">&#8288;$(R RHOME)/etc/Renviron.site&#8288;</code>.
</p>
</li></ul>

<p>Any directory specified as environment variable will recursively be created.
</p>
<p>Data source directories typically are sub-directories to <code>data_dir()</code> named
the same as the respective dataset. For demo datasets corresponding to
<code>mimic</code> and <code>eicu</code>, file location however deviates from this scheme. The
function <code>src_data_dir()</code> is used to determine the expected data location
of a given dataset.
</p>
<p>Configuration files used both for data source configuration, as well as for
dictionary definitions potentially involve multiple files that are read and
merged. For that reason, <code>get_config()</code> will iterate over directories
passed as <code>cfg_dirs</code> and look for the specified file (with suffix <code>.json</code>
appended and might be missing in some of the queried directories). All
found files are read by <code><a href="jsonlite.html#topic+read_json">jsonlite::read_json()</a></code> and the resulting lists are
combined by reduction with the binary function passed as <code>combine_fun</code>.
</p>
<p>With default arguments, <code>get_config()</code> will simply concatenate lists
corresponding to files found in the default config locations as returned by
<code>config_paths()</code>: first the directory specified by the environment variable
<code>RICU_CONFIG_PATH</code> (if set), followed by the directory at
</p>
<div class="sourceCode"><pre>system.file("extdata", "config", package = "ricu")
</pre></div>
<p>Further arguments are passed to <code><a href="jsonlite.html#topic+read_json">jsonlite::read_json()</a></code>, which is called
with slightly modified defaults: <code>simplifyVector = TRUE</code>,
<code>simplifyDataFrame = FALSE</code> and <code>simplifyMatrix = FALSE</code>.
</p>
<p>The utility function <code>set_config()</code> writes the list passed as <code>x</code> to file
<code>dir/name.json</code>, using <code><a href="jsonlite.html#topic+read_json">jsonlite::write_json()</a></code> also with slightly modified
defaults (which can be overridden by passing arguments as <code>...</code>): <code>null = "null"</code>, <code>auto_unbox = TRUE</code> and <code>pretty = TRUE</code>.
</p>
<p>Whenever the package namespace is attached, a summary of dataset
availability is printed using the utility functions <code>auto_attach_srcs()</code>
and <code>src_data_avail()</code>. While the former simply returns a character vector
of data sources that are configures for automatically being set up on
package loading, the latter returns a summary of the number of available
tables per dataset.m Finally, <code>is_data_avail()</code> returns a named logical
vector indicating which data sources have all required data available.
</p>


<h3>Value</h3>

<p>Functions <code>data_dir()</code>, <code>src_data_dir()</code> and <code>config_paths()</code> return
file paths as character vectors, <code>auto_attach_srcs()</code> returns a character
vector of data source names, <code>src_data_avail()</code> returns a <code>data.frame</code>
describing availability of data sources and <code>is_data_avail()</code> a named
logical vector. Configuration utilities <code>get_config()</code> and <code>set_config()</code>
read and write list objects to/from JSON format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sys.setenv(RICU_DATA_PATH = tempdir())
identical(data_dir(), tempdir())

dir.exists(file.path(tempdir(), "some_subdir"))
some_subdir &lt;- data_dir("some_subdir")
dir.exists(some_subdir)

cfg &lt;- get_config("concept-dict")

identical(
  cfg,
  get_config("concept-dict",
             system.file("extdata", "config", package = "ricu"))
)

</code></pre>

<hr>
<h2 id='download_src'>Data download utilities</h2><span id='topic+download_src'></span><span id='topic+download_src.src_cfg'></span><span id='topic+download_src.aumc_cfg'></span><span id='topic+download_src.character'></span>

<h3>Description</h3>

<p>Making a dataset available to <code>ricu</code> consists of 3 steps: downloading
(<code><a href="#topic+download_src">download_src()</a></code>), importing (<code><a href="#topic+import_src">import_src()</a></code>) and attaching
(<code><a href="#topic+attach_src">attach_src()</a></code>). While downloading and importing are one-time procedures,
attaching of the dataset is repeated every time the package is loaded.
Briefly, downloading loads the raw dataset from the internet (most likely
in <code>.csv</code> format), importing consists of some preprocessing to make the
data available more efficiently (by converting it to <code><a href="fst.html#topic+fst">.fst</a></code>
format) and attaching sets up the data for use by the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_src(x, data_dir = src_data_dir(x), ...)

## S3 method for class 'src_cfg'
download_src(x, data_dir = src_data_dir(x), tables = NULL, force = FALSE, ...)

## S3 method for class 'aumc_cfg'
download_src(
  x,
  data_dir = src_data_dir(x),
  tables = NULL,
  force = FALSE,
  token = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'character'
download_src(
  x,
  data_dir = src_data_dir(x),
  tables = NULL,
  force = FALSE,
  user = NULL,
  pass = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_src_+3A_x">x</code></td>
<td>
<p>Object specifying the source configuration</p>
</td></tr>
<tr><td><code id="download_src_+3A_data_dir">data_dir</code></td>
<td>
<p>Destination directory where the downloaded data is written
to.</p>
</td></tr>
<tr><td><code id="download_src_+3A_...">...</code></td>
<td>
<p>Generic consistency</p>
</td></tr>
<tr><td><code id="download_src_+3A_tables">tables</code></td>
<td>
<p>Character vector specifying the tables to download. If
<code>NULL</code>, all available tables are downloaded.</p>
</td></tr>
<tr><td><code id="download_src_+3A_force">force</code></td>
<td>
<p>Logical flag; if <code>TRUE</code>, existing data will be re-downloaded</p>
</td></tr>
<tr><td><code id="download_src_+3A_token">token</code></td>
<td>
<p>Download token for AmsterdamUMCdb (see 'Details')</p>
</td></tr>
<tr><td><code id="download_src_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag indicating whether to print progress information</p>
</td></tr>
<tr><td><code id="download_src_+3A_user">user</code>, <code id="download_src_+3A_pass">pass</code></td>
<td>
<p>PhysioNet credentials; if <code>NULL</code> and environment
variables <code>RICU_PHYSIONET_USER</code>/<code>RICU_PHYSIONET_PASS</code> are not set, user
input is required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Downloads by <code>ricu</code> are focused data hosted by
<a href="https://physionet.org">PhysioNet</a> and tools are currently available for
downloading the datasets
<a href="https://physionet.org/content/mimiciii/1.4/">MIMIC-III</a>,
<a href="https://physionet.org/content/eicu-crd/2.0/">eICU</a> and
<a href="https://physionet.org/content/hirid/1.0/">HiRID</a> (see <a href="#topic+data">data</a>). While
credentials are required for downloading any of the three datasets, demo
dataset for both MIMIC-III and eICU are available without having to log in.
Even though access to full dataset is credentialed, the datasets are in
fact publicly available. For setting up an account, please refer to <a href="https://physionet.org/register/">the registration form</a>.
</p>
<p>PhysioNet credentials can either be entered in an interactive session,
passed as function arguments <code>user</code>/<code>pass</code> or as environment
variables <code>RICU_PHYSIONET_USER</code>/<code>RICU_PHYSIONET_PASS</code>. For setting
environment variables on session startup, refer to <code><a href="base.html#topic+Startup">base::.First.sys()</a></code> and
for setting environment variables in general, refer to <code><a href="base.html#topic+Sys.setenv">base::Sys.setenv()</a></code>
If the openssl package is available, SHA256 hashes of downloaded files are
verified using <code><a href="openssl.html#topic+hash">openssl::sha256()</a></code>.
</p>
<p>Demo datasets
<a href="https://physionet.org/content/mimiciii-demo/1.4/">MIMIC-III demo</a> and
<a href="https://physionet.org/content/eicu-crd-demo/2.0/">eICU demo</a> can either be
installed as R packages directly by running
</p>
<div class="sourceCode"><pre>install.packages(
  c("mimic.demo", "eicu.demo"),
  repos = "https://eth-mds.github.io/physionet-demo"
)
</pre></div>
<p>or downloaded and imported using <code><a href="#topic+download_src">download_src()</a></code> and <code><a href="#topic+import_src">import_src()</a></code>.
Furthermore, <code>ricu</code> specifies <code>mimic.demo</code> and <code>eicu.demo</code> as <code>Suggests</code>
dependencies therefore, passing <code>dependencies = TURE</code> when calling
<code><a href="utils.html#topic+install.packages">install.packages()</a></code> for installing <code>ricu</code>, this will automatically install
the demo datasets as well.
</p>
<p>While the included data downloaders are intended for data hosted by
PhysioNet, <code>download_src()</code> is an S3 generic function that can be extended
to new classes. Method dispatch is intended to occur on objects that
inherit from or can be coerced to <code>src_cfg</code>. For more information on data
source configuration, refer to <code><a href="#topic+load_src_cfg">load_src_cfg()</a></code>.
</p>
<p>As such, with the addition of the AmsterdamUMCdb dataset, which
unfortunately is not hosted on PhysioNet, A separate downloader for that
dataset is available as well. Currently this requires both availability of
the CRAN package <code>xml2</code>, as well as the command line utility 7zip.
Furthermore, data access has to be <a href="https://amsterdammedicaldatascience.nl/#amsterdamumcdb">requested </a> and for
non-interactive download the download token has to be made available as
environment variable <code>RICU_AUMC_TOKEN</code> or passed as <code>token</code> argument to
<code>download_src()</code>. The download token can be retrieved from the URL provided
when granted access as by extracting the string followed by <code style="white-space: pre;">&#8288;token=&#8288;</code>:
</p>
<div class="sourceCode"><pre>https://example.org/?s=download&amp;token=0c27af59-72d1-0349-aa59-00000a8076d9
</pre></div>
<p>would translate to
</p>
<div class="sourceCode r"><pre>Sys.setenv(RICU_AUMC_TOKEN = "0c27af59-72d1-0349-aa59-00000a8076d9")
</pre></div>
<p>If the dependencies outlined above are not fulfilled, download and archive
extraction can be carried out manually into the corresponding folder and
<code><a href="#topic+import_src">import_src()</a></code> can be run.
</p>


<h3>Value</h3>

<p>Called for side effects and returns <code>NULL</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

dir &lt;- tempdir()
list.files(dir)

download_datasource("mimic_demo", data_dir = dir)
list.files(dir)

unlink(dir, recursive = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='expand'>Time series utility functions</h2><span id='topic+expand'></span><span id='topic+collapse'></span><span id='topic+has_no_gaps'></span><span id='topic+has_gaps'></span><span id='topic+is_regular'></span><span id='topic+fill_gaps'></span><span id='topic+remove_gaps'></span><span id='topic+slide'></span><span id='topic+slide_index'></span><span id='topic+hop'></span>

<h3>Description</h3>

<p>ICU data as handled by <code>ricu</code> is mostly comprised of time series data and as
such, several utility functions are available for working with time series
data in addition to a class dedicated to representing time series data (see
<code><a href="#topic+ts_tbl">ts_tbl()</a></code>). Some terminology to begin with: a time series is considered
to have gaps if, per (combination of) ID variable value(s), some time steps
are missing. Expanding and collapsing mean to change between
representations where time steps are explicit or encoded as interval with
start and end times. For sliding window-type operations, <code>slide()</code> means to
iterate over time-windows, <code>slide_index()</code> means to iterate over certain
time-windows, selected relative to the index and <code>hop()</code> means to iterate
over time-windows selected in absolute terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(
  x,
  start_var = index_var(x),
  end_var = NULL,
  step_size = time_step(x),
  new_index = start_var,
  keep_vars = NULL,
  aggregate = FALSE
)

collapse(
  x,
  id_vars = NULL,
  index_var = NULL,
  start_var = "start",
  end_var = "end",
  env = NULL,
  as_win_tbl = TRUE,
  ...
)

has_no_gaps(x)

has_gaps(...)

is_regular(x)

fill_gaps(x, limits = collapse(x), start_var = "start", end_var = "end")

remove_gaps(x)

slide(x, expr, before, after = hours(0L), ...)

slide_index(x, expr, index, before, after = hours(0L), ...)

hop(
  x,
  expr,
  windows,
  full_window = FALSE,
  lwr_col = "min_time",
  upr_col = "max_time",
  left_closed = TRUE,
  right_closed = TRUE,
  eval_env = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_+3A_x">x</code></td>
<td>
<p><code>ts_tbl</code> object to use</p>
</td></tr>
<tr><td><code id="expand_+3A_start_var">start_var</code>, <code id="expand_+3A_end_var">end_var</code></td>
<td>
<p>Name of the columns that represent lower and upper
windows bounds</p>
</td></tr>
<tr><td><code id="expand_+3A_step_size">step_size</code></td>
<td>
<p>Controls the step size used to interpolate between
<code>start_var</code> and <code>end_var</code></p>
</td></tr>
<tr><td><code id="expand_+3A_new_index">new_index</code></td>
<td>
<p>Name of the new index column</p>
</td></tr>
<tr><td><code id="expand_+3A_keep_vars">keep_vars</code></td>
<td>
<p>Names of the columns to hold onto</p>
</td></tr>
<tr><td><code id="expand_+3A_aggregate">aggregate</code></td>
<td>
<p>Function for aggregating values in overlapping intervals</p>
</td></tr>
<tr><td><code id="expand_+3A_id_vars">id_vars</code>, <code id="expand_+3A_index_var">index_var</code></td>
<td>
<p>ID and index variables</p>
</td></tr>
<tr><td><code id="expand_+3A_env">env</code></td>
<td>
<p>Environment used as parent to the environment used to evaluate
expressions passes as <code>...</code></p>
</td></tr>
<tr><td><code id="expand_+3A_as_win_tbl">as_win_tbl</code></td>
<td>
<p>Logical flag indicating whether to return a <code>win_tbl</code> or
an <code>id_tbl</code></p>
</td></tr>
<tr><td><code id="expand_+3A_...">...</code></td>
<td>
<p>Passed to <code>hop_quo()</code> and ultimately to
<code><a href="data.table.html#topic+data.table">data.table::[()</a></code></p>
</td></tr>
<tr><td><code id="expand_+3A_limits">limits</code></td>
<td>
<p>A table with columns for lower and upper window bounds or a
length 2 difftime vector</p>
</td></tr>
<tr><td><code id="expand_+3A_expr">expr</code></td>
<td>
<p>Expression (quoted for <code style="white-space: pre;">&#8288;*_quo&#8288;</code> and unquoted otherwise) to be
evaluated over each window</p>
</td></tr>
<tr><td><code id="expand_+3A_before">before</code>, <code id="expand_+3A_after">after</code></td>
<td>
<p>Time span to look back/forward</p>
</td></tr>
<tr><td><code id="expand_+3A_index">index</code></td>
<td>
<p>A vector of times around which windows are spanned (relative
to the index)</p>
</td></tr>
<tr><td><code id="expand_+3A_windows">windows</code></td>
<td>
<p>An <code>icu_tbl</code> defining the windows to span</p>
</td></tr>
<tr><td><code id="expand_+3A_full_window">full_window</code></td>
<td>
<p>Logical flag controlling how the situation is handled
where the sliding window extends beyond available data</p>
</td></tr>
<tr><td><code id="expand_+3A_lwr_col">lwr_col</code>, <code id="expand_+3A_upr_col">upr_col</code></td>
<td>
<p>Names of columns (in <code>windows</code>) of lower/upper
window bounds</p>
</td></tr>
<tr><td><code id="expand_+3A_left_closed">left_closed</code>, <code id="expand_+3A_right_closed">right_closed</code></td>
<td>
<p>Logical flag indicating whether intervals
are closed (default) or open.</p>
</td></tr>
<tr><td><code id="expand_+3A_eval_env">eval_env</code></td>
<td>
<p>Environment in which <code>expr</code> is substituted; <code>NULL</code> resolves
to the environment in which <code>expr</code> was created</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A gap in a <code>ts_tbl</code> object is a missing time step, i.e. a missing entry in
the sequence <code>seq(min(index), max(index), by = interval)</code> in at least one
group (as defined by <code><a href="#topic+id_vars">id_vars()</a></code>, where the extrema are calculated per
group. In this case, <code>has_gaps()</code> will return <code>TRUE</code>. The function
<code>is_regular()</code> checks whether the time series has no gaps, in addition to
the object being sorted and unique (see <code><a href="#topic+is_sorted">is_sorted()</a></code> and <code><a href="#topic+is_unique">is_unique()</a></code>).
In order to transform a time series containing gaps into a regular time
series, <code>fill_gaps()</code> will fill missing time steps with <code>NA</code> values in all
<code><a href="#topic+data_vars">data_vars()</a></code> columns, while <code>remove_gaps()</code> provides the inverse operation
of removing time steps that consist of <code>NA</code> values in <code><a href="#topic+data_vars">data_vars()</a></code> columns.
</p>
<p>An <code>expand()</code> operation performed on an object inheriting from <code>data.table</code>
yields a <code>ts_tbl</code> where time-steps encoded by columns <code>start_var</code> and
<code>end_var</code> are made explicit with values in <code>keep_vars</code> being appropriately
repeated. The inverse operation is available as <code>collapse()</code>, which groups
by <code>id_vars</code>, represents <code>index_var</code> as group-wise extrema in two new
columns <code>start_var</code> and <code>end_var</code> and allows for further data summary using
<code>...</code>. An aspect to keep in mind when applying <code>expand()</code> to a <code>win_tbl</code>
object is that values simply are repeated for all time-steps that fall into
a given validity interval. This gives correct results when a <code>win_tbl</code> for
example contains data on infusions as rates, but might not lead to correct
results when infusions are represented as drug amounts administered over a
given time-span. In such a scenario it might be desirable to evenly
distribute the total amount over the corresponding time steps (currently not
implemented).
</p>
<p>Sliding-window type operations are available as <code>slide()</code>, <code>slide_index()</code>
and <code>hop()</code> (function naming is inspired by the CRAN package <code>slider</code>). The
most flexible of the three, <code>hop</code> takes as input a <code>ts_tbl</code> object <code>x</code>
containing the data, an <code>id_tbl</code> object <code>windows</code>, containing for each ID
the desired windows represented by two columns <code>lwr_col</code> and <code>upr_col</code>, as
well as an expression <code>expr</code> to be evaluated per window. At the other end
of the spectrum, <code>slide()</code> spans windows for every ID and available
time-step using the arguments <code>before</code> and <code>after</code>, while <code>slide_index()</code>
can be seen as a compromise between the two, where windows are spanned for
certain time-points, specified by <code>index</code>.
</p>


<h3>Value</h3>

<p>Most functions return <code>ts_tbl</code> objects with the exception of
<code>has_gaps()</code>/<code>has_no_gaps()</code>/<code>is_regular()</code>, which return logical flags.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (FALSE) {
tbl &lt;- ts_tbl(x = 1:5, y = hours(1:5), z = hours(2:6), val = rnorm(5),
              index_var = "y")
exp &lt;- expand(tbl, "y", "z", step_size = 1L, new_index = "y",
              keep_vars = c("x", "val"))
col &lt;- collapse(exp, start_var = "y", end_var = "z", val = unique(val))
all.equal(tbl, col, check.attributes = FALSE)

tbl &lt;- ts_tbl(x = rep(1:5, 1:5), y = hours(sequence(1:5)), z = 1:15)

win &lt;- id_tbl(x = c(3, 4), a = hours(c(2, 1)), b = hours(c(3, 4)))
hop(tbl, list(z = sum(z)), win, lwr_col = "a", upr_col = "b")
slide_index(tbl, list(z = sum(z)), hours(c(4, 5)), before = hours(2))
slide(tbl, list(z = sum(z)), before = hours(2))

tbl &lt;- ts_tbl(x = rep(3:4, 3:4), y = hours(sequence(3:4)), z = 1:7)
has_no_gaps(tbl)
is_regular(tbl)

tbl[1, 2] &lt;- hours(2)
has_no_gaps(tbl)
is_regular(tbl)

tbl[6, 2] &lt;- hours(2)
has_no_gaps(tbl)
is_regular(tbl)
}

</code></pre>

<hr>
<h2 id='id_origin'>Data loading utilities</h2><span id='topic+id_origin'></span><span id='topic+id_orig_helper'></span><span id='topic+id_orig_helper.src_env'></span><span id='topic+id_orig_helper.miiv_env'></span><span id='topic+id_windows'></span><span id='topic+id_win_helper'></span><span id='topic+id_win_helper.mimic_env'></span><span id='topic+id_win_helper.eicu_env'></span><span id='topic+id_win_helper.hirid_env'></span><span id='topic+id_win_helper.aumc_env'></span><span id='topic+id_win_helper.miiv_env'></span><span id='topic+id_map'></span><span id='topic+id_map_helper'></span><span id='topic+id_map_helper.src_env'></span>

<h3>Description</h3>

<p>Two important tools for smoothing out differences among used datasets are
<code>id_origin()</code> which returns origin times for a given ID and <code>id_map()</code>
which returns a mapping between two ID systems alongside start and end
columns of the target ID system relative to the source ID system. As both
these function are called frequently during data loading and might involve
somewhat expensive operations, both rely on internal helper functions
(<code>id_orig_helper()</code> and <code>id_map_helper()</code>) which perform the heavy lifting
and wrap those helper functions, providing a memoization layer. When adding
a new data source, a class specific implementation of the S3 generic
function <code>id_map_helper()</code> might be required, as this is used during data
loading using <code><a href="#topic+load_id">load_id()</a></code> and <code><a href="#topic+load_ts">load_ts()</a></code> via <code><a href="#topic+change_id">change_id()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_origin(x, id, origin_name = NULL, copy = TRUE)

id_orig_helper(x, id)

## S3 method for class 'src_env'
id_orig_helper(x, id)

## S3 method for class 'miiv_env'
id_orig_helper(x, id)

id_windows(x, copy = TRUE)

id_win_helper(x)

## S3 method for class 'mimic_env'
id_win_helper(x)

## S3 method for class 'eicu_env'
id_win_helper(x)

## S3 method for class 'hirid_env'
id_win_helper(x)

## S3 method for class 'aumc_env'
id_win_helper(x)

## S3 method for class 'miiv_env'
id_win_helper(x)

id_map(x, id_var, win_var, in_time = NULL, out_time = NULL)

id_map_helper(x, id_var, win_var)

## S3 method for class 'src_env'
id_map_helper(x, id_var, win_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_origin_+3A_x">x</code></td>
<td>
<p>Object identify the ID system (passed to <code><a href="#topic+as_src_env">as_src_env()</a></code>)</p>
</td></tr>
<tr><td><code id="id_origin_+3A_id">id</code></td>
<td>
<p>ID name for which to return origin times</p>
</td></tr>
<tr><td><code id="id_origin_+3A_origin_name">origin_name</code></td>
<td>
<p>String-valued name which will be used to label the origin
column</p>
</td></tr>
<tr><td><code id="id_origin_+3A_copy">copy</code></td>
<td>
<p>Logical flag indicating whether to return a copy of the memoized
<code style="white-space: pre;">&#8288;0data.table&#8288;</code> for safety</p>
</td></tr>
<tr><td><code id="id_origin_+3A_id_var">id_var</code></td>
<td>
<p>Type of ID all returned times are relative to</p>
</td></tr>
<tr><td><code id="id_origin_+3A_win_var">win_var</code></td>
<td>
<p>Type of ID for which the in/out times is returned</p>
</td></tr>
<tr><td><code id="id_origin_+3A_in_time">in_time</code>, <code id="id_origin_+3A_out_time">out_time</code></td>
<td>
<p>column names of the returned in/out times</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the internal datasets, <code>id_map_helper()</code> relies on yet another S3
generic function <code>id_windows()</code>, which provides a table containing all
available ID systems, as well as all ID windows for a given data source. As
for the other two functions, the same helper-function approach is in place,
with the data loading function <code>id_win_helper()</code>. The function
<code>id_map_helper()</code> is then implemented in a data source agnostic manner
(dispatching on the <code>src_env</code> class), providing subsetting of this larger
ID map table and ensuring timestamps are relative to the correct ID system.
For adding a new data source however, this layer can be forgone. Similarly
for <code>id_origin()</code>, this is used for the internal datasets in
<code><a href="#topic+load_difftime">load_difftime()</a></code>. An implementation of <code><a href="#topic+load_difftime">load_difftime()</a></code>, specific to a
new data source can be provided that does not rely on <code>id_windows()</code>,
making this function irrelevant for this specific dataset.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>id_origin()</code>/<code>id_orig_helper()</code>: an <code>id_tbl</code> with admission time stamps
corresponding to the selected ID
</p>
</li>
<li> <p><code>id_windows()</code>/<code>id_win_helper()</code>: an <code>id_tbl</code> holding all IDs and their
respective start and end times
</p>
</li>
<li> <p><code>id_map()</code>/<code>id_map_helper()</code>: an <code>id_tbl</code> containing the selected IDs and
depending on values passed as <code>in_time</code> and <code>out_time</code>, start and end
times of the ID passed as <code>win_var</code>
</p>
</li></ul>


<hr>
<h2 id='id_tbl'>Tabular ICU data classes</h2><span id='topic+id_tbl'></span><span id='topic+is_id_tbl'></span><span id='topic+as_id_tbl'></span><span id='topic+ts_tbl'></span><span id='topic+is_ts_tbl'></span><span id='topic+as_ts_tbl'></span><span id='topic+win_tbl'></span><span id='topic+is_win_tbl'></span><span id='topic+as_win_tbl'></span><span id='topic+as.data.table.id_tbl'></span><span id='topic+as.data.frame.id_tbl'></span><span id='topic+validate_tbl'></span>

<h3>Description</h3>

<p>In order to simplify handling or tabular ICU data, <code>ricu</code> provides
S3 classes, <code>id_tbl</code>, <code>ts_tbl</code>, and <code>win_tbl</code>. These classes essentially
consist of a <code>data.table</code> object, alongside some meta data and S3 dispatch
is used to enable more natural behavior for some data manipulation tasks.
For example, when merging two tables, a default for the <code>by</code> argument can
be chosen more sensibly if columns representing patient ID and timestamp
information can be identified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_tbl(..., id_vars = 1L)

is_id_tbl(x)

as_id_tbl(x, id_vars = NULL, by_ref = FALSE)

ts_tbl(..., id_vars = 1L, index_var = NULL, interval = NULL)

is_ts_tbl(x)

as_ts_tbl(x, id_vars = NULL, index_var = NULL, interval = NULL, by_ref = FALSE)

win_tbl(..., id_vars = NULL, index_var = NULL, interval = NULL, dur_var = NULL)

is_win_tbl(x)

as_win_tbl(
  x,
  id_vars = NULL,
  index_var = NULL,
  interval = NULL,
  dur_var = NULL,
  by_ref = FALSE
)

## S3 method for class 'id_tbl'
as.data.table(x, keep.rownames = FALSE, by_ref = FALSE, ...)

## S3 method for class 'id_tbl'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

validate_tbl(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_tbl_+3A_...">...</code></td>
<td>
<p>forwarded to <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> or generic consistency</p>
</td></tr>
<tr><td><code id="id_tbl_+3A_id_vars">id_vars</code></td>
<td>
<p>Column name(s) to be used as <code>id</code> column(s)</p>
</td></tr>
<tr><td><code id="id_tbl_+3A_x">x</code></td>
<td>
<p>Object to query/operate on</p>
</td></tr>
<tr><td><code id="id_tbl_+3A_by_ref">by_ref</code></td>
<td>
<p>Logical flag indicating whether to perform the operation by
reference</p>
</td></tr>
<tr><td><code id="id_tbl_+3A_index_var">index_var</code></td>
<td>
<p>Column name of the index column</p>
</td></tr>
<tr><td><code id="id_tbl_+3A_interval">interval</code></td>
<td>
<p>Time series interval length specified as scalar-valued
<code>difftime</code> object</p>
</td></tr>
<tr><td><code id="id_tbl_+3A_dur_var">dur_var</code></td>
<td>
<p>Column name of the duration column</p>
</td></tr>
<tr><td><code id="id_tbl_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Default is <code>FALSE</code>. If <code>TRUE</code>, adds the input object's names as a separate column named <code>"rn"</code>. <code>keep.rownames = "id"</code> names the column <code>"id"</code> instead.</p>
</td></tr>
<tr><td><code id="id_tbl_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row
names for the data frame.  Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="id_tbl_+3A_optional">optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and
converting column names (to syntactic names: see
<code><a href="base.html#topic+make.names">make.names</a></code>) is optional.  Note that all of <span class="rlang"><b>R</b></span>'s
<span class="pkg">base</span> package <code>as.data.frame()</code> methods use
<code>optional</code> only for column names treatment, basically with the
meaning of <code><a href="base.html#topic+data.frame">data.frame</a>(*, check.names = !optional)</code>.
See also the <code>make.names</code> argument of the <code>matrix</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The introduced classes are designed for several often encountered data
scenarios:
</p>

<ul>
<li> <p><code>id_tbl</code> objects can be used to represent static (with respect to
relevant time scales) patient data such as patient age and such an object
is simply a <code>data.table</code> combined with a non-zero length character vector
valued attribute marking the columns tracking patient ID information
(<code><a href="#topic+id_vars">id_vars</a></code>). All further columns are considered as
<a href="#topic+data_vars">data_vars</a>.
</p>
</li>
<li> <p><code>ts_tbl</code> objects are used for grouped time series data. A <code>data.table</code>
object again is augmented by attributes, including a non-zero length
character vector identifying patient ID columns (<a href="#topic+id_vars">id_vars</a>),
a string, tracking the column holding time-stamps
(<a href="#topic+index_var">index_var</a>) and a scalar <code>difftime</code> object determining
the time-series step size <a href="#topic+interval">interval</a>. Again, all further
columns are treated as <a href="#topic+data_vars">data_vars</a>.
</p>
</li>
<li> <p><code>win_tbl</code>: In addition to representing grouped time-series data as does
a <code>ts_tbl</code>, <code>win_tbl</code> objects also encode a validity interval for each
time-stamped measurement (as <a href="#topic+dur_var">dur_var</a>). This can for example
be useful when a drug is administered at a certain infusion rate for a
given time period.
</p>
</li></ul>

<p>Owing to the nested structure of required meta data, <code>ts_tbl</code> inherits from
<code>id_tbl</code> and <code>win_tbl</code> from <code>ts_tbl</code>. Furthermore, both classes inherit from
<code>data.table</code>. As such, <code>data.table</code> <a href="data.table.html#topic+assign">reference semantics</a>
are available for some operations, indicated by presence of a <code>by_ref</code>
argument. At default, value, <code>by_ref</code> is set to <code>FALSE</code> as this is in line
with base R behavior at the cost of potentially incurring unnecessary data
copies. Some care has to be taken when passing <code>by_ref = TRUE</code> and enabling
by reference operations as this can have side effects (see examples).
</p>
<p>For instantiating <code>ts_tbl</code> objects, both <code>index_var</code> and <code>interval</code> can be
automatically determined if not specified. For the index column, the only
requirement is that a single <code><a href="base.html#topic+difftime">difftime</a></code> column is
present, while for the time step, the minimal difference between two
consecutive observations is chosen (and all differences are therefore
required to be multiples of the minimum difference). Similarly, for a
<code>win_tbl</code>, exactly two <code><a href="base.html#topic+difftime">difftime</a></code> columns are required
where the first is assumed to be corresponding to the <code>index_var</code> and the
second to the <code>dur_var</code>.
</p>
<p>Upon instantiation, the data might be rearranged: columns are reordered
such that ID columns are moved to the front, followed by the index column
and a <code><a href="data.table.html#topic+setkey">data.table::key()</a></code> is set on meta columns, causing rows to be sorted
accordingly. Moving meta columns to the front is done for reasons of
convenience for printing, while setting a key on meta columns is done to
improve efficiency of subsequent transformations such as merging or grouped
operations. Furthermore, <code>NA</code> values in either ID or index columns are not
allowed and therefore corresponding rows are silently removed.
</p>
<p>Coercion between <code>id_tbl</code> and <code>ts_tbl</code> (and <code>win_tbl</code>) by default keeps
intersecting attributes fixed and new attributes are by default inferred as
for class instantiation. Each class comes with a class-specific
implementation of the S3 generic function <code>validate_tbl()</code> which returns
<code>TRUE</code> if the object is considered valid or a string outlining the type of
validation failure that was encountered. Validity requires
</p>

<ol>
<li><p> inheriting from <code>data.table</code> and unique column names
</p>
</li>
<li><p> for <code>id_tbl</code> that all columns specified by the non-zero length character
vector holding onto the <code>id_vars</code> specification are available
</p>
</li>
<li><p> for <code>ts_tbl</code> that the string-valued <code>index_var</code> column is available and
does not intersect with <code>id_vars</code> and that the index column obeys the
specified interval.
</p>
</li>
<li><p> for <code>win_tbl</code> that the string-valued <code>dur_var</code> corresponds to a
<code>difftime</code> vector and is not among the columns marked as index or ID
variables
</p>
</li></ol>

<p>Finally, inheritance can be checked by calling <code>is_id_tbl()</code> and
<code>is_ts_tbl()</code>. Note that due to <code>ts_tbl</code> inheriting from <code>id_tbl</code>,
<code>is_id_tbl()</code> returns <code>TRUE</code> for both <code>id_tbl</code> and <code>ts_tbl</code> objects (and
similarly for <code>win_tbl</code>), while <code>is_ts_tbl()</code> only returns <code>TRUE</code> for
<code>ts_tbl</code> objects.
</p>


<h3>Value</h3>

<p>Constructors <code>id_tbl()</code>/<code>ts_tbl()</code>/<code>win_tbl()</code>, as well as coercion
functions <code>as_id_tbl()</code>/<code>as_ts_tbl()</code>/<code>as_win_tbl()</code> return
<code>id_tbl</code>/<code>ts_tbl</code>/<code>win_tbl</code> objects respectively,
while inheritance testers <code>is_id_tbl()</code>/<code>is_ts_tbl()</code>/<code>is_win_tbl()</code> return
logical flags and <code>validate_tbl()</code> returns either <code>TRUE</code> or a string
describing the validation failure.
</p>


<h3>Relationship to <code>data.table</code></h3>

<p>Both <code>id_tbl</code> and <code>ts_tbl</code> inherit from <code>data.table</code> and as such, functions
intended for use with <code>data.table</code> objects can be applied to <code>id_tbl</code> and
<code>ts_tbl</code> as well. But there are some caveats: Many functions introduced by
<code>data.table</code> are not S3 generic and therefore they would have to be masked
in order to retain control over how they operate on objects inheriting form
<code>data.table</code>. Take for example the function <code><a href="data.table.html#topic+setattr">data.table::setnames()</a></code>, which
changes column names by reference. Using this function, the name of an
index column of an <code>id_tbl</code> object can me changed without updating the
attribute marking the column as such and thusly leaving the object in an
inconsistent state. Instead of masking the function <code>setnames()</code>, an
alternative is provided as <code><a href="#topic+rename_cols">rename_cols()</a></code>. In places where it is possible
to seamlessly insert the appropriate function (such as
<code><a href="base.html#topic+names">base::names&lt;-()</a></code> or <code><a href="base.html#topic+colnames">base::colnames&lt;-()</a></code>) and the responsibility for not
using <code><a href="data.table.html#topic+setattr">data.table::setnames()</a></code> in a way that breaks the <code>id_tbl</code> object is
left to the user.
</p>
<p>Owing to <code>data.table</code> heritage, one of the functions that is often called
on <code>id_tbl</code> and <code>ts_tbl</code> objects is base S3 generic [base::<code>[</code>()]. As this
function is capable of modifying the object in a way that makes it
incompatible with attached meta data, an attempt is made at preserving as
much as possible and if all fails, a <code>data.table</code> object is returned
instead of an object inheriting form <code>id_tbl</code>. If for example the index
column is removed (or modified in a way that makes it incompatible with the
interval specification) from a <code>ts_tbl</code>, an <code>id_tbl</code> is returned. If
however the ID column is removed the only sensible thing to return is a
<code>data.table</code> (see examples).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tbl &lt;- id_tbl(a = 1:10, b = rnorm(10))
is_id_tbl(tbl)
is_ts_tbl(tbl)

dat &lt;- data.frame(a = 1:10, b = hours(1:10), c = rnorm(10))
tbl &lt;- as_ts_tbl(dat, "a")
is_id_tbl(tbl)
is_ts_tbl(tbl)

tmp &lt;- as_id_tbl(tbl)
is_ts_tbl(tbl)
is_ts_tbl(tmp)

tmp &lt;- as_id_tbl(tbl, by_ref = TRUE)
is_ts_tbl(tbl)
is_ts_tbl(tmp)

tbl &lt;- id_tbl(a = 1:10, b = rnorm(10))
names(tbl) &lt;- c("c", "b")
tbl

tbl &lt;- id_tbl(a = 1:10, b = rnorm(10))
validate_tbl(data.table::setnames(tbl, c("c", "b")))

tbl &lt;- id_tbl(a = 1:10, b = rnorm(10))
validate_tbl(rename_cols(tbl, c("c", "b")))

tbl &lt;- ts_tbl(a = rep(1:2, each = 5), b = hours(rep(1:5, 2)), c = rnorm(10))
tbl[, c("a", "c"), with = FALSE]
tbl[, c("b", "c"), with = FALSE]
tbl[, list(a, b = as.double(b), c)]

</code></pre>

<hr>
<h2 id='id_vars'>ICU class meta data utilities</h2><span id='topic+id_vars'></span><span id='topic+id_var'></span><span id='topic+id_col'></span><span id='topic+index_var'></span><span id='topic+index_col'></span><span id='topic+dur_var'></span><span id='topic+dur_col'></span><span id='topic+dur_unit'></span><span id='topic+meta_vars'></span><span id='topic+data_vars'></span><span id='topic+data_var'></span><span id='topic+data_col'></span><span id='topic+interval'></span><span id='topic+time_unit'></span><span id='topic+time_step'></span><span id='topic+time_vars'></span>

<h3>Description</h3>

<p>The two data classes <code>id_tbl</code> and <code>ts_tbl</code>, used by <code>ricu</code> to represent ICU
patient data, consist of a <code>data.table</code> alongside some meta data. This
includes marking columns that have special meaning and for data
representing measurements ordered in time, the step size. The following
utility functions can be used to extract columns and column names with
special meaning, as well as query a <code>ts_tbl</code> object regarding its time
series related meta data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_vars(x)

id_var(x)

id_col(x)

index_var(x)

index_col(x)

dur_var(x)

dur_col(x)

dur_unit(x)

meta_vars(x)

data_vars(x)

data_var(x)

data_col(x)

interval(x)

time_unit(x)

time_step(x)

time_vars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_vars_+3A_x">x</code></td>
<td>
<p>Object to query</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following functions can be used to query an object for columns or
column names that represent a distinct aspect of the data:
</p>

<ul>
<li> <p><code>id_vars()</code>: ID variables are one or more column names with the
interaction of corresponding columns identifying a grouping of the data.
Most commonly this is some sort of patient identifier.
</p>
</li>
<li> <p><code>id_var()</code>: This function either fails or returns a string and can
therefore be used in case only a single column provides grouping
information.
</p>
</li>
<li> <p><code>id_col()</code>: Again, in case only a single column provides grouping
information, this column can be extracted using this function.
</p>
</li>
<li> <p><code>index_var()</code>: Suitable for use as index variable is a column that encodes
a temporal ordering of observations as <code><a href="base.html#topic+difftime">difftime</a></code>
vector. Only a single column can be marked as index variable and this
function queries a <code>ts_tbl</code> object for its name.
</p>
</li>
<li> <p><code>index_col()</code>: similarly to <code>id_col()</code>, this function extracts the column
with the given designation. As a <code>ts_tbl</code> object is required to have
exactly one column marked as index, this function always returns for
<code>ts_tbl</code> objects (and fails for <code>id_tbl</code> objects).
</p>
</li>
<li> <p><code>dur_var()</code>: For <code>win_tbl</code> objects, this returns the name of the column
encoding the data validity interval.
</p>
</li>
<li> <p><code>dur_col()</code>: Similarly to <code>index_col()</code>, this returns the <code>difftime</code>
vector corresponding to the <code>dur_var()</code>.
</p>
</li>
<li> <p><code>meta_vars()</code>: For <code>ts_tbl</code> objects, meta variables represent the union
of ID and index variables (for <code>win_tbl</code>, this also includes the
<code>dur_var()</code>), while for <code>id_tbl</code> objects meta variables consist pf ID
variables.
</p>
</li>
<li> <p><code>data_vars()</code>: Data variables on the other hand are all columns that are
not meta variables.
</p>
</li>
<li> <p><code>data_var()</code>: Similarly to <code>id_var()</code>, this function either returns the
name of a single data variable or fails.
</p>
</li>
<li> <p><code>data_col()</code>: Building on <code>data_var()</code>, in situations where only a single
data variable is present, it is returned or if multiple data column
exists, an error is thrown.
</p>
</li>
<li> <p><code>time_vars()</code>: Time variables are all columns in an object inheriting
from <code><a href="base.html#topic+data.frame">data.frame</a></code> that are of type
<code><a href="base.html#topic+difftime">difftime</a></code>. Therefore in a <code>ts_tbl</code> object the index
column is one of (potentially) several time variables. For a <code>win_tbl</code>,
however the <code>dur_var()</code> is not among the <code>time_vars()</code>.
</p>
</li>
<li> <p><code>interval()</code>: The time series interval length is represented a scalar
valued <code><a href="base.html#topic+difftime">difftime</a></code> object.
</p>
</li>
<li> <p><code>time_unit()</code>: The time unit of the time series interval, represented by
a string such as &quot;hours&quot; or &quot;mins&quot; (see <code><a href="base.html#topic+difftime">difftime</a></code>).
</p>
</li>
<li> <p><code>time_step()</code>: The time series step size represented by a numeric value
in the unit as returned by <code>time_unit()</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Mostly column names as character vectors, in case of <code>id_var()</code>,
<code>index_var()</code>, <code>data_var()</code> and <code>time_unit()</code> of length 1, else of variable
length. Functions <code>id_col()</code>, <code>index_col()</code> and <code>data_col()</code> return table
columns as vectors, while <code>interval()</code> returns a scalar valued <code>difftime</code>
object and <code>time_step()</code> a number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tbl &lt;- id_tbl(a = rep(1:2, each = 5), b = rep(1:5, 2), c = rnorm(10),
              id_vars = c("a", "b"))

id_vars(tbl)
tryCatch(id_col(tbl), error = function(...) "no luck")
data_vars(tbl)
data_col(tbl)

tmp &lt;- as_id_tbl(tbl, id_vars = "a")
id_vars(tmp)
id_col(tmp)

tbl &lt;- ts_tbl(a = rep(1:2, each = 5), b = hours(rep(1:5, 2)), c = rnorm(10))
index_var(tbl)
index_col(tbl)

identical(index_var(tbl), time_vars(tbl))

interval(tbl)
time_unit(tbl)
time_step(tbl)

</code></pre>

<hr>
<h2 id='import_src'>Data import utilities</h2><span id='topic+import_src'></span><span id='topic+import_src.src_cfg'></span><span id='topic+import_src.aumc_cfg'></span><span id='topic+import_src.character'></span><span id='topic+import_tbl'></span><span id='topic+import_tbl.tbl_cfg'></span>

<h3>Description</h3>

<p>Making a dataset available to <code>ricu</code> consists of 3 steps: downloading
(<code><a href="#topic+download_src">download_src()</a></code>), importing (<code><a href="#topic+import_src">import_src()</a></code>) and attaching
(<code><a href="#topic+attach_src">attach_src()</a></code>). While downloading and importing are one-time procedures,
attaching of the dataset is repeated every time the package is loaded.
Briefly, downloading loads the raw dataset from the internet (most likely
in <code>.csv</code> format), importing consists of some preprocessing to make the
data available more efficiently and attaching sets up the data for use by
the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_src(x, ...)

## S3 method for class 'src_cfg'
import_src(
  x,
  data_dir = src_data_dir(x),
  tables = NULL,
  force = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'aumc_cfg'
import_src(x, ...)

## S3 method for class 'character'
import_src(
  x,
  data_dir = src_data_dir(x),
  tables = NULL,
  force = FALSE,
  verbose = TRUE,
  cleanup = FALSE,
  ...
)

import_tbl(x, ...)

## S3 method for class 'tbl_cfg'
import_tbl(
  x,
  data_dir = src_data_dir(x),
  progress = NULL,
  cleanup = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_src_+3A_x">x</code></td>
<td>
<p>Object specifying the source configuration</p>
</td></tr>
<tr><td><code id="import_src_+3A_...">...</code></td>
<td>
<p>Passed to downstream methods (finally to
<a href="readr.html#topic+read_delim">readr::read_csv</a>/<a href="readr.html#topic+read_delim_chunked">readr::read_csv_chunked</a>)/generic consistency</p>
</td></tr>
<tr><td><code id="import_src_+3A_data_dir">data_dir</code></td>
<td>
<p>Destination directory where the downloaded data is written
to.</p>
</td></tr>
<tr><td><code id="import_src_+3A_tables">tables</code></td>
<td>
<p>Character vector specifying the tables to download. If
<code>NULL</code>, all available tables are downloaded.</p>
</td></tr>
<tr><td><code id="import_src_+3A_force">force</code></td>
<td>
<p>Logical flag; if <code>TRUE</code>, existing data will be re-downloaded</p>
</td></tr>
<tr><td><code id="import_src_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag indicating whether to print progress information</p>
</td></tr>
<tr><td><code id="import_src_+3A_cleanup">cleanup</code></td>
<td>
<p>Logical flag indicating whether to remove raw csv files after
conversion to fst</p>
</td></tr>
<tr><td><code id="import_src_+3A_progress">progress</code></td>
<td>
<p>Either <code>NULL</code> or a progress bar as created by
<code><a href="progress.html#topic+progress_bar">progress::progress_bar()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to speed up data access operations, <code>ricu</code> does not directly use
the PhysioNet provided CSV files, but converts all data to <code><a href="fst.html#topic+fst">fst::fst()</a></code>
format, which allows for random row and column access. Large tables are
split into chunks in order to keep memory requirements reasonably low.
</p>
<p>The one-time step per dataset of data import is fairly resource intensive:
depending on CPU and available storage system, it will take on the order of
an hour to run to completion and depending on the dataset, somewhere
between 50 GB and 75 GB of temporary disk space are required as tables are
uncompressed, in case of partitioned data, rows are reordered and the data
again is saved to a storage efficient format.
</p>
<p>The S3 generic function <code>import_src()</code> performs import of an entire data
source, internally calling the S3 generic function <code>import_tbl()</code> in order
to perform import of individual tables. Method dispatch is intended to
occur on objects inheriting from <code>src_cfg</code> and <code>tbl_cfg</code> respectively. Such
objects can be generated from JSON based configuration files which contain
information such as table names,  column types or row numbers, in order to
provide safety in parsing of <code>.csv</code> files. For more information on data
source configuration, refer to <code><a href="#topic+load_src_cfg">load_src_cfg()</a></code>.
</p>
<p>Current import capabilities include re-saving a <code>.csv</code> file to <code>.fst</code> at
once (used for smaller sized tables), reading a large <code>.csv</code> file using the
<code><a href="readr.html#topic+read_delim_chunked">readr::read_csv_chunked()</a></code> API, while partitioning chunks and reassembling
sub-partitions (used for splitting a large file into partitions), as well
as re-partitioning an already partitioned table according to a new
partitioning scheme. Care has been taken to keep the maximal memory
requirements for this reasonably low, such that data import is feasible on
laptop class hardware.
</p>


<h3>Value</h3>

<p>Called for side effects and returns <code>NULL</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

dir &lt;- tempdir()
list.files(dir)

download_src("mimic_demo", dir)
list.files(dir)

import_src("mimic_demo", dir)
list.files(dir)

unlink(dir, recursive = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='load_concepts'>Load concept data</h2><span id='topic+load_concepts'></span><span id='topic+load_concepts.character'></span><span id='topic+load_concepts.integer'></span><span id='topic+load_concepts.numeric'></span><span id='topic+load_concepts.concept'></span><span id='topic+load_concepts.cncpt'></span><span id='topic+load_concepts.num_cncpt'></span><span id='topic+load_concepts.unt_cncpt'></span><span id='topic+load_concepts.fct_cncpt'></span><span id='topic+load_concepts.lgl_cncpt'></span><span id='topic+load_concepts.rec_cncpt'></span><span id='topic+load_concepts.item'></span><span id='topic+load_concepts.itm'></span>

<h3>Description</h3>

<p>Concept objects are used in <code>ricu</code> as a way to specify how a clinical
concept, such as heart rate can be loaded from a data source. Building on
this abstraction, <code>load_concepts()</code> powers concise loading of data with
data source specific preprocessing hidden away from the user, thereby
providing a data source agnostic interface to data loading. At default
value of the argument <code>merge_data</code>, a tabular data structure (either a
<code><a href="#topic+ts_tbl">ts_tbl</a></code> or an <code><a href="#topic+id_tbl">id_tbl</a></code>, depending on what kind of
concepts are requested), inheriting from
<code><a href="data.table.html#topic+data.table">data.table</a></code>, is returned, representing the data
in wide format (i.e. returning concepts as columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_concepts(x, ...)

## S3 method for class 'character'
load_concepts(
  x,
  src = NULL,
  concepts = NULL,
  ...,
  dict_name = "concept-dict",
  dict_dirs = NULL
)

## S3 method for class 'integer'
load_concepts(
  x,
  src = NULL,
  concepts = NULL,
  ...,
  dict_name = "concept-dict",
  dict_dirs = NULL
)

## S3 method for class 'numeric'
load_concepts(x, ...)

## S3 method for class 'concept'
load_concepts(
  x,
  src = NULL,
  aggregate = NULL,
  merge_data = TRUE,
  verbose = TRUE,
  ...
)

## S3 method for class 'cncpt'
load_concepts(x, aggregate = NULL, ..., progress = NULL)

## S3 method for class 'num_cncpt'
load_concepts(x, aggregate = NULL, ..., progress = NULL)

## S3 method for class 'unt_cncpt'
load_concepts(x, aggregate = NULL, ..., progress = NULL)

## S3 method for class 'fct_cncpt'
load_concepts(x, aggregate = NULL, ..., progress = NULL)

## S3 method for class 'lgl_cncpt'
load_concepts(x, aggregate = NULL, ..., progress = NULL)

## S3 method for class 'rec_cncpt'
load_concepts(
  x,
  aggregate = NULL,
  patient_ids = NULL,
  id_type = "icustay",
  interval = hours(1L),
  ...,
  progress = NULL
)

## S3 method for class 'item'
load_concepts(
  x,
  patient_ids = NULL,
  id_type = "icustay",
  interval = hours(1L),
  progress = NULL,
  ...
)

## S3 method for class 'itm'
load_concepts(
  x,
  patient_ids = NULL,
  id_type = "icustay",
  interval = hours(1L),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_concepts_+3A_x">x</code></td>
<td>
<p>Object specifying the data to be loaded</p>
</td></tr>
<tr><td><code id="load_concepts_+3A_...">...</code></td>
<td>
<p>Passed to downstream methods</p>
</td></tr>
<tr><td><code id="load_concepts_+3A_src">src</code></td>
<td>
<p>A character vector, used to subset the <code>concepts</code>; <code>NULL</code>
means no subsetting</p>
</td></tr>
<tr><td><code id="load_concepts_+3A_concepts">concepts</code></td>
<td>
<p>The concepts to be used, or <code>NULL</code>. In the latter case the
standard ricu dictionary (obtained by calling <code><a href="#topic+load_dictionary">load_dictionary()</a></code>) is used
for loading the objects specified in <code>x</code>.</p>
</td></tr>
<tr><td><code id="load_concepts_+3A_dict_name">dict_name</code>, <code id="load_concepts_+3A_dict_dirs">dict_dirs</code></td>
<td>
<p>In case not concepts are passed as <code>concepts</code>,
these are forwarded to <code><a href="#topic+load_dictionary">load_dictionary()</a></code> as <code>name</code> and <code>file</code> arguments</p>
</td></tr>
<tr><td><code id="load_concepts_+3A_aggregate">aggregate</code></td>
<td>
<p>Controls how data within concepts is aggregated</p>
</td></tr>
<tr><td><code id="load_concepts_+3A_merge_data">merge_data</code></td>
<td>
<p>Logical flag, specifying whether to merge concepts into
wide format or return a list, each entry corresponding to a concept</p>
</td></tr>
<tr><td><code id="load_concepts_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag for muting informational output</p>
</td></tr>
<tr><td><code id="load_concepts_+3A_progress">progress</code></td>
<td>
<p>Either <code>NULL</code>, or a progress bar object as created by
<a href="progress.html#topic+progress_bar">progress::progress_bar</a></p>
</td></tr>
<tr><td><code id="load_concepts_+3A_patient_ids">patient_ids</code></td>
<td>
<p>Optional vector of patient ids to subset the fetched data
with</p>
</td></tr>
<tr><td><code id="load_concepts_+3A_id_type">id_type</code></td>
<td>
<p>String specifying the patient id type to return</p>
</td></tr>
<tr><td><code id="load_concepts_+3A_interval">interval</code></td>
<td>
<p>The time interval used to discretize time stamps with,
specified as <code><a href="base.html#topic+difftime">base::difftime()</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to allow for a large degree of flexibility (and extensibility),
which is much needed owing to considerable heterogeneity presented by
different data sources, several nested S3 classes are involved in
representing a concept and <code>load_concepts()</code> follows this hierarchy of
classes recursively when
resolving a concept. An outline of this hierarchy can be described as
</p>

<ul>
<li> <p><code>concept</code>: contains many <code>cncpt</code> objects (of potentially differing
sub-types), each comprising of some meta-data and an <code>item</code> object
</p>
</li>
<li> <p><code>item</code>: contains many <code>itm</code> objects (of potentially differing
sub-types), each encoding how to retrieve a data item.
</p>
</li></ul>

<p>The design choice for wrapping a vector of <code>cncpt</code> objects with a container
class <code>concept</code> is motivated by the requirement of having several different
sub-types of <code>cncpt</code> objects (all inheriting from the parent type <code>cncpt</code>),
while retaining control over how this homogeneous w.r.t. parent type, but
heterogeneous w.r.t. sub-type vector of objects behaves in terms of S3
generic functions.
</p>


<h3>Value</h3>

<p>An <code>id_tbl</code>/<code>ts_tbl</code> or a list thereof, depending on loaded
concepts and the value passed as <code>merge_data</code>.
</p>


<h3>Concept</h3>

<p>Top-level entry points are either a character vector of concept names or an
integer vector of concept IDs (matched against <code>omopid</code> fields), which are
used to subset a <code>concept</code> object or an entire <a href="#topic+load_dictionary">concept dictionary</a>, or a <code>concept</code> object. When passing a
character/integer vector as first argument, the most important further
arguments at that level control from where the dictionary is taken
(<code>dict_name</code> or <code>dict_dirs</code>). At <code>concept</code> level, the most important
additional arguments control the result structure: data merging can be
disabled using <code>merge_data</code> and data aggregation is governed by the
<code>aggregate</code> argument.
</p>
<p>Data aggregation is important for merging several concepts into a
wide-format table, as this requires data to be unique per observation (i.e.
by either id or combination of id and index). Several value types are
acceptable as <code>aggregate</code> argument, the most important being <code>FALSE</code>, which
disables aggregation, NULL, which auto-determines a suitable aggregation
function or a string which is ultimately passed to <code><a href="#topic+dt_gforce">dt_gforce()</a></code> where it
identifies a function such as <code>sum()</code>, <code>mean()</code>, <code>min()</code> or <code>max()</code>. More
information on aggregation is available as <a href="#topic+rename_cols">aggregate()</a>.
If the object passed as <code>aggregate</code> is scalar, it is applied to all
requested concepts in the same way. In order to customize aggregation per
concept, a named object (with names corresponding to concepts) of the same
length as the number of requested concepts may be passed.
</p>
<p>Under the hood, a <code>concept</code> object comprises of several <code>cncpt</code> objects
with varying sub-types (for example <code>num_cncpt</code>, representing continuous
numeric data or <code>fct_cncpt</code> representing categorical data). This
implementation detail is of no further importance for understanding concept
loading and for more information, please refer to the
<code><a href="#topic+concept">concept</a></code> documentation. The only argument that is introduced
at <code>cncpt</code> level is <code>progress</code>, which controls progress reporting. If
called directly, the default value of <code>NULL</code> yields messages, sent to the
terminal. Internally, if called from <code>load_concepts()</code> at <code>concept</code> level
(with <code>verbose</code> set to <code>TRUE</code>), a <a href="progress.html#topic+progress_bar">progress::progress_bar</a> is set up in a
way that allows nested messages to be captured and not interrupt progress
reporting (see <code><a href="#topic+msg_progress">msg_progress()</a></code>).
</p>


<h3>Item</h3>

<p>A single <code>cncpt</code> object contains an <code>item</code> object, which in turn is
composed of several <code>itm</code> objects with varying sub-types, the relationship
<code>item</code> to <code>itm</code> being that of <code>concept</code> to <code>cncpt</code> and the rationale for
this implementation choice is the same as previously: a container class
used representing a vector of objects of varying sub-types, all inheriting
form a common super-type. For more information on the <code>item</code> class, please
refer to the <a href="#topic+item">relevant documentation</a>. Arguments introduced at <code>item</code>
level include <code>patient_ids</code>, <code>id_type</code> and <code>interval</code>. Acceptable values for
<code>interval</code> are scalar-valued <code><a href="base.html#topic+difftime">base::difftime()</a></code> objects (see also helper
functions such as <code><a href="#topic+hours">hours()</a></code>) and this argument essentially controls the
time-resolution of the returned time-series. Of course, the limiting factor
raw time resolution which is on the order of hours for data sets like
<a href="https://physionet.org/content/mimiciii/">MIMIC-III</a> or
<a href="https://physionet.org/content/eicu-crd">eICU</a> but can be much higher for a
data set like <a href="https://physionet.org/content/hirid/">HiRID</a>. The argument
<code>id_type</code> is used to specify what kind of id system should be used to
identify different time series in the returned data. A data set like
MIMIC-III, for example, makes possible the resolution of data to 3 nested
ID systems:
</p>

<ul>
<li> <p><code>patient</code> (<code>subject_id</code>): identifies a person
</p>
</li>
<li> <p><code>hadm</code> (<code>hadm_id</code>): identifies a hospital admission (several of which are
possible for a given person)
</p>
</li>
<li> <p><code>icustay</code> (<code>icustay_id</code>): identifies an admission to an ICU and again has
a one-to-many relationship to <code>hadm</code>.
</p>
</li></ul>

<p>Acceptable argument values are strings that match ID systems as specified
by the <a href="#topic+load_src_cfg">data source configuration</a>. Finally, <code>patient_ids</code>
is used to define a patient cohort for which data can be requested. Values
may either be a vector of IDs (which are assumed to be of the same type as
specified by the <code>id_type</code> argument) or a tabular object inheriting from
<code>data.frame</code>, which must contain a column named after the data set-specific
ID system identifier (for MIMIC-III and an <code>id_type</code> argument of <code>hadm</code>,
for example, that would be <code>hadm_id</code>).
</p>


<h3>Extensions</h3>

<p>The presented hierarchy of S3 classes is designed with extensibility in
mind: while the current range of functionality covers settings encountered
when dealing with the included concepts and datasets, further data sets
and/or clinical concepts might necessitate different behavior for data
loading. For this reason, various parts in the cascade of calls to
<code>load_concepts()</code> can be adapted for new requirements by defining new sub-
classes to <code>cncpt</code> or <code>itm</code> and  providing methods for the generic function
<code>load_concepts()</code>specific to these new classes. At <code>cncpt</code> level, method
dispatch defaults to <code>load_concepts.cncpt()</code> if no method specific to the
new class is provided, while at <code>itm</code> level, no default function is
available.
</p>
<p>Roughly speaking, the semantics for the two functions are as follows:
</p>

<ul>
<li> <p><code>cncpt</code>: Called with arguments <code>x</code> (the current <code>cncpt</code> object),
<code>aggregate</code> (controlling how aggregation per time-point and ID is
handled), <code>...</code> (further arguments passed to downstream methods) and
<code>progress</code> (controlling progress reporting), this function should be able
to load and aggregate data for the given concept. Usually this involves
extracting the <code>item</code> object and calling <code>load_concepts()</code> again,
dispatching on the <code>item</code> class with arguments <code>x</code> (the given <code>item</code>),
arguments passed as <code>...</code>, as well as <code>progress</code>.
</p>
</li>
<li> <p><code>itm</code>: Called with arguments <code>x</code> (the current object inheriting from
<code>itm</code>, <code>patient_ids</code> (<code>NULL</code> or a patient ID selection), <code>id_type</code> (a
string specifying what ID system to retrieve), and <code>interval</code> (the time
series interval), this function actually carries out the loading of
individual data items, using the specified ID system, rounding times to
the correct interval and subsetting on patient IDs. As return value, on
object of class as specified by the <code>target</code> entry is expected and all
<code><a href="#topic+data_vars">data_vars()</a></code> should be named consistently, as data corresponding to
multiple <code>itm</code> objects concatenated in row-wise fashion as in
<code><a href="base.html#topic+cbind">base::rbind()</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (require(mimic.demo)) {
dat &lt;- load_concepts("glu", "mimic_demo")

gluc &lt;- concept("gluc",
  item("mimic_demo", "labevents", "itemid", list(c(50809L, 50931L)))
)

identical(load_concepts(gluc), dat)

class(dat)
class(load_concepts(c("sex", "age"), "mimic_demo"))
}

</code></pre>

<hr>
<h2 id='load_dictionary'>Load concept dictionaries</h2><span id='topic+load_dictionary'></span><span id='topic+concept_availability'></span><span id='topic+explain_dictionary'></span>

<h3>Description</h3>

<p>Data concepts can be specified in JSON format as a concept dictionary which
can be read and parsed into <code>concept</code>/<code>item</code> objects. Dictionary loading
can either be performed on the default included dictionary or on a user-
specified custom dictionary. Furthermore, a mechanism is provided for adding
concepts and/or data sources to the existing dictionary (see the Details
section).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_dictionary(
  src = NULL,
  concepts = NULL,
  name = "concept-dict",
  cfg_dirs = NULL
)

concept_availability(dict = NULL, include_rec = FALSE, ...)

explain_dictionary(
  dict = NULL,
  cols = c("name", "category", "description"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_dictionary_+3A_src">src</code></td>
<td>
<p><code>NULL</code> or the name of one or several data sources</p>
</td></tr>
<tr><td><code id="load_dictionary_+3A_concepts">concepts</code></td>
<td>
<p>A character vector used to subset the concept dictionary or
<code>NULL</code> indicating no subsetting</p>
</td></tr>
<tr><td><code id="load_dictionary_+3A_name">name</code></td>
<td>
<p>Name of the dictionary to be read</p>
</td></tr>
<tr><td><code id="load_dictionary_+3A_cfg_dirs">cfg_dirs</code></td>
<td>
<p>File name of the dictionary</p>
</td></tr>
<tr><td><code id="load_dictionary_+3A_dict">dict</code></td>
<td>
<p>A dictionary (<code>conncept</code> object) or <code>NULL</code></p>
</td></tr>
<tr><td><code id="load_dictionary_+3A_include_rec">include_rec</code></td>
<td>
<p>Logical flag indicating whether to include <code>rec_cncpt</code>
concepts as well</p>
</td></tr>
<tr><td><code id="load_dictionary_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>load_dictionary()</code> in case <code>NULL</code> is passed as
<code>dict</code> argument</p>
</td></tr>
<tr><td><code id="load_dictionary_+3A_cols">cols</code></td>
<td>
<p>Columns to include in the output of <code>explain_dictionary()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A default dictionary is provided at
</p>
<div class="sourceCode"><pre>system.file(
  file.path("extdata", "config", "concept-dict.json"),
  package = "ricu"
)
</pre></div>
<p>and can be loaded in to an R session by calling
<code>get_config("concept-dict")</code>. The default dictionary can be extended by
adding a file <code>concept-dict.json</code> to the path specified by the environment
variable <code>RICU_CONFIG_PATH</code>. New concepts can be added to this file and
existing concepts can be extended (by adding new data sources).
Alternatively, <code>load_dictionary()</code> can be called on non-default
dictionaries using the <code>file</code> argument.
</p>
<p>In order to specify a concept as JSON object, for example the numeric
concept for glucose, is given by
</p>
<div class="sourceCode"><pre>{
  "glu": {
    "unit": "mg/dL",
    "min": 0,
    "max": 1000,
    "description": "glucose",
    "category": "chemistry",
    "sources": {
      "mimic_demo": [
        {
          "ids": [50809, 50931],
          "table": "labevents",
          "sub_var": "itemid"
        }
      ]
    }
  }
}
</pre></div>
<p>Using such a specification, constructors for <code><a href="#topic+new_cncpt">cncpt</a></code> and
<code><a href="#topic+new_itm">itm</a></code> objects are called either using default arguments or as
specified by the JSON object, with the above corresponding to a call like
</p>
<div class="sourceCode"><pre>concept(
  name = "glu",
  items = item(
    src = "mimic_demo", table = "labevents", sub_var = "itemid",
    ids = list(c(50809L, 50931L))
  ),
  description = "glucose", category = "chemistry",
  unit = "mg/dL", min = 0, max = 1000
)
</pre></div>
<p>The arguments <code>src</code> and <code>concepts</code> can be used to only load a subset of a
dictionary by specifying a character vector of data sources and/or concept
names.
</p>
<p>A summary of item availability for a set of concepts can be created using
<code>concept_availability()</code>. This produces a logical matrix with <code>TRUE</code> entries
corresponding to concepts where for the given data source, at least a single
item has been defined. If data is loaded for a combination of concept and
data source, where the corresponding entry is <code>FALSE</code>, this will yield
either a zero-row <code>id_tbl</code> object or an object inheriting form <code>id_tbl</code>
where the column corresponding to the concept is <code>NA</code> throughout, depending
on whether the concept was loaded alongside other concepts where data is
available or not.
</p>
<p>Whether to include <code>rec_cncpt</code> concepts in the overview produced by
<code>concept_availability()</code> can be controlled via the logical flag
<code>include_rec</code>. A recursive concept is considered available simply if all its
building blocks are available. This can, however lead to slightly confusing
output as a recursive concept might not strictly depend on one of its
sub-concepts but handle such missingness by design. In such a scenario, the
availability summary might report <code>FALSE</code> even though data can still be
produced.
</p>


<h3>Value</h3>

<p>A <code>concept</code> object containing several data concepts as <code>cncpt</code>
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mimic.demo)) {
head(load_dictionary("mimic_demo"))
load_dictionary("mimic_demo", c("glu", "lact"))
}

</code></pre>

<hr>
<h2 id='load_id'>Load data as <code>id_tbl</code> or <code>ts_tbl</code> objects</h2><span id='topic+load_id'></span><span id='topic+load_id.src_tbl'></span><span id='topic+load_id.character'></span><span id='topic+load_id.itm'></span><span id='topic+load_id.fun_itm'></span><span id='topic+load_id.default'></span><span id='topic+load_ts'></span><span id='topic+load_ts.src_tbl'></span><span id='topic+load_ts.character'></span><span id='topic+load_ts.itm'></span><span id='topic+load_ts.fun_itm'></span><span id='topic+load_ts.default'></span><span id='topic+load_win'></span><span id='topic+load_win.src_tbl'></span><span id='topic+load_win.character'></span><span id='topic+load_win.itm'></span><span id='topic+load_win.fun_itm'></span><span id='topic+load_win.default'></span>

<h3>Description</h3>

<p>Building on functionality provided by <code><a href="#topic+load_src">load_src()</a></code> and <code><a href="#topic+load_difftime">load_difftime()</a></code>,
<code>load_id()</code> and <code>load_ts()</code> load data from disk as <code>id_tbl</code> and <code>ts_tbl</code>
objects respectively. Over <code>load_difftime()</code> both <code>load_id()</code> and
<code>load_ts()</code> provide a way to specify <code><a href="#topic+meta_vars">meta_vars()</a></code> (as <code>id_var</code> and
<code>index_var</code> arguments), as well as an interval size (as <code>interval</code>
argument) for time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_id(x, ...)

## S3 method for class 'src_tbl'
load_id(
  x,
  rows,
  cols = colnames(x),
  id_var = id_vars(x),
  interval = hours(1L),
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'character'
load_id(x, src, ...)

## S3 method for class 'itm'
load_id(
  x,
  cols = colnames(x),
  id_var = id_vars(x),
  interval = hours(1L),
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'fun_itm'
load_id(x, ...)

## Default S3 method:
load_id(x, ...)

load_ts(x, ...)

## S3 method for class 'src_tbl'
load_ts(
  x,
  rows,
  cols = colnames(x),
  id_var = id_vars(x),
  index_var = ricu::index_var(x),
  interval = hours(1L),
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'character'
load_ts(x, src, ...)

## S3 method for class 'itm'
load_ts(
  x,
  cols = colnames(x),
  id_var = id_vars(x),
  index_var = ricu::index_var(x),
  interval = hours(1L),
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'fun_itm'
load_ts(x, ...)

## Default S3 method:
load_ts(x, ...)

load_win(x, ...)

## S3 method for class 'src_tbl'
load_win(
  x,
  rows,
  cols = colnames(x),
  id_var = id_vars(x),
  index_var = ricu::index_var(x),
  interval = hours(1L),
  dur_var = ricu::dur_var(x),
  dur_is_end = TRUE,
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'character'
load_win(x, src, ...)

## S3 method for class 'itm'
load_win(
  x,
  cols = colnames(x),
  id_var = id_vars(x),
  index_var = ricu::index_var(x),
  interval = hours(1L),
  dur_var = ricu::dur_var(x),
  dur_is_end = TRUE,
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'fun_itm'
load_win(x, ...)

## Default S3 method:
load_win(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_id_+3A_x">x</code></td>
<td>
<p>Object for which to load data</p>
</td></tr>
<tr><td><code id="load_id_+3A_...">...</code></td>
<td>
<p>Generic consistency</p>
</td></tr>
<tr><td><code id="load_id_+3A_rows">rows</code></td>
<td>
<p>Expression used for row subsetting (NSE)</p>
</td></tr>
<tr><td><code id="load_id_+3A_cols">cols</code></td>
<td>
<p>Character vector of column names</p>
</td></tr>
<tr><td><code id="load_id_+3A_id_var">id_var</code></td>
<td>
<p>The column defining the id of <code>ts_tbl</code> and <code>id_tbl</code> objects</p>
</td></tr>
<tr><td><code id="load_id_+3A_interval">interval</code></td>
<td>
<p>The time interval used to discretize time stamps with,
specified as <code><a href="base.html#topic+difftime">base::difftime()</a></code> object</p>
</td></tr>
<tr><td><code id="load_id_+3A_time_vars">time_vars</code></td>
<td>
<p>Character vector enumerating the columns to be treated as
timestamps and thus returned as <code><a href="base.html#topic+difftime">base::difftime()</a></code> vectors</p>
</td></tr>
<tr><td><code id="load_id_+3A_src">src</code></td>
<td>
<p>Passed to <code><a href="#topic+as_src_tbl">as_src_tbl()</a></code> in order to determine the data source</p>
</td></tr>
<tr><td><code id="load_id_+3A_index_var">index_var</code></td>
<td>
<p>The column defining the index of <code>ts_tbl</code> objects</p>
</td></tr>
<tr><td><code id="load_id_+3A_dur_var">dur_var</code></td>
<td>
<p>The column used for determining durations</p>
</td></tr>
<tr><td><code id="load_id_+3A_dur_is_end">dur_is_end</code></td>
<td>
<p>Logical flag indicating whether to use durations as-is or
to calculated them by subtracting the <code>index_var</code> column</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While for <code><a href="#topic+load_difftime">load_difftime()</a></code> the ID variable can be suggested, the function
only returns a best effort at fulfilling this request. In some cases, where
the data does not allow for the desired ID type, data is returned using the
ID system (among all available ones for the given table) with highest
cardinality. Both <code>load_id()</code> and <code>load_ts()</code> are guaranteed to return an
object with <code><a href="#topic+id_vars">id_vars()</a></code> set as requested by the <code>id_var</code> argument.
Internally, the change of ID system is performed by <code><a href="#topic+change_id">change_id()</a></code>.
</p>
<p>Additionally, while times returned by <code><a href="#topic+load_difftime">load_difftime()</a></code> are in 1 minute
resolution, the time series step size can be specified by the <code>interval</code>
argument when calling <code>load_id()</code> or <code>load_ts()</code>. This rounding and
potential change of time unit is performed by <code><a href="#topic+change_interval">change_interval()</a></code> on all
columns specified by the <code>time_vars</code> argument. All time stamps are relative
to the origin provided by the ID system. This means that for an <code>id_var</code>
corresponding to hospital IDs, times are relative to hospital admission.
</p>
<p>When <code>load_id()</code> (or <code>load_ts()</code>) is called on <code><a href="#topic+new_itm">itm</a></code> objects
instead of <code><a href="#topic+new_src_tbl">src_tbl</a></code> (or objects that can be coerced to
<code>src_tbl</code>), The row-subsetting is performed according the the specification
as provided by the <code>itm</code> object. Furthermore, at default settings, columns
are returned as required by the <code>itm</code> object and <code>id_var</code> (as well as
<code>index_var</code>) are set accordingly if specified by the <code>itm</code> or set to
default values for the given <code>src_tbl</code> object if not explicitly specified.
</p>


<h3>Value</h3>

<p>An <code>id_tbl</code> or a <code>ts_tbl</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mimic.demo)) {
load_id("admissions", "mimic_demo", cols = "admission_type")

dat &lt;- load_ts(mimic_demo$labevents, itemid %in% c(50809L, 50931L),
               cols = c("itemid", "valuenum"))

glu &lt;- new_itm(src = "mimic_demo", table = "labevents",
               sub_var = "itemid", ids = c(50809L, 50931L))

identical(load_ts(glu), dat)
}

</code></pre>

<hr>
<h2 id='load_src'>Low level functions for loading data</h2><span id='topic+load_src'></span><span id='topic+load_src.src_tbl'></span><span id='topic+load_src.character'></span><span id='topic+load_difftime'></span><span id='topic+load_difftime.mimic_tbl'></span><span id='topic+load_difftime.eicu_tbl'></span><span id='topic+load_difftime.hirid_tbl'></span><span id='topic+load_difftime.aumc_tbl'></span><span id='topic+load_difftime.miiv_tbl'></span><span id='topic+load_difftime.character'></span>

<h3>Description</h3>

<p>Data loading involves a cascade of S3 generic functions, which can
individually be adapted to the specifics of individual data sources. A the
lowest level, <code>load_scr</code> is called, followed by <code>load_difftime()</code>.
Functions up the chain, are described in <code><a href="#topic+load_id">load_id()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_src(x, ...)

## S3 method for class 'src_tbl'
load_src(x, rows, cols = colnames(x), ...)

## S3 method for class 'character'
load_src(x, src, ...)

load_difftime(x, ...)

## S3 method for class 'mimic_tbl'
load_difftime(
  x,
  rows,
  cols = colnames(x),
  id_hint = id_vars(x),
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'eicu_tbl'
load_difftime(
  x,
  rows,
  cols = colnames(x),
  id_hint = id_vars(x),
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'hirid_tbl'
load_difftime(
  x,
  rows,
  cols = colnames(x),
  id_hint = id_vars(x),
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'aumc_tbl'
load_difftime(
  x,
  rows,
  cols = colnames(x),
  id_hint = id_vars(x),
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'miiv_tbl'
load_difftime(
  x,
  rows,
  cols = colnames(x),
  id_hint = id_vars(x),
  time_vars = ricu::time_vars(x),
  ...
)

## S3 method for class 'character'
load_difftime(x, src, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_src_+3A_x">x</code></td>
<td>
<p>Object for which to load data</p>
</td></tr>
<tr><td><code id="load_src_+3A_...">...</code></td>
<td>
<p>Generic consistency</p>
</td></tr>
<tr><td><code id="load_src_+3A_rows">rows</code></td>
<td>
<p>Expression used for row subsetting (NSE)</p>
</td></tr>
<tr><td><code id="load_src_+3A_cols">cols</code></td>
<td>
<p>Character vector of column names</p>
</td></tr>
<tr><td><code id="load_src_+3A_src">src</code></td>
<td>
<p>Passed to <code><a href="#topic+as_src_tbl">as_src_tbl()</a></code> in order to determine the data source</p>
</td></tr>
<tr><td><code id="load_src_+3A_id_hint">id_hint</code></td>
<td>
<p>String valued id column selection (not necessarily honored)</p>
</td></tr>
<tr><td><code id="load_src_+3A_time_vars">time_vars</code></td>
<td>
<p>Character vector enumerating the columns to be treated as
timestamps and thus returned as <code><a href="base.html#topic+difftime">base::difftime()</a></code> vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function extending the S3 generic <code>load_src()</code> is expected to load a
subset of rows/columns from a tabular data source. While the column
specification is provided as character vector of column names, the row
subsetting involves non-standard evaluation (NSE). Data-sets that are
included with <code>ricu</code> are represented by <code><a href="prt.html#topic+new_prt">prt</a></code> objects,
which use <code><a href="rlang.html#topic+eval_tidy">rlang::eval_tidy()</a></code> to evaluate NSE expressions. Furthermore,
<code>prt</code> objects potentially represent tabular data split into partitions and
row-subsetting expressions are evaluated per partition (see the <code>part_safe</code>
flag in <code><a href="prt.html#topic+nse">prt::subset.prt()</a></code>). The return value of <code>load_src()</code> is expected
to be of type <code>data.table</code>.
</p>
<p>Timestamps are represented differently among the included data sources:
while MIMIC-III and HiRID use absolute date/times, eICU provides temporal
information as minutes relative to ICU admission. Other data sources, such
as the ICU dataset provided by Amsterdam UMC, opt for relative times as
well, but not in minutes since admission, but in milliseconds. In order to
smoothen out such discrepancies, the next function in the data loading
hierarchy is <code>load_difftime()</code>. This function is expected to call
<code>load_src()</code> in order to load a subset of rows/columns from a table stored
on disk and convert all columns that represent timestamps (as specified by
the argument <code>time_vars</code>) into <code><a href="base.html#topic+difftime">base::difftime()</a></code> vectors using <code>mins</code> as
time unit.
</p>
<p>The returned object should be of type <code>id_tbl</code>, with the ID vars
identifying the ID system the times are relative to. If for example all
times are relative to ICU admission, the ICU stay ID should be returned as
ID column. The argument <code>id_hint</code> may suggest an ID type, but if in the raw
data, this ID is not available, <code>load_difftime()</code> may return data using a
different ID system. In MIMIC-III, for example, data in the <code>labevents</code>
table is available for <code>subject_id</code> (patient ID) pr <code>hadm_id</code> (hospital
admission ID). If data is requested for <code>icustay_id</code> (ICU stay ID), this
request cannot be fulfilled and data is returned using the ID system with
the highest cardinality (among the available ones). Utilities such as
<code><a href="#topic+change_id">change_id()</a></code> can the later be used to resolve data to <code>icustay_id</code>.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mimic.demo)) {
tbl &lt;- mimic_demo$labevents
col &lt;- c("charttime", "value")

load_src(tbl, itemid == 50809)

colnames(
  load_src("labevents", "mimic_demo", itemid == 50809, cols = col)
)

load_difftime(tbl, itemid == 50809)

colnames(
  load_difftime(tbl, itemid == 50809, col)
)

id_vars(
  load_difftime(tbl, itemid == 50809, id_hint = "icustay_id")
)

id_vars(
  load_difftime(tbl, itemid == 50809, id_hint = "subject_id")
)
}

</code></pre>

<hr>
<h2 id='load_src_cfg'>Load configuration for a data source</h2><span id='topic+load_src_cfg'></span>

<h3>Description</h3>

<p>For a data source to be accessible by <code>ricu</code>, a configuration object
inheriting from the S3 class <code>src_cfg</code> is required. Such objects can be
generated from JSON based configuration files, using <code>load_src_cfg()</code>.
Information encoded by this configuration object includes available ID
systems (mainly for use in <code><a href="#topic+change_id">change_id()</a></code>, default column names per table
for columns with special meaning (such as index column, value columns, unit
columns, etc.), as well as a specification used for initial setup of the
dataset which includes file names and column names alongside their data
types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_src_cfg(src = NULL, name = "data-sources", cfg_dirs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_src_cfg_+3A_src">src</code></td>
<td>
<p>(Optional) name(s) of data sources used for subsetting</p>
</td></tr>
<tr><td><code id="load_src_cfg_+3A_name">name</code></td>
<td>
<p>String valued name of a config file which will be looked up in
the default config directors</p>
</td></tr>
<tr><td><code id="load_src_cfg_+3A_cfg_dirs">cfg_dirs</code></td>
<td>
<p>Additional directory/ies to look for configuration files</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Configuration files are looked for as files <code>name</code> with added suffix
<code>.json</code> starting with the directory (or directories) supplied as <code>cfg_dirs</code>
argument, followed by the directory specified by the environment variable
<code>RICU_CONFIG_PATH</code>, and finally in <code>extdata/config</code> of the package install
directory. If files with matching names are found in multiple places they
are concatenated such that in cases of name clashes. the earlier hits take
precedent over the later ones. The following JSON code blocks show excerpts
of the config file available at
</p>
<div class="sourceCode"><pre>system.file("extdata", "config", "data-sources.json", package = "ricu")
</pre></div>
<p>A data source configuration entry in a config file starts with a name,
followed by optional entries <code>class_prefix</code> and further (variable)
key-value pairs, such as an URL. For more information on <code>class_prefix</code>,
please refer to the end of this section. Further entries include <code>id_cfg</code>
and <code>tables</code> which are explained in more detail below. As outline, this
gives for the data source <code>mimic_demo</code>, the following JSON object:
</p>
<div class="sourceCode"><pre>{
  "name": "mimic_demo",
  "class_prefix": ["mimic_demo", "mimic"],
  "url": "https://physionet.org/files/mimiciii-demo/1.4",
  "id_cfg": {
    ...
  },
  "tables": {
    ...
  }
}
</pre></div>
<p>The <code>id_cfg</code> entry is used to specify the available ID systems for a data
source and how they relate to each other. An ID system within the context
of <code>ricu</code> is a patient identifier of which typically several are present in
a data set. In MIMIC-III, for example, three ID systems are available:
patient IDs (<code>subject_id</code>), hospital admission IDs (<code>hadm_id</code>) and ICU stay
IDs (<code>icustay_id</code>). Furthermore there is a one-to-many relationship between
<code>subject_id</code> and <code>hadm_id</code>, as well as between <code>hadm_id</code> and <code>icustay_id</code>.
Required for defining an ID system are a name, a <code>position</code> entry which
orders the ID systems by their cardinality, a <code>table</code> entry, alongside
column specifications <code>id</code>, <code>start</code> and <code>end</code>, which define how the IDs
themselves, combined with start and end times can be loaded from a table.
This gives the following specification for the ICU stay ID system in
MIMIC-III:
</p>
<div class="sourceCode"><pre>{
  "icustay": {
    "id": "icustay_id",
    "position": 3,
    "start": "intime",
    "end": "outtime",
    "table": "icustays"
  }
}
</pre></div>
<p>Tables are defined by a name and entries <code>files</code>, <code>defaults</code>, and <code>cols</code>,
as well as optional entries <code>num_rows</code> and <code>partitioning</code>. As <code>files</code> entry,
a character vector of file names is expected. For all of MIMIC-III a single
<code>.csv</code> file corresponds to a table, but for example for HiRID, some tables
are distributed in partitions. The <code>defaults</code> entry consists of key-value
pairs, identifying columns in a table with special meaning, such as the
default index column or the set of all columns that represent timestamps.
This gives as an example for a table entry for the <code>chartevents</code> table in
MIMIC-III a JSON object like:
</p>
<div class="sourceCode"><pre>{
  "chartevents": {
    "files": "CHARTEVENTS.csv.gz",
    "defaults": {
      "index_var": "charttime",
      "val_var": "valuenum",
      "unit_var": "valueuom",
      "time_vars": ["charttime", "storetime"]
    },
    "num_rows": 330712483,
    "cols": {
      ...
    },
    "partitioning": {
      "col": "itemid",
      "breaks": [127, 210, 425, 549, 643, 741, 1483, 3458, 3695, 8440,
                 8553, 220274, 223921, 224085, 224859, 227629]
    }
  }
}
</pre></div>
<p>The optional <code>num_rows</code> entry is used when importing data (see
<code><a href="#topic+import_src">import_src()</a></code>) as a sanity check, which is not performed if this entry is
missing from the data source configuration. The remaining table entry,
<code>partitioning</code>, is optional in the sense that if it is missing, the table
is not partitioned and if it is present, the table will be partitioned
accordingly when being imported (see <code><a href="#topic+import_src">import_src()</a></code>). In order to specify a
partitioning, two entries are required, <code>col</code> and <code>breaks</code>, where the former
denotes a column and the latter a numeric vector which is used to construct
intervals according to which <code>col</code> is binned. As such, currently <code>col</code> is
required to be of numeric type. A <code>partitioning</code> entry as in the example
above will assign rows corresponding to <code>idemid</code> 1 through 126 to partition
1, 127 through 209 to partition 2 and so on up to partition 17.
</p>
<p>Column specifications consist of a <code>name</code> and a <code>spec</code> entry alongside a
name which determines the column name that will be used by <code>ricu</code>. The
<code>spec</code> entry is expected to be the name of a column specification function
of the <code>readr</code> package (see <code><a href="readr.html#topic+cols">readr::cols()</a></code>) and all further entries in a
<code>cols</code> object are used as arguments to the <code>readr</code> column specification.
For the <code>admissions</code> table of MIMIC-III the columns <code>hadm_id</code> and
<code>admittime</code> are represented by:
</p>
<div class="sourceCode"><pre>{
  ...,
  "hadm_id": {
    "name": "HADM_ID",
    "spec": "col_integer"
  },
  "admittime": {
    "name": "ADMITTIME",
    "spec": "col_datetime",
    "format": "%Y-%m-%d %H:%M:%S"
  },
  ...
}
</pre></div>
<p>Internally, a <code>src_cfg</code> object consist of further S3 classes, which are
instantiated when loading a JSON source configuration file. Functions for
creating and manipulating <code>src_cfg</code> and related objects are marked
<code>internal</code> but a brief overview is given here nevertheless:
</p>

<ul>
<li> <p><code>src_cfg</code>: wraps objects <code>id_cfg</code>, <code>col_cfg</code> and optionally <code>tbl_cfg</code>
</p>
</li>
<li> <p><code>id_cfg</code>: contains information in ID systems and is created from <code>id_cfg</code>
entries in config files
</p>
</li>
<li> <p><code>col_cfg</code>: contains column default settings represented by <code>defaults</code>
entries in table configuration blocks
</p>
</li>
<li> <p><code>tbl_cfg</code>: used when importing data and therefore encompasses information
in <code>files</code>, <code>num_rows</code> and <code>cols</code> entries of table configuration blocks
</p>
</li></ul>

<p>A <code>src_cfg</code> can be instantiated without corresponding <code>tbl_cfg</code> but
consequently cannot be used for data import (see <code><a href="#topic+import_src">import_src()</a></code>). In that
sense, table config entries <code>files</code> and <code>cols</code> are optional as well with
the restriction that the data source has to be already available in <code>.fst</code>
format
</p>
<p>An example for such a slimmed down config file is available at
</p>
<div class="sourceCode"><pre>system.file("extdata", "config", "demo-sources.json", package = "ricu")
</pre></div>
<p>The <code>class_prefix</code> entry in a data source configuration is used create sub-
classes to <code>src_cfg</code>, <code>id_cfg</code>, <code>col_cfg</code> and <code>tbl_cfg</code> classes and passed
on to constructors of <code>src_env</code> (<code><a href="#topic+new_src_env">new_src_env()</a></code>) and <code>src_tbl</code>
<code><a href="#topic+new_src_tbl">new_src_tbl()</a></code> objects. As an example, for the above <code>class_prefix</code> value
of <code>c("mimic_demo", "mimic")</code>, the corresponding <code>src_cfg</code> will be assigned
classes <code>c("mimic_demo_cfg", "mimic_cfg", "src_cfg")</code> and consequently the
<code>src_tbl</code> objects will inherit from <code>"mimic_demo_tbl"</code>, <code>"mimic_tbl"</code> and
<code> "src_tbl"</code>. This can be used to adapt the behavior of involved S3 generic
function to specifics of the different data sources. An example for this is
how <code><a href="#topic+load_difftime">load_difftime()</a></code> uses theses sub-classes to smoothen out different
time-stamp representations. Furthermore, such a design was chosen with
extensibility in mind. Currently, <code><a href="#topic+download_src">download_src()</a></code> is designed around data
sources hosted on PhysioNet, but in order to include a dataset external to
PhysioNet, the <code>download_src()</code> generic can simply be extended for the new
class.
</p>


<h3>Value</h3>

<p>A list of data source configurations as <code>src_cfg</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cfg &lt;- load_src_cfg("mimic_demo")
str(cfg, max.level = 1L)
cfg &lt;- cfg[["mimic_demo"]]
str(cfg, max.level = 1L)

cols &lt;- as_col_cfg(cfg)
index_var(head(cols))
time_vars(head(cols))

as_id_cfg(cfg)

</code></pre>

<hr>
<h2 id='min_or_na'>Utility functions</h2><span id='topic+min_or_na'></span><span id='topic+max_or_na'></span><span id='topic+is_val'></span><span id='topic+not_val'></span><span id='topic+is_true'></span><span id='topic+is_false'></span><span id='topic+last_elem'></span><span id='topic+first_elem'></span>

<h3>Description</h3>

<p>Several utility functions exported for convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_or_na(x)

max_or_na(x)

is_val(x, val)

not_val(x, val)

is_true(x)

is_false(x)

last_elem(x)

first_elem(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_or_na_+3A_x">x</code></td>
<td>
<p>Object to use</p>
</td></tr>
<tr><td><code id="min_or_na_+3A_val">val</code></td>
<td>
<p>Value to compare against or to use as replacement</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two functions <code>min_or_na()</code> and <code>max_or_na()</code> overcome a design choice
of <code><a href="base.html#topic+Extremes">base::min()</a></code> (or <code><a href="base.html#topic+Extremes">base::max()</a></code><code style="white-space: pre;">&#8288;) that can yield undesirable results. If called on a vector of all missing values with &#8288;</code>na.rm = TRUE<code style="white-space: pre;">&#8288;, &#8288;</code>Inf<code style="white-space: pre;">&#8288;(and&#8288;</code>-Inf<code style="white-space: pre;">&#8288;respectively) are returned. This is changed to returning a missing value of the same type as&#8288;</code>x'.
</p>
<p>The functions <code>is_val()</code> and <code>not_val()</code> (as well as analogously
<code>is_true()</code> and <code>is_false()</code>) return logical vectors of the same length as
the value passed as <code>x</code>, with non-base R semanticists of comparing against
<code>NA</code>: instead of returning <code>c(NA, TRUE)</code> for <code>c(NA, 5) == 5</code>, <code>is_val()</code>
will return <code style="white-space: pre;">&#8288;c(FALSE TRUE)&#8288;</code>. Passing <code>NA</code> as <code>val</code> might lead to unintended
results but no warning is thrown.
</p>
<p>Finally, <code>first_elem()</code> and <code>last_elem()</code> has the same semantics as
<code><a href="utils.html#topic+head">utils::head()</a></code> and <code><a href="utils.html#topic+head">utils::tail()</a></code> with <code>n = 1L</code> and <code>replace_na()</code> will
replace all occurrences of <code>NA</code> in <code>x</code> with <code>val</code> and can be called on both
objects inheriting from <code>data.table</code> in which case internally
<code><a href="data.table.html#topic+nafill">data.table::setnafill()</a></code> is called or other objects.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>min_or_na()</code>/<code>max_or_na()</code>: scalar-valued extrema of a vector
</p>
</li>
<li> <p><code>is_val()</code>/<code>not_val()</code>/<code>is_true()</code>/<code>is_false()</code>: Logical vector of the
same length as the object passed as <code>x</code>
</p>
</li>
<li> <p><code>first_elem()</code>/<code>last_elem()</code>: single element of the object passed as <code>x</code>
</p>
</li>
<li> <p><code>replace_na()</code>: modified version of the object passed as <code>x</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>some_na &lt;- c(NA, sample(1:10, 5), NA)
identical(min(some_na, na.rm = TRUE), min_or_na(some_na))

all_na &lt;- rep(NA, 5)
min(all_na, na.rm = TRUE)
min_or_na(all_na)

is_val(some_na, 5)
some_na == 5

is_val(some_na, NA)

identical(first_elem(letters), head(letters, n = 1L))
identical(last_elem(letters), tail(letters, n = 1L))

replace_na(some_na, 11)
replace_na(all_na, 11)
replace_na(1:5, 11)

tbl &lt;- ts_tbl(a = 1:10, b = hours(1:10), c = c(NA, 1:5, NA, 8:9, NA))
res &lt;- replace_na(tbl, 0)
identical(tbl, res)

</code></pre>

<hr>
<h2 id='msg_progress'>Message signaling nested with progress reporting</h2><span id='topic+msg_progress'></span><span id='topic+fmt_msg'></span>

<h3>Description</h3>

<p>In order to not interrupt progress reporting by a <a href="progress.html#topic+progress_bar">progress::progress_bar</a>,
messages are wrapped with class <code>msg_progress</code> which causes them to be
captured printed after progress bar completion. This function is intended to
be used when signaling messages in callback functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msg_progress(..., envir = parent.frame())

fmt_msg(msg, envir = parent.frame(), indent = 0L, exdent = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msg_progress_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+message">base::.makeMessage()</a></code></p>
</td></tr>
<tr><td><code id="msg_progress_+3A_envir">envir</code></td>
<td>
<p>Environment in this objects from <code>msg</code> are evaluated</p>
</td></tr>
<tr><td><code id="msg_progress_+3A_msg">msg</code></td>
<td>
<p>String valued message</p>
</td></tr>
<tr><td><code id="msg_progress_+3A_indent">indent</code>, <code id="msg_progress_+3A_exdent">exdent</code></td>
<td>
<p>Vector valued and mapped to <code><a href="fansi.html#topic+strwrap_ctl">fansi::strwrap2_ctl()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for side effects and returns <code>NULL</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>msg_progress("Foo", "bar")

capt_fun &lt;- function(x) {
  message("captured: ", conditionMessage(x))
}

tryCatch(msg_progress("Foo", "bar"), msg_progress = capt_fun)

</code></pre>

<hr>
<h2 id='new_cncpt'>Data Concepts</h2><span id='topic+new_cncpt'></span><span id='topic+is_cncpt'></span><span id='topic+init_cncpt'></span><span id='topic+init_cncpt.num_cncpt'></span><span id='topic+init_cncpt.unt_cncpt'></span><span id='topic+init_cncpt.fct_cncpt'></span><span id='topic+init_cncpt.cncpt'></span><span id='topic+init_cncpt.rec_cncpt'></span><span id='topic+new_concept'></span><span id='topic+concept'></span><span id='topic+is_concept'></span><span id='topic+as_concept'></span>

<h3>Description</h3>

<p>Concept objects are used in <code>ricu</code> as a way to specify how a clinical
concept, such as heart rate can be loaded from a data source and are mainly
consumed by <code><a href="#topic+load_concepts">load_concepts()</a></code>. Several functions are available for
constructing <code>concept</code> (and related auxiliary) objects either from code or
by parsing a JSON formatted concept dictionary using <code><a href="#topic+load_dictionary">load_dictionary()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_cncpt(
  name,
  items,
  description = name,
  omopid = NA_integer_,
  category = NA_character_,
  aggregate = NULL,
  ...,
  target = "ts_tbl",
  class = "num_cncpt"
)

is_cncpt(x)

init_cncpt(x, ...)

## S3 method for class 'num_cncpt'
init_cncpt(x, unit = NULL, min = NULL, max = NULL, ...)

## S3 method for class 'unt_cncpt'
init_cncpt(x, unit = NULL, min = NULL, max = NULL, ...)

## S3 method for class 'fct_cncpt'
init_cncpt(x, levels, ...)

## S3 method for class 'cncpt'
init_cncpt(x, ...)

## S3 method for class 'rec_cncpt'
init_cncpt(
  x,
  callback = paste0("rename_data_var('", x[["name"]], "')"),
  interval = NULL,
  ...
)

new_concept(x)

concept(...)

is_concept(x)

as_concept(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_cncpt_+3A_name">name</code></td>
<td>
<p>The name of the concept</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_items">items</code></td>
<td>
<p>Zero or more <code>itm</code> objects</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_description">description</code></td>
<td>
<p>String-valued concept description</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_omopid">omopid</code></td>
<td>
<p>OMOP identifier</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_category">category</code></td>
<td>
<p>String-valued category</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_aggregate">aggregate</code></td>
<td>
<p>NULL or a string denoting a function used to aggregate per
id and if applicable per time step</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_...">...</code></td>
<td>
<p>Further specification of the <code>cncpt</code> object (passed to
<code><a href="#topic+init_cncpt">init_cncpt()</a></code>)</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_target">target</code></td>
<td>
<p>The target object yielded by loading</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_class">class</code></td>
<td>
<p><code>NULL</code> or a string-valued sub-class name used for customizing
concept behavior</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_x">x</code></td>
<td>
<p>Object to query/dispatch on</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_unit">unit</code></td>
<td>
<p>A string, specifying the measurement unit of the concept (can
be <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_min">min</code>, <code id="new_cncpt_+3A_max">max</code></td>
<td>
<p>Scalar valued; defines a range of plausible values for a
numeric concept</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_levels">levels</code></td>
<td>
<p>A vector of possible values a categorical concept may take on</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_callback">callback</code></td>
<td>
<p>Name of a function to be called on the returned data used
for data cleanup operations</p>
</td></tr>
<tr><td><code id="new_cncpt_+3A_interval">interval</code></td>
<td>
<p>Time interval used for data loading; if NULL, the respective
interval passed as argument to <code><a href="#topic+load_concepts">load_concepts()</a></code> is taken</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to allow for a large degree of flexibility (and extensibility),
which is much needed owing to considerable heterogeneity presented by
different data sources, several nested S3 classes are involved in
representing a concept. An outline of this hierarchy can be described as
</p>

<ul>
<li> <p><code>concept</code>: contains many <code>cncpt</code> objects (of potentially differing
sub-types), each comprising of some meta-data and an <code>item</code> object
</p>
</li>
<li> <p><code>item</code>: contains many <code>itm</code> objects (of potentially differing
sub-types), each encoding how to retrieve a data item.
</p>
</li></ul>

<p>The design choice for wrapping a vector of <code>cncpt</code> objects with a container
class <code>concept</code> is motivated by the requirement of having several different
sub-types of <code>cncpt</code> objects (all inheriting from the parent type <code>cncpt</code>),
while retaining control over how this homogeneous w.r.t. parent type, but
heterogeneous w.r.t. sub-type vector of objects behaves in terms of S3
generic functions.
</p>
<p>Each individual <code>cncpt</code> object contains the following information: a string-
valued name, an <code><a href="#topic+new_itm">item</a></code> vector containing <code><a href="#topic+new_itm">itm</a></code>
objects, a string-valued description (can be missing), a string-valued
category designation (can be missing), a character vector-valued
specification for an aggregation function and a target class specification
(e.g. <code><a href="#topic+id_tbl">id_tbl</a></code> or <code><a href="#topic+id_tbl">ts_tbl</a></code>). Additionally, a sub-
class to <code>cncpt</code> has to be specified, each representing a different
data-scenario and holding further class-specific information. The following
sub-classes to <code>cncpt</code> are available:
</p>

<ul>
<li> <p><code>num_cncpt</code>: The most widely used concept type is indented for concepts
representing numerical measurements. Additional information that can be
specified includes a string-valued unit specification, alongside a
plausible range which can be used during data loading.
</p>
</li>
<li> <p><code>fct_cncpt</code>: In case of categorical concepts, such as <code>sex</code>, a set of
factor levels can be specified, against which the loaded data is checked.
</p>
</li>
<li> <p><code>lgl_cncpt</code>: A special case of <code>fct_cncpt</code>, this allows only for logical
values (<code>TRUE</code>, <code>FALSE</code> and <code>NA</code>).
</p>
</li>
<li> <p><code>rec_cncpt</code>: More involved concepts, such as a <a href="#topic+sofa_score">SOFA score</a>
can pull in other concepts. Recursive concepts can build on other
recursive concepts up to arbitrary recursion depth. Owing to the more
complicated nature of such concepts, a <code>callback</code> function can be
specified which is used in data loading for concept-specific post-
processing steps.
</p>
</li>
<li> <p><code>unt_cncpt</code>: A recent (experimental) addition which inherits from
<code>num_cncpt</code> but instead of manual unit conversion, leverages
</p>
</li></ul>

<p>Class instantiation is organized in the same fashion as for
<code><a href="#topic+new_itm">item</a></code> objects: <code>concept()</code> maps vector-valued arguments
to <code>new_cncpt()</code>, which internally calls the S3 generic function
<code>init_cncpt()</code>, while <code>new_concept()</code> instantiates a <code>concept</code> object from
a list of <code>cncpt</code> objects (created by calls to <code>new_cncpt()</code>). Coercion is
only possible from <code>list</code> and <code>cncpt</code>, by calling <code>as_concept()</code> and
inheritance can be checked using <code>is_concept()</code> or <code>is_cncpt()</code>.
</p>


<h3>Value</h3>

<p>Constructors and coercion functions return <code>cncpt</code> and <code>concept</code>
objects, while inheritance tester functions return logical flags.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mimic.demo)) {
gluc &lt;- concept("glu",
  item("mimic_demo", "labevents", "itemid", list(c(50809L, 50931L))),
  description = "glucose", category = "chemistry",
  unit = "mg/dL", min = 0, max = 1000
)

is_concept(gluc)

identical(gluc, load_dictionary("mimic_demo", "glu"))

gl1 &lt;- new_cncpt("glu",
  item("mimic_demo", "labevents", "itemid", list(c(50809L, 50931L))),
  description = "glucose"
)

is_cncpt(gl1)
is_concept(gl1)

conc &lt;- concept(c("glu", "lact"),
  list(
    item("mimic_demo", "labevents", "itemid", list(c(50809L, 50931L))),
    item("mimic_demo", "labevents", "itemid", 50813L)
  ),
  description = c("glucose", "lactate")
)

conc

identical(as_concept(gl1), conc[1L])
}

</code></pre>

<hr>
<h2 id='new_itm'>Data items</h2><span id='topic+new_itm'></span><span id='topic+is_itm'></span><span id='topic+init_itm'></span><span id='topic+init_itm.sel_itm'></span><span id='topic+init_itm.hrd_itm'></span><span id='topic+init_itm.col_itm'></span><span id='topic+init_itm.rgx_itm'></span><span id='topic+init_itm.fun_itm'></span><span id='topic+init_itm.itm'></span><span id='topic+new_item'></span><span id='topic+item'></span><span id='topic+as_item'></span><span id='topic+is_item'></span>

<h3>Description</h3>

<p>Item objects are used in <code>ricu</code> as a way to specify how individual data
items corresponding to clinical concepts (see also <code><a href="#topic+concept">concept()</a></code>), such as
heart rate can be loaded from a data source. Several functions are
available for constructing <code>item</code> (and related auxiliary) objects either
from code or by parsing a JSON formatted concept dictionary using
<code><a href="#topic+load_dictionary">load_dictionary()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_itm(src, ..., interval = NULL, target = NA_character_, class = "sel_itm")

is_itm(x)

init_itm(x, ...)

## S3 method for class 'sel_itm'
init_itm(x, table, sub_var, ids, callback = "identity_callback", ...)

## S3 method for class 'hrd_itm'
init_itm(x, table, sub_var, ids, callback = "identity_callback", ...)

## S3 method for class 'col_itm'
init_itm(x, table, unit_val = NULL, callback = "identity_callback", ...)

## S3 method for class 'rgx_itm'
init_itm(x, table, sub_var, regex, callback = "identity_callback", ...)

## S3 method for class 'fun_itm'
init_itm(x, callback, ...)

## S3 method for class 'itm'
init_itm(x, ...)

new_item(x)

item(...)

as_item(x)

is_item(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_itm_+3A_src">src</code></td>
<td>
<p>The data source name</p>
</td></tr>
<tr><td><code id="new_itm_+3A_...">...</code></td>
<td>
<p>Further specification of the <code>itm</code> object (passed to
<code><a href="#topic+init_itm">init_itm()</a></code>)</p>
</td></tr>
<tr><td><code id="new_itm_+3A_interval">interval</code></td>
<td>
<p>A default data loading interval (either specified as scalar
<code>difftime</code> or string such as &quot;00:01:00&quot;)</p>
</td></tr>
<tr><td><code id="new_itm_+3A_target">target</code></td>
<td>
<p>Item target class (e.g. &quot;id_tbl&quot;), <code>NA</code> indicates no specific
class requirement</p>
</td></tr>
<tr><td><code id="new_itm_+3A_class">class</code></td>
<td>
<p>Sub class for customizing <code>itm</code> behavior</p>
</td></tr>
<tr><td><code id="new_itm_+3A_x">x</code></td>
<td>
<p>Object to query/dispatch on</p>
</td></tr>
<tr><td><code id="new_itm_+3A_table">table</code></td>
<td>
<p>Name of the table containing the data</p>
</td></tr>
<tr><td><code id="new_itm_+3A_sub_var">sub_var</code></td>
<td>
<p>Column name used for subsetting</p>
</td></tr>
<tr><td><code id="new_itm_+3A_ids">ids</code></td>
<td>
<p>Vector of ids used to subset table rows. If <code>NULL</code>, all rows are
considered corresponding to the data item</p>
</td></tr>
<tr><td><code id="new_itm_+3A_callback">callback</code></td>
<td>
<p>Name of a function to be called on the returned data used
for data cleanup operations (or a string that evaluates to a function)</p>
</td></tr>
<tr><td><code id="new_itm_+3A_unit_val">unit_val</code></td>
<td>
<p>String valued unit to be used in case no <code>unit_var</code> is
available for the given table</p>
</td></tr>
<tr><td><code id="new_itm_+3A_regex">regex</code></td>
<td>
<p>String-valued regular expression which will be evaluated by
<code><a href="base.html#topic+grep">base::grepl()</a></code> with <code>ignore.case = TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to allow for a large degree of flexibility (and extensibility),
which is much needed owing to considerable heterogeneity presented by
different data sources, several nested S3 classes are involved in
representing a concept. An outline of this hierarchy can be described as
</p>

<ul>
<li> <p><code><a href="#topic+concept">concept</a></code>: contains many <code>cncpt</code> objects (of potentially
differing sub-types), each comprising of some meta-data and an <code>item</code>
object
</p>
</li>
<li> <p><code>item</code>: contains many <code>itm</code> objects (of potentially differing
sub-types), each encoding how to retrieve a data item.
</p>
</li></ul>

<p>The design choice for wrapping a vector of <code>itm</code> objects with a container
class <code>item</code> is motivated by the requirement of having several different
sub-types of <code>itm</code> objects (all inheriting from the parent type <code>itm</code>),
while retaining control over how this homogeneous w.r.t. parent type, but
heterogeneous w.r.t. sub-type vector of objects behaves in terms of S3
generic functions.
</p>
<p>The following sub-classes to <code>itm</code> are available, each representing a
different data-scenario:
</p>

<ul>
<li> <p><code>sel_itm</code>: The most widely used item class is intended for the situation
where rows of interest can be identified by looking for occurrences of a
set of IDs (<code>ids</code>) in a column (<code>sub_var</code>). An example for this is heart
rate <code>hr</code> on mimic, where the IDs <code>211</code> and 220045<code style="white-space: pre;">&#8288;are looked up in the&#8288;</code>itemid<code style="white-space: pre;">&#8288;column of&#8288;</code>chartevents'.
</p>
</li>
<li> <p><code>col_itm</code>: This item class can be used if no row-subsetting is required.
An example for this is heart rate (<code>hr</code>) on <code>eicu</code>, where the table
<code>vitalperiodic</code> contains an entire column dedicated to heart rate
measurements.
</p>
</li>
<li> <p><code>rgx_itm</code>: As alternative to the value-matching approach of <code>sel_itm</code>
objects, this class identifies rows using regular expressions. Used for
example for insulin in <code>eicu</code>, where the regular expression <code style="white-space: pre;">&#8288;^insulin (250.+)?\\(((ml|units)/hr)?\\)$&#8288;</code> is matched against the <code>drugname</code> column
of <code>infusiondrug</code>. The regular expression is evaluated by <code><a href="base.html#topic+grep">base::grepl()</a></code>
with <code>ignore.case = TRUE</code>.
</p>
</li>
<li> <p><code>fun_itm</code>: Intended for the scenario where data of interest is not
directly available from a table, this <code>itm</code> class offers most flexibility.
A function can be specified as <code>callback</code> and this function will be called
with arguments <code>x</code> (the object itself), <code>patient_ids</code>, <code>id_type</code> and
<code>interval</code> (see <code><a href="#topic+load_concepts">load_concepts()</a></code>) and is expected to return an object as
specified by the <code>target</code> entry.
</p>
</li>
<li> <p><code>hrd_itm</code>: A special case of <code>sel_itm</code> for HiRID data where measurement
units are not available as separate column, but as separate table with
units fixed per concept.
</p>
</li></ul>

<p>All <code>itm</code> objects have to specify a data source (<code>src</code>) as well as a
sub-class. Further arguments then are specific to the respective sub-class
and encode information that define data loading, such as the table to
query, the column name and values to use for identifying relevant rows,
etc. The S3 generic function <code>init_itm()</code> is responsible for input
validation of class-specific arguments as well as class initialization. A
list of <code>itm</code> objects, created by calls to <code>new_itm()</code> can be passed to
<code>new_item</code> in order to instantiate an <code>item</code> object. An alternative
constructor for <code>item</code> objects is given by <code>item()</code> which calls <code>new_itm()</code>
on the passed arguments (see examples). Finally <code>as_item()</code> can be used
for coercion of related objects such as <code>list</code>, <code>concept</code>, and the like.
Several additional S3 generic functions exist for manipulation of
<code>item</code>-like objects but are marked <code>internal</code> (see
<a href="#topic+prepare_query">item/concept utilities</a>).
</p>


<h3>Value</h3>

<p>Constructors and coercion functions return <code>itm</code> and <code>item</code> objects,
while inheritance tester functions return logical flags.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mimic.demo)) {
gluc &lt;- item("mimic_demo", "labevents", "itemid", list(c(50809L, 50931L)),
             unit_var = TRUE, target = "ts_tbl")

is_item(gluc)

all.equal(gluc, as_item(load_dictionary("mimic_demo", "glu")))

hr1 &lt;- new_itm(src = "mimic_demo", table = "chartevents",
               sub_var = "itemid", ids = c(211L, 220045L))

hr2 &lt;- item(src = c("mimic_demo", "eicu_demo"),
            table = c("chartevents", "vitalperiodic"),
            sub_var = list("itemid", NULL),
            val_var = list(NULL, "heartrate"),
            ids = list(c(211L, 220045L), FALSE),
            class = c("sel_itm", "col_itm"))

hr3 &lt;- new_itm(src = "eicu_demo", table = "vitalperiodic",
               val_var = "heartrate", class = "col_itm")

identical(as_item(hr1), hr2[1])
identical(new_item(list(hr1)), hr2[1])
identical(hr2, as_item(list(hr1, hr3)))
}

</code></pre>

<hr>
<h2 id='new_src_cfg'>Internal utilities for working with data source configurations</h2><span id='topic+new_src_cfg'></span><span id='topic+new_id_cfg'></span><span id='topic+new_col_cfg'></span><span id='topic+new_tbl_cfg'></span><span id='topic+is_src_cfg'></span><span id='topic+as_src_cfg'></span><span id='topic+is_id_cfg'></span><span id='topic+as_id_cfg'></span><span id='topic+is_col_cfg'></span><span id='topic+as_col_cfg'></span><span id='topic+is_tbl_cfg'></span><span id='topic+as_tbl_cfg'></span><span id='topic+src_name'></span><span id='topic+tbl_name'></span><span id='topic+src_extra_cfg'></span><span id='topic+src_prefix'></span><span id='topic+src_url'></span><span id='topic+id_var_opts'></span><span id='topic+default_vars'></span>

<h3>Description</h3>

<p>Data source configuration objects store information on data sources used
throughout <code>ricu</code>. This includes URLs for data set downloading, Column
specifications used for data set importing, default values per table for
important columns such as index columns when loading data and how different
patient identifiers used throughout a dataset relate to another. Per
dataset, a <code>src_cfg</code> object is created from a JSON file (see
<code><a href="#topic+load_src_cfg">load_src_cfg()</a></code>), consisting of several helper-classes compartmentalizing
the pieces of information outlined above. Alongside constructors for the
various classes, several utilities, such as inheritance checks, coercion
functions, as well as functions to extract pieces of information from these
objects are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_src_cfg(name, id_cfg, col_cfg, tbl_cfg, ..., class_prefix = name)

new_id_cfg(
  src,
  name,
  id,
  pos = seq_along(name),
  start = NULL,
  end = NULL,
  table = NULL,
  class_prefix = src
)

new_col_cfg(src, table, ..., class_prefix = src)

new_tbl_cfg(
  src,
  table,
  files = NULL,
  cols = NULL,
  num_rows = NULL,
  partitioning = NULL,
  ...,
  class_prefix = src
)

is_src_cfg(x)

as_src_cfg(x)

is_id_cfg(x)

as_id_cfg(x)

is_col_cfg(x)

as_col_cfg(x)

is_tbl_cfg(x)

as_tbl_cfg(x)

src_name(x)

tbl_name(x)

src_extra_cfg(x)

src_prefix(x)

src_url(x)

id_var_opts(x)

default_vars(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_src_cfg_+3A_name">name</code></td>
<td>
<p>Name of the data source</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_id_cfg">id_cfg</code></td>
<td>
<p>An <code>id_cfg</code> object for the given data source</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_col_cfg">col_cfg</code></td>
<td>
<p>A list of <code>col_cfg</code> objects representing column defaults for
all tables of the</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_tbl_cfg">tbl_cfg</code></td>
<td>
<p>A list of <code>tbl_cfg</code> containing information on how tables are
organized (may be <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_...">...</code></td>
<td>
<p>Further objects to add (such as an URL specification)</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_class_prefix">class_prefix</code></td>
<td>
<p>A character vector of class prefixes that are added to
the instantiated classes</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_src">src</code></td>
<td>
<p>Data source name</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_id">id</code>, <code id="new_src_cfg_+3A_start">start</code>, <code id="new_src_cfg_+3A_end">end</code></td>
<td>
<p>Name(s) of ID column(s), as well as respective start
and end timestamps</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_pos">pos</code></td>
<td>
<p>Integer valued position, ordering IDs by their cardinality</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_table">table</code></td>
<td>
<p>Table name</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_cols">cols</code></td>
<td>
<p>List containing a list per column each holding string valued
entries <code>name</code> (column name as used by <code>ricu</code>), <code>col</code> (column name as used
in the raw data) and <code>spec</code> (name of <code><a href="readr.html#topic+cols">readr::cols()</a></code> column specification).
Further entries will be passed as argument to the respective <code>readr</code> column
specification</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_num_rows">num_rows</code></td>
<td>
<p>A count indicating the expected number of rows</p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_partitioning">partitioning</code></td>
<td>
<p>A table partitioning is defined by a column name and a
vector of numeric values that are passed as <code>vec</code> argument to
<code>base::findInterval()</code></p>
</td></tr>
<tr><td><code id="new_src_cfg_+3A_x">x</code></td>
<td>
<p>Object to coerce/query</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following classes are used to represent data source configuration
objects:
</p>

<ul>
<li> <p><code>src_cfg</code>: wraps objects <code>id_cfg</code>, <code>col_cfg</code> and optionally <code>tbl_cfg</code>
</p>
</li>
<li> <p><code>id_cfg</code>: contains information in ID systems and is created from <code>id_cfg</code>
entries in config files
</p>
</li>
<li> <p><code>col_cfg</code>: contains column default settings represented by <code>defaults</code>
entries in table configuration blocks
</p>
</li>
<li> <p><code>tbl_cfg</code>: used when importing data and therefore encompasses information
in <code>files</code>, <code>num_rows</code> and <code>cols</code> entries of table configuration blocks
</p>
</li></ul>

<p>Represented by a <code>col_cfg</code>, a table can have some of its columns marked as
default columns for the following concepts and further column meanings can
be specified via <code>...</code>:
</p>

<ul>
<li> <p><code>id_col</code>: column will be used for as id for <code>icu_tbl</code> objects
</p>
</li>
<li> <p><code>index_col</code>: column represents a timestamp variable and will be use as
such for <code>ts_tbl</code> objects
</p>
</li>
<li> <p><code>val_col</code>: column contains the measured variable of interest
</p>
</li>
<li> <p><code>unit_col</code>: column specifies the unit of measurement in the corresponding
<code>val_col</code>
</p>
</li></ul>

<p>Alongside constructors (<code style="white-space: pre;">&#8288;new_*()&#8288;</code>), inheritance checking functions
(<code style="white-space: pre;">&#8288;is_*()&#8288;</code>), as well as coercion functions (<code style="white-space: pre;">&#8288;as_*(&#8288;</code>), relevant utility
functions include:
</p>

<ul>
<li> <p><code>src_url()</code>: retrieve the URL of a data source
</p>
</li>
<li> <p><code>id_var_opts()</code>: column name(s) corresponding to ID systems
</p>
</li>
<li> <p><code>src_name()</code>: name of the data source
</p>
</li>
<li> <p><code>tbl_name()</code>: name of a table
</p>
</li></ul>

<p>Coercion between objects under some circumstances can yield list-of object
return types. For example when coercing <code>src_cfg</code> to <code>tbl_cfg</code>, this will
result in a list of <code>tbl_cfg</code> objects, as multiple tables typically
correspond to a data source.
</p>


<h3>Value</h3>

<p>Constructors <code style="white-space: pre;">&#8288;new_*()&#8288;</code> as well as coercion functions <code style="white-space: pre;">&#8288;as_*()&#8288;</code>
return the respective objects, while inheritance tester functions <code style="white-space: pre;">&#8288;is_*()&#8288;</code>
return a logical flag.
</p>

<ul>
<li> <p><code>src_url()</code>: string valued data source URL
</p>
</li>
<li> <p><code>id_var_opts()</code>: character vector of ID variable options
</p>
</li>
<li> <p><code>src_name()</code>: string valued data source name
</p>
</li>
<li> <p><code>tbl_name()</code>: string valued table name
</p>
</li></ul>


<hr>
<h2 id='new_src_tbl'>Data source environments</h2><span id='topic+new_src_tbl'></span><span id='topic+is_src_tbl'></span><span id='topic+as_src_tbl'></span><span id='topic+as_src_tbl.src_env'></span><span id='topic+new_src_env'></span><span id='topic+is_src_env'></span><span id='topic+as.list.src_env'></span><span id='topic+as_src_env'></span><span id='topic+attached_srcs'></span><span id='topic+is_tbl_avail'></span><span id='topic+src_tbl_avail'></span><span id='topic+src_data_avail'></span><span id='topic+is_data_avail'></span>

<h3>Description</h3>

<p>Attaching a data source (see <code><a href="#topic+attach_src">attach_src()</a></code>) instantiates two types of S3
classes: a single <code>src_env</code> object, representing the data source as
collection of tables, as well as a <code>src_tbl</code> objects per table,
representing the given table. Upon package loading, <code>src_env</code> objects
including the respective <code>src_tbl</code> objects are created for all data sources
that are configured for auto-attaching, irrespective of whether data is
actually available. If some (or all) data is missing, the user is asked for
permission to download in interactive sessions and an error is thrown in
non-interactive sessions. See <code><a href="#topic+setup_src_env">setup_src_env()</a></code> for manually downloading
and setting up data sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_src_tbl(files, col_cfg, tbl_cfg, prefix, src_env)

is_src_tbl(x)

as_src_tbl(x, ...)

## S3 method for class 'src_env'
as_src_tbl(x, tbl, ...)

new_src_env(x, env = new.env(parent = data_env()), link = NULL)

is_src_env(x)

## S3 method for class 'src_env'
as.list(x, ...)

as_src_env(x)

attached_srcs()

is_tbl_avail(tbl, env)

src_tbl_avail(env, tbls = ls(envir = env))

src_data_avail(src = auto_attach_srcs())

is_data_avail(src = auto_attach_srcs())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_src_tbl_+3A_files">files</code></td>
<td>
<p>File names of <code>fst</code> files that will be used to create a <code>prt</code>
object (see also <code><a href="prt.html#topic+new_prt">prt::new_prt()</a></code>)</p>
</td></tr>
<tr><td><code id="new_src_tbl_+3A_col_cfg">col_cfg</code></td>
<td>
<p>Coerced to <code>col_cfg</code> by calling <code><a href="#topic+as_col_cfg">as_col_cfg()</a></code></p>
</td></tr>
<tr><td><code id="new_src_tbl_+3A_tbl_cfg">tbl_cfg</code></td>
<td>
<p>Coerced to <code>tbl_cfg</code> by calling <code><a href="#topic+as_tbl_cfg">as_tbl_cfg()</a></code></p>
</td></tr>
<tr><td><code id="new_src_tbl_+3A_prefix">prefix</code></td>
<td>
<p>Character vector valued data source name(s) (used as class
prefix)</p>
</td></tr>
<tr><td><code id="new_src_tbl_+3A_src_env">src_env</code></td>
<td>
<p>The data source environment (as <code>src_env</code> object)</p>
</td></tr>
<tr><td><code id="new_src_tbl_+3A_x">x</code></td>
<td>
<p>Object to test/coerce</p>
</td></tr>
<tr><td><code id="new_src_tbl_+3A_tbl">tbl</code></td>
<td>
<p>String-valued table name</p>
</td></tr>
<tr><td><code id="new_src_tbl_+3A_env">env</code></td>
<td>
<p>Environment used as <code>src_env</code></p>
</td></tr>
<tr><td><code id="new_src_tbl_+3A_link">link</code></td>
<td>
<p><code>NULL</code> or a second environment (in addition to <code>data_env()</code>) in
which the resulting <code>src_env</code> is bound to a name</p>
</td></tr>
<tr><td><code id="new_src_tbl_+3A_tbls">tbls</code></td>
<td>
<p>Character vector of table names</p>
</td></tr>
<tr><td><code id="new_src_tbl_+3A_src">src</code></td>
<td>
<p>Character vector of data source names or any other object (or
list thereof) for which an <code>as_src_env()</code> method exists</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>src_env</code> object is an environment with attributes <code>src_name</code> (a
string-valued data source name, such as <code>mimic_demo</code>) and <code>id_cfg</code>
(describing the possible patient IDs for the given data source). In
addition to the <code>src_env</code> class attribute, sub-classes are defined by the
source <code>class_prefix</code> configuration setting (see <code><a href="#topic+load_src_cfg">load_src_cfg()</a></code>). Such
data source environments are intended to contain several corresponding
<code>src_tbl</code> objects (or rather active bindings that evaluate to <code>src_tbl</code>
objects; see <code><a href="#topic+setup_src_env">setup_src_env()</a></code>).
</p>
<p>The S3 class <code>src_tbl</code> inherits from <code><a href="prt.html#topic+new_prt">prt</a></code>, which
represents a partitioned <code><a href="fst.html#topic+fst">fst</a></code> file. In addition to the <code>prt</code>
object, meta data in the form of <code>col_cfg</code> and <code>tbl_cfg</code> is associated with
a <code>src_tbl</code> object (see <code><a href="#topic+load_src_cfg">load_src_cfg()</a></code>). Furthermore, sub-classes are
added as specified by the source configuration <code>class_prefix</code> entry, as
with <code>src_env</code> objects. This allows certain functionality, for example data
loading, to be adapted to data source-specific requirements.
</p>
<p>Instantiation and set up of <code>src_env</code> objects is possible irrespective of
whether the underlying data is available. If some (or all) data is missing,
the user is asked for permission to download in interactive sessions and an
error is thrown in non-interactive sessions upon first access of a
<code>src_tbl</code> bound as set up by <code><a href="#topic+setup_src_env">setup_src_env()</a></code>. Data availability can be
checked with the following utilities:
</p>

<ul>
<li> <p><code>is_tbl_avail()</code>: Returns a logical flag indicating whether all required
data for the table passed as <code>tbl</code> which may be a string or any object
that has a <code>tbl_name()</code> implementation is available from the environment
<code>env</code> (requires an <code>as_src_env()</code> method).
</p>
</li>
<li> <p><code>src_tbl_avail()</code>: Returns a named logical vector, indicating which tables
have all required data available. As above, both <code>tbls</code> (arbitrary
length) and <code>env</code> (scalar-valued) may be character vectors or objects
with corresponding <code>tbl_name()</code> and <code>as_src_env()</code> methods.
</p>
</li>
<li> <p><code>src_data_avail()</code>: The most comprehensive data availability report can
be generated by calling <code>src_data_avail()</code>, returning a <code>data.frame</code> with
columns <code>name</code> (the data source name), <code>available</code> (logical vector
indicating whether all data is available), <code>tables</code> (the number of
available tables) and <code>total</code> (the total number of tables). As input,
<code>src</code> may be an arbitrary length character vector, an object for which an
<code>as_src_env()</code> method is defined or an arbitrary-length list thereof.
</p>
</li>
<li> <p><code>is_data_avail()</code>: Returns a named logical vector, indicating for which
data sources all required data is available. As above, <code>src</code> may be an
arbitrary length character vector, an object for which an <code>as_src_env()</code>
method is defined or an arbitrary-length list thereof.
</p>
</li></ul>



<h3>Value</h3>

<p>The constructors <code>new_src_env()</code>/<code>new_src_tbl()</code> as well as coercion
functions <code>as_src_env()</code>/<code>as_src_tbl()</code> return <code>src_env</code> and <code>src_tbl</code>
objects respectively, while inheritance testers <code>is_src_env()</code>/
<code>is_src_tbl()</code> return logical flags. For data availability utilities, see
Details section.
</p>

<hr>
<h2 id='pafi'>Concept callback functions</h2><span id='topic+pafi'></span><span id='topic+safi'></span><span id='topic+vent_ind'></span><span id='topic+gcs'></span><span id='topic+urine24'></span><span id='topic+vaso60'></span><span id='topic+vaso_ind'></span><span id='topic+supp_o2'></span><span id='topic+avpu'></span><span id='topic+bmi'></span><span id='topic+norepi_equiv'></span>

<h3>Description</h3>

<p>Owing to increased complexity and more diverse applications, recursive
concepts (class <code><a href="#topic+new_cncpt">rec_cncpt</a></code>) may specify callback functions
to be called on corresponding data objects and perform post-processing
steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pafi(
  ...,
  match_win = hours(2L),
  mode = c("match_vals", "extreme_vals", "fill_gaps"),
  fix_na_fio2 = TRUE,
  interval = NULL
)

safi(
  ...,
  match_win = hours(2L),
  mode = c("match_vals", "extreme_vals", "fill_gaps"),
  fix_na_fio2 = TRUE,
  interval = NULL
)

vent_ind(..., match_win = hours(6L), min_length = mins(30L), interval = NULL)

gcs(
  ...,
  valid_win = hours(6L),
  sed_impute = c("max", "prev", "none", "verb"),
  set_na_max = TRUE,
  interval = NULL
)

urine24(
  ...,
  min_win = hours(12L),
  limits = NULL,
  start_var = "start",
  end_var = "end",
  interval = NULL
)

vaso60(..., max_gap = mins(5L), interval = NULL)

vaso_ind(..., interval = NULL)

supp_o2(..., interval = NULL)

avpu(..., interval = NULL)

bmi(..., interval = NULL)

norepi_equiv(..., interval = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pafi_+3A_...">...</code></td>
<td>
<p>Data input used for concept calculation</p>
</td></tr>
<tr><td><code id="pafi_+3A_match_win">match_win</code></td>
<td>
<p>Time-span during which matching of values is allowed</p>
</td></tr>
<tr><td><code id="pafi_+3A_mode">mode</code></td>
<td>
<p>Method for matching PaO<sub>2</sub> and FiO<sub>2</sub> values</p>
</td></tr>
<tr><td><code id="pafi_+3A_fix_na_fio2">fix_na_fio2</code></td>
<td>
<p>Logical flag indicating whether to impute missing
FiO<sub>2</sub> values with 21</p>
</td></tr>
<tr><td><code id="pafi_+3A_interval">interval</code></td>
<td>
<p>Expected time series step size (determined from data if
<code>NULL</code>)</p>
</td></tr>
<tr><td><code id="pafi_+3A_min_length">min_length</code></td>
<td>
<p>Minimal time span between a ventilation start and end
time</p>
</td></tr>
<tr><td><code id="pafi_+3A_valid_win">valid_win</code></td>
<td>
<p>Maximal time window for which a GCS value is valid
if no newer measurement is available</p>
</td></tr>
<tr><td><code id="pafi_+3A_sed_impute">sed_impute</code></td>
<td>
<p>Imputation scheme for values taken when patient was
sedated (i.e. unconscious).</p>
</td></tr>
<tr><td><code id="pafi_+3A_set_na_max">set_na_max</code></td>
<td>
<p>Logical flag controlling imputation of missing GCS values
with the respective maximum values</p>
</td></tr>
<tr><td><code id="pafi_+3A_min_win">min_win</code></td>
<td>
<p>Minimal time span required for calculation of urine/24h</p>
</td></tr>
<tr><td><code id="pafi_+3A_limits">limits</code></td>
<td>
<p>Passed to <code><a href="#topic+fill_gaps">fill_gaps()</a></code> in order to expand the time series
beyond first and last measurements</p>
</td></tr>
<tr><td><code id="pafi_+3A_start_var">start_var</code>, <code id="pafi_+3A_end_var">end_var</code></td>
<td>
<p>Passed to <code><a href="#topic+fill_gaps">fill_gaps()</a></code></p>
</td></tr>
<tr><td><code id="pafi_+3A_max_gap">max_gap</code></td>
<td>
<p>Maximum time gap between administration windows that are
merged (can be negative).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several concept callback functions are exported, mainly for documenting
their arguments, as default values oftentimes represent somewhat arbitrary
choices and passing non-default values might be of interest for
investigating stability with respect to such choices. Furthermore, default
values might not be ideal for some datasets and/or analysis tasks.
</p>


<h4><code>pafi</code></h4>

<p>In order to calculate the PaO<sub>2</sub>/FiO<sub>2</sub> (or Horowitz index), for
a given time point, both a PaO<sub>2</sub> and an FiO<sub>2</sub> measurement is
required. As the two are often not measured at the same time, some form of
imputation or matching procedure is required. Several options are available:
</p>

<ul>
<li> <p><code>match_vals</code> allows for a time difference of maximally <code>match_win</code>
between two measurements for calculating their ratio
</p>
</li>
<li> <p><code>extreme_vals</code> uses the worst PaO<sub>2</sub> and FiO<sub>2</sub> values within
the time window spanned by <code>match_win</code>
</p>
</li>
<li> <p><code>fill_gaps</code> represents a variation of <code>extreme_vals</code>, where ratios are
evaluated at every time-point as specified by <code>interval</code>as opposed to
only the time points where either a PaO<sub>2</sub> or an FiO<sub>2</sub>
measurement is available
</p>
</li></ul>

<p>Finally, <code>fix_na_fio2</code> imputes all remaining missing FiO<sub>2</sub> with 21,
the percentage (by volume) of oxygen in (tropospheric) air.
</p>



<h4><code>vent_ind</code></h4>

<p>Building on the atomic concepts <code>vent_start</code> and <code>vent_end</code>, <code>vent_ind</code>
determines time windows during which patients are mechanically ventilated
by combining start and end events that are separated by at most <code>match_win</code>
and at least <code>min_length</code>. Durations are represented by the <code>dur_var</code> column
in the returned <code>win_tbl</code> and the <code>data_var</code> column simply indicates the
ventilation status with <code>TRUE</code> values. Currently, no clear distinction
between invasive an non-invasive ventilation is made.
</p>



<h4><code>sed_gcs</code></h4>

<p>In order to construct an indicator for patient sedation (used within the
context of <code>gcs</code>), information from the two concepts <code>ett_gcs</code> and <code>rass</code> is
pooled: A patient is considered sedated if intubated or has less or equal to
-2 on the Richmond Agitation-Sedation Scale.
</p>



<h4><code>gcs</code></h4>

<p>Aggregating components of the Glasgow Coma Scale into a total score
(whenever the total score <code>tgcs</code> is not already available) requires
coinciding availability of an eye (<code>egcs</code>), verbal (<code>vgcs</code>) and motor
(<code>mgcs</code>) score. In order to match values, a last observation carry forward
imputation scheme over the time span specified by <code>valid_win</code> is performed.
Furthermore passing <code>"max"</code> as <code>sed_impute</code> will assume maximal points for
time steps where the patient is sedated (as indicated by <code>sed_gcs</code>), while
passing <code>"prev"</code>, will assign the last observed value previous to the
current sedation window and finally passing <code>FALSE</code> will in turn use raw
values. Finally, passing <code>TRUE</code> as <code>set_na_max</code> will assume maximal points
for missing values (after matching and potentially applying <code>sed_impute</code>).
</p>



<h4><code>urine24</code></h4>

<p>Single urine output events are aggregated into a 24 hour moving window sum.
At default value of <code>limits = NULL</code>, moving window evaluation begins with
the first and ends with the last available measurement. This can however be
extended by passing an <code>id_tbl</code> object, such as for example returned by
<code><a href="#topic+stay_windows">stay_windows()</a></code> to full stay windows. In order to provide data earlier
than 24 hours before the evaluation start point, <code>min_win</code> specifies the
minimally required data window and the evaluation scheme is adjusted for
shorter than 24 hour windows.
</p>



<h4><code>vaso60</code></h4>

<p>Building on concepts for drug administration rate and drug administration
durations, administration events are filtered if they do not fall into
administrations windows of at least 1h. The <code>max_gap</code> argument can be used
to control how far apart windows can be in order to be merged (negative
times are possible as well, meaning that even overlapping windows can be
considered as individual windows).
</p>



<h3>Value</h3>

<p>Either an <code>id_tbl</code> or <code>ts_tbl</code> depending on the type of concept.
</p>

<hr>
<h2 id='prepare_query'>Internal utilities for <code>item</code>/<code>concept</code> objects</h2><span id='topic+prepare_query'></span><span id='topic+try_add_vars'></span><span id='topic+get_itm_var'></span><span id='topic+set_callback'></span><span id='topic+do_callback'></span><span id='topic+do_itm_load'></span><span id='topic+n_tick'></span><span id='topic+set_target'></span><span id='topic+get_target'></span><span id='topic+subset_src'></span><span id='topic+subset_src.item'></span><span id='topic+subset_src.cncpt'></span><span id='topic+subset_src.concept'></span>

<h3>Description</h3>

<p>Several internal utilities for modifying, querying ans subsetting item and
concept objects, including getters and setters for <code>itm</code> variables,
callback functions, <code>cncpt</code> target classes, as well as utilities for data
loading such as <code>prepare_query()</code> which creates a row-subsetting
expression, <code>do_callback()</code>, which applies a callback function to data or
<code>do_itm_load()</code>, which performs data loading corresponding to an <code>itm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_query(x)

try_add_vars(x, ..., var_lst = NULL, type = c("data_vars", "meta_vars"))

get_itm_var(x, var = NULL, type = c("data_vars", "meta_vars"))

set_callback(x, fun)

do_callback(x, ...)

do_itm_load(x, id_type = "icustay", interval = hours(1L))

n_tick(x)

set_target(x, target)

get_target(x)

subset_src(x, src)

## S3 method for class 'item'
subset_src(x, src)

## S3 method for class 'cncpt'
subset_src(x, src)

## S3 method for class 'concept'
subset_src(x, src)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_query_+3A_x">x</code></td>
<td>
<p>Object defining the row-subsetting</p>
</td></tr>
<tr><td><code id="prepare_query_+3A_...">...</code></td>
<td>
<p>Variable specification</p>
</td></tr>
<tr><td><code id="prepare_query_+3A_var_lst">var_lst</code></td>
<td>
<p>List-based variable specification</p>
</td></tr>
<tr><td><code id="prepare_query_+3A_type">type</code></td>
<td>
<p>Variable type (either data or meta)</p>
</td></tr>
<tr><td><code id="prepare_query_+3A_var">var</code></td>
<td>
<p>Variable name (<code>NULL</code>) returns all available</p>
</td></tr>
<tr><td><code id="prepare_query_+3A_fun">fun</code></td>
<td>
<p>Callback function (passed as string)</p>
</td></tr>
<tr><td><code id="prepare_query_+3A_id_type">id_type</code></td>
<td>
<p>String specifying the patient id type to return</p>
</td></tr>
<tr><td><code id="prepare_query_+3A_interval">interval</code></td>
<td>
<p>The time interval used to discretize time stamps with,
specified as <code><a href="base.html#topic+difftime">base::difftime()</a></code> object</p>
</td></tr>
<tr><td><code id="prepare_query_+3A_src">src</code></td>
<td>
<p>Character vector of data source name(s)</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>prepare_query()</code>: an unevaluated expression used for row-subsetting
</p>
</li>
<li> <p><code>try_add_vars()</code>: a (potentially) modified item object with added
variables
</p>
</li>
<li> <p><code>get_itm_var()</code>: character vector of <code>itm</code> variables
</p>
</li>
<li> <p><code>set_callback()</code>: a modified object with added callback function
</p>
</li>
<li> <p><code>do_callback()</code>: result of the callback function applied to data, most
likely (<code>id_tbl</code>/<code>ts_tbl</code>)
</p>
</li>
<li> <p><code>do_itm_load()</code>: result of item loading (<code>id_tbl</code>/<code>ts_tbl</code>)
</p>
</li>
<li> <p><code>n_tick()</code>: Integer valued number of progress bar ticks
</p>
</li>
<li> <p><code>set_target()</code>: a modified object with newly set target class
</p>
</li>
<li> <p><code>get_target()</code>: string valued target class of an object
</p>
</li>
<li> <p><code>subset_src()</code>: an object of the same type as the object passed as <code>x</code>
</p>
</li></ul>


<hr>
<h2 id='rename_cols'>ICU class data utilities</h2><span id='topic+rename_cols'></span><span id='topic+rm_cols'></span><span id='topic+change_interval'></span><span id='topic+change_dur_unit'></span><span id='topic+rm_na'></span><span id='topic+sort.id_tbl'></span><span id='topic+is_sorted'></span><span id='topic+duplicated.id_tbl'></span><span id='topic+anyDuplicated.id_tbl'></span><span id='topic+unique.id_tbl'></span><span id='topic+is_unique'></span><span id='topic+aggregate.id_tbl'></span><span id='topic+dt_gforce'></span><span id='topic+replace_na'></span>

<h3>Description</h3>

<p>Several utility functions for working with <code>id_tbl</code> and <code>ts_tbl</code> objects
are available, including functions for changing column names, removing
columns, as well as aggregating or removing rows. An important thing to
note is that as <code>id_tbl</code> (and consequently <code>ts_tbl</code>) inherits from
<code>data.table</code>, there are several functions provided by the <code>data.table</code>
package that are capable of modifying <code>id_tbl</code> in a way that results in an
object with inconsistent state. An example for this is
<code><a href="data.table.html#topic+setattr">data.table::setnames()</a></code>: if an ID column or the index column name is
modified without updating the attribute marking the column as such, this
leads to an invalid object. As <code><a href="data.table.html#topic+setattr">data.table::setnames()</a></code> is not an S3
generic function, the only way to control its behavior with respect to
<code>id_tbl</code> objects is masking the function. As such an approach has its own
down-sides, a separate function, <code>rename_cols()</code> is provided, which is able
to handle column renaming correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_cols(
  x,
  new,
  old = colnames(x),
  skip_absent = FALSE,
  by_ref = FALSE,
  ...
)

rm_cols(x, cols, skip_absent = FALSE, by_ref = FALSE)

change_interval(x, new_interval, cols = time_vars(x), by_ref = FALSE)

change_dur_unit(x, new_unit, by_ref = FALSE)

rm_na(x, cols = data_vars(x), mode = c("all", "any"))

## S3 method for class 'id_tbl'
sort(
  x,
  decreasing = FALSE,
  by = meta_vars(x),
  reorder_cols = TRUE,
  by_ref = FALSE,
  ...
)

is_sorted(x)

## S3 method for class 'id_tbl'
duplicated(x, incomparables = FALSE, by = meta_vars(x), ...)

## S3 method for class 'id_tbl'
anyDuplicated(x, incomparables = FALSE, by = meta_vars(x), ...)

## S3 method for class 'id_tbl'
unique(x, incomparables = FALSE, by = meta_vars(x), ...)

is_unique(x, ...)

## S3 method for class 'id_tbl'
aggregate(
  x,
  expr = NULL,
  by = meta_vars(x),
  vars = data_vars(x),
  env = NULL,
  ...
)

dt_gforce(
  x,
  fun = c("mean", "median", "min", "max", "sum", "prod", "var", "sd", "first", "last",
    "any", "all"),
  by = meta_vars(x),
  vars = data_vars(x),
  na_rm = !fun %in% c("first", "last")
)

replace_na(x, val, type = "const", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_cols_+3A_x">x</code></td>
<td>
<p>Object to query</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_new">new</code>, <code id="rename_cols_+3A_old">old</code></td>
<td>
<p>Replacement names and existing column names for renaming
columns</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_skip_absent">skip_absent</code></td>
<td>
<p>Logical flag for ignoring non-existent column names</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_by_ref">by_ref</code></td>
<td>
<p>Logical flag indicating whether to perform the operation by
reference</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_cols">cols</code></td>
<td>
<p>Column names of columns to consider</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_new_interval">new_interval</code></td>
<td>
<p>Replacement interval length specified as scalar-valued
<code>difftime</code> object</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_new_unit">new_unit</code></td>
<td>
<p>New <code>difftime</code> unit for the <code>dur_var</code> column</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_mode">mode</code></td>
<td>
<p>Switch between <code>all</code> where all entries of a row have to be
missing (for the selected columns) or <code>any</code>, where a single missing entry
suffices</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical flag indicating the sort order</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_by">by</code></td>
<td>
<p>Character vector indicating which combinations of columns from
<code>x</code> to use for uniqueness checks</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_reorder_cols">reorder_cols</code></td>
<td>
<p>Logical flag indicating whether to move the <code>by</code>
columns to the front.</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_incomparables">incomparables</code></td>
<td>
<p>Not used. Here for S3 method consistency</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_expr">expr</code></td>
<td>
<p>Expression to apply over groups</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_vars">vars</code></td>
<td>
<p>Column names to apply the function to</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_env">env</code></td>
<td>
<p>Environment to look up names in <code>expr</code></p>
</td></tr>
<tr><td><code id="rename_cols_+3A_fun">fun</code></td>
<td>
<p>Function name (as string) to apply over groups</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_na_rm">na_rm</code></td>
<td>
<p>Logical flag indicating how to treat <code>NA</code> values</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_val">val</code></td>
<td>
<p>Replacement value (if <code>type</code> is <code>"const"</code>)</p>
</td></tr>
<tr><td><code id="rename_cols_+3A_type">type</code></td>
<td>
<p> character, one of <em>&quot;const&quot;</em>, <em>&quot;locf&quot;</em> or <em>&quot;nocb&quot;</em>. Defaults to <code>"const"</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apart from a function for renaming columns while respecting attributes
marking columns a index or ID columns, several other utility functions are
provided to make handling of <code>id_tbl</code> and <code>ts_tbl</code> objects more convenient.
</p>


<h4>Sorting</h4>

<p>An <code>id_tbl</code> or <code>ts_tbl</code> object is considered sorted when rows are in
ascending order according to columns as specified by <code><a href="#topic+meta_vars">meta_vars()</a></code>. This
means that for an <code>id_tbl</code> object rows have to be ordered by <code><a href="#topic+id_vars">id_vars()</a></code>
and for a <code>ts_tbl</code> object rows have to be ordered first by <code><a href="#topic+id_vars">id_vars()</a></code>,
followed by the <code><a href="#topic+index_var">index_var()</a></code>. Calling the S3 generic function
<code><a href="base.html#topic+sort">base::sort()</a></code> on an object that inherits form <code>id_tbl</code> using default
arguments yields an object that is considered sorted. For convenience
(mostly in printing), the column by which the table was sorted are moved to
the front (this can be disabled by passing <code>FALSE</code> as <code>reorder_cols</code>
argument). Internally, sorting is handled by either setting a
<code><a href="data.table.html#topic+setkey">data.table::key()</a></code> in case <code>decreasing = FALSE</code> or be calling
<code><a href="data.table.html#topic+setorder">data.table::setorder()</a></code> in case <code>decreasing = TRUE</code>.
</p>



<h4>Uniqueness</h4>

<p>On object inheriting form <code>id_tbl</code> is considered unique if it is unique in
terms of the columns as specified by <code><a href="#topic+meta_vars">meta_vars()</a></code>. This means that for an
<code>id_tbl</code> object, either zero or a single row is allowed per combination of
values in columns <code><a href="#topic+id_vars">id_vars()</a></code> and consequently for <code>ts_tbl</code> objects a
maximum of one row is allowed per combination of time step and ID. In order
to create a unique <code>id_tbl</code> object from a non-unique <code>id_tbl</code> object,
<code>aggregate()</code> will combine observations that represent repeated
measurements within a group.
</p>



<h4>Aggregating</h4>

<p>In order to turn a non-unique <code>id_tbl</code> or <code>ts_tbl</code> object into an object
considered unique, the S3 generic function <code><a href="stats.html#topic+aggregate">stats::aggregate()</a></code> is
available. This applied the expression (or function specification) passed
as <code>expr</code> to each combination of grouping variables. The columns to be
aggregated can be controlled using the <code>vars</code> argument and the grouping
variables can be changed using the <code>by</code> argument. The argument <code>expr</code> is
fairly flexible: it can take an expression that will be evaluated in the
context of the <code>data.table</code> in a clean environment inheriting from <code>env</code>,
it can be a function, or it can be a string in which case <code>dt_gforce()</code> is
called. The default value <code>NULL</code> chooses a string dependent on data types,
where <code>numeric</code> resolves to <code>median</code>, <code>logical</code> to <code>sum</code> and <code>character</code> to
<code>first</code>.
</p>
<p>As aggregation is used in concept loading (see <code><a href="#topic+load_concepts">load_concepts()</a></code>),
performance is important. For this reason, <code>dt_gforce()</code> allows for any of
the available functions to be applied using the <code>GForce</code> optimization of
<code>data.table</code> (see <a href="data.table.html#topic+datatable-optimize">data.table::datatable.optimize</a>).
</p>



<h3>Value</h3>

<p>Most of the utility functions return an object inheriting from
<code>id_tbl</code>, potentially modified by reference, depending on the type of the
object passed as <code>x</code>. The functions <code>is_sorted()</code>, <code>anyDuplicated()</code> and
<code>is_unique()</code> return logical flags, while <code>duplicated()</code> returns a logical
vector of the length <code>nrow(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tbl &lt;- id_tbl(a = rep(1:5, 4), b = rep(1:2, each = 10), c = rnorm(20),
              id_vars = c("a", "b"))
is_unique(tbl)
is_sorted(tbl)

is_sorted(tbl[order(c)])

identical(aggregate(tbl, list(c = sum(c))), aggregate(tbl, "sum"))

tbl &lt;- aggregate(tbl, "sum")
is_unique(tbl)
is_sorted(tbl)

</code></pre>

<hr>
<h2 id='ricu-package'>ricu: Intensive Care Unit Data with R</h2><span id='topic+ricu'></span><span id='topic+ricu-package'></span>

<h3>Description</h3>

<p>Focused on (but not exclusive to) data sets hosted on PhysioNet (<a href="https://physionet.org">https://physionet.org</a>), 'ricu' provides utilities for download, setup and access of intensive care unit (ICU) data sets. In addition to functions for running arbitrary queries against available data sets, a system for defining clinical concepts and encoding their representations in tabular ICU data is presented.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nicolas Bennett <a href="mailto:r@nbenn.ch">r@nbenn.ch</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Drago Plecko <a href="mailto:drago.plecko@stat.math.ethz.ch">drago.plecko@stat.math.ethz.ch</a>
</p>
</li>
<li><p> Ida-Fong Ukor <a href="mailto:ida-fong.ukor@monashhealth.org">ida-fong.ukor@monashhealth.org</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/eth-mds/ricu">https://github.com/eth-mds/ricu</a>
</p>
</li>
<li> <p><a href="https://physionet.org">https://physionet.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/eth-mds/ricu/issues">https://github.com/eth-mds/ricu/issues</a>
</p>
</li></ul>


<hr>
<h2 id='secs'>Utilities for <code>difftime</code></h2><span id='topic+secs'></span><span id='topic+mins'></span><span id='topic+hours'></span><span id='topic+days'></span><span id='topic+weeks'></span>

<h3>Description</h3>

<p>As <code><a href="base.html#topic+difftime">base::difftime()</a></code> vectors are used throughout <code>ricu</code>, a set of wrapper
functions are exported for convenience of instantiation <code><a href="base.html#topic+difftime">base::difftime()</a></code>
vectors with given time units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secs(...)

mins(...)

hours(...)

days(...)

weeks(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secs_+3A_...">...</code></td>
<td>
<p>Numeric vector to coerce to <code><a href="base.html#topic+difftime">base::difftime()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector valued time differences as <code>difftime</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hours(1L)
mins(NA_real_)
secs(1:10)
hours(numeric(0L))

</code></pre>

<hr>
<h2 id='sep3'>Sepsis 3 label</h2><span id='topic+sep3'></span><span id='topic+delta_cummin'></span><span id='topic+delta_start'></span><span id='topic+delta_min'></span>

<h3>Description</h3>

<p>The sepsis 3 label consists of a suspected infection combined with an acute
increase in SOFA score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep3(
  ...,
  si_window = c("first", "last", "any"),
  delta_fun = delta_cummin,
  sofa_thresh = 2L,
  si_lwr = hours(48L),
  si_upr = hours(24L),
  keep_components = FALSE,
  interval = NULL
)

delta_cummin(x)

delta_start(x)

delta_min(x, shifts = seq.int(0L, 23L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep3_+3A_...">...</code></td>
<td>
<p>Data objects</p>
</td></tr>
<tr><td><code id="sep3_+3A_si_window">si_window</code></td>
<td>
<p>Switch that can be used to filter SI windows</p>
</td></tr>
<tr><td><code id="sep3_+3A_delta_fun">delta_fun</code></td>
<td>
<p>Function used to determine the SOFA increase during an SI
window</p>
</td></tr>
<tr><td><code id="sep3_+3A_sofa_thresh">sofa_thresh</code></td>
<td>
<p>Required SOFA increase to trigger Sepsis 3</p>
</td></tr>
<tr><td><code id="sep3_+3A_si_lwr">si_lwr</code>, <code id="sep3_+3A_si_upr">si_upr</code></td>
<td>
<p>Lower/upper extent of SI windows</p>
</td></tr>
<tr><td><code id="sep3_+3A_keep_components">keep_components</code></td>
<td>
<p>Logical flag indicating whether to return the
individual components alongside the aggregated score</p>
</td></tr>
<tr><td><code id="sep3_+3A_interval">interval</code></td>
<td>
<p>Time series interval (only used for checking consistency
of input data)</p>
</td></tr>
<tr><td><code id="sep3_+3A_x">x</code></td>
<td>
<p>Vector of SOFA scores</p>
</td></tr>
<tr><td><code id="sep3_+3A_shifts">shifts</code></td>
<td>
<p>Vector of time shifts (multiples of the current interval) over
which <code><a href="base.html#topic+Extremes">base::pmin()</a></code> is evaluated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Sepsis-3 Consensus (Singer et. al.) defines sepsis as an acute
increase in the SOFA score (see <code><a href="#topic+sofa_score">sofa_score()</a></code>) of 2 points or more within
the suspected infection (SI) window (see <code><a href="#topic+susp_inf">susp_inf()</a></code>):
<img src="../help/figures/sofa-sep-3-1.png" alt="sofa-sep-3-1.png" />
</p>
<p>A patient can potentially have multiple SI windows. The argument
<code>si_window</code> is used to control which SI window we focus on (options are
<code style="white-space: pre;">&#8288;"first", "last", "any"&#8288;</code>).
</p>
<p>Further, although a 2 or more point increase in the SOFA score is defined,
it is not perfectly clear to which value the increase refers. For this the
<code>delta_fun</code> argument is used. If the increase is required to happen with
respect to the minimal SOFA value (within the SI window) up to the current
time, the <code>delta_cummin</code> function should be used. If, however, we are
looking for an increase with respect to the start of the SI window, then
the <code>delta_start</code> function should be used. Lastly, the increase might be
defined with respect to values of the previous 24 hours, in which case the
<code>delta_min</code> function is used.
</p>


<h3>References</h3>

<p>Singer M, Deutschman CS, Seymour CW, et al. The Third International
Consensus Definitions for Sepsis and Septic Shock (Sepsis-3). JAMA.
2016;315(8):801–810. doi:10.1001/jama.2016.0287
</p>

<hr>
<h2 id='setup_src_data'>Data setup</h2><span id='topic+setup_src_data'></span>

<h3>Description</h3>

<p>Making a dataset available to <code>ricu</code> consists of 3 steps: downloading
(<code><a href="#topic+download_src">download_src()</a></code>), importing (<code><a href="#topic+import_src">import_src()</a></code>) and attaching
(<code><a href="#topic+attach_src">attach_src()</a></code>). While downloading and importing are one-time procedures,
attaching of the dataset is repeated every time the package is loaded.
Briefly, downloading loads the raw dataset from the internet (most likely
in <code>.csv</code> format), importing consists of some preprocessing to make the
data available more efficiently and attaching sets up the data for use by
the package. The download and import steps can be combined using
<code>setup_src_data()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_src_data(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_src_data_+3A_x">x</code></td>
<td>
<p>Object specifying the source configuration</p>
</td></tr>
<tr><td><code id="setup_src_data_+3A_...">...</code></td>
<td>
<p>Forwarded to <code><a href="#topic+load_src_cfg">load_src_cfg()</a></code> if <code>x</code> is a character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>setup_src_data()</code> is called on data sources that have all data available
with <code>force = FALSE</code>, nothing happens apart of a message being displayed. If
only a subset of tables is missing, only these tables are downloaded
(whenever possible) and imported. Passing <code>force = TRUE</code> attempts to re-
download and import the entire data set. If the data source is available
as a data package (as is the case for the two demo datasets), data is not
downloaded and imported, but this package is installed.
</p>
<p>In most scenarios, <code>setup_src_data()</code> does not need to be called by users,
as upon package loading, all configured data sources are set up in a way
that enables download of missing data upon first access (and barring user
consent). However, instead of accessing all data sources where data
missingness should be resolved one by one, <code>setup_src_data()</code> is exported
for convenience.
</p>


<h3>Value</h3>

<p>Called for side effects and returns <code>NULL</code> invisibly.
</p>

<hr>
<h2 id='sirs_score'>SIRS score label</h2><span id='topic+sirs_score'></span><span id='topic+qsofa_score'></span><span id='topic+news_score'></span><span id='topic+mews_score'></span>

<h3>Description</h3>

<p>The SIRS (Systemic Inflammatory Response Syndrome) score is a commonly used
assessment tool used to track a patient's well-being in an ICU.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sirs_score(
  ...,
  win_length = hours(24L),
  keep_components = FALSE,
  interval = NULL
)

qsofa_score(
  ...,
  win_length = hours(24L),
  keep_components = FALSE,
  interval = NULL
)

news_score(
  ...,
  win_length = hours(24L),
  keep_components = FALSE,
  interval = NULL
)

mews_score(
  ...,
  win_length = hours(24L),
  keep_components = FALSE,
  interval = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sirs_score_+3A_...">...</code></td>
<td>
<p>Data input used for score
evaluation</p>
</td></tr>
<tr><td><code id="sirs_score_+3A_win_length">win_length</code></td>
<td>
<p>Window used for carry forward</p>
</td></tr>
<tr><td><code id="sirs_score_+3A_keep_components">keep_components</code></td>
<td>
<p>Logical flag indicating whether to return the
individual components alongside the aggregated score</p>
</td></tr>
<tr><td><code id="sirs_score_+3A_interval">interval</code></td>
<td>
<p>Time series interval (only used for checking consistency
of input data)</p>
</td></tr>
</table>

<hr>
<h2 id='sofa_score'>SOFA score label</h2><span id='topic+sofa_score'></span><span id='topic+sofa_resp'></span><span id='topic+sofa_coag'></span><span id='topic+sofa_liver'></span><span id='topic+sofa_cardio'></span><span id='topic+sofa_cns'></span><span id='topic+sofa_renal'></span>

<h3>Description</h3>

<p>The SOFA (Sequential Organ Failure Assessment) score is a commonly used
assessment tool for tracking a patient's status during a stay at an ICU.
Organ function is quantified by aggregating 6 individual scores,
representing respiratory, cardiovascular, hepatic, coagulation, renal and
neurological systems. The function <code>sofa_score()</code> is used as callback
function to the <code>sofa</code> concept but is exported as there are a few arguments
that can used to modify some aspects of the presented SOFA implementation.
Internally, <code>sofa_score()</code> calls first <code>sofa_window()</code>, followed by
<code>sofa_compute()</code> and arguments passed as <code>...</code> will be forwarded to the
respective internally called function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sofa_score(
  ...,
  worst_val_fun = max_or_na,
  explicit_wins = FALSE,
  win_length = hours(24L),
  keep_components = FALSE,
  interval = NULL
)

sofa_resp(..., interval = NULL)

sofa_coag(..., interval = NULL)

sofa_liver(..., interval = NULL)

sofa_cardio(..., interval = NULL)

sofa_cns(..., interval = NULL)

sofa_renal(..., interval = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sofa_score_+3A_...">...</code></td>
<td>
<p>Concept data, either passed as list or individual argument</p>
</td></tr>
<tr><td><code id="sofa_score_+3A_worst_val_fun">worst_val_fun</code></td>
<td>
<p>functions used to calculate worst values over windows</p>
</td></tr>
<tr><td><code id="sofa_score_+3A_explicit_wins">explicit_wins</code></td>
<td>
<p>The default <code>FALSE</code> iterates over all time steps,
<code>TRUE</code> uses only the last time step per patient and a vector of times will
iterate over these explicit time points</p>
</td></tr>
<tr><td><code id="sofa_score_+3A_win_length">win_length</code></td>
<td>
<p>Time-frame to look back and apply the <code>worst_val_fun</code></p>
</td></tr>
<tr><td><code id="sofa_score_+3A_keep_components">keep_components</code></td>
<td>
<p>Logical flag indicating whether to return the
individual components alongside the aggregated score (with a suffix <code style="white-space: pre;">&#8288;_comp&#8288;</code>
added to their names)</p>
</td></tr>
<tr><td><code id="sofa_score_+3A_interval">interval</code></td>
<td>
<p>Time series interval (only used for checking consistency
of input data, <code>NULL</code> will use the interval of the first data object)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>sofa_score()</code> calculates, for each component, the worst value
over a moving window as specified by <code>win_length</code>, using the function
passed as <code>worst_val_fun</code>. The default functions <code>max_or_na()</code> return <code>NA</code>
instead of <code>-Inf/Inf</code> in the case where no measurement is available over an
entire window. When calculating the overall score by summing up components
per time-step, a <code>NA</code> value is treated as 0.
</p>
<p>Building on separate concepts, measurements for each component are
converted to a component score using the definition by Vincent et. al.:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>SOFA score</strong> </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 3 </td><td style="text-align: left;"> 4 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Respiration</strong> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   PaO<sub>2</sub>/FiO<sub>2</sub> [mmHg] </td><td style="text-align: left;"> &lt; 400 </td><td style="text-align: left;"> &lt; 300 </td><td style="text-align: left;"> &lt; 200 </td><td style="text-align: left;"> &lt; 100 </td>
</tr>
<tr>
 <td style="text-align: left;">
   and mechanical ventilation </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;"> yes </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Coagulation</strong> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   Platelets [&times;10<sup>3</sup>/mm<sup>3</sup>] </td><td style="text-align: left;"> &lt; 150 </td><td style="text-align: left;"> &lt; 100 </td><td style="text-align: left;"> &lt; 50 </td><td style="text-align: left;"> &lt; 20 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Liver</strong> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   Bilirubin [mg/dl] </td><td style="text-align: left;"> 1.2-1.9 </td><td style="text-align: left;"> 2.0-5.9 </td><td style="text-align: left;"> 6.0-11.9 </td><td style="text-align: left;"> &gt; 12.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Cardiovascular</strong><sup>a</sup> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   MAP </td><td style="text-align: left;"> &lt; 70 mmHg </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   or dopamine </td><td style="text-align: left;">  </td><td style="text-align: left;"> &leq;5 </td><td style="text-align: left;"> &gt; 5 </td><td style="text-align: left;"> &gt; 15 </td>
</tr>
<tr>
 <td style="text-align: left;">
   or dobutamine </td><td style="text-align: left;">  </td><td style="text-align: left;"> any dose </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   or epinephrine </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;"> &leq;0.1 </td><td style="text-align: left;"> &gt; 0.1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   or norepinephrine </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;"> &leq;0.1 </td><td style="text-align: left;"> &gt; 0.1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Central nervous system</strong> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   Glasgow Coma Score </td><td style="text-align: left;"> 13-14 </td><td style="text-align: left;"> 10-12 </td><td style="text-align: left;"> 6-9 </td><td style="text-align: left;"> &lt; 6 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Renal</strong> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   Creatinine [mg/dl] </td><td style="text-align: left;"> 1.2-1.9 </td><td style="text-align: left;"> 2.0-3.4 </td><td style="text-align: left;"> 3.5-4.9 </td><td style="text-align: left;"> &gt; 5.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   or urine output [ml/day] </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td><td style="text-align: left;"> &lt; 500 </td><td style="text-align: left;"> &lt; 200 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Adrenergic<sup>a</sup> agents administered for at least 1h
(doses given are in [&mu;g/kg &middot; min]
</p>
<p>At default, for each patient, a score is calculated for every time step,
from the first available measurement to the last. In instead of a regularly
evaluated score, only certain time points are of interest, this can be
specified using the <code>explicit_wins</code> argument: passing for example
<code>hours(24, 48)</code> will yield for every patient a score at hours 24 and 48
relative to the origin of the current ID system (for example ICU stay).
</p>


<h3>Value</h3>

<p>A <code>ts_tbl</code> object.
</p>


<h3>References</h3>

<p>Vincent, J.-L., Moreno, R., Takala, J. et al. The SOFA (Sepsis-related Organ
Failure Assessment) score to describe organ dysfunction/failure. Intensive
Care Med 22, 707–710 (1996). https://doi.org/10.1007/BF01709751
</p>

<hr>
<h2 id='stay_windows'>Stays</h2><span id='topic+stay_windows'></span><span id='topic+stay_windows.src_env'></span><span id='topic+stay_windows.character'></span><span id='topic+stay_windows.list'></span><span id='topic+stay_windows.default'></span>

<h3>Description</h3>

<p>Building on functionality offered by the (internal) function <code><a href="#topic+id_map">id_map()</a></code>,
stay windows as well as (in case of differing values being passed as
<code>id_type</code> and <code>win_type</code>) an ID mapping is computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stay_windows(x, ...)

## S3 method for class 'src_env'
stay_windows(
  x,
  id_type = "icustay",
  win_type = id_type,
  in_time = "start",
  out_time = "end",
  interval = hours(1L),
  patient_ids = NULL,
  ...
)

## S3 method for class 'character'
stay_windows(x, ...)

## S3 method for class 'list'
stay_windows(x, ..., patient_ids = NULL)

## Default S3 method:
stay_windows(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stay_windows_+3A_x">x</code></td>
<td>
<p>Data source (is coerced to <code>src_env</code> using <code>as_src_env()</code>)</p>
</td></tr>
<tr><td><code id="stay_windows_+3A_...">...</code></td>
<td>
<p>Generic consistency</p>
</td></tr>
<tr><td><code id="stay_windows_+3A_id_type">id_type</code></td>
<td>
<p>Type of ID all returned times are relative to</p>
</td></tr>
<tr><td><code id="stay_windows_+3A_win_type">win_type</code></td>
<td>
<p>Type of ID for which the in/out times is returned</p>
</td></tr>
<tr><td><code id="stay_windows_+3A_in_time">in_time</code>, <code id="stay_windows_+3A_out_time">out_time</code></td>
<td>
<p>column names of the returned in/out times</p>
</td></tr>
<tr><td><code id="stay_windows_+3A_interval">interval</code></td>
<td>
<p>The time interval used to discretize time stamps with,
specified as <code><a href="base.html#topic+difftime">base::difftime()</a></code> object</p>
</td></tr>
<tr><td><code id="stay_windows_+3A_patient_ids">patient_ids</code></td>
<td>
<p>Patient IDs used to subset the result</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>id_tbl</code> containing the selected IDs and depending on values
passed as <code>in_time</code> and <code>out_time</code>, start and end times of the ID passed as
<code>win_var</code>.
</p>


<h3>See Also</h3>

<p>change_id
</p>

<hr>
<h2 id='susp_inf'>Suspicion of infection label</h2><span id='topic+susp_inf'></span>

<h3>Description</h3>

<p>Suspected infection is defined as co-occurrence of of antibiotic treatment
and body-fluid sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>susp_inf(
  ...,
  abx_count_win = hours(24L),
  abx_min_count = 1L,
  positive_cultures = FALSE,
  si_mode = c("and", "or", "abx", "samp"),
  abx_win = hours(24L),
  samp_win = hours(72L),
  by_ref = TRUE,
  keep_components = FALSE,
  interval = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="susp_inf_+3A_...">...</code></td>
<td>
<p>Data and further arguments are passed to <code>si_calc()</code></p>
</td></tr>
<tr><td><code id="susp_inf_+3A_abx_count_win">abx_count_win</code></td>
<td>
<p>Time span during which to apply the <code>abx_min_count</code>
criterion</p>
</td></tr>
<tr><td><code id="susp_inf_+3A_abx_min_count">abx_min_count</code></td>
<td>
<p>Minimal number of antibiotic administrations</p>
</td></tr>
<tr><td><code id="susp_inf_+3A_positive_cultures">positive_cultures</code></td>
<td>
<p>Logical flag indicating whether to require
cultures to be positive</p>
</td></tr>
<tr><td><code id="susp_inf_+3A_si_mode">si_mode</code></td>
<td>
<p>Switch between <code>and</code>, <code>or</code>, <code>abx</code>, <code>samp</code> modes</p>
</td></tr>
<tr><td><code id="susp_inf_+3A_abx_win">abx_win</code></td>
<td>
<p>Time-span within which sampling has to occur</p>
</td></tr>
<tr><td><code id="susp_inf_+3A_samp_win">samp_win</code></td>
<td>
<p>Time-span within which antibiotic administration has to
occur</p>
</td></tr>
<tr><td><code id="susp_inf_+3A_by_ref">by_ref</code></td>
<td>
<p>Logical flag indicating whether to process data by reference</p>
</td></tr>
<tr><td><code id="susp_inf_+3A_keep_components">keep_components</code></td>
<td>
<p>Logical flag indicating whether to return the
individual components alongside the aggregated score</p>
</td></tr>
<tr><td><code id="susp_inf_+3A_interval">interval</code></td>
<td>
<p>Time series interval (only used for checking consistency
of input data)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suspected infection can occur in one of the two following ways:
</p>

<ul>
<li><p> administration of antibiotics followed by a culture sampling within
<code>samp_win</code> hours
</p>
<div class="sourceCode"><pre>       abx_win
   |---------------|
  ABX           sampling (last possible)
</pre></div>
</li>
<li><p> culture sampling followed by an antibiotic administration within
<code>abx_win</code> hours
</p>
<div class="sourceCode"><pre>                     samp_win
   |---------------------------------------------|
sampling                                        ABX (last possible)
</pre></div>
</li></ul>

<p>The default values of <code>samp_win</code> and <code>abx_win</code> are 24 and 72 hours
respectively, as per <a href="https://jamanetwork.com/journals/jama/fullarticle/2492881">Singer et.al. </a>.
</p>
<p>The earlier of the two times (fluid sampling, antibiotic treatment) is taken
as the time of suspected infection (SI time). The suspected infection
window (SI window) is defined to start <code>si_lwr</code> hours before the SI time
and end <code>si_upr</code> hours after the SI time. The default values of 48 and 24
hours (respectively) are chosen as used by <a href="https://jamanetwork.com/journals/jama/fullarticle/2492875">Seymour et.al. </a> (see
Supplemental Material).
</p>
<div class="sourceCode"><pre>                48h                       24h
  |------------------------------(|)---------------|
                                SI time
</pre></div>
<p>For some datasets, however, information on body fluid sampling is not
available for majority of the patients (eICU data). Therefore, an
alternative definition of suspected infection is required. For this, we use
administration of multiple antibiotics (argument <code>abx_min_count</code> determines
the required number) within <code>abx_count_win</code> hours. The first time of
antibiotic administration is taken as the SI time in this case.
</p>


<h3>References</h3>

<p>Singer M, Deutschman CS, Seymour CW, et al. The Third International
Consensus Definitions for Sepsis and Septic Shock (Sepsis-3). JAMA.
2016;315(8):801–810. doi:10.1001/jama.2016.0287
</p>
<p>Seymour CW, Liu VX, Iwashyna TJ, et al. Assessment of Clinical Criteria for
Sepsis: For the Third International Consensus Definitions for Sepsis and
Septic Shock (Sepsis-3). JAMA. 2016;315(8):762–774.
doi:10.1001/jama.2016.0288
</p>

<hr>
<h2 id='transform_fun'>Item callback utilities</h2><span id='topic+transform_fun'></span><span id='topic+binary_op'></span><span id='topic+comp_na'></span><span id='topic+set_val'></span><span id='topic+apply_map'></span><span id='topic+convert_unit'></span>

<h3>Description</h3>

<p>For concept loading, item callback functions are used in order to handle
item-specific post-processing steps, such as converting measurement units,
mapping a set of values to another or for more involved data
transformations, like turning absolute drug administration rates into rates
that are relative to body weight. Item callback functions are called by
<code><a href="#topic+load_concepts">load_concepts()</a></code> with arguments <code>x</code> (the data), a variable number of name/
string pairs specifying roles of columns for the given item, followed by
<code>env</code>, the data source environment as <code><a href="#topic+new_src_env">src_env</a></code> object.
Item callback functions can be specified by their name or using function
factories such as <code>transform_fun()</code>, <code>apply_map()</code> or <code>convert_unit()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_fun(fun, ...)

binary_op(op, y)

comp_na(op, y)

set_val(val)

apply_map(map, var = "val_var")

convert_unit(fun, new, rgx = NULL, ignore_case = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_fun_+3A_fun">fun</code></td>
<td>
<p>Function(s) used for transforming matching values</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_...">...</code></td>
<td>
<p>Further arguments passed to downstream function</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_op">op</code></td>
<td>
<p>Function taking two arguments, such as <code>+</code></p>
</td></tr>
<tr><td><code id="transform_fun_+3A_y">y</code></td>
<td>
<p>Value passed as second argument to function <code>op</code></p>
</td></tr>
<tr><td><code id="transform_fun_+3A_val">val</code></td>
<td>
<p>Value to replace every element of x with</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_map">map</code></td>
<td>
<p>Named atomic vector used for mapping a set of values (the names
of <code>map</code>) to a different set (the values of <code>map</code>)</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_var">var</code></td>
<td>
<p>Argument which is used to determine the column the mapping is
applied to</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_new">new</code></td>
<td>
<p>Name(s) of transformed units</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_rgx">rgx</code></td>
<td>
<p>Regular expression(s) used for identifying observations based on
their current unit of measurement, <code>NULL</code> means everything</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Forwarded to <code><a href="base.html#topic+grep">base::grep()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most forward setting is where a function is simply referred to by its
name. For example in eICU, age is available as character vector due to
ages 90 and above being represented by the string &quot;&gt; 89&quot;. A function such
as the following turns this into a numeric vector, replacing occurrences of
&quot;&gt; 89&quot; by the number 90.
</p>
<div class="sourceCode"><pre>eicu_age &lt;- function(x, val_var, ...) {
  data.table::set(
    data.table::set(x, which(x[[val_var]] == "&gt; 89"), j = val_var,
                    value = 90),
    j = val_var,
    value = as.numeric(x[[val_var]])
  )
}
</pre></div>
<p>This function then is specified as item callback function for items
corresponding to eICU data sources of the <code>age</code> concept as
</p>
<div class="sourceCode"><pre>item(src = "eicu_demo", table = "patient", val_var = "age",
     callback = "eicu_age", class = "col_itm")
</pre></div>
<p>The string passed as <code>callback</code> argument is evaluated, meaning that an
expression can be passed which evaluates to a function that in turn can be
used as callback. Several function factories are provided which return
functions suitable for use as item callbacks: <code>transform_fun()</code> creates a
function that transforms the <code>val_var</code> column using the function supplied
as <code>fun</code> argument, <code>apply_map()</code> can be used to map one set of values to
another (again using the <code>val_var</code> column) and <code>convert_unit()</code> is intended
for converting a subset of rows (identified by matching <code>rgx</code> against the
<code>unit_var</code> column) by applying <code>fun</code> to the <code>val_var</code> column and setting
<code>new</code> as the transformed unit name (arguments are not limited to scalar
values). As transformations require unary functions, two utility function,
<code>binary_op()</code> and <code>comp_na()</code> are provided which can be used to fix the
second argument of binary functions such as <code>*</code> or <code>==</code>. Taking all this
together, an item callback function for dividing the <code>val_var</code> column by 2
could be specified as <code style="white-space: pre;">&#8288;"transform_fun(binary_op(&#8288;</code>/<code style="white-space: pre;">&#8288;, 2))"&#8288;</code>. The supplied
function factories create functions that operate on the data using
<a href="data.table.html#topic+assign">by-reference semantics</a>. Furthermore, during concept
loading, progress is reported by a <a href="progress.html#topic+progress_bar">progress::progress_bar</a>. In order to
signal a message without disrupting the current loading status, see
<code><a href="#topic+msg_progress">msg_progress()</a></code>.
</p>


<h3>Value</h3>

<p>Callback function factories such as <code>transform_fun()</code>, <code>apply_map()</code>
or <code>convert_unit()</code> return functions suitable as item callback functions,
while transform function generators such as <code>binary_op()</code>, <code>comp_na()</code>
return functions that apply a transformation to a vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- ts_tbl(x = rep(1:2, each = 5), y = hours(rep(1:5, 2)), z = 1:10)

subtract_3 &lt;- transform_fun(binary_op(`-`, 3))
subtract_3(data.table::copy(dat), val_var = "z")

gte_4 &lt;- transform_fun(comp_na(`&gt;=`, 4))
gte_4(data.table::copy(dat), val_var = "z")

map_letters &lt;- apply_map(setNames(letters[1:9], 1:9))
res &lt;- map_letters(data.table::copy(dat), val_var = "z")
res

not_b &lt;- transform_fun(comp_na(`!=`, "b"))
not_b(res, val_var = "z")

</code></pre>

<hr>
<h2 id='unclass_tbl'>Internal utilities for ICU data objects</h2><span id='topic+unclass_tbl'></span><span id='topic+reclass_tbl'></span><span id='topic+as_ptype'></span>

<h3>Description</h3>

<p>In order to remove all <code>id_tbl</code>/<code>ts_tbl</code>-related attributes, as well as
extra class-labels, the exported but marked internal function
<code>unclass_tbl()</code> can be used. This function provides what one might expect
from an <code>id_tbl</code>/<code>ts_tbl</code>-specific implementation of the S3 generic
function <code><a href="data.table.html#topic+as.data.table">data.table::as.data.table()</a></code>. The inverse functionality if
provided by <code>reclass_tbl()</code> which attempts to add attributes as seen in
<code>template</code> to the object passed as <code>x</code>. The logical flag <code>stop_on_fail</code>
controls how to proceed if the attributes of <code>template</code> are incompatible
with the object <code>x</code>. Finally, in order to generate a template, <code>as_ptype()</code>
creates an empty object with the appropriate attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unclass_tbl(x)

reclass_tbl(x, template, stop_on_fail = TRUE)

as_ptype(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unclass_tbl_+3A_x">x</code></td>
<td>
<p>Object to modify/query</p>
</td></tr>
<tr><td><code id="unclass_tbl_+3A_template">template</code></td>
<td>
<p>Object after which to model the object in question</p>
</td></tr>
<tr><td><code id="unclass_tbl_+3A_stop_on_fail">stop_on_fail</code></td>
<td>
<p>Logical flag indicating whether to consider failed
object validation as error</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>unclass_tbl()</code>: a <code>data.table</code>
</p>
</li>
<li> <p><code>reclass_tbl()</code>: either an <code>id_tbl</code> or a <code>ts_tbl</code> depending on the type
of the object passed as <code>template</code>
</p>
</li>
<li> <p><code>as_ptype()</code>: an object of the same type as <code>x</code>, but with on data
</p>
</li></ul>


<hr>
<h2 id='write_psv'>Read and write utilities</h2><span id='topic+write_psv'></span><span id='topic+read_psv'></span>

<h3>Description</h3>

<p>Support for reading from and writing to pipe separated values (<code>.psv</code>)
files as used for the PhysioNet Sepsis Challenge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_psv(x, dir, na_rows = NULL)

read_psv(dir, col_spec = NULL, id_var = "stay_id", index_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_psv_+3A_x">x</code></td>
<td>
<p>Object to write to files</p>
</td></tr>
<tr><td><code id="write_psv_+3A_dir">dir</code></td>
<td>
<p>Directory to write the (many) files to or read from</p>
</td></tr>
<tr><td><code id="write_psv_+3A_na_rows">na_rows</code></td>
<td>
<p>If <code>TRUE</code> missing time steps are filled with <code>NaN</code> values,
if <code>FALSE</code>, rows where all data columns entries are missing are removed and
if <code>NULL</code>, data is written as-is</p>
</td></tr>
<tr><td><code id="write_psv_+3A_col_spec">col_spec</code></td>
<td>
<p>A column specification as created by <code><a href="readr.html#topic+cols">readr::cols()</a></code></p>
</td></tr>
<tr><td><code id="write_psv_+3A_id_var">id_var</code></td>
<td>
<p>Name of the id column (IDs are generated from file names)</p>
</td></tr>
<tr><td><code id="write_psv_+3A_index_var">index_var</code></td>
<td>
<p>Optional name of index column (will be coerced to
<code>difftime</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data for the PhysioNet Sepsis Challenge is distributed as pipe separated
values (<code>.psv</code>) files, split into separate files per patient ID, containing
time stamped rows with measured variables as columns. Files are named with
patient IDs and do not contain any patient identifiers as data. Functions
<code>read_psv()</code> and <code>write_psv()</code> can be used to read from and write to such
a data format.
</p>


<h3>Value</h3>

<p>While <code>write_psv()</code> is called for side effects and returns <code>NULL</code>
invisibly, <code>read_psv()</code> returns an object inheriting from <code>id_tbl</code>.
</p>


<h3>References</h3>

<p>Reyna, M., Josef, C., Jeter, R., Shashikumar, S., Moody, B., Westover, M.
B., Sharma, A., Nemati, S., &amp; Clifford, G. (2019). Early Prediction of
Sepsis from Clinical Data &ndash; the PhysioNet Computing in Cardiology
Challenge 2019 (version 1.0.0). PhysioNet.
https://doi.org/10.13026/v64v-d857.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
