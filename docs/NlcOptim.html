<!DOCTYPE html><html><head><title>Help for package NlcOptim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NlcOptim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#solnl'><p>Solve Optimization problem with Nonlinear Objective and Constraints</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Solve Nonlinear Optimization with Nonlinear Constraints</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Xianyan Chen &lt;xychen@uga.edu&gt;, Xiangrong Yin &lt;yinxiangrong@uky.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xianyan Chen &lt;xychen@uga.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Optimization for nonlinear objective and constraint functions.  Linear or nonlinear equality and inequality constraints are allowed.  It accepts the input parameters as a constrained matrix.</td>
</tr>
<tr>
<td>Depends:</td>
<td>MASS, R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>quadprog</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-17 19:18:16 UTC; Chenxy</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-18 15:00:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='solnl'>Solve Optimization problem with Nonlinear Objective and Constraints</h2><span id='topic+solnl'></span>

<h3>Description</h3>

<p>Sequential Quatratic
Programming (SQP) method is implemented to find solution for general nonlinear optimization problem 
(with nonlinear objective and constraint functions). The SQP method can be find in detail in Chapter 18 of 
Jorge Nocedal and Stephen J. Wright's book.
Linear or nonlinear equality and inequality constraints are allowed.  
It accepts the input parameters as a constrained matrix.
The function <code>solnl</code> is to solve generalized nonlinear optimization problem:
</p>
<p style="text-align: center;"><code class="reqn">min f(x)</code>
</p>

<p style="text-align: center;"><code class="reqn">s.t. ceq(x)=0</code>
</p>

<p style="text-align: center;"><code class="reqn">c(x)\le 0</code>
</p>

<p style="text-align: center;"><code class="reqn">Ax\le B</code>
</p>

<p style="text-align: center;"><code class="reqn">Aeq x \le Beq</code>
</p>

<p style="text-align: center;"><code class="reqn">lb\le x \le ub</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>solnl(X = NULL, objfun = NULL, confun = NULL, A = NULL, B = NULL,
  Aeq = NULL, Beq = NULL, lb = NULL, ub = NULL, tolX = 1e-05,
  tolFun = 1e-06, tolCon = 1e-06, maxnFun = 1e+07, maxIter = 4000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solnl_+3A_x">X</code></td>
<td>
<p>Starting vector of parameter values.</p>
</td></tr>
<tr><td><code id="solnl_+3A_objfun">objfun</code></td>
<td>
<p>Nonlinear objective function that is to be optimized.</p>
</td></tr>
<tr><td><code id="solnl_+3A_confun">confun</code></td>
<td>
<p>Nonlinear constraint function. Return a <code>ceq</code> vector 
and a <code>c</code> vector as nonlinear equality constraints and an inequality constraints.</p>
</td></tr>
<tr><td><code id="solnl_+3A_a">A</code></td>
<td>
<p>A in the linear inequality constraints.</p>
</td></tr>
<tr><td><code id="solnl_+3A_b">B</code></td>
<td>
<p>B in the linear inequality constraints.</p>
</td></tr>
<tr><td><code id="solnl_+3A_aeq">Aeq</code></td>
<td>
<p>Aeq in the linear equality constraints.</p>
</td></tr>
<tr><td><code id="solnl_+3A_beq">Beq</code></td>
<td>
<p>Beq in the linear equality constraints.</p>
</td></tr>
<tr><td><code id="solnl_+3A_lb">lb</code></td>
<td>
<p>Lower bounds of parameters.</p>
</td></tr>
<tr><td><code id="solnl_+3A_ub">ub</code></td>
<td>
<p>Upper bounds of parameters.</p>
</td></tr>
<tr><td><code id="solnl_+3A_tolx">tolX</code></td>
<td>
<p>The tolerance in X.</p>
</td></tr>
<tr><td><code id="solnl_+3A_tolfun">tolFun</code></td>
<td>
<p>The tolerance in the objective function.</p>
</td></tr>
<tr><td><code id="solnl_+3A_tolcon">tolCon</code></td>
<td>
<p>The tolenrance in the constraint function.</p>
</td></tr>
<tr><td><code id="solnl_+3A_maxnfun">maxnFun</code></td>
<td>
<p>Maximum updates in the objective function.</p>
</td></tr>
<tr><td><code id="solnl_+3A_maxiter">maxIter</code></td>
<td>
<p>Maximum iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with the following components:  
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>The optimum solution.</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>The value of the objective function at the optimal point.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>Number of function evaluations, and number of gradient evaluations.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Lagrangian multiplier.</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>
<p>The gradient of the objective function at the optimal point.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Hessian of the objective function at the optimal point.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xianyan Chen, Xiangrong Yin
</p>


<h3>References</h3>

<p>Nocedal, Jorge, and Stephen Wright. Numerical optimization. Springer Science &amp; Business Media, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
###ex1
objfun=function(x){
 return(exp(x[1]*x[2]*x[3]*x[4]*x[5]))  
}
#constraint function
confun=function(x){
 f=NULL
 f=rbind(f,x[1]^2+x[2]^2+x[3]^2+x[4]^2+x[5]^2-10)
 f=rbind(f,x[2]*x[3]-5*x[4]*x[5])
 f=rbind(f,x[1]^3+x[2]^3+1)
 return(list(ceq=f,c=NULL))
}

x0=c(-2,2,2,-1,-1)
solnl(x0,objfun=objfun,confun=confun)

####ex2
obj=function(x){
 return((x[1]-1)^2+(x[1]-x[2])^2+(x[2]-x[3])^3+(x[3]-x[4])^4+(x[4]-x[5])^4)  
}
#constraint function
con=function(x){
 f=NULL
 f=rbind(f,x[1]+x[2]^2+x[3]^3-2-3*sqrt(2))
 f=rbind(f,x[2]-x[3]^2+x[4]+2-2*sqrt(2))
 f=rbind(f,x[1]*x[5]-2)
 return(list(ceq=f,c=NULL))
}

x0=c(1,1,1,1,1)
solnl(x0,objfun=obj,confun=con)


##########ex3
obj=function(x){
 return((1-x[1])^2+(x[2]-x[1]^2)^2)  
}
#constraint function
con=function(x){
 f=NULL
 f=rbind(f,x[1]^2+x[2]^2-1.5)
 return(list(ceq=NULL,c=f))
}

x0=as.matrix(c(-1.9,2))
obj(x0)
con(x0)
solnl(x0,objfun=obj,confun=con)


##########ex4
objfun=function(x){
 return(x[1]^2+x[2]^2)  
}
#constraint function
confun=function(x){
 f=NULL
 f=rbind(f,-x[1] - x[2] + 1)
 f=rbind(f,-x[1]^2 - x[2]^2 + 1)
 f=rbind(f,-9*x[1]^2 - x[2]^2 + 9)
 f=rbind(f,-x[1]^2 + x[2])
 f=rbind(f,-x[2]^2 + x[1])
 return(list(ceq=NULL,c=f))
}

x0=as.matrix(c(3,1))
solnl(x0,objfun=objfun,confun=confun)


##############ex5
rosbkext.f &lt;- function(x){
   n &lt;- length(x)
   sum (100*(x[1:(n-1)]^2 - x[2:n])^2 + (x[1:(n-1)] - 1)^2)
}
n &lt;- 2
set.seed(54321)
p0 &lt;- rnorm(n)
Aeq &lt;- matrix(rep(1, n), nrow=1)
Beq &lt;- 1
lb &lt;- c(rep(-Inf, n-1), 0)
solnl(X=p0,objfun=rosbkext.f, lb=lb, Aeq=Aeq, Beq=Beq)
ub &lt;- rep(1, n)
solnl(X=p0,objfun=rosbkext.f, lb=lb, ub=ub, Aeq=Aeq, Beq=Beq)


##############ex6
nh &lt;- vector("numeric", length = 5)

Nh &lt;- c(6221,11738,4333,22809,5467)
ch &lt;- c(120, 80, 80, 90, 150)

mh.rev &lt;- c(85, 11, 23, 17, 126)
Sh.rev &lt;- c(170.0, 8.8, 23.0, 25.5, 315.0)

mh.emp &lt;- c(511, 21, 70, 32, 157)
Sh.emp &lt;- c(255.50, 5.25, 35.00, 32.00, 471.00)

ph.rsch &lt;- c(0.8, 0.2, 0.5, 0.3, 0.9)

ph.offsh &lt;- c(0.06, 0.03, 0.03, 0.21, 0.77)

budget = 300000
n.min &lt;- 100
relvar.rev &lt;- function(nh){
 rv &lt;- sum(Nh * (Nh/nh - 1)*Sh.rev^2)
 tot &lt;- sum(Nh * mh.rev)
 rv/tot^2
}

relvar.emp &lt;- function(nh){
 rv &lt;- sum(Nh * (Nh/nh - 1)*Sh.emp^2)
 tot &lt;- sum(Nh * mh.emp)
 rv/tot^2
}

relvar.rsch &lt;- function(nh){
 rv &lt;- sum( Nh * (Nh/nh - 1)*ph.rsch*(1-ph.rsch)*Nh/(Nh-1) )
 tot &lt;- sum(Nh * ph.rsch)
 rv/tot^2
}

relvar.offsh &lt;- function(nh){
 rv &lt;- sum( Nh * (Nh/nh - 1)*ph.offsh*(1-ph.offsh)*Nh/(Nh-1) )
 tot &lt;- sum(Nh * ph.offsh)
 rv/tot^2
}

nlc.constraints &lt;- function(nh){
 h &lt;- rep(NA, 13)
 h[1:length(nh)] &lt;- (Nh + 0.01) - nh
 h[(length(nh)+1) : (2*length(nh)) ] &lt;- (nh + 0.01) - n.min
 h[2*length(nh) + 1] &lt;- 0.05^2 - relvar.emp(nh)
 h[2*length(nh) + 2] &lt;- 0.03^2 - relvar.rsch(nh)
 h[2*length(nh) + 3] &lt;- 0.03^2 - relvar.offsh(nh)
 return(list(ceq=NULL, c=-h))
}

nlc &lt;- function(nh){
 h &lt;- rep(NA, 3)
 h[ 1] &lt;- 0.05^2 - relvar.emp(nh)
 h[ 2] &lt;- 0.03^2 - relvar.rsch(nh)
 h[3] &lt;- 0.03^2 - relvar.offsh(nh)
 return(list(ceq=NULL, c=-h))
}

Aeq &lt;- matrix(ch/budget, nrow=1)
Beq &lt;- 1

A=rbind(diag(-1,5,5),diag(1,5,5))
B=c(-Nh-0.01,rep(n.min-0.01,5))

solnl(X=rep(100,5),objfun=relvar.rev,confun=nlc.constraints, Aeq=Aeq, Beq=Beq)

solnl(X=rep(100,5),objfun=relvar.rev,confun=nlc, Aeq=Aeq, Beq=Beq, A=-A, B=-B)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
