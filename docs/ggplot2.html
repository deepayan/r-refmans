<!DOCTYPE html><html><head><title>Help for package ggplot2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggplot2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+.gg'><p>Add components to a plot</p></a></li>
<li><a href='#absoluteGrob'><p>Absolute grob</p></a></li>
<li><a href='#add_theme'><p>Modify properties of an element in a theme object</p></a></li>
<li><a href='#aes'><p>Construct aesthetic mappings</p></a></li>
<li><a href='#aes_'><p>Define aesthetic mappings programmatically</p></a></li>
<li><a href='#aes_all'><p>Given a character vector, create a set of identity mappings</p></a></li>
<li><a href='#aes_auto'><p>Automatic aesthetic mapping</p></a></li>
<li><a href='#aes_colour_fill_alpha'><p>Colour related aesthetics: colour, fill, and alpha</p></a></li>
<li><a href='#aes_eval'><p>Control aesthetic evaluation</p></a></li>
<li><a href='#aes_group_order'><p>Aesthetics: grouping</p></a></li>
<li><a href='#aes_linetype_size_shape'><p>Differentiation related aesthetics: linetype, size, shape</p></a></li>
<li><a href='#aes_position'><p>Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend</p></a></li>
<li><a href='#annotate'><p>Create an annotation layer</p></a></li>
<li><a href='#annotation_custom'><p>Annotation: Custom grob</p></a></li>
<li><a href='#annotation_logticks'><p>Annotation: log tick marks</p></a></li>
<li><a href='#annotation_map'><p>Annotation: a map</p></a></li>
<li><a href='#annotation_raster'><p>Annotation: high-performance rectangular tiling</p></a></li>
<li><a href='#as_labeller'><p>Coerce to labeller function</p></a></li>
<li><a href='#as.list.ggproto'><p>Convert a ggproto object to a list</p></a></li>
<li><a href='#autolayer'><p>Create a ggplot layer appropriate to a particular data type</p></a></li>
<li><a href='#autoplot'><p>Create a complete ggplot appropriate to a particular data type</p></a></li>
<li><a href='#benchplot'><p>Benchmark plot creation time.</p>
Broken down into construct, build, render and draw times.</a></li>
<li><a href='#bidirection'><p>Utilities for working with bidirectional layers</p></a></li>
<li><a href='#binned_scale'><p>Binning scale constructor</p></a></li>
<li><a href='#borders'><p>Create a layer of map borders</p></a></li>
<li><a href='#calc_element'><p>Calculate the element properties, by inheriting properties from its parents</p></a></li>
<li><a href='#check_device'><p>Check graphics device capabilities</p></a></li>
<li><a href='#combine_vars'><p>Take input data and define a mapping between faceting variables and ROW,</p>
COL and PANEL keys</a></li>
<li><a href='#continuous_scale'><p>Continuous scale constructor</p></a></li>
<li><a href='#coord_cartesian'><p>Cartesian coordinates</p></a></li>
<li><a href='#coord_fixed'><p>Cartesian coordinates with fixed &quot;aspect ratio&quot;</p></a></li>
<li><a href='#coord_flip'><p>Cartesian coordinates with x and y flipped</p></a></li>
<li><a href='#coord_map'><p>Map projections</p></a></li>
<li><a href='#coord_munch'><p>Munch coordinates data</p></a></li>
<li><a href='#coord_polar'><p>Polar coordinates</p></a></li>
<li><a href='#coord_trans'><p>Transformed Cartesian coordinate system</p></a></li>
<li><a href='#CoordSf'><p>Visualise sf objects</p></a></li>
<li><a href='#cut_interval'><p>Discretise numeric data into categorical</p></a></li>
<li><a href='#datetime_scale'><p>Date/time scale constructor</p></a></li>
<li><a href='#diamonds'><p>Prices of over 50,000 round cut diamonds</p></a></li>
<li><a href='#discrete_scale'><p>Discrete scale constructor</p></a></li>
<li><a href='#draw_key'><p>Key glyphs for legends</p></a></li>
<li><a href='#economics'><p>US economic time series</p></a></li>
<li><a href='#element'><p>Theme elements</p></a></li>
<li><a href='#element_grob'><p>Generate grid grob from theme element</p></a></li>
<li><a href='#element_render'><p>Render a specified theme element into a grob</p></a></li>
<li><a href='#expand_limits'><p>Expand the plot limits, using data</p></a></li>
<li><a href='#expansion'><p>Generate expansion vector for scales</p></a></li>
<li><a href='#facet_grid'><p>Lay out panels in a grid</p></a></li>
<li><a href='#facet_null'><p>Facet specification: a single panel.</p></a></li>
<li><a href='#facet_wrap'><p>Wrap a 1d ribbon of panels into 2d</p></a></li>
<li><a href='#faithfuld'><p>2d density estimate of Old Faithful data</p></a></li>
<li><a href='#fill_alpha'><p>Modify fill transparency</p></a></li>
<li><a href='#find_panel'><p>Find panels in a gtable</p></a></li>
<li><a href='#fortify'><p>Fortify a model with data.</p></a></li>
<li><a href='#fortify-multcomp'><p>Fortify methods for objects produced by <span class="pkg">multcomp</span></p></a></li>
<li><a href='#fortify.lm'><p>Supplement the data fitted to a linear model with model fit statistics.</p></a></li>
<li><a href='#fortify.map'><p>Fortify method for map objects</p></a></li>
<li><a href='#fortify.sp'><p>Fortify method for classes from the sp package.</p></a></li>
<li><a href='#geom_abline'><p>Reference lines: horizontal, vertical, and diagonal</p></a></li>
<li><a href='#geom_bar'><p>Bar charts</p></a></li>
<li><a href='#geom_bin_2d'><p>Heatmap of 2d bin counts</p></a></li>
<li><a href='#geom_blank'><p>Draw nothing</p></a></li>
<li><a href='#geom_boxplot'><p>A box and whiskers plot (in the style of Tukey)</p></a></li>
<li><a href='#geom_contour'><p>2D contours of a 3D surface</p></a></li>
<li><a href='#geom_count'><p>Count overlapping points</p></a></li>
<li><a href='#geom_crossbar'><p>Vertical intervals: lines, crossbars &amp; errorbars</p></a></li>
<li><a href='#geom_density'><p>Smoothed density estimates</p></a></li>
<li><a href='#geom_density_2d'><p>Contours of a 2D density estimate</p></a></li>
<li><a href='#geom_dotplot'><p>Dot plot</p></a></li>
<li><a href='#geom_errorbarh'><p>Horizontal error bars</p></a></li>
<li><a href='#geom_freqpoly'><p>Histograms and frequency polygons</p></a></li>
<li><a href='#geom_function'><p>Draw a function as a continuous curve</p></a></li>
<li><a href='#geom_hex'><p>Hexagonal heatmap of 2d bin counts</p></a></li>
<li><a href='#geom_jitter'><p>Jittered points</p></a></li>
<li><a href='#geom_label'><p>Text</p></a></li>
<li><a href='#geom_map'><p>Polygons from a reference map</p></a></li>
<li><a href='#geom_path'><p>Connect observations</p></a></li>
<li><a href='#geom_point'><p>Points</p></a></li>
<li><a href='#geom_polygon'><p>Polygons</p></a></li>
<li><a href='#geom_qq_line'><p>A quantile-quantile plot</p></a></li>
<li><a href='#geom_quantile'><p>Quantile regression</p></a></li>
<li><a href='#geom_raster'><p>Rectangles</p></a></li>
<li><a href='#geom_ribbon'><p>Ribbons and area plots</p></a></li>
<li><a href='#geom_rug'><p>Rug plots in the margins</p></a></li>
<li><a href='#geom_segment'><p>Line segments and curves</p></a></li>
<li><a href='#geom_smooth'><p>Smoothed conditional means</p></a></li>
<li><a href='#geom_spoke'><p>Line segments parameterised by location, direction and distance</p></a></li>
<li><a href='#geom_violin'><p>Violin plot</p></a></li>
<li><a href='#get_alt_text'><p>Extract alt text from a plot</p></a></li>
<li><a href='#get_guide_data'><p>Extract tick information from guides</p></a></li>
<li><a href='#gg_dep'><p>Give a deprecation error, warning, or message, depending on version number.</p></a></li>
<li><a href='#ggplot'><p>Create a new ggplot</p></a></li>
<li><a href='#ggplot_add'><p>Add custom objects to ggplot</p></a></li>
<li><a href='#ggplot_build'><p>Build ggplot for rendering.</p></a></li>
<li><a href='#ggplot_gtable'><p>Build a plot with all the usual bits and pieces.</p></a></li>
<li><a href='#ggplot2-ggproto'><p>Base ggproto classes for ggplot2</p></a></li>
<li><a href='#ggplot2-package'><p>ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics</p></a></li>
<li><a href='#ggplotGrob'><p>Generate a ggplot2 plot grob.</p></a></li>
<li><a href='#ggproto'><p>Create a new ggproto object</p></a></li>
<li><a href='#ggsave'><p>Save a ggplot (or other grid object) with sensible defaults</p></a></li>
<li><a href='#ggtheme'><p>Complete themes</p></a></li>
<li><a href='#graphical-units'><p>Graphical units</p></a></li>
<li><a href='#guide_axis'><p>Axis guide</p></a></li>
<li><a href='#guide_axis_logticks'><p>Axis with logarithmic tick marks</p></a></li>
<li><a href='#guide_axis_stack'><p>Stacked axis guides</p></a></li>
<li><a href='#guide_axis_theta'><p>Angle axis guide</p></a></li>
<li><a href='#guide_bins'><p>A binned version of guide_legend</p></a></li>
<li><a href='#guide_colourbar'><p>Continuous colour bar guide</p></a></li>
<li><a href='#guide_coloursteps'><p>Discretized colourbar guide</p></a></li>
<li><a href='#guide_custom'><p>Custom guides</p></a></li>
<li><a href='#guide_legend'><p>Legend guide</p></a></li>
<li><a href='#guide_none'><p>Empty guide</p></a></li>
<li><a href='#guides'><p>Set guides for each scale</p></a></li>
<li><a href='#hmisc'><p>A selection of summary functions from Hmisc</p></a></li>
<li><a href='#ignoring_data'><p>Ignoring and exposing data</p></a></li>
<li><a href='#is.Coord'><p>Is this object a coordinate system?</p></a></li>
<li><a href='#is.facet'><p>Is this object a faceting specification?</p></a></li>
<li><a href='#is.ggplot'><p>Reports whether x is a ggplot object</p></a></li>
<li><a href='#is.rel'><p>Reports whether x is a rel object</p></a></li>
<li><a href='#is.theme'><p>Reports whether x is a theme object</p></a></li>
<li><a href='#label_bquote'><p>Label with mathematical expressions</p></a></li>
<li><a href='#labeller'><p>Construct labelling specification</p></a></li>
<li><a href='#labellers'><p>Useful labeller functions</p></a></li>
<li><a href='#labs'><p>Modify axis, legend, and plot labels</p></a></li>
<li><a href='#last_plot'><p>Retrieve the last plot to be modified or created.</p></a></li>
<li><a href='#layer'><p>Create a new layer</p></a></li>
<li><a href='#layer_sf'><p>Create a new sf layer that auto-maps geometry data</p></a></li>
<li><a href='#limits'><p>Generate correct scale type for specified limits</p></a></li>
<li><a href='#lims'><p>Set scale limits</p></a></li>
<li><a href='#luv_colours'><p><code>colors()</code> in Luv space</p></a></li>
<li><a href='#map_data'><p>Create a data frame of map data</p></a></li>
<li><a href='#max_height'><p>Get the maximal width/length of a list of grobs</p></a></li>
<li><a href='#mean_se'><p>Calculate mean and standard error of the mean</p></a></li>
<li><a href='#merge_element'><p>Merge a parent element into a child element</p></a></li>
<li><a href='#midwest'><p>Midwest demographics</p></a></li>
<li><a href='#mpg'><p>Fuel economy data from 1999 to 2008 for 38 popular models of cars</p></a></li>
<li><a href='#msleep'><p>An updated and expanded version of the mammals sleep dataset</p></a></li>
<li><a href='#new_guide'><p>Guide constructor</p></a></li>
<li><a href='#old_guide'><p>The previous S3 guide system</p></a></li>
<li><a href='#pattern_alpha'><p>Modify transparency for patterns</p></a></li>
<li><a href='#position_dodge'><p>Dodge overlapping objects side-to-side</p></a></li>
<li><a href='#position_identity'><p>Don't adjust position</p></a></li>
<li><a href='#position_jitter'><p>Jitter points to avoid overplotting</p></a></li>
<li><a href='#position_jitterdodge'><p>Simultaneously dodge and jitter</p></a></li>
<li><a href='#position_nudge'><p>Nudge points a fixed distance</p></a></li>
<li><a href='#position_stack'><p>Stack overlapping objects on top of each another</p></a></li>
<li><a href='#presidential'><p>Terms of 12 presidents from Eisenhower to Trump</p></a></li>
<li><a href='#print.ggplot'><p>Explicitly draw plot</p></a></li>
<li><a href='#print.ggproto'><p>Format or print a ggproto object</p></a></li>
<li><a href='#qplot'><p>Quick plot</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#register_theme_elements'><p>Define and register new theme elements</p></a></li>
<li><a href='#remove_missing'><p>Convenience function to remove missing values from a data.frame</p></a></li>
<li><a href='#render_axes'><p>Render panel axes</p></a></li>
<li><a href='#render_strips'><p>Render panel strips</p></a></li>
<li><a href='#resolution'><p>Compute the &quot;resolution&quot; of a numeric vector</p></a></li>
<li><a href='#scale_alpha'><p>Alpha transparency scales</p></a></li>
<li><a href='#scale_binned'><p>Positional scales for binning continuous data (x &amp; y)</p></a></li>
<li><a href='#scale_colour_brewer'><p>Sequential, diverging and qualitative colour scales from ColorBrewer</p></a></li>
<li><a href='#scale_colour_continuous'><p>Continuous and binned colour scales</p></a></li>
<li><a href='#scale_colour_discrete'><p>Discrete colour scales</p></a></li>
<li><a href='#scale_colour_gradient'><p>Gradient colour scales</p></a></li>
<li><a href='#scale_colour_grey'><p>Sequential grey colour scales</p></a></li>
<li><a href='#scale_colour_hue'><p>Evenly spaced colours for discrete data</p></a></li>
<li><a href='#scale_colour_steps'><p>Binned gradient colour scales</p></a></li>
<li><a href='#scale_colour_viridis_d'><p>Viridis colour scales from viridisLite</p></a></li>
<li><a href='#scale_continuous'><p>Position scales for continuous data (x &amp; y)</p></a></li>
<li><a href='#scale_date'><p>Position scales for date/time data</p></a></li>
<li><a href='#scale_identity'><p>Use values without scaling</p></a></li>
<li><a href='#scale_linetype'><p>Scale for line patterns</p></a></li>
<li><a href='#scale_linewidth'><p>Scales for line width</p></a></li>
<li><a href='#scale_manual'><p>Create your own discrete scale</p></a></li>
<li><a href='#scale_shape'><p>Scales for shapes, aka glyphs</p></a></li>
<li><a href='#scale_size'><p>Scales for area or radius</p></a></li>
<li><a href='#scale_type'><p>Determine default scale type</p></a></li>
<li><a href='#scale_x_discrete'><p>Position scales for discrete data</p></a></li>
<li><a href='#seals'><p>Vector field of seal movements</p></a></li>
<li><a href='#sec_axis'><p>Specify a secondary axis</p></a></li>
<li><a href='#set_last_plot'><p>Set the last plot to be fetched by lastplot()</p></a></li>
<li><a href='#sf_transform_xy'><p>Transform spatial position data</p></a></li>
<li><a href='#should_stop'><p>Used in examples to illustrate when errors should occur.</p></a></li>
<li><a href='#standardise_aes_names'><p>Standardise aesthetic names</p></a></li>
<li><a href='#stat_ecdf'><p>Compute empirical cumulative distribution</p></a></li>
<li><a href='#stat_ellipse'><p>Compute normal data ellipses</p></a></li>
<li><a href='#stat_identity'><p>Leave data as is</p></a></li>
<li><a href='#stat_sf_coordinates'><p>Extract coordinates from 'sf' objects</p></a></li>
<li><a href='#stat_summary_2d'><p>Bin and summarise in 2d (rectangle &amp; hexagons)</p></a></li>
<li><a href='#stat_summary_bin'><p>Summarise y values at unique/binned x</p></a></li>
<li><a href='#stat_unique'><p>Remove duplicates</p></a></li>
<li><a href='#summarise_plot'><p>Summarise built plot objects</p></a></li>
<li><a href='#summary.ggplot'><p>Displays a useful description of a ggplot object</p></a></li>
<li><a href='#theme'><p>Modify components of a theme</p></a></li>
<li><a href='#theme_get'><p>Get, set, and modify the active theme</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
<li><a href='#transform_position'><p>Convenience function to transform all position variables.</p></a></li>
<li><a href='#translate_shape_string'><p>Translating shape strings</p></a></li>
<li><a href='#txhousing'><p>Housing sales in TX</p></a></li>
<li><a href='#update_geom_defaults'><p>Modify geom/stat aesthetic defaults for future plots</p></a></li>
<li><a href='#update_labels'><p>Update axis/legend labels</p></a></li>
<li><a href='#vars'><p>Quote faceting variables</p></a></li>
<li><a href='#waiver'><p>A waiver object.</p></a></li>
<li><a href='#wrap_dims'><p>Arrange 1d structure into a grid</p></a></li>
<li><a href='#zeroGrob'><p>The zero grob draws nothing and has zero size.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.5.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Create Elegant Data Visualisations Using the Grammar of Graphics</td>
</tr>
<tr>
<td>Description:</td>
<td>A system for 'declaratively' creating graphics, based on "The
    Grammar of Graphics". You provide the data, tell 'ggplot2' how to map
    variables to aesthetics, what graphical primitives to use, and it
    takes care of the details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ggplot2.tidyverse.org">https://ggplot2.tidyverse.org</a>,
<a href="https://github.com/tidyverse/ggplot2">https://github.com/tidyverse/ggplot2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/ggplot2/issues">https://github.com/tidyverse/ggplot2/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, glue, grDevices, grid, gtable (&ge; 0.1.1), isoband,
lifecycle (&gt; 1.0.1), MASS, mgcv, rlang (&ge; 1.1.0), scales (&ge;
1.3.0), stats, tibble, vctrs (&ge; 0.5.0), withr (&ge; 2.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, ggplot2movies, hexbin, Hmisc, knitr, mapproj,
maps, multcomp, munsell, nlme, profvis, quantreg, ragg (&ge;
1.2.6), RColorBrewer, rmarkdown, rpart, sf (&ge; 0.7-3), svglite
(&ge; 2.1.2), testthat (&ge; 3.1.2), vdiffr (&ge; 1.0.6), xml2</td>
</tr>
<tr>
<td>Enhances:</td>
<td>sp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>ggtext, tidyr, forcats, tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Collate:</td>
<td>'ggproto.R' 'ggplot-global.R' 'aaa-.R'
'aes-colour-fill-alpha.R' 'aes-evaluation.R'
'aes-group-order.R' 'aes-linetype-size-shape.R'
'aes-position.R' 'compat-plyr.R' 'utilities.R' 'aes.R'
'utilities-checks.R' 'legend-draw.R' 'geom-.R'
'annotation-custom.R' 'annotation-logticks.R' 'geom-polygon.R'
'geom-map.R' 'annotation-map.R' 'geom-raster.R'
'annotation-raster.R' 'annotation.R' 'autolayer.R' 'autoplot.R'
'axis-secondary.R' 'backports.R' 'bench.R' 'bin.R' 'coord-.R'
'coord-cartesian-.R' 'coord-fixed.R' 'coord-flip.R'
'coord-map.R' 'coord-munch.R' 'coord-polar.R'
'coord-quickmap.R' 'coord-radial.R' 'coord-sf.R'
'coord-transform.R' 'data.R' 'facet-.R' 'facet-grid-.R'
'facet-null.R' 'facet-wrap.R' 'fortify-lm.R' 'fortify-map.R'
'fortify-multcomp.R' 'fortify-spatial.R' 'fortify.R' 'stat-.R'
'geom-abline.R' 'geom-rect.R' 'geom-bar.R' 'geom-bin2d.R'
'geom-blank.R' 'geom-boxplot.R' 'geom-col.R' 'geom-path.R'
'geom-contour.R' 'geom-count.R' 'geom-crossbar.R'
'geom-segment.R' 'geom-curve.R' 'geom-defaults.R'
'geom-ribbon.R' 'geom-density.R' 'geom-density2d.R'
'geom-dotplot.R' 'geom-errorbar.R' 'geom-errorbarh.R'
'geom-freqpoly.R' 'geom-function.R' 'geom-hex.R'
'geom-histogram.R' 'geom-hline.R' 'geom-jitter.R'
'geom-label.R' 'geom-linerange.R' 'geom-point.R'
'geom-pointrange.R' 'geom-quantile.R' 'geom-rug.R' 'geom-sf.R'
'geom-smooth.R' 'geom-spoke.R' 'geom-text.R' 'geom-tile.R'
'geom-violin.R' 'geom-vline.R' 'ggplot2-package.R'
'grob-absolute.R' 'grob-dotstack.R' 'grob-null.R' 'grouping.R'
'theme-elements.R' 'guide-.R' 'guide-axis.R'
'guide-axis-logticks.R' 'guide-axis-stack.R'
'guide-axis-theta.R' 'guide-legend.R' 'guide-bins.R'
'guide-colorbar.R' 'guide-colorsteps.R' 'guide-custom.R'
'layer.R' 'guide-none.R' 'guide-old.R' 'guides-.R'
'guides-grid.R' 'hexbin.R' 'import-standalone-obj-type.R'
'import-standalone-types-check.R' 'labeller.R' 'labels.R'
'layer-sf.R' 'layout.R' 'limits.R' 'margins.R' 'performance.R'
'plot-build.R' 'plot-construction.R' 'plot-last.R' 'plot.R'
'position-.R' 'position-collide.R' 'position-dodge.R'
'position-dodge2.R' 'position-identity.R' 'position-jitter.R'
'position-jitterdodge.R' 'position-nudge.R' 'position-stack.R'
'quick-plot.R' 'reshape-add-margins.R' 'save.R' 'scale-.R'
'scale-alpha.R' 'scale-binned.R' 'scale-brewer.R'
'scale-colour.R' 'scale-continuous.R' 'scale-date.R'
'scale-discrete-.R' 'scale-expansion.R' 'scale-gradient.R'
'scale-grey.R' 'scale-hue.R' 'scale-identity.R'
'scale-linetype.R' 'scale-linewidth.R' 'scale-manual.R'
'scale-shape.R' 'scale-size.R' 'scale-steps.R' 'scale-type.R'
'scale-view.R' 'scale-viridis.R' 'scales-.R' 'stat-align.R'
'stat-bin.R' 'stat-bin2d.R' 'stat-bindot.R' 'stat-binhex.R'
'stat-boxplot.R' 'stat-contour.R' 'stat-count.R'
'stat-density-2d.R' 'stat-density.R' 'stat-ecdf.R'
'stat-ellipse.R' 'stat-function.R' 'stat-identity.R'
'stat-qq-line.R' 'stat-qq.R' 'stat-quantilemethods.R'
'stat-sf-coordinates.R' 'stat-sf.R' 'stat-smooth-methods.R'
'stat-smooth.R' 'stat-sum.R' 'stat-summary-2d.R'
'stat-summary-bin.R' 'stat-summary-hex.R' 'stat-summary.R'
'stat-unique.R' 'stat-ydensity.R' 'summarise-plot.R'
'summary.R' 'theme.R' 'theme-defaults.R' 'theme-current.R'
'utilities-break.R' 'utilities-grid.R' 'utilities-help.R'
'utilities-matrix.R' 'utilities-patterns.R'
'utilities-resolution.R' 'utilities-tidy-eval.R' 'zxx.R'
'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-21 12:29:53 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Winston Chang <a href="https://orcid.org/0000-0002-1576-2126"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Lionel Henry [aut],
  Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Kohske Takahashi [aut],
  Claus Wilke <a href="https://orcid.org/0000-0002-7470-9261"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Kara Woo <a href="https://orcid.org/0000-0002-5125-4188"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Hiroaki Yutani <a href="https://orcid.org/0000-0002-3385-7233"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Dewey Dunnington <a href="https://orcid.org/0000-0002-9415-4582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Teun van den Brand
    <a href="https://orcid.org/0000-0002-9335-7468"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Posit, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomas.pedersen@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2B.gg'>Add components to a plot</h2><span id='topic++2B.gg'></span><span id='topic++25+2B+25'></span>

<h3>Description</h3>

<p><code>+</code> is the key to constructing sophisticated ggplot2 graphics. It
allows you to start simple, then get more and more complex, checking your
work at each step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gg'
e1 + e2

e1 %+% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.gg_+3A_e1">e1</code></td>
<td>
<p>An object of class <code><a href="#topic+ggplot">ggplot()</a></code> or a <code><a href="#topic+theme">theme()</a></code>.</p>
</td></tr>
<tr><td><code id="+2B2B.gg_+3A_e2">e2</code></td>
<td>
<p>A plot component, as described below.</p>
</td></tr>
</table>


<h3>What can you add?</h3>

<p>You can add any of the following types of objects:
</p>

<ul>
<li><p> An <code><a href="#topic+aes">aes()</a></code> object replaces the default aesthetics.
</p>
</li>
<li><p> A layer created by a <code>geom_</code> or <code>stat_</code> function adds a
new layer.
</p>
</li>
<li><p> A <code>scale</code> overrides the existing scale.
</p>
</li>
<li><p> A <code><a href="#topic+theme">theme()</a></code> modifies the current theme.
</p>
</li>
<li><p> A <code>coord</code> overrides the current coordinate system.
</p>
</li>
<li><p> A <code>facet</code> specification overrides the current faceting.
</p>
</li></ul>

<p>To replace the current default data frame, you must use <code style="white-space: pre;">&#8288;%+%&#8288;</code>,
due to S3 method precedence issues.
</p>
<p>You can also supply a list, in which case each element of the list will
be added in turn.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theme">theme()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>base &lt;-
 ggplot(mpg, aes(displ, hwy)) +
 geom_point()
base + geom_smooth()

# To override the data, you must use %+%
base %+% subset(mpg, fl == "p")

# Alternatively, you can add multiple components with a list.
# This can be useful to return from a function.
base + list(subset(mpg, fl == "p"), geom_smooth())
</code></pre>

<hr>
<h2 id='absoluteGrob'>Absolute grob</h2><span id='topic+absoluteGrob'></span>

<h3>Description</h3>

<p>This grob has fixed dimensions and position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absoluteGrob(
  grob,
  width = NULL,
  height = NULL,
  xmin = NULL,
  ymin = NULL,
  vp = NULL
)
</code></pre>


<h3>Details</h3>

<p>It's still experimental
</p>

<hr>
<h2 id='add_theme'>Modify properties of an element in a theme object</h2><span id='topic+add_theme'></span>

<h3>Description</h3>

<p>Modify properties of an element in a theme object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_theme(t1, t2, t2name, call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_theme_+3A_t1">t1</code></td>
<td>
<p>A theme object</p>
</td></tr>
<tr><td><code id="add_theme_+3A_t2">t2</code></td>
<td>
<p>A theme object that is to be added to <code>t1</code></p>
</td></tr>
<tr><td><code id="add_theme_+3A_t2name">t2name</code></td>
<td>
<p>A name of the t2 object. This is used for printing
informative error messages.</p>
</td></tr>
</table>

<hr>
<h2 id='aes'>Construct aesthetic mappings</h2><span id='topic+aes'></span>

<h3>Description</h3>

<p>Aesthetic mappings describe how variables in the data are mapped to visual
properties (aesthetics) of geoms. Aesthetic mappings can be set in
<code><a href="#topic+ggplot">ggplot()</a></code> and in individual layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aes(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes_+3A_x">x</code>, <code id="aes_+3A_y">y</code>, <code id="aes_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+topic-data-mask">data-masking</a></code>&gt; List of name-value
pairs in the form <code>aesthetic = variable</code> describing which variables in the
layer data should be mapped to which aesthetics used by the paired
geom/stat. The expression <code>variable</code> is evaluated within the layer data, so
there is no need to refer to the original dataset (i.e., use
<code>ggplot(df, aes(variable))</code> instead of <code>ggplot(df, aes(df$variable))</code>).
The names for x and y aesthetics are typically omitted because they are so
common; all other aesthetics must be named.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function also standardises aesthetic names by converting <code>color</code> to <code>colour</code>
(also in substrings, e.g., <code>point_color</code> to <code>point_colour</code>) and translating old style
R names to ggplot names (e.g., <code>pch</code> to <code>shape</code> and <code>cex</code> to <code>size</code>).
</p>


<h3>Value</h3>

<p>A list with class <code>uneval</code>. Components of the list are either
quosures or constants.
</p>


<h3>Quasiquotation</h3>

<p><code>aes()</code> is a <a href="rlang.html#topic+topic-defuse">quoting function</a>. This means that
its inputs are quoted to be evaluated in the context of the
data. This makes it easy to work with variables from the data frame
because you can name those directly. The flip side is that you have
to use <a href="rlang.html#topic+topic-inject">quasiquotation</a> to program with
<code>aes()</code>. See a tidy evaluation tutorial such as the <a href="https://dplyr.tidyverse.org/articles/programming.html">dplyr programming vignette</a>
to learn more about these techniques.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vars">vars()</a></code> for another quoting function designed for
faceting specifications.
</p>
<p>Run <code>vignette("ggplot2-specs")</code> to see an overview of other aesthetics
that can be modified.
</p>
<p><a href="#topic+aes_eval">Delayed evaluation</a> for working with computed variables.
</p>
<p>Other aesthetics documentation: 
<code><a href="#topic+aes_colour_fill_alpha">aes_colour_fill_alpha</a></code>,
<code><a href="#topic+aes_group_order">aes_group_order</a></code>,
<code><a href="#topic+aes_linetype_size_shape">aes_linetype_size_shape</a></code>,
<code><a href="#topic+aes_position">aes_position</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aes(x = mpg, y = wt)
aes(mpg, wt)

# You can also map aesthetics to functions of variables
aes(x = mpg ^ 2, y = wt / cyl)

# Or to constants
aes(x = 1, colour = "smooth")

# Aesthetic names are automatically standardised
aes(col = x)
aes(fg = x)
aes(color = x)
aes(colour = x)

# aes() is passed to either ggplot() or specific layer. Aesthetics supplied
# to ggplot() are used as defaults for every layer.
ggplot(mpg, aes(displ, hwy)) + geom_point()
ggplot(mpg) + geom_point(aes(displ, hwy))

# Tidy evaluation ----------------------------------------------------
# aes() automatically quotes all its arguments, so you need to use tidy
# evaluation to create wrappers around ggplot2 pipelines. The
# simplest case occurs when your wrapper takes dots:
scatter_by &lt;- function(data, ...) {
  ggplot(data) + geom_point(aes(...))
}
scatter_by(mtcars, disp, drat)

# If your wrapper has a more specific interface with named arguments,
# you need the "embrace operator":
scatter_by &lt;- function(data, x, y) {
  ggplot(data) + geom_point(aes({{ x }}, {{ y }}))
}
scatter_by(mtcars, disp, drat)

# Note that users of your wrapper can use their own functions in the
# quoted expressions and all will resolve as it should!
cut3 &lt;- function(x) cut_number(x, 3)
scatter_by(mtcars, cut3(disp), drat)
</code></pre>

<hr>
<h2 id='aes_'>Define aesthetic mappings programmatically</h2><span id='topic+aes_'></span><span id='topic+aes_string'></span><span id='topic+aes_q'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Aesthetic mappings describe how variables in the data are mapped to visual
properties (aesthetics) of geoms. <code><a href="#topic+aes">aes()</a></code> uses non-standard
evaluation to capture the variable names. <code>aes_()</code> and <code>aes_string()</code>
require you to explicitly quote the inputs either with <code>""</code> for
<code>aes_string()</code>, or with <code>quote</code> or <code>~</code> for <code>aes_()</code>.
(<code>aes_q()</code> is an alias to <code>aes_()</code>). This makes <code>aes_()</code> and
<code>aes_string()</code> easy to program with.
</p>
<p><code>aes_string()</code> and <code>aes_()</code> are particularly useful when writing
functions that create plots because you can use strings or quoted
names/calls to define the aesthetic mappings, rather than having to use
<code><a href="base.html#topic+substitute">substitute()</a></code> to generate a call to <code>aes()</code>.
</p>
<p>I recommend using <code>aes_()</code>, because creating the equivalents of
<code>aes(colour = "my colour")</code> or <code>aes(x = `X$1`)</code>
with <code>aes_string()</code> is quite clunky.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aes_(x, y, ...)

aes_string(x, y, ...)

aes_q(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes__+3A_x">x</code>, <code id="aes__+3A_y">y</code>, <code id="aes__+3A_...">...</code></td>
<td>
<p>List of name value pairs. Elements must be either
quoted calls, strings, one-sided formulas or constants.</p>
</td></tr>
</table>


<h3>Life cycle</h3>

<p>All these functions are soft-deprecated. Please use tidy evaluation idioms
instead. Regarding <code>aes_string()</code>, you can replace it with <code>.data</code> pronoun.
For example, the following code can achieve the same mapping as
<code>aes_string(x_var, y_var)</code>.
</p>
<div class="sourceCode r"><pre>x_var &lt;- "foo"
y_var &lt;- "bar"
aes(.data[[x_var]], .data[[y_var]])
</pre></div>
<p>For more details, please see <code>vignette("ggplot2-in-packages")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aes">aes()</a></code>
</p>

<hr>
<h2 id='aes_all'>Given a character vector, create a set of identity mappings</h2><span id='topic+aes_all'></span>

<h3>Description</h3>

<p>Given a character vector, create a set of identity mappings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aes_all(vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes_all_+3A_vars">vars</code></td>
<td>
<p>vector of variable names</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>aes_all(names(mtcars))
aes_all(c("x", "y", "col", "pch"))
</code></pre>

<hr>
<h2 id='aes_auto'>Automatic aesthetic mapping</h2><span id='topic+aes_auto'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aes_auto(data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes_auto_+3A_data">data</code></td>
<td>
<p>data.frame or names of variables</p>
</td></tr>
<tr><td><code id="aes_auto_+3A_...">...</code></td>
<td>
<p>aesthetics that need to be explicitly mapped.</p>
</td></tr>
</table>

<hr>
<h2 id='aes_colour_fill_alpha'>Colour related aesthetics: colour, fill, and alpha</h2><span id='topic+aes_colour_fill_alpha'></span><span id='topic+colour'></span><span id='topic+color'></span><span id='topic+fill'></span>

<h3>Description</h3>

<p>These aesthetics parameters change the colour (<code>colour</code> and <code>fill</code>) and the
opacity (<code>alpha</code>) of geom elements on a plot. Almost every geom has either
colour or fill (or both), as well as can have their alpha modified.
Modifying colour on a plot is a useful way to enhance the presentation of data,
often especially when a plot graphs more than two variables.
</p>


<h3>Colour and fill</h3>

<p>The <code>colour</code> aesthetic is used to draw lines and strokes, such as in
<code><a href="#topic+geom_point">geom_point()</a></code> and <code><a href="#topic+geom_line">geom_line()</a></code>, but also the line contours of
<code><a href="#topic+geom_rect">geom_rect()</a></code> and <code><a href="#topic+geom_polygon">geom_polygon()</a></code>. The <code>fill</code> aesthetic is used to
colour the inside areas of geoms, such as <code><a href="#topic+geom_rect">geom_rect()</a></code> and
<code><a href="#topic+geom_polygon">geom_polygon()</a></code>, but also the insides of shapes 21-25 of <code><a href="#topic+geom_point">geom_point()</a></code>.
</p>
<p>Colours and fills can be specified in the following ways:
</p>

<ul>
<li><p> A name, e.g., <code>"red"</code>. R has 657 built-in named colours, which can be
listed with <code><a href="grDevices.html#topic+colors">grDevices::colors()</a></code>.
</p>
</li>
<li><p> An rgb specification, with a string of the form <code>"#RRGGBB"</code> where each of the
pairs <code>RR</code>, <code>GG</code>, <code>BB</code> consists of two hexadecimal digits giving a value in the
range <code>00</code> to <code>FF</code>. You can optionally make the colour transparent by using the
form <code>"#RRGGBBAA"</code>.
</p>
</li>
<li><p> An <code>NA</code>, for a completely transparent colour.
</p>
</li></ul>



<h3>Alpha</h3>

<p>Alpha refers to the opacity of a geom. Values of <code>alpha</code> range from 0 to 1,
with lower values corresponding to more transparent colors.
</p>
<p>Alpha can additionally be modified through the <code>colour</code> or <code>fill</code> aesthetic
if either aesthetic provides color values using an rgb specification
(<code>"#RRGGBBAA"</code>), where <code>AA</code> refers to transparency values.
</p>


<h3>See Also</h3>


<ul>
<li><p> Other options for modifying colour:
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer()</a></code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient()</a></code>, <code><a href="#topic+scale_colour_grey">scale_colour_grey()</a></code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue()</a></code>, <code><a href="#topic+scale_colour_identity">scale_colour_identity()</a></code>,
<code><a href="#topic+scale_colour_manual">scale_colour_manual()</a></code>, <code><a href="#topic+scale_colour_viridis_d">scale_colour_viridis_d()</a></code>
</p>
</li>
<li><p> Other options for modifying fill:
<code><a href="#topic+scale_fill_brewer">scale_fill_brewer()</a></code>,
<code><a href="#topic+scale_fill_gradient">scale_fill_gradient()</a></code>, <code><a href="#topic+scale_fill_grey">scale_fill_grey()</a></code>,
<code><a href="#topic+scale_fill_hue">scale_fill_hue()</a></code>, <code><a href="#topic+scale_fill_identity">scale_fill_identity()</a></code>,
<code><a href="#topic+scale_fill_manual">scale_fill_manual()</a></code>, <code><a href="#topic+scale_fill_viridis_d">scale_fill_viridis_d()</a></code>
</p>
</li>
<li><p> Other options for modifying alpha:
<code><a href="#topic+scale_alpha">scale_alpha()</a></code>, <code><a href="#topic+scale_alpha_manual">scale_alpha_manual()</a></code>, <code><a href="#topic+scale_alpha_identity">scale_alpha_identity()</a></code>
</p>
</li>
<li><p> Run <code>vignette("ggplot2-specs")</code> to see an overview of other aesthetics that
can be modified.
</p>
</li></ul>

<p>Other aesthetics documentation: 
<code><a href="#topic+aes_group_order">aes_group_order</a></code>,
<code><a href="#topic+aes_linetype_size_shape">aes_linetype_size_shape</a></code>,
<code><a href="#topic+aes_position">aes_position</a></code>,
<code><a href="#topic+aes">aes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Bar chart example
p &lt;- ggplot(mtcars, aes(factor(cyl)))
# Default plotting
p + geom_bar()
# To change the interior colouring use fill aesthetic
p + geom_bar(fill = "red")
# Compare with the colour aesthetic which changes just the bar outline
p + geom_bar(colour = "red")
# Combining both, you can see the changes more clearly
p + geom_bar(fill = "white", colour = "red")
# Both colour and fill can take an rgb specification.
p + geom_bar(fill = "#00abff")
# Use NA for a completely transparent colour.
p + geom_bar(fill = NA, colour = "#00abff")

# Colouring scales differ depending on whether a discrete or
# continuous variable is being mapped. For example, when mapping
# fill to a factor variable, a discrete colour scale is used.
ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) + geom_bar()

# When mapping fill to continuous variable a continuous colour
# scale is used.
ggplot(faithfuld, aes(waiting, eruptions)) +
  geom_raster(aes(fill = density))

# Some geoms only use the colour aesthetic but not the fill
# aesthetic (e.g. geom_point() or geom_line()).
p &lt;- ggplot(economics, aes(x = date, y = unemploy))
p + geom_line()
p + geom_line(colour = "green")
p + geom_point()
p + geom_point(colour = "red")

# For large datasets with overplotting the alpha
# aesthetic will make the points more transparent.
set.seed(1)
df &lt;- data.frame(x = rnorm(5000), y = rnorm(5000))
p  &lt;- ggplot(df, aes(x,y))
p + geom_point()
p + geom_point(alpha = 0.5)
p + geom_point(alpha = 1/10)

# Alpha can also be used to add shading.
p &lt;- ggplot(economics, aes(x = date, y = unemploy)) + geom_line()
p
yrng &lt;- range(economics$unemploy)
p &lt;- p +
  geom_rect(
    aes(NULL, NULL, xmin = start, xmax = end, fill = party),
    ymin = yrng[1], ymax = yrng[2], data = presidential
  )
p
p + scale_fill_manual(values = alpha(c("blue", "red"), .3))

</code></pre>

<hr>
<h2 id='aes_eval'>Control aesthetic evaluation</h2><span id='topic+aes_eval'></span><span id='topic+after_stat'></span><span id='topic+stat'></span><span id='topic+after_scale'></span><span id='topic+stage'></span>

<h3>Description</h3>

<p>Most <a href="#topic+aes">aesthetics</a> are mapped from variables found in the data.
Sometimes, however, you want to delay the mapping until later in the
rendering process. ggplot2 has three stages of the data that you can map
aesthetics from, and three functions to control at which stage aesthetics
should be evaluated.
</p>
<p><code>after_stat()</code> replaces the old approaches of using either <code>stat()</code>, e.g.
<code>stat(density)</code>, or surrounding the variable names with <code>..</code>, e.g.
<code>..density..</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># These functions can be used inside the `aes()` function
# used as the `mapping` argument in layers, for example:
# geom_density(mapping = aes(y = after_stat(scaled)))

after_stat(x)

after_scale(x)

stage(start = NULL, after_stat = NULL, after_scale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes_eval_+3A_x">x</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+topic-data-mask">data-masking</a></code>&gt; An aesthetic expression
using variables calculated by the stat (<code>after_stat()</code>) or layer aesthetics
(<code>after_scale()</code>).</p>
</td></tr>
<tr><td><code id="aes_eval_+3A_start">start</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+topic-data-mask">data-masking</a></code>&gt; An aesthetic
expression using variables from the layer data.</p>
</td></tr>
<tr><td><code id="aes_eval_+3A_after_stat">after_stat</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+topic-data-mask">data-masking</a></code>&gt; An aesthetic
expression using variables calculated by the stat.</p>
</td></tr>
<tr><td><code id="aes_eval_+3A_after_scale">after_scale</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+topic-data-mask">data-masking</a></code>&gt; An aesthetic
expression using layer aesthetics.</p>
</td></tr>
</table>


<h3>Staging</h3>

<p>Below follows an overview of the three stages of evaluation and how aesthetic
evaluation can be controlled.
</p>


<h4>Stage 1: direct input</h4>

<p>The default is to map at the beginning, using the layer data provided by
the user. If you want to map directly from the layer data you should not do
anything special. This is the only stage where the original layer data can
be accessed.
</p>
<div class="sourceCode r"><pre># 'x' and 'y' are mapped directly
ggplot(mtcars) + geom_point(aes(x = mpg, y = disp))
</pre></div>



<h4>Stage 2: after stat transformation</h4>

<p>The second stage is after the data has been transformed by the layer
stat. The most common example of mapping from stat transformed data is the
height of bars in <code><a href="#topic+geom_histogram">geom_histogram()</a></code>: the height does not come from a
variable in the underlying data, but is instead mapped to the <code>count</code>
computed by <code><a href="#topic+stat_bin">stat_bin()</a></code>. In order to map from stat transformed data you
should use the <code>after_stat()</code> function to flag that evaluation of the
aesthetic mapping should be postponed until after stat transformation.
Evaluation after stat transformation will have access to the variables
calculated by the stat, not the original mapped values. The 'computed
variables' section in each stat lists which variables are available to
access.
</p>
<div class="sourceCode r"><pre># The 'y' values for the histogram are computed by the stat
ggplot(faithful, aes(x = waiting)) +
  geom_histogram()

# Choosing a different computed variable to display, matching up the
# histogram with the density plot
ggplot(faithful, aes(x = waiting)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density()
</pre></div>



<h4>Stage 3: after scale transformation</h4>

<p>The third and last stage is after the data has been transformed and
mapped by the plot scales. An example of mapping from scaled data could
be to use a desaturated version of the stroke colour for fill. You should
use <code>after_scale()</code> to flag evaluation of mapping for after data has been
scaled. Evaluation after scaling will only have access to the final
aesthetics of the layer (including non-mapped, default aesthetics).
</p>
<div class="sourceCode r"><pre># The exact colour is known after scale transformation
ggplot(mpg, aes(cty, colour = factor(cyl))) +
  geom_density()

# We re-use colour properties for the fill without a separate fill scale
ggplot(mpg, aes(cty, colour = factor(cyl))) +
  geom_density(aes(fill = after_scale(alpha(colour, 0.3))))
</pre></div>



<h4>Complex staging</h4>

<p>If you want to map the same aesthetic multiple times, e.g. map <code>x</code> to a
data column for the stat, but remap it for the geom, you can use the
<code>stage()</code> function to collect multiple mappings.
</p>
<div class="sourceCode r"><pre># Use stage to modify the scaled fill
ggplot(mpg, aes(class, hwy)) +
  geom_boxplot(aes(fill = stage(class, after_scale = alpha(fill, 0.4))))

# Using data for computing summary, but placing label elsewhere.
# Also, we're making our own computed variable to use for the label.
ggplot(mpg, aes(class, displ)) +
  geom_violin() +
  stat_summary(
    aes(
      y = stage(displ, after_stat = 8),
      label = after_stat(paste(mean, "Â±", sd))
    ),
    geom = "text",
    fun.data = ~ round(data.frame(mean = mean(.x), sd = sd(.x)), 2)
  )
</pre></div>



<h3>Examples</h3>

<pre><code class='language-R'># Default histogram display
ggplot(mpg, aes(displ)) +
  geom_histogram(aes(y = after_stat(count)))

# Scale tallest bin to 1
ggplot(mpg, aes(displ)) +
  geom_histogram(aes(y = after_stat(count / max(count))))

# Use a transparent version of colour for fill
ggplot(mpg, aes(class, hwy)) +
  geom_boxplot(aes(colour = class, fill = after_scale(alpha(colour, 0.4))))

# Use stage to modify the scaled fill
ggplot(mpg, aes(class, hwy)) +
  geom_boxplot(aes(fill = stage(class, after_scale = alpha(fill, 0.4))))

# Making a proportional stacked density plot
ggplot(mpg, aes(cty)) +
  geom_density(
    aes(
      colour = factor(cyl),
      fill = after_scale(alpha(colour, 0.3)),
      y = after_stat(count / sum(n[!duplicated(group)]))
    ),
    position = "stack", bw = 1
  ) +
  geom_density(bw = 1)

# Imitating a ridgeline plot
ggplot(mpg, aes(cty, colour = factor(cyl))) +
  geom_ribbon(
    stat = "density", outline.type = "upper",
    aes(
      fill = after_scale(alpha(colour, 0.3)),
      ymin = after_stat(group),
      ymax = after_stat(group + ndensity)
    )
  )

# Labelling a bar plot
ggplot(mpg, aes(class)) +
  geom_bar() +
  geom_text(
    aes(
      y = after_stat(count + 2),
      label = after_stat(count)
    ),
    stat = "count"
  )

# Labelling the upper hinge of a boxplot,
# inspired by June Choe
ggplot(mpg, aes(displ, class)) +
  geom_boxplot(outlier.shape = NA) +
  geom_text(
    aes(
      label = after_stat(xmax),
      x = stage(displ, after_stat = xmax)
    ),
    stat = "boxplot", hjust = -0.5
  )
</code></pre>

<hr>
<h2 id='aes_group_order'>Aesthetics: grouping</h2><span id='topic+aes_group_order'></span><span id='topic+group'></span>

<h3>Description</h3>

<p>The <code>group</code> aesthetic is by default set to the interaction of all discrete variables
in the plot. This choice often partitions the data correctly, but when it does not,
or when no discrete variable is used in the plot, you will need to explicitly define the
grouping structure by mapping <code>group</code> to a variable that has a different value
for each group.
</p>


<h3>Details</h3>

<p>For most applications the grouping is set implicitly by mapping one or more
discrete variables to <code>x</code>, <code>y</code>, <code>colour</code>, <code>fill</code>, <code>alpha</code>, <code>shape</code>, <code>size</code>,
and/or <code>linetype</code>. This is demonstrated in the examples below.
</p>
<p>There are three common cases where the default does not display the data correctly.
</p>

<ol>
<li> <p><code>geom_line()</code> where there are multiple individuals and the plot tries to
connect every observation, even across individuals, with a line.
</p>
</li>
<li> <p><code>geom_line()</code> where a discrete x-position implies groups, whereas observations
span the discrete x-positions.
</p>
</li>
<li><p> When the grouping needs to be different over different layers, for example
when computing a statistic on all observations when another layer shows
individuals.
</p>
</li></ol>

<p>The examples below use a longitudinal dataset, <code>Oxboys</code>, from the nlme package to demonstrate
these cases. <code>Oxboys</code> records the heights (height) and centered ages (age) of 26 boys (Subject),
measured on nine occasions (Occasion).
</p>


<h3>See Also</h3>


<ul>
<li><p> Geoms commonly used with groups: <code><a href="#topic+geom_bar">geom_bar()</a></code>, <code><a href="#topic+geom_histogram">geom_histogram()</a></code>, <code><a href="#topic+geom_line">geom_line()</a></code>
</p>
</li>
<li><p> Run <code>vignette("ggplot2-specs")</code> to see an overview of other aesthetics that
can be modified.
</p>
</li></ul>

<p>Other aesthetics documentation: 
<code><a href="#topic+aes_colour_fill_alpha">aes_colour_fill_alpha</a></code>,
<code><a href="#topic+aes_linetype_size_shape">aes_linetype_size_shape</a></code>,
<code><a href="#topic+aes_position">aes_position</a></code>,
<code><a href="#topic+aes">aes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

p &lt;- ggplot(mtcars, aes(wt, mpg))
# A basic scatter plot
p + geom_point(size = 4)
# Using the colour aesthetic
p + geom_point(aes(colour = factor(cyl)), size = 4)
# Using the shape aesthetic
p + geom_point(aes(shape = factor(cyl)), size = 4)

# Using fill
p &lt;- ggplot(mtcars, aes(factor(cyl)))
p + geom_bar()
p + geom_bar(aes(fill = factor(cyl)))
p + geom_bar(aes(fill = factor(vs)))

# Using linetypes
ggplot(economics_long, aes(date, value01)) +
  geom_line(aes(linetype = variable))

# Multiple groups with one aesthetic
p &lt;- ggplot(nlme::Oxboys, aes(age, height))
# The default is not sufficient here. A single line tries to connect all
# the observations.
p + geom_line()
# To fix this, use the group aesthetic to map a different line for each
# subject.
p + geom_line(aes(group = Subject))

# Different groups on different layers
p &lt;- p + geom_line(aes(group = Subject))
# Using the group aesthetic with both geom_line() and geom_smooth()
# groups the data the same way for both layers
p + geom_smooth(aes(group = Subject), method = "lm", se = FALSE)
# Changing the group aesthetic for the smoother layer
# fits a single line of best fit across all boys
p + geom_smooth(aes(group = 1), size = 2, method = "lm", se = FALSE)

# Overriding the default grouping
# Sometimes the plot has a discrete scale but you want to draw lines
# that connect across groups. This is the strategy used in interaction
# plots, profile plots, and parallel coordinate plots, among others.
# For example, we draw boxplots of height at each measurement occasion.
p &lt;- ggplot(nlme::Oxboys, aes(Occasion, height)) + geom_boxplot()
p
# There is no need to specify the group aesthetic here; the default grouping
# works because occasion is a discrete variable. To overlay individual
# trajectories, we again need to override the default grouping for that layer
# with aes(group = Subject)
p + geom_line(aes(group = Subject), colour = "blue")

</code></pre>

<hr>
<h2 id='aes_linetype_size_shape'>Differentiation related aesthetics: linetype, size, shape</h2><span id='topic+aes_linetype_size_shape'></span><span id='topic+linetype'></span><span id='topic+size'></span><span id='topic+shape'></span>

<h3>Description</h3>

<p>The <code>linetype</code>, <code>linewidth</code>, <code>size</code>, and <code>shape</code> aesthetics modify the
appearance of lines and/or points. They also apply to the outlines of
polygons (<code>linetype</code> and <code>linewidth</code>) or to text (<code>size</code>).
</p>


<h3>Linetype</h3>

<p>The <code>linetype</code> aesthetic can be specified with either an integer (0-6), a
name (0 = blank, 1 = solid, 2 = dashed, 3 = dotted, 4 = dotdash, 5 = longdash,
6 = twodash), a mapping to a discrete variable, or a string of an even number
(up to eight) of hexadecimal digits which give the lengths in consecutive
positions in the string. See examples for a hex string demonstration.
</p>


<h3>Linewidth and stroke</h3>

<p>The <code>linewidth</code> aesthetic sets the widths of lines, and can be specified
with a numeric value (for historical reasons, these units are about 0.75
millimetres). Alternatively, they can also be set via mapping to a continuous
variable. The <code>stroke</code> aesthetic serves the same role for points, but is
distinct for discriminating points from lines in geoms such as
<code><a href="#topic+geom_pointrange">geom_pointrange()</a></code>.
</p>


<h3>Size</h3>

<p>The <code>size</code> aesthetic control the size of points and text, and can be
specified with a numerical value (in millimetres) or via a mapping to a
continuous variable.
</p>


<h3>Shape</h3>

<p>The <code>shape</code> aesthetic controls the symbols of points, and can be specified
with an integer (between 0 and 25), a single character (which uses that
character as the plotting symbol), a <code>.</code> to draw the smallest rectangle that
is visible (i.e., about one pixel), an <code>NA</code> to draw nothing, or a mapping to
a discrete variable. Symbols and filled shapes are described in the examples
below.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+geom_line">geom_line()</a></code> and <code><a href="#topic+geom_point">geom_point()</a></code> for geoms commonly used
with these aesthetics.
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">aes_group_order()</a></code> for using <code>linetype</code>, <code>size</code>, or
<code>shape</code> for grouping.
</p>
</li>
<li><p> Scales that can be used to modify these aesthetics: <code><a href="#topic+scale_linetype">scale_linetype()</a></code>,
<code><a href="#topic+scale_linewidth">scale_linewidth()</a></code>, <code><a href="#topic+scale_size">scale_size()</a></code>, and <code><a href="#topic+scale_shape">scale_shape()</a></code>.
</p>
</li>
<li><p> Run <code>vignette("ggplot2-specs")</code> to see an overview of other aesthetics that
can be modified.
</p>
</li></ul>

<p>Other aesthetics documentation: 
<code><a href="#topic+aes_colour_fill_alpha">aes_colour_fill_alpha</a></code>,
<code><a href="#topic+aes_group_order">aes_group_order</a></code>,
<code><a href="#topic+aes_position">aes_position</a></code>,
<code><a href="#topic+aes">aes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(x = 1:10 , y = 1:10)
p &lt;- ggplot(df, aes(x, y))
p + geom_line(linetype = 2)
p + geom_line(linetype = "dotdash")

# An example with hex strings; the string "33" specifies three units on followed
# by three off and "3313" specifies three units on followed by three off followed
# by one on and finally three off.
p + geom_line(linetype = "3313")

# Mapping line type from a grouping variable
ggplot(economics_long, aes(date, value01)) +
  geom_line(aes(linetype = variable))

# Linewidth examples
ggplot(economics, aes(date, unemploy)) +
  geom_line(linewidth = 2, lineend = "round")
ggplot(economics, aes(date, unemploy)) +
  geom_line(aes(linewidth = uempmed), lineend = "round")

# Size examples
p &lt;- ggplot(mtcars, aes(wt, mpg))
p + geom_point(size = 4)
p + geom_point(aes(size = qsec))
p + geom_point(size = 2.5) +
  geom_hline(yintercept = 25, size = 3.5)

# Shape examples
p + geom_point()
p + geom_point(shape = 5)
p + geom_point(shape = "k", size = 3)
p + geom_point(shape = ".")
p + geom_point(shape = NA)
p + geom_point(aes(shape = factor(cyl)))

# A look at all 25 symbols
df2 &lt;- data.frame(x = 1:5 , y = 1:25, z = 1:25)
p &lt;- ggplot(df2, aes(x, y))
p + geom_point(aes(shape = z), size = 4) +
  scale_shape_identity()
# While all symbols have a foreground colour, symbols 19-25 also take a
# background colour (fill)
p + geom_point(aes(shape = z), size = 4, colour = "Red") +
  scale_shape_identity()
p + geom_point(aes(shape = z), size = 4, colour = "Red", fill = "Black") +
  scale_shape_identity()
</code></pre>

<hr>
<h2 id='aes_position'>Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend</h2><span id='topic+aes_position'></span><span id='topic+x'></span><span id='topic+y'></span><span id='topic+xmin'></span><span id='topic+xmax'></span><span id='topic+ymin'></span><span id='topic+ymax'></span><span id='topic+xend'></span><span id='topic+yend'></span>

<h3>Description</h3>

<p>The following aesthetics can be used to specify the position of elements:
<code>x</code>, <code>y</code>, <code>xmin</code>, <code>xmax</code>, <code>ymin</code>, <code>ymax</code>, <code>xend</code>, <code>yend</code>.
</p>


<h3>Details</h3>

<p><code>x</code> and <code>y</code> define the locations of points or of positions along a line
or path.
</p>
<p><code>x</code>, <code>y</code> and <code>xend</code>, <code>yend</code> define the starting and ending points of
segment and curve geometries.
</p>
<p><code>xmin</code>, <code>xmax</code>, <code>ymin</code>  and <code>ymax</code> can be used to specify the position of
annotations and to represent rectangular areas.
</p>
<p>In addition, there are position aesthetics that are contextual to the
geometry that they're used in. These are <code>xintercept</code>, <code>yintercept</code>,
<code>xmin_final</code>, <code>ymin_final</code>, <code>xmax_final</code>, <code>ymax_final</code>, <code>xlower</code>, <code>lower</code>,
<code>xmiddle</code>, <code>middle</code>, <code>xupper</code>, <code>upper</code>, <code>x0</code> and <code>y0</code>. Many of these are used
and automatically computed in <code><a href="#topic+geom_boxplot">geom_boxplot()</a></code>.
</p>


<h3>See Also</h3>


<ul>
<li><p> Geoms that commonly use these aesthetics: <code><a href="#topic+geom_crossbar">geom_crossbar()</a></code>,
<code><a href="#topic+geom_curve">geom_curve()</a></code>, <code><a href="#topic+geom_errorbar">geom_errorbar()</a></code>, <code><a href="#topic+geom_line">geom_line()</a></code>, <code><a href="#topic+geom_linerange">geom_linerange()</a></code>,
<code><a href="#topic+geom_path">geom_path()</a></code>, <code><a href="#topic+geom_point">geom_point()</a></code>, <code><a href="#topic+geom_pointrange">geom_pointrange()</a></code>, <code><a href="#topic+geom_rect">geom_rect()</a></code>,
<code><a href="#topic+geom_segment">geom_segment()</a></code>
</p>
</li>
<li><p> Scales that can be used to modify positions:
<code><a href="#topic+scale_x_continuous">scale_continuous()</a></code>,
<code><a href="#topic+scale_x_discrete">scale_discrete()</a></code>,
<code><a href="#topic+scale_x_binned">scale_binned()</a></code>,
<code><a href="#topic+scale_x_date">scale_date()</a></code>.
</p>
</li>
<li><p> See also <code><a href="#topic+annotate">annotate()</a></code> for placing annotations.
</p>
</li></ul>

<p>Other aesthetics documentation: 
<code><a href="#topic+aes_colour_fill_alpha">aes_colour_fill_alpha</a></code>,
<code><a href="#topic+aes_group_order">aes_group_order</a></code>,
<code><a href="#topic+aes_linetype_size_shape">aes_linetype_size_shape</a></code>,
<code><a href="#topic+aes">aes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate data: means and standard errors of means for prices
# for each type of cut
dmod &lt;- lm(price ~ cut, data = diamonds)
cut &lt;- unique(diamonds$cut)
cuts_df &lt;- data.frame(
  cut,
  predict(dmod, data.frame(cut), se = TRUE)[c("fit", "se.fit")]
)
ggplot(cuts_df) +
  aes(
   x = cut,
   y = fit,
   ymin = fit - se.fit,
   ymax = fit + se.fit,
   colour = cut
  ) +
  geom_pointrange()

# Using annotate
p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p
p + annotate(
  "rect", xmin = 2, xmax = 3.5, ymin = 2, ymax = 25,
  fill = "dark grey", alpha = .5
)

# Geom_segment examples
p + geom_segment(
  aes(x = 2, y = 15, xend = 2, yend = 25),
  arrow = arrow(length = unit(0.5, "cm"))
)
p + geom_segment(
  aes(x = 2, y = 15, xend = 3, yend = 15),
  arrow = arrow(length = unit(0.5, "cm"))
)
p + geom_segment(
  aes(x = 5, y = 30, xend = 3.5, yend = 25),
  arrow = arrow(length = unit(0.5, "cm"))
)

# You can also use geom_segment() to recreate plot(type = "h")
# from base R:
set.seed(1)
counts &lt;- as.data.frame(table(x = rpois(100, 5)))
counts$x &lt;- as.numeric(as.character(counts$x))
with(counts, plot(x, Freq, type = "h", lwd = 10))

ggplot(counts, aes(x = x, y = Freq)) +
  geom_segment(aes(yend = 0, xend = x), size = 10)
</code></pre>

<hr>
<h2 id='annotate'>Create an annotation layer</h2><span id='topic+annotate'></span>

<h3>Description</h3>

<p>This function adds geoms to a plot, but unlike a typical geom function,
the properties of the geoms are not mapped from variables of a data frame,
but are instead passed in as vectors. This is useful for adding small annotations
(such as text labels) or if you have your data in vectors, and for some
reason don't want to put them in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate(
  geom,
  x = NULL,
  y = NULL,
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL,
  xend = NULL,
  yend = NULL,
  ...,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_+3A_geom">geom</code></td>
<td>
<p>name of geom to use for annotation</p>
</td></tr>
<tr><td><code id="annotate_+3A_x">x</code>, <code id="annotate_+3A_y">y</code>, <code id="annotate_+3A_xmin">xmin</code>, <code id="annotate_+3A_ymin">ymin</code>, <code id="annotate_+3A_xmax">xmax</code>, <code id="annotate_+3A_ymax">ymax</code>, <code id="annotate_+3A_xend">xend</code>, <code id="annotate_+3A_yend">yend</code></td>
<td>
<p>positioning aesthetics -
you must specify at least one of these.</p>
</td></tr>
<tr><td><code id="annotate_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="annotate_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all position aesthetics are scaled (i.e. they will expand the
limits of the plot so they are visible), but all other aesthetics are
set. This means that layers created with this function will never
affect the legend.
</p>


<h3>Unsupported geoms</h3>

<p>Due to their special nature, reference line geoms <code><a href="#topic+geom_abline">geom_abline()</a></code>,
<code><a href="#topic+geom_hline">geom_hline()</a></code>, and <code><a href="#topic+geom_vline">geom_vline()</a></code> can't be used with <code>annotate()</code>.
You can use these geoms directly for annotations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate("text", x = 4, y = 25, label = "Some text")
p + annotate("text", x = 2:5, y = 25, label = "Some text")
p + annotate("rect", xmin = 3, xmax = 4.2, ymin = 12, ymax = 21,
  alpha = .2)
p + annotate("segment", x = 2.5, xend = 4, y = 15, yend = 25,
  colour = "blue")
p + annotate("pointrange", x = 3.5, y = 20, ymin = 12, ymax = 28,
  colour = "red", size = 2.5, linewidth = 1.5)

p + annotate("text", x = 2:3, y = 20:21, label = c("my label", "label 2"))

p + annotate("text", x = 4, y = 25, label = "italic(R) ^ 2 == 0.75",
  parse = TRUE)
p + annotate("text", x = 4, y = 25,
  label = "paste(italic(R) ^ 2, \" = .75\")", parse = TRUE)
</code></pre>

<hr>
<h2 id='annotation_custom'>Annotation: Custom grob</h2><span id='topic+annotation_custom'></span>

<h3>Description</h3>

<p>This is a special geom intended for use as static annotations
that are the same in every panel. These annotations will not
affect scales (i.e. the x and y axes will not grow to cover the range
of the grob, and the grob will not be modified by any ggplot settings
or mappings).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_custom(grob, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation_custom_+3A_grob">grob</code></td>
<td>
<p>grob to display</p>
</td></tr>
<tr><td><code id="annotation_custom_+3A_xmin">xmin</code>, <code id="annotation_custom_+3A_xmax">xmax</code></td>
<td>
<p>x location (in data coordinates) giving horizontal
location of raster</p>
</td></tr>
<tr><td><code id="annotation_custom_+3A_ymin">ymin</code>, <code id="annotation_custom_+3A_ymax">ymax</code></td>
<td>
<p>y location (in data coordinates) giving vertical
location of raster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most useful for adding tables, inset plots, and other grid-based decorations.
</p>


<h3>Note</h3>

<p><code>annotation_custom()</code> expects the grob to fill the entire viewport
defined by xmin, xmax, ymin, ymax. Grobs with a different (absolute) size
will be center-justified in that region.
Inf values can be used to fill the full plot panel (see examples).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Dummy plot
df &lt;- data.frame(x = 1:10, y = 1:10)
base &lt;- ggplot(df, aes(x, y)) +
  geom_blank() +
  theme_bw()

# Full panel annotation
base + annotation_custom(
  grob = grid::roundrectGrob(),
  xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
)

# Inset plot
df2 &lt;- data.frame(x = 1 , y = 1)
g &lt;- ggplotGrob(ggplot(df2, aes(x, y)) +
  geom_point() +
  theme(plot.background = element_rect(colour = "black")))
base +
  annotation_custom(grob = g, xmin = 1, xmax = 10, ymin = 8, ymax = 10)
</code></pre>

<hr>
<h2 id='annotation_logticks'>Annotation: log tick marks</h2><span id='topic+annotation_logticks'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>This function is superseded by using <code><a href="#topic+guide_axis_logticks">guide_axis_logticks()</a></code>.
</p>
<p>This annotation adds log tick marks with diminishing spacing.
These tick marks probably make sense only for base 10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_logticks(
  base = 10,
  sides = "bl",
  outside = FALSE,
  scaled = TRUE,
  short = unit(0.1, "cm"),
  mid = unit(0.2, "cm"),
  long = unit(0.3, "cm"),
  colour = "black",
  linewidth = 0.5,
  linetype = 1,
  alpha = 1,
  color = NULL,
  ...,
  size = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation_logticks_+3A_base">base</code></td>
<td>
<p>the base of the log (default 10)</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_sides">sides</code></td>
<td>
<p>a string that controls which sides of the plot the log ticks appear on.
It can be set to a string containing any of <code>"trbl"</code>, for top, right,
bottom, and left.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_outside">outside</code></td>
<td>
<p>logical that controls whether to move the log ticks outside
of the plot area. Default is off (<code>FALSE</code>). You will also need to use
<code>coord_cartesian(clip = "off")</code>. See examples.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_scaled">scaled</code></td>
<td>
<p>is the data already log-scaled? This should be <code>TRUE</code>
(default) when the data is already transformed with <code>log10()</code> or when
using <code>scale_y_log10()</code>. It should be <code>FALSE</code> when using
<code>coord_trans(y = "log10")</code>.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_short">short</code></td>
<td>
<p>a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object specifying the length of the
short tick marks</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_mid">mid</code></td>
<td>
<p>a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object specifying the length of the
middle tick marks. In base 10, these are the &quot;5&quot; ticks.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_long">long</code></td>
<td>
<p>a <code><a href="grid.html#topic+unit">grid::unit()</a></code> object specifying the length of the
long tick marks. In base 10, these are the &quot;1&quot; (or &quot;10&quot;) ticks.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_colour">colour</code></td>
<td>
<p>Colour of the tick marks.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_linewidth">linewidth</code></td>
<td>
<p>Thickness of tick marks, in mm.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_linetype">linetype</code></td>
<td>
<p>Linetype of tick marks (<code>solid</code>, <code>dashed</code>, etc.)</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_alpha">alpha</code></td>
<td>
<p>The transparency of the tick marks.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_color">color</code></td>
<td>
<p>An alias for <code>colour</code>.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to the layer</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_size">size</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+scale_y_continuous">scale_y_continuous()</a></code>, <code><a href="#topic+scale_y_log10">scale_y_log10()</a></code> for log scale
transformations.
</p>
<p><code><a href="#topic+coord_trans">coord_trans()</a></code> for log coordinate transformations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a log-log plot (without log ticks)
a &lt;- ggplot(msleep, aes(bodywt, brainwt)) +
 geom_point(na.rm = TRUE) +
 scale_x_log10(
   breaks = scales::trans_breaks("log10", function(x) 10^x),
   labels = scales::trans_format("log10", scales::math_format(10^.x))
 ) +
 scale_y_log10(
   breaks = scales::trans_breaks("log10", function(x) 10^x),
   labels = scales::trans_format("log10", scales::math_format(10^.x))
 ) +
 theme_bw()

a + annotation_logticks()                # Default: log ticks on bottom and left
a + annotation_logticks(sides = "lr")    # Log ticks for y, on left and right
a + annotation_logticks(sides = "trbl")  # All four sides

a + annotation_logticks(sides = "lr", outside = TRUE) +
 coord_cartesian(clip = "off")  # Ticks outside plot

# Hide the minor grid lines because they don't align with the ticks
a + annotation_logticks(sides = "trbl") + theme(panel.grid.minor = element_blank())

# Another way to get the same results as 'a' above: log-transform the data before
# plotting it. Also hide the minor grid lines.
b &lt;- ggplot(msleep, aes(log10(bodywt), log10(brainwt))) +
 geom_point(na.rm = TRUE) +
 scale_x_continuous(name = "body", labels = scales::label_math(10^.x)) +
 scale_y_continuous(name = "brain", labels = scales::label_math(10^.x)) +
 theme_bw() + theme(panel.grid.minor = element_blank())

b + annotation_logticks()

# Using a coordinate transform requires scaled = FALSE
t &lt;- ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  coord_trans(x = "log10", y = "log10") +
  theme_bw()
t + annotation_logticks(scaled = FALSE)

# Change the length of the ticks
a + annotation_logticks(
  short = unit(.5,"mm"),
  mid = unit(3,"mm"),
  long = unit(4,"mm")
)
</code></pre>

<hr>
<h2 id='annotation_map'>Annotation: a map</h2><span id='topic+annotation_map'></span>

<h3>Description</h3>

<p>Display a fixed map on a plot. This function predates the <code><a href="#topic+geom_sf">geom_sf()</a></code>
framework and does not work with sf geometry columns as input. However,
it can be used in conjunction with <code>geom_sf()</code> layers and/or
<code><a href="#topic+coord_sf">coord_sf()</a></code> (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_map(map, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation_map_+3A_map">map</code></td>
<td>
<p>Data frame representing a map. See <code><a href="#topic+geom_map">geom_map()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="annotation_map_+3A_...">...</code></td>
<td>
<p>Other arguments used to modify visual parameters, such as
<code>colour</code> or <code>fill</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("maps", quietly = TRUE)) {
# location of cities in North Carolina
df &lt;- data.frame(
  name = c("Charlotte", "Raleigh", "Greensboro"),
  lat = c(35.227, 35.772, 36.073),
  long = c(-80.843, -78.639, -79.792)
)

p &lt;- ggplot(df, aes(x = long, y = lat)) +
  annotation_map(
    map_data("state"),
    fill = "antiquewhite", colour = "darkgrey"
  ) +
  geom_point(color = "blue") +
  geom_text(
    aes(label = name),
    hjust = 1.105, vjust = 1.05, color = "blue"
  )

# use without coord_sf() is possible but not recommended
p + xlim(-84, -76) + ylim(34, 37.2)

if (requireNamespace("sf", quietly = TRUE)) {
# use with coord_sf() for appropriate projection
p +
  coord_sf(
    crs = sf::st_crs(3347),
    default_crs = sf::st_crs(4326),  # data is provided as long-lat
    xlim = c(-84, -76),
    ylim = c(34, 37.2)
  )

# you can mix annotation_map() and geom_sf()
nc &lt;- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
p +
  geom_sf(
    data = nc, inherit.aes = FALSE,
    fill = NA, color = "black", linewidth = 0.1
  ) +
  coord_sf(crs = sf::st_crs(3347), default_crs = sf::st_crs(4326))
}}
## End(Not run)
</code></pre>

<hr>
<h2 id='annotation_raster'>Annotation: high-performance rectangular tiling</h2><span id='topic+annotation_raster'></span>

<h3>Description</h3>

<p>This is a special version of <code><a href="#topic+geom_raster">geom_raster()</a></code> optimised for static
annotations that are the same in every panel. These annotations will not
affect scales (i.e. the x and y axes will not grow to cover the range
of the raster, and the raster must already have its own colours). This
is useful for adding bitmap images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_raster(raster, xmin, xmax, ymin, ymax, interpolate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation_raster_+3A_raster">raster</code></td>
<td>
<p>raster object to display, may be an <code>array</code> or a <code>nativeRaster</code></p>
</td></tr>
<tr><td><code id="annotation_raster_+3A_xmin">xmin</code>, <code id="annotation_raster_+3A_xmax">xmax</code></td>
<td>
<p>x location (in data coordinates) giving horizontal
location of raster</p>
</td></tr>
<tr><td><code id="annotation_raster_+3A_ymin">ymin</code>, <code id="annotation_raster_+3A_ymax">ymax</code></td>
<td>
<p>y location (in data coordinates) giving vertical
location of raster</p>
</td></tr>
<tr><td><code id="annotation_raster_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
rainbow &lt;- matrix(hcl(seq(0, 360, length.out = 50 * 50), 80, 70), nrow = 50)
ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  annotation_raster(rainbow, 15, 20, 3, 4)
# To fill up whole plot
ggplot(mtcars, aes(mpg, wt)) +
  annotation_raster(rainbow, -Inf, Inf, -Inf, Inf) +
  geom_point()

rainbow2 &lt;- matrix(hcl(seq(0, 360, length.out = 10), 80, 70), nrow = 1)
ggplot(mtcars, aes(mpg, wt)) +
  annotation_raster(rainbow2, -Inf, Inf, -Inf, Inf) +
  geom_point()
rainbow2 &lt;- matrix(hcl(seq(0, 360, length.out = 10), 80, 70), nrow = 1)
ggplot(mtcars, aes(mpg, wt)) +
  annotation_raster(rainbow2, -Inf, Inf, -Inf, Inf, interpolate = TRUE) +
  geom_point()
</code></pre>

<hr>
<h2 id='as_labeller'>Coerce to labeller function</h2><span id='topic+as_labeller'></span>

<h3>Description</h3>

<p>This transforms objects to labeller functions. Used internally by
<code><a href="#topic+labeller">labeller()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_labeller(x, default = label_value, multi_line = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_labeller_+3A_x">x</code></td>
<td>
<p>Object to coerce to a labeller function. If a named
character vector, it is used as a lookup table before being
passed on to <code>default</code>. If a non-labeller function, it is
assumed it takes and returns character vectors and is applied to
the labels. If a labeller, it is simply applied to the labels.</p>
</td></tr>
<tr><td><code id="as_labeller_+3A_default">default</code></td>
<td>
<p>Default labeller to process the labels produced by
lookup tables or modified by non-labeller functions.</p>
</td></tr>
<tr><td><code id="as_labeller_+3A_multi_line">multi_line</code></td>
<td>
<p>Whether to display the labels of multiple factors
on separate lines. This is passed to the labeller function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+labeller">labeller()</a></code>, <a href="#topic+labellers">labellers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(disp, drat)) + geom_point()
p + facet_wrap(~am)

# Rename labels on the fly with a lookup character vector
to_string &lt;- as_labeller(c(`0` = "Zero", `1` = "One"))
p + facet_wrap(~am, labeller = to_string)

# Quickly transform a function operating on character vectors to a
# labeller function:
appender &lt;- function(string, suffix = "-foo") paste0(string, suffix)
p + facet_wrap(~am, labeller = as_labeller(appender))

# If you have more than one faceting variable, be sure to dispatch
# your labeller to the right variable with labeller()
p + facet_grid(cyl ~ am, labeller = labeller(am = to_string))
</code></pre>

<hr>
<h2 id='as.list.ggproto'>Convert a ggproto object to a list</h2><span id='topic+as.list.ggproto'></span>

<h3>Description</h3>

<p>This will not include the object's <code>super</code> member.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggproto'
as.list(x, inherit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.ggproto_+3A_x">x</code></td>
<td>
<p>A ggproto object to convert to a list.</p>
</td></tr>
<tr><td><code id="as.list.ggproto_+3A_inherit">inherit</code></td>
<td>
<p>If <code>TRUE</code> (the default), flatten all inherited items into
the returned list. If <code>FALSE</code>, do not include any inherited items.</p>
</td></tr>
<tr><td><code id="as.list.ggproto_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+list">base::as.list.environment</a></code>
</p>

<dl>
<dt><code>all.names</code></dt><dd><p>a logical indicating whether to copy all values or
(default) only those whose names do not begin with a dot.</p>
</dd>
<dt><code>sorted</code></dt><dd><p>a logical indicating whether the <code><a href="base.html#topic+names">names</a></code> of
the resulting list should be sorted (increasingly).  Note that this
is somewhat costly, but may be useful for comparison of environments.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='autolayer'>Create a ggplot layer appropriate to a particular data type</h2><span id='topic+autolayer'></span>

<h3>Description</h3>

<p><code>autolayer()</code> uses ggplot2 to draw a particular layer for an object of a
particular class in a single command. This defines the S3 generic that
other classes and packages can extend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autolayer(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autolayer_+3A_object">object</code></td>
<td>
<p>an object, whose class will determine the behaviour of autolayer</p>
</td></tr>
<tr><td><code id="autolayer_+3A_...">...</code></td>
<td>
<p>other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot layer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoplot">autoplot()</a></code>, <code><a href="#topic+ggplot">ggplot()</a></code> and <code><a href="#topic+fortify">fortify()</a></code>
</p>

<hr>
<h2 id='autoplot'>Create a complete ggplot appropriate to a particular data type</h2><span id='topic+autoplot'></span>

<h3>Description</h3>

<p><code>autoplot()</code> uses ggplot2 to draw a particular plot for an object of a
particular class in a single command. This defines the S3 generic that
other classes and packages can extend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot_+3A_object">object</code></td>
<td>
<p>an object, whose class will determine the behaviour of autoplot</p>
</td></tr>
<tr><td><code id="autoplot_+3A_...">...</code></td>
<td>
<p>other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autolayer">autolayer()</a></code>, <code><a href="#topic+ggplot">ggplot()</a></code> and <code><a href="#topic+fortify">fortify()</a></code>
</p>

<hr>
<h2 id='benchplot'>Benchmark plot creation time.
Broken down into construct, build, render and draw times.</h2><span id='topic+benchplot'></span>

<h3>Description</h3>

<p>Benchmark plot creation time.
Broken down into construct, build, render and draw times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchplot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="benchplot_+3A_x">x</code></td>
<td>
<p>code to create ggplot2 plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>benchplot(ggplot(mtcars, aes(mpg, wt)) + geom_point())
benchplot(ggplot(mtcars, aes(mpg, wt)) + geom_point() + facet_grid(. ~ cyl))

# With tidy eval:
p &lt;- expr(ggplot(mtcars, aes(mpg, wt)) + geom_point())
benchplot(!!p)
</code></pre>

<hr>
<h2 id='bidirection'>Utilities for working with bidirectional layers</h2><span id='topic+bidirection'></span><span id='topic+has_flipped_aes'></span><span id='topic+flip_data'></span><span id='topic+flipped_names'></span>

<h3>Description</h3>

<p>These functions are what underpins the ability of certain geoms to work
automatically in both directions. See the <em>Extending ggplot2</em> vignette for
how they are used when implementing <code>Geom</code>, <code>Stat</code>, and <code>Position</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_flipped_aes(
  data,
  params = list(),
  main_is_orthogonal = NA,
  range_is_orthogonal = NA,
  group_has_equal = FALSE,
  ambiguous = FALSE,
  main_is_continuous = FALSE,
  main_is_optional = FALSE
)

flip_data(data, flip = NULL)

flipped_names(flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bidirection_+3A_data">data</code></td>
<td>
<p>The layer data</p>
</td></tr>
<tr><td><code id="bidirection_+3A_params">params</code></td>
<td>
<p>The parameters of the <code>Stat</code>/<code>Geom</code>. Only the <code>orientation</code>
parameter will be used.</p>
</td></tr>
<tr><td><code id="bidirection_+3A_main_is_orthogonal">main_is_orthogonal</code></td>
<td>
<p>If only <code>x</code> or <code>y</code> are present do they correspond
to the main orientation or the reverse. E.g. If <code>TRUE</code> and <code>y</code> is present
it is not flipped. If <code>NA</code> this check will be ignored.</p>
</td></tr>
<tr><td><code id="bidirection_+3A_range_is_orthogonal">range_is_orthogonal</code></td>
<td>
<p>If <code>xmin</code>/<code>xmax</code> or <code>ymin</code>/<code>ymax</code> is present do
they correspond to the main orientation or reverse. If <code>NA</code> this check will
be ignored.</p>
</td></tr>
<tr><td><code id="bidirection_+3A_group_has_equal">group_has_equal</code></td>
<td>
<p>Is it expected that grouped data has either a single
<code>x</code> or <code>y</code> value that will correspond to the orientation.</p>
</td></tr>
<tr><td><code id="bidirection_+3A_ambiguous">ambiguous</code></td>
<td>
<p>Is the layer ambiguous in its mapping by nature. If so, it
will only be flipped if <code>params$orientation == "y"</code></p>
</td></tr>
<tr><td><code id="bidirection_+3A_main_is_continuous">main_is_continuous</code></td>
<td>
<p>If there is a discrete and continuous axis, does
the continuous one correspond to the main orientation?</p>
</td></tr>
<tr><td><code id="bidirection_+3A_main_is_optional">main_is_optional</code></td>
<td>
<p>Is the main axis aesthetic optional and, if not
given, set to <code>0</code></p>
</td></tr>
<tr><td><code id="bidirection_+3A_flip">flip</code></td>
<td>
<p>Logical. Is the layer flipped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>has_flipped_aes()</code> is used to sniff out the orientation of the layer from
the data. It has a range of arguments that can be used to finetune the
sniffing based on what the data should look like. <code>flip_data()</code> will switch
the column names of the data so that it looks like x-oriented data.
<code>flipped_names()</code> provides a named list of aesthetic names that corresponds
to the orientation of the layer.
</p>


<h3>Value</h3>

<p><code>has_flipped_aes()</code> returns <code>TRUE</code> if it detects a layer in the other
orientation and <code>FALSE</code> otherwise. <code>flip_data()</code> will return the input
unchanged if <code>flip = FALSE</code> and the data with flipped aesthetic names if
<code>flip = TRUE</code>. <code>flipped_names()</code> returns a named list of strings. If
<code>flip = FALSE</code> the name of the element will correspond to the element, e.g.
<code>flipped_names(FALSE)$x == "x"</code> and if <code>flip = TRUE</code> it will correspond to
the flipped name, e.g. <code>flipped_names(FALSE)$x == "y"</code>
</p>


<h3>Controlling the sniffing</h3>

<p>How the layer data should be interpreted depends on its specific features.
<code>has_flipped_aes()</code> contains a range of flags for defining what certain
features in the data correspond to:
</p>

<ul>
<li> <p><code>main_is_orthogonal</code>: This argument controls how the existence of only a <code>x</code>
or <code>y</code> aesthetic is understood. If <code>TRUE</code> then the existing aesthetic
would be then secondary axis. This behaviour is present in <code><a href="#topic+stat_ydensity">stat_ydensity()</a></code>
and <code><a href="#topic+stat_boxplot">stat_boxplot()</a></code>. If <code>FALSE</code> then the existing aesthetic is the main
axis as seen in e.g. <code><a href="#topic+stat_bin">stat_bin()</a></code>, <code><a href="#topic+geom_count">geom_count()</a></code>, and <code><a href="#topic+stat_density">stat_density()</a></code>.
</p>
</li>
<li> <p><code>range_is_orthogonal</code>: This argument controls whether the existence of
range-like aesthetics (e.g. <code>xmin</code> and <code>xmax</code>) represents the main or
secondary axis. If <code>TRUE</code> then the range is given for the secondary axis as
seen in e.g. <code><a href="#topic+geom_ribbon">geom_ribbon()</a></code> and <code><a href="#topic+geom_linerange">geom_linerange()</a></code>.
</p>
</li>
<li> <p><code>group_has_equal</code>: This argument controls whether to test for equality of
all <code>x</code> and <code>y</code> values inside each group and set the main axis to the one
where all is equal. This test is only performed if <code>TRUE</code>, and only after
less computationally heavy tests has come up empty handed. Examples are
<code><a href="#topic+stat_boxplot">stat_boxplot()</a></code> and <a href="#topic+stat_ydensity">stat_ydensity</a>
</p>
</li>
<li> <p><code>ambiguous</code>: This argument tells the function that the layer, while
bidirectional, doesn't treat each axis differently. It will circumvent any
data based guessing and only take hint from the <code>orientation</code> element in
<code>params</code>. If this is not present it will fall back to <code>FALSE</code>. Examples are
<code><a href="#topic+geom_line">geom_line()</a></code> and <code><a href="#topic+geom_area">geom_area()</a></code>
</p>
</li>
<li> <p><code>main_is_continuous</code>: This argument controls how the test for discreteness
in the scales should be interpreted. If <code>TRUE</code> then the main axis will be
the one which is not discrete-like. Conversely, if <code>FALSE</code> the main axis
will be the discrete-like one. Examples of <code>TRUE</code> is <code><a href="#topic+stat_density">stat_density()</a></code> and
<code><a href="#topic+stat_bin">stat_bin()</a></code>, while examples of <code>FALSE</code> is <code><a href="#topic+stat_ydensity">stat_ydensity()</a></code> and
<code><a href="#topic+stat_boxplot">stat_boxplot()</a></code>
</p>
</li>
<li> <p><code>main_is_optional</code>: This argument controls the rare case of layers were the
main direction is an optional aesthetic. This is only seen in
<code><a href="#topic+stat_boxplot">stat_boxplot()</a></code> where <code>x</code> is set to <code>0</code> if not given. If <code>TRUE</code> there will
be a check for whether all <code>x</code> or all <code>y</code> are equal to <code>0</code>
</p>
</li></ul>


<hr>
<h2 id='binned_scale'>Binning scale constructor</h2><span id='topic+binned_scale'></span>

<h3>Description</h3>

<p>Binning scale constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binned_scale(
  aesthetics,
  scale_name = deprecated(),
  palette,
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  rescaler = rescale,
  oob = squish,
  expand = waiver(),
  na.value = NA_real_,
  n.breaks = NULL,
  nice.breaks = TRUE,
  right = TRUE,
  transform = "identity",
  trans = deprecated(),
  show.limits = FALSE,
  guide = "bins",
  position = "left",
  call = caller_call(),
  super = ScaleBinned
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binned_scale_+3A_aesthetics">aesthetics</code></td>
<td>
<p>The names of the aesthetics that this scale works with.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_scale_name">scale_name</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_palette">palette</code></td>
<td>
<p>A palette function that when called with a numeric vector with
values between 0 and 1 returns the corresponding output values
(e.g., <code><a href="scales.html#topic+pal_area">scales::pal_area()</a></code>).</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="binned_scale_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="binned_scale_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="binned_scale_+3A_rescaler">rescaler</code></td>
<td>
<p>A function used to scale the input values to the
range [0, 1]. This is always <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>, except for
diverging and n colour gradients (i.e., <code><a href="#topic+scale_colour_gradient2">scale_colour_gradient2()</a></code>,
<code><a href="#topic+scale_colour_gradientn">scale_colour_gradientn()</a></code>). The <code>rescaler</code> is ignored by position
scales, which always use <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>. Also accepts rlang
<a href="rlang.html#topic+as_function">lambda</a> function notation.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="binned_scale_+3A_expand">expand</code></td>
<td>
<p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_n.breaks">n.breaks</code></td>
<td>
<p>The number of break points to create if breaks are not given
directly.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_nice.breaks">nice.breaks</code></td>
<td>
<p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_right">right</code></td>
<td>
<p>Should the intervals be closed on the right (<code>TRUE</code>, default) or
should the intervals be closed on the left (<code>FALSE</code>)? 'Closed on the right'
means that values at break positions are part of the lower bin (open on the
left), whereas they are part of the upper bin when intervals are closed on
the left (open on the right).</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_show.limits">show.limits</code></td>
<td>
<p>should the limits of the scale appear as ticks</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_call">call</code></td>
<td>
<p>The <code>call</code> used to construct the scale for reporting messages.</p>
</td></tr>
<tr><td><code id="binned_scale_+3A_super">super</code></td>
<td>
<p>The super class to use for the constructed scale</p>
</td></tr>
</table>

<hr>
<h2 id='borders'>Create a layer of map borders</h2><span id='topic+borders'></span>

<h3>Description</h3>

<p>This is a quick and dirty way to get map data (from the <span class="pkg">maps</span> package)
onto your plot. This is a good place to start if you need some crude
reference lines, but you'll typically want something more sophisticated
for communication graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>borders(
  database = "world",
  regions = ".",
  fill = NA,
  colour = "grey50",
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="borders_+3A_database">database</code></td>
<td>
<p>map data, see <code><a href="maps.html#topic+map">maps::map()</a></code> for details</p>
</td></tr>
<tr><td><code id="borders_+3A_regions">regions</code></td>
<td>
<p>map region</p>
</td></tr>
<tr><td><code id="borders_+3A_fill">fill</code></td>
<td>
<p>fill colour</p>
</td></tr>
<tr><td><code id="borders_+3A_colour">colour</code></td>
<td>
<p>border colour</p>
</td></tr>
<tr><td><code id="borders_+3A_xlim">xlim</code>, <code id="borders_+3A_ylim">ylim</code></td>
<td>
<p>latitudinal and longitudinal ranges for extracting map
polygons, see <code><a href="maps.html#topic+map">maps::map()</a></code> for details.</p>
</td></tr>
<tr><td><code id="borders_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+geom_polygon">geom_polygon</a></code>
</p>

<dl>
<dt><code>rule</code></dt><dd><p>Either <code>"evenodd"</code> or <code>"winding"</code>. If polygons with holes are
being drawn (using the <code>subgroup</code> aesthetic) this argument defines how the
hole coordinates are interpreted. See the examples in <code><a href="grid.html#topic+grid.path">grid::pathGrob()</a></code> for
an explanation.</p>
</dd>
<dt><code>mapping</code></dt><dd><p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</dd>
<dt><code>data</code></dt><dd><p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</dd>
<dt><code>stat</code></dt><dd><p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</dd>
<dt><code>position</code></dt><dd><p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</dd>
<dt><code>show.legend</code></dt><dd><p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</dd>
<dt><code>inherit.aes</code></dt><dd><p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</dd>
<dt><code>na.rm</code></dt><dd><p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("maps")) {

ia &lt;- map_data("county", "iowa")
mid_range &lt;- function(x) mean(range(x))
seats &lt;- do.call(rbind, lapply(split(ia, ia$subregion), function(d) {
  data.frame(lat = mid_range(d$lat), long = mid_range(d$long), subregion = unique(d$subregion))
}))

ggplot(ia, aes(long, lat)) +
  geom_polygon(aes(group = group), fill = NA, colour = "grey60") +
  geom_text(aes(label = subregion), data = seats, size = 2, angle = 45)
}

if (require("maps")) {
data(us.cities)
capitals &lt;- subset(us.cities, capital == 2)
ggplot(capitals, aes(long, lat)) +
  borders("state") +
  geom_point(aes(size = pop)) +
  scale_size_area() +
  coord_quickmap()
}

if (require("maps")) {
# Same map, with some world context
ggplot(capitals, aes(long, lat)) +
  borders("world", xlim = c(-130, -60), ylim = c(20, 50)) +
  geom_point(aes(size = pop)) +
  scale_size_area() +
  coord_quickmap()
}
</code></pre>

<hr>
<h2 id='calc_element'>Calculate the element properties, by inheriting properties from its parents</h2><span id='topic+calc_element'></span>

<h3>Description</h3>

<p>Calculate the element properties, by inheriting properties from its parents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_element(
  element,
  theme,
  verbose = FALSE,
  skip_blank = FALSE,
  call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_element_+3A_element">element</code></td>
<td>
<p>The name of the theme element to calculate</p>
</td></tr>
<tr><td><code id="calc_element_+3A_theme">theme</code></td>
<td>
<p>A theme object (like <code><a href="#topic+theme_grey">theme_grey()</a></code>)</p>
</td></tr>
<tr><td><code id="calc_element_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print out which elements this one inherits from</p>
</td></tr>
<tr><td><code id="calc_element_+3A_skip_blank">skip_blank</code></td>
<td>
<p>If TRUE, elements of type <code>element_blank</code> in the
inheritance hierarchy will be ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- theme_grey()
calc_element('text', t)

# Compare the "raw" element definition to the element with calculated inheritance
t$axis.text.x
calc_element('axis.text.x', t, verbose = TRUE)

# This reports that axis.text.x inherits from axis.text,
# which inherits from text. You can view each of them with:
t$axis.text.x
t$axis.text
t$text
</code></pre>

<hr>
<h2 id='check_device'>Check graphics device capabilities</h2><span id='topic+check_device'></span>

<h3>Description</h3>

<p>This function makes an attempt to estimate whether the graphics device is
able to render newer graphics features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_device(
  feature,
  action = "warn",
  op = NULL,
  maybe = FALSE,
  call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_device_+3A_feature">feature</code></td>
<td>
<p>A string naming a graphics device feature. One of:
<code>"clippingPaths"</code>, <code>"alpha_masks"</code>, <code>"lumi_masks"</code>, <code>"compositing"</code>,
<code>"blending"</code>, <code>"transformations"</code>, <code>"gradients"</code>, <code>"patterns"</code>, <code>"paths"</code>
or <code>"glyphs"</code>. See the 'Features' section below for an explanation
of these terms.</p>
</td></tr>
<tr><td><code id="check_device_+3A_action">action</code></td>
<td>
<p>A string for what action to take. One of:
</p>

<ul>
<li> <p><code>"test"</code> returns <code>TRUE</code> or <code>FALSE</code> indicating support of the feature.
</p>
</li>
<li> <p><code>"warn"</code> also returns a logical, but throws an informative warning when
<code>FALSE</code>.
</p>
</li>
<li> <p><code>"abort"</code> throws an error when the device is estimated to not support
the feature.
</p>
</li></ul>
</td></tr>
<tr><td><code id="check_device_+3A_op">op</code></td>
<td>
<p>A string for a specific operation to test for when <code>feature</code> is
either <code>"blending"</code> or <code>"compositing"</code>. If <code>NULL</code> (default), support for
all known blending or compositing operations is queried.</p>
</td></tr>
<tr><td><code id="check_device_+3A_maybe">maybe</code></td>
<td>
<p>A logical of length 1 determining what the return value should
be in case the device capabilities cannot be assessed. When the current
device is the 'null device', <code>maybe</code> is returned.</p>
</td></tr>
<tr><td><code id="check_device_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently running function, e.g.
<code><a href="rlang.html#topic+stack">caller_env()</a></code>. The function will be mentioned in
warnings and error messages as the source of the warning or error. See
the <code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure for testing is as follows:
</p>

<ul>
<li><p> First, the <span class="rlang"><b>R</b></span> version is checked against the version wherein a feature was
introduced.
</p>
</li>
<li><p> Next, the <a href="grDevices.html#topic+dev.capabilities">dev.capabilities()</a> function is
queried for support of the feature.
</p>
</li>
<li><p> If that check is ambiguous, the <span class="pkg">svglite</span> and <span class="pkg">ragg</span> devices are
checked for known support.
</p>
</li>
<li><p> Lastly, if there is no answer yet, it is checked whether the device is one
of the 'known' devices that supports a feature.
</p>
</li></ul>



<h3>Value</h3>

<p><code>TRUE</code> when the feature is thought to be supported and <code>FALSE</code>
otherwise.
</p>


<h3>Features</h3>


<dl>
<dt><code>"clippingPaths"</code></dt><dd><p>While most devices support rectangular clipping
regions, this feature is about the support for clipping to arbitrary paths.
It can be used to only display a part of a drawing.</p>
</dd>
<dt><code>"alpha_masks"</code></dt><dd><p>Like clipping regions and paths, alpha masks can also
be used to only display a part of a drawing. In particular a
semi-transparent mask can be used to display a drawing in the opaque parts
of the mask and hide a drawing in transparent part of a mask.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;"lumi_masks&#8288;</code></dt><dd><p>Similar to alpha masks, but using the mask's luminance
(greyscale value) to determine what is drawn. Light values are opaque and
dark values are transparent.</p>
</dd>
<dt><code>"compositing"</code></dt><dd><p>Compositing allows one to control how to drawings
are drawn in relation to one another. By default, one drawing is drawn
'over' the previous one, but other operators are possible, like 'clear',
'in' and 'out'.</p>
</dd>
<dt><code>"blending"</code></dt><dd><p>When placing one drawing atop of another, the blend
mode determines how the colours of the drawings relate to one another.</p>
</dd>
<dt><code>"transformations"</code></dt><dd><p>Performing an affine transformation on a group
can be used to translate, rotate, scale, shear and flip the drawing.</p>
</dd>
<dt><code>"gradients"</code></dt><dd><p>Gradients can be used to show a transition between
two or more colours as a fill in a drawing. The checks expects both linear
and radial gradients to be supported.</p>
</dd>
<dt><code>"patterns"</code></dt><dd><p>Patterns can be used to display a repeated, tiled
drawing as a fill in another drawing.</p>
</dd>
<dt><code>"paths"</code></dt><dd><p>Contrary to 'paths' as polyline or polygon drawings,
<code>"paths"</code> refers to the ability to fill and stroke collections of
drawings.</p>
</dd>
<dt><code>"glyphs"</code></dt><dd><p>Refers to the advanced typesetting feature for
controlling the appearance of individual glyphs.</p>
</dd>
</dl>



<h3>Limitations</h3>


<ul>
<li><p> On Windows machines, bitmap devices such as <code>png()</code> or <code>jpeg()</code> default
to <code>type = "windows"</code>. At the time of writing, these don't support any
new features, in contrast to <code>type = "cairo"</code>, which does. Prior to <span class="rlang"><b>R</b></span>
version 4.2.0, the capabilities cannot be resolved and the value of the
<code>maybe</code> argument is returned.
</p>
</li>
<li><p> With the exception of the <span class="pkg">ragg</span> and <span class="pkg">svglite</span> devices, if the
device doesn't report their capabilities via
<a href="grDevices.html#topic+dev.capabilities">dev.capabilities()</a>, or the <span class="rlang"><b>R</b></span> version is
below 4.2.0, the <code>maybe</code> value is returned.
</p>
</li>
<li><p> Even though patterns and gradients where introduced in <span class="rlang"><b>R</b></span> 4.1.0, they
are considered unsupported because providing vectorised patterns and
gradients was only introduced later in <span class="rlang"><b>R</b></span> 4.2.0.
</p>
</li>
<li><p> When using the RStudio graphics device, the back end is assumed to be the
next device on the list. This assumption is typically met by default,
unless the device list is purposefully rearranged.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Typically you'd run `check_device()` inside a function that might produce
# advanced graphics.
# The check is designed for use in control flow statements in the test mode
if (check_device("patterns", action = "test")) {
  print("Yay")
} else {
  print("Nay")
}

# Automatically throw a warning when unavailable
if (check_device("compositing", action = "warn")) {
  print("Yay")
} else {
  print("Nay")
}

# Possibly throw an error
try(check_device("glyphs", action = "abort"))
</code></pre>

<hr>
<h2 id='combine_vars'>Take input data and define a mapping between faceting variables and ROW,
COL and PANEL keys</h2><span id='topic+combine_vars'></span>

<h3>Description</h3>

<p>Take input data and define a mapping between faceting variables and ROW,
COL and PANEL keys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_vars(data, env = emptyenv(), vars = NULL, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_vars_+3A_data">data</code></td>
<td>
<p>A list of data.frames, the first being the plot data and the
subsequent individual layer data</p>
</td></tr>
<tr><td><code id="combine_vars_+3A_env">env</code></td>
<td>
<p>The environment the vars should be evaluated in</p>
</td></tr>
<tr><td><code id="combine_vars_+3A_vars">vars</code></td>
<td>
<p>A list of quoted symbols matching columns in data</p>
</td></tr>
<tr><td><code id="combine_vars_+3A_drop">drop</code></td>
<td>
<p>should missing combinations/levels be dropped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns for PANEL, ROW, COL, and faceting vars
</p>

<hr>
<h2 id='continuous_scale'>Continuous scale constructor</h2><span id='topic+continuous_scale'></span>

<h3>Description</h3>

<p>Continuous scale constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous_scale(
  aesthetics,
  scale_name = deprecated(),
  palette,
  name = waiver(),
  breaks = waiver(),
  minor_breaks = waiver(),
  n.breaks = NULL,
  labels = waiver(),
  limits = NULL,
  rescaler = rescale,
  oob = censor,
  expand = waiver(),
  na.value = NA_real_,
  transform = "identity",
  trans = deprecated(),
  guide = "legend",
  position = "left",
  call = caller_call(),
  super = ScaleContinuous
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuous_scale_+3A_aesthetics">aesthetics</code></td>
<td>
<p>The names of the aesthetics that this scale works with.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_scale_name">scale_name</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_palette">palette</code></td>
<td>
<p>A palette function that when called with a numeric vector with
values between 0 and 1 returns the corresponding output values
(e.g., <code><a href="scales.html#topic+pal_area">scales::pal_area()</a></code>).</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="continuous_scale_+3A_minor_breaks">minor_breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</td></tr>
<tr><td><code id="continuous_scale_+3A_n.breaks">n.breaks</code></td>
<td>
<p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="continuous_scale_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="continuous_scale_+3A_rescaler">rescaler</code></td>
<td>
<p>A function used to scale the input values to the
range [0, 1]. This is always <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>, except for
diverging and n colour gradients (i.e., <code><a href="#topic+scale_colour_gradient2">scale_colour_gradient2()</a></code>,
<code><a href="#topic+scale_colour_gradientn">scale_colour_gradientn()</a></code>). The <code>rescaler</code> is ignored by position
scales, which always use <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>. Also accepts rlang
<a href="rlang.html#topic+as_function">lambda</a> function notation.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="continuous_scale_+3A_expand">expand</code></td>
<td>
<p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_call">call</code></td>
<td>
<p>The <code>call</code> used to construct the scale for reporting messages.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_super">super</code></td>
<td>
<p>The super class to use for the constructed scale</p>
</td></tr>
</table>

<hr>
<h2 id='coord_cartesian'>Cartesian coordinates</h2><span id='topic+coord_cartesian'></span>

<h3>Description</h3>

<p>The Cartesian coordinate system is the most familiar, and common, type of
coordinate system. Setting limits on the coordinate system will zoom the
plot (like you're looking at it with a magnifying glass), and will not
change the underlying data like setting limits on a scale will.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_cartesian(
  xlim = NULL,
  ylim = NULL,
  expand = TRUE,
  default = FALSE,
  clip = "on"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_cartesian_+3A_xlim">xlim</code>, <code id="coord_cartesian_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes.</p>
</td></tr>
<tr><td><code id="coord_cartesian_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
<tr><td><code id="coord_cartesian_+3A_default">default</code></td>
<td>
<p>Is this the default coordinate system? If <code>FALSE</code> (the default),
then replacing this coordinate system with another one creates a message alerting
the user that the coordinate system is being replaced. If <code>TRUE</code>, that warning
is suppressed.</p>
</td></tr>
<tr><td><code id="coord_cartesian_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. In most cases, the default of <code>"on"</code> should not be changed,
as setting <code>clip = "off"</code> can cause unexpected results. It allows
drawing of data points anywhere on the plot, including in the plot margins. If
limits are set via <code>xlim</code> and <code>ylim</code> and some data points fall outside those
limits, then those data points may show up in places such as the axes, the
legend, the plot title, or the plot margins.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># There are two ways of zooming the plot display: with scales or
# with coordinate systems.  They work in two rather different ways.

p &lt;- ggplot(mtcars, aes(disp, wt)) +
  geom_point() +
  geom_smooth()
p

# Setting the limits on a scale converts all values outside the range to NA.
p + scale_x_continuous(limits = c(325, 500))

# Setting the limits on the coordinate system performs a visual zoom.
# The data is unchanged, and we just view a small portion of the original
# plot. Note how smooth continues past the points visible on this plot.
p + coord_cartesian(xlim = c(325, 500))

# By default, the same expansion factor is applied as when setting scale
# limits. You can set the limits precisely by setting expand = FALSE
p + coord_cartesian(xlim = c(325, 500), expand = FALSE)

# Similarly, we can use expand = FALSE to turn off expansion with the
# default limits
p + coord_cartesian(expand = FALSE)

# You can see the same thing with this 2d histogram
d &lt;- ggplot(diamonds, aes(carat, price)) +
  stat_bin_2d(bins = 25, colour = "white")
d

# When zooming the scale, the we get 25 new bins that are the same
# size on the plot, but represent smaller regions of the data space
d + scale_x_continuous(limits = c(0, 1))

# When zooming the coordinate system, we see a subset of original 50 bins,
# displayed bigger
d + coord_cartesian(xlim = c(0, 1))
</code></pre>

<hr>
<h2 id='coord_fixed'>Cartesian coordinates with fixed &quot;aspect ratio&quot;</h2><span id='topic+coord_fixed'></span><span id='topic+coord_equal'></span>

<h3>Description</h3>

<p>A fixed scale coordinate system forces a specified ratio between the
physical representation of data units on the axes. The ratio represents the
number of units on the y-axis equivalent to one unit on the x-axis. The
default, <code>ratio = 1</code>, ensures that one unit on the x-axis is the same
length as one unit on the y-axis. Ratios higher than one make units on the
y axis longer than units on the x-axis, and vice versa. This is similar to
<code><a href="MASS.html#topic+eqscplot">MASS::eqscplot()</a></code>, but it works for all types of graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_fixed_+3A_ratio">ratio</code></td>
<td>
<p>aspect ratio, expressed as <code>y / x</code></p>
</td></tr>
<tr><td><code id="coord_fixed_+3A_xlim">xlim</code>, <code id="coord_fixed_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes.</p>
</td></tr>
<tr><td><code id="coord_fixed_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
<tr><td><code id="coord_fixed_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. In most cases, the default of <code>"on"</code> should not be changed,
as setting <code>clip = "off"</code> can cause unexpected results. It allows
drawing of data points anywhere on the plot, including in the plot margins. If
limits are set via <code>xlim</code> and <code>ylim</code> and some data points fall outside those
limits, then those data points may show up in places such as the axes, the
legend, the plot title, or the plot margins.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ensures that the ranges of axes are equal to the specified ratio by
# adjusting the plot aspect ratio

p &lt;- ggplot(mtcars, aes(mpg, wt)) + geom_point()
p + coord_fixed(ratio = 1)
p + coord_fixed(ratio = 5)
p + coord_fixed(ratio = 1/5)
p + coord_fixed(xlim = c(15, 30))

# Resize the plot to see that the specified aspect ratio is maintained
</code></pre>

<hr>
<h2 id='coord_flip'>Cartesian coordinates with x and y flipped</h2><span id='topic+coord_flip'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>This function is superseded because in many cases, <code>coord_flip()</code> can easily
be replaced by swapping the x and y aesthetics, or optionally setting the
<code>orientation</code> argument in geom and stat layers.
</p>
<p><code>coord_flip()</code> is useful for geoms and statistics that do not support
the <code>orientation</code> setting, and converting the display of y conditional on x,
to x conditional on y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_flip(xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_flip_+3A_xlim">xlim</code>, <code id="coord_flip_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes.</p>
</td></tr>
<tr><td><code id="coord_flip_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
<tr><td><code id="coord_flip_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. In most cases, the default of <code>"on"</code> should not be changed,
as setting <code>clip = "off"</code> can cause unexpected results. It allows
drawing of data points anywhere on the plot, including in the plot margins. If
limits are set via <code>xlim</code> and <code>ylim</code> and some data points fall outside those
limits, then those data points may show up in places such as the axes, the
legend, the plot title, or the plot margins.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># The preferred method of creating horizontal instead of vertical boxplots
ggplot(diamonds, aes(price, cut)) +
  geom_boxplot()

# Using `coord_flip()` to make the same plot
ggplot(diamonds, aes(cut, price)) +
  geom_boxplot() +
  coord_flip()

# With swapped aesthetics, the y-scale controls the left axis
ggplot(diamonds, aes(y = carat)) +
  geom_histogram() +
  scale_y_reverse()

# In `coord_flip()`, the x-scale controls the left axis
ggplot(diamonds, aes(carat)) +
  geom_histogram() +
  coord_flip() +
  scale_x_reverse()

# In line and area plots, swapped aesthetics require an explicit orientation
df &lt;- data.frame(a = 1:5, b = (1:5) ^ 2)
ggplot(df, aes(b, a)) +
  geom_area(orientation = "y")

# The same plot with `coord_flip()`
ggplot(df, aes(a, b)) +
  geom_area() +
  coord_flip()
</code></pre>

<hr>
<h2 id='coord_map'>Map projections</h2><span id='topic+coord_map'></span><span id='topic+coord_quickmap'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>coord_map()</code> projects a portion of the earth, which is approximately
spherical, onto a flat 2D plane using any projection defined by the
<code>mapproj</code> package. Map projections do not, in general, preserve straight
lines, so this requires considerable computation. <code>coord_quickmap()</code> is a
quick approximation that does preserve straight lines. It works best for
smaller areas closer to the equator.
</p>
<p>Both <code>coord_map()</code> and <code>coord_quickmap()</code>
are superseded by <code><a href="#topic+coord_sf">coord_sf()</a></code>, and should no longer be used in new
code. All regular (non-sf) geoms can be used with <code>coord_sf()</code> by
setting the default coordinate system via the <code>default_crs</code> argument.
See also the examples for <code><a href="#topic+annotation_map">annotation_map()</a></code> and <code><a href="#topic+geom_map">geom_map()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_map(
  projection = "mercator",
  ...,
  parameters = NULL,
  orientation = NULL,
  xlim = NULL,
  ylim = NULL,
  clip = "on"
)

coord_quickmap(xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_map_+3A_projection">projection</code></td>
<td>
<p>projection to use, see
<code><a href="mapproj.html#topic+mapproject">mapproj::mapproject()</a></code> for list</p>
</td></tr>
<tr><td><code id="coord_map_+3A_...">...</code>, <code id="coord_map_+3A_parameters">parameters</code></td>
<td>
<p>Other arguments passed on to
<code><a href="mapproj.html#topic+mapproject">mapproj::mapproject()</a></code>. Use <code>...</code> for named parameters to
the projection, and <code>parameters</code> for unnamed parameters.
<code>...</code> is ignored if the <code>parameters</code> argument is present.</p>
</td></tr>
<tr><td><code id="coord_map_+3A_orientation">orientation</code></td>
<td>
<p>projection orientation, which defaults to
<code>c(90, 0, mean(range(x)))</code>.  This is not optimal for many
projections, so you will have to supply your own. See
<code><a href="mapproj.html#topic+mapproject">mapproj::mapproject()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="coord_map_+3A_xlim">xlim</code>, <code id="coord_map_+3A_ylim">ylim</code></td>
<td>
<p>Manually specific x/y limits (in degrees of
longitude/latitude)</p>
</td></tr>
<tr><td><code id="coord_map_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. For details, please see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>.</p>
</td></tr>
<tr><td><code id="coord_map_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Map projections must account for the fact that the actual length
(in km) of one degree of longitude varies between the equator and the pole.
Near the equator, the ratio between the lengths of one degree of latitude and
one degree of longitude is approximately 1. Near the pole, it tends
towards infinity because the length of one degree of longitude tends towards
0. For regions that span only a few degrees and are not too close to the
poles, setting the aspect ratio of the plot to the appropriate lat/lon ratio
approximates the usual mercator projection. This is what
<code>coord_quickmap()</code> does, and is much faster (particularly for complex
plots like <code><a href="#topic+geom_tile">geom_tile()</a></code>) at the expense of correctness.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("maps")) {
nz &lt;- map_data("nz")
# Prepare a map of NZ
nzmap &lt;- ggplot(nz, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")

# Plot it in cartesian coordinates
nzmap
}

if (require("maps")) {
# With correct mercator projection
nzmap + coord_map()
}

if (require("maps")) {
# With the aspect ratio approximation
nzmap + coord_quickmap()
}

if (require("maps")) {
# Other projections
nzmap + coord_map("azequalarea", orientation = c(-36.92, 174.6, 0))
}

if (require("maps")) {
states &lt;- map_data("state")
usamap &lt;- ggplot(states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")

# Use cartesian coordinates
usamap
}

if (require("maps")) {
# With mercator projection
usamap + coord_map()
}

if (require("maps")) {
# See ?mapproject for coordinate systems and their parameters
usamap + coord_map("gilbert")
}

if (require("maps")) {
# For most projections, you'll need to set the orientation yourself
# as the automatic selection done by mapproject is not available to
# ggplot
usamap + coord_map("orthographic")
}

if (require("maps")) {
usamap + coord_map("conic", lat0 = 30)
}

if (require("maps")) {
usamap + coord_map("bonne", lat0 = 50)
}

## Not run: 
if (require("maps")) {
# World map, using geom_path instead of geom_polygon
world &lt;- map_data("world")
worldmap &lt;- ggplot(world, aes(x = long, y = lat, group = group)) +
  geom_path() +
  scale_y_continuous(breaks = (-2:2) * 30) +
  scale_x_continuous(breaks = (-4:4) * 45)

# Orthographic projection with default orientation (looking down at North pole)
worldmap + coord_map("ortho")
}

if (require("maps")) {
# Looking up up at South Pole
worldmap + coord_map("ortho", orientation = c(-90, 0, 0))
}

if (require("maps")) {
# Centered on New York (currently has issues with closing polygons)
worldmap + coord_map("ortho", orientation = c(41, -74, 0))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='coord_munch'>Munch coordinates data</h2><span id='topic+coord_munch'></span>

<h3>Description</h3>

<p>This function &quot;munches&quot; lines, dividing each line into many small pieces
so they can be transformed independently. Used inside geom functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_munch(coord, data, range, segment_length = 0.01, is_closed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_munch_+3A_coord">coord</code></td>
<td>
<p>Coordinate system definition.</p>
</td></tr>
<tr><td><code id="coord_munch_+3A_data">data</code></td>
<td>
<p>Data set to transform - should have variables <code>x</code> and
<code>y</code> are chopped up into small pieces (as defined by <code>group</code>).
All other variables are duplicated as needed.</p>
</td></tr>
<tr><td><code id="coord_munch_+3A_range">range</code></td>
<td>
<p>Panel range specification.</p>
</td></tr>
<tr><td><code id="coord_munch_+3A_segment_length">segment_length</code></td>
<td>
<p>Target segment length</p>
</td></tr>
<tr><td><code id="coord_munch_+3A_is_closed">is_closed</code></td>
<td>
<p>Whether data should be considered as a closed polygon.</p>
</td></tr>
</table>

<hr>
<h2 id='coord_polar'>Polar coordinates</h2><span id='topic+coord_polar'></span><span id='topic+coord_radial'></span>

<h3>Description</h3>

<p>The polar coordinate system is most commonly used for pie charts, which
are a stacked bar chart in polar coordinates. <code>coord_radial()</code> has extended
options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_polar(theta = "x", start = 0, direction = 1, clip = "on")

coord_radial(
  theta = "x",
  start = 0,
  end = NULL,
  expand = TRUE,
  direction = 1,
  clip = "off",
  r_axis_inside = NULL,
  rotate_angle = FALSE,
  inner.radius = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_polar_+3A_theta">theta</code></td>
<td>
<p>variable to map angle to (<code>x</code> or <code>y</code>)</p>
</td></tr>
<tr><td><code id="coord_polar_+3A_start">start</code></td>
<td>
<p>Offset of starting point from 12 o'clock in radians. Offset
is applied clockwise or anticlockwise depending on value of <code>direction</code>.</p>
</td></tr>
<tr><td><code id="coord_polar_+3A_direction">direction</code></td>
<td>
<p>1, clockwise; -1, anticlockwise</p>
</td></tr>
<tr><td><code id="coord_polar_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. For details, please see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>.</p>
</td></tr>
<tr><td><code id="coord_polar_+3A_end">end</code></td>
<td>
<p>Position from 12 o'clock in radians where plot ends, to allow
for partial polar coordinates. The default, <code>NULL</code>, is set to
<code>start + 2 * pi</code>.</p>
</td></tr>
<tr><td><code id="coord_polar_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor the
the limits to prevent overlap between data and axes. If <code>FALSE</code>, limits
are taken directly from the scale.</p>
</td></tr>
<tr><td><code id="coord_polar_+3A_r_axis_inside">r_axis_inside</code></td>
<td>
<p>If <code>TRUE</code>, places the radius axis inside the
panel. If <code>FALSE</code>, places the radius axis next to the panel. The default,
<code>NULL</code>, places the radius axis outside if the <code>start</code> and <code>end</code> arguments
form a full circle.</p>
</td></tr>
<tr><td><code id="coord_polar_+3A_rotate_angle">rotate_angle</code></td>
<td>
<p>If <code>TRUE</code>, transforms the <code>angle</code> aesthetic in data
in accordance with the computed <code>theta</code> position. If <code>FALSE</code> (default),
no such transformation is performed. Can be useful to rotate text geoms in
alignment with the coordinates.</p>
</td></tr>
<tr><td><code id="coord_polar_+3A_inner.radius">inner.radius</code></td>
<td>
<p>A <code>numeric</code> between 0 and 1 setting the size of a inner.radius hole.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In <code>coord_radial()</code>, position guides are can be defined by using
<code>guides(r = ..., theta = ..., r.sec = ..., theta.sec = ...)</code>. Note that
these guides require <code>r</code> and <code>theta</code> as available aesthetics. The classic
<code>guide_axis()</code> can be used for the <code>r</code> positions and <code>guide_axis_theta()</code> can
be used for the <code>theta</code> positions. Using the <code>theta.sec</code> position is only
sensible when <code>inner.radius &gt; 0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># NOTE: Use these plots with caution - polar coordinates has
# major perceptual problems.  The main point of these examples is
# to demonstrate how these common plots can be described in the
# grammar.  Use with EXTREME caution.

#' # A pie chart = stacked bar chart + polar coordinates
pie &lt;- ggplot(mtcars, aes(x = factor(1), fill = factor(cyl))) +
 geom_bar(width = 1)
pie + coord_polar(theta = "y")



# A coxcomb plot = bar chart + polar coordinates
cxc &lt;- ggplot(mtcars, aes(x = factor(cyl))) +
  geom_bar(width = 1, colour = "black")
cxc + coord_polar()
# A new type of plot?
cxc + coord_polar(theta = "y")

# The bullseye chart
pie + coord_polar()

# Hadley's favourite pie chart
df &lt;- data.frame(
  variable = c("does not resemble", "resembles"),
  value = c(20, 80)
)
ggplot(df, aes(x = "", y = value, fill = variable)) +
  geom_col(width = 1) +
  scale_fill_manual(values = c("red", "yellow")) +
  coord_polar("y", start = pi / 3) +
  labs(title = "Pac man")

# Windrose + doughnut plot
if (require("ggplot2movies")) {
movies$rrating &lt;- cut_interval(movies$rating, length = 1)
movies$budgetq &lt;- cut_number(movies$budget, 4)

doh &lt;- ggplot(movies, aes(x = rrating, fill = budgetq))

# Wind rose
doh + geom_bar(width = 1) + coord_polar()
# Race track plot
doh + geom_bar(width = 0.9, position = "fill") + coord_polar(theta = "y")
}

# A partial polar plot
ggplot(mtcars, aes(disp, mpg)) +
  geom_point() +
  coord_radial(start = -0.4 * pi, end = 0.4 * pi, inner.radius = 0.3)
</code></pre>

<hr>
<h2 id='coord_trans'>Transformed Cartesian coordinate system</h2><span id='topic+coord_trans'></span>

<h3>Description</h3>

<p><code>coord_trans()</code> is different to scale transformations in that it occurs after
statistical transformation and will affect the visual appearance of geoms - there is
no guarantee that straight lines will continue to be straight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_trans(
  x = "identity",
  y = "identity",
  xlim = NULL,
  ylim = NULL,
  limx = deprecated(),
  limy = deprecated(),
  clip = "on",
  expand = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_trans_+3A_x">x</code>, <code id="coord_trans_+3A_y">y</code></td>
<td>
<p>Transformers for x and y axes or their names.</p>
</td></tr>
<tr><td><code id="coord_trans_+3A_xlim">xlim</code>, <code id="coord_trans_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes.</p>
</td></tr>
<tr><td><code id="coord_trans_+3A_limx">limx</code>, <code id="coord_trans_+3A_limy">limy</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> use <code>xlim</code> and <code>ylim</code> instead.</p>
</td></tr>
<tr><td><code id="coord_trans_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. In most cases, the default of <code>"on"</code> should not be changed,
as setting <code>clip = "off"</code> can cause unexpected results. It allows
drawing of data points anywhere on the plot, including in the plot margins. If
limits are set via <code>xlim</code> and <code>ylim</code> and some data points fall outside those
limits, then those data points may show up in places such as the axes, the
legend, the plot title, or the plot margins.</p>
</td></tr>
<tr><td><code id="coord_trans_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transformations only work with continuous values: see
<code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code> for list of transformations, and instructions
on how to create your own.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See ?geom_boxplot for other examples

# Three ways of doing transformation in ggplot:
#  * by transforming the data
ggplot(diamonds, aes(log10(carat), log10(price))) +
  geom_point()
#  * by transforming the scales
ggplot(diamonds, aes(carat, price)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10()
#  * by transforming the coordinate system:
ggplot(diamonds, aes(carat, price)) +
  geom_point() +
  coord_trans(x = "log10", y = "log10")

# The difference between transforming the scales and
# transforming the coordinate system is that scale
# transformation occurs BEFORE statistics, and coordinate
# transformation afterwards.  Coordinate transformation also
# changes the shape of geoms:

d &lt;- subset(diamonds, carat &gt; 0.5)

ggplot(d, aes(carat, price)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_x_log10() +
  scale_y_log10()

ggplot(d, aes(carat, price)) +
  geom_point() +
  geom_smooth(method = "lm") +
  coord_trans(x = "log10", y = "log10")

# Here I used a subset of diamonds so that the smoothed line didn't
# drop below zero, which obviously causes problems on the log-transformed
# scale

# With a combination of scale and coordinate transformation, it's
# possible to do back-transformations:
ggplot(diamonds, aes(carat, price)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_x_log10() +
  scale_y_log10() +
  coord_trans(x = scales::transform_exp(10), y = scales::transform_exp(10))

# cf.
ggplot(diamonds, aes(carat, price)) +
  geom_point() +
  geom_smooth(method = "lm")

# Also works with discrete scales
set.seed(1)
df &lt;- data.frame(a = abs(rnorm(26)),letters)
plot &lt;- ggplot(df,aes(a,letters)) + geom_point()

plot + coord_trans(x = "log10")
plot + coord_trans(x = "sqrt")

</code></pre>

<hr>
<h2 id='CoordSf'>Visualise sf objects</h2><span id='topic+CoordSf'></span><span id='topic+coord_sf'></span><span id='topic+ggsf'></span><span id='topic+GeomSf'></span><span id='topic+geom_sf'></span><span id='topic+geom_sf_label'></span><span id='topic+geom_sf_text'></span><span id='topic+StatSf'></span><span id='topic+stat_sf'></span>

<h3>Description</h3>

<p>This set of geom, stat, and coord are used to visualise simple feature (sf)
objects. For simple plots, you will only need <code>geom_sf()</code> as it
uses <code>stat_sf()</code> and adds <code>coord_sf()</code> for you. <code>geom_sf()</code> is
an unusual geom because it will draw different geometric objects depending
on what simple features are present in the data: you can get points, lines,
or polygons.
For text and labels, you can use <code>geom_sf_text()</code> and <code>geom_sf_label()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_sf(
  xlim = NULL,
  ylim = NULL,
  expand = TRUE,
  crs = NULL,
  default_crs = NULL,
  datum = sf::st_crs(4326),
  label_graticule = waiver(),
  label_axes = waiver(),
  lims_method = "cross",
  ndiscr = 100,
  default = FALSE,
  clip = "on"
)

geom_sf(
  mapping = aes(),
  data = NULL,
  stat = "sf",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_sf_label(
  mapping = aes(),
  data = NULL,
  stat = "sf_coordinates",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  label.padding = unit(0.25, "lines"),
  label.r = unit(0.15, "lines"),
  label.size = 0.25,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  fun.geometry = NULL
)

geom_sf_text(
  mapping = aes(),
  data = NULL,
  stat = "sf_coordinates",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  fun.geometry = NULL
)

stat_sf(
  mapping = NULL,
  data = NULL,
  geom = "rect",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoordSf_+3A_xlim">xlim</code>, <code id="CoordSf_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes. These limits are specified
in the units of the default CRS. By default, this means projected coordinates
(<code>default_crs = NULL</code>). How limit specifications translate into the exact
region shown on the plot can be confusing when non-linear or rotated coordinate
systems are used as the default crs. First, different methods can be preferable
under different conditions. See parameter <code>lims_method</code> for details. Second,
specifying limits along only one direction can affect the automatically generated
limits along the other direction. Therefore, it is best to always specify limits
for both x and y. Third, specifying limits via position scales or <code>xlim()</code>/<code>ylim()</code>
is strongly discouraged, as it can result in data points being dropped from the plot even
though they would be visible in the final plot region.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_crs">crs</code></td>
<td>
<p>The coordinate reference system (CRS) into which all data should
be projected before plotting. If not specified, will use the CRS defined
in the first sf layer of the plot.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_default_crs">default_crs</code></td>
<td>
<p>The default CRS to be used for non-sf layers (which
don't carry any CRS information) and scale limits. The default value of
<code>NULL</code> means that the setting for <code>crs</code> is used. This implies that all
non-sf layers and scale limits are assumed to be specified in projected
coordinates. A useful alternative setting is <code>default_crs = sf::st_crs(4326)</code>,
which means x and y positions are interpreted as longitude and latitude,
respectively, in the World Geodetic System 1984 (WGS84).</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_datum">datum</code></td>
<td>
<p>CRS that provides datum to use when generating graticules.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_label_graticule">label_graticule</code></td>
<td>
<p>Character vector indicating which graticule lines should be labeled
where. Meridians run north-south, and the letters <code>"N"</code> and <code>"S"</code> indicate that
they should be labeled on their north or south end points, respectively.
Parallels run east-west, and the letters <code>"E"</code> and <code>"W"</code> indicate that they
should be labeled on their east or west end points, respectively. Thus,
<code>label_graticule = "SW"</code> would label meridians at their south end and parallels at
their west end, whereas <code>label_graticule = "EW"</code> would label parallels at both
ends and meridians not at all. Because meridians and parallels can in general
intersect with any side of the plot panel, for any choice of <code>label_graticule</code> labels
are not guaranteed to reside on only one particular side of the plot panel. Also,
<code>label_graticule</code> can cause labeling artifacts, in particular if a graticule line
coincides with the edge of the plot panel. In such circumstances, <code>label_axes</code> will
generally yield better results and should be used instead.
</p>
<p>This parameter can be used alone or in combination with <code>label_axes</code>.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_label_axes">label_axes</code></td>
<td>
<p>Character vector or named list of character values
specifying which graticule lines (meridians or parallels) should be labeled on
which side of the plot. Meridians are indicated by <code>"E"</code> (for East) and
parallels by <code>"N"</code> (for North). Default is <code>"--EN"</code>, which specifies
(clockwise from the top) no labels on the top, none on the right, meridians
on the bottom, and parallels on the left. Alternatively, this setting could have been
specified with <code>list(bottom = "E", left = "N")</code>.
</p>
<p>This parameter can be used alone or in combination with <code>label_graticule</code>.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_lims_method">lims_method</code></td>
<td>
<p>Method specifying how scale limits are converted into
limits on the plot region. Has no effect when <code>default_crs = NULL</code>.
For a very non-linear CRS (e.g., a perspective centered
around the North pole), the available methods yield widely differing results, and
you may want to try various options. Methods currently implemented include <code>"cross"</code>
(the default), <code>"box"</code>, <code>"orthogonal"</code>, and <code>"geometry_bbox"</code>. For method <code>"cross"</code>,
limits along one direction (e.g., longitude) are applied at the midpoint of the
other direction (e.g., latitude). This method avoids excessively large limits for
rotated coordinate systems but means that sometimes limits need to be expanded a
little further if extreme data points are to be included in the final plot region.
By contrast, for method <code>"box"</code>, a box is generated out of the limits along both directions,
and then limits in projected coordinates are chosen such that the entire box is
visible. This method can yield plot regions that are too large. Finally, method
<code>"orthogonal"</code> applies limits separately along each axis, and method
<code>"geometry_bbox"</code> ignores all limit information except the bounding boxes of any
objects in the <code>geometry</code> aesthetic.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_ndiscr">ndiscr</code></td>
<td>
<p>Number of segments to use for discretising graticule lines;
try increasing this number when graticules look incorrect.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_default">default</code></td>
<td>
<p>Is this the default coordinate system? If <code>FALSE</code> (the default),
then replacing this coordinate system with another one creates a message alerting
the user that the coordinate system is being replaced. If <code>TRUE</code>, that warning
is suppressed.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. In most cases, the default of <code>"on"</code> should not be changed,
as setting <code>clip = "off"</code> can cause unexpected results. It allows
drawing of data points anywhere on the plot, including in the plot margins. If
limits are set via <code>xlim</code> and <code>ylim</code> and some data points fall outside those
limits, then those data points may show up in places such as the axes, the
legend, the plot title, or the plot margins.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
</p>
<p>You can also set this to one of &quot;polygon&quot;, &quot;line&quot;, and &quot;point&quot; to
override the default legend.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_nudge_x">nudge_x</code>, <code id="CoordSf_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_fun.geometry">fun.geometry</code></td>
<td>
<p>A function that takes a <code>sfc</code> object and returns a <code>sfc_POINT</code> with the
same length as the input. If <code>NULL</code>, <code>function(x) sf::st_point_on_surface(sf::st_zm(x))</code>
will be used. Note that the function may warn about the incorrectness of
the result if the data is not projected, but you can ignore this except
when you really care about the exact locations.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="CoordSf_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
</table>


<h3>Geometry aesthetic</h3>

<p><code>geom_sf()</code> uses a unique aesthetic: <code>geometry</code>, giving an
column of class <code>sfc</code> containing simple features data. There
are three ways to supply the <code>geometry</code> aesthetic:
</p>

<ul>
<li><p> Do nothing: by default <code>geom_sf()</code> assumes it is stored in
the <code>geometry</code> column.
</p>
</li>
<li><p> Explicitly pass an <code>sf</code> object to the <code>data</code> argument.
This will use the primary geometry column, no matter what it's called.
</p>
</li>
<li><p> Supply your own using <code>aes(geometry = my_column)</code>
</p>
</li></ul>

<p>Unlike other aesthetics, <code>geometry</code> will never be inherited from
the plot.
</p>


<h3>CRS</h3>

<p><code>coord_sf()</code> ensures that all layers use a common CRS. You can
either specify it using the <code>crs</code> param, or <code>coord_sf()</code> will
take it from the first layer that defines a CRS.
</p>


<h3>Combining sf layers and regular geoms</h3>

<p>Most regular geoms, such as <code><a href="#topic+geom_point">geom_point()</a></code>, <code><a href="#topic+geom_path">geom_path()</a></code>,
<code><a href="#topic+geom_text">geom_text()</a></code>, <code><a href="#topic+geom_polygon">geom_polygon()</a></code> etc. will work fine with <code>coord_sf()</code>. However
when using these geoms, two problems arise. First, what CRS should be used
for the x and y coordinates used by these non-sf geoms? The CRS applied to
non-sf geoms is set by the <code>default_crs</code> parameter, and it defaults to
<code>NULL</code>, which means positions for non-sf geoms are interpreted as projected
coordinates in the coordinate system set by the <code>crs</code> parameter. This setting
allows you complete control over where exactly items are placed on the plot
canvas, but it may require some understanding of how projections work and how
to generate data in projected coordinates. As an alternative, you can set
<code>default_crs = sf::st_crs(4326)</code>, the World Geodetic System 1984 (WGS84).
This means that x and y positions are interpreted as longitude and latitude,
respectively. You can also specify any other valid CRS as the default CRS for
non-sf geoms.
</p>
<p>The second problem that arises for non-sf geoms is how straight lines
should be interpreted in projected space when <code>default_crs</code> is not set to <code>NULL</code>.
The approach <code>coord_sf()</code> takes is to break straight lines into small pieces
(i.e., segmentize them) and then transform the pieces into projected coordinates.
For the default setting where x and y are interpreted as longitude and latitude,
this approach means that horizontal lines follow the parallels and vertical lines
follow the meridians. If you need a different approach to handling straight lines,
then you should manually segmentize and project coordinates and generate the plot
in projected coordinates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stat_sf_coordinates">stat_sf_coordinates()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("sf", quietly = TRUE)) {
nc &lt;- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
ggplot(nc) +
  geom_sf(aes(fill = AREA))

# If not supplied, coord_sf() will take the CRS from the first layer
# and automatically transform all other layers to use that CRS. This
# ensures that all data will correctly line up
nc_3857 &lt;- sf::st_transform(nc, 3857)
ggplot() +
  geom_sf(data = nc) +
  geom_sf(data = nc_3857, colour = "red", fill = NA)

# Unfortunately if you plot other types of feature you'll need to use
# show.legend to tell ggplot2 what type of legend to use
nc_3857$mid &lt;- sf::st_centroid(nc_3857$geometry)
ggplot(nc_3857) +
  geom_sf(colour = "white") +
  geom_sf(aes(geometry = mid, size = AREA), show.legend = "point")

# You can also use layers with x and y aesthetics. To have these interpreted
# as longitude/latitude you need to set the default CRS in coord_sf()
ggplot(nc_3857) +
  geom_sf() +
  annotate("point", x = -80, y = 35, colour = "red", size = 4) +
  coord_sf(default_crs = sf::st_crs(4326))

# To add labels, use geom_sf_label().
ggplot(nc_3857[1:3, ]) +
   geom_sf(aes(fill = AREA)) +
   geom_sf_label(aes(label = NAME))
}

# Thanks to the power of sf, a geom_sf nicely handles varying projections
# setting the aspect ratio correctly.
if (requireNamespace('maps', quietly = TRUE)) {
library(maps)
world1 &lt;- sf::st_as_sf(map('world', plot = FALSE, fill = TRUE))
ggplot() + geom_sf(data = world1)

world2 &lt;- sf::st_transform(
  world1,
  "+proj=laea +y_0=0 +lon_0=155 +lat_0=-90 +ellps=WGS84 +no_defs"
)
ggplot() + geom_sf(data = world2)
}
</code></pre>

<hr>
<h2 id='cut_interval'>Discretise numeric data into categorical</h2><span id='topic+cut_interval'></span><span id='topic+cut_number'></span><span id='topic+cut_width'></span>

<h3>Description</h3>

<p><code>cut_interval()</code> makes <code>n</code> groups with equal range, <code>cut_number()</code>
makes <code>n</code> groups with (approximately) equal numbers of observations;
<code>cut_width()</code> makes groups of width <code>width</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_interval(x, n = NULL, length = NULL, ...)

cut_number(x, n = NULL, ...)

cut_width(x, width, center = NULL, boundary = NULL, closed = "right", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_interval_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="cut_interval_+3A_n">n</code></td>
<td>
<p>number of intervals to create, OR</p>
</td></tr>
<tr><td><code id="cut_interval_+3A_length">length</code></td>
<td>
<p>length of each interval</p>
</td></tr>
<tr><td><code id="cut_interval_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+cut">base::cut.default</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>either a numeric vector of two or more unique cut points or a
single number (greater than or equal to 2) giving the number of
intervals into which <code>x</code> is to be cut.</p>
</dd>
<dt><code>labels</code></dt><dd><p>labels for the levels of the resulting category.  By default,
labels are constructed using <code>"(a,b]"</code> interval notation.  If
<code>labels = FALSE</code>, simple integer codes are returned instead of
a factor.</p>
</dd>
<dt><code>right</code></dt><dd><p>logical, indicating if the intervals should be closed on
the right (and open on the left) or vice versa.</p>
</dd>
<dt><code>dig.lab</code></dt><dd><p>integer which is used when labels are not given.  It
determines the number of digits used in formatting the break numbers.</p>
</dd>
<dt><code>ordered_result</code></dt><dd><p>logical: should the result be an ordered factor?</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cut_interval_+3A_width">width</code></td>
<td>
<p>The bin width.</p>
</td></tr>
<tr><td><code id="cut_interval_+3A_center">center</code>, <code id="cut_interval_+3A_boundary">boundary</code></td>
<td>
<p>Specify either the position of edge or the center of
a bin. Since all bins are aligned, specifying the position of a single bin
(which doesn't need to be in the range of the data) affects the location of
all bins. If not specified, uses the &quot;tile layers algorithm&quot;, and sets
the boundary to half of the binwidth.
</p>
<p>To center on integers, <code>width = 1</code> and <code>center = 0</code>.
<code>boundary = 0.5</code>.</p>
</td></tr>
<tr><td><code id="cut_interval_+3A_closed">closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Randall Prium contributed most of the implementation of
<code>cut_width()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>table(cut_interval(1:100, 10))
table(cut_interval(1:100, 11))

set.seed(1)

table(cut_number(runif(1000), 10))

table(cut_width(runif(1000), 0.1))
table(cut_width(runif(1000), 0.1, boundary = 0))
table(cut_width(runif(1000), 0.1, center = 0))
table(cut_width(runif(1000), 0.1, labels = FALSE))
</code></pre>

<hr>
<h2 id='datetime_scale'>Date/time scale constructor</h2><span id='topic+datetime_scale'></span>

<h3>Description</h3>

<p>Date/time scale constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datetime_scale(
  aesthetics,
  transform,
  trans = deprecated(),
  palette,
  breaks = pretty_breaks(),
  minor_breaks = waiver(),
  labels = waiver(),
  date_breaks = waiver(),
  date_labels = waiver(),
  date_minor_breaks = waiver(),
  timezone = NULL,
  guide = "legend",
  call = caller_call(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datetime_scale_+3A_aesthetics">aesthetics</code></td>
<td>
<p>The names of the aesthetics that this scale works with.</p>
</td></tr>
<tr><td><code id="datetime_scale_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="datetime_scale_+3A_trans">trans</code></td>
<td>
<p>For date/time scales, the name of a date/time transformation or
the object itself. Built-in transformations include &quot;hms&quot;, &quot;date&quot; and &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="datetime_scale_+3A_palette">palette</code></td>
<td>
<p>A palette function that when called with a numeric vector with
values between 0 and 1 returns the corresponding output values
(e.g., <code><a href="scales.html#topic+pal_area">scales::pal_area()</a></code>).</p>
</td></tr>
<tr><td><code id="datetime_scale_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the breaks specified by <code>date_breaks</code>
</p>
</li>
<li><p> A <code>Date</code>/<code>POSIXct</code> vector giving positions of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="datetime_scale_+3A_minor_breaks">minor_breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the breaks specified by <code>date_minor_breaks</code>
</p>
</li>
<li><p> A <code>Date</code>/<code>POSIXct</code> vector giving positions of minor breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns minor breaks as
output
</p>
</li></ul>
</td></tr>
<tr><td><code id="datetime_scale_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="datetime_scale_+3A_date_breaks">date_breaks</code></td>
<td>
<p>A string giving the distance between breaks like &quot;2
weeks&quot;, or &quot;10 years&quot;. If both <code>breaks</code> and <code>date_breaks</code> are
specified, <code>date_breaks</code> wins. Valid specifications are 'sec', 'min',
'hour', 'day', 'week', 'month' or 'year', optionally followed by 's'.</p>
</td></tr>
<tr><td><code id="datetime_scale_+3A_date_labels">date_labels</code></td>
<td>
<p>A string giving the formatting specification for the
labels. Codes are defined in <code><a href="base.html#topic+strftime">strftime()</a></code>. If both <code>labels</code>
and <code>date_labels</code> are specified, <code>date_labels</code> wins.</p>
</td></tr>
<tr><td><code id="datetime_scale_+3A_date_minor_breaks">date_minor_breaks</code></td>
<td>
<p>A string giving the distance between minor breaks
like &quot;2 weeks&quot;, or &quot;10 years&quot;. If both <code>minor_breaks</code> and
<code>date_minor_breaks</code> are specified, <code>date_minor_breaks</code> wins. Valid
specifications are 'sec', 'min', 'hour', 'day', 'week', 'month' or 'year',
optionally followed by 's'.</p>
</td></tr>
<tr><td><code id="datetime_scale_+3A_timezone">timezone</code></td>
<td>
<p>The timezone to use for display on the axes. The default
(<code>NULL</code>) uses the timezone encoded in the data.</p>
</td></tr>
<tr><td><code id="datetime_scale_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="datetime_scale_+3A_call">call</code></td>
<td>
<p>The <code>call</code> used to construct the scale for reporting messages.</p>
</td></tr>
<tr><td><code id="datetime_scale_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+continuous_scale">continuous_scale</a></code>
</p>

<dl>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</dd>
<dt><code>rescaler</code></dt><dd><p>A function used to scale the input values to the
range [0, 1]. This is always <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>, except for
diverging and n colour gradients (i.e., <code><a href="#topic+scale_colour_gradient2">scale_colour_gradient2()</a></code>,
<code><a href="#topic+scale_colour_gradientn">scale_colour_gradientn()</a></code>). The <code>rescaler</code> is ignored by position
scales, which always use <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>. Also accepts rlang
<a href="rlang.html#topic+as_function">lambda</a> function notation.</p>
</dd>
<dt><code>oob</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</dd>
<dt><code>na.value</code></dt><dd><p>Missing values will be replaced with this value.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='diamonds'>Prices of over 50,000 round cut diamonds</h2><span id='topic+diamonds'></span>

<h3>Description</h3>

<p>A dataset containing the prices and other attributes of almost 54,000
diamonds. The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diamonds
</code></pre>


<h3>Format</h3>

<p>A data frame with 53940 rows and 10 variables:
</p>

<dl>
<dt>price</dt><dd><p>price in US dollars ($326&ndash;$18,823)</p>
</dd>
<dt>carat</dt><dd><p>weight of the diamond (0.2&ndash;5.01)</p>
</dd>
<dt>cut</dt><dd><p>quality of the cut (Fair, Good, Very Good, Premium, Ideal)</p>
</dd>
<dt>color</dt><dd><p>diamond colour, from D (best) to J (worst)</p>
</dd>
<dt>clarity</dt><dd><p>a measurement of how clear the diamond is (I1 (worst), SI2,
SI1, VS2, VS1, VVS2, VVS1, IF (best))</p>
</dd>
<dt>x</dt><dd><p>length in mm (0&ndash;10.74)</p>
</dd>
<dt>y</dt><dd><p>width in mm (0&ndash;58.9)</p>
</dd>
<dt>z</dt><dd><p>depth in mm (0&ndash;31.8)</p>
</dd>
<dt>depth</dt><dd><p>total depth percentage = z / mean(x, y) = 2 * z / (x + y) (43&ndash;79)</p>
</dd>
<dt>table</dt><dd><p>width of top of diamond relative to widest point (43&ndash;95)</p>
</dd>
</dl>


<hr>
<h2 id='discrete_scale'>Discrete scale constructor</h2><span id='topic+discrete_scale'></span>

<h3>Description</h3>

<p>Discrete scale constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete_scale(
  aesthetics,
  scale_name = deprecated(),
  palette,
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  na.translate = TRUE,
  na.value = NA,
  drop = TRUE,
  guide = "legend",
  position = "left",
  call = caller_call(),
  super = ScaleDiscrete
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete_scale_+3A_aesthetics">aesthetics</code></td>
<td>
<p>The names of the aesthetics that this scale works with.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_scale_name">scale_name</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_palette">palette</code></td>
<td>
<p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="discrete_scale_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="discrete_scale_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="discrete_scale_+3A_expand">expand</code></td>
<td>
<p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_na.translate">na.translate</code></td>
<td>
<p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_na.value">na.value</code></td>
<td>
<p>If <code>na.translate = TRUE</code>, what aesthetic value should the
missing values be displayed as? Does not apply to position scales
where <code>NA</code> is always placed at the far right.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_call">call</code></td>
<td>
<p>The <code>call</code> used to construct the scale for reporting messages.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_super">super</code></td>
<td>
<p>The super class to use for the constructed scale</p>
</td></tr>
</table>

<hr>
<h2 id='draw_key'>Key glyphs for legends</h2><span id='topic+draw_key'></span><span id='topic+draw_key_point'></span><span id='topic+draw_key_abline'></span><span id='topic+draw_key_rect'></span><span id='topic+draw_key_polygon'></span><span id='topic+draw_key_blank'></span><span id='topic+draw_key_boxplot'></span><span id='topic+draw_key_crossbar'></span><span id='topic+draw_key_path'></span><span id='topic+draw_key_vpath'></span><span id='topic+draw_key_dotplot'></span><span id='topic+draw_key_linerange'></span><span id='topic+draw_key_pointrange'></span><span id='topic+draw_key_smooth'></span><span id='topic+draw_key_text'></span><span id='topic+draw_key_label'></span><span id='topic+draw_key_vline'></span><span id='topic+draw_key_timeseries'></span>

<h3>Description</h3>

<p>Each geom has an associated function that draws the key when the geom needs
to be displayed in a legend. These functions are called <code style="white-space: pre;">&#8288;draw_key_*()&#8288;</code>, where
<code>*</code> stands for the name of the respective key glyph. The key glyphs can be
customized for individual geoms by providing a geom with the <code>key_glyph</code>
argument (see <code><a href="#topic+layer">layer()</a></code> or examples below.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_key_point(data, params, size)

draw_key_abline(data, params, size)

draw_key_rect(data, params, size)

draw_key_polygon(data, params, size)

draw_key_blank(data, params, size)

draw_key_boxplot(data, params, size)

draw_key_crossbar(data, params, size)

draw_key_path(data, params, size)

draw_key_vpath(data, params, size)

draw_key_dotplot(data, params, size)

draw_key_linerange(data, params, size)

draw_key_pointrange(data, params, size)

draw_key_smooth(data, params, size)

draw_key_text(data, params, size)

draw_key_label(data, params, size)

draw_key_vline(data, params, size)

draw_key_timeseries(data, params, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_key_+3A_data">data</code></td>
<td>
<p>A single row data frame containing the scaled aesthetics to
display in this key</p>
</td></tr>
<tr><td><code id="draw_key_+3A_params">params</code></td>
<td>
<p>A list of additional parameters supplied to the geom.</p>
</td></tr>
<tr><td><code id="draw_key_+3A_size">size</code></td>
<td>
<p>Width and height of key in mm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(economics, aes(date, psavert, color = "savings rate"))
# key glyphs can be specified by their name
p + geom_line(key_glyph = "timeseries")

# key glyphs can be specified via their drawing function
p + geom_line(key_glyph = draw_key_rect)
</code></pre>

<hr>
<h2 id='economics'>US economic time series</h2><span id='topic+economics'></span><span id='topic+economics_long'></span>

<h3>Description</h3>

<p>This dataset was produced from US economic time series data available from
<a href="https://fred.stlouisfed.org/">https://fred.stlouisfed.org/</a>. <code>economics</code> is in &quot;wide&quot;
format, <code>economics_long</code> is in &quot;long&quot; format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>economics

economics_long
</code></pre>


<h3>Format</h3>

<p>A data frame with 574 rows and 6 variables:
</p>

<dl>
<dt>date</dt><dd><p>Month of data collection</p>
</dd>
<dt>pce</dt><dd><p>personal consumption expenditures, in billions of dollars,
<a href="https://fred.stlouisfed.org/series/PCE">https://fred.stlouisfed.org/series/PCE</a></p>
</dd>
<dt>pop</dt><dd><p>total population, in thousands,
<a href="https://fred.stlouisfed.org/series/POP">https://fred.stlouisfed.org/series/POP</a></p>
</dd>
<dt>psavert</dt><dd><p>personal savings rate,
<a href="https://fred.stlouisfed.org/series/PSAVERT/">https://fred.stlouisfed.org/series/PSAVERT/</a></p>
</dd>
<dt>uempmed</dt><dd><p>median duration of unemployment, in weeks,
<a href="https://fred.stlouisfed.org/series/UEMPMED">https://fred.stlouisfed.org/series/UEMPMED</a></p>
</dd>
<dt>unemploy</dt><dd><p>number of unemployed in thousands,
<a href="https://fred.stlouisfed.org/series/UNEMPLOY">https://fred.stlouisfed.org/series/UNEMPLOY</a></p>
</dd>
</dl>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 2870 rows and 4 columns.
</p>

<hr>
<h2 id='element'>Theme elements</h2><span id='topic+element_blank'></span><span id='topic+element_rect'></span><span id='topic+element_line'></span><span id='topic+element_text'></span><span id='topic+rel'></span><span id='topic+margin'></span>

<h3>Description</h3>

<p>In conjunction with the <a href="#topic+theme">theme</a> system, the <code>element_</code> functions
specify the display of how non-data components of the plot are drawn.
</p>

<ul>
<li> <p><code>element_blank()</code>: draws nothing, and assigns no space.
</p>
</li>
<li> <p><code>element_rect()</code>: borders and backgrounds.
</p>
</li>
<li> <p><code>element_line()</code>: lines.
</p>
</li>
<li> <p><code>element_text()</code>: text.
</p>
</li></ul>

<p><code>rel()</code> is used to specify sizes relative to the parent,
<code>margin()</code> is used to specify the margins of elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_blank()

element_rect(
  fill = NULL,
  colour = NULL,
  linewidth = NULL,
  linetype = NULL,
  color = NULL,
  inherit.blank = FALSE,
  size = deprecated()
)

element_line(
  colour = NULL,
  linewidth = NULL,
  linetype = NULL,
  lineend = NULL,
  color = NULL,
  arrow = NULL,
  inherit.blank = FALSE,
  size = deprecated()
)

element_text(
  family = NULL,
  face = NULL,
  colour = NULL,
  size = NULL,
  hjust = NULL,
  vjust = NULL,
  angle = NULL,
  lineheight = NULL,
  color = NULL,
  margin = NULL,
  debug = NULL,
  inherit.blank = FALSE
)

rel(x)

margin(t = 0, r = 0, b = 0, l = 0, unit = "pt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_+3A_fill">fill</code></td>
<td>
<p>Fill colour.</p>
</td></tr>
<tr><td><code id="element_+3A_colour">colour</code>, <code id="element_+3A_color">color</code></td>
<td>
<p>Line/border colour. Color is an alias for colour.</p>
</td></tr>
<tr><td><code id="element_+3A_linewidth">linewidth</code></td>
<td>
<p>Line/border size in mm.</p>
</td></tr>
<tr><td><code id="element_+3A_linetype">linetype</code></td>
<td>
<p>Line type. An integer (0:8), a name (blank, solid,
dashed, dotted, dotdash, longdash, twodash), or a string with
an even number (up to eight) of hexadecimal digits which give the
lengths in consecutive positions in the string.</p>
</td></tr>
<tr><td><code id="element_+3A_inherit.blank">inherit.blank</code></td>
<td>
<p>Should this element inherit the existence of an
<code>element_blank</code> among its parents? If <code>TRUE</code> the existence of
a blank element among its parents will cause this element to be blank as
well. If <code>FALSE</code> any blank parent element will be ignored when
calculating final element state.</p>
</td></tr>
<tr><td><code id="element_+3A_size">size</code></td>
<td>
<p>text size in pts.</p>
</td></tr>
<tr><td><code id="element_+3A_lineend">lineend</code></td>
<td>
<p>Line end Line end style (round, butt, square)</p>
</td></tr>
<tr><td><code id="element_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code></p>
</td></tr>
<tr><td><code id="element_+3A_family">family</code></td>
<td>
<p>Font family</p>
</td></tr>
<tr><td><code id="element_+3A_face">face</code></td>
<td>
<p>Font face (&quot;plain&quot;, &quot;italic&quot;, &quot;bold&quot;, &quot;bold.italic&quot;)</p>
</td></tr>
<tr><td><code id="element_+3A_hjust">hjust</code></td>
<td>
<p>Horizontal justification (in <code class="reqn">[0, 1]</code>)</p>
</td></tr>
<tr><td><code id="element_+3A_vjust">vjust</code></td>
<td>
<p>Vertical justification (in <code class="reqn">[0, 1]</code>)</p>
</td></tr>
<tr><td><code id="element_+3A_angle">angle</code></td>
<td>
<p>Angle (in <code class="reqn">[0, 360]</code>)</p>
</td></tr>
<tr><td><code id="element_+3A_lineheight">lineheight</code></td>
<td>
<p>Line height</p>
</td></tr>
<tr><td><code id="element_+3A_margin">margin</code></td>
<td>
<p>Margins around the text. See <code><a href="#topic+margin">margin()</a></code> for more
details. When creating a theme, the margins should be placed on the
side of the text facing towards the center of the plot.</p>
</td></tr>
<tr><td><code id="element_+3A_debug">debug</code></td>
<td>
<p>If <code>TRUE</code>, aids visual debugging by drawing a solid
rectangle behind the complete text area, and a point where each label
is anchored.</p>
</td></tr>
<tr><td><code id="element_+3A_x">x</code></td>
<td>
<p>A single number specifying size relative to parent element.</p>
</td></tr>
<tr><td><code id="element_+3A_t">t</code>, <code id="element_+3A_r">r</code>, <code id="element_+3A_b">b</code>, <code id="element_+3A_l">l</code></td>
<td>
<p>Dimensions of each margin. (To remember order, think trouble).</p>
</td></tr>
<tr><td><code id="element_+3A_unit">unit</code></td>
<td>
<p>Default units of dimensions. Defaults to &quot;pt&quot; so it
can be most easily scaled with the text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>element</code>, <code>rel</code>, or <code>margin</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()

plot + theme(
  panel.background = element_blank(),
  axis.text = element_blank()
)

plot + theme(
  axis.text = element_text(colour = "red", size = rel(1.5))
)

plot + theme(
  axis.line = element_line(arrow = arrow())
)

plot + theme(
  panel.background = element_rect(fill = "white"),
  plot.margin = margin(2, 2, 2, 2, "cm"),
  plot.background = element_rect(
    fill = "grey90",
    colour = "black",
    linewidth = 1
  )
)
</code></pre>

<hr>
<h2 id='element_grob'>Generate grid grob from theme element</h2><span id='topic+element_grob'></span>

<h3>Description</h3>

<p>Generate grid grob from theme element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_grob(element, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_grob_+3A_element">element</code></td>
<td>
<p>Theme element, i.e. <code>element_rect</code> or similar.</p>
</td></tr>
<tr><td><code id="element_grob_+3A_...">...</code></td>
<td>
<p>Other arguments to control specific of rendering. This is
usually at least position. See the source code for individual methods.</p>
</td></tr>
</table>

<hr>
<h2 id='element_render'>Render a specified theme element into a grob</h2><span id='topic+element_render'></span>

<h3>Description</h3>

<p>Given a theme object and element name, returns a grob for the element.
Uses <code><a href="#topic+element_grob">element_grob()</a></code> to generate the grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_render(theme, element, ..., name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_render_+3A_theme">theme</code></td>
<td>
<p>The theme object</p>
</td></tr>
<tr><td><code id="element_render_+3A_element">element</code></td>
<td>
<p>The element name given as character vector</p>
</td></tr>
<tr><td><code id="element_render_+3A_...">...</code></td>
<td>
<p>Other arguments provided to <code><a href="#topic+element_grob">element_grob()</a></code></p>
</td></tr>
<tr><td><code id="element_render_+3A_name">name</code></td>
<td>
<p>Character vector added to the name of the grob</p>
</td></tr>
</table>

<hr>
<h2 id='expand_limits'>Expand the plot limits, using data</h2><span id='topic+expand_limits'></span>

<h3>Description</h3>

<p>Sometimes you may want to ensure limits include a single value, for all
panels or all plots.  This function is a thin wrapper around
<code><a href="#topic+geom_blank">geom_blank()</a></code> that makes it easy to add such values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_limits(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_limits_+3A_...">...</code></td>
<td>
<p>named list of aesthetics specifying the value (or values) that
should be included in each scale.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) + geom_point()
p + expand_limits(x = 0)
p + expand_limits(y = c(1, 9))
p + expand_limits(x = 0, y = 0)

ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = cyl)) +
  expand_limits(colour = seq(2, 10, by = 2))
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = factor(cyl))) +
  expand_limits(colour = factor(seq(2, 10, by = 2)))
</code></pre>

<hr>
<h2 id='expansion'>Generate expansion vector for scales</h2><span id='topic+expansion'></span><span id='topic+expand_scale'></span>

<h3>Description</h3>

<p>This is a convenience function for generating scale expansion vectors
for the <code>expand</code> argument of <a href="#topic+scale_x_continuous">scale_(x|y)_continuous</a>
and <a href="#topic+scale_x_discrete">scale_(x|y)_discrete</a>. The expansion vectors are used to
add some space between the data and the axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expansion(mult = 0, add = 0)

expand_scale(mult = 0, add = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expansion_+3A_mult">mult</code></td>
<td>
<p>vector of multiplicative range expansion factors.
If length 1, both the lower and upper limits of the scale
are expanded outwards by <code>mult</code>. If length 2, the lower limit
is expanded by <code>mult[1]</code> and the upper limit by <code>mult[2]</code>.</p>
</td></tr>
<tr><td><code id="expansion_+3A_add">add</code></td>
<td>
<p>vector of additive range expansion constants.
If length 1, both the lower and upper limits of the scale
are expanded outwards by <code>add</code> units. If length 2, the
lower limit is expanded by <code>add[1]</code> and the upper
limit by <code>add[2]</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># No space below the bars but 10% above them
ggplot(mtcars) +
  geom_bar(aes(x = factor(cyl))) +
  scale_y_continuous(expand = expansion(mult = c(0, .1)))

# Add 2 units of space on the left and right of the data
ggplot(subset(diamonds, carat &gt; 2), aes(cut, clarity)) +
  geom_jitter() +
  scale_x_discrete(expand = expansion(add = 2))

# Reproduce the default range expansion used
# when the 'expand' argument is not specified
ggplot(subset(diamonds, carat &gt; 2), aes(cut, price)) +
  geom_jitter() +
  scale_x_discrete(expand = expansion(add = .6)) +
  scale_y_continuous(expand = expansion(mult = .05))

</code></pre>

<hr>
<h2 id='facet_grid'>Lay out panels in a grid</h2><span id='topic+facet_grid'></span>

<h3>Description</h3>

<p><code>facet_grid()</code> forms a matrix of panels defined by row and column
faceting variables. It is most useful when you have two discrete
variables, and all combinations of the variables exist in the data.
If you have only one variable with many levels, try <code><a href="#topic+facet_wrap">facet_wrap()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_grid(
  rows = NULL,
  cols = NULL,
  scales = "fixed",
  space = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  as.table = TRUE,
  switch = NULL,
  drop = TRUE,
  margins = FALSE,
  axes = "margins",
  axis.labels = "all",
  facets = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_grid_+3A_rows">rows</code>, <code id="facet_grid_+3A_cols">cols</code></td>
<td>
<p>A set of variables or expressions quoted by
<code><a href="#topic+vars">vars()</a></code> and defining faceting groups on the rows or columns
dimension. The variables can be named (the names are passed to
<code>labeller</code>).
</p>
<p>For compatibility with the classic interface, <code>rows</code> can also be
a formula with the rows (of the tabular display) on the LHS and
the columns (of the tabular display) on the RHS; the dot in the
formula is used to indicate there should be no faceting on this
dimension (either row or column).</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_scales">scales</code></td>
<td>
<p>Are scales shared across all facets (the default,
<code>"fixed"</code>), or do they vary across rows (<code>"free_x"</code>),
columns (<code>"free_y"</code>), or both rows and columns (<code>"free"</code>)?</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_space">space</code></td>
<td>
<p>If <code>"fixed"</code>, the default, all panels have the same size.
If <code>"free_y"</code> their height will be proportional to the length of the
y scale; if <code>"free_x"</code> their width will be proportional to the
length of the x scale; or if <code>"free"</code> both height and width will
vary.  This setting has no effect unless the appropriate scales also vary.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with <code>vars(cyl, am)</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="#topic+labeller">labeller()</a></code>. You can use different labeling
functions for different kind of labels, for example use <code><a href="#topic+label_parsed">label_parsed()</a></code> for
formatting facet labels. <code><a href="#topic+label_value">label_value()</a></code> is used by default,
check it for more details and pointers to other options.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_as.table">as.table</code></td>
<td>
<p>If <code>TRUE</code>, the default, the facets are laid out like
a table with highest values at the bottom-right. If <code>FALSE</code>, the
facets are laid out like a plot with the highest value at the top-right.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_switch">switch</code></td>
<td>
<p>By default, the labels are displayed on the top and
right of the plot. If <code>"x"</code>, the top labels will be
displayed to the bottom. If <code>"y"</code>, the right-hand side
labels will be displayed to the left. Can also be set to
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the default, all factor levels not used in the
data will automatically be dropped. If <code>FALSE</code>, all factor levels
will be shown, regardless of whether or not they appear in the data.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_margins">margins</code></td>
<td>
<p>Either a logical value or a character
vector. Margins are additional facets which contain all the data
for each of the possible values of the faceting variables. If
<code>FALSE</code>, no additional facets are included (the
default). If <code>TRUE</code>, margins are included for all faceting
variables. If specified as a character vector, it is the names of
variables for which margins are to be created.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_axes">axes</code></td>
<td>
<p>Determines which axes will be drawn. When <code>"margins"</code>
(default), axes will be drawn at the exterior margins. <code>"all_x"</code> and
<code>"all_y"</code> will draw the respective axes at the interior panels too, whereas
<code>"all"</code> will draw all axes at all panels.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_axis.labels">axis.labels</code></td>
<td>
<p>Determines whether to draw labels for interior axes when
the <code>axes</code> argument is not <code>"margins"</code>. When <code>"all"</code> (default), all
interior axes get labels. When <code>"margins"</code>, only the exterior axes get
labels and the interior axes get none. When <code>"all_x"</code> or <code>"all_y"</code>, only
draws the labels at the interior axes in the x- or y-direction
respectively.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_facets">facets</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>rows</code>
and <code>cols</code> instead.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mpg, aes(displ, cty)) + geom_point()

# Use vars() to supply variables from the dataset:
p + facet_grid(rows = vars(drv))
p + facet_grid(cols = vars(cyl))
p + facet_grid(vars(drv), vars(cyl))

# To change plot order of facet grid,
# change the order of variable levels with factor()

# If you combine a facetted dataset with a dataset that lacks those
# faceting variables, the data will be repeated across the missing
# combinations:
df &lt;- data.frame(displ = mean(mpg$displ), cty = mean(mpg$cty))
p +
  facet_grid(cols = vars(cyl)) +
  geom_point(data = df, colour = "red", size = 2)

# When scales are constant, duplicated axes can be shown with
# or without labels
ggplot(mpg, aes(cty, hwy)) +
  geom_point() +
  facet_grid(year ~ drv, axes = "all", axis.labels = "all_x")

# Free scales -------------------------------------------------------
# You can also choose whether the scales should be constant
# across all panels (the default), or whether they should be allowed
# to vary
mt &lt;- ggplot(mtcars, aes(mpg, wt, colour = factor(cyl))) +
  geom_point()

mt + facet_grid(vars(cyl), scales = "free")

# If scales and space are free, then the mapping between position
# and values in the data will be the same across all panels. This
# is particularly useful for categorical axes
ggplot(mpg, aes(drv, model)) +
  geom_point() +
  facet_grid(manufacturer ~ ., scales = "free", space = "free") +
  theme(strip.text.y = element_text(angle = 0))

# Margins ----------------------------------------------------------

# Margins can be specified logically (all yes or all no) or for specific
# variables as (character) variable names
mg &lt;- ggplot(mtcars, aes(x = mpg, y = wt)) + geom_point()
mg + facet_grid(vs + am ~ gear, margins = TRUE)
mg + facet_grid(vs + am ~ gear, margins = "am")
# when margins are made over "vs", since the facets for "am" vary
# within the values of "vs", the marginal facet for "vs" is also
# a margin over "am".
mg + facet_grid(vs + am ~ gear, margins = "vs")

</code></pre>

<hr>
<h2 id='facet_null'>Facet specification: a single panel.</h2><span id='topic+facet_null'></span>

<h3>Description</h3>

<p>Facet specification: a single panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_null(shrink = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_null_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># facet_null is the default faceting specification if you
# don't override it with facet_grid or facet_wrap
ggplot(mtcars, aes(mpg, wt)) + geom_point()
</code></pre>

<hr>
<h2 id='facet_wrap'>Wrap a 1d ribbon of panels into 2d</h2><span id='topic+facet_wrap'></span>

<h3>Description</h3>

<p><code>facet_wrap()</code> wraps a 1d sequence of panels into 2d. This is generally
a better use of screen space than <code><a href="#topic+facet_grid">facet_grid()</a></code> because most
displays are roughly rectangular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_wrap(
  facets,
  nrow = NULL,
  ncol = NULL,
  scales = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  as.table = TRUE,
  switch = deprecated(),
  drop = TRUE,
  dir = "h",
  strip.position = "top",
  axes = "margins",
  axis.labels = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_wrap_+3A_facets">facets</code></td>
<td>
<p>A set of variables or expressions quoted by <code><a href="#topic+vars">vars()</a></code>
and defining faceting groups on the rows or columns dimension.
The variables can be named (the names are passed to <code>labeller</code>).
</p>
<p>For compatibility with the classic interface, can also be a
formula or character vector. Use either a one sided formula, <code>~a + b</code>,
or a character vector, <code>c("a", "b")</code>.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_nrow">nrow</code>, <code id="facet_wrap_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_scales">scales</code></td>
<td>
<p>Should scales be fixed (<code>"fixed"</code>, the default),
free (<code>"free"</code>), or free in one dimension (<code>"free_x"</code>,
<code>"free_y"</code>)?</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with <code>vars(cyl, am)</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="#topic+labeller">labeller()</a></code>. You can use different labeling
functions for different kind of labels, for example use <code><a href="#topic+label_parsed">label_parsed()</a></code> for
formatting facet labels. <code><a href="#topic+label_value">label_value()</a></code> is used by default,
check it for more details and pointers to other options.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_as.table">as.table</code></td>
<td>
<p>If <code>TRUE</code>, the default, the facets are laid out like
a table with highest values at the bottom-right. If <code>FALSE</code>, the
facets are laid out like a plot with the highest value at the top-right.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_switch">switch</code></td>
<td>
<p>By default, the labels are displayed on the top and
right of the plot. If <code>"x"</code>, the top labels will be
displayed to the bottom. If <code>"y"</code>, the right-hand side
labels will be displayed to the left. Can also be set to
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the default, all factor levels not used in the
data will automatically be dropped. If <code>FALSE</code>, all factor levels
will be shown, regardless of whether or not they appear in the data.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_dir">dir</code></td>
<td>
<p>Direction: either <code>"h"</code> for horizontal, the default, or <code>"v"</code>,
for vertical.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_strip.position">strip.position</code></td>
<td>
<p>By default, the labels are displayed on the top of
the plot. Using <code>strip.position</code> it is possible to place the labels on
either of the four sides by setting <code>strip.position = c("top",
  "bottom", "left", "right")</code></p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_axes">axes</code></td>
<td>
<p>Determines which axes will be drawn in case of fixed scales.
When <code>"margins"</code> (default), axes will be drawn at the exterior margins.
<code>"all_x"</code> and <code>"all_y"</code> will draw the respective axes at the interior
panels too, whereas <code>"all"</code> will draw all axes at all panels.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_axis.labels">axis.labels</code></td>
<td>
<p>Determines whether to draw labels for interior axes when
the scale is fixed and the <code>axis</code> argument is not <code>"margins"</code>. When
<code>"all"</code> (default), all interior axes get labels. When <code>"margins"</code>, only
the exterior axes get labels, and the interior axes get none. When
<code>"all_x"</code> or <code>"all_y"</code>, only draws the labels at the interior axes in the
x- or y-direction respectively.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()

# Use vars() to supply faceting variables:
p + facet_wrap(vars(class))

# Control the number of rows and columns with nrow and ncol
p + facet_wrap(vars(class), nrow = 4)


# You can facet by multiple variables
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(vars(cyl, drv))

# Use the `labeller` option to control how labels are printed:
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(vars(cyl, drv), labeller = "label_both")

# To change the order in which the panels appear, change the levels
# of the underlying factor.
mpg$class2 &lt;- reorder(mpg$class, mpg$displ)
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(vars(class2))

# By default, the same scales are used for all panels. You can allow
# scales to vary across the panels with the `scales` argument.
# Free scales make it easier to see patterns within each panel, but
# harder to compare across panels.
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(vars(class), scales = "free")

# When scales are constant, duplicated axes can be shown with
# or without labels
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(vars(class), axes = "all", axis.labels = "all_y")

# To repeat the same data in every panel, simply construct a data frame
# that does not contain the faceting variable.
ggplot(mpg, aes(displ, hwy)) +
  geom_point(data = transform(mpg, class = NULL), colour = "grey85") +
  geom_point() +
  facet_wrap(vars(class))

# Use `strip.position` to display the facet labels at the side of your
# choice. Setting it to `bottom` makes it act as a subtitle for the axis.
# This is typically used with free scales and a theme without boxes around
# strip labels.
ggplot(economics_long, aes(date, value)) +
  geom_line() +
  facet_wrap(vars(variable), scales = "free_y", nrow = 2, strip.position = "top") +
  theme(strip.background = element_blank(), strip.placement = "outside")

</code></pre>

<hr>
<h2 id='faithfuld'>2d density estimate of Old Faithful data</h2><span id='topic+faithfuld'></span>

<h3>Description</h3>

<p>A 2d density estimate of the waiting and eruptions variables data
<a href="datasets.html#topic+faithful">faithful</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faithfuld
</code></pre>


<h3>Format</h3>

<p>A data frame with 5,625 observations and 3 variables:
</p>

<dl>
<dt>eruptions</dt><dd><p>Eruption time in mins</p>
</dd>
<dt>waiting</dt><dd><p>Waiting time to next eruption in mins</p>
</dd>
<dt>density</dt><dd><p>2d density estimate</p>
</dd>
</dl>


<hr>
<h2 id='fill_alpha'>Modify fill transparency</h2><span id='topic+fill_alpha'></span>

<h3>Description</h3>

<p>This works much like <a href="scales.html#topic+alpha">alpha()</a> in that it modifies the
transparency of fill colours. It differs in that <code>fill_alpha()</code> also attempts
to set the transparency of <code style="white-space: pre;">&#8288;&lt;GridPattern&gt;&#8288;</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_alpha(fill, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_alpha_+3A_fill">fill</code></td>
<td>
<p>A fill colour given as a <code>character</code> or <code>integer</code> vector, or as a
(list of) <code style="white-space: pre;">&#8288;&lt;GridPattern&gt;&#8288;</code> object(s).</p>
</td></tr>
<tr><td><code id="fill_alpha_+3A_alpha">alpha</code></td>
<td>
<p>A transparency value between 0 (transparent) and 1 (opaque),
parallel to <code>fill</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of colours, or list of <code style="white-space: pre;">&#8288;&lt;GridPattern&gt;&#8288;</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Typical colour input
fill_alpha("red", 0.5)

if (utils::packageVersion("grid") &gt; "4.2") {
  # Pattern input
  fill_alpha(list(grid::linearGradient()), 0.5)
}
</code></pre>

<hr>
<h2 id='find_panel'>Find panels in a gtable</h2><span id='topic+find_panel'></span><span id='topic+panel_cols'></span><span id='topic+panel_rows'></span>

<h3>Description</h3>

<p>These functions help detect the placement of panels in a gtable, if they are
named with &quot;panel&quot; in the beginning. <code>find_panel()</code> returns the extend of
the panel area, while <code>panel_cols()</code> and <code>panel_rows()</code> returns the
columns and rows that contains panels respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_panel(table)

panel_cols(table)

panel_rows(table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_panel_+3A_table">table</code></td>
<td>
<p>A gtable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with some or all of the columns t(op), r(ight),
b(ottom), and l(eft)
</p>

<hr>
<h2 id='fortify'>Fortify a model with data.</h2><span id='topic+fortify'></span>

<h3>Description</h3>

<p>Rather than using this function, I now recommend using the <span class="pkg">broom</span>
package, which implements a much wider range of methods. <code>fortify()</code>
may be deprecated in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify_+3A_model">model</code></td>
<td>
<p>model or other R object to convert to data frame</p>
</td></tr>
<tr><td><code id="fortify_+3A_data">data</code></td>
<td>
<p>original dataset, if needed</p>
</td></tr>
<tr><td><code id="fortify_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fortify.lm">fortify.lm()</a></code>
</p>

<hr>
<h2 id='fortify-multcomp'>Fortify methods for objects produced by <span class="pkg">multcomp</span></h2><span id='topic+fortify-multcomp'></span><span id='topic+fortify.glht'></span><span id='topic+fortify.confint.glht'></span><span id='topic+fortify.summary.glht'></span><span id='topic+fortify.cld'></span>

<h3>Description</h3>

<p>Fortify methods for objects produced by <span class="pkg">multcomp</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glht'
fortify(model, data, ...)

## S3 method for class 'confint.glht'
fortify(model, data, ...)

## S3 method for class 'summary.glht'
fortify(model, data, ...)

## S3 method for class 'cld'
fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify-multcomp_+3A_model">model</code></td>
<td>
<p>an object of class <code>glht</code>, <code>confint.glht</code>,
<code>summary.glht</code> or <code><a href="multcomp.html#topic+cld">multcomp::cld()</a></code></p>
</td></tr>
<tr><td><code id="fortify-multcomp_+3A_data">data</code>, <code id="fortify-multcomp_+3A_...">...</code></td>
<td>
<p>other arguments to the generic ignored in this method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("multcomp")) {
amod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)
wht &lt;- glht(amod, linfct = mcp(tension = "Tukey"))

fortify(wht)
ggplot(wht, aes(lhs, estimate)) + geom_point()

CI &lt;- confint(wht)
fortify(CI)
ggplot(CI, aes(lhs, estimate, ymin = lwr, ymax = upr)) +
   geom_pointrange()

fortify(summary(wht))
ggplot(mapping = aes(lhs, estimate)) +
   geom_linerange(aes(ymin = lwr, ymax = upr), data = CI) +
   geom_point(aes(size = p), data = summary(wht)) +
   scale_size(transform = "reverse")

cld &lt;- cld(wht)
fortify(cld)
}
</code></pre>

<hr>
<h2 id='fortify.lm'>Supplement the data fitted to a linear model with model fit statistics.</h2><span id='topic+fortify.lm'></span>

<h3>Description</h3>

<p>If you have missing values in your model data, you may need to refit
the model with <code>na.action = na.exclude</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
fortify(model, data = model$model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify.lm_+3A_model">model</code></td>
<td>
<p>linear model</p>
</td></tr>
<tr><td><code id="fortify.lm_+3A_data">data</code></td>
<td>
<p>data set, defaults to data used to fit model</p>
</td></tr>
<tr><td><code id="fortify.lm_+3A_...">...</code></td>
<td>
<p>not used by this method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data with extra columns:
</p>
<table>
<tr><td><code>.hat</code></td>
<td>
<p>Diagonal of the hat matrix</p>
</td></tr>
<tr><td><code>.sigma</code></td>
<td>
<p>Estimate of residual standard deviation when
corresponding observation is dropped from model</p>
</td></tr>
<tr><td><code>.cooksd</code></td>
<td>
<p>Cooks distance, <code><a href="stats.html#topic+cooks.distance">cooks.distance()</a></code></p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted values of model</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>Residuals</p>
</td></tr>
<tr><td><code>.stdresid</code></td>
<td>
<p>Standardised residuals</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(mpg ~ wt, data = mtcars)
head(fortify(mod))
head(fortify(mod, mtcars))

plot(mod, which = 1)

ggplot(mod, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE)

ggplot(mod, aes(.fitted, .stdresid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE)

ggplot(fortify(mod, mtcars), aes(.fitted, .stdresid)) +
  geom_point(aes(colour = factor(cyl)))

ggplot(fortify(mod, mtcars), aes(mpg, .stdresid)) +
  geom_point(aes(colour = factor(cyl)))

plot(mod, which = 2)
ggplot(mod) +
  stat_qq(aes(sample = .stdresid)) +
  geom_abline()

plot(mod, which = 3)
ggplot(mod, aes(.fitted, sqrt(abs(.stdresid)))) +
  geom_point() +
  geom_smooth(se = FALSE)

plot(mod, which = 4)
ggplot(mod, aes(seq_along(.cooksd), .cooksd)) +
  geom_col()

plot(mod, which = 5)
ggplot(mod, aes(.hat, .stdresid)) +
  geom_vline(linewidth = 2, colour = "white", xintercept = 0) +
  geom_hline(linewidth = 2, colour = "white", yintercept = 0) +
  geom_point() + geom_smooth(se = FALSE)

ggplot(mod, aes(.hat, .stdresid)) +
  geom_point(aes(size = .cooksd)) +
  geom_smooth(se = FALSE, linewidth = 0.5)

plot(mod, which = 6)
ggplot(mod, aes(.hat, .cooksd)) +
  geom_vline(xintercept = 0, colour = NA) +
  geom_abline(slope = seq(0, 3, by = 0.5), colour = "white") +
  geom_smooth(se = FALSE) +
  geom_point()

ggplot(mod, aes(.hat, .cooksd)) +
  geom_point(aes(size = .cooksd / .hat)) +
  scale_size_area()
</code></pre>

<hr>
<h2 id='fortify.map'>Fortify method for map objects</h2><span id='topic+fortify.map'></span>

<h3>Description</h3>

<p>This function turns a map into a data frame that can more easily be
plotted with ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map'
fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify.map_+3A_model">model</code></td>
<td>
<p>map object</p>
</td></tr>
<tr><td><code id="fortify.map_+3A_data">data</code></td>
<td>
<p>not used by this method</p>
</td></tr>
<tr><td><code id="fortify.map_+3A_...">...</code></td>
<td>
<p>not used by this method</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+map_data">map_data()</a></code> and <code><a href="#topic+borders">borders()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("maps")) {
ca &lt;- map("county", "ca", plot = FALSE, fill = TRUE)
head(fortify(ca))
ggplot(ca, aes(long, lat)) +
  geom_polygon(aes(group = group))
}

if (require("maps")) {
tx &lt;- map("county", "texas", plot = FALSE, fill = TRUE)
head(fortify(tx))
ggplot(tx, aes(long, lat)) +
  geom_polygon(aes(group = group), colour = "white")
}
</code></pre>

<hr>
<h2 id='fortify.sp'>Fortify method for classes from the sp package.</h2><span id='topic+fortify.sp'></span><span id='topic+fortify.SpatialPolygonsDataFrame'></span><span id='topic+fortify.SpatialPolygons'></span><span id='topic+fortify.Polygons'></span><span id='topic+fortify.Polygon'></span><span id='topic+fortify.SpatialLinesDataFrame'></span><span id='topic+fortify.Lines'></span><span id='topic+fortify.Line'></span>

<h3>Description</h3>

<p>To figure out the correct variable name for region, inspect
<code>as.data.frame(model)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPolygonsDataFrame'
fortify(model, data, region = NULL, ...)

## S3 method for class 'SpatialPolygons'
fortify(model, data, ...)

## S3 method for class 'Polygons'
fortify(model, data, ...)

## S3 method for class 'Polygon'
fortify(model, data, ...)

## S3 method for class 'SpatialLinesDataFrame'
fortify(model, data, ...)

## S3 method for class 'Lines'
fortify(model, data, ...)

## S3 method for class 'Line'
fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify.sp_+3A_model">model</code></td>
<td>
<p><code>SpatialPolygonsDataFrame</code> to convert into a dataframe.</p>
</td></tr>
<tr><td><code id="fortify.sp_+3A_data">data</code></td>
<td>
<p>not used by this method</p>
</td></tr>
<tr><td><code id="fortify.sp_+3A_region">region</code></td>
<td>
<p>name of variable used to split up regions</p>
</td></tr>
<tr><td><code id="fortify.sp_+3A_...">...</code></td>
<td>
<p>not used by this method</p>
</td></tr>
</table>

<hr>
<h2 id='geom_abline'>Reference lines: horizontal, vertical, and diagonal</h2><span id='topic+geom_abline'></span><span id='topic+geom_hline'></span><span id='topic+geom_vline'></span>

<h3>Description</h3>

<p>These geoms add reference lines (sometimes called rules) to a plot, either
horizontal, vertical, or diagonal (specified by slope and intercept).
These are useful for annotating plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_abline(
  mapping = NULL,
  data = NULL,
  ...,
  slope,
  intercept,
  na.rm = FALSE,
  show.legend = NA
)

geom_hline(
  mapping = NULL,
  data = NULL,
  ...,
  yintercept,
  na.rm = FALSE,
  show.legend = NA
)

geom_vline(
  mapping = NULL,
  data = NULL,
  ...,
  xintercept,
  na.rm = FALSE,
  show.legend = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_abline_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_abline_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_abline_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_abline_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_abline_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_abline_+3A_xintercept">xintercept</code>, <code id="geom_abline_+3A_yintercept">yintercept</code>, <code id="geom_abline_+3A_slope">slope</code>, <code id="geom_abline_+3A_intercept">intercept</code></td>
<td>
<p>Parameters that control the
position of the line. If these are set, <code>data</code>, <code>mapping</code> and
<code>show.legend</code> are overridden.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These geoms act slightly differently from other geoms. You can supply the
parameters in two ways: either as arguments to the layer function,
or via aesthetics. If you use arguments, e.g.
<code>geom_abline(intercept = 0, slope = 1)</code>, then behind the scenes
the geom makes a new data frame containing just the data you've supplied.
That means that the lines will be the same in all facets; if you want them
to vary across facets, construct the data frame yourself and use aesthetics.
</p>
<p>Unlike most other geoms, these geoms do not inherit aesthetics from the plot
default, because they do not understand x and y aesthetics which are
commonly set in the plot. They also do not affect the x and y scales.
</p>


<h3>Aesthetics</h3>

<p>These geoms are drawn using <code><a href="#topic+geom_line">geom_line()</a></code> so they support the
same aesthetics: <code>alpha</code>, <code>colour</code>, <code>linetype</code> and
<code>linewidth</code>. They also each have aesthetics that control the position of
the line:
</p>

<ul>
<li> <p><code>geom_vline()</code>: <code>xintercept</code>
</p>
</li>
<li> <p><code>geom_hline()</code>: <code>yintercept</code>
</p>
</li>
<li> <p><code>geom_abline()</code>: <code>slope</code> and <code>intercept</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>See <code><a href="#topic+geom_segment">geom_segment()</a></code> for a more general approach to
adding straight line segments to a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()

# Fixed values
p + geom_vline(xintercept = 5)
p + geom_vline(xintercept = 1:5)
p + geom_hline(yintercept = 20)

p + geom_abline() # Can't see it - outside the range of the data
p + geom_abline(intercept = 20)

# Calculate slope and intercept of line of best fit
coef(lm(mpg ~ wt, data = mtcars))
p + geom_abline(intercept = 37, slope = -5)
# But this is easier to do with geom_smooth:
p + geom_smooth(method = "lm", se = FALSE)

# To show different lines in different facets, use aesthetics
p &lt;- ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  facet_wrap(~ cyl)

mean_wt &lt;- data.frame(cyl = c(4, 6, 8), wt = c(2.28, 3.11, 4.00))
p + geom_hline(aes(yintercept = wt), mean_wt)

# You can also control other aesthetics
ggplot(mtcars, aes(mpg, wt, colour = wt)) +
  geom_point() +
  geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
  facet_wrap(~ cyl)
</code></pre>

<hr>
<h2 id='geom_bar'>Bar charts</h2><span id='topic+geom_bar'></span><span id='topic+geom_col'></span><span id='topic+stat_count'></span>

<h3>Description</h3>

<p>There are two types of bar charts: <code>geom_bar()</code> and <code>geom_col()</code>.
<code>geom_bar()</code> makes the height of the bar proportional to the number of
cases in each group (or if the <code>weight</code> aesthetic is supplied, the sum
of the weights). If you want the heights of the bars to represent values
in the data, use <code>geom_col()</code> instead. <code>geom_bar()</code> uses <code>stat_count()</code> by
default: it counts the number of cases at each x position. <code>geom_col()</code>
uses <code>stat_identity()</code>: it leaves the data as is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_bar(
  mapping = NULL,
  data = NULL,
  stat = "count",
  position = "stack",
  ...,
  just = 0.5,
  width = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_col(
  mapping = NULL,
  data = NULL,
  position = "stack",
  ...,
  just = 0.5,
  width = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_count(
  mapping = NULL,
  data = NULL,
  geom = "bar",
  position = "stack",
  ...,
  width = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_bar_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_just">just</code></td>
<td>
<p>Adjustment for column placement. Set to <code>0.5</code> by default, meaning
that columns will be centered about axis breaks. Set to <code>0</code> or <code>1</code> to place
columns to the left/right of axis breaks. Note that this argument may have
unintended behaviour when used with alternative positions, e.g.
<code>position_dodge()</code>.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_width">width</code></td>
<td>
<p>Bar width. By default, set to 90% of the <code><a href="#topic+resolution">resolution()</a></code> of the
data.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_geom">geom</code>, <code id="geom_bar_+3A_stat">stat</code></td>
<td>
<p>Override the default connection between <code>geom_bar()</code> and
<code>stat_count()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bar chart uses height to represent a value, and so the base of the
bar must always be shown to produce a valid visual comparison.
Proceed with caution when using transformed scales with a bar chart.
It's important to always use a meaningful reference point for the base of the bar.
For example, for log transformations the reference point is 1. In fact, when
using a log scale, <code>geom_bar()</code> automatically places the base of the bar at 1.
Furthermore, never use stacked bars with a transformed scale, because scaling
happens before stacking. As a consequence, the height of bars will be wrong
when stacking occurs with a transformed scale.
</p>
<p>By default, multiple bars occupying the same <code>x</code> position will be stacked
atop one another by <code><a href="#topic+position_stack">position_stack()</a></code>. If you want them to be dodged
side-to-side, use <code><a href="#topic+position_dodge">position_dodge()</a></code> or <code><a href="#topic+position_dodge2">position_dodge2()</a></code>. Finally,
<code><a href="#topic+position_fill">position_fill()</a></code> shows relative proportions at each <code>x</code> by stacking the
bars and then standardising each bar to have the same height.
</p>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Aesthetics</h3>

<p><code>geom_bar()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>
<p><code>geom_col()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>
<p><code>stat_count()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code> <em>or</em> <code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(count)</code><br /> number of points in bin.
</p>
</li>
<li> <p><code>after_stat(prop)</code><br /> groupwise proportion
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geom_histogram">geom_histogram()</a></code> for continuous data,
<code><a href="#topic+position_dodge">position_dodge()</a></code> and <code><a href="#topic+position_dodge2">position_dodge2()</a></code> for creating side-by-side
bar charts.
</p>
<p><code><a href="#topic+stat_bin">stat_bin()</a></code>, which bins data in ranges and counts the
cases in each range. It differs from <code>stat_count()</code>, which counts the
number of cases at each <code>x</code> position (without binning into ranges).
<code><a href="#topic+stat_bin">stat_bin()</a></code> requires continuous <code>x</code> data, whereas
<code>stat_count()</code> can be used for both discrete and continuous <code>x</code> data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># geom_bar is designed to make it easy to create bar charts that show
# counts (or sums of weights)
g &lt;- ggplot(mpg, aes(class))
# Number of cars in each class:
g + geom_bar()
# Total engine displacement of each class
g + geom_bar(aes(weight = displ))
# Map class to y instead to flip the orientation
ggplot(mpg) + geom_bar(aes(y = class))

# Bar charts are automatically stacked when multiple bars are placed
# at the same location. The order of the fill is designed to match
# the legend
g + geom_bar(aes(fill = drv))

# If you need to flip the order (because you've flipped the orientation)
# call position_stack() explicitly:
ggplot(mpg, aes(y = class)) +
 geom_bar(aes(fill = drv), position = position_stack(reverse = TRUE)) +
 theme(legend.position = "top")

# To show (e.g.) means, you need geom_col()
df &lt;- data.frame(trt = c("a", "b", "c"), outcome = c(2.3, 1.9, 3.2))
ggplot(df, aes(trt, outcome)) +
  geom_col()
# But geom_point() displays exactly the same information and doesn't
# require the y-axis to touch zero.
ggplot(df, aes(trt, outcome)) +
  geom_point()

# You can also use geom_bar() with continuous data, in which case
# it will show counts at unique locations
df &lt;- data.frame(x = rep(c(2.9, 3.1, 4.5), c(5, 10, 4)))
ggplot(df, aes(x)) + geom_bar()
# cf. a histogram of the same data
ggplot(df, aes(x)) + geom_histogram(binwidth = 0.5)

# Use `just` to control how columns are aligned with axis breaks:
df &lt;- data.frame(x = as.Date(c("2020-01-01", "2020-02-01")), y = 1:2)
# Columns centered on the first day of the month
ggplot(df, aes(x, y)) + geom_col(just = 0.5)
# Columns begin on the first day of the month
ggplot(df, aes(x, y)) + geom_col(just = 1)
</code></pre>

<hr>
<h2 id='geom_bin_2d'>Heatmap of 2d bin counts</h2><span id='topic+geom_bin_2d'></span><span id='topic+geom_bin2d'></span><span id='topic+stat_bin_2d'></span><span id='topic+stat_bin2d'></span>

<h3>Description</h3>

<p>Divides the plane into rectangles, counts the number of cases in
each rectangle, and then (by default) maps the number of cases to the
rectangle's fill. This is a useful alternative to <code><a href="#topic+geom_point">geom_point()</a></code>
in the presence of overplotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_bin_2d(
  mapping = NULL,
  data = NULL,
  stat = "bin2d",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_bin_2d(
  mapping = NULL,
  data = NULL,
  geom = "tile",
  position = "identity",
  ...,
  bins = 30,
  binwidth = NULL,
  drop = TRUE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_bin_2d_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_bin_2d_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_bin_2d_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_bin_2d_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_bin_2d_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_bin_2d_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_bin_2d_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_bin_2d_+3A_geom">geom</code>, <code id="geom_bin_2d_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_bin_2d()</code> and <code>stat_bin_2d()</code>.</p>
</td></tr>
<tr><td><code id="geom_bin_2d_+3A_bins">bins</code></td>
<td>
<p>numeric vector giving number of bins in both vertical and
horizontal directions. Set to 30 by default.</p>
</td></tr>
<tr><td><code id="geom_bin_2d_+3A_binwidth">binwidth</code></td>
<td>
<p>Numeric vector giving bin width in both vertical and
horizontal directions. Overrides <code>bins</code> if both set.</p>
</td></tr>
<tr><td><code id="geom_bin_2d_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> removes all cells with 0 counts.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_bin_2d()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(count)</code><br /> number of points in bin.
</p>
</li>
<li> <p><code>after_stat(density)</code><br /> density of points in bin, scaled to integrate to 1.
</p>
</li>
<li> <p><code>after_stat(ncount)</code><br /> count, scaled to maximum of 1.
</p>
</li>
<li> <p><code>after_stat(ndensity)</code><br /> density, scaled to a maximum of 1.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+stat_bin_hex">stat_bin_hex()</a></code> for hexagonal binning
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- ggplot(diamonds, aes(x, y)) + xlim(4, 10) + ylim(4, 10)
d + geom_bin_2d()

# You can control the size of the bins by specifying the number of
# bins in each direction:
d + geom_bin_2d(bins = 10)
d + geom_bin_2d(bins = 30)

# Or by specifying the width of the bins
d + geom_bin_2d(binwidth = c(0.1, 0.1))
</code></pre>

<hr>
<h2 id='geom_blank'>Draw nothing</h2><span id='topic+geom_blank'></span>

<h3>Description</h3>

<p>The blank geom draws nothing, but can be a useful way of ensuring common
scales between different plots. See <code><a href="#topic+expand_limits">expand_limits()</a></code> for
more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_blank(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_blank_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars, aes(wt, mpg))
# Nothing to see here!
</code></pre>

<hr>
<h2 id='geom_boxplot'>A box and whiskers plot (in the style of Tukey)</h2><span id='topic+geom_boxplot'></span><span id='topic+stat_boxplot'></span>

<h3>Description</h3>

<p>The boxplot compactly displays the distribution of a continuous variable.
It visualises five summary statistics (the median, two hinges
and two whiskers), and all &quot;outlying&quot; points individually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_boxplot(
  mapping = NULL,
  data = NULL,
  stat = "boxplot",
  position = "dodge2",
  ...,
  outliers = TRUE,
  outlier.colour = NULL,
  outlier.color = NULL,
  outlier.fill = NULL,
  outlier.shape = 19,
  outlier.size = 1.5,
  outlier.stroke = 0.5,
  outlier.alpha = NULL,
  notch = FALSE,
  notchwidth = 0.5,
  staplewidth = 0,
  varwidth = FALSE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_boxplot(
  mapping = NULL,
  data = NULL,
  geom = "boxplot",
  position = "dodge2",
  ...,
  coef = 1.5,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_boxplot_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_outliers">outliers</code></td>
<td>
<p>Whether to display (<code>TRUE</code>) or discard (<code>FALSE</code>) outliers
from the plot. Hiding or discarding outliers can be useful when, for
example, raw data points need to be displayed on top of the boxplot.
By discarding outliers, the axis limits will adapt to the box and whiskers
only, not the full data range. If outliers need to be hidden and the axes
needs to show the full data range, please use <code>outlier.shape = NA</code> instead.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_outlier.colour">outlier.colour</code>, <code id="geom_boxplot_+3A_outlier.color">outlier.color</code>, <code id="geom_boxplot_+3A_outlier.fill">outlier.fill</code>, <code id="geom_boxplot_+3A_outlier.shape">outlier.shape</code>, <code id="geom_boxplot_+3A_outlier.size">outlier.size</code>, <code id="geom_boxplot_+3A_outlier.stroke">outlier.stroke</code>, <code id="geom_boxplot_+3A_outlier.alpha">outlier.alpha</code></td>
<td>
<p>Default aesthetics for outliers. Set to <code>NULL</code> to inherit from the
aesthetics used for the box.
</p>
<p>In the unlikely event you specify both US and UK spellings of colour, the
US spelling will take precedence.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_notch">notch</code></td>
<td>
<p>If <code>FALSE</code> (default) make a standard box plot. If
<code>TRUE</code>, make a notched box plot. Notches are used to compare groups;
if the notches of two boxes do not overlap, this suggests that the medians
are significantly different.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_notchwidth">notchwidth</code></td>
<td>
<p>For a notched box plot, width of the notch relative to
the body (defaults to <code>notchwidth = 0.5</code>).</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_staplewidth">staplewidth</code></td>
<td>
<p>The relative width of staples to the width of the box.
Staples mark the ends of the whiskers with a line.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_varwidth">varwidth</code></td>
<td>
<p>If <code>FALSE</code> (default) make a standard box plot. If
<code>TRUE</code>, boxes are drawn with widths proportional to the
square-roots of the number of observations in the groups (possibly
weighted, using the <code>weight</code> aesthetic).</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_geom">geom</code>, <code id="geom_boxplot_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_boxplot()</code> and <code>stat_boxplot()</code>.</p>
</td></tr>
<tr><td><code id="geom_boxplot_+3A_coef">coef</code></td>
<td>
<p>Length of the whiskers as multiple of IQR. Defaults to 1.5.</p>
</td></tr>
</table>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Summary statistics</h3>

<p>The lower and upper hinges correspond to the first and third quartiles
(the 25th and 75th percentiles). This differs slightly from the method used
by the <code><a href="graphics.html#topic+boxplot">boxplot()</a></code> function, and may be apparent with small samples.
See <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats()</a></code> for more information on how hinge
positions are calculated for <code><a href="graphics.html#topic+boxplot">boxplot()</a></code>.
</p>
<p>The upper whisker extends from the hinge to the largest value no further than
1.5 * IQR from the hinge (where IQR is the inter-quartile range, or distance
between the first and third quartiles). The lower whisker extends from the
hinge to the smallest value at most 1.5 * IQR of the hinge. Data beyond the
end of the whiskers are called &quot;outlying&quot; points and are plotted
individually.
</p>
<p>In a notched box plot, the notches extend <code>1.58 * IQR / sqrt(n)</code>.
This gives a roughly 95% confidence interval for comparing medians.
See McGill et al. (1978) for more details.
</p>


<h3>Aesthetics</h3>

<p><code>geom_boxplot()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code> <em>or</em> <code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><strong><code>lower</code> <em>or</em> <code>xlower</code></strong>
</p>
</li>
<li> <p><strong><code>upper</code> <em>or</em> <code>xupper</code></strong>
</p>
</li>
<li> <p><strong><code>middle</code> <em>or</em> <code>xmiddle</code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">ymin</a></code> <em>or</em> <code><a href="#topic+aes_position">xmin</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">ymax</a></code> <em>or</em> <code><a href="#topic+aes_position">xmax</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">shape</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">size</a></code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>. <code>stat_boxplot()</code> provides the following variables, some of  which depend on the orientation:
</p>

<ul>
<li> <p><code>after_stat(width)</code><br /> width of boxplot.
</p>
</li>
<li> <p><code>after_stat(ymin)</code> <em>or</em> <code>after_stat(xmin)</code><br /> lower whisker = smallest observation greater than or equal  to lower hinger - 1.5 * IQR.
</p>
</li>
<li> <p><code>after_stat(lower)</code> <em>or</em> <code>after_stat(xlower)</code><br /> lower hinge, 25% quantile.
</p>
</li>
<li> <p><code>after_stat(notchlower)</code><br /> lower edge of notch = median - 1.58 * IQR / sqrt(n).
</p>
</li>
<li> <p><code>after_stat(middle)</code> <em>or</em> <code>after_stat(xmiddle)</code><br /> median, 50% quantile.
</p>
</li>
<li> <p><code>after_stat(notchupper)</code><br /> upper edge of notch = median + 1.58 * IQR / sqrt(n).
</p>
</li>
<li> <p><code>after_stat(upper)</code> <em>or</em> <code>after_stat(xupper)</code><br /> upper hinge, 75% quantile.
</p>
</li>
<li> <p><code>after_stat(ymax)</code> <em>or</em> <code>after_stat(xmax)</code><br /> upper whisker = largest observation less than or equal to  upper hinger + 1.5 * IQR.
</p>
</li></ul>



<h3>References</h3>

<p>McGill, R., Tukey, J. W. and Larsen, W. A. (1978) Variations of
box plots. The American Statistician 32, 12-16.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_quantile">geom_quantile()</a></code> for continuous <code>x</code>,
<code><a href="#topic+geom_violin">geom_violin()</a></code> for a richer display of the distribution, and
<code><a href="#topic+geom_jitter">geom_jitter()</a></code> for a useful technique for small data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mpg, aes(class, hwy))
p + geom_boxplot()
# Orientation follows the discrete axis
ggplot(mpg, aes(hwy, class)) + geom_boxplot()

p + geom_boxplot(notch = TRUE)
p + geom_boxplot(varwidth = TRUE)
p + geom_boxplot(fill = "white", colour = "#3366FF")
# By default, outlier points match the colour of the box. Use
# outlier.colour to override
p + geom_boxplot(outlier.colour = "red", outlier.shape = 1)
# Remove outliers when overlaying boxplot with original data points
p + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2)

# Boxplots are automatically dodged when any aesthetic is a factor
p + geom_boxplot(aes(colour = drv))

# You can also use boxplots with continuous x, as long as you supply
# a grouping variable. cut_width is particularly useful
ggplot(diamonds, aes(carat, price)) +
  geom_boxplot()
ggplot(diamonds, aes(carat, price)) +
  geom_boxplot(aes(group = cut_width(carat, 0.25)))
# Adjust the transparency of outliers using outlier.alpha
ggplot(diamonds, aes(carat, price)) +
  geom_boxplot(aes(group = cut_width(carat, 0.25)), outlier.alpha = 0.1)


# It's possible to draw a boxplot with your own computations if you
# use stat = "identity":
set.seed(1)
y &lt;- rnorm(100)
df &lt;- data.frame(
  x = 1,
  y0 = min(y),
  y25 = quantile(y, 0.25),
  y50 = median(y),
  y75 = quantile(y, 0.75),
  y100 = max(y)
)
ggplot(df, aes(x)) +
  geom_boxplot(
   aes(ymin = y0, lower = y25, middle = y50, upper = y75, ymax = y100),
   stat = "identity"
 )

</code></pre>

<hr>
<h2 id='geom_contour'>2D contours of a 3D surface</h2><span id='topic+geom_contour'></span><span id='topic+geom_contour_filled'></span><span id='topic+stat_contour'></span><span id='topic+stat_contour_filled'></span>

<h3>Description</h3>

<p>ggplot2 can not draw true 3D surfaces, but you can use <code>geom_contour()</code>,
<code>geom_contour_filled()</code>, and <code><a href="#topic+geom_tile">geom_tile()</a></code> to visualise 3D surfaces in 2D.
</p>
<p>These functions require regular data, where the <code>x</code> and <code>y</code> coordinates
form an equally spaced grid, and each combination of <code>x</code> and <code>y</code> appears
once. Missing values of <code>z</code> are allowed, but contouring will only work for
grid points where all four corners are non-missing. If you have irregular
data, you'll need to first interpolate on to a grid before visualising,
using <code><a href="interp.html#topic+interp">interp::interp()</a></code>, <code><a href="akima.html#topic+bilinear">akima::bilinear()</a></code>, or similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_contour(
  mapping = NULL,
  data = NULL,
  stat = "contour",
  position = "identity",
  ...,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_contour_filled(
  mapping = NULL,
  data = NULL,
  stat = "contour_filled",
  position = "identity",
  ...,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_contour(
  mapping = NULL,
  data = NULL,
  geom = "contour",
  position = "identity",
  ...,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_contour_filled(
  mapping = NULL,
  data = NULL,
  geom = "contour_filled",
  position = "identity",
  ...,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_contour_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_bins">bins</code></td>
<td>
<p>Number of contour bins. Overridden by <code>breaks</code>.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the contour bins. Overridden by <code>bins</code>.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Numeric vector to set the contour breaks
</p>
</li>
<li><p> A function that takes the range of the data and binwidth as input
and returns breaks as output. A function can be created from a formula
(e.g. ~ fullseq(.x, .y)).
</p>
</li></ul>

<p>Overrides <code>binwidth</code> and <code>bins</code>. By default, this is a vector of length
ten with <code><a href="base.html#topic+pretty">pretty()</a></code> breaks.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_contour()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>
<p><code>geom_contour_filled()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code>subgroup</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>
<p><code>stat_contour()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><strong><code>z</code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code>order</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>
<p><code>stat_contour_filled()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><strong><code>z</code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code>order</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>. The computed variables differ somewhat for contour lines  (computed by <code>stat_contour()</code>) and contour bands (filled contours,  computed by <code>stat_contour_filled()</code>). The variables <code>nlevel</code> and <code>piece</code>  are available for both, whereas <code>level_low</code>, <code>level_high</code>, and <code>level_mid</code>  are only available for bands. The variable <code>level</code> is a numeric or a factor  depending on whether lines or bands are calculated.
</p>

<ul>
<li> <p><code>after_stat(level)</code><br /> Height of contour. For contour lines, this is a numeric vector  that represents bin boundaries. For contour bands, this is an ordered  factor that represents bin ranges.
</p>
</li>
<li> <p><code>after_stat(level_low)</code>, <code>after_stat(level_high)</code>, <code>after_stat(level_mid)</code><br /> (contour bands only) Lower and upper  bin boundaries for each band, as well as the mid point between boundaries.
</p>
</li>
<li> <p><code>after_stat(nlevel)</code><br /> Height of contour, scaled to a maximum of 1.
</p>
</li>
<li> <p><code>after_stat(piece)</code><br /> Contour piece (an integer).
</p>
</li></ul>



<h3>Dropped variables</h3>


<dl>
<dt><code>z</code></dt><dd><p>After contouring, the z values of individual data points are no longer available.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+geom_density_2d">geom_density_2d()</a></code>: 2d density contours
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic plot
v &lt;- ggplot(faithfuld, aes(waiting, eruptions, z = density))
v + geom_contour()

# Or compute from raw data
ggplot(faithful, aes(waiting, eruptions)) +
  geom_density_2d()


# use geom_contour_filled() for filled contours
v + geom_contour_filled()

# Setting bins creates evenly spaced contours in the range of the data
v + geom_contour(bins = 3)
v + geom_contour(bins = 5)

# Setting binwidth does the same thing, parameterised by the distance
# between contours
v + geom_contour(binwidth = 0.01)
v + geom_contour(binwidth = 0.001)

# Other parameters
v + geom_contour(aes(colour = after_stat(level)))
v + geom_contour(colour = "red")
v + geom_raster(aes(fill = density)) +
  geom_contour(colour = "white")

</code></pre>

<hr>
<h2 id='geom_count'>Count overlapping points</h2><span id='topic+geom_count'></span><span id='topic+stat_sum'></span>

<h3>Description</h3>

<p>This is a variant <code><a href="#topic+geom_point">geom_point()</a></code> that counts the number of
observations at each location, then maps the count to point area. It
useful when you have discrete data and overplotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_count(
  mapping = NULL,
  data = NULL,
  stat = "sum",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_sum(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_count_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_count_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_geom">geom</code>, <code id="geom_count_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_count()</code> and <code>stat_sum()</code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_point()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">shape</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">size</a></code>
</p>
</li>
<li> <p><code>stroke</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(n)</code><br /> Number of observations at position.
</p>
</li>
<li> <p><code>after_stat(prop)</code><br /> Percent of points in that panel at that position.
</p>
</li></ul>



<h3>See Also</h3>

<p>For continuous <code>x</code> and <code>y</code>, use <code><a href="#topic+geom_bin_2d">geom_bin_2d()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mpg, aes(cty, hwy)) +
 geom_point()

ggplot(mpg, aes(cty, hwy)) +
 geom_count()

# Best used in conjunction with scale_size_area which ensures that
# counts of zero would be given size 0. Doesn't make much different
# here because the smallest count is already close to 0.
ggplot(mpg, aes(cty, hwy)) +
 geom_count() +
 scale_size_area()

# Display proportions instead of counts -------------------------------------
# By default, all categorical variables in the plot form the groups.
# Specifying geom_count without a group identifier leads to a plot which is
# not useful:
d &lt;- ggplot(diamonds, aes(x = cut, y = clarity))
d + geom_count(aes(size = after_stat(prop)))
# To correct this problem and achieve a more desirable plot, we need
# to specify which group the proportion is to be calculated over.
d + geom_count(aes(size = after_stat(prop), group = 1)) +
  scale_size_area(max_size = 10)

# Or group by x/y variables to have rows/columns sum to 1.
d + geom_count(aes(size = after_stat(prop), group = cut)) +
  scale_size_area(max_size = 10)
d + geom_count(aes(size = after_stat(prop), group = clarity)) +
  scale_size_area(max_size = 10)
</code></pre>

<hr>
<h2 id='geom_crossbar'>Vertical intervals: lines, crossbars &amp; errorbars</h2><span id='topic+geom_crossbar'></span><span id='topic+geom_errorbar'></span><span id='topic+geom_linerange'></span><span id='topic+geom_pointrange'></span>

<h3>Description</h3>

<p>Various ways of representing a vertical interval defined by <code>x</code>,
<code>ymin</code> and <code>ymax</code>. Each case draws a single graphical object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_crossbar(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  fatten = 2.5,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_errorbar(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_linerange(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_pointrange(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  fatten = 4,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_crossbar_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_fatten">fatten</code></td>
<td>
<p>A multiplicative factor used to increase the size of the
middle bar in <code>geom_crossbar()</code> and the middle point in
<code>geom_pointrange()</code>.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Aesthetics</h3>

<p><code>geom_linerange()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code> <em>or</em> <code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">ymin</a></code> <em>or</em> <code><a href="#topic+aes_position">xmin</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">ymax</a></code> <em>or</em> <code><a href="#topic+aes_position">xmax</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Note that <code>geom_pointrange()</code> also understands <code>size</code> for the size of the points.
</p>
<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stat_summary">stat_summary()</a></code> for examples of these guys in use,
<code><a href="#topic+geom_smooth">geom_smooth()</a></code> for continuous analogue,
<code><a href="#topic+geom_errorbarh">geom_errorbarh()</a></code> for a horizontal error bar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a simple example dataset
df &lt;- data.frame(
  trt = factor(c(1, 1, 2, 2)),
  resp = c(1, 5, 3, 4),
  group = factor(c(1, 2, 1, 2)),
  upper = c(1.1, 5.3, 3.3, 4.2),
  lower = c(0.8, 4.6, 2.4, 3.6)
)

p &lt;- ggplot(df, aes(trt, resp, colour = group))
p + geom_linerange(aes(ymin = lower, ymax = upper))
p + geom_pointrange(aes(ymin = lower, ymax = upper))
p + geom_crossbar(aes(ymin = lower, ymax = upper), width = 0.2)
p + geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)

# Flip the orientation by changing mapping
ggplot(df, aes(resp, trt, colour = group)) +
  geom_linerange(aes(xmin = lower, xmax = upper))

# Draw lines connecting group means
p +
  geom_line(aes(group = group)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)

# If you want to dodge bars and errorbars, you need to manually
# specify the dodge width
p &lt;- ggplot(df, aes(trt, resp, fill = group))
p +
 geom_col(position = "dodge") +
 geom_errorbar(aes(ymin = lower, ymax = upper), position = "dodge", width = 0.25)

# Because the bars and errorbars have different widths
# we need to specify how wide the objects we are dodging are
dodge &lt;- position_dodge(width=0.9)
p +
  geom_col(position = dodge) +
  geom_errorbar(aes(ymin = lower, ymax = upper), position = dodge, width = 0.25)

# When using geom_errorbar() with position_dodge2(), extra padding will be
# needed between the error bars to keep them aligned with the bars.
p +
geom_col(position = "dodge2") +
geom_errorbar(
  aes(ymin = lower, ymax = upper),
  position = position_dodge2(width = 0.5, padding = 0.5)
)
</code></pre>

<hr>
<h2 id='geom_density'>Smoothed density estimates</h2><span id='topic+geom_density'></span><span id='topic+stat_density'></span>

<h3>Description</h3>

<p>Computes and draws kernel density estimate, which is a smoothed version of
the histogram. This is a useful alternative to the histogram for continuous
data that comes from an underlying smooth distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_density(
  mapping = NULL,
  data = NULL,
  stat = "density",
  position = "identity",
  ...,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  outline.type = "upper"
)

stat_density(
  mapping = NULL,
  data = NULL,
  geom = "area",
  position = "stack",
  ...,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n = 512,
  trim = FALSE,
  na.rm = FALSE,
  bounds = c(-Inf, Inf),
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_density_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_density_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_outline.type">outline.type</code></td>
<td>
<p>Type of the outline of the area; <code>"both"</code> draws both the
upper and lower lines, <code>"upper"</code>/<code>"lower"</code> draws the respective lines only.
<code>"full"</code> draws a closed polygon around the area.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_geom">geom</code>, <code id="geom_density_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_density()</code> and <code>stat_density()</code>.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_bw">bw</code></td>
<td>
<p>The smoothing bandwidth to be used.
If numeric, the standard deviation of the smoothing kernel.
If character, a rule to choose the bandwidth, as listed in
<code><a href="stats.html#topic+bandwidth">stats::bw.nrd()</a></code>. Note that automatic calculation of the bandwidth does
not take weights into account.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_adjust">adjust</code></td>
<td>
<p>A multiplicate bandwidth adjustment. This makes it possible
to adjust the bandwidth while still using the a bandwidth estimator.
For example, <code>adjust = 1/2</code> means use half of the default bandwidth.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_kernel">kernel</code></td>
<td>
<p>Kernel. See list of available kernels in <code><a href="stats.html#topic+density">density()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_n">n</code></td>
<td>
<p>number of equally spaced points at which the density is to be
estimated, should be a power of two, see <code><a href="stats.html#topic+density">density()</a></code> for
details</p>
</td></tr>
<tr><td><code id="geom_density_+3A_trim">trim</code></td>
<td>
<p>If <code>FALSE</code>, the default, each density is computed on the
full range of the data. If <code>TRUE</code>, each density is computed over the
range of that group: this typically means the estimated x values will
not line-up, and hence you won't be able to stack density values.
This parameter only matters if you are displaying multiple densities in
one plot or if you are manually adjusting the scale limits.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_bounds">bounds</code></td>
<td>
<p>Known lower and upper bounds for estimated data. Default
<code>c(-Inf, Inf)</code> means that there are no (finite) bounds. If any bound is
finite, boundary effect of default density estimation will be corrected by
reflecting tails outside <code>bounds</code> around their closest edge. Data points
outside of bounds are removed with a warning.</p>
</td></tr>
</table>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Aesthetics</h3>

<p><code>geom_density()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(density)</code><br /> density estimate.
</p>
</li>
<li> <p><code>after_stat(count)</code><br /> density * number of points - useful for stacked density plots.
</p>
</li>
<li> <p><code>after_stat(scaled)</code><br /> density estimate, scaled to maximum of 1.
</p>
</li>
<li> <p><code>after_stat(n)</code><br /> number of points.
</p>
</li>
<li> <p><code>after_stat(ndensity)</code><br /> alias for <code>scaled</code>, to mirror the syntax of <code><a href="#topic+stat_bin">stat_bin()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>See <code><a href="#topic+geom_histogram">geom_histogram()</a></code>, <code><a href="#topic+geom_freqpoly">geom_freqpoly()</a></code> for
other methods of displaying continuous distribution.
See <code><a href="#topic+geom_violin">geom_violin()</a></code> for a compact density display.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(diamonds, aes(carat)) +
  geom_density()
# Map the values to y to flip the orientation
ggplot(diamonds, aes(y = carat)) +
  geom_density()

ggplot(diamonds, aes(carat)) +
  geom_density(adjust = 1/5)
ggplot(diamonds, aes(carat)) +
  geom_density(adjust = 5)

ggplot(diamonds, aes(depth, colour = cut)) +
  geom_density() +
  xlim(55, 70)
ggplot(diamonds, aes(depth, fill = cut, colour = cut)) +
  geom_density(alpha = 0.1) +
  xlim(55, 70)

# Use `bounds` to adjust computation for known data limits
big_diamonds &lt;- diamonds[diamonds$carat &gt;= 1, ]
ggplot(big_diamonds, aes(carat)) +
  geom_density(color = 'red') +
  geom_density(bounds = c(1, Inf), color = 'blue')


# Stacked density plots: if you want to create a stacked density plot, you
# probably want to 'count' (density * n) variable instead of the default
# density

# Loses marginal densities
ggplot(diamonds, aes(carat, fill = cut)) +
  geom_density(position = "stack")
# Preserves marginal densities
ggplot(diamonds, aes(carat, after_stat(count), fill = cut)) +
  geom_density(position = "stack")

# You can use position="fill" to produce a conditional density estimate
ggplot(diamonds, aes(carat, after_stat(count), fill = cut)) +
  geom_density(position = "fill")

</code></pre>

<hr>
<h2 id='geom_density_2d'>Contours of a 2D density estimate</h2><span id='topic+geom_density_2d'></span><span id='topic+geom_density2d'></span><span id='topic+geom_density_2d_filled'></span><span id='topic+geom_density2d_filled'></span><span id='topic+stat_density_2d'></span><span id='topic+stat_density2d'></span><span id='topic+stat_density_2d_filled'></span><span id='topic+stat_density2d_filled'></span>

<h3>Description</h3>

<p>Perform a 2D kernel density estimation using <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code> and
display the results with contours. This can be useful for dealing with
overplotting. This is a 2D version of <code><a href="#topic+geom_density">geom_density()</a></code>. <code>geom_density_2d()</code>
draws contour lines, and <code>geom_density_2d_filled()</code> draws filled contour
bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_density_2d(
  mapping = NULL,
  data = NULL,
  stat = "density_2d",
  position = "identity",
  ...,
  contour_var = "density",
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_density_2d_filled(
  mapping = NULL,
  data = NULL,
  stat = "density_2d_filled",
  position = "identity",
  ...,
  contour_var = "density",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_density_2d(
  mapping = NULL,
  data = NULL,
  geom = "density_2d",
  position = "identity",
  ...,
  contour = TRUE,
  contour_var = "density",
  n = 100,
  h = NULL,
  adjust = c(1, 1),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_density_2d_filled(
  mapping = NULL,
  data = NULL,
  geom = "density_2d_filled",
  position = "identity",
  ...,
  contour = TRUE,
  contour_var = "density",
  n = 100,
  h = NULL,
  adjust = c(1, 1),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_density_2d_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+geom_contour">geom_contour</a></code>
</p>

<dl>
<dt><code>binwidth</code></dt><dd><p>The width of the contour bins. Overridden by <code>bins</code>.</p>
</dd>
<dt><code>bins</code></dt><dd><p>Number of contour bins. Overridden by <code>breaks</code>.</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Numeric vector to set the contour breaks
</p>
</li>
<li><p> A function that takes the range of the data and binwidth as input
and returns breaks as output. A function can be created from a formula
(e.g. ~ fullseq(.x, .y)).
</p>
</li></ul>

<p>Overrides <code>binwidth</code> and <code>bins</code>. By default, this is a vector of length
ten with <code><a href="base.html#topic+pretty">pretty()</a></code> breaks.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_contour_var">contour_var</code></td>
<td>
<p>Character string identifying the variable to contour
by. Can be one of <code>"density"</code>, <code>"ndensity"</code>, or <code>"count"</code>. See the section
on computed variables for details.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_geom">geom</code>, <code id="geom_density_2d_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_density_2d()</code> and <code>stat_density_2d()</code>.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_contour">contour</code></td>
<td>
<p>If <code>TRUE</code>, contour the results of the 2d density
estimation.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_n">n</code></td>
<td>
<p>Number of grid points in each direction.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_h">h</code></td>
<td>
<p>Bandwidth (vector of length two). If <code>NULL</code>, estimated
using <code><a href="MASS.html#topic+bandwidth.nrd">MASS::bandwidth.nrd()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_adjust">adjust</code></td>
<td>
<p>A multiplicative bandwidth adjustment to be used if 'h' is
'NULL'. This makes it possible to adjust the bandwidth while still
using the a bandwidth estimator. For example, <code>adjust = 1/2</code> means
use half of the default bandwidth.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_density_2d()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>
<p><code>geom_density_2d_filled()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code>subgroup</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>. <code>stat_density_2d()</code> and <code>stat_density_2d_filled()</code> compute  different variables depending on whether contouring is turned on or off.  With contouring off (<code>contour = FALSE</code>), both stats behave the same, and  the following variables are provided:
</p>

<ul>
<li> <p><code>after_stat(density)</code><br /> The density estimate.
</p>
</li>
<li> <p><code>after_stat(ndensity)</code><br /> Density estimate, scaled to a maximum of 1.
</p>
</li>
<li> <p><code>after_stat(count)</code><br /> Density estimate * number of observations in group.
</p>
</li>
<li> <p><code>after_stat(n)</code><br /> Number of observations in each group.
</p>
</li></ul>

<p>With contouring on (<code>contour = TRUE</code>), either <code><a href="#topic+stat_contour">stat_contour()</a></code> or
<code><a href="#topic+stat_contour_filled">stat_contour_filled()</a></code> (for contour lines or contour bands,
respectively) is run after the density estimate has been obtained,
and the computed variables are determined by these stats.
Contours are calculated for one of the three types of density estimates
obtained before contouring, <code>density</code>, <code>ndensity</code>, and <code>count</code>. Which
of those should be used is determined by the <code>contour_var</code> parameter.
</p>


<h3>Dropped variables</h3>


<dl>
<dt><code>z</code></dt><dd><p>After density estimation, the z values of individual data points are no longer available.</p>
</dd>
</dl>

<p>If contouring is enabled, then similarly <code>density</code>, <code>ndensity</code>, and <code>count</code>
are no longer available after the contouring pass.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_contour">geom_contour()</a></code>, <code><a href="#topic+geom_contour_filled">geom_contour_filled()</a></code> for information about
how contours are drawn; <code><a href="#topic+geom_bin_2d">geom_bin_2d()</a></code> for another way of dealing with
overplotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- ggplot(faithful, aes(x = eruptions, y = waiting)) +
 geom_point() +
 xlim(0.5, 6) +
 ylim(40, 110)

# contour lines
m + geom_density_2d()


# contour bands
m + geom_density_2d_filled(alpha = 0.5)

# contour bands and contour lines
m + geom_density_2d_filled(alpha = 0.5) +
  geom_density_2d(linewidth = 0.25, colour = "black")

set.seed(4393)
dsmall &lt;- diamonds[sample(nrow(diamonds), 1000), ]
d &lt;- ggplot(dsmall, aes(x, y))
# If you map an aesthetic to a categorical variable, you will get a
# set of contours for each value of that variable
d + geom_density_2d(aes(colour = cut))

# If you draw filled contours across multiple facets, the same bins are
# used across all facets
d + geom_density_2d_filled() + facet_wrap(vars(cut))
# If you want to make sure the peak intensity is the same in each facet,
# use `contour_var = "ndensity"`.
d + geom_density_2d_filled(contour_var = "ndensity") + facet_wrap(vars(cut))
# If you want to scale intensity by the number of observations in each group,
# use `contour_var = "count"`.
d + geom_density_2d_filled(contour_var = "count") + facet_wrap(vars(cut))

# If we turn contouring off, we can use other geoms, such as tiles:
d + stat_density_2d(
  geom = "raster",
  aes(fill = after_stat(density)),
  contour = FALSE
) + scale_fill_viridis_c()
# Or points:
d + stat_density_2d(geom = "point", aes(size = after_stat(density)), n = 20, contour = FALSE)

</code></pre>

<hr>
<h2 id='geom_dotplot'>Dot plot</h2><span id='topic+geom_dotplot'></span>

<h3>Description</h3>

<p>In a dot plot, the width of a dot corresponds to the bin width
(or maximum width, depending on the binning algorithm), and dots are
stacked, with each dot representing one observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dotplot(
  mapping = NULL,
  data = NULL,
  position = "identity",
  ...,
  binwidth = NULL,
  binaxis = "x",
  method = "dotdensity",
  binpositions = "bygroup",
  stackdir = "up",
  stackratio = 1,
  dotsize = 1,
  stackgroups = FALSE,
  origin = NULL,
  right = TRUE,
  width = 0.9,
  drop = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_dotplot_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_binwidth">binwidth</code></td>
<td>
<p>When <code>method</code> is &quot;dotdensity&quot;, this specifies maximum bin
width. When <code>method</code> is &quot;histodot&quot;, this specifies bin width.
Defaults to 1/30 of the range of the data</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_binaxis">binaxis</code></td>
<td>
<p>The axis to bin along, &quot;x&quot; (default) or &quot;y&quot;</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_method">method</code></td>
<td>
<p>&quot;dotdensity&quot; (default) for dot-density binning, or
&quot;histodot&quot; for fixed bin widths (like stat_bin)</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_binpositions">binpositions</code></td>
<td>
<p>When <code>method</code> is &quot;dotdensity&quot;, &quot;bygroup&quot; (default)
determines positions of the bins for each group separately. &quot;all&quot; determines
positions of the bins with all the data taken together; this is used for
aligning dot stacks across multiple groups.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_stackdir">stackdir</code></td>
<td>
<p>which direction to stack the dots. &quot;up&quot; (default),
&quot;down&quot;, &quot;center&quot;, &quot;centerwhole&quot; (centered, but with dots aligned)</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_stackratio">stackratio</code></td>
<td>
<p>how close to stack the dots. Default is 1, where dots
just touch. Use smaller values for closer, overlapping dots.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_dotsize">dotsize</code></td>
<td>
<p>The diameter of the dots relative to <code>binwidth</code>, default 1.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_stackgroups">stackgroups</code></td>
<td>
<p>should dots be stacked across groups? This has the effect
that <code>position = "stack"</code> should have, but can't (because this geom has
some odd properties).</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_origin">origin</code></td>
<td>
<p>When <code>method</code> is &quot;histodot&quot;, origin of first bin</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_right">right</code></td>
<td>
<p>When <code>method</code> is &quot;histodot&quot;, should intervals be closed
on the right (a, b], or not [a, b)</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_width">width</code></td>
<td>
<p>When <code>binaxis</code> is &quot;y&quot;, the spacing of the dot stacks
for dodging.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_drop">drop</code></td>
<td>
<p>If TRUE, remove all bins with zero counts</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two basic approaches: <em>dot-density</em> and <em>histodot</em>.
With dot-density binning, the bin positions are determined by the data and
<code>binwidth</code>, which is the maximum width of each bin. See Wilkinson
(1999) for details on the dot-density binning algorithm. With histodot
binning, the bins have fixed positions and fixed widths, much like a
histogram.
</p>
<p>When binning along the x axis and stacking along the y axis, the numbers on
y axis are not meaningful, due to technical limitations of ggplot2. You can
hide the y axis, as in one of the examples, or manually scale it
to match the number of dots.
</p>


<h3>Aesthetics</h3>

<p><code>geom_dotplot()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code>stroke</code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(x)</code><br /> center of each bin, if <code>binaxis</code> is <code>"x"</code>.
</p>
</li>
<li> <p><code>after_stat(y)</code><br /> center of each bin, if <code>binaxis</code> is <code>"x"</code>.
</p>
</li>
<li> <p><code>after_stat(binwidth)</code><br /> maximum width of each bin if method is <code>"dotdensity"</code>;  width of each bin if method is <code>"histodot"</code>.
</p>
</li>
<li> <p><code>after_stat(count)</code><br /> number of points in bin.
</p>
</li>
<li> <p><code>after_stat(ncount)</code><br /> count, scaled to a maximum of 1.
</p>
</li>
<li> <p><code>after_stat(density)</code><br /> density of points in bin, scaled to integrate to 1, if method  is <code>"histodot"</code>.
</p>
</li>
<li> <p><code>after_stat(ndensity)</code><br /> density, scaled to maximum of 1, if method is <code>"histodot"</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Wilkinson, L. (1999) Dot plots. The American Statistician,
53(3), 276-281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot()

ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot(binwidth = 1.5)

# Use fixed-width bins
ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot(method="histodot", binwidth = 1.5)

# Some other stacking methods
ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot(binwidth = 1.5, stackdir = "center")

ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot(binwidth = 1.5, stackdir = "centerwhole")

# y axis isn't really meaningful, so hide it
ggplot(mtcars, aes(x = mpg)) + geom_dotplot(binwidth = 1.5) +
  scale_y_continuous(NULL, breaks = NULL)

# Overlap dots vertically
ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot(binwidth = 1.5, stackratio = .7)

# Expand dot diameter
ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot(binwidth = 1.5, dotsize = 1.25)

# Change dot fill colour, stroke width
ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot(binwidth = 1.5, fill = "white", stroke = 2)


# Examples with stacking along y axis instead of x
ggplot(mtcars, aes(x = 1, y = mpg)) +
  geom_dotplot(binaxis = "y", stackdir = "center")

ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_dotplot(binaxis = "y", stackdir = "center")

ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_dotplot(binaxis = "y", stackdir = "centerwhole")

ggplot(mtcars, aes(x = factor(vs), fill = factor(cyl), y = mpg)) +
  geom_dotplot(binaxis = "y", stackdir = "center", position = "dodge")

# binpositions="all" ensures that the bins are aligned between groups
ggplot(mtcars, aes(x = factor(am), y = mpg)) +
  geom_dotplot(binaxis = "y", stackdir = "center", binpositions="all")

# Stacking multiple groups, with different fill
ggplot(mtcars, aes(x = mpg, fill = factor(cyl))) +
  geom_dotplot(stackgroups = TRUE, binwidth = 1, binpositions = "all")

ggplot(mtcars, aes(x = mpg, fill = factor(cyl))) +
  geom_dotplot(stackgroups = TRUE, binwidth = 1, method = "histodot")

ggplot(mtcars, aes(x = 1, y = mpg, fill = factor(cyl))) +
  geom_dotplot(binaxis = "y", stackgroups = TRUE, binwidth = 1, method = "histodot")

</code></pre>

<hr>
<h2 id='geom_errorbarh'>Horizontal error bars</h2><span id='topic+geom_errorbarh'></span>

<h3>Description</h3>

<p>A rotated version of <code><a href="#topic+geom_errorbar">geom_errorbar()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_errorbarh(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_errorbarh_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_errorbarh()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">xmin</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">xmax</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code>height</code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  trt = factor(c(1, 1, 2, 2)),
  resp = c(1, 5, 3, 4),
  group = factor(c(1, 2, 1, 2)),
  se = c(0.1, 0.3, 0.3, 0.2)
)

# Define the top and bottom of the errorbars

p &lt;- ggplot(df, aes(resp, trt, colour = group))
p +
  geom_point() +
  geom_errorbarh(aes(xmax = resp + se, xmin = resp - se))

p +
  geom_point() +
  geom_errorbarh(aes(xmax = resp + se, xmin = resp - se, height = .2))
</code></pre>

<hr>
<h2 id='geom_freqpoly'>Histograms and frequency polygons</h2><span id='topic+geom_freqpoly'></span><span id='topic+geom_histogram'></span><span id='topic+stat_bin'></span>

<h3>Description</h3>

<p>Visualise the distribution of a single continuous variable by dividing
the x axis into bins and counting the number of observations in each bin.
Histograms (<code>geom_histogram()</code>) display the counts with bars; frequency
polygons (<code>geom_freqpoly()</code>) display the counts with lines. Frequency
polygons are more suitable when you want to compare the distribution
across the levels of a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_freqpoly(
  mapping = NULL,
  data = NULL,
  stat = "bin",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_histogram(
  mapping = NULL,
  data = NULL,
  stat = "bin",
  position = "stack",
  ...,
  binwidth = NULL,
  bins = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_bin(
  mapping = NULL,
  data = NULL,
  geom = "bar",
  position = "stack",
  ...,
  binwidth = NULL,
  bins = NULL,
  center = NULL,
  boundary = NULL,
  breaks = NULL,
  closed = c("right", "left"),
  pad = FALSE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_freqpoly_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the bins. Can be specified as a numeric value
or as a function that calculates width from unscaled x. Here, &quot;unscaled x&quot;
refers to the original x values in the data, before application of any
scale transformation. When specifying a function along with a grouping
structure, the function will be called once per group.
The default is to use the number of bins in <code>bins</code>,
covering the range of the data. You should always override
this value, exploring multiple widths to find the best to illustrate the
stories in your data.
</p>
<p>The bin width of a date variable is the number of days in each time; the
bin width of a time variable is the number of seconds.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_bins">bins</code></td>
<td>
<p>Number of bins. Overridden by <code>binwidth</code>. Defaults to 30.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_geom">geom</code>, <code id="geom_freqpoly_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_histogram()</code>/<code>geom_freqpoly()</code> and <code>stat_bin()</code>.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_center">center</code>, <code id="geom_freqpoly_+3A_boundary">boundary</code></td>
<td>
<p>bin position specifiers. Only one, <code>center</code> or
<code>boundary</code>, may be specified for a single plot. <code>center</code> specifies the
center of one of the bins. <code>boundary</code> specifies the boundary between two
bins. Note that if either is above or below the range of the data, things
will be shifted by the appropriate integer multiple of <code>binwidth</code>.
For example, to center on integers use <code>binwidth = 1</code> and <code>center = 0</code>, even
if <code>0</code> is outside the range of the data. Alternatively, this same alignment
can be specified with <code>binwidth = 1</code> and <code>boundary = 0.5</code>, even if <code>0.5</code> is
outside the range of the data.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_breaks">breaks</code></td>
<td>
<p>Alternatively, you can supply a numeric vector giving
the bin boundaries. Overrides <code>binwidth</code>, <code>bins</code>, <code>center</code>,
and <code>boundary</code>.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_closed">closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_pad">pad</code></td>
<td>
<p>If <code>TRUE</code>, adds empty bins at either end of x. This ensures
frequency polygons touch 0. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stat_bin()</code> is suitable only for continuous x data. If your x data is
discrete, you probably want to use <code><a href="#topic+stat_count">stat_count()</a></code>.
</p>
<p>By default, the underlying computation (<code>stat_bin()</code>) uses 30 bins;
this is not a good default, but the idea is to get you experimenting with
different number of bins. You can also experiment modifying the <code>binwidth</code> with
<code>center</code> or <code>boundary</code> arguments. <code>binwidth</code> overrides <code>bins</code> so you should do
one change at a time. You may need to look at a few options to uncover
the full story behind your data.
</p>
<p>In addition to <code>geom_histogram()</code>, you can create a histogram plot by using
<code>scale_x_binned()</code> with <code><a href="#topic+geom_bar">geom_bar()</a></code>. This method by default plots tick marks
in between each bar.
</p>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Aesthetics</h3>

<p><code>geom_histogram()</code> uses the same aesthetics as <code><a href="#topic+geom_bar">geom_bar()</a></code>;
<code>geom_freqpoly()</code> uses the same aesthetics as <code><a href="#topic+geom_line">geom_line()</a></code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(count)</code><br /> number of points in bin.
</p>
</li>
<li> <p><code>after_stat(density)</code><br /> density of points in bin, scaled to integrate to 1.
</p>
</li>
<li> <p><code>after_stat(ncount)</code><br /> count, scaled to a maximum of 1.
</p>
</li>
<li> <p><code>after_stat(ndensity)</code><br /> density, scaled to a maximum of 1.
</p>
</li>
<li> <p><code>after_stat(width)</code><br /> widths of bins.
</p>
</li></ul>



<h3>Dropped variables</h3>


<dl>
<dt><code>weight</code></dt><dd><p>After binning, weights of individual data points (if supplied) are no longer available.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+stat_count">stat_count()</a></code>, which counts the number of cases at each x
position, without binning. It is suitable for both discrete and continuous
x data, whereas <code>stat_bin()</code> is suitable only for continuous x data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(diamonds, aes(carat)) +
  geom_histogram()
ggplot(diamonds, aes(carat)) +
  geom_histogram(binwidth = 0.01)
ggplot(diamonds, aes(carat)) +
  geom_histogram(bins = 200)
# Map values to y to flip the orientation
ggplot(diamonds, aes(y = carat)) +
  geom_histogram()

# For histograms with tick marks between each bin, use `geom_bar()` with
# `scale_x_binned()`.
ggplot(diamonds, aes(carat)) +
  geom_bar() +
  scale_x_binned()

# Rather than stacking histograms, it's easier to compare frequency
# polygons
ggplot(diamonds, aes(price, fill = cut)) +
  geom_histogram(binwidth = 500)
ggplot(diamonds, aes(price, colour = cut)) +
  geom_freqpoly(binwidth = 500)

# To make it easier to compare distributions with very different counts,
# put density on the y axis instead of the default count
ggplot(diamonds, aes(price, after_stat(density), colour = cut)) +
  geom_freqpoly(binwidth = 500)

if (require("ggplot2movies")) {
# Often we don't want the height of the bar to represent the
# count of observations, but the sum of some other variable.
# For example, the following plot shows the number of movies
# in each rating.
m &lt;- ggplot(movies, aes(rating))
m + geom_histogram(binwidth = 0.1)

# If, however, we want to see the number of votes cast in each
# category, we need to weight by the votes variable
m +
  geom_histogram(aes(weight = votes), binwidth = 0.1) +
  ylab("votes")

# For transformed scales, binwidth applies to the transformed data.
# The bins have constant width on the transformed scale.
m +
 geom_histogram() +
 scale_x_log10()
m +
  geom_histogram(binwidth = 0.05) +
  scale_x_log10()

# For transformed coordinate systems, the binwidth applies to the
# raw data. The bins have constant width on the original scale.

# Using log scales does not work here, because the first
# bar is anchored at zero, and so when transformed becomes negative
# infinity. This is not a problem when transforming the scales, because
# no observations have 0 ratings.
m +
  geom_histogram(boundary = 0) +
  coord_trans(x = "log10")
# Use boundary = 0, to make sure we don't take sqrt of negative values
m +
  geom_histogram(boundary = 0) +
  coord_trans(x = "sqrt")

# You can also transform the y axis.  Remember that the base of the bars
# has value 0, so log transformations are not appropriate
m &lt;- ggplot(movies, aes(x = rating))
m +
  geom_histogram(binwidth = 0.5) +
  scale_y_sqrt()
}

# You can specify a function for calculating binwidth, which is
# particularly useful when faceting along variables with
# different ranges because the function will be called once per facet
ggplot(economics_long, aes(value)) +
  facet_wrap(~variable, scales = 'free_x') +
  geom_histogram(binwidth = function(x) 2 * IQR(x) / (length(x)^(1/3)))
</code></pre>

<hr>
<h2 id='geom_function'>Draw a function as a continuous curve</h2><span id='topic+geom_function'></span><span id='topic+stat_function'></span>

<h3>Description</h3>

<p>Computes and draws a function as a continuous curve. This makes it easy to
superimpose a function on top of an existing plot. The function is called
with a grid of evenly spaced values along the x axis, and the results are
drawn (by default) with a line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_function(
  mapping = NULL,
  data = NULL,
  stat = "function",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_function(
  mapping = NULL,
  data = NULL,
  geom = "function",
  position = "identity",
  ...,
  fun,
  xlim = NULL,
  n = 101,
  args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_function_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_function_+3A_data">data</code></td>
<td>
<p>Ignored by <code>stat_function()</code>, do not use.</p>
</td></tr>
<tr><td><code id="geom_function_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_function_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_function_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_function_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_function_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_function_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_function_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_function_+3A_fun">fun</code></td>
<td>
<p>Function to use. Either 1) an anonymous function in the base or
rlang formula syntax (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
or 2) a quoted or character name referencing a function; see examples. Must
be vectorised.</p>
</td></tr>
<tr><td><code id="geom_function_+3A_xlim">xlim</code></td>
<td>
<p>Optionally, specify the range of the function.</p>
</td></tr>
<tr><td><code id="geom_function_+3A_n">n</code></td>
<td>
<p>Number of points to interpolate along the x axis.</p>
</td></tr>
<tr><td><code id="geom_function_+3A_args">args</code></td>
<td>
<p>List of additional arguments passed on to the function defined by <code>fun</code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_function()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(x)</code><br /> <code>x</code> values along a grid.
</p>
</li>
<li> <p><code>after_stat(y)</code><br /> values of the function evaluated at corresponding <code>x</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# geom_function() is useful for overlaying functions
set.seed(1492)
ggplot(data.frame(x = rnorm(100)), aes(x)) +
  geom_density() +
  geom_function(fun = dnorm, colour = "red")

# To plot functions without data, specify range of x-axis
base &lt;-
  ggplot() +
  xlim(-5, 5)

base + geom_function(fun = dnorm)

base + geom_function(fun = dnorm, args = list(mean = 2, sd = .5))

# The underlying mechanics evaluate the function at discrete points
# and connect the points with lines
base + stat_function(fun = dnorm, geom = "point")

base + stat_function(fun = dnorm, geom = "point", n = 20)

base + stat_function(fun = dnorm, geom = "polygon", color = "blue", fill = "blue", alpha = 0.5)

base + geom_function(fun = dnorm, n = 20)

# Two functions on the same plot
base +
  geom_function(aes(colour = "normal"), fun = dnorm) +
  geom_function(aes(colour = "t, df = 1"), fun = dt, args = list(df = 1))

# Using a custom anonymous function
base + geom_function(fun = function(x) 0.5*exp(-abs(x)))

base + geom_function(fun = ~ 0.5*exp(-abs(.x)))

# Using a custom named function
f &lt;- function(x) 0.5*exp(-abs(x))

base + geom_function(fun = f)

# Using xlim to restrict the range of function
ggplot(data.frame(x = rnorm(100)), aes(x)) +
geom_density() +
geom_function(fun = dnorm, colour = "red", xlim=c(-1, 1))

# Using xlim to widen the range of function
ggplot(data.frame(x = rnorm(100)), aes(x)) +
geom_density() +
geom_function(fun = dnorm, colour = "red", xlim=c(-7, 7))

</code></pre>

<hr>
<h2 id='geom_hex'>Hexagonal heatmap of 2d bin counts</h2><span id='topic+geom_hex'></span><span id='topic+stat_bin_hex'></span><span id='topic+stat_binhex'></span>

<h3>Description</h3>

<p>Divides the plane into regular hexagons, counts the number of cases in
each hexagon, and then (by default) maps the number of cases to the hexagon
fill.  Hexagon bins avoid the visual artefacts sometimes generated by
the very regular alignment of <code><a href="#topic+geom_bin_2d">geom_bin_2d()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_hex(
  mapping = NULL,
  data = NULL,
  stat = "binhex",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_bin_hex(
  mapping = NULL,
  data = NULL,
  geom = "hex",
  position = "identity",
  ...,
  bins = 30,
  binwidth = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_hex_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_geom">geom</code>, <code id="geom_hex_+3A_stat">stat</code></td>
<td>
<p>Override the default connection between <code>geom_hex()</code> and
<code>stat_bin_hex()</code>.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_bins">bins</code></td>
<td>
<p>numeric vector giving number of bins in both vertical and
horizontal directions. Set to 30 by default.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_binwidth">binwidth</code></td>
<td>
<p>Numeric vector giving bin width in both vertical and
horizontal directions. Overrides <code>bins</code> if both set.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_hex()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(count)</code><br /> number of points in bin.
</p>
</li>
<li> <p><code>after_stat(density)</code><br /> density of points in bin, scaled to integrate to 1.
</p>
</li>
<li> <p><code>after_stat(ncount)</code><br /> count, scaled to maximum of 1.
</p>
</li>
<li> <p><code>after_stat(ndensity)</code><br /> density, scaled to maximum of 1.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+stat_bin_2d">stat_bin_2d()</a></code> for rectangular binning
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- ggplot(diamonds, aes(carat, price))
d + geom_hex()


# You can control the size of the bins by specifying the number of
# bins in each direction:
d + geom_hex(bins = 10)
d + geom_hex(bins = 30)

# Or by specifying the width of the bins
d + geom_hex(binwidth = c(1, 1000))
d + geom_hex(binwidth = c(.1, 500))

</code></pre>

<hr>
<h2 id='geom_jitter'>Jittered points</h2><span id='topic+geom_jitter'></span>

<h3>Description</h3>

<p>The jitter geom is a convenient shortcut for
<code>geom_point(position = "jitter")</code>. It adds a small amount of random
variation to the location of each point, and is a useful way of handling
overplotting caused by discreteness in smaller datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_jitter(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "jitter",
  ...,
  width = NULL,
  height = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_jitter_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_width">width</code>, <code id="geom_jitter_+3A_height">height</code></td>
<td>
<p>Amount of vertical and horizontal jitter. The jitter
is added in both positive and negative directions, so the total spread
is twice the value specified here.
</p>
<p>If omitted, defaults to 40% of the resolution of the data: this means the
jitter values will occupy 80% of the implied bins. Categorical data
is aligned on the integers, so a width or height of 0.5 will spread the
data so it's not possible to see the distinction between the categories.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_point()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">shape</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">size</a></code>
</p>
</li>
<li> <p><code>stroke</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_point">geom_point()</a></code> for regular, unjittered points,
<code><a href="#topic+geom_boxplot">geom_boxplot()</a></code> for another way of looking at the conditional
distribution of a variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mpg, aes(cyl, hwy))
p + geom_point()
p + geom_jitter()

# Add aesthetic mappings
p + geom_jitter(aes(colour = class))

# Use smaller width/height to emphasise categories
ggplot(mpg, aes(cyl, hwy)) +
  geom_jitter()
ggplot(mpg, aes(cyl, hwy)) +
  geom_jitter(width = 0.25)

# Use larger width/height to completely smooth away discreteness
ggplot(mpg, aes(cty, hwy)) +
  geom_jitter()
ggplot(mpg, aes(cty, hwy)) +
  geom_jitter(width = 0.5, height = 0.5)
</code></pre>

<hr>
<h2 id='geom_label'>Text</h2><span id='topic+geom_label'></span><span id='topic+geom_text'></span>

<h3>Description</h3>

<p>Text geoms are useful for labeling plots. They can be used by themselves as
scatterplots or in combination with other geoms, for example, for labeling
points or for annotating the height of bars. <code>geom_text()</code> adds only text
to the plot. <code>geom_label()</code> draws a rectangle behind the text, making it
easier to read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_label(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  label.padding = unit(0.25, "lines"),
  label.r = unit(0.15, "lines"),
  label.size = 0.25,
  size.unit = "mm",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_text(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  size.unit = "mm",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_label_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_label_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_label_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function. Cannot be jointly specified with
<code>nudge_x</code> or <code>nudge_y</code>.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_nudge_x">nudge_x</code>, <code id="geom_label_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_size.unit">size.unit</code></td>
<td>
<p>How the <code>size</code> aesthetic is interpreted: as millimetres
(<code>"mm"</code>, default), points (<code>"pt"</code>), centimetres (<code>"cm"</code>), inches (<code>"in"</code>),
or picas (<code>"pc"</code>).</p>
</td></tr>
<tr><td><code id="geom_label_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when you resize a plot, text labels stay the same size, even
though the size of the plot area changes. This happens because the &quot;width&quot;
and &quot;height&quot; of a text element are 0. Obviously, text labels do have height
and width, but they are physical units, not data units. For the same reason,
stacking and dodging text will not work by default, and axis limits are not
automatically expanded to include all text.
</p>
<p><code>geom_text()</code> and <code>geom_label()</code> add labels for each row in the
data, even if coordinates x, y are set to single values in the call
to <code>geom_label()</code> or <code>geom_text()</code>.
To add labels at specified points use <code><a href="#topic+annotate">annotate()</a></code> with
<code>annotate(geom = "text", ...)</code> or <code>annotate(geom = "label", ...)</code>.
</p>
<p>To automatically position non-overlapping text labels see the
<a href="https://cran.r-project.org/package=ggrepel">ggrepel</a>
package.
</p>


<h3>Aesthetics</h3>

<p><code>geom_text()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><strong><code>label</code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code>angle</code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code>family</code>
</p>
</li>
<li> <p><code>fontface</code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code>hjust</code>
</p>
</li>
<li> <p><code>lineheight</code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">size</a></code>
</p>
</li>
<li> <p><code>vjust</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3><code>geom_label()</code></h3>

<p>Currently <code>geom_label()</code> does not support the <code>check_overlap</code> argument. Also,
it is considerably slower than <code>geom_text()</code>. The <code>fill</code> aesthetic controls
the background colour of the label.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and <code>hjust</code>
aesthetics. These can either be a number between 0 (right/bottom) and
1 (top/left) or a character (<code>"left"</code>, <code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>,
<code>"center"</code>, <code>"top"</code>). There are two special alignments: <code>"inward"</code> and
<code>"outward"</code>. Inward always aligns text towards the center, and outward
aligns it away from the center.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg, label = rownames(mtcars)))

p + geom_text()
# Avoid overlaps
p + geom_text(check_overlap = TRUE)
# Labels with background
p + geom_label()
# Change size of the label
p + geom_text(size = 10)

# Set aesthetics to fixed value
p +
  geom_point() +
  geom_text(hjust = 0, nudge_x = 0.05)
p +
  geom_point() +
  geom_text(vjust = 0, nudge_y = 0.5)
p +
  geom_point() +
  geom_text(angle = 45)
## Not run: 
# Doesn't work on all systems
p +
  geom_text(family = "Times New Roman")

## End(Not run)

# Add aesthetic mappings
p + geom_text(aes(colour = factor(cyl)))
p + geom_text(aes(colour = factor(cyl))) +
  scale_colour_discrete(l = 40)
p + geom_label(aes(fill = factor(cyl)), colour = "white", fontface = "bold")

p + geom_text(aes(size = wt))
# Scale height of text, rather than sqrt(height)
p +
  geom_text(aes(size = wt)) +
  scale_radius(range = c(3,6))

# You can display expressions by setting parse = TRUE.  The
# details of the display are described in ?plotmath, but note that
# geom_text uses strings, not expressions.
p +
  geom_text(
    aes(label = paste(wt, "^(", cyl, ")", sep = "")),
    parse = TRUE
  )

# Add a text annotation
p +
  geom_text() +
  annotate(
    "text", label = "plot mpg vs. wt",
    x = 2, y = 15, size = 8, colour = "red"
  )


# Aligning labels and bars --------------------------------------------------
df &lt;- data.frame(
  x = factor(c(1, 1, 2, 2)),
  y = c(1, 3, 2, 1),
  grp = c("a", "b", "a", "b")
)

# ggplot2 doesn't know you want to give the labels the same virtual width
# as the bars:
ggplot(data = df, aes(x, y, group = grp)) +
  geom_col(aes(fill = grp), position = "dodge") +
  geom_text(aes(label = y), position = "dodge")
# So tell it:
ggplot(data = df, aes(x, y, group = grp)) +
  geom_col(aes(fill = grp), position = "dodge") +
  geom_text(aes(label = y), position = position_dodge(0.9))
# You can't nudge and dodge text, so instead adjust the y position
ggplot(data = df, aes(x, y, group = grp)) +
  geom_col(aes(fill = grp), position = "dodge") +
  geom_text(
    aes(label = y, y = y + 0.05),
    position = position_dodge(0.9),
    vjust = 0
  )

# To place text in the middle of each bar in a stacked barplot, you
# need to set the vjust parameter of position_stack()
ggplot(data = df, aes(x, y, group = grp)) +
 geom_col(aes(fill = grp)) +
 geom_text(aes(label = y), position = position_stack(vjust = 0.5))

# Justification -------------------------------------------------------------
df &lt;- data.frame(
  x = c(1, 1, 2, 2, 1.5),
  y = c(1, 2, 1, 2, 1.5),
  text = c("bottom-left", "top-left", "bottom-right", "top-right", "center")
)
ggplot(df, aes(x, y)) +
  geom_text(aes(label = text))
ggplot(df, aes(x, y)) +
  geom_text(aes(label = text), vjust = "inward", hjust = "inward")

</code></pre>

<hr>
<h2 id='geom_map'>Polygons from a reference map</h2><span id='topic+geom_map'></span>

<h3>Description</h3>

<p>Display polygons as a map. This is meant as annotation, so it does not
affect position scales. Note that this function predates the <code><a href="#topic+geom_sf">geom_sf()</a></code>
framework and does not work with sf geometry columns as input. However,
it can be used in conjunction with <code>geom_sf()</code> layers and/or
<code><a href="#topic+coord_sf">coord_sf()</a></code> (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_map(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  ...,
  map,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_map_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_map_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_map_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_map">map</code></td>
<td>
<p>Data frame that contains the map coordinates.  This will
typically be created using <code><a href="#topic+fortify">fortify()</a></code> on a spatial object.
It must contain columns <code>x</code> or <code>long</code>, <code>y</code> or
<code>lat</code>, and <code>region</code> or <code>id</code>.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_map()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code>map_id</code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code>subgroup</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, a made-up example containing a few polygons, to explain
# how `geom_map()` works. It requires two data frames:
# One contains the coordinates of each polygon (`positions`), and is
# provided via the `map` argument. The other contains the
# other the values associated with each polygon (`values`).  An id
# variable links the two together.

ids &lt;- factor(c("1.1", "2.1", "1.2", "2.2", "1.3", "2.3"))

values &lt;- data.frame(
  id = ids,
  value = c(3, 3.1, 3.1, 3.2, 3.15, 3.5)
)

positions &lt;- data.frame(
  id = rep(ids, each = 4),
  x = c(2, 1, 1.1, 2.2, 1, 0, 0.3, 1.1, 2.2, 1.1, 1.2, 2.5, 1.1, 0.3,
  0.5, 1.2, 2.5, 1.2, 1.3, 2.7, 1.2, 0.5, 0.6, 1.3),
  y = c(-0.5, 0, 1, 0.5, 0, 0.5, 1.5, 1, 0.5, 1, 2.1, 1.7, 1, 1.5,
  2.2, 2.1, 1.7, 2.1, 3.2, 2.8, 2.1, 2.2, 3.3, 3.2)
)

ggplot(values) +
  geom_map(aes(map_id = id), map = positions) +
  expand_limits(positions)
ggplot(values, aes(fill = value)) +
  geom_map(aes(map_id = id), map = positions) +
  expand_limits(positions)
ggplot(values, aes(fill = value)) +
  geom_map(aes(map_id = id), map = positions) +
  expand_limits(positions) + ylim(0, 3)

# Now some examples with real maps
if (require(maps)) {

  crimes &lt;- data.frame(state = tolower(rownames(USArrests)), USArrests)

  # Equivalent to crimes %&gt;% tidyr::pivot_longer(Murder:Rape)
  vars &lt;- lapply(names(crimes)[-1], function(j) {
    data.frame(state = crimes$state, variable = j, value = crimes[[j]])
  })
  crimes_long &lt;- do.call("rbind", vars)

  states_map &lt;- map_data("state")

  # without geospatial coordinate system, the resulting plot
  # looks weird
  ggplot(crimes, aes(map_id = state)) +
    geom_map(aes(fill = Murder), map = states_map) +
    expand_limits(x = states_map$long, y = states_map$lat)

  # in combination with `coord_sf()` we get an appropriate result
  ggplot(crimes, aes(map_id = state)) +
    geom_map(aes(fill = Murder), map = states_map) +
    # crs = 5070 is a Conus Albers projection for North America,
    #   see: https://epsg.io/5070
    # default_crs = 4326 tells coord_sf() that the input map data
    #   are in longitude-latitude format
    coord_sf(
      crs = 5070, default_crs = 4326,
      xlim = c(-125, -70), ylim = c(25, 52)
    )

 ggplot(crimes_long, aes(map_id = state)) +
   geom_map(aes(fill = value), map = states_map) +
   coord_sf(
     crs = 5070, default_crs = 4326,
     xlim = c(-125, -70), ylim = c(25, 52)
   ) +
   facet_wrap(~variable)
}
</code></pre>

<hr>
<h2 id='geom_path'>Connect observations</h2><span id='topic+geom_path'></span><span id='topic+geom_line'></span><span id='topic+geom_step'></span>

<h3>Description</h3>

<p><code>geom_path()</code> connects the observations in the order in which they appear
in the data. <code>geom_line()</code> connects them in order of the variable on the
x axis. <code>geom_step()</code> creates a stairstep plot, highlighting exactly
when changes occur. The <code>group</code> aesthetic determines which cases are
connected together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_path(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_line(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_step(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  direction = "hv",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_path_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_path_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_path_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_path_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_path_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_path_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_direction">direction</code></td>
<td>
<p>direction of stairs: 'vh' for vertical then horizontal,
'hv' for horizontal then vertical, or 'mid' for step half-way between
adjacent x-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alternative parameterisation is <code><a href="#topic+geom_segment">geom_segment()</a></code>, where each line
corresponds to a single case which provides the start and end coordinates.
</p>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Aesthetics</h3>

<p><code>geom_path()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Missing value handling</h3>

<p><code>geom_path()</code>, <code>geom_line()</code>, and <code>geom_step()</code> handle <code>NA</code> as follows:
</p>

<ul>
<li><p> If an <code>NA</code> occurs in the middle of a line, it breaks the line. No warning
is shown, regardless of whether <code>na.rm</code> is <code>TRUE</code> or <code>FALSE</code>.
</p>
</li>
<li><p> If an <code>NA</code> occurs at the start or the end of the line and <code>na.rm</code> is <code>FALSE</code>
(default), the <code>NA</code> is removed with a warning.
</p>
</li>
<li><p> If an <code>NA</code> occurs at the start or the end of the line and <code>na.rm</code> is <code>TRUE</code>,
the <code>NA</code> is removed silently, without warning.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geom_polygon">geom_polygon()</a></code>: Filled paths (polygons);
<code><a href="#topic+geom_segment">geom_segment()</a></code>: Line segments
</p>


<h3>Examples</h3>

<pre><code class='language-R'># geom_line() is suitable for time series
ggplot(economics, aes(date, unemploy)) + geom_line()
ggplot(economics_long, aes(date, value01, colour = variable)) +
  geom_line()

# You can get a timeseries that run vertically by setting the orientation
ggplot(economics, aes(unemploy, date)) + geom_line(orientation = "y")

# geom_step() is useful when you want to highlight exactly when
# the y value changes
recent &lt;- economics[economics$date &gt; as.Date("2013-01-01"), ]
ggplot(recent, aes(date, unemploy)) + geom_line()
ggplot(recent, aes(date, unemploy)) + geom_step()

# geom_path lets you explore how two variables are related over time,
# e.g. unemployment and personal savings rate
m &lt;- ggplot(economics, aes(unemploy/pop, psavert))
m + geom_path()
m + geom_path(aes(colour = as.numeric(date)))

# Changing parameters ----------------------------------------------
ggplot(economics, aes(date, unemploy)) +
  geom_line(colour = "red")

# Use the arrow parameter to add an arrow to the line
# See ?arrow for more details
c &lt;- ggplot(economics, aes(x = date, y = pop))
c + geom_line(arrow = arrow())
c + geom_line(
  arrow = arrow(angle = 15, ends = "both", type = "closed")
)

# Control line join parameters
df &lt;- data.frame(x = 1:3, y = c(4, 1, 9))
base &lt;- ggplot(df, aes(x, y))
base + geom_path(linewidth = 10)
base + geom_path(linewidth = 10, lineend = "round")
base + geom_path(linewidth = 10, linejoin = "mitre", lineend = "butt")

# You can use NAs to break the line.
df &lt;- data.frame(x = 1:5, y = c(1, 2, NA, 4, 5))
ggplot(df, aes(x, y)) + geom_point() + geom_line()


# Setting line type vs colour/size
# Line type needs to be applied to a line as a whole, so it can
# not be used with colour or size that vary across a line
x &lt;- seq(0.01, .99, length.out = 100)
df &lt;- data.frame(
  x = rep(x, 2),
  y = c(qlogis(x), 2 * qlogis(x)),
  group = rep(c("a","b"),
  each = 100)
)
p &lt;- ggplot(df, aes(x=x, y=y, group=group))
# These work
p + geom_line(linetype = 2)
p + geom_line(aes(colour = group), linetype = 2)
p + geom_line(aes(colour = x))
# But this doesn't
should_stop(p + geom_line(aes(colour = x), linetype=2))

</code></pre>

<hr>
<h2 id='geom_point'>Points</h2><span id='topic+geom_point'></span>

<h3>Description</h3>

<p>The point geom is used to create scatterplots. The scatterplot is most
useful for displaying the relationship between two continuous variables.
It can be used to compare one continuous and one categorical variable, or
two categorical variables, but a variation like <code><a href="#topic+geom_jitter">geom_jitter()</a></code>,
<code><a href="#topic+geom_count">geom_count()</a></code>, or <code><a href="#topic+geom_bin_2d">geom_bin_2d()</a></code> is usually more
appropriate. A <em>bubblechart</em> is a scatterplot with a third variable
mapped to the size of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_point(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_point_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_point_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_point_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Overplotting</h3>

<p>The biggest potential problem with a scatterplot is overplotting: whenever
you have more than a few points, points may be plotted on top of one
another. This can severely distort the visual appearance of the plot.
There is no one solution to this problem, but there are some techniques
that can help. You can add additional information with
<code><a href="#topic+geom_smooth">geom_smooth()</a></code>, <code><a href="#topic+geom_quantile">geom_quantile()</a></code> or
<code><a href="#topic+geom_density_2d">geom_density_2d()</a></code>. If you have few unique <code>x</code> values,
<code><a href="#topic+geom_boxplot">geom_boxplot()</a></code> may also be useful.
</p>
<p>Alternatively, you can
summarise the number of points at each location and display that in some
way, using <code><a href="#topic+geom_count">geom_count()</a></code>, <code><a href="#topic+geom_hex">geom_hex()</a></code>, or
<code><a href="#topic+geom_density2d">geom_density2d()</a></code>.
</p>
<p>Another technique is to make the points transparent (e.g.
<code>geom_point(alpha = 0.05)</code>) or very small (e.g.
<code>geom_point(shape = ".")</code>).
</p>


<h3>Aesthetics</h3>

<p><code>geom_point()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">shape</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">size</a></code>
</p>
</li>
<li> <p><code>stroke</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg))
p + geom_point()

# Add aesthetic mappings
p + geom_point(aes(colour = factor(cyl)))
p + geom_point(aes(shape = factor(cyl)))
# A "bubblechart":
p + geom_point(aes(size = qsec))

# Set aesthetics to fixed value
ggplot(mtcars, aes(wt, mpg)) + geom_point(colour = "red", size = 3)


# Varying alpha is useful for large datasets
d &lt;- ggplot(diamonds, aes(carat, price))
d + geom_point(alpha = 1/10)
d + geom_point(alpha = 1/20)
d + geom_point(alpha = 1/100)


# For shapes that have a border (like 21), you can colour the inside and
# outside separately. Use the stroke aesthetic to modify the width of the
# border
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(shape = 21, colour = "black", fill = "white", size = 5, stroke = 5)


# You can create interesting shapes by layering multiple points of
# different sizes
p &lt;- ggplot(mtcars, aes(mpg, wt, shape = factor(cyl)))
p +
  geom_point(aes(colour = factor(cyl)), size = 4) +
  geom_point(colour = "grey90", size = 1.5)
p +
  geom_point(colour = "black", size = 4.5) +
  geom_point(colour = "pink", size = 4) +
  geom_point(aes(shape = factor(cyl)))

# geom_point warns when missing values have been dropped from the data set
# and not plotted, you can turn this off by setting na.rm = TRUE
set.seed(1)
mtcars2 &lt;- transform(mtcars, mpg = ifelse(runif(32) &lt; 0.2, NA, mpg))
ggplot(mtcars2, aes(wt, mpg)) +
  geom_point()
ggplot(mtcars2, aes(wt, mpg)) +
  geom_point(na.rm = TRUE)

</code></pre>

<hr>
<h2 id='geom_polygon'>Polygons</h2><span id='topic+geom_polygon'></span>

<h3>Description</h3>

<p>Polygons are very similar to paths (as drawn by <code><a href="#topic+geom_path">geom_path()</a></code>)
except that the start and end points are connected and the inside is
coloured by <code>fill</code>. The <code>group</code> aesthetic determines which cases
are connected together into a polygon. From R 3.6 and onwards it is possible
to draw polygons with holes by providing a subgroup aesthetic that
differentiates the outer ring points from those describing holes in the
polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_polygon(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  rule = "evenodd",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_polygon_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_rule">rule</code></td>
<td>
<p>Either <code>"evenodd"</code> or <code>"winding"</code>. If polygons with holes are
being drawn (using the <code>subgroup</code> aesthetic) this argument defines how the
hole coordinates are interpreted. See the examples in <code><a href="grid.html#topic+grid.path">grid::pathGrob()</a></code> for
an explanation.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_polygon()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code>subgroup</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_path">geom_path()</a></code> for an unfilled polygon,
<code><a href="#topic+geom_ribbon">geom_ribbon()</a></code> for a polygon anchored on the x-axis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># When using geom_polygon, you will typically need two data frames:
# one contains the coordinates of each polygon (positions),  and the
# other the values associated with each polygon (values).  An id
# variable links the two together

ids &lt;- factor(c("1.1", "2.1", "1.2", "2.2", "1.3", "2.3"))

values &lt;- data.frame(
  id = ids,
  value = c(3, 3.1, 3.1, 3.2, 3.15, 3.5)
)

positions &lt;- data.frame(
  id = rep(ids, each = 4),
  x = c(2, 1, 1.1, 2.2, 1, 0, 0.3, 1.1, 2.2, 1.1, 1.2, 2.5, 1.1, 0.3,
  0.5, 1.2, 2.5, 1.2, 1.3, 2.7, 1.2, 0.5, 0.6, 1.3),
  y = c(-0.5, 0, 1, 0.5, 0, 0.5, 1.5, 1, 0.5, 1, 2.1, 1.7, 1, 1.5,
  2.2, 2.1, 1.7, 2.1, 3.2, 2.8, 2.1, 2.2, 3.3, 3.2)
)

# Currently we need to manually merge the two together
datapoly &lt;- merge(values, positions, by = c("id"))

p &lt;- ggplot(datapoly, aes(x = x, y = y)) +
  geom_polygon(aes(fill = value, group = id))
p

# Which seems like a lot of work, but then it's easy to add on
# other features in this coordinate system, e.g.:

set.seed(1)
stream &lt;- data.frame(
  x = cumsum(runif(50, max = 0.1)),
  y = cumsum(runif(50,max = 0.1))
)

p + geom_line(data = stream, colour = "grey30", linewidth = 5)

# And if the positions are in longitude and latitude, you can use
# coord_map to produce different map projections.

if (packageVersion("grid") &gt;= "3.6") {
  # As of R version 3.6 geom_polygon() supports polygons with holes
  # Use the subgroup aesthetic to differentiate holes from the main polygon

  holes &lt;- do.call(rbind, lapply(split(datapoly, datapoly$id), function(df) {
    df$x &lt;- df$x + 0.5 * (mean(df$x) - df$x)
    df$y &lt;- df$y + 0.5 * (mean(df$y) - df$y)
    df
  }))
  datapoly$subid &lt;- 1L
  holes$subid &lt;- 2L
  datapoly &lt;- rbind(datapoly, holes)

  p &lt;- ggplot(datapoly, aes(x = x, y = y)) +
    geom_polygon(aes(fill = value, group = id, subgroup = subid))
  p
}

</code></pre>

<hr>
<h2 id='geom_qq_line'>A quantile-quantile plot</h2><span id='topic+geom_qq_line'></span><span id='topic+stat_qq_line'></span><span id='topic+geom_qq'></span><span id='topic+stat_qq'></span>

<h3>Description</h3>

<p><code>geom_qq()</code> and <code>stat_qq()</code> produce quantile-quantile plots. <code>geom_qq_line()</code> and
<code>stat_qq_line()</code> compute the slope and intercept of the line connecting the
points at specified quartiles of the theoretical and sample distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_qq_line(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  ...,
  distribution = stats::qnorm,
  dparams = list(),
  line.p = c(0.25, 0.75),
  fullrange = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_qq_line(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  ...,
  distribution = stats::qnorm,
  dparams = list(),
  line.p = c(0.25, 0.75),
  fullrange = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_qq(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  distribution = stats::qnorm,
  dparams = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_qq(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  distribution = stats::qnorm,
  dparams = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_qq_line_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_distribution">distribution</code></td>
<td>
<p>Distribution function to use, if x not specified</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_dparams">dparams</code></td>
<td>
<p>Additional parameters passed on to <code>distribution</code>
function.</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_line.p">line.p</code></td>
<td>
<p>Vector of quantiles to use when fitting the Q-Q line, defaults
defaults to <code>c(.25, .75)</code>.</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_fullrange">fullrange</code></td>
<td>
<p>Should the q-q line span the full range of the plot, or just
the data</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_qq_line_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_qq()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code>sample</code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_position">x</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_position">y</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>
<p><code>stat_qq_line()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code>sample</code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_position">x</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_position">y</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>. <br /> Variables computed by <code>stat_qq()</code>:
</p>

<ul>
<li> <p><code>after_stat(sample)</code><br /> Sample quantiles.
</p>
</li>
<li> <p><code>after_stat(theoretical)</code><br /> Theoretical quantiles.
</p>
</li></ul>

<p>Variables computed by <code>stat_qq_line()</code>:
</p>

<ul>
<li> <p><code>after_stat(x)</code><br /> x-coordinates of the endpoints of the line segment connecting the  points at the chosen quantiles of the theoretical and the sample  distributions.
</p>
</li>
<li> <p><code>after_stat(y)</code><br /> y-coordinates of the endpoints.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(y = rt(200, df = 5))
p &lt;- ggplot(df, aes(sample = y))
p + stat_qq() + stat_qq_line()

# Use fitdistr from MASS to estimate distribution params
params &lt;- as.list(MASS::fitdistr(df$y, "t")$estimate)
ggplot(df, aes(sample = y)) +
  stat_qq(distribution = qt, dparams = params["df"]) +
  stat_qq_line(distribution = qt, dparams = params["df"])

# Using to explore the distribution of a variable
ggplot(mtcars, aes(sample = mpg)) +
  stat_qq() +
  stat_qq_line()
ggplot(mtcars, aes(sample = mpg, colour = factor(cyl))) +
  stat_qq() +
  stat_qq_line()

</code></pre>

<hr>
<h2 id='geom_quantile'>Quantile regression</h2><span id='topic+geom_quantile'></span><span id='topic+stat_quantile'></span>

<h3>Description</h3>

<p>This fits a quantile regression to the data and draws the fitted quantiles
with lines. This is as a continuous analogue to <code><a href="#topic+geom_boxplot">geom_boxplot()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_quantile(
  mapping = NULL,
  data = NULL,
  stat = "quantile",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_quantile(
  mapping = NULL,
  data = NULL,
  geom = "quantile",
  position = "identity",
  ...,
  quantiles = c(0.25, 0.5, 0.75),
  formula = NULL,
  method = "rq",
  method.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_quantile_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_geom">geom</code>, <code id="geom_quantile_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_quantile()</code> and <code>stat_quantile()</code>.</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_quantiles">quantiles</code></td>
<td>
<p>conditional quantiles of y to calculate and display</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_formula">formula</code></td>
<td>
<p>formula relating y variables to x variables</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_method">method</code></td>
<td>
<p>Quantile regression method to use. Available options are <code>"rq"</code> (for
<code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>) and <code>"rqss"</code> (for <code><a href="quantreg.html#topic+rqss">quantreg::rqss()</a></code>).</p>
</td></tr>
<tr><td><code id="geom_quantile_+3A_method.args">method.args</code></td>
<td>
<p>List of additional arguments passed on to the modelling
function defined by <code>method</code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_quantile()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(quantile)</code><br /> Quantile of distribution.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m &lt;-
  ggplot(mpg, aes(displ, 1 / hwy)) +
  geom_point()
m + geom_quantile()
m + geom_quantile(quantiles = 0.5)
q10 &lt;- seq(0.05, 0.95, by = 0.05)
m + geom_quantile(quantiles = q10)

# You can also use rqss to fit smooth quantiles
m + geom_quantile(method = "rqss")
# Note that rqss doesn't pick a smoothing constant automatically, so
# you'll need to tweak lambda yourself
m + geom_quantile(method = "rqss", lambda = 0.1)

# Set aesthetics to fixed value
m + geom_quantile(colour = "red", linewidth = 2, alpha = 0.5)
</code></pre>

<hr>
<h2 id='geom_raster'>Rectangles</h2><span id='topic+geom_raster'></span><span id='topic+geom_rect'></span><span id='topic+geom_tile'></span>

<h3>Description</h3>

<p><code>geom_rect()</code> and <code>geom_tile()</code> do the same thing, but are
parameterised differently: <code>geom_rect()</code> uses the locations of the four
corners (<code>xmin</code>, <code>xmax</code>, <code>ymin</code> and <code>ymax</code>), while
<code>geom_tile()</code> uses the center of the tile and its size (<code>x</code>,
<code>y</code>, <code>width</code>, <code>height</code>). <code>geom_raster()</code> is a high
performance special case for when all the tiles are the same size, and no
pattern fills are applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_raster(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  hjust = 0.5,
  vjust = 0.5,
  interpolate = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rect(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  linejoin = "mitre",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_tile(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  linejoin = "mitre",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_raster_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_hjust">hjust</code>, <code id="geom_raster_+3A_vjust">vjust</code></td>
<td>
<p>horizontal and vertical justification of the grob.  Each
justification value should be a number between 0 and 1.  Defaults to 0.5
for both, centering each pixel over its data location.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geom_rect()</code> and <code>geom_tile()</code>'s respond differently to scale
transformations due to their parameterisation. In <code>geom_rect()</code>, the scale
transformation is applied to the corners of the rectangles. In <code>geom_tile()</code>,
the transformation is applied only to the centres and its size is determined
after transformation.
</p>


<h3>Aesthetics</h3>

<p><code>geom_tile()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code>height</code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code>width</code>
</p>
</li></ul>

<p>Note that <code>geom_raster()</code> ignores <code>colour</code>.
</p>
<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The most common use for rectangles is to draw a surface. You always want
# to use geom_raster here because it's so much faster, and produces
# smaller output when saving to PDF
ggplot(faithfuld, aes(waiting, eruptions)) +
 geom_raster(aes(fill = density))

# Interpolation smooths the surface &amp; is most helpful when rendering images.
ggplot(faithfuld, aes(waiting, eruptions)) +
 geom_raster(aes(fill = density), interpolate = TRUE)

# If you want to draw arbitrary rectangles, use geom_tile() or geom_rect()
df &lt;- data.frame(
  x = rep(c(2, 5, 7, 9, 12), 2),
  y = rep(c(1, 2), each = 5),
  z = factor(rep(1:5, each = 2)),
  w = rep(diff(c(0, 4, 6, 8, 10, 14)), 2)
)
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = z), colour = "grey50")
ggplot(df, aes(x, y, width = w)) +
  geom_tile(aes(fill = z), colour = "grey50")
ggplot(df, aes(xmin = x - w / 2, xmax = x + w / 2, ymin = y, ymax = y + 1)) +
  geom_rect(aes(fill = z), colour = "grey50")


# Justification controls where the cells are anchored
df &lt;- expand.grid(x = 0:5, y = 0:5)
set.seed(1)
df$z &lt;- runif(nrow(df))
# default is compatible with geom_tile()
ggplot(df, aes(x, y, fill = z)) +
  geom_raster()
# zero padding
ggplot(df, aes(x, y, fill = z)) +
  geom_raster(hjust = 0, vjust = 0)

# Inspired by the image-density plots of Ken Knoblauch
cars &lt;- ggplot(mtcars, aes(mpg, factor(cyl)))
cars + geom_point()
cars + stat_bin_2d(aes(fill = after_stat(count)), binwidth = c(3,1))
cars + stat_bin_2d(aes(fill = after_stat(density)), binwidth = c(3,1))

cars +
  stat_density(
    aes(fill = after_stat(density)),
    geom = "raster",
    position = "identity"
   )
cars +
  stat_density(
    aes(fill = after_stat(count)),
    geom = "raster",
    position = "identity"
  )

</code></pre>

<hr>
<h2 id='geom_ribbon'>Ribbons and area plots</h2><span id='topic+geom_ribbon'></span><span id='topic+geom_area'></span><span id='topic+stat_align'></span>

<h3>Description</h3>

<p>For each x value, <code>geom_ribbon()</code> displays a y interval defined
by <code>ymin</code> and <code>ymax</code>. <code>geom_area()</code> is a special case of
<code>geom_ribbon()</code>, where the <code>ymin</code> is fixed to 0 and <code>y</code> is used instead
of <code>ymax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_ribbon(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  outline.type = "both"
)

geom_area(
  mapping = NULL,
  data = NULL,
  stat = "align",
  position = "stack",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...,
  outline.type = "upper"
)

stat_align(
  mapping = NULL,
  data = NULL,
  geom = "area",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_ribbon_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_outline.type">outline.type</code></td>
<td>
<p>Type of the outline of the area; <code>"both"</code> draws both the
upper and lower lines, <code>"upper"</code>/<code>"lower"</code> draws the respective lines only.
<code>"full"</code> draws a closed polygon around the area.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An area plot is the continuous analogue of a stacked bar chart (see
<code><a href="#topic+geom_bar">geom_bar()</a></code>), and can be used to show how composition of the
whole varies over the range of x. Choosing the order in which different
components is stacked is very important, as it becomes increasing hard to
see the individual pattern as you move up the stack. See
<code><a href="#topic+position_stack">position_stack()</a></code> for the details of stacking algorithm. To facilitate
stacking, the default <code>stat = "align"</code> interpolates groups to a common set
of x-coordinates. To turn off this interpolation, <code>stat = "identity"</code> can
be used instead.
</p>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Aesthetics</h3>

<p><code>geom_ribbon()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code> <em>or</em> <code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">ymin</a></code> <em>or</em> <code><a href="#topic+aes_position">xmin</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">ymax</a></code> <em>or</em> <code><a href="#topic+aes_position">xmax</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_bar">geom_bar()</a></code> for discrete intervals (bars),
<code><a href="#topic+geom_linerange">geom_linerange()</a></code> for discrete intervals (lines),
<code><a href="#topic+geom_polygon">geom_polygon()</a></code> for general polygons
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
huron &lt;- data.frame(year = 1875:1972, level = as.vector(LakeHuron))
h &lt;- ggplot(huron, aes(year))

h + geom_ribbon(aes(ymin=0, ymax=level))
h + geom_area(aes(y = level))

# Orientation cannot be deduced by mapping, so must be given explicitly for
# flipped orientation
h + geom_area(aes(x = level, y = year), orientation = "y")

# Add aesthetic mappings
h +
  geom_ribbon(aes(ymin = level - 1, ymax = level + 1), fill = "grey70") +
  geom_line(aes(y = level))

# The underlying stat_align() takes care of unaligned data points
df &lt;- data.frame(
  g = c("a", "a", "a", "b", "b", "b"),
  x = c(1, 3, 5, 2, 4, 6),
  y = c(2, 5, 1, 3, 6, 7)
)
a &lt;- ggplot(df, aes(x, y, fill = g)) +
  geom_area()

# Two groups have points on different X values.
a + geom_point(size = 8) + facet_grid(g ~ .)

# stat_align() interpolates and aligns the value so that the areas can stack
# properly.
a + geom_point(stat = "align", position = "stack", size = 8)

# To turn off the alignment, the stat can be set to "identity"
ggplot(df, aes(x, y, fill = g)) +
  geom_area(stat = "identity")
</code></pre>

<hr>
<h2 id='geom_rug'>Rug plots in the margins</h2><span id='topic+geom_rug'></span>

<h3>Description</h3>

<p>A rug plot is a compact visualisation designed to supplement a 2d display
with the two 1d marginal distributions. Rug plots display individual
cases so are best used with smaller datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_rug(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  outside = FALSE,
  sides = "bl",
  length = unit(0.03, "npc"),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_rug_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_outside">outside</code></td>
<td>
<p>logical that controls whether to move the rug tassels outside of the plot area. Default is off (FALSE). You will also need to use <code>coord_cartesian(clip = "off")</code>. When set to TRUE, also consider changing the sides argument to &quot;tr&quot;. See examples.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_sides">sides</code></td>
<td>
<p>A string that controls which sides of the plot the rugs appear on.
It can be set to a string containing any of <code>"trbl"</code>, for top, right,
bottom, and left.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_length">length</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> object that sets the length of the rug lines. Use scale expansion to avoid overplotting of data.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the rug lines are drawn with a length that corresponds to 3%
of the total plot size. Since the default scale expansion of for continuous
variables is 5% at both ends of the scale, the rug will not overlap with
any data points under the default settings.
</p>


<h3>Aesthetics</h3>

<p><code>geom_rug()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_position">x</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_position">y</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg)) +
  geom_point()
p
p + geom_rug()
p + geom_rug(sides="b")    # Rug on bottom only
p + geom_rug(sides="trbl") # All four sides

# Use jittering to avoid overplotting for smaller datasets
ggplot(mpg, aes(displ, cty)) +
  geom_point() +
  geom_rug()

ggplot(mpg, aes(displ, cty)) +
  geom_jitter() +
  geom_rug(alpha = 1/2, position = "jitter")

# move the rug tassels to outside the plot
# remember to set clip = "off".
p +
  geom_rug(outside = TRUE) +
  coord_cartesian(clip = "off")

# set sides to top right, and then move the margins
p +
  geom_rug(outside = TRUE, sides = "tr") +
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(1, 1, 1, 1, "cm"))

# increase the line length and
# expand axis to avoid overplotting
p +
  geom_rug(length = unit(0.05, "npc")) +
  scale_y_continuous(expand = c(0.1, 0.1))

</code></pre>

<hr>
<h2 id='geom_segment'>Line segments and curves</h2><span id='topic+geom_segment'></span><span id='topic+geom_curve'></span>

<h3>Description</h3>

<p><code>geom_segment()</code> draws a straight line between points (x, y) and
(xend, yend). <code>geom_curve()</code> draws a curved line. See the underlying
drawing function <code><a href="grid.html#topic+grid.curve">grid::curveGrob()</a></code> for the parameters that
control the curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_segment(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  arrow = NULL,
  arrow.fill = NULL,
  lineend = "butt",
  linejoin = "round",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_curve(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  curvature = 0.5,
  angle = 90,
  ncp = 5,
  arrow = NULL,
  arrow.fill = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_segment_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_arrow.fill">arrow.fill</code></td>
<td>
<p>fill colour to use for the arrow head (if closed). <code>NULL</code>
means use <code>colour</code> aesthetic.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_curvature">curvature</code></td>
<td>
<p>A numeric value giving the amount of curvature.
Negative values produce left-hand curves, positive values
produce right-hand curves, and zero produces a straight line.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_angle">angle</code></td>
<td>
<p>A numeric value between 0 and 180,
giving an amount to skew the control
points of the curve.  Values less than 90 skew the curve towards
the start point and values greater than 90 skew the curve
towards the end point.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_ncp">ncp</code></td>
<td>
<p>The number of control points used to draw the curve.
More control points creates a smoother curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both geoms draw a single segment/curve per case. See <code>geom_path()</code> if you
need to connect points across multiple cases.
</p>


<h3>Aesthetics</h3>

<p><code>geom_segment()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">xend</a></code> <em>or</em> <code><a href="#topic+aes_position">yend</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_path">geom_path()</a></code> and <code><a href="#topic+geom_line">geom_line()</a></code> for multi-
segment lines and paths.
</p>
<p><code><a href="#topic+geom_spoke">geom_spoke()</a></code> for a segment parameterised by a location
(x, y), and an angle and radius.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- ggplot(mtcars, aes(wt, mpg)) +
  geom_point()

df &lt;- data.frame(x1 = 2.62, x2 = 3.57, y1 = 21.0, y2 = 15.0)
b +
 geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "curve"), data = df) +
 geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "segment"), data = df)

b + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2), data = df, curvature = -0.2)
b + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2), data = df, curvature = 1)
b + geom_curve(
  aes(x = x1, y = y1, xend = x2, yend = y2),
  data = df,
  arrow = arrow(length = unit(0.03, "npc"))
)

if (requireNamespace('maps', quietly = TRUE)) {
ggplot(seals, aes(long, lat)) +
  geom_segment(aes(xend = long + delta_long, yend = lat + delta_lat),
    arrow = arrow(length = unit(0.1,"cm"))) +
  borders("state")
}

# Use lineend and linejoin to change the style of the segments
df2 &lt;- expand.grid(
  lineend = c('round', 'butt', 'square'),
  linejoin = c('round', 'mitre', 'bevel'),
  stringsAsFactors = FALSE
)
df2 &lt;- data.frame(df2, y = 1:9)
ggplot(df2, aes(x = 1, y = y, xend = 2, yend = y, label = paste(lineend, linejoin))) +
  geom_segment(
     lineend = df2$lineend, linejoin = df2$linejoin,
     size = 3, arrow = arrow(length = unit(0.3, "inches"))
  ) +
  geom_text(hjust = 'outside', nudge_x = -0.2) +
  xlim(0.5, 2)

# You can also use geom_segment to recreate plot(type = "h") :
set.seed(1)
counts &lt;- as.data.frame(table(x = rpois(100,5)))
counts$x &lt;- as.numeric(as.character(counts$x))
with(counts, plot(x, Freq, type = "h", lwd = 10))

ggplot(counts, aes(x, Freq)) +
  geom_segment(aes(xend = x, yend = 0), linewidth = 10, lineend = "butt")
</code></pre>

<hr>
<h2 id='geom_smooth'>Smoothed conditional means</h2><span id='topic+geom_smooth'></span><span id='topic+stat_smooth'></span>

<h3>Description</h3>

<p>Aids the eye in seeing patterns in the presence of overplotting.
<code>geom_smooth()</code> and <code>stat_smooth()</code> are effectively aliases: they
both use the same arguments. Use <code>stat_smooth()</code> if you want to
display the results with a non-standard geom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_smooth(
  mapping = NULL,
  data = NULL,
  stat = "smooth",
  position = "identity",
  ...,
  method = NULL,
  formula = NULL,
  se = TRUE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_smooth(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  method = NULL,
  formula = NULL,
  se = TRUE,
  n = 80,
  span = 0.75,
  fullrange = FALSE,
  level = 0.95,
  method.args = list(),
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_smooth_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_method">method</code></td>
<td>
<p>Smoothing method (function) to use, accepts either
<code>NULL</code> or a character vector, e.g. <code>"lm"</code>, <code>"glm"</code>, <code>"gam"</code>, <code>"loess"</code>
or a function, e.g. <code>MASS::rlm</code> or <code>mgcv::gam</code>, <code>stats::lm</code>, or <code>stats::loess</code>.
<code>"auto"</code> is also accepted for backwards compatibility.  It is equivalent to
<code>NULL</code>.
</p>
<p>For <code>method = NULL</code> the smoothing method is chosen based on the
size of the largest group (across all panels). <code><a href="stats.html#topic+loess">stats::loess()</a></code> is
used for less than 1,000 observations; otherwise <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> is
used with <code>formula = y ~ s(x, bs = "cs")</code> with <code>method = "REML"</code>. Somewhat anecdotally,
<code>loess</code> gives a better appearance, but is <code class="reqn">O(N^{2})</code> in memory,
so does not work for larger datasets.
</p>
<p>If you have fewer than 1,000 observations but want to use the same <code>gam()</code>
model that <code>method = NULL</code> would use, then set
<code style="white-space: pre;">&#8288;method = "gam", formula = y ~ s(x, bs = "cs")&#8288;</code>.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_formula">formula</code></td>
<td>
<p>Formula to use in smoothing function, eg. <code>y ~ x</code>,
<code>y ~ poly(x, 2)</code>, <code>y ~ log(x)</code>. <code>NULL</code> by default, in which case
<code>method = NULL</code> implies <code>formula = y ~ x</code> when there are fewer than 1,000
observations and <code>formula = y ~ s(x, bs = "cs")</code> otherwise.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_se">se</code></td>
<td>
<p>Display confidence interval around smooth? (<code>TRUE</code> by default, see
<code>level</code> to control.)</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_geom">geom</code>, <code id="geom_smooth_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_smooth()</code> and <code>stat_smooth()</code>.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate smoother.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_span">span</code></td>
<td>
<p>Controls the amount of smoothing for the default loess smoother.
Smaller numbers produce wigglier lines, larger numbers produce smoother
lines. Only used with loess, i.e. when <code>method = "loess"</code>,
or when <code>method = NULL</code> (the default) and there are fewer than 1,000
observations.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_fullrange">fullrange</code></td>
<td>
<p>If <code>TRUE</code>, the smoothing line gets expanded to the range of the plot,
potentially beyond the data. This does not extend the line into any additional padding
created by <code>expansion</code>.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_level">level</code></td>
<td>
<p>Level of confidence interval to use (0.95 by default).</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_method.args">method.args</code></td>
<td>
<p>List of additional arguments passed on to the modelling
function defined by <code>method</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation is performed by the (currently undocumented)
<code>predictdf()</code> generic and its methods.  For most methods the standard
error bounds are computed using the <code><a href="stats.html#topic+predict">predict()</a></code> method &ndash; the
exceptions are <code>loess()</code>, which uses a t-based approximation, and
<code>glm()</code>, where the normal confidence interval is constructed on the link
scale and then back-transformed to the response scale.
</p>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Aesthetics</h3>

<p><code>geom_smooth()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li>
<li> <p><code><a href="#topic+aes_position">ymax</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_position">ymin</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>. <code>stat_smooth()</code> provides the following variables, some of  which depend on the orientation:
</p>

<ul>
<li> <p><code>after_stat(y)</code> <em>or</em> <code>after_stat(x)</code><br /> Predicted value.
</p>
</li>
<li> <p><code>after_stat(ymin)</code> <em>or</em> <code>after_stat(xmin)</code><br /> Lower pointwise confidence interval around the mean.
</p>
</li>
<li> <p><code>after_stat(ymax)</code> <em>or</em> <code>after_stat(xmax)</code><br /> Upper pointwise confidence interval around the mean.
</p>
</li>
<li> <p><code>after_stat(se)</code><br /> Standard error.
</p>
</li></ul>



<h3>See Also</h3>

<p>See individual modelling functions for more details:
<code><a href="stats.html#topic+lm">lm()</a></code> for linear smooths,
<code><a href="stats.html#topic+glm">glm()</a></code> for generalised linear smooths, and
<code><a href="stats.html#topic+loess">loess()</a></code> for local smooths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth()

# If you need the fitting to be done along the y-axis set the orientation
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(orientation = "y")

# Use span to control the "wiggliness" of the default loess smoother.
# The span is the fraction of points used to fit each local regression:
# small numbers make a wigglier curve, larger numbers make a smoother curve.
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(span = 0.3)

# Instead of a loess smooth, you can use any other modelling function:
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(method = lm, se = FALSE)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = FALSE)

# Smooths are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

ggplot(mpg, aes(displ, hwy, colour = class)) +
  geom_point() +
  geom_smooth(se = FALSE, method = lm)
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(span = 0.8) +
  facet_wrap(~drv)


binomial_smooth &lt;- function(...) {
  geom_smooth(method = "glm", method.args = list(family = "binomial"), ...)
}
# To fit a logistic regression, you need to coerce the values to
# a numeric vector lying between 0 and 1.
ggplot(rpart::kyphosis, aes(Age, Kyphosis)) +
  geom_jitter(height = 0.05) +
  binomial_smooth()

ggplot(rpart::kyphosis, aes(Age, as.numeric(Kyphosis) - 1)) +
  geom_jitter(height = 0.05) +
  binomial_smooth()

ggplot(rpart::kyphosis, aes(Age, as.numeric(Kyphosis) - 1)) +
  geom_jitter(height = 0.05) +
  binomial_smooth(formula = y ~ splines::ns(x, 2))

# But in this case, it's probably better to fit the model yourself
# so you can exercise more control and see whether or not it's a good model.

</code></pre>

<hr>
<h2 id='geom_spoke'>Line segments parameterised by location, direction and distance</h2><span id='topic+geom_spoke'></span><span id='topic+stat_spoke'></span>

<h3>Description</h3>

<p>This is a polar parameterisation of <code><a href="#topic+geom_segment">geom_segment()</a></code>. It is
useful when you have variables that describe direction and distance.
The angles start from east and increase counterclockwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spoke(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_spoke_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_spoke()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><strong><code>angle</code></strong>
</p>
</li>
<li> <p><strong><code>radius</code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- expand.grid(x = 1:10, y=1:10)

set.seed(1)
df$angle &lt;- runif(100, 0, 2*pi)
df$speed &lt;- runif(100, 0, sqrt(0.1 * df$x))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_spoke(aes(angle = angle), radius = 0.5)

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_spoke(aes(angle = angle, radius = speed))
</code></pre>

<hr>
<h2 id='geom_violin'>Violin plot</h2><span id='topic+geom_violin'></span><span id='topic+stat_ydensity'></span>

<h3>Description</h3>

<p>A violin plot is a compact display of a continuous distribution. It is a
blend of <code><a href="#topic+geom_boxplot">geom_boxplot()</a></code> and <code><a href="#topic+geom_density">geom_density()</a></code>: a
violin plot is a mirrored density plot displayed in the same way as a
boxplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_violin(
  mapping = NULL,
  data = NULL,
  stat = "ydensity",
  position = "dodge",
  ...,
  draw_quantiles = NULL,
  trim = TRUE,
  bounds = c(-Inf, Inf),
  scale = "area",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_ydensity(
  mapping = NULL,
  data = NULL,
  geom = "violin",
  position = "dodge",
  ...,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  trim = TRUE,
  scale = "area",
  drop = TRUE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  bounds = c(-Inf, Inf)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_violin_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_draw_quantiles">draw_quantiles</code></td>
<td>
<p>If <code>not(NULL)</code> (default), draw horizontal lines
at the given quantiles of the density estimate.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_trim">trim</code></td>
<td>
<p>If <code>TRUE</code> (default), trim the tails of the violins
to the range of the data. If <code>FALSE</code>, don't trim the tails.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_bounds">bounds</code></td>
<td>
<p>Known lower and upper bounds for estimated data. Default
<code>c(-Inf, Inf)</code> means that there are no (finite) bounds. If any bound is
finite, boundary effect of default density estimation will be corrected by
reflecting tails outside <code>bounds</code> around their closest edge. Data points
outside of bounds are removed with a warning.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_scale">scale</code></td>
<td>
<p>if &quot;area&quot; (default), all violins have the same area (before trimming
the tails). If &quot;count&quot;, areas are scaled proportionally to the number of
observations. If &quot;width&quot;, all violins have the same maximum width.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_geom">geom</code>, <code id="geom_violin_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_violin()</code> and <code>stat_ydensity()</code>.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_bw">bw</code></td>
<td>
<p>The smoothing bandwidth to be used.
If numeric, the standard deviation of the smoothing kernel.
If character, a rule to choose the bandwidth, as listed in
<code><a href="stats.html#topic+bandwidth">stats::bw.nrd()</a></code>. Note that automatic calculation of the bandwidth does
not take weights into account.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_adjust">adjust</code></td>
<td>
<p>A multiplicate bandwidth adjustment. This makes it possible
to adjust the bandwidth while still using the a bandwidth estimator.
For example, <code>adjust = 1/2</code> means use half of the default bandwidth.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_kernel">kernel</code></td>
<td>
<p>Kernel. See list of available kernels in <code><a href="stats.html#topic+density">density()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_drop">drop</code></td>
<td>
<p>Whether to discard groups with less than 2 observations
(<code>TRUE</code>, default) or keep such groups for position adjustment purposes
(<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Aesthetics</h3>

<p><code>geom_violin()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="#topic+aes_linetype_size_shape">linewidth</a></code>
</p>
</li>
<li> <p><code>weight</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(density)</code><br /> Density estimate.
</p>
</li>
<li> <p><code>after_stat(scaled)</code><br /> Density estimate, scaled to a maximum of 1.
</p>
</li>
<li> <p><code>after_stat(count)</code><br /> Density * number of points - probably useless for violin  plots.
</p>
</li>
<li> <p><code>after_stat(violinwidth)</code><br /> Density scaled for the violin plot, according to area,  counts or to a constant maximum width.
</p>
</li>
<li> <p><code>after_stat(n)</code><br /> Number of points.
</p>
</li>
<li> <p><code>after_stat(width)</code><br /> Width of violin bounding box.
</p>
</li></ul>



<h3>References</h3>

<p>Hintze, J. L., Nelson, R. D. (1998) Violin Plots: A Box
Plot-Density Trace Synergism. The American Statistician 52, 181-184.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_violin">geom_violin()</a></code> for examples, and <code><a href="#topic+stat_density">stat_density()</a></code>
for examples with data along the x axis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(factor(cyl), mpg))
p + geom_violin()

# Orientation follows the discrete axis
ggplot(mtcars, aes(mpg, factor(cyl))) +
  geom_violin()


p + geom_violin() + geom_jitter(height = 0, width = 0.1)

# Scale maximum width proportional to sample size:
p + geom_violin(scale = "count")

# Scale maximum width to 1 for all violins:
p + geom_violin(scale = "width")

# Default is to trim violins to the range of the data. To disable:
p + geom_violin(trim = FALSE)

# Use a smaller bandwidth for closer density fit (default is 1).
p + geom_violin(adjust = .5)

# Add aesthetic mappings
# Note that violins are automatically dodged when any aesthetic is
# a factor
p + geom_violin(aes(fill = cyl))
p + geom_violin(aes(fill = factor(cyl)))
p + geom_violin(aes(fill = factor(vs)))
p + geom_violin(aes(fill = factor(am)))

# Set aesthetics to fixed value
p + geom_violin(fill = "grey80", colour = "#3366FF")

# Show quartiles
p + geom_violin(draw_quantiles = c(0.25, 0.5, 0.75))

# Scales vs. coordinate transforms -------
if (require("ggplot2movies")) {
# Scale transformations occur before the density statistics are computed.
# Coordinate transformations occur afterwards.  Observe the effect on the
# number of outliers.
m &lt;- ggplot(movies, aes(y = votes, x = rating, group = cut_width(rating, 0.5)))
m + geom_violin()
m +
  geom_violin() +
  scale_y_log10()
m +
  geom_violin() +
  coord_trans(y = "log10")
m +
  geom_violin() +
  scale_y_log10() + coord_trans(y = "log10")

# Violin plots with continuous x:
# Use the group aesthetic to group observations in violins
ggplot(movies, aes(year, budget)) +
  geom_violin()
ggplot(movies, aes(year, budget)) +
  geom_violin(aes(group = cut_width(year, 10)), scale = "width")
}

</code></pre>

<hr>
<h2 id='get_alt_text'>Extract alt text from a plot</h2><span id='topic+get_alt_text'></span><span id='topic+alt_text'></span>

<h3>Description</h3>

<p>This function returns a text that can be used as alt-text in webpages etc.
Currently it will use the <code>alt</code> label, added with <code style="white-space: pre;">&#8288;+ labs(alt = &lt;...&gt;)&#8288;</code>, or
a return an empty string, but in the future it might try to generate an alt
text from the information stored in the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_alt_text(p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_alt_text_+3A_p">p</code></td>
<td>
<p>a ggplot object</p>
</td></tr>
<tr><td><code id="get_alt_text_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A text string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mpg, aes(displ, hwy)) +
  geom_point()

# Returns an empty string
get_alt_text(p)

# A user provided alt text
p &lt;- p + labs(
  alt = paste("A scatterplot showing the negative correlation between engine",
              "displacement as a function of highway miles per gallon")
)

get_alt_text(p)

</code></pre>

<hr>
<h2 id='get_guide_data'>Extract tick information from guides</h2><span id='topic+get_guide_data'></span>

<h3>Description</h3>

<p><code>get_guide_data()</code> builds a plot and extracts information from guide keys. This
information typically contains positions, values and/or labels, depending
on which aesthetic is queried or guide is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_guide_data(plot = last_plot(), aesthetic, panel = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_guide_data_+3A_plot">plot</code></td>
<td>
<p>A <code>ggplot</code> or <code>ggplot_build</code> object.</p>
</td></tr>
<tr><td><code id="get_guide_data_+3A_aesthetic">aesthetic</code></td>
<td>
<p>A string that describes a single aesthetic for which to
extract guide information. For example: <code>"colour"</code>, <code>"size"</code>, <code>"x"</code> or
<code>"y.sec"</code>.</p>
</td></tr>
<tr><td><code id="get_guide_data_+3A_panel">panel</code></td>
<td>
<p>An integer giving a panel number for which to return position guide
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One of the following:
</p>

<ul>
<li><p> A <code>data.frame</code> representing the guide key, when the guide is unique for
the aesthetic.
</p>
</li>
<li><p> A <code>list</code> when the coord does not support position axes or multiple guides
match the aesthetic.
</p>
</li>
<li> <p><code>NULL</code> when no guide key could be found.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># A standard plot
p &lt;- ggplot(mtcars) +
  aes(mpg, disp, colour = drat, size = drat) +
  geom_point() +
  facet_wrap(vars(cyl), scales = "free_x")

# Guide information for legends
get_guide_data(p, "size")

# Note that legend guides can be merged
merged &lt;- p + guides(colour = "legend")
get_guide_data(merged, "size")

# Guide information for positions
get_guide_data(p, "x", panel = 2)

# Coord polar doesn't support proper guides, so we get a list
polar &lt;- p + coord_polar()
get_guide_data(polar, "theta", panel = 2)
</code></pre>

<hr>
<h2 id='gg_dep'>Give a deprecation error, warning, or message, depending on version number.</h2><span id='topic+gg_dep'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_dep(version, msg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_dep_+3A_version">version</code></td>
<td>
<p>The last version of ggplot2 where this function was good
(in other words, the last version where it was not deprecated).</p>
</td></tr>
<tr><td><code id="gg_dep_+3A_msg">msg</code></td>
<td>
<p>The message to print.</p>
</td></tr>
</table>

<hr>
<h2 id='ggplot'>Create a new ggplot</h2><span id='topic+ggplot'></span>

<h3>Description</h3>

<p><code>ggplot()</code> initializes a ggplot object. It can be used to
declare the input data frame for a graphic and to specify the
set of plot aesthetics intended to be common throughout all
subsequent layers unless specifically overridden.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot(data = NULL, mapping = aes(), ..., environment = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_+3A_data">data</code></td>
<td>
<p>Default dataset to use for plot. If not already a data.frame,
will be converted to one by <code><a href="#topic+fortify">fortify()</a></code>. If not specified,
must be supplied in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_mapping">mapping</code></td>
<td>
<p>Default list of aesthetic mappings to use for plot.
If not specified, must be supplied in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_environment">environment</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Used prior to tidy
evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggplot()</code> is used to construct the initial plot object,
and is almost always followed by a plus sign (<code>+</code>) to add
components to the plot.
</p>
<p>There are three common patterns used to invoke <code>ggplot()</code>:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;ggplot(data = df, mapping = aes(x, y, other aesthetics))&#8288;</code>
</p>
</li>
<li> <p><code>ggplot(data = df)</code>
</p>
</li>
<li> <p><code>ggplot()</code>
</p>
</li></ul>

<p>The first pattern is recommended if all layers use the same
data and the same set of aesthetics, although this method
can also be used when adding a layer using data from another
data frame.
</p>
<p>The second pattern specifies the default data frame to use
for the plot, but no aesthetics are defined up front. This
is useful when one data frame is used predominantly for the
plot, but the aesthetics vary from one layer to another.
</p>
<p>The third pattern initializes a skeleton <code>ggplot</code> object, which
is fleshed out as layers are added. This is useful when
multiple data frames are used to produce different layers, as
is often the case in complex graphics.
</p>
<p>The <code style="white-space: pre;">&#8288;data =&#8288;</code> and <code style="white-space: pre;">&#8288;mapping =&#8288;</code> specifications in the arguments are optional
(and are often omitted in practice), so long as the data and the mapping
values are passed into the function in the right order. In the examples
below, however, they are left in place for clarity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a data frame with some sample data, then create a data frame
# containing the mean value for each group in the sample data.
set.seed(1)

sample_df &lt;- data.frame(
  group = factor(rep(letters[1:3], each = 10)),
  value = rnorm(30)
)

group_means_df &lt;- setNames(
  aggregate(value ~ group, sample_df, mean),
  c("group", "group_mean")
)

# The following three code blocks create the same graphic, each using one
# of the three patterns specified above. In each graphic, the sample data
# are plotted in the first layer and the group means data frame is used to
# plot larger red points on top of the sample data in the second layer.

# Pattern 1
# Both the `data` and `mapping` arguments are passed into the `ggplot()`
# call. Those arguments are omitted in the first `geom_point()` layer
# because they get passed along from the `ggplot()` call. Note that the
# second `geom_point()` layer re-uses the `x = group` aesthetic through
# that mechanism but overrides the y-position aesthetic.
ggplot(data = sample_df, mapping = aes(x = group, y = value)) +
  geom_point() +
  geom_point(
    mapping = aes(y = group_mean), data = group_means_df,
    colour = 'red', size = 3
  )

# Pattern 2
# Same plot as above, passing only the `data` argument into the `ggplot()`
# call. The `mapping` arguments are now required in each `geom_point()`
# layer because there is no `mapping` argument passed along from the
# `ggplot()` call.
ggplot(data = sample_df) +
  geom_point(mapping = aes(x = group, y = value)) +
  geom_point(
    mapping = aes(x = group, y = group_mean), data = group_means_df,
    colour = 'red', size = 3
  )

# Pattern 3
# Same plot as above, passing neither the `data` or `mapping` arguments
# into the `ggplot()` call. Both those arguments are now required in
# each `geom_point()` layer. This pattern can be particularly useful when
# creating more complex graphics with many layers using data from multiple
# data frames.
ggplot() +
  geom_point(mapping = aes(x = group, y = value), data = sample_df) +
  geom_point(
    mapping = aes(x = group, y = group_mean), data = group_means_df,
    colour = 'red', size = 3
  )
</code></pre>

<hr>
<h2 id='ggplot_add'>Add custom objects to ggplot</h2><span id='topic+ggplot_add'></span>

<h3>Description</h3>

<p>This generic allows you to add your own methods for adding custom objects to
a ggplot with <a href="#topic++2B.gg">+.gg</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_add(object, plot, object_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_add_+3A_object">object</code></td>
<td>
<p>An object to add to the plot</p>
</td></tr>
<tr><td><code id="ggplot_add_+3A_plot">plot</code></td>
<td>
<p>The ggplot object to add <code>object</code> to</p>
</td></tr>
<tr><td><code id="ggplot_add_+3A_object_name">object_name</code></td>
<td>
<p>The name of the object to add</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified ggplot object
</p>

<hr>
<h2 id='ggplot_build'>Build ggplot for rendering.</h2><span id='topic+ggplot_build'></span><span id='topic+layer_data'></span><span id='topic+layer_scales'></span><span id='topic+layer_grob'></span>

<h3>Description</h3>

<p><code>ggplot_build()</code> takes the plot object, and performs all steps necessary
to produce an object that can be rendered.  This function outputs two pieces:
a list of data frames (one for each layer), and a panel object, which
contain all information about axis limits, breaks etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_build(plot)

layer_data(plot = last_plot(), i = 1L)

layer_scales(plot = last_plot(), i = 1L, j = 1L)

layer_grob(plot = last_plot(), i = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_build_+3A_plot">plot</code></td>
<td>
<p>ggplot object</p>
</td></tr>
<tr><td><code id="ggplot_build_+3A_i">i</code></td>
<td>
<p>An integer. In <code>layer_data()</code>, the data to return (in the order added to the
plot). In <code>layer_grob()</code>, the grob to return (in the order added to the
plot). In <code>layer_scales()</code>, the row of a facet to return scales for.</p>
</td></tr>
<tr><td><code id="ggplot_build_+3A_j">j</code></td>
<td>
<p>An integer. In <code>layer_scales()</code>, the column of a facet to return
scales for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>layer_data()</code>, <code>layer_grob()</code>, and <code>layer_scales()</code> are helper
functions that return the data, grob, or scales associated with a given
layer. These are useful for tests.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.ggplot">print.ggplot()</a></code> and <code><a href="#topic+benchplot">benchplot()</a></code> for
functions that contain the complete set of steps for generating
a ggplot2 plot.
</p>

<hr>
<h2 id='ggplot_gtable'>Build a plot with all the usual bits and pieces.</h2><span id='topic+ggplot_gtable'></span>

<h3>Description</h3>

<p>This function builds all grobs necessary for displaying the plot, and
stores them in a special data structure called a <code><a href="gtable.html#topic+gtable">gtable()</a></code>.
This object is amenable to programmatic manipulation, should you want
to (e.g.) make the legend box 2 cm wide, or combine multiple plots into
a single display, preserving aspect ratios across the plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_gtable(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_gtable_+3A_data">data</code></td>
<td>
<p>plot data generated by <code><a href="#topic+ggplot_build">ggplot_build()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="gtable.html#topic+gtable">gtable()</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.ggplot">print.ggplot()</a></code> and <code><a href="#topic+benchplot">benchplot()</a></code> for
for functions that contain the complete set of steps for generating
a ggplot2 plot.
</p>

<hr>
<h2 id='ggplot2-ggproto'>Base ggproto classes for ggplot2</h2><span id='topic+ggplot2-ggproto'></span><span id='topic+Geom'></span><span id='topic+GeomCustomAnn'></span><span id='topic+GeomLogticks'></span><span id='topic+GeomPolygon'></span><span id='topic+GeomMap'></span><span id='topic+GeomAnnotationMap'></span><span id='topic+GeomRaster'></span><span id='topic+GeomRasterAnn'></span><span id='topic+AxisSecondary'></span><span id='topic+Coord'></span><span id='topic+CoordCartesian'></span><span id='topic+CoordFixed'></span><span id='topic+CoordFlip'></span><span id='topic+CoordMap'></span><span id='topic+CoordPolar'></span><span id='topic+CoordQuickmap'></span><span id='topic+CoordRadial'></span><span id='topic+CoordTrans'></span><span id='topic+Facet'></span><span id='topic+FacetGrid'></span><span id='topic+FacetNull'></span><span id='topic+FacetWrap'></span><span id='topic+Stat'></span><span id='topic+GeomAbline'></span><span id='topic+GeomRect'></span><span id='topic+GeomBar'></span><span id='topic+GeomBlank'></span><span id='topic+GeomBoxplot'></span><span id='topic+GeomCol'></span><span id='topic+GeomPath'></span><span id='topic+GeomLine'></span><span id='topic+GeomStep'></span><span id='topic+GeomContour'></span><span id='topic+GeomContourFilled'></span><span id='topic+GeomCrossbar'></span><span id='topic+GeomSegment'></span><span id='topic+GeomCurve'></span><span id='topic+GeomRibbon'></span><span id='topic+GeomArea'></span><span id='topic+GeomDensity'></span><span id='topic+GeomDensity2d'></span><span id='topic+GeomDensity2dFilled'></span><span id='topic+GeomDotplot'></span><span id='topic+GeomErrorbar'></span><span id='topic+GeomErrorbarh'></span><span id='topic+GeomFunction'></span><span id='topic+GeomHex'></span><span id='topic+GeomHline'></span><span id='topic+GeomLabel'></span><span id='topic+GeomLinerange'></span><span id='topic+GeomPoint'></span><span id='topic+GeomPointrange'></span><span id='topic+GeomQuantile'></span><span id='topic+GeomRug'></span><span id='topic+GeomSmooth'></span><span id='topic+GeomSpoke'></span><span id='topic+GeomText'></span><span id='topic+GeomTile'></span><span id='topic+GeomViolin'></span><span id='topic+GeomVline'></span><span id='topic+Guide'></span><span id='topic+GuideAxis'></span><span id='topic+GuideAxisLogticks'></span><span id='topic+GuideAxisStack'></span><span id='topic+GuideAxisTheta'></span><span id='topic+GuideLegend'></span><span id='topic+GuideBins'></span><span id='topic+GuideColourbar'></span><span id='topic+GuideColoursteps'></span><span id='topic+GuideCustom'></span><span id='topic+GuideNone'></span><span id='topic+GuideOld'></span><span id='topic+Layout'></span><span id='topic+Position'></span><span id='topic+PositionDodge'></span><span id='topic+PositionDodge2'></span><span id='topic+PositionIdentity'></span><span id='topic+PositionJitter'></span><span id='topic+PositionJitterdodge'></span><span id='topic+PositionNudge'></span><span id='topic+PositionStack'></span><span id='topic+PositionFill'></span><span id='topic+Scale'></span><span id='topic+ScaleContinuous'></span><span id='topic+ScaleDiscrete'></span><span id='topic+ScaleBinned'></span><span id='topic+ScaleBinnedPosition'></span><span id='topic+ScaleContinuousPosition'></span><span id='topic+ScaleContinuousDatetime'></span><span id='topic+ScaleContinuousDate'></span><span id='topic+ScaleDiscretePosition'></span><span id='topic+ScaleDiscreteIdentity'></span><span id='topic+ScaleContinuousIdentity'></span><span id='topic+StatAlign'></span><span id='topic+StatBin'></span><span id='topic+StatBin2d'></span><span id='topic+StatBindot'></span><span id='topic+StatBinhex'></span><span id='topic+StatBoxplot'></span><span id='topic+StatContour'></span><span id='topic+StatContourFilled'></span><span id='topic+StatCount'></span><span id='topic+StatDensity2d'></span><span id='topic+StatDensity2dFilled'></span><span id='topic+StatDensity'></span><span id='topic+StatEcdf'></span><span id='topic+StatEllipse'></span><span id='topic+StatFunction'></span><span id='topic+StatIdentity'></span><span id='topic+StatQqLine'></span><span id='topic+StatQq'></span><span id='topic+StatQuantile'></span><span id='topic+StatSmooth'></span><span id='topic+StatSum'></span><span id='topic+StatSummary2d'></span><span id='topic+StatSummaryBin'></span><span id='topic+StatSummaryHex'></span><span id='topic+StatSummary'></span><span id='topic+StatUnique'></span><span id='topic+StatYdensity'></span>

<h3>Description</h3>

<p>If you are creating a new geom, stat, position, or scale in another package,
you'll need to extend from <code>ggplot2::Geom</code>, <code>ggplot2::Stat</code>,
<code>ggplot2::Position</code>, or <code>ggplot2::Scale</code>.
</p>


<h3>Geoms</h3>

<p>All <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> functions (like <code>geom_point()</code>) return a layer that
contains a <code style="white-space: pre;">&#8288;Geom*&#8288;</code> object (like <code>GeomPoint</code>). The <code style="white-space: pre;">&#8288;Geom*&#8288;</code>
object is responsible for rendering the data in the plot.
</p>
<p>Each of the <code style="white-space: pre;">&#8288;Geom*&#8288;</code> objects is a <code><a href="#topic+ggproto">ggproto()</a></code> object, descended
from the top-level <code>Geom</code>, and each implements various methods and
fields.
</p>
<p>Compared to <code>Stat</code> and <code>Position</code>, <code>Geom</code> is a little
different because the execution of the setup and compute functions is
split up. <code>setup_data</code> runs before position adjustments, and
<code>draw_layer()</code> is not run until render time, much later.
</p>
<p>To create a new type of Geom object, you typically will want to
override one or more of the following:
</p>

<ul>
<li><p> Either <code>draw_panel(self, data, panel_params, coord)</code> or
<code>draw_group(self, data, panel_params, coord)</code>. <code>draw_panel</code> is
called once per panel, <code>draw_group</code> is called once per group.
</p>
<p>Use <code>draw_panel</code> if each row in the data represents a
single element. Use <code>draw_group</code> if each group represents
an element (e.g. a smooth, a violin).
</p>
<p><code>data</code> is a data frame of scaled aesthetics.
</p>
<p><code>panel_params</code> is a set of per-panel parameters for the
<code>coord</code>. Generally, you should consider <code>panel_params</code>
to be an opaque data structure that you pass along whenever you call
a coord method.
</p>
<p>You must always call <code>coord$transform(data, panel_params)</code> to
get the (position) scaled data for plotting. To work with
non-linear coordinate systems, you typically need to convert into a
primitive geom (e.g. point, path or polygon), and then pass on to the
corresponding draw method for munching.
</p>
<p>Must return a grob. Use <code><a href="#topic+zeroGrob">zeroGrob()</a></code> if there's nothing to
draw.
</p>
</li>
<li> <p><code>draw_key</code>: Renders a single legend key.
</p>
</li>
<li> <p><code>required_aes</code>: A character vector of aesthetics needed to
render the geom.
</p>
</li>
<li> <p><code>default_aes</code>: A list (generated by <code><a href="#topic+aes">aes()</a></code> of
default values for aesthetics.
</p>
</li>
<li> <p><code>setup_data</code>: Converts width and height to xmin and xmax,
and ymin and ymax values. It can potentially set other values as well.
</p>
</li></ul>



<h3>Coordinate systems</h3>

<p>All <code style="white-space: pre;">&#8288;coord_*()&#8288;</code> functions (like <code>coord_trans()</code>) return a <code style="white-space: pre;">&#8288;Coord*&#8288;</code>
object (like <code>CoordTrans</code>).
</p>
<p>Each of the <code style="white-space: pre;">&#8288;Coord*&#8288;</code> objects is a <code><a href="#topic+ggproto">ggproto()</a></code> object,
descended from the top-level <code>Coord</code>.  To create a new type of Coord
object, you typically will want to implement one or more of the following:
</p>

<ul>
<li> <p><code>aspect</code>: Returns the desired aspect ratio for the plot.
</p>
</li>
<li> <p><code>labels</code>: Returns a list containing labels for x and y.
</p>
</li>
<li> <p><code>render_fg</code>: Renders foreground elements.
</p>
</li>
<li> <p><code>render_bg</code>: Renders background elements.
</p>
</li>
<li> <p><code>render_axis_h</code>: Renders the horizontal axes.
</p>
</li>
<li> <p><code>render_axis_v</code>: Renders the vertical axes.
</p>
</li>
<li> <p><code>backtransform_range(panel_params)</code>: Extracts the panel range provided
in <code>panel_params</code> (created by <code>setup_panel_params()</code>, see below) and
back-transforms to data coordinates. This back-transformation can be needed
for coords such as <code>coord_trans()</code> where the range in the transformed
coordinates differs from the range in the untransformed coordinates. Returns
a list of two ranges, <code>x</code> and <code>y</code>, and these correspond to the variables
mapped to the <code>x</code> and <code>y</code> aesthetics, even for coords such as <code>coord_flip()</code>
where the <code>x</code> aesthetic is shown along the y direction and vice versa.
</p>
</li>
<li> <p><code>range(panel_params)</code>: Extracts the panel range provided
in <code>panel_params</code> (created by <code>setup_panel_params()</code>, see below) and
returns it. Unlike <code>backtransform_range()</code>, this function does not perform
any back-transformation and instead returns final transformed coordinates. Returns
a list of two ranges, <code>x</code> and <code>y</code>, and these correspond to the variables
mapped to the <code>x</code> and <code>y</code> aesthetics, even for coords such as <code>coord_flip()</code>
where the <code>x</code> aesthetic is shown along the y direction and vice versa.
</p>
</li>
<li> <p><code>transform</code>: Transforms x and y coordinates.
</p>
</li>
<li> <p><code>distance</code>: Calculates distance.
</p>
</li>
<li> <p><code>is_linear</code>: Returns <code>TRUE</code> if the coordinate system is
linear; <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>is_free</code>: Returns <code>TRUE</code> if the coordinate system supports free
positional scales; <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>setup_panel_params(scale_x, scale_y, params)</code>: Determines the appropriate
x and y ranges for each panel, and also calculates anything else needed to
render the panel and axes, such as tick positions and labels for major
and minor ticks. Returns all this information in a named list.
</p>
</li>
<li> <p><code>setup_data(data, params)</code>: Allows the coordinate system to
manipulate the plot data. Should return list of data frames.
</p>
</li>
<li> <p><code>setup_layout(layout, params)</code>: Allows the coordinate
system to manipulate the <code>layout</code> data frame which assigns
data to panels and scales.
</p>
</li></ul>



<h3>Facets</h3>

<p>All <code style="white-space: pre;">&#8288;facet_*&#8288;</code> functions returns a <code>Facet</code> object or an object of a
<code>Facet</code> subclass. This object describes how to assign data to different
panels, how to apply positional scales and how to lay out the panels, once
rendered.
</p>
<p>Extending facets can range from the simple modifications of current facets,
to very laborious rewrites with a lot of <code><a href="gtable.html#topic+gtable">gtable()</a></code> manipulation.
For some examples of both, please see the extension vignette.
</p>
<p><code>Facet</code> subclasses, like other extendible ggproto classes, have a range
of methods that can be modified. Some of these are required for all new
subclasses, while other only need to be modified if need arises.
</p>
<p>The required methods are:
</p>

<ul>
<li> <p><code>compute_layout</code>: Based on layer data compute a mapping between
panels, axes, and potentially other parameters such as faceting variable
level etc. This method must return a data.frame containing at least the
columns <code>PANEL</code>, <code>SCALE_X</code>, and <code>SCALE_Y</code> each containing
integer keys mapping a PANEL to which axes it should use. In addition the
data.frame can contain whatever other information is necessary to assign
observations to the correct panel as well as determining the position of
the panel.
</p>
</li>
<li> <p><code>map_data</code>: This method is supplied the data for each layer in
turn and is expected to supply a <code>PANEL</code> column mapping each row to a
panel defined in the layout. Additionally this method can also add or
subtract data points as needed e.g. in the case of adding margins to
<code>facet_grid()</code>.
</p>
</li>
<li> <p><code>draw_panels</code>: This is where the panels are assembled into a
<code>gtable</code> object. The method receives, among others, a list of grobs
defining the content of each panel as generated by the Geoms and Coord
objects. The responsibility of the method is to decorate the panels with
axes and strips as needed, as well as position them relative to each other
in a gtable. For some of the automatic functions to work correctly, each
panel, axis, and strip grob name must be prefixed with &quot;panel&quot;, &quot;axis&quot;, and
&quot;strip&quot; respectively.
</p>
</li></ul>

<p>In addition to the methods described above, it is also possible to override
the default behaviour of one or more of the following methods:
</p>

<ul>
<li> <p><code>setup_params</code>:
</p>
</li>
<li> <p><code>init_scales</code>: Given a master scale for x and y, create panel
specific scales for each panel defined in the layout. The default is to
simply clone the master scale.
</p>
</li>
<li> <p><code>train_scales</code>: Based on layer data train each set of panel
scales. The default is to train it on the data related to the panel.
</p>
</li>
<li> <p><code>finish_data</code>: Make last-minute modifications to layer data
before it is rendered by the Geoms. The default is to not modify it.
</p>
</li>
<li> <p><code>draw_back</code>: Add a grob in between the background defined by the
Coord object (usually the axis grid) and the layer stack. The default is to
return an empty grob for each panel.
</p>
</li>
<li> <p><code>draw_front</code>: As above except the returned grob is placed
between the layer stack and the foreground defined by the Coord object
(usually empty). The default is, as above, to return an empty grob.
</p>
</li>
<li> <p><code>draw_labels</code>: Given the gtable returned by <code>draw_panels</code>,
add axis titles to the gtable. The default is to add one title at each side
depending on the position and existence of axes.
</p>
</li></ul>

<p>All extension methods receive the content of the params field as the params
argument, so the constructor function will generally put all relevant
information into this field. The only exception is the <code>shrink</code>
parameter which is used to determine if scales are retrained after Stat
transformations has been applied.
</p>


<h3>Stats</h3>

<p>All <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> functions (like <code>stat_bin()</code>) return a layer that
contains a <code style="white-space: pre;">&#8288;Stat*&#8288;</code> object (like <code>StatBin</code>). The <code style="white-space: pre;">&#8288;Stat*&#8288;</code>
object is responsible for rendering the data in the plot.
</p>
<p>Each of the <code style="white-space: pre;">&#8288;Stat*&#8288;</code> objects is a <code><a href="#topic+ggproto">ggproto()</a></code> object, descended
from the top-level <code>Stat</code>, and each implements various methods and
fields. To create a new type of Stat object, you typically will want to
override one or more of the following:
</p>

<ul>
<li><p> One of :
<code>compute_layer(self, data, scales, ...)</code>,
<code>compute_panel(self, data, scales, ...)</code>, or
<code>compute_group(self, data, scales, ...)</code>.
</p>
<p><code>compute_layer()</code> is called once per layer, <code>compute_panel()</code>
is called once per panel, and <code>compute_group()</code> is called once per
group. All must return a data frame.
</p>
<p>It's usually best to start by overriding <code>compute_group</code>: if
you find substantial performance optimisations, override higher up.
You'll need to read the source code of the default methods to see
what else you should be doing.
</p>
<p><code>data</code> is a data frame containing the variables named according
to the aesthetics that they're mapped to. <code>scales</code> is a list
containing the <code>x</code> and <code>y</code> scales. There functions are called
before the facets are trained, so they are global scales, not local
to the individual panels.<code>...</code> contains the parameters returned by
<code>setup_params()</code>.
</p>
</li>
<li> <p><code>finish_layer(data, params)</code>: called once for each layer. Used
to modify the data after scales has been applied, but before the data is
handed of to the geom for rendering. The default is to not modify the
data. Use this hook if the stat needs access to the actual aesthetic
values rather than the values that are mapped to the aesthetic.
</p>
</li>
<li> <p><code>setup_params(data, params)</code>: called once for each layer.
Used to setup defaults that need to complete dataset, and to inform
the user of important choices. Should return list of parameters.
</p>
</li>
<li> <p><code>setup_data(data, params)</code>: called once for each layer,
after <code>setup_params()</code>. Should return modified <code>data</code>.
Default methods removes all rows containing a missing value in
required aesthetics (with a warning if <code>!na.rm</code>).
</p>
</li>
<li> <p><code>required_aes</code>: A character vector of aesthetics needed to
render the geom.
</p>
</li>
<li> <p><code>default_aes</code>: A list (generated by <code><a href="#topic+aes">aes()</a></code> of
default values for aesthetics.
</p>
</li></ul>



<h3>Guides</h3>

<p>The <code style="white-space: pre;">&#8288;guide_*()&#8288;</code> functions, such as <code>guide_legend()</code> return an object that
is responsible for displaying how objects in the plotting panel are related
to actual values.
</p>
<p>Each of the <code style="white-space: pre;">&#8288;Guide*&#8288;</code> object is a <code><a href="#topic+ggproto">ggproto()</a></code> object, descended from the
top-level <code>Guide</code>, and each implements their own methods for drawing.
</p>
<p>To create a new type of Guide object, you typically will want to override
one or more of the following:
</p>
<p>Properties:
</p>

<ul>
<li> <p><code>available_aes</code> A <code>character</code> vector with aesthetics that this guide
supports. The value <code>"any"</code> indicates all non-position aesthetics.
</p>
</li>
<li> <p><code>params</code> A named <code>list</code> of parameters that the guide needs to function.
It has the following roles:
</p>

<ul>
<li> <p><code>params</code> provides the defaults for a guide.
</p>
</li>
<li> <p><code>names(params)</code> determines what are valid arguments to <code>new_guide()</code>.
Some parameters are <em>required</em> to render the guide. These are: <code>title</code>,
<code>name</code>, <code>position</code>, <code>direction</code>, <code>order</code> and <code>hash</code>.
</p>
</li>
<li><p> During build stages, <code>params</code> holds information about the guide.
</p>
</li></ul>

</li>
<li> <p><code>elements</code> A named list of <code>character</code>s, giving the name of theme elements
that should be retrieved automatically, for example <code>"legend.text"</code>.
</p>
</li>
<li> <p><code>hashables</code> An <code>expression</code> that can be evaluated in the context of
<code>params</code>. The hash of the evaluated expression determines the merge
compatibility of guides, and is stored in <code>params$hash</code>.
</p>
</li></ul>

<p>Methods:
</p>

<ul>
<li> <p><code>extract_key()</code> Returns a <code>data.frame</code> with (mapped) breaks and labels
extracted from the scale, which will be stored in <code>params$key</code>.
</p>
</li>
<li> <p><code>extract_decor()</code> Returns a <code>data.frame</code> containing other structured
information extracted from the scale, which will be stored in
<code>params$decor</code>. The <code>decor</code> has a guide-specific  meaning: it is the bar in
<code>guide_colourbar()</code>, but specifies the <code>axis.line</code> in <code>guide_axis()</code>.
</p>
</li>
<li> <p><code>extract_params()</code> Updates the <code>params</code> with other, unstructured
information from the scale. An example of this is inheriting the guide's
title from the <code>scale$name</code> field.
</p>
</li>
<li> <p><code>transform()</code> Updates the <code>params$key</code> based on the coordinates. This
applies to position guides, as it rescales the aesthetic to the [0, 1]
range.
</p>
</li>
<li> <p><code>merge()</code> Combines information from multiple guides with the same
<code>params$hash</code>. This ensures that e.g. <code>guide_legend()</code> can display both
<code>shape</code> and <code>colour</code> in the same guide.
</p>
</li>
<li> <p><code>process_layers()</code> Extract information from layers. This acts mostly
as a filter for which layers to include and these are then (typically)
forwarded to <code>get_layer_key()</code>.
</p>
</li>
<li> <p><code>get_layer_key()</code> This can be used to gather information about how legend
keys should be displayed.
</p>
</li>
<li> <p><code>setup_params()</code> Set up parameters at the beginning of drawing stages.
It can be used to overrule user-supplied parameters or perform checks on
the <code>params</code> property.
</p>
</li>
<li> <p><code>override_elements()</code> Take populated theme elements derived from the
<code>elements</code> property and allows overriding these theme settings.
</p>
</li>
<li> <p><code>build_title()</code> Render the guide's title.
</p>
</li>
<li> <p><code>build_labels()</code> Render the guide's labels.
</p>
</li>
<li> <p><code>build_decor()</code> Render the <code>params$decor</code>, which is different for every
guide.
</p>
</li>
<li> <p><code>build_ticks()</code> Render tick marks.
</p>
</li>
<li> <p><code>measure_grobs()</code> Measure dimensions of the graphical objects produced
by the <code style="white-space: pre;">&#8288;build_*()&#8288;</code> methods to be used in the layout or assembly.
</p>
</li>
<li> <p><code>arrange_layout()</code> Set up a layout for how graphical objects produced by
the <code style="white-space: pre;">&#8288;build_*()&#8288;</code> methods should be arranged.
</p>
</li>
<li> <p><code>assemble_drawing()</code> Take the graphical objects produced by the <code style="white-space: pre;">&#8288;build_*()&#8288;</code>
methods, the measurements from <code>measure_grobs()</code> and layout from
<code>arrange_layout()</code> to finalise the guide.
</p>
</li>
<li> <p><code>add_title</code> Adds the title to a gtable, taking into account the size
of the title as well as the gtable size.
</p>
</li></ul>



<h3>Positions</h3>

<p>All <code style="white-space: pre;">&#8288;position_*()&#8288;</code> functions (like <code>position_dodge()</code>) return a
<code style="white-space: pre;">&#8288;Position*&#8288;</code> object (like <code>PositionDodge</code>). The <code style="white-space: pre;">&#8288;Position*&#8288;</code>
object is responsible for adjusting the position of overlapping geoms.
</p>
<p>The way that the <code style="white-space: pre;">&#8288;position_*&#8288;</code> functions work is slightly different from
the <code style="white-space: pre;">&#8288;geom_*&#8288;</code> and <code style="white-space: pre;">&#8288;stat_*&#8288;</code> functions, because a <code style="white-space: pre;">&#8288;position_*&#8288;</code>
function actually &quot;instantiates&quot; the <code style="white-space: pre;">&#8288;Position*&#8288;</code> object by creating a
descendant, and returns that.
</p>
<p>Each of the <code style="white-space: pre;">&#8288;Position*&#8288;</code> objects is a <code><a href="#topic+ggproto">ggproto()</a></code> object,
descended from the top-level <code>Position</code>, and each implements the
following methods:
</p>

<ul>
<li> <p><code>compute_layer(self, data, params, panel)</code> is called once
per layer. <code>panel</code> is currently an internal data structure, so
this method should not be overridden.
</p>
</li>
<li> <p><code>compute_panel(self, data, params, scales)</code> is called once per
panel and should return a modified data frame.
</p>
<p><code>data</code> is a data frame containing the variables named according
to the aesthetics that they're mapped to. <code>scales</code> is a list
containing the <code>x</code> and <code>y</code> scales. There functions are called
before the facets are trained, so they are global scales, not local
to the individual panels. <code>params</code> contains the parameters returned by
<code>setup_params()</code>.
</p>
</li>
<li> <p><code>setup_params(data, params)</code>: called once for each layer.
Used to setup defaults that need to complete dataset, and to inform
the user of important choices. Should return list of parameters.
</p>
</li>
<li> <p><code>setup_data(data, params)</code>: called once for each layer,
after <code>setup_params()</code>. Should return modified <code>data</code>.
Default checks that required aesthetics are present.
</p>
</li></ul>

<p>And the following fields
</p>

<ul>
<li> <p><code>required_aes</code>: a character vector giving the aesthetics
that must be present for this position adjustment to work.
</p>
</li></ul>



<h3>Scales</h3>

<p>All <code style="white-space: pre;">&#8288;scale_*&#8288;</code> functions like <code><a href="#topic+scale_x_continuous">scale_x_continuous()</a></code> return a <code style="white-space: pre;">&#8288;Scale*&#8288;</code>
object like <code>ScaleContinuous</code>. Each of the <code style="white-space: pre;">&#8288;Scale*&#8288;</code> objects is a <code><a href="#topic+ggproto">ggproto()</a></code>
object, descended from the top-level <code>Scale</code>.
</p>
<p>Properties not documented in <code><a href="#topic+continuous_scale">continuous_scale()</a></code> or <code><a href="#topic+discrete_scale">discrete_scale()</a></code>:
</p>

<ul>
<li> <p><code>call</code> The call to <code><a href="#topic+continuous_scale">continuous_scale()</a></code> or <code><a href="#topic+discrete_scale">discrete_scale()</a></code> that constructed
the scale.
</p>
</li>
<li> <p><code>range</code> One of <code>continuous_range()</code> or <code>discrete_range()</code>.
</p>
</li></ul>

<p>Methods:
</p>

<ul>
<li> <p><code>is_discrete()</code> Returns <code>TRUE</code> if the scale is a discrete scale
</p>
</li>
<li> <p><code>is_empty()</code> Returns <code>TRUE</code> if the scale contains no information (i.e.,
it has no information with which to calculate its <code>limits</code>).
</p>
</li>
<li> <p><code>clone()</code> Returns a copy of the scale that can be trained
independently without affecting the original scale.
</p>
</li>
<li> <p><code>transform()</code> Transforms a vector of values using <code>self$trans</code>.
This occurs before the <code>Stat</code> is calculated.
</p>
</li>
<li> <p><code>train()</code> Update the <code>self$range</code> of observed (transformed) data values with
a vector of (possibly) new values.
</p>
</li>
<li> <p><code>reset()</code> Reset the <code>self$range</code> of observed data values. For discrete
position scales, only the continuous range is reset.
</p>
</li>
<li> <p><code>map()</code> Map transformed data values to some output value as
determined by <code>self$rescale()</code> and <code>self$palette</code> (except for position scales,
which do not use the default implementation of this method). The output corresponds
to the transformed data value in aesthetic space (e.g., a color, line width, or size).
</p>
</li>
<li> <p><code>rescale()</code> Rescale transformed data to the the range 0, 1. This is most useful for
position scales. For continuous scales, <code>rescale()</code> uses the <code>rescaler</code> that
was provided to the constructor. <code>rescale()</code> does not apply <code>self$oob()</code> to
its input, which means that discrete values outside <code>limits</code> will be <code>NA</code>, and
values that are outside <code>range</code> will have values less than 0 or greater than 1.
This allows guides more control over how out-of-bounds values are displayed.
</p>
</li>
<li> <p><code>transform_df()</code>, <code>train_df()</code>, <code>map_df()</code> These <code style="white-space: pre;">&#8288;_df&#8288;</code> variants
accept a data frame, and apply the <code>transform</code>, <code>train</code>, and <code>map</code> methods
(respectively) to the columns whose names are in <code>self$aesthetics</code>.
</p>
</li>
<li> <p><code>get_limits()</code> Calculates the final scale limits in transformed data space
based on the combination of <code>self$limits</code> and/or the range of observed values
(<code>self$range</code>).
</p>
</li>
<li> <p><code>get_breaks()</code> Calculates the final scale breaks in transformed data space
based on on the combination of <code>self$breaks</code>, <code>self$trans$breaks()</code> (for
continuous scales), and <code>limits</code>. Breaks outside of <code>limits</code> are assigned
a value of <code>NA</code> (continuous scales) or dropped (discrete scales).
</p>
</li>
<li> <p><code>get_labels()</code> Calculates labels for a given set of (transformed) <code>breaks</code>
based on the combination of <code>self$labels</code> and <code>breaks</code>.
</p>
</li>
<li> <p><code>get_breaks_minor()</code> For continuous scales, calculates the final scale minor breaks
in transformed data space based on the rescaled <code>breaks</code>, the value of <code>self$minor_breaks</code>,
and the value of <code>self$trans$minor_breaks()</code>. Discrete scales always return <code>NULL</code>.
</p>
</li>
<li> <p><code>get_transformation()</code> Returns the scale's transformation object.
</p>
</li>
<li> <p><code>make_title()</code> Hook to modify the title that is calculated during guide construction
(for non-position scales) or when the <code>Layout</code> calculates the x and y labels
(position scales).
</p>
</li></ul>

<p>These methods are only valid for position (x and y) scales:
</p>

<ul>
<li> <p><code>dimension()</code> For continuous scales, the dimension is the same concept as the limits.
For discrete scales, <code>dimension()</code> returns a continuous range, where the limits
would be placed at integer positions. <code>dimension()</code> optionally expands
this range given an expansion of length 4 (see <code><a href="#topic+expansion">expansion()</a></code>).
</p>
</li>
<li> <p><code>break_info()</code> Returns a <code>list()</code> with calculated values needed for the <code>Coord</code>
to transform values in transformed data space. Axis and grid guides also use
these values to draw guides. This is called with
a (usually expanded) continuous range, such as that returned by <code>self$dimension()</code>
(even for discrete scales). The list has components <code>major_source</code>
(<code>self$get_breaks()</code> for continuous scales, or <code>seq_along(self$get_breaks())</code>
for discrete scales), <code>major</code> (the rescaled value of <code>major_source</code>, ignoring
<code>self$rescaler</code>), <code>minor</code> (the rescaled value of <code>minor_source</code>, ignoring
<code>self$rescaler</code>), <code>range</code> (the range that was passed in to <code>break_info()</code>),
<code>labels</code> (the label values, one for each element in <code>breaks</code>).
</p>
</li>
<li> <p><code>axis_order()</code> One of <code>c("primary", "secondary")</code> or <code>c("secondary", "primary")</code>
</p>
</li>
<li> <p><code>make_sec_title()</code> Hook to modify the title for the second axis that is calculated
when the <code>Layout</code> calculates the x and y labels.
</p>
</li></ul>



<h3>See Also</h3>

<p>ggproto
</p>

<hr>
<h2 id='ggplot2-package'>ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics</h2><span id='topic+ggplot2'></span><span id='topic+ggplot2-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A system for 'declaratively' creating graphics, based on &quot;The Grammar of Graphics&quot;. You provide the data, tell 'ggplot2' how to map variables to aesthetics, what graphical primitives to use, and it takes care of the details.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomas.pedersen@posit.co">thomas.pedersen@posit.co</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a> (<a href="https://orcid.org/0000-0003-4757-117X">ORCID</a>)
</p>
</li>
<li><p> Winston Chang (<a href="https://orcid.org/0000-0002-1576-2126">ORCID</a>)
</p>
</li>
<li><p> Lionel Henry
</p>
</li>
<li><p> Kohske Takahashi
</p>
</li>
<li><p> Claus Wilke (<a href="https://orcid.org/0000-0002-7470-9261">ORCID</a>)
</p>
</li>
<li><p> Kara Woo (<a href="https://orcid.org/0000-0002-5125-4188">ORCID</a>)
</p>
</li>
<li><p> Hiroaki Yutani (<a href="https://orcid.org/0000-0002-3385-7233">ORCID</a>)
</p>
</li>
<li><p> Dewey Dunnington (<a href="https://orcid.org/0000-0002-9415-4582">ORCID</a>)
</p>
</li>
<li><p> Teun van den Brand (<a href="https://orcid.org/0000-0002-9335-7468">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ggplot2.tidyverse.org">https://ggplot2.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/ggplot2">https://github.com/tidyverse/ggplot2</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/ggplot2/issues">https://github.com/tidyverse/ggplot2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ggplotGrob'>Generate a ggplot2 plot grob.</h2><span id='topic+ggplotGrob'></span>

<h3>Description</h3>

<p>Generate a ggplot2 plot grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplotGrob(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplotGrob_+3A_x">x</code></td>
<td>
<p>ggplot2 object</p>
</td></tr>
</table>

<hr>
<h2 id='ggproto'>Create a new ggproto object</h2><span id='topic+ggproto'></span><span id='topic+ggproto_parent'></span><span id='topic+is.ggproto'></span>

<h3>Description</h3>

<p>Construct a new object with <code>ggproto()</code>, test with <code>is.ggproto()</code>,
and access parent methods/fields with <code>ggproto_parent()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggproto(`_class` = NULL, `_inherit` = NULL, ...)

ggproto_parent(parent, self)

is.ggproto(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggproto_+3A__class">_class</code></td>
<td>
<p>Class name to assign to the object. This is stored as the class
attribute of the object. This is optional: if <code>NULL</code> (the default),
no class name will be added to the object.</p>
</td></tr>
<tr><td><code id="ggproto_+3A__inherit">_inherit</code></td>
<td>
<p>ggproto object to inherit from. If <code>NULL</code>, don't
inherit from any object.</p>
</td></tr>
<tr><td><code id="ggproto_+3A_...">...</code></td>
<td>
<p>A list of members in the ggproto object.</p>
</td></tr>
<tr><td><code id="ggproto_+3A_parent">parent</code>, <code id="ggproto_+3A_self">self</code></td>
<td>
<p>Access parent class <code>parent</code> of object <code>self</code>.</p>
</td></tr>
<tr><td><code id="ggproto_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ggproto implements a protype based OO system which blurs the lines between
classes and instances. It is inspired by the proto package, but it has some
important differences. Notably, it cleanly supports cross-package
inheritance, and has faster performance.
</p>
<p>In most cases, creating a new OO system to be used by a single package is
not a good idea. However, it was the least-bad solution for ggplot2 because
it required the fewest changes to an already complex code base.
</p>


<h3>Calling methods</h3>

<p>ggproto methods can take an optional <code>self</code> argument: if it is present,
it is a regular method; if it's absent, it's a &quot;static&quot; method (i.e. it
doesn't use any fields).
</p>
<p>Imagine you have a ggproto object <code>Adder</code>, which has a
method <code>addx = function(self, n) n + self$x</code>. Then, to call this
function, you would use <code>Adder$addx(10)</code> &ndash; the <code>self</code> is passed
in automatically by the wrapper function. <code>self</code> be located anywhere
in the function signature, although customarily it comes first.
</p>


<h3>Calling methods in a parent</h3>

<p>To explicitly call a methods in a parent, use
<code>ggproto_parent(Parent, self)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Adder &lt;- ggproto("Adder",
  x = 0,
  add = function(self, n) {
    self$x &lt;- self$x + n
    self$x
  }
 )
is.ggproto(Adder)

Adder$add(10)
Adder$add(10)

Doubler &lt;- ggproto("Doubler", Adder,
  add = function(self, n) {
    ggproto_parent(Adder, self)$add(n * 2)
  }
)
Doubler$x
Doubler$add(10)
</code></pre>

<hr>
<h2 id='ggsave'>Save a ggplot (or other grid object) with sensible defaults</h2><span id='topic+ggsave'></span>

<h3>Description</h3>

<p><code>ggsave()</code> is a convenient function for saving a plot. It defaults to
saving the last plot that you displayed, using the size of the current
graphics device. It also guesses the type of graphics device from the
extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggsave(
  filename,
  plot = last_plot(),
  device = NULL,
  path = NULL,
  scale = 1,
  width = NA,
  height = NA,
  units = c("in", "cm", "mm", "px"),
  dpi = 300,
  limitsize = TRUE,
  bg = NULL,
  create.dir = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggsave_+3A_filename">filename</code></td>
<td>
<p>File name to create on disk.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_plot">plot</code></td>
<td>
<p>Plot to save, defaults to last plot displayed.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_device">device</code></td>
<td>
<p>Device to use. Can either be a device function
(e.g. <a href="grDevices.html#topic+png">png</a>), or one of &quot;eps&quot;, &quot;ps&quot;, &quot;tex&quot; (pictex),
&quot;pdf&quot;, &quot;jpeg&quot;, &quot;tiff&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;svg&quot; or &quot;wmf&quot; (windows only). If
<code>NULL</code> (default), the device is guessed based on the <code>filename</code> extension.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_path">path</code></td>
<td>
<p>Path of the directory to save plot to: <code>path</code> and <code>filename</code>
are combined to create the fully qualified file name. Defaults to the
working directory.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_scale">scale</code></td>
<td>
<p>Multiplicative scaling factor.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_width">width</code>, <code id="ggsave_+3A_height">height</code></td>
<td>
<p>Plot size in units expressed by the <code>units</code> argument.
If not supplied, uses the size of the current graphics device.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_units">units</code></td>
<td>
<p>One of the following units in which the <code>width</code> and <code>height</code>
arguments are expressed: <code>"in"</code>, <code>"cm"</code>, <code>"mm"</code> or <code>"px"</code>.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_dpi">dpi</code></td>
<td>
<p>Plot resolution. Also accepts a string input: &quot;retina&quot; (320),
&quot;print&quot; (300), or &quot;screen&quot; (72). Applies only to raster output types.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_limitsize">limitsize</code></td>
<td>
<p>When <code>TRUE</code> (the default), <code>ggsave()</code> will not
save images larger than 50x50 inches, to prevent the common error of
specifying dimensions in pixels.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_bg">bg</code></td>
<td>
<p>Background colour. If <code>NULL</code>, uses the <code>plot.background</code> fill value
from the plot theme.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_create.dir">create.dir</code></td>
<td>
<p>Whether to create new directories if a non-existing
directory is specified in the <code>filename</code> or <code>path</code> (<code>TRUE</code>) or return an
error (<code>FALSE</code>, default). If <code>FALSE</code> and run in an interactive session,
a prompt will appear asking to create a new directory when necessary.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to the graphics device function,
as specified by <code>device</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Filenames with page numbers can be generated by including a C
integer format expression, such as <code style="white-space: pre;">&#8288;%03d&#8288;</code> (as in the default file name
for most R graphics devices, see e.g. <code><a href="grDevices.html#topic+png">png()</a></code>).
Thus, <code>filename = "figure%03d.png"</code> will produce successive filenames
<code>figure001.png</code>, <code>figure002.png</code>, <code>figure003.png</code>, etc. To write a filename
containing the <code style="white-space: pre;">&#8288;%&#8288;</code> sign, use <code>%%</code>. For example, <code>filename = "figure-100%%.png"</code>
will produce the filename <code style="white-space: pre;">&#8288;figure-100%.png&#8288;</code>.
</p>


<h3>Saving images without ggsave()</h3>

<p>In most cases <code>ggsave()</code> is the simplest way to save your plot, but
sometimes you may wish to save the plot by writing directly to a
graphics device. To do this, you can open a regular R graphics
device such as <code>png()</code> or <code>pdf()</code>, print the plot, and then close
the device using <code>dev.off()</code>. This technique is illustrated in the
examples section.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ggplot(mtcars, aes(mpg, wt)) +
  geom_point()

# here, the device is inferred from the filename extension
ggsave("mtcars.pdf")
ggsave("mtcars.png")

# setting dimensions of the plot
ggsave("mtcars.pdf", width = 4, height = 4)
ggsave("mtcars.pdf", width = 20, height = 20, units = "cm")

# passing device-specific arguments to '...'
ggsave("mtcars.pdf", colormodel = "cmyk")

# delete files with base::unlink()
unlink("mtcars.pdf")
unlink("mtcars.png")

# specify device when saving to a file with unknown extension
# (for example a server supplied temporary file)
file &lt;- tempfile()
ggsave(file, device = "pdf")
unlink(file)

# save plot to file without using ggsave
p &lt;-
  ggplot(mtcars, aes(mpg, wt)) +
  geom_point()
png("mtcars.png")
print(p)
dev.off()


## End(Not run)
</code></pre>

<hr>
<h2 id='ggtheme'>Complete themes</h2><span id='topic+theme_grey'></span><span id='topic+theme_gray'></span><span id='topic+theme_bw'></span><span id='topic+theme_linedraw'></span><span id='topic+theme_light'></span><span id='topic+theme_dark'></span><span id='topic+theme_minimal'></span><span id='topic+theme_classic'></span><span id='topic+theme_void'></span><span id='topic+theme_test'></span>

<h3>Description</h3>

<p>These are complete themes which control all non-data display. Use
<code><a href="#topic+theme">theme()</a></code> if you just need to tweak the display of an existing
theme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_grey(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_gray(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_bw(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_linedraw(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_light(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_dark(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_minimal(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_classic(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_void(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_test(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggtheme_+3A_base_size">base_size</code></td>
<td>
<p>base font size, given in pts.</p>
</td></tr>
<tr><td><code id="ggtheme_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
<tr><td><code id="ggtheme_+3A_base_line_size">base_line_size</code></td>
<td>
<p>base size for line elements</p>
</td></tr>
<tr><td><code id="ggtheme_+3A_base_rect_size">base_rect_size</code></td>
<td>
<p>base size for rect elements</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>theme_gray()</code></dt><dd>
<p>The signature ggplot2 theme with a grey background and white gridlines,
designed to put the data forward yet make comparisons easy.</p>
</dd>
<dt><code>theme_bw()</code></dt><dd>
<p>The classic dark-on-light ggplot2 theme. May work better for presentations
displayed with a projector.</p>
</dd>
<dt><code>theme_linedraw()</code></dt><dd>
<p>A theme with only black lines of various widths on white backgrounds,
reminiscent of a line drawing. Serves a purpose similar to <code>theme_bw()</code>.
Note that this theme has some very thin lines (&lt;&lt; 1 pt) which some journals
may refuse.</p>
</dd>
<dt><code>theme_light()</code></dt><dd>
<p>A theme similar to <code>theme_linedraw()</code> but with light grey lines and axes,
to direct more attention towards the data.</p>
</dd>
<dt><code>theme_dark()</code></dt><dd>
<p>The dark cousin of <code>theme_light()</code>, with similar line sizes but a dark background. Useful to make thin coloured lines pop out.</p>
</dd>
<dt><code>theme_minimal()</code></dt><dd>
<p>A minimalistic theme with no background annotations.</p>
</dd>
<dt><code>theme_classic()</code></dt><dd>
<p>A classic-looking theme, with x and y axis lines and no gridlines.</p>
</dd>
<dt><code>theme_void()</code></dt><dd>
<p>A completely empty theme.</p>
</dd>
<dt><code>theme_test()</code></dt><dd>
<p>A theme for visual unit tests. It should ideally never change except
for new features.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>mtcars2 &lt;- within(mtcars, {
  vs &lt;- factor(vs, labels = c("V-shaped", "Straight"))
  am &lt;- factor(am, labels = c("Automatic", "Manual"))
  cyl  &lt;- factor(cyl)
  gear &lt;- factor(gear)
})

p1 &lt;- ggplot(mtcars2) +
  geom_point(aes(x = wt, y = mpg, colour = gear)) +
  labs(
    title = "Fuel economy declines as weight increases",
    subtitle = "(1973-74)",
    caption = "Data from the 1974 Motor Trend US magazine.",
    tag = "Figure 1",
    x = "Weight (1000 lbs)",
    y = "Fuel economy (mpg)",
    colour = "Gears"
  )

p1 + theme_gray() # the default
p1 + theme_bw()
p1 + theme_linedraw()
p1 + theme_light()
p1 + theme_dark()
p1 + theme_minimal()
p1 + theme_classic()
p1 + theme_void()

# Theme examples with panels

p2 &lt;- p1 + facet_grid(vs ~ am)

p2 + theme_gray() # the default
p2 + theme_bw()
p2 + theme_linedraw()
p2 + theme_light()
p2 + theme_dark()
p2 + theme_minimal()
p2 + theme_classic()
p2 + theme_void()

</code></pre>

<hr>
<h2 id='graphical-units'>Graphical units</h2><span id='topic+.pt'></span><span id='topic+.stroke'></span>

<h3>Description</h3>

<p>Multiply size in mm by these constants in order to convert to the units
that grid uses internally for <code>lwd</code> and <code>fontsize</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pt

.stroke
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 1.
</p>
<p>An object of class <code>numeric</code> of length 1.
</p>

<hr>
<h2 id='guide_axis'>Axis guide</h2><span id='topic+guide_axis'></span>

<h3>Description</h3>

<p>Axis guides are the visual representation of position scales like those
created with <a href="#topic+scale_x_continuous">scale_(x|y)_continuous()</a> and
<a href="#topic+scale_x_discrete">scale_(x|y)_discrete()</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_axis(
  title = waiver(),
  theme = NULL,
  check.overlap = FALSE,
  angle = waiver(),
  n.dodge = 1,
  minor.ticks = FALSE,
  cap = "none",
  order = 0,
  position = waiver()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_axis_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_axis_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
<tr><td><code id="guide_axis_+3A_check.overlap">check.overlap</code></td>
<td>
<p>silently remove overlapping labels,
(recursively) prioritizing the first, last, and middle labels.</p>
</td></tr>
<tr><td><code id="guide_axis_+3A_angle">angle</code></td>
<td>
<p>Compared to setting the angle in <code><a href="#topic+theme">theme()</a></code> / <code><a href="#topic+element_text">element_text()</a></code>,
this also uses some heuristics to automatically pick the <code>hjust</code> and <code>vjust</code> that
you probably want. Can be one of the following:
</p>

<ul>
<li> <p><code>NULL</code> to take the angles and <code>hjust</code>/<code>vjust</code> directly from the theme.
</p>
</li>
<li> <p><code>waiver()</code> to allow reasonable defaults in special cases.
</p>
</li>
<li><p> A number representing the text angle in degrees.
</p>
</li></ul>
</td></tr>
<tr><td><code id="guide_axis_+3A_n.dodge">n.dodge</code></td>
<td>
<p>The number of rows (for vertical axes) or columns (for
horizontal axes) that should be used to render the labels. This is
useful for displaying labels that would otherwise overlap.</p>
</td></tr>
<tr><td><code id="guide_axis_+3A_minor.ticks">minor.ticks</code></td>
<td>
<p>Whether to draw the minor ticks (<code>TRUE</code>) or not draw
minor ticks (<code>FALSE</code>, default).</p>
</td></tr>
<tr><td><code id="guide_axis_+3A_cap">cap</code></td>
<td>
<p>A <code>character</code> to cut the axis line back to the last breaks. Can
be <code>"none"</code> (default) to draw the axis line along the whole panel, or
<code>"upper"</code> and <code>"lower"</code> to draw the axis to the upper or lower break, or
<code>"both"</code> to only draw the line in between the most extreme breaks. <code>TRUE</code>
and <code>FALSE</code> are shorthand for <code>"both"</code> and <code>"none"</code> respectively.</p>
</td></tr>
<tr><td><code id="guide_axis_+3A_order">order</code></td>
<td>
<p>A positive <code>integer</code> of length 1 that specifies the order of
this guide among multiple guides. This controls in which order guides are
merged if there are multiple guides for the same position. If 0 (default),
the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_axis_+3A_position">position</code></td>
<td>
<p>Where this guide should be drawn: one of top, bottom,
left, or right.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># plot with overlapping text
p &lt;- ggplot(mpg, aes(cty * 100, hwy * 100)) +
  geom_point() +
  facet_wrap(vars(class))

# axis guides can be customized in the scale_* functions or
# using guides()
p + scale_x_continuous(guide = guide_axis(n.dodge = 2))
p + guides(x = guide_axis(angle = 90))

# can also be used to add a duplicate guide
p + guides(x = guide_axis(n.dodge = 2), y.sec = guide_axis())
</code></pre>

<hr>
<h2 id='guide_axis_logticks'>Axis with logarithmic tick marks</h2><span id='topic+guide_axis_logticks'></span>

<h3>Description</h3>

<p>This axis guide replaces the placement of ticks marks at intervals in
log10 space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_axis_logticks(
  long = 2.25,
  mid = 1.5,
  short = 0.75,
  prescale_base = NULL,
  negative_small = 0.1,
  short_theme = element_line(),
  expanded = TRUE,
  cap = "none",
  theme = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_axis_logticks_+3A_long">long</code>, <code id="guide_axis_logticks_+3A_mid">mid</code>, <code id="guide_axis_logticks_+3A_short">short</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> object or <code><a href="#topic+rel">rel()</a></code> object setting
the (relative) length of the long, middle and short ticks. Numeric values
are interpreted as <code><a href="#topic+rel">rel()</a></code> objects. The <code><a href="#topic+rel">rel()</a></code> values are used to multiply
values of the <code>axis.ticks.length</code> theme setting.</p>
</td></tr>
<tr><td><code id="guide_axis_logticks_+3A_prescale_base">prescale_base</code></td>
<td>
<p>Base of logarithm used to transform data manually. The
default, <code>NULL</code>, will use the scale transformation to calculate positions.
Only set <code>prescale_base</code> if the data has already been log-transformed.
When using a log-transform in the position scale or in <code>coord_trans()</code>,
keep the default <code>NULL</code> argument.</p>
</td></tr>
<tr><td><code id="guide_axis_logticks_+3A_negative_small">negative_small</code></td>
<td>
<p>When the scale limits include 0 or negative numbers,
what should be the smallest absolute value that is marked with a tick?</p>
</td></tr>
<tr><td><code id="guide_axis_logticks_+3A_short_theme">short_theme</code></td>
<td>
<p>A theme <a href="#topic+element_line">element</a> for customising the
display of the shortest ticks. Must be a line or blank element, and
it inherits from the <code>axis.minor.ticks</code> setting for the relevant position.</p>
</td></tr>
<tr><td><code id="guide_axis_logticks_+3A_expanded">expanded</code></td>
<td>
<p>Whether the ticks should cover the range after scale
expansion (<code>TRUE</code>, default), or be restricted to the scale limits
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="guide_axis_logticks_+3A_cap">cap</code></td>
<td>
<p>A <code>character</code> to cut the axis line back to the last breaks. Can
be <code>"none"</code> (default) to draw the axis line along the whole panel, or
<code>"upper"</code> and <code>"lower"</code> to draw the axis to the upper or lower break, or
<code>"both"</code> to only draw the line in between the most extreme breaks. <code>TRUE</code>
and <code>FALSE</code> are shorthand for <code>"both"</code> and <code>"none"</code> respectively.</p>
</td></tr>
<tr><td><code id="guide_axis_logticks_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
<tr><td><code id="guide_axis_logticks_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+guide_axis">guide_axis</a></code>
</p>

<dl>
<dt><code>check.overlap</code></dt><dd><p>silently remove overlapping labels,
(recursively) prioritizing the first, last, and middle labels.</p>
</dd>
<dt><code>angle</code></dt><dd><p>Compared to setting the angle in <code><a href="#topic+theme">theme()</a></code> / <code><a href="#topic+element_text">element_text()</a></code>,
this also uses some heuristics to automatically pick the <code>hjust</code> and <code>vjust</code> that
you probably want. Can be one of the following:
</p>

<ul>
<li> <p><code>NULL</code> to take the angles and <code>hjust</code>/<code>vjust</code> directly from the theme.
</p>
</li>
<li> <p><code>waiver()</code> to allow reasonable defaults in special cases.
</p>
</li>
<li><p> A number representing the text angle in degrees.
</p>
</li></ul>
</dd>
<dt><code>n.dodge</code></dt><dd><p>The number of rows (for vertical axes) or columns (for
horizontal axes) that should be used to render the labels. This is
useful for displaying labels that would otherwise overlap.</p>
</dd>
<dt><code>order</code></dt><dd><p>A positive <code>integer</code> of length 1 that specifies the order of
this guide among multiple guides. This controls in which order guides are
merged if there are multiple guides for the same position. If 0 (default),
the order is determined by a secret algorithm.</p>
</dd>
<dt><code>position</code></dt><dd><p>Where this guide should be drawn: one of top, bottom,
left, or right.</p>
</dd>
<dt><code>title</code></dt><dd><p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs()</a></code> is used for the title.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A standard plot
p &lt;- ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point(na.rm = TRUE)

# The logticks axis works well with log scales
p + scale_x_log10(guide = "axis_logticks") +
  scale_y_log10(guide = "axis_logticks")

# Or with log-transformed coordinates
p + coord_trans(x = "log10", y = "log10") +
  guides(x = "axis_logticks", y = "axis_logticks")

# When data is transformed manually, one should provide `prescale_base`
# Keep in mind that this axis uses log10 space for placement, not log2
p + aes(x = log2(bodywt), y = log10(brainwt)) +
  guides(
    x = guide_axis_logticks(prescale_base = 2),
    y = guide_axis_logticks(prescale_base = 10)
  )

# A plot with both positive and negative extremes, pseudo-log transformed
set.seed(42)
p2 &lt;- ggplot(data.frame(x = rcauchy(1000)), aes(x = x)) +
  geom_density() +
  scale_x_continuous(
    breaks = c(-10^(4:0), 0, 10^(0:4)),
    transform = "pseudo_log"
  )

# The log ticks are mirrored when 0 is included
p2 + guides(x = "axis_logticks")

# To control the tick density around 0, one can set `negative_small`
p2 + guides(x = guide_axis_logticks(negative_small = 1))
</code></pre>

<hr>
<h2 id='guide_axis_stack'>Stacked axis guides</h2><span id='topic+guide_axis_stack'></span>

<h3>Description</h3>

<p>This guide can stack other position guides that represent position scales,
like those created with <a href="#topic+scale_x_continuous">scale_(x|y)_continuous()</a> and
<a href="#topic+scale_x_discrete">scale_(x|y)_discrete()</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_axis_stack(
  first = "axis",
  ...,
  title = waiver(),
  theme = NULL,
  spacing = NULL,
  order = 0,
  position = waiver()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_axis_stack_+3A_first">first</code></td>
<td>
<p>A position guide given as one of the following:
</p>

<ul>
<li><p> A string, for example <code>"axis"</code>.
</p>
</li>
<li><p> A call to a guide function, for example <code>guide_axis()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="guide_axis_stack_+3A_...">...</code></td>
<td>
<p>Additional guides to stack given in the same manner as <code>first</code>.</p>
</td></tr>
<tr><td><code id="guide_axis_stack_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_axis_stack_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
<tr><td><code id="guide_axis_stack_+3A_spacing">spacing</code></td>
<td>
<p>A <code><a href="#topic+unit">unit()</a></code> objects that determines how far separate guides are
spaced apart.</p>
</td></tr>
<tr><td><code id="guide_axis_stack_+3A_order">order</code></td>
<td>
<p>A positive <code>integer</code> of length 1 that specifies the order of
this guide among multiple guides. This controls in which order guides are
merged if there are multiple guides for the same position. If 0 (default),
the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_axis_stack_+3A_position">position</code></td>
<td>
<p>Where this guide should be drawn: one of top, bottom,
left, or right.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>first</code> guide will be placed closest to the panel and any subsequent
guides provided through <code>...</code> will follow in the given order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # A standard plot
p &lt;- ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  theme(axis.line = element_line())

# A normal axis first, then a capped axis
p + guides(x = guide_axis_stack("axis", guide_axis(cap = "both")))
</code></pre>

<hr>
<h2 id='guide_axis_theta'>Angle axis guide</h2><span id='topic+guide_axis_theta'></span>

<h3>Description</h3>

<p>This is a specialised guide used in <code>coord_radial()</code> to represent the theta
position scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_axis_theta(
  title = waiver(),
  theme = NULL,
  angle = waiver(),
  minor.ticks = FALSE,
  cap = "none",
  order = 0,
  position = waiver()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_axis_theta_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_axis_theta_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
<tr><td><code id="guide_axis_theta_+3A_angle">angle</code></td>
<td>
<p>Compared to setting the angle in <code><a href="#topic+theme">theme()</a></code> / <code><a href="#topic+element_text">element_text()</a></code>,
this also uses some heuristics to automatically pick the <code>hjust</code> and <code>vjust</code> that
you probably want. Can be one of the following:
</p>

<ul>
<li> <p><code>NULL</code> to take the angles and <code>hjust</code>/<code>vjust</code> directly from the theme.
</p>
</li>
<li> <p><code>waiver()</code> to allow reasonable defaults in special cases.
</p>
</li>
<li><p> A number representing the text angle in degrees.
</p>
</li></ul>
</td></tr>
<tr><td><code id="guide_axis_theta_+3A_minor.ticks">minor.ticks</code></td>
<td>
<p>Whether to draw the minor ticks (<code>TRUE</code>) or not draw
minor ticks (<code>FALSE</code>, default).</p>
</td></tr>
<tr><td><code id="guide_axis_theta_+3A_cap">cap</code></td>
<td>
<p>A <code>character</code> to cut the axis line back to the last breaks. Can
be <code>"none"</code> (default) to draw the axis line along the whole panel, or
<code>"upper"</code> and <code>"lower"</code> to draw the axis to the upper or lower break, or
<code>"both"</code> to only draw the line in between the most extreme breaks. <code>TRUE</code>
and <code>FALSE</code> are shorthand for <code>"both"</code> and <code>"none"</code> respectively.</p>
</td></tr>
<tr><td><code id="guide_axis_theta_+3A_order">order</code></td>
<td>
<p>A positive <code>integer</code> of length 1 that specifies the order of
this guide among multiple guides. This controls in which order guides are
merged if there are multiple guides for the same position. If 0 (default),
the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_axis_theta_+3A_position">position</code></td>
<td>
<p>Where this guide should be drawn: one of top, bottom,
left, or right.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The axis labels in this guide are insensitive to <code>hjust</code> and <code>vjust</code>
settings. The distance from the tick marks to the labels is determined by
the largest <code>margin</code> size set in the theme.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A plot using coord_radial
p &lt;- ggplot(mtcars, aes(disp, mpg)) +
  geom_point() +
  coord_radial()

# The `angle` argument can be used to set relative angles
p + guides(theta = guide_axis_theta(angle = 0))
</code></pre>

<hr>
<h2 id='guide_bins'>A binned version of guide_legend</h2><span id='topic+guide_bins'></span>

<h3>Description</h3>

<p>This guide is a version of the <code><a href="#topic+guide_legend">guide_legend()</a></code> guide for binned scales. It
differs in that it places ticks correctly between the keys, and sports a
small axis to better show the binning. Like <code><a href="#topic+guide_legend">guide_legend()</a></code> it can be used
for all non-position aesthetics though colour and fill defaults to
<code><a href="#topic+guide_coloursteps">guide_coloursteps()</a></code>, and it will merge aesthetics together into the same
guide if they are mapped in the same way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_bins(
  title = waiver(),
  theme = NULL,
  position = NULL,
  direction = NULL,
  override.aes = list(),
  reverse = FALSE,
  order = 0,
  show.limits = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_bins_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_bins_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
<tr><td><code id="guide_bins_+3A_position">position</code></td>
<td>
<p>A character string indicating where the legend should be
placed relative to the plot panels.</p>
</td></tr>
<tr><td><code id="guide_bins_+3A_direction">direction</code></td>
<td>
<p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</td></tr>
<tr><td><code id="guide_bins_+3A_override.aes">override.aes</code></td>
<td>
<p>A list specifying aesthetic parameters of legend key.
See details and examples.</p>
</td></tr>
<tr><td><code id="guide_bins_+3A_reverse">reverse</code></td>
<td>
<p>logical. If <code>TRUE</code> the order of legends is reversed.</p>
</td></tr>
<tr><td><code id="guide_bins_+3A_order">order</code></td>
<td>
<p>positive integer less than 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_bins_+3A_show.limits">show.limits</code></td>
<td>
<p>Logical. Should the limits of the scale be shown with
labels and ticks. Default is <code>NULL</code> meaning it will take the value from the
scale. This argument is ignored if <code>labels</code> is given as a vector of
values. If one or both of the limits is also given in <code>breaks</code> it will be
shown irrespective of the value of <code>show.limits</code>.</p>
</td></tr>
<tr><td><code id="guide_bins_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A guide object
</p>


<h3>Use with discrete scale</h3>

<p>This guide is intended to show binned data and work together with ggplot2's
binning scales. However, it is sometimes desirable to perform the binning in
a separate step, either as part of a stat (e.g. <code><a href="#topic+stat_contour_filled">stat_contour_filled()</a></code>) or
prior to the visualisation. If you want to use this guide for discrete data
the levels must follow the naming scheme implemented by <code><a href="base.html#topic+cut">base::cut()</a></code>. This
means that a bin must be encoded as <code>"(&lt;lower&gt;, &lt;upper&gt;]"</code> with <code style="white-space: pre;">&#8288;&lt;lower&gt;&#8288;</code>
giving the lower bound of the bin and <code style="white-space: pre;">&#8288;&lt;upper&gt;&#8288;</code> giving the upper bound
(<code>"[&lt;lower&gt;, &lt;upper&gt;)"</code> is also accepted). If you use <code><a href="base.html#topic+cut">base::cut()</a></code> to
perform the binning everything should work as expected, if not, some recoding
may be needed.
</p>


<h3>See Also</h3>

<p>Other guides: 
<code><a href="#topic+guide_colourbar">guide_colourbar</a>()</code>,
<code><a href="#topic+guide_coloursteps">guide_coloursteps</a>()</code>,
<code><a href="#topic+guide_legend">guide_legend</a>()</code>,
<code><a href="#topic+guides">guides</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars) +
  geom_point(aes(disp, mpg, size = hp)) +
  scale_size_binned()

# Standard look
p

# Remove the axis or style it
p + guides(size = guide_bins(
  theme = theme(legend.axis.line = element_blank())
))

p + guides(size = guide_bins(show.limits = TRUE))

my_arrow &lt;- arrow(length = unit(1.5, "mm"), ends = "both")
p + guides(size = guide_bins(
  theme = theme(legend.axis.line = element_line(arrow = my_arrow))
))

# Guides are merged together if possible
ggplot(mtcars) +
  geom_point(aes(disp, mpg, size = hp, colour = hp)) +
  scale_size_binned() +
  scale_colour_binned(guide = "bins")

</code></pre>

<hr>
<h2 id='guide_colourbar'>Continuous colour bar guide</h2><span id='topic+guide_colourbar'></span><span id='topic+guide_colorbar'></span>

<h3>Description</h3>

<p>Colour bar guide shows continuous colour scales mapped onto values.
Colour bar is available with <code>scale_fill</code> and <code>scale_colour</code>.
For more information, see the inspiration for this function:
<a href="http://www.mathworks.com/help/techdoc/ref/colorbar.html">Matlab's colorbar function</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_colourbar(
  title = waiver(),
  theme = NULL,
  nbin = NULL,
  display = "raster",
  raster = deprecated(),
  alpha = NA,
  draw.ulim = TRUE,
  draw.llim = TRUE,
  position = NULL,
  direction = NULL,
  reverse = FALSE,
  order = 0,
  available_aes = c("colour", "color", "fill"),
  ...
)

guide_colorbar(
  title = waiver(),
  theme = NULL,
  nbin = NULL,
  display = "raster",
  raster = deprecated(),
  alpha = NA,
  draw.ulim = TRUE,
  draw.llim = TRUE,
  position = NULL,
  direction = NULL,
  reverse = FALSE,
  order = 0,
  available_aes = c("colour", "color", "fill"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_colourbar_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_nbin">nbin</code></td>
<td>
<p>A numeric specifying the number of bins for drawing the
colourbar. A smoother colourbar results from a larger value.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_display">display</code></td>
<td>
<p>A string indicating a method to display the colourbar. Can be
one of the following:
</p>

<ul>
<li> <p><code>"raster"</code> to display as a bitmap image.
</p>
</li>
<li> <p><code>"rectangles"</code> to display as a series of rectangles.
</p>
</li>
<li> <p><code>"gradient"</code> to display as a linear gradient.
</p>
</li></ul>

<p>Note that not all devices are able to render rasters and gradients.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_raster">raster</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>  A logical. If <code>TRUE</code> then
the colourbar is rendered as a raster object. If <code>FALSE</code> then the colourbar
is rendered as a set of rectangles. Note that not all graphics devices are
capable of rendering raster image.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_alpha">alpha</code></td>
<td>
<p>A numeric between 0 and 1 setting the colour transparency of
the bar. Use <code>NA</code> to preserve the alpha encoded in the colour itself
(default).</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_draw.ulim">draw.ulim</code></td>
<td>
<p>A logical specifying if the upper limit tick marks should
be visible.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_draw.llim">draw.llim</code></td>
<td>
<p>A logical specifying if the lower limit tick marks should
be visible.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_position">position</code></td>
<td>
<p>A character string indicating where the legend should be
placed relative to the plot panels.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_direction">direction</code></td>
<td>
<p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_reverse">reverse</code></td>
<td>
<p>logical. If <code>TRUE</code> the colourbar is reversed. By default,
the highest value is on the top and the lowest value is on the bottom</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_order">order</code></td>
<td>
<p>positive integer less than 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_available_aes">available_aes</code></td>
<td>
<p>A vector of character strings listing the aesthetics
for which a colourbar can be drawn.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Guides can be specified in each <code style="white-space: pre;">&#8288;scale_*&#8288;</code> or in <code><a href="#topic+guides">guides()</a></code>.
<code>guide="legend"</code> in <code style="white-space: pre;">&#8288;scale_*&#8288;</code> is syntactic sugar for
<code>guide=guide_legend()</code> (e.g. <code>scale_colour_manual(guide = "legend")</code>).
As for how to specify the guide for each scale in more detail,
see <code><a href="#topic+guides">guides()</a></code>.
</p>


<h3>Value</h3>

<p>A guide object
</p>


<h3>See Also</h3>

<p>Other guides: 
<code><a href="#topic+guide_bins">guide_bins</a>()</code>,
<code><a href="#topic+guide_coloursteps">guide_coloursteps</a>()</code>,
<code><a href="#topic+guide_legend">guide_legend</a>()</code>,
<code><a href="#topic+guides">guides</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- expand.grid(X1 = 1:10, X2 = 1:10)
df$value &lt;- df$X1 * df$X2

p1 &lt;- ggplot(df, aes(X1, X2)) + geom_tile(aes(fill = value))
p2 &lt;- p1 + geom_point(aes(size = value))

# Basic form
p1 + scale_fill_continuous(guide = "colourbar")
p1 + scale_fill_continuous(guide = guide_colourbar())
p1 + guides(fill = guide_colourbar())

# Control styles

# bar size
p1 + guides(fill = guide_colourbar(theme = theme(
  legend.key.width  = unit(0.5, "lines"),
  legend.key.height = unit(10, "lines")
)))


# no label
p1 + guides(fill = guide_colourbar(theme = theme(
  legend.text = element_blank()
)))

# no tick marks
p1 + guides(fill = guide_colourbar(theme = theme(
  legend.ticks = element_blank()
)))

# label position
p1 + guides(fill = guide_colourbar(theme = theme(
  legend.text.position = "left"
)))

# label theme
p1 + guides(fill = guide_colourbar(theme = theme(
  legend.text = element_text(colour = "blue", angle = 0)
)))

# small number of bins
p1 + guides(fill = guide_colourbar(nbin = 3))

# large number of bins
p1 + guides(fill = guide_colourbar(nbin = 100))

# make top- and bottom-most ticks invisible
p1 +
  scale_fill_continuous(
    limits = c(0,20), breaks = c(0, 5, 10, 15, 20),
    guide = guide_colourbar(nbin = 100, draw.ulim = FALSE, draw.llim = FALSE)
  )

# guides can be controlled independently
p2 +
  scale_fill_continuous(guide = "colourbar") +
  scale_size(guide = "legend")
p2 + guides(fill = "colourbar", size = "legend")

p2 +
  scale_fill_continuous(guide = guide_colourbar(theme = theme(
    legend.direction = "horizontal"
  ))) +
  scale_size(guide = guide_legend(theme = theme(
    legend.direction = "vertical"
  )))
</code></pre>

<hr>
<h2 id='guide_coloursteps'>Discretized colourbar guide</h2><span id='topic+guide_coloursteps'></span><span id='topic+guide_colorsteps'></span>

<h3>Description</h3>

<p>This guide is version of <code><a href="#topic+guide_colourbar">guide_colourbar()</a></code> for binned colour and fill
scales. It shows areas between breaks as a single constant colour instead of
the gradient known from the colourbar counterpart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_coloursteps(
  title = waiver(),
  theme = NULL,
  alpha = NA,
  even.steps = TRUE,
  show.limits = NULL,
  direction = NULL,
  reverse = FALSE,
  order = 0,
  available_aes = c("colour", "color", "fill"),
  ...
)

guide_colorsteps(
  title = waiver(),
  theme = NULL,
  alpha = NA,
  even.steps = TRUE,
  show.limits = NULL,
  direction = NULL,
  reverse = FALSE,
  order = 0,
  available_aes = c("colour", "color", "fill"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_coloursteps_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_coloursteps_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
<tr><td><code id="guide_coloursteps_+3A_alpha">alpha</code></td>
<td>
<p>A numeric between 0 and 1 setting the colour transparency of
the bar. Use <code>NA</code> to preserve the alpha encoded in the colour itself
(default).</p>
</td></tr>
<tr><td><code id="guide_coloursteps_+3A_even.steps">even.steps</code></td>
<td>
<p>Should the rendered size of the bins be equal, or should
they be proportional to their length in the data space? Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="guide_coloursteps_+3A_show.limits">show.limits</code></td>
<td>
<p>Logical. Should the limits of the scale be shown with
labels and ticks. Default is <code>NULL</code> meaning it will take the value from the
scale. This argument is ignored if <code>labels</code> is given as a vector of
values. If one or both of the limits is also given in <code>breaks</code> it will be
shown irrespective of the value of <code>show.limits</code>.</p>
</td></tr>
<tr><td><code id="guide_coloursteps_+3A_direction">direction</code></td>
<td>
<p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</td></tr>
<tr><td><code id="guide_coloursteps_+3A_reverse">reverse</code></td>
<td>
<p>logical. If <code>TRUE</code> the colourbar is reversed. By default,
the highest value is on the top and the lowest value is on the bottom</p>
</td></tr>
<tr><td><code id="guide_coloursteps_+3A_order">order</code></td>
<td>
<p>positive integer less than 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_coloursteps_+3A_available_aes">available_aes</code></td>
<td>
<p>A vector of character strings listing the aesthetics
for which a colourbar can be drawn.</p>
</td></tr>
<tr><td><code id="guide_coloursteps_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A guide object
</p>


<h3>Use with discrete scale</h3>

<p>This guide is intended to show binned data and work together with ggplot2's
binning scales. However, it is sometimes desirable to perform the binning in
a separate step, either as part of a stat (e.g. <code><a href="#topic+stat_contour_filled">stat_contour_filled()</a></code>) or
prior to the visualisation. If you want to use this guide for discrete data
the levels must follow the naming scheme implemented by <code><a href="base.html#topic+cut">base::cut()</a></code>. This
means that a bin must be encoded as <code>"(&lt;lower&gt;, &lt;upper&gt;]"</code> with <code style="white-space: pre;">&#8288;&lt;lower&gt;&#8288;</code>
giving the lower bound of the bin and <code style="white-space: pre;">&#8288;&lt;upper&gt;&#8288;</code> giving the upper bound
(<code>"[&lt;lower&gt;, &lt;upper&gt;)"</code> is also accepted). If you use <code><a href="base.html#topic+cut">base::cut()</a></code> to
perform the binning everything should work as expected, if not, some recoding
may be needed.
</p>


<h3>See Also</h3>

<p>Other guides: 
<code><a href="#topic+guide_bins">guide_bins</a>()</code>,
<code><a href="#topic+guide_colourbar">guide_colourbar</a>()</code>,
<code><a href="#topic+guide_legend">guide_legend</a>()</code>,
<code><a href="#topic+guides">guides</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- expand.grid(X1 = 1:10, X2 = 1:10)
df$value &lt;- df$X1 * df$X2

p &lt;- ggplot(df, aes(X1, X2)) + geom_tile(aes(fill = value))

# Coloursteps guide is the default for binned colour scales
p + scale_fill_binned()

# By default each bin in the guide is the same size irrespectively of how
# their sizes relate in data space
p + scale_fill_binned(breaks = c(10, 25, 50))

# This can be changed with the `even.steps` argument
p + scale_fill_binned(
  breaks = c(10, 25, 50),
  guide = guide_coloursteps(even.steps = FALSE)
)

# By default the limits is not shown, but this can be changed
p + scale_fill_binned(guide = guide_coloursteps(show.limits = TRUE))

# (can also be set in the scale)
p + scale_fill_binned(show.limits = TRUE)
</code></pre>

<hr>
<h2 id='guide_custom'>Custom guides</h2><span id='topic+guide_custom'></span>

<h3>Description</h3>

<p>This is a special guide that can be used to display any graphical object
(grob) along with the regular guides. This guide has no associated scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_custom(
  grob,
  width = grobWidth(grob),
  height = grobHeight(grob),
  title = NULL,
  theme = NULL,
  position = NULL,
  order = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_custom_+3A_grob">grob</code></td>
<td>
<p>A grob to display.</p>
</td></tr>
<tr><td><code id="guide_custom_+3A_width">width</code>, <code id="guide_custom_+3A_height">height</code></td>
<td>
<p>The allocated width and height to display the grob, given
in <code><a href="grid.html#topic+unit">grid::unit()</a></code>s.</p>
</td></tr>
<tr><td><code id="guide_custom_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating the title of guide.
If <code>NULL</code> (default), no title is shown.</p>
</td></tr>
<tr><td><code id="guide_custom_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
<tr><td><code id="guide_custom_+3A_position">position</code></td>
<td>
<p>A character string indicating where the legend should be
placed relative to the plot panels.</p>
</td></tr>
<tr><td><code id="guide_custom_+3A_order">order</code></td>
<td>
<p>positive integer less than 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A standard plot
p &lt;- ggplot(mpg, aes(displ, hwy)) +
  geom_point()

# Define a graphical object
circle &lt;- grid::circleGrob()

# Rendering a grob as a guide
p + guides(custom = guide_custom(circle, title = "My circle"))

# Controlling the size of the grob defined in relative units
p + guides(custom = guide_custom(
  circle, title = "My circle",
  width = unit(2, "cm"), height = unit(2, "cm"))
)

# Size of grobs in absolute units is taken directly without the need to
# set these manually
p + guides(custom = guide_custom(
  title = "My circle",
  grob = grid::circleGrob(r = unit(1, "cm"))
))
</code></pre>

<hr>
<h2 id='guide_legend'>Legend guide</h2><span id='topic+guide_legend'></span>

<h3>Description</h3>

<p>Legend type guide shows key (i.e., geoms) mapped onto values.
Legend guides for various scales are integrated if possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_legend(
  title = waiver(),
  theme = NULL,
  position = NULL,
  direction = NULL,
  override.aes = list(),
  nrow = NULL,
  ncol = NULL,
  reverse = FALSE,
  order = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_legend_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_position">position</code></td>
<td>
<p>A character string indicating where the legend should be
placed relative to the plot panels.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_direction">direction</code></td>
<td>
<p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_override.aes">override.aes</code></td>
<td>
<p>A list specifying aesthetic parameters of legend key.
See details and examples.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_nrow">nrow</code>, <code id="guide_legend_+3A_ncol">ncol</code></td>
<td>
<p>The desired number of rows and column of legends
respectively.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_reverse">reverse</code></td>
<td>
<p>logical. If <code>TRUE</code> the order of legends is reversed.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_order">order</code></td>
<td>
<p>positive integer less than 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Guides can be specified in each <code style="white-space: pre;">&#8288;scale_*&#8288;</code> or in <code><a href="#topic+guides">guides()</a></code>.
<code>guide = "legend"</code> in <code style="white-space: pre;">&#8288;scale_*&#8288;</code> is syntactic sugar for
<code>guide = guide_legend()</code> (e.g. <code>scale_color_manual(guide = "legend")</code>).
As for how to specify the guide for each scale in more detail,
see <code><a href="#topic+guides">guides()</a></code>.
</p>


<h3>See Also</h3>

<p>Other guides: 
<code><a href="#topic+guide_bins">guide_bins</a>()</code>,
<code><a href="#topic+guide_colourbar">guide_colourbar</a>()</code>,
<code><a href="#topic+guide_coloursteps">guide_coloursteps</a>()</code>,
<code><a href="#topic+guides">guides</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- expand.grid(X1 = 1:10, X2 = 1:10)
df$value &lt;- df$X1 * df$X2

p1 &lt;- ggplot(df, aes(X1, X2)) + geom_tile(aes(fill = value))
p2 &lt;- p1 + geom_point(aes(size = value))

# Basic form
p1 + scale_fill_continuous(guide = guide_legend())

# Control styles

# title position
p1 + guides(fill = guide_legend(
  title = "LEFT", theme(legend.title.position = "left")
))

# title text styles via element_text
p1 + guides(fill = guide_legend(theme = theme(
  legend.title = element_text(size = 15, face = "italic", colour = "red")
)))

# label position
p1 + guides(fill = guide_legend(theme = theme(
  legend.text.position = "left",
  legend.text = element_text(hjust = 1)
)))

# label styles
p1 +
  scale_fill_continuous(
    breaks = c(5, 10, 15),
    labels = paste("long", c(5, 10, 15)),
    guide = guide_legend(theme = theme(
      legend.direction = "horizontal",
      legend.title.position = "top",
      legend.text.position = "bottom",
      legend.text = element_text(hjust = 0.5, vjust = 1, angle = 90)
    ))
  )

# Set aesthetic of legend key
# very low alpha value make it difficult to see legend key
p3 &lt;- ggplot(mtcars, aes(vs, am, colour = factor(cyl))) +
  geom_jitter(alpha = 1/5, width = 0.01, height = 0.01)
p3
# override.aes overwrites the alpha
p3 + guides(colour = guide_legend(override.aes = list(alpha = 1)))

# multiple row/col legends
df &lt;- data.frame(x = 1:20, y = 1:20, color = letters[1:20])
p &lt;- ggplot(df, aes(x, y)) +
  geom_point(aes(colour = color))
p + guides(col = guide_legend(nrow = 8))
p + guides(col = guide_legend(ncol = 8))
p + guides(col = guide_legend(nrow = 8, theme = theme(legend.byrow = TRUE)))

# reversed order legend
p + guides(col = guide_legend(reverse = TRUE))

</code></pre>

<hr>
<h2 id='guide_none'>Empty guide</h2><span id='topic+guide_none'></span>

<h3>Description</h3>

<p>This guide draws nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_none(title = waiver(), position = waiver())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_none_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_none_+3A_position">position</code></td>
<td>
<p>Where this guide should be drawn: one of top, bottom,
left, or right.</p>
</td></tr>
</table>

<hr>
<h2 id='guides'>Set guides for each scale</h2><span id='topic+guides'></span>

<h3>Description</h3>

<p>Guides for each scale can be set scale-by-scale with the <code>guide</code>
argument, or en masse with <code>guides()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guides(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guides_+3A_...">...</code></td>
<td>
<p>List of scale name-guide pairs.  The guide can either
be a string (i.e. &quot;colorbar&quot; or &quot;legend&quot;), or a call to a guide function
(i.e. <code><a href="#topic+guide_colourbar">guide_colourbar()</a></code> or <code><a href="#topic+guide_legend">guide_legend()</a></code>)
specifying additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the mapping between scale and guide.
</p>


<h3>See Also</h3>

<p>Other guides: 
<code><a href="#topic+guide_bins">guide_bins</a>()</code>,
<code><a href="#topic+guide_colourbar">guide_colourbar</a>()</code>,
<code><a href="#topic+guide_coloursteps">guide_coloursteps</a>()</code>,
<code><a href="#topic+guide_legend">guide_legend</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ggplot object

dat &lt;- data.frame(x = 1:5, y = 1:5, p = 1:5, q = factor(1:5),
 r = factor(1:5))
p &lt;-
  ggplot(dat, aes(x, y, colour = p, size = q, shape = r)) +
  geom_point()

# without guide specification
p

# Show colorbar guide for colour.
# All these examples below have a same effect.

p + guides(colour = "colorbar", size = "legend", shape = "legend")
p + guides(colour = guide_colorbar(), size = guide_legend(),
  shape = guide_legend())
p +
 scale_colour_continuous(guide = "colorbar") +
 scale_size_discrete(guide = "legend") +
 scale_shape(guide = "legend")

 # Remove some guides
 p + guides(colour = "none")
 p + guides(colour = "colorbar",size = "none")

# Guides are integrated where possible

p +
  guides(
    colour = guide_legend("title"),
    size = guide_legend("title"),
    shape = guide_legend("title")
 )
# same as
g &lt;- guide_legend("title")
p + guides(colour = g, size = g, shape = g)

p + theme(legend.position = "bottom")

# position of guides

# Set order for multiple guides
ggplot(mpg, aes(displ, cty)) +
  geom_point(aes(size = hwy, colour = cyl, shape = drv)) +
  guides(
   colour = guide_colourbar(order = 1),
   shape = guide_legend(order = 2),
   size = guide_legend(order = 3)
 )

</code></pre>

<hr>
<h2 id='hmisc'>A selection of summary functions from Hmisc</h2><span id='topic+hmisc'></span><span id='topic+mean_cl_boot'></span><span id='topic+mean_cl_normal'></span><span id='topic+mean_sdl'></span><span id='topic+median_hilow'></span>

<h3>Description</h3>

<p>These are wrappers around functions from <span class="pkg">Hmisc</span> designed to make them
easier to use with <code><a href="#topic+stat_summary">stat_summary()</a></code>. See the Hmisc documentation
for more details:
</p>

<ul>
<li> <p><code><a href="Hmisc.html#topic+smean.sd">Hmisc::smean.cl.boot()</a></code>
</p>
</li>
<li> <p><code><a href="Hmisc.html#topic+smean.sd">Hmisc::smean.cl.normal()</a></code>
</p>
</li>
<li> <p><code><a href="Hmisc.html#topic+smean.sd">Hmisc::smean.sdl()</a></code>
</p>
</li>
<li> <p><code><a href="Hmisc.html#topic+smean.sd">Hmisc::smedian.hilow()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mean_cl_boot(x, ...)

mean_cl_normal(x, ...)

mean_sdl(x, ...)

median_hilow(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmisc_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="hmisc_+3A_...">...</code></td>
<td>
<p>other arguments passed on to the respective Hmisc function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>y</code>, <code>ymin</code>, and <code>ymax</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("Hmisc", quietly = TRUE)) {
set.seed(1)
x &lt;- rnorm(100)
mean_cl_boot(x)
mean_cl_normal(x)
mean_sdl(x)
median_hilow(x)
}
</code></pre>

<hr>
<h2 id='ignoring_data'>Ignoring and exposing data</h2><span id='topic+ignoring_data'></span><span id='topic+.ignore_data'></span><span id='topic+.expose_data'></span>

<h3>Description</h3>

<p>The <code>.ignore_data()</code> function is used to hide <code style="white-space: pre;">&#8288;&lt;AsIs&gt;&#8288;</code> columns during
scale interactions in <code>ggplot_build()</code>. The <code>.expose_data()</code> function is
used to restore hidden columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ignore_data(data)

.expose_data(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ignoring_data_+3A_data">data</code></td>
<td>
<p>A list of <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified list of <code style="white-space: pre;">&#8288;&lt;data.frame&gt;s&#8288;</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- list(
  data.frame(x = 1:3, y = I(1:3)),
  data.frame(w = I(1:3), z = 1:3)
)

ignored &lt;- .ignore_data(data)
str(ignored)

.expose_data(ignored)
</code></pre>

<hr>
<h2 id='is.Coord'>Is this object a coordinate system?</h2><span id='topic+is.Coord'></span>

<h3>Description</h3>

<p>Is this object a coordinate system?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Coord(x)
</code></pre>

<hr>
<h2 id='is.facet'>Is this object a faceting specification?</h2><span id='topic+is.facet'></span>

<h3>Description</h3>

<p>Is this object a faceting specification?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.facet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.facet_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
</table>

<hr>
<h2 id='is.ggplot'>Reports whether x is a ggplot object</h2><span id='topic+is.ggplot'></span>

<h3>Description</h3>

<p>Reports whether x is a ggplot object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ggplot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.ggplot_+3A_x">x</code></td>
<td>
<p>An object to test</p>
</td></tr>
</table>

<hr>
<h2 id='is.rel'>Reports whether x is a rel object</h2><span id='topic+is.rel'></span>

<h3>Description</h3>

<p>Reports whether x is a rel object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rel_+3A_x">x</code></td>
<td>
<p>An object to test</p>
</td></tr>
</table>

<hr>
<h2 id='is.theme'>Reports whether x is a theme object</h2><span id='topic+is.theme'></span>

<h3>Description</h3>

<p>Reports whether x is a theme object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.theme(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.theme_+3A_x">x</code></td>
<td>
<p>An object to test</p>
</td></tr>
</table>

<hr>
<h2 id='label_bquote'>Label with mathematical expressions</h2><span id='topic+label_bquote'></span>

<h3>Description</h3>

<p><code>label_bquote()</code> offers a flexible way of labelling
facet rows or columns with plotmath expressions. Backquoted
variables will be replaced with their value in the facet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_bquote(rows = NULL, cols = NULL, default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_bquote_+3A_rows">rows</code></td>
<td>
<p>Backquoted labelling expression for rows.</p>
</td></tr>
<tr><td><code id="label_bquote_+3A_cols">cols</code></td>
<td>
<p>Backquoted labelling expression for columns.</p>
</td></tr>
<tr><td><code id="label_bquote_+3A_default">default</code></td>
<td>
<p>Unused, kept for compatibility.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+labellers">labellers</a>, <code><a href="#topic+labeller">labeller()</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The variables mentioned in the plotmath expression must be
# backquoted and referred to by their names.
p &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()
p + facet_grid(vs ~ ., labeller = label_bquote(alpha ^ .(vs)))
p + facet_grid(. ~ vs, labeller = label_bquote(cols = .(vs) ^ .(vs)))
p + facet_grid(. ~ vs + am, labeller = label_bquote(cols = .(am) ^ .(vs)))
</code></pre>

<hr>
<h2 id='labeller'>Construct labelling specification</h2><span id='topic+labeller'></span>

<h3>Description</h3>

<p>This function makes it easy to assign different labellers to
different factors. The labeller can be a function or it can be a
named character vectors that will serve as a lookup table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labeller(
  ...,
  .rows = NULL,
  .cols = NULL,
  keep.as.numeric = deprecated(),
  .multi_line = TRUE,
  .default = label_value
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labeller_+3A_...">...</code></td>
<td>
<p>Named arguments of the form <code>variable =
  labeller</code>. Each labeller is passed to <code><a href="#topic+as_labeller">as_labeller()</a></code>
and can be a lookup table, a function taking and returning
character vectors, or simply a labeller function.</p>
</td></tr>
<tr><td><code id="labeller_+3A_.rows">.rows</code>, <code id="labeller_+3A_.cols">.cols</code></td>
<td>
<p>Labeller for a whole margin (either the rows or
the columns). It is passed to <code><a href="#topic+as_labeller">as_labeller()</a></code>. When a
margin-wide labeller is set, make sure you don't mention in
<code>...</code> any variable belonging to the margin.</p>
</td></tr>
<tr><td><code id="labeller_+3A_keep.as.numeric">keep.as.numeric</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> All supplied
labellers and on-labeller functions should be able to work with character
labels.</p>
</td></tr>
<tr><td><code id="labeller_+3A_.multi_line">.multi_line</code></td>
<td>
<p>Whether to display the labels of multiple
factors on separate lines. This is passed to the labeller
function.</p>
</td></tr>
<tr><td><code id="labeller_+3A_.default">.default</code></td>
<td>
<p>Default labeller for variables not specified. Also
used with lookup tables or non-labeller functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of functions, if the labeller has class <code>labeller</code>, it
is directly applied on the data frame of labels. Otherwise, it is
applied to the columns of the data frame of labels. The data frame
is then processed with the function specified in the
<code>.default</code> argument. This is intended to be used with
functions taking a character vector such as
<code><a href="Hmisc.html#topic+capitalize">Hmisc::capitalize()</a></code>.
</p>


<h3>Value</h3>

<p>A labeller function to supply to <code><a href="#topic+facet_grid">facet_grid()</a></code> or <code><a href="#topic+facet_wrap">facet_wrap()</a></code>
for the argument <code>labeller</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_labeller">as_labeller()</a></code>, <a href="#topic+labellers">labellers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p1 &lt;- ggplot(mtcars, aes(x = mpg, y = wt)) + geom_point()

# You can assign different labellers to variables:
p1 + facet_grid(
  vs + am ~ gear,
  labeller = labeller(vs = label_both, am = label_value)
)

# Or whole margins:
p1 + facet_grid(
  vs + am ~ gear,
  labeller = labeller(.rows = label_both, .cols = label_value)
)

# You can supply functions operating on strings:
capitalize &lt;- function(string) {
  substr(string, 1, 1) &lt;- toupper(substr(string, 1, 1))
  string
}
p2 &lt;- ggplot(msleep, aes(x = sleep_total, y = awake)) + geom_point()
p2 + facet_grid(vore ~ conservation, labeller = labeller(vore = capitalize))

# Or use character vectors as lookup tables:
conservation_status &lt;- c(
  cd = "Conservation Dependent",
  en = "Endangered",
  lc = "Least concern",
  nt = "Near Threatened",
  vu = "Vulnerable",
  domesticated = "Domesticated"
)
## Source: http://en.wikipedia.org/wiki/Wikipedia:Conservation_status

p2 + facet_grid(vore ~ conservation, labeller = labeller(
  .default = capitalize,
  conservation = conservation_status
))

# In the following example, we rename the levels to the long form,
# then apply a wrap labeller to the columns to prevent cropped text
idx &lt;- match(msleep$conservation, names(conservation_status))
msleep$conservation2 &lt;- conservation_status[idx]

p3 &lt;- ggplot(msleep, aes(x = sleep_total, y = awake)) + geom_point()
p3 +
  facet_grid(vore ~ conservation2,
    labeller = labeller(conservation2 = label_wrap_gen(10))
  )

# labeller() is especially useful to act as a global labeller. You
# can set it up once and use it on a range of different plots with
# different facet specifications.

global_labeller &lt;- labeller(
  vore = capitalize,
  conservation = conservation_status,
  conservation2 = label_wrap_gen(10),
  .default = label_both
)

p2 + facet_grid(vore ~ conservation, labeller = global_labeller)
p3 + facet_wrap(~conservation2, labeller = global_labeller)

</code></pre>

<hr>
<h2 id='labellers'>Useful labeller functions</h2><span id='topic+labellers'></span><span id='topic+label_value'></span><span id='topic+label_both'></span><span id='topic+label_context'></span><span id='topic+label_parsed'></span><span id='topic+label_wrap_gen'></span>

<h3>Description</h3>

<p>Labeller functions are in charge of formatting the strip labels of
facet grids and wraps. Most of them accept a <code>multi_line</code>
argument to control whether multiple factors (defined in formulae
such as <code>~first + second</code>) should be displayed on a single
line separated with commas, or each on their own line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_value(labels, multi_line = TRUE)

label_both(labels, multi_line = TRUE, sep = ": ")

label_context(labels, multi_line = TRUE, sep = ": ")

label_parsed(labels, multi_line = TRUE)

label_wrap_gen(width = 25, multi_line = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labellers_+3A_labels">labels</code></td>
<td>
<p>Data frame of labels. Usually contains only one
element, but faceting over multiple factors entails multiple
label variables.</p>
</td></tr>
<tr><td><code id="labellers_+3A_multi_line">multi_line</code></td>
<td>
<p>Whether to display the labels of multiple factors
on separate lines.</p>
</td></tr>
<tr><td><code id="labellers_+3A_sep">sep</code></td>
<td>
<p>String separating variables and values.</p>
</td></tr>
<tr><td><code id="labellers_+3A_width">width</code></td>
<td>
<p>Maximum number of characters before wrapping the strip.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>label_value()</code> only displays the value of a factor while
<code>label_both()</code> displays both the variable name and the factor
value. <code>label_context()</code> is context-dependent and uses
<code>label_value()</code> for single factor faceting and
<code>label_both()</code> when multiple factors are
involved. <code>label_wrap_gen()</code> uses <code><a href="base.html#topic+strwrap">base::strwrap()</a></code>
for line wrapping.
</p>
<p><code>label_parsed()</code> interprets the labels as plotmath
expressions. <code><a href="#topic+label_bquote">label_bquote()</a></code> offers a more flexible
way of constructing plotmath expressions. See examples and
<code><a href="base.html#topic+bquote">bquote()</a></code> for details on the syntax of the
argument.
</p>


<h3>Writing New Labeller Functions</h3>

<p>Note that an easy way to write a labeller function is to
transform a function operating on character vectors with
<code><a href="#topic+as_labeller">as_labeller()</a></code>.
</p>
<p>A labeller function accepts a data frame of labels (character
vectors) containing one column for each factor. Multiple factors
occur with formula of the type <code>~first + second</code>.
</p>
<p>The return value must be a rectangular list where each 'row'
characterises a single facet. The list elements can be either
character vectors or lists of plotmath expressions. When multiple
elements are returned, they get displayed on their own new lines
(i.e., each facet gets a multi-line strip of labels).
</p>
<p>To illustrate, let's say your labeller returns a list of two
character vectors of length 3. This is a rectangular list because
all elements have the same length. The first facet will get the
first elements of each vector and display each of them on their
own line. Then the second facet gets the second elements of each
vector, and so on.
</p>
<p>If it's useful to your labeller, you can retrieve the <code>type</code>
attribute of the incoming data frame of labels. The value of this
attribute reflects the kind of strips your labeller is dealing
with: <code>"cols"</code> for columns and <code>"rows"</code> for rows. Note
that <code><a href="#topic+facet_wrap">facet_wrap()</a></code> has columns by default and rows
when the strips are switched with the <code>switch</code> option. The
<code>facet</code> attribute also provides metadata on the labels. It
takes the values <code>"grid"</code> or <code>"wrap"</code>.
</p>
<p>For compatibility with <code><a href="#topic+labeller">labeller()</a></code>, each labeller
function must have the <code>labeller</code> S3 class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+labeller">labeller()</a></code>, <code><a href="#topic+as_labeller">as_labeller()</a></code>,
<code><a href="#topic+label_bquote">label_bquote()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars$cyl2 &lt;- factor(mtcars$cyl, labels = c("alpha", "beta", "gamma"))
p &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()

# The default is label_value
p + facet_grid(. ~ cyl, labeller = label_value)


# Displaying both the values and the variables
p + facet_grid(. ~ cyl, labeller = label_both)

# Displaying only the values or both the values and variables
# depending on whether multiple factors are facetted over
p + facet_grid(am ~ vs+cyl, labeller = label_context)

# Interpreting the labels as plotmath expressions
p + facet_grid(. ~ cyl2)
p + facet_grid(. ~ cyl2, labeller = label_parsed)

</code></pre>

<hr>
<h2 id='labs'>Modify axis, legend, and plot labels</h2><span id='topic+labs'></span><span id='topic+xlab'></span><span id='topic+ylab'></span><span id='topic+ggtitle'></span>

<h3>Description</h3>

<p>Good labels are critical for making your plots accessible to a wider
audience. Always ensure the axis and legend labels display the full
variable name. Use the plot <code>title</code> and <code>subtitle</code> to explain the
main findings. It's common to use the <code>caption</code> to provide information
about the data source. <code>tag</code> can be used for adding identification tags
to differentiate between multiple plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labs(
  ...,
  title = waiver(),
  subtitle = waiver(),
  caption = waiver(),
  tag = waiver(),
  alt = waiver(),
  alt_insight = waiver()
)

xlab(label)

ylab(label)

ggtitle(label, subtitle = waiver())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labs_+3A_...">...</code></td>
<td>
<p>A list of new name-value pairs. The name should be an aesthetic.</p>
</td></tr>
<tr><td><code id="labs_+3A_title">title</code></td>
<td>
<p>The text for the title.</p>
</td></tr>
<tr><td><code id="labs_+3A_subtitle">subtitle</code></td>
<td>
<p>The text for the subtitle for the plot which will be
displayed below the title.</p>
</td></tr>
<tr><td><code id="labs_+3A_caption">caption</code></td>
<td>
<p>The text for the caption which will be displayed in the
bottom-right of the plot by default.</p>
</td></tr>
<tr><td><code id="labs_+3A_tag">tag</code></td>
<td>
<p>The text for the tag label which will be displayed at the
top-left of the plot by default.</p>
</td></tr>
<tr><td><code id="labs_+3A_alt">alt</code>, <code id="labs_+3A_alt_insight">alt_insight</code></td>
<td>
<p>Text used for the generation of alt-text for the plot.
See <a href="#topic+get_alt_text">get_alt_text</a> for examples.</p>
</td></tr>
<tr><td><code id="labs_+3A_label">label</code></td>
<td>
<p>The title of the respective axis (for <code>xlab()</code> or <code>ylab()</code>) or
of the plot (for <code>ggtitle()</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also set axis and legend labels in the individual scales (using
the first argument, the <code>name</code>). If you're changing other scale options, this
is recommended.
</p>
<p>If a plot already has a title, subtitle, caption, etc., and you want to
remove it, you can do so by setting the respective argument to <code>NULL</code>. For
example, if plot <code>p</code> has a subtitle, then <code>p + labs(subtitle = NULL)</code> will
remove the subtitle from the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt, colour = cyl)) + geom_point()
p + labs(colour = "Cylinders")
p + labs(x = "New x label")

# The plot title appears at the top-left, with the subtitle
# display in smaller text underneath it
p + labs(title = "New plot title")
p + labs(title = "New plot title", subtitle = "A subtitle")

# The caption appears in the bottom-right, and is often used for
# sources, notes or copyright
p + labs(caption = "(based on data from ...)")

# The plot tag appears at the top-left, and is typically used
# for labelling a subplot with a letter.
p + labs(title = "title", tag = "A")

# If you want to remove a label, set it to NULL.
p +
 labs(title = "title") +
 labs(title = NULL)
</code></pre>

<hr>
<h2 id='last_plot'>Retrieve the last plot to be modified or created.</h2><span id='topic+last_plot'></span>

<h3>Description</h3>

<p>Retrieve the last plot to be modified or created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_plot()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ggsave">ggsave()</a></code>
</p>

<hr>
<h2 id='layer'>Create a new layer</h2><span id='topic+layer'></span>

<h3>Description</h3>

<p>A layer is a combination of data, stat and geom with a potential position
adjustment. Usually layers are created using <code style="white-space: pre;">&#8288;geom_*&#8288;</code> or <code style="white-space: pre;">&#8288;stat_*&#8288;</code>
calls but it can also be created directly using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer(
  geom = NULL,
  stat = NULL,
  data = NULL,
  mapping = NULL,
  position = NULL,
  params = list(),
  inherit.aes = TRUE,
  check.aes = TRUE,
  check.param = TRUE,
  show.legend = NA,
  key_glyph = NULL,
  layer_class = Layer
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layer_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="layer_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="layer_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="layer_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="layer_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="layer_+3A_params">params</code></td>
<td>
<p>Additional parameters to the <code>geom</code> and <code>stat</code>.</p>
</td></tr>
<tr><td><code id="layer_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="layer_+3A_check.aes">check.aes</code>, <code id="layer_+3A_check.param">check.param</code></td>
<td>
<p>If <code>TRUE</code>, the default, will check that
supplied parameters and aesthetics are understood by the <code>geom</code> or
<code>stat</code>. Use <code>FALSE</code> to suppress the checks.</p>
</td></tr>
<tr><td><code id="layer_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="layer_+3A_key_glyph">key_glyph</code></td>
<td>
<p>A legend key drawing function or a string providing the
function name minus the <code>draw_key_</code> prefix. See <a href="#topic+draw_key">draw_key</a> for details.</p>
</td></tr>
<tr><td><code id="layer_+3A_layer_class">layer_class</code></td>
<td>
<p>The type of layer object to be constructed. This is
intended for ggplot2 internal use only.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># geom calls are just a short cut for layer
ggplot(mpg, aes(displ, hwy)) + geom_point()
# shortcut for
ggplot(mpg, aes(displ, hwy)) +
  layer(
    geom = "point", stat = "identity", position = "identity",
    params = list(na.rm = FALSE)
  )

# use a function as data to plot a subset of global data
ggplot(mpg, aes(displ, hwy)) +
  layer(
    geom = "point", stat = "identity", position = "identity",
    data = head, params = list(na.rm = FALSE)
  )

</code></pre>

<hr>
<h2 id='layer_sf'>Create a new sf layer that auto-maps geometry data</h2><span id='topic+layer_sf'></span>

<h3>Description</h3>

<p>The <code>layer_sf()</code> function is a variant of <code><a href="#topic+layer">layer()</a></code> meant to be used by
extension developers who are writing new sf-based geoms or stats.
The sf layer checks whether the data contains a geometry column, and
if one is found it is automatically mapped to the <code>geometry</code> aesthetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_sf(
  geom = NULL,
  stat = NULL,
  data = NULL,
  mapping = NULL,
  position = NULL,
  params = list(),
  inherit.aes = TRUE,
  check.aes = TRUE,
  check.param = TRUE,
  show.legend = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layer_sf_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="layer_sf_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="layer_sf_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="layer_sf_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="layer_sf_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="layer_sf_+3A_params">params</code></td>
<td>
<p>Additional parameters to the <code>geom</code> and <code>stat</code>.</p>
</td></tr>
<tr><td><code id="layer_sf_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="layer_sf_+3A_check.aes">check.aes</code>, <code id="layer_sf_+3A_check.param">check.param</code></td>
<td>
<p>If <code>TRUE</code>, the default, will check that
supplied parameters and aesthetics are understood by the <code>geom</code> or
<code>stat</code>. Use <code>FALSE</code> to suppress the checks.</p>
</td></tr>
<tr><td><code id="layer_sf_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
</table>

<hr>
<h2 id='limits'>Generate correct scale type for specified limits</h2><span id='topic+limits'></span>

<h3>Description</h3>

<p>Generate correct scale type for specified limits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limits(lims, var, call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="limits_+3A_lims">lims</code></td>
<td>
<p>vector of limits</p>
</td></tr>
<tr><td><code id="limits_+3A_var">var</code></td>
<td>
<p>name of variable</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot2:::limits(c(1, 5), "x")
ggplot2:::limits(c(5, 1), "x")
ggplot2:::limits(c("A", "b", "c"), "x")
ggplot2:::limits(c("A", "b", "c"), "fill")
ggplot2:::limits(as.Date(c("2008-01-01", "2009-01-01")), "x")
</code></pre>

<hr>
<h2 id='lims'>Set scale limits</h2><span id='topic+lims'></span><span id='topic+xlim'></span><span id='topic+ylim'></span>

<h3>Description</h3>

<p>This is a shortcut for supplying the <code>limits</code> argument to the individual
scales. By default, any values outside the limits specified are replaced with
<code>NA</code>. Be warned that this will remove data outside the limits and this can
produce unintended results. For changing x or y axis limits <strong>without</strong>
dropping data observations, see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lims(...)

xlim(...)

ylim(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lims_+3A_...">...</code></td>
<td>
<p>For <code>xlim()</code> and <code>ylim()</code>: Two numeric values, specifying the left/lower
limit and the right/upper limit of the scale. If the larger value is given first,
the scale will be reversed. You can leave one value as <code>NA</code> if you want to compute
the corresponding limit from the range of the data.
</p>
<p>For <code>lims()</code>: A name&ndash;value pair. The name must be an aesthetic, and the value
must be either a length-2 numeric, a character, a factor, or a date/time.
A numeric value will create a continuous scale. If the larger value comes first,
the scale will be reversed. You can leave one value as <code>NA</code> if you want
to compute the corresponding limit from the range of the data.
A character or factor value will create a discrete scale.
A date-time value will create a continuous date/time scale.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>To expand the range of a plot to always include
certain values, see <code><a href="#topic+expand_limits">expand_limits()</a></code>. For other types of data, see
<code><a href="#topic+scale_x_discrete">scale_x_discrete()</a></code>, <code><a href="#topic+scale_x_continuous">scale_x_continuous()</a></code>, <code><a href="#topic+scale_x_date">scale_x_date()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Zoom into a specified area
ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  xlim(15, 20)

# reverse scale
ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  xlim(20, 15)

# with automatic lower limit
ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  xlim(NA, 20)

# You can also supply limits that are larger than the data.
# This is useful if you want to match scales across different plots
small &lt;- subset(mtcars, cyl == 4)
big &lt;- subset(mtcars, cyl &gt; 4)

ggplot(small, aes(mpg, wt, colour = factor(cyl))) +
  geom_point() +
  lims(colour = c("4", "6", "8"))

ggplot(big, aes(mpg, wt, colour = factor(cyl))) +
  geom_point() +
  lims(colour = c("4", "6", "8"))

# There are two ways of setting the axis limits: with limits or
# with coordinate systems. They work in two rather different ways.

set.seed(1)
last_month &lt;- Sys.Date() - 0:59
df &lt;- data.frame(
  date = last_month,
  price = c(rnorm(30, mean = 15), runif(30) + 0.2 * (1:30))
)

p &lt;- ggplot(df, aes(date, price)) +
  geom_line() +
  stat_smooth()

p

# Setting the limits with the scale discards all data outside the range.
p + lims(x= c(Sys.Date() - 30, NA), y = c(10, 20))

# For changing x or y axis limits **without** dropping data
# observations use [coord_cartesian()]. Setting the limits on the
# coordinate system performs a visual zoom.
p + coord_cartesian(xlim =c(Sys.Date() - 30, NA), ylim = c(10, 20))

</code></pre>

<hr>
<h2 id='luv_colours'><code>colors()</code> in Luv space</h2><span id='topic+luv_colours'></span>

<h3>Description</h3>

<p>All built-in <code><a href="grDevices.html#topic+colors">colors()</a></code> translated into Luv colour space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>luv_colours
</code></pre>


<h3>Format</h3>

<p>A data frame with 657 observations and 4 variables:
</p>

<dl>
<dt>L,u,v</dt><dd><p>Position in Luv colour space</p>
</dd>
<dt>col</dt><dd><p>Colour name</p>
</dd>
</dl>


<hr>
<h2 id='map_data'>Create a data frame of map data</h2><span id='topic+map_data'></span>

<h3>Description</h3>

<p>Easily turn data from the <span class="pkg">maps</span> package into a data frame suitable
for plotting with ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_data(map, region = ".", exact = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_data_+3A_map">map</code></td>
<td>
<p>name of map provided by the <span class="pkg">maps</span> package. These
include <code><a href="maps.html#topic+county">maps::county()</a></code>, <code><a href="maps.html#topic+france">maps::france()</a></code>,
<code><a href="maps.html#topic+italy">maps::italy()</a></code>, <code><a href="maps.html#topic+nz">maps::nz()</a></code>,
<code><a href="maps.html#topic+state">maps::state()</a></code>, <code><a href="maps.html#topic+usa">maps::usa()</a></code>,
<code><a href="maps.html#topic+world">maps::world()</a></code>, <code><a href="maps.html#topic+world2">maps::world2()</a></code>.</p>
</td></tr>
<tr><td><code id="map_data_+3A_region">region</code></td>
<td>
<p>name(s) of subregion(s) to include. Defaults to <code>.</code> which
includes all subregions. See documentation for <code><a href="maps.html#topic+map">maps::map()</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="map_data_+3A_exact">exact</code></td>
<td>
<p>should the <code>region</code> be treated as a regular expression
(<code>FALSE</code>) or as a fixed string (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="map_data_+3A_...">...</code></td>
<td>
<p>all other arguments passed on to <code><a href="maps.html#topic+map">maps::map()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("maps")) {
states &lt;- map_data("state")
arrests &lt;- USArrests
names(arrests) &lt;- tolower(names(arrests))
arrests$region &lt;- tolower(rownames(USArrests))

choro &lt;- merge(states, arrests, sort = FALSE, by = "region")
choro &lt;- choro[order(choro$order), ]
ggplot(choro, aes(long, lat)) +
  geom_polygon(aes(group = group, fill = assault)) +
  coord_map("albers",  lat0 = 45.5, lat1 = 29.5)
}

if (require("maps")) {
ggplot(choro, aes(long, lat)) +
  geom_polygon(aes(group = group, fill = assault / murder)) +
  coord_map("albers",  lat0 = 45.5, lat1 = 29.5)
}
</code></pre>

<hr>
<h2 id='max_height'>Get the maximal width/length of a list of grobs</h2><span id='topic+max_height'></span><span id='topic+max_width'></span>

<h3>Description</h3>

<p>Get the maximal width/length of a list of grobs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_height(grobs, value_only = FALSE)

max_width(grobs, value_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_height_+3A_grobs">grobs</code></td>
<td>
<p>A list of grobs</p>
</td></tr>
<tr><td><code id="max_height_+3A_value_only">value_only</code></td>
<td>
<p>Should the return value be a simple numeric vector giving
the maximum in cm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The largest value. measured in cm as a unit object or a numeric
vector depending on <code>value_only</code>
</p>

<hr>
<h2 id='mean_se'>Calculate mean and standard error of the mean</h2><span id='topic+mean_se'></span>

<h3>Description</h3>

<p>For use with <code><a href="#topic+stat_summary">stat_summary()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_se(x, mult = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_se_+3A_x">x</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="mean_se_+3A_mult">mult</code></td>
<td>
<p>number of multiples of standard error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns:
</p>

<dl>
<dt><code>y</code></dt><dd><p> The mean.</p>
</dd>
<dt><code>ymin</code></dt><dd><p> The mean minus the multiples of the standard error.</p>
</dd>
<dt><code>ymax</code></dt><dd><p> The mean plus the multiples of the standard error.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rnorm(100)
mean_se(x)
</code></pre>

<hr>
<h2 id='merge_element'>Merge a parent element into a child element</h2><span id='topic+merge_element'></span><span id='topic+merge_element.default'></span><span id='topic+merge_element.element_blank'></span><span id='topic+merge_element.element'></span>

<h3>Description</h3>

<p>This is a generic and element classes must provide an implementation of this
method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_element(new, old)

## Default S3 method:
merge_element(new, old)

## S3 method for class 'element_blank'
merge_element(new, old)

## S3 method for class 'element'
merge_element(new, old)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_element_+3A_new">new</code></td>
<td>
<p>The child element in the theme hierarchy</p>
</td></tr>
<tr><td><code id="merge_element_+3A_old">old</code></td>
<td>
<p>The parent element in the theme hierarchy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of <code>new</code> updated with the properties of
<code>old</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new &lt;- element_text(colour = "red")
old &lt;- element_text(colour = "blue", size = 10)

# Adopt size but ignore colour
merge_element(new, old)

</code></pre>

<hr>
<h2 id='midwest'>Midwest demographics</h2><span id='topic+midwest'></span>

<h3>Description</h3>

<p>Demographic information of midwest counties from 2000 US census
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midwest
</code></pre>


<h3>Format</h3>

<p>A data frame with 437 rows and 28 variables:
</p>

<dl>
<dt>PID</dt><dd><p>Unique county identifier.</p>
</dd>
<dt>county</dt><dd><p>County name.</p>
</dd>
<dt>state</dt><dd><p>State to which county belongs to.</p>
</dd>
<dt>area</dt><dd><p>Area of county (units unknown).</p>
</dd>
<dt>poptotal</dt><dd><p>Total population.</p>
</dd>
<dt>popdensity</dt><dd><p>Population density (person/unit area).</p>
</dd>
<dt>popwhite</dt><dd><p>Number of whites.</p>
</dd>
<dt>popblack</dt><dd><p>Number of blacks.</p>
</dd>
<dt>popamerindian</dt><dd><p>Number of American Indians.</p>
</dd>
<dt>popasian</dt><dd><p>Number of Asians.</p>
</dd>
<dt>popother</dt><dd><p>Number of other races.</p>
</dd>
<dt>percwhite</dt><dd><p>Percent white.</p>
</dd>
<dt>percblack</dt><dd><p>Percent black.</p>
</dd>
<dt>percamerindan</dt><dd><p>Percent American Indian.</p>
</dd>
<dt>percasian</dt><dd><p>Percent Asian.</p>
</dd>
<dt>percother</dt><dd><p>Percent other races.</p>
</dd>
<dt>popadults</dt><dd><p>Number of adults.</p>
</dd>
<dt>perchsd</dt><dd><p>Percent with high school diploma.</p>
</dd>
<dt>percollege</dt><dd><p>Percent college educated.</p>
</dd>
<dt>percprof</dt><dd><p>Percent with professional degree.</p>
</dd>
<dt>poppovertyknown</dt><dd><p>Population with known poverty status.</p>
</dd>
<dt>percpovertyknown</dt><dd><p>Percent of population with known poverty status.</p>
</dd>
<dt>percbelowpoverty</dt><dd><p>Percent of people below poverty line.</p>
</dd>
<dt>percchildbelowpovert</dt><dd><p>Percent of children below poverty line.</p>
</dd>
<dt>percadultpoverty</dt><dd><p>Percent of adults below poverty line.</p>
</dd>
<dt>percelderlypoverty</dt><dd><p>Percent of elderly below poverty line.</p>
</dd>
<dt>inmetro</dt><dd><p>County considered in a metro area.</p>
</dd>
<dt>category</dt><dd><p>Miscellaneous.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Note: this dataset is included for illustrative purposes. The original
descriptions were not documented and the current descriptions here are based
on speculation. For more accurate and up-to-date US census data, see the
<a href="https://cran.r-project.org/package=acs"><code>acs</code> package</a>.
</p>

<hr>
<h2 id='mpg'>Fuel economy data from 1999 to 2008 for 38 popular models of cars</h2><span id='topic+mpg'></span>

<h3>Description</h3>

<p>This dataset contains a subset of the fuel economy data that the EPA makes
available on <a href="https://fueleconomy.gov/">https://fueleconomy.gov/</a>. It contains only models which
had a new release every year between 1999 and 2008 - this was used as a
proxy for the popularity of the car.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpg
</code></pre>


<h3>Format</h3>

<p>A data frame with 234 rows and 11 variables:
</p>

<dl>
<dt>manufacturer</dt><dd><p>manufacturer name</p>
</dd>
<dt>model</dt><dd><p>model name</p>
</dd>
<dt>displ</dt><dd><p>engine displacement, in litres</p>
</dd>
<dt>year</dt><dd><p>year of manufacture</p>
</dd>
<dt>cyl</dt><dd><p>number of cylinders</p>
</dd>
<dt>trans</dt><dd><p>type of transmission</p>
</dd>
<dt>drv</dt><dd><p>the type of drive train, where f = front-wheel drive, r = rear wheel drive, 4 = 4wd</p>
</dd>
<dt>cty</dt><dd><p>city miles per gallon</p>
</dd>
<dt>hwy</dt><dd><p>highway miles per gallon</p>
</dd>
<dt>fl</dt><dd><p>fuel type</p>
</dd>
<dt>class</dt><dd><p>&quot;type&quot; of car</p>
</dd>
</dl>


<hr>
<h2 id='msleep'>An updated and expanded version of the mammals sleep dataset</h2><span id='topic+msleep'></span>

<h3>Description</h3>

<p>This is an updated and expanded version of the mammals sleep dataset.
Updated sleep times and weights were taken from V. M. Savage and G. B.
West. A quantitative, theoretical framework for understanding mammalian
sleep. Proceedings of the National Academy of Sciences, 104 (3):1051-1056,
2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msleep
</code></pre>


<h3>Format</h3>

<p>A data frame with 83 rows and 11 variables:
</p>

<dl>
<dt>name</dt><dd><p>common name</p>
</dd>
<dt>genus</dt><dd></dd>
<dt>vore</dt><dd><p>carnivore, omnivore or herbivore?</p>
</dd>
<dt>order</dt><dd></dd>
<dt>conservation</dt><dd><p>the conservation status of the animal</p>
</dd>
<dt>sleep_total</dt><dd><p>total amount of sleep, in hours</p>
</dd>
<dt>sleep_rem</dt><dd><p>rem sleep, in hours</p>
</dd>
<dt>sleep_cycle</dt><dd><p>length of sleep cycle, in hours</p>
</dd>
<dt>awake</dt><dd><p>amount of time spent awake, in hours</p>
</dd>
<dt>brainwt</dt><dd><p>brain weight in kilograms</p>
</dd>
<dt>bodywt</dt><dd><p>body weight in kilograms</p>
</dd>
</dl>



<h3>Details</h3>

<p>Additional variables order, conservation status and vore were added from
wikipedia.
</p>

<hr>
<h2 id='new_guide'>Guide constructor</h2><span id='topic+new_guide'></span>

<h3>Description</h3>

<p>A constructor function for guides, which performs some standard compatibility
checks between the guide and provided arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_guide(..., available_aes = "any", super)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_guide_+3A_...">...</code></td>
<td>
<p>Named arguments that match the parameters of <code>super$params</code> or
the theme elements in <code>super$elements</code>.</p>
</td></tr>
<tr><td><code id="new_guide_+3A_available_aes">available_aes</code></td>
<td>
<p>A vector of character strings listing the aesthetics
for which the guide can be drawn.</p>
</td></tr>
<tr><td><code id="new_guide_+3A_super">super</code></td>
<td>
<p>The super class to use for the constructed guide. Should be a
Guide class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Guide</code> ggproto object.
</p>

<hr>
<h2 id='old_guide'>The previous S3 guide system</h2><span id='topic+old_guide'></span><span id='topic+guide_train'></span><span id='topic+guide_merge'></span><span id='topic+guide_geom'></span><span id='topic+guide_transform'></span><span id='topic+guide_gengrob'></span>

<h3>Description</h3>

<p>The guide system has been overhauled to use the ggproto infrastructure to
accommodate guide extensions with the same flexibility as layers, scales and
other ggplot2 objects. In rewriting, the old S3 system has become defunct,
meaning that the previous methods for guides have been superseded by ggproto
methods. As a fallback option, the generics, but not the methods, that the
previous S3 system used are encapsulated in the <code>GuideOld</code> ggproto class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_train(guide, scale, aesthetic = NULL)

guide_merge(guide, new_guide)

guide_geom(guide, layers, default_mapping = NULL)

guide_transform(guide, coord, panel_params)

guide_gengrob(guide, theme)

old_guide(guide)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="old_guide_+3A_guide">guide</code></td>
<td>
<p>An old guide object</p>
</td></tr>
</table>

<hr>
<h2 id='pattern_alpha'>Modify transparency for patterns</h2><span id='topic+pattern_alpha'></span>

<h3>Description</h3>

<p>This generic allows you to add your own methods for adding transparency to
pattern-like objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattern_alpha(x, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pattern_alpha_+3A_x">x</code></td>
<td>
<p>Object to be interpreted as pattern.</p>
</td></tr>
<tr><td><code id="pattern_alpha_+3A_alpha">alpha</code></td>
<td>
<p>A <code>numeric</code> vector between 0 and 1. If <code>NA</code>, alpha values
are preserved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with modified transparency
</p>

<hr>
<h2 id='position_dodge'>Dodge overlapping objects side-to-side</h2><span id='topic+position_dodge'></span><span id='topic+position_dodge2'></span>

<h3>Description</h3>

<p>Dodging preserves the vertical position of an geom while adjusting the
horizontal position. <code>position_dodge()</code> requires the grouping variable to be
be specified in the global or <code style="white-space: pre;">&#8288;geom_*&#8288;</code> layer. Unlike <code>position_dodge()</code>,
<code>position_dodge2()</code> works without a grouping variable in a layer.
<code>position_dodge2()</code> works with bars and rectangles, but is
particularly useful for arranging box plots, which
can have variable widths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_dodge(width = NULL, preserve = "total")

position_dodge2(
  width = NULL,
  preserve = "total",
  padding = 0.1,
  reverse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_dodge_+3A_width">width</code></td>
<td>
<p>Dodging width, when different to the width of the individual
elements. This is useful when you want to align narrow geoms with wider
geoms. See the examples.</p>
</td></tr>
<tr><td><code id="position_dodge_+3A_preserve">preserve</code></td>
<td>
<p>Should dodging preserve the <code>"total"</code> width of all elements
at a position, or the width of a <code>"single"</code> element?</p>
</td></tr>
<tr><td><code id="position_dodge_+3A_padding">padding</code></td>
<td>
<p>Padding between elements at the same position. Elements are
shrunk by this proportion to allow space between them. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="position_dodge_+3A_reverse">reverse</code></td>
<td>
<p>If <code>TRUE</code>, will reverse the default stacking order.
This is useful if you're rotating both the plot and legend.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_identity">position_identity</a>()</code>,
<code><a href="#topic+position_jitterdodge">position_jitterdodge</a>()</code>,
<code><a href="#topic+position_jitter">position_jitter</a>()</code>,
<code><a href="#topic+position_nudge">position_nudge</a>()</code>,
<code><a href="#topic+position_stack">position_stack</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
  geom_bar(position = "dodge2")

# By default, dodging with `position_dodge2()` preserves the total width of
# the elements. You can choose to preserve the width of each element with:
ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
  geom_bar(position = position_dodge2(preserve = "single"))


ggplot(diamonds, aes(price, fill = cut)) +
  geom_histogram(position="dodge2")
# see ?geom_bar for more examples

# In this case a frequency polygon is probably a better choice
ggplot(diamonds, aes(price, colour = cut)) +
  geom_freqpoly()


# Dodging with various widths -------------------------------------
# To dodge items with different widths, you need to be explicit
df &lt;- data.frame(
  x = c("a","a","b","b"),
  y = 2:5,
  g = rep(1:2, 2)
)
p &lt;- ggplot(df, aes(x, y, group = g)) +
  geom_col(position = "dodge", fill = "grey50", colour = "black")
p

# A line range has no width:
p + geom_linerange(aes(ymin = y - 1, ymax = y + 1), position = "dodge")

# So you must explicitly specify the width
p + geom_linerange(
  aes(ymin = y - 1, ymax = y + 1),
  position = position_dodge(width = 0.9)
)

# The same principle applies to error bars, which are usually
# narrower than the bars
p + geom_errorbar(
  aes(ymin = y - 1, ymax = y + 1),
  width = 0.2,
  position = "dodge"
)
p + geom_errorbar(
  aes(ymin = y - 1, ymax = y + 1),
  width = 0.2,
  position = position_dodge(width = 0.9)
)

# Box plots use position_dodge2 by default, and bars can use it too
ggplot(mpg, aes(factor(year), displ)) +
  geom_boxplot(aes(colour = hwy &lt; 30))

ggplot(mpg, aes(factor(year), displ)) +
  geom_boxplot(aes(colour = hwy &lt; 30), varwidth = TRUE)

ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
  geom_bar(position = position_dodge2(preserve = "single"))

ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
  geom_bar(position = position_dodge2(preserve = "total"))
</code></pre>

<hr>
<h2 id='position_identity'>Don't adjust position</h2><span id='topic+position_identity'></span>

<h3>Description</h3>

<p>Don't adjust position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_identity()
</code></pre>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_dodge">position_dodge</a>()</code>,
<code><a href="#topic+position_jitterdodge">position_jitterdodge</a>()</code>,
<code><a href="#topic+position_jitter">position_jitter</a>()</code>,
<code><a href="#topic+position_nudge">position_nudge</a>()</code>,
<code><a href="#topic+position_stack">position_stack</a>()</code>
</p>

<hr>
<h2 id='position_jitter'>Jitter points to avoid overplotting</h2><span id='topic+position_jitter'></span>

<h3>Description</h3>

<p>Counterintuitively adding random noise to a plot can sometimes make it
easier to read. Jittering is particularly useful for small datasets with
at least one discrete position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_jitter(width = NULL, height = NULL, seed = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_jitter_+3A_width">width</code>, <code id="position_jitter_+3A_height">height</code></td>
<td>
<p>Amount of vertical and horizontal jitter. The jitter
is added in both positive and negative directions, so the total spread
is twice the value specified here.
</p>
<p>If omitted, defaults to 40% of the resolution of the data: this means the
jitter values will occupy 80% of the implied bins. Categorical data
is aligned on the integers, so a width or height of 0.5 will spread the
data so it's not possible to see the distinction between the categories.</p>
</td></tr>
<tr><td><code id="position_jitter_+3A_seed">seed</code></td>
<td>
<p>A random seed to make the jitter reproducible.
Useful if you need to apply the same jitter twice, e.g., for a point and
a corresponding label.
The random seed is reset after jittering.
If <code>NA</code> (the default value), the seed is initialised with a random value;
this makes sure that two subsequent calls start with a different seed.
Use <code>NULL</code> to use the current random seed and also avoid resetting
(the behaviour of <span class="pkg">ggplot</span> 2.2.1 and earlier).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_dodge">position_dodge</a>()</code>,
<code><a href="#topic+position_identity">position_identity</a>()</code>,
<code><a href="#topic+position_jitterdodge">position_jitterdodge</a>()</code>,
<code><a href="#topic+position_nudge">position_nudge</a>()</code>,
<code><a href="#topic+position_stack">position_stack</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Jittering is useful when you have a discrete position, and a relatively
# small number of points
# take up as much space as a boxplot or a bar
ggplot(mpg, aes(class, hwy)) +
  geom_boxplot(colour = "grey50") +
  geom_jitter()

# If the default jittering is too much, as in this plot:
ggplot(mtcars, aes(am, vs)) +
  geom_jitter()

# You can adjust it in two ways
ggplot(mtcars, aes(am, vs)) +
  geom_jitter(width = 0.1, height = 0.1)
ggplot(mtcars, aes(am, vs)) +
  geom_jitter(position = position_jitter(width = 0.1, height = 0.1))

# Create a jitter object for reproducible jitter:
jitter &lt;- position_jitter(width = 0.1, height = 0.1)
ggplot(mtcars, aes(am, vs)) +
  geom_point(position = jitter) +
  geom_point(position = jitter, color = "red", aes(am + 0.2, vs + 0.2))
</code></pre>

<hr>
<h2 id='position_jitterdodge'>Simultaneously dodge and jitter</h2><span id='topic+position_jitterdodge'></span>

<h3>Description</h3>

<p>This is primarily used for aligning points generated through
<code>geom_point()</code> with dodged boxplots (e.g., a <code>geom_boxplot()</code> with
a fill aesthetic supplied).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_jitterdodge(
  jitter.width = NULL,
  jitter.height = 0,
  dodge.width = 0.75,
  seed = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_jitterdodge_+3A_jitter.width">jitter.width</code></td>
<td>
<p>degree of jitter in x direction. Defaults to 40% of the
resolution of the data.</p>
</td></tr>
<tr><td><code id="position_jitterdodge_+3A_jitter.height">jitter.height</code></td>
<td>
<p>degree of jitter in y direction. Defaults to 0.</p>
</td></tr>
<tr><td><code id="position_jitterdodge_+3A_dodge.width">dodge.width</code></td>
<td>
<p>the amount to dodge in the x direction. Defaults to 0.75,
the default <code>position_dodge()</code> width.</p>
</td></tr>
<tr><td><code id="position_jitterdodge_+3A_seed">seed</code></td>
<td>
<p>A random seed to make the jitter reproducible.
Useful if you need to apply the same jitter twice, e.g., for a point and
a corresponding label.
The random seed is reset after jittering.
If <code>NA</code> (the default value), the seed is initialised with a random value;
this makes sure that two subsequent calls start with a different seed.
Use <code>NULL</code> to use the current random seed and also avoid resetting
(the behaviour of <span class="pkg">ggplot</span> 2.2.1 and earlier).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_dodge">position_dodge</a>()</code>,
<code><a href="#topic+position_identity">position_identity</a>()</code>,
<code><a href="#topic+position_jitter">position_jitter</a>()</code>,
<code><a href="#topic+position_nudge">position_nudge</a>()</code>,
<code><a href="#topic+position_stack">position_stack</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(596)
dsub &lt;- diamonds[sample(nrow(diamonds), 1000), ]
ggplot(dsub, aes(x = cut, y = carat, fill = clarity)) +
  geom_boxplot(outlier.size = 0) +
  geom_point(pch = 21, position = position_jitterdodge())
</code></pre>

<hr>
<h2 id='position_nudge'>Nudge points a fixed distance</h2><span id='topic+position_nudge'></span>

<h3>Description</h3>

<p><code>position_nudge()</code> is generally useful for adjusting the position of
items on discrete scales by a small amount. Nudging is built in to
<code><a href="#topic+geom_text">geom_text()</a></code> because it's so useful for moving labels a small
distance from what they're labelling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_nudge(x = 0, y = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_nudge_+3A_x">x</code>, <code id="position_nudge_+3A_y">y</code></td>
<td>
<p>Amount of vertical and horizontal distance to move.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_dodge">position_dodge</a>()</code>,
<code><a href="#topic+position_identity">position_identity</a>()</code>,
<code><a href="#topic+position_jitterdodge">position_jitterdodge</a>()</code>,
<code><a href="#topic+position_jitter">position_jitter</a>()</code>,
<code><a href="#topic+position_stack">position_stack</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  x = c(1,3,2,5),
  y = c("a","c","d","c")
)

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text(aes(label = y))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text(aes(label = y), position = position_nudge(y = -0.1))

# Or, in brief
ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text(aes(label = y), nudge_y = -0.1)
</code></pre>

<hr>
<h2 id='position_stack'>Stack overlapping objects on top of each another</h2><span id='topic+position_stack'></span><span id='topic+position_fill'></span>

<h3>Description</h3>

<p><code>position_stack()</code> stacks bars on top of each other;
<code>position_fill()</code> stacks bars and standardises each stack to have
constant height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_stack(vjust = 1, reverse = FALSE)

position_fill(vjust = 1, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_stack_+3A_vjust">vjust</code></td>
<td>
<p>Vertical adjustment for geoms that have a position
(like points or lines), not a dimension (like bars or areas). Set to
<code>0</code> to align with the bottom, <code>0.5</code> for the middle,
and <code>1</code> (the default) for the top.</p>
</td></tr>
<tr><td><code id="position_stack_+3A_reverse">reverse</code></td>
<td>
<p>If <code>TRUE</code>, will reverse the default stacking order.
This is useful if you're rotating both the plot and legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>position_fill()</code> and <code>position_stack()</code> automatically stack
values in reverse order of the group aesthetic, which for bar charts is
usually defined by the fill aesthetic (the default group aesthetic is formed
by the combination of all discrete aesthetics except for x and y). This
default ensures that bar colours align with the default legend.
</p>
<p>There are three ways to override the defaults depending on what you want:
</p>

<ol>
<li><p> Change the order of the levels in the underlying factor. This
will change the stacking order, and the order of keys in the legend.
</p>
</li>
<li><p> Set the legend <code>breaks</code> to change the order of the keys
without affecting the stacking.
</p>
</li>
<li><p> Manually set the group aesthetic to change the stacking order
without affecting the legend.
</p>
</li></ol>

<p>Stacking of positive and negative values are performed separately so that
positive values stack upwards from the x-axis and negative values stack
downward.
</p>
<p>Because stacking is performed after scale transformations, stacking with
non-linear scales gives distortions that easily lead to misinterpretations of
the data. It is therefore <em>discouraged</em> to use these position adjustments in
combination with scale transformations, such as logarithmic or square root
scales.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_bar">geom_bar()</a></code> and <code><a href="#topic+geom_area">geom_area()</a></code> for
more examples.
</p>
<p>Other position adjustments: 
<code><a href="#topic+position_dodge">position_dodge</a>()</code>,
<code><a href="#topic+position_identity">position_identity</a>()</code>,
<code><a href="#topic+position_jitterdodge">position_jitterdodge</a>()</code>,
<code><a href="#topic+position_jitter">position_jitter</a>()</code>,
<code><a href="#topic+position_nudge">position_nudge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stacking and filling ------------------------------------------------------

# Stacking is the default behaviour for most area plots.
# Fill makes it easier to compare proportions
ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
  geom_bar()
ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
  geom_bar(position = "fill")

ggplot(diamonds, aes(price, fill = cut)) +
  geom_histogram(binwidth = 500)
ggplot(diamonds, aes(price, fill = cut)) +
  geom_histogram(binwidth = 500, position = "fill")

# Stacking is also useful for time series
set.seed(1)
series &lt;- data.frame(
  time = c(rep(1, 4),rep(2, 4), rep(3, 4), rep(4, 4)),
  type = rep(c('a', 'b', 'c', 'd'), 4),
  value = rpois(16, 10)
)
ggplot(series, aes(time, value)) +
  geom_area(aes(fill = type))

# Stacking order ------------------------------------------------------------
# The stacking order is carefully designed so that the plot matches
# the legend.

# You control the stacking order by setting the levels of the underlying
# factor. See the forcats package for convenient helpers.
series$type2 &lt;- factor(series$type, levels = c('c', 'b', 'd', 'a'))
ggplot(series, aes(time, value)) +
  geom_area(aes(fill = type2))

# You can change the order of the levels in the legend using the scale
ggplot(series, aes(time, value)) +
  geom_area(aes(fill = type)) +
  scale_fill_discrete(breaks = c('a', 'b', 'c', 'd'))

# If you've flipped the plot, use reverse = TRUE so the levels
# continue to match
ggplot(series, aes(time, value)) +
  geom_area(aes(fill = type2), position = position_stack(reverse = TRUE)) +
  coord_flip() +
  theme(legend.position = "top")

# Non-area plots ------------------------------------------------------------

# When stacking across multiple layers it's a good idea to always set
# the `group` aesthetic in the ggplot() call. This ensures that all layers
# are stacked in the same way.
ggplot(series, aes(time, value, group = type)) +
  geom_line(aes(colour = type), position = "stack") +
  geom_point(aes(colour = type), position = "stack")

ggplot(series, aes(time, value, group = type)) +
  geom_area(aes(fill = type)) +
  geom_line(aes(group = type), position = "stack")

# You can also stack labels, but the default position is suboptimal.
ggplot(series, aes(time, value, group = type)) +
  geom_area(aes(fill = type)) +
  geom_text(aes(label = type), position = "stack")

# You can override this with the vjust parameter. A vjust of 0.5
# will center the labels inside the corresponding area
ggplot(series, aes(time, value, group = type)) +
  geom_area(aes(fill = type)) +
  geom_text(aes(label = type), position = position_stack(vjust = 0.5))

# Negative values -----------------------------------------------------------

df &lt;- tibble::tribble(
  ~x, ~y, ~grp,
  "a", 1,  "x",
  "a", 2,  "y",
  "b", 1,  "x",
  "b", 3,  "y",
  "b", -1, "y"
)
ggplot(data = df, aes(x, y, group = grp)) +
  geom_col(aes(fill = grp), position = position_stack(reverse = TRUE)) +
  geom_hline(yintercept = 0)

ggplot(data = df, aes(x, y, group = grp)) +
  geom_col(aes(fill = grp)) +
  geom_hline(yintercept = 0) +
  geom_text(aes(label = grp), position = position_stack(vjust = 0.5))
</code></pre>

<hr>
<h2 id='presidential'>Terms of 12 presidents from Eisenhower to Trump</h2><span id='topic+presidential'></span>

<h3>Description</h3>

<p>The names of each president, the start and end date of their term, and
their party of 12 US presidents from Eisenhower to Trump.  This data is
in the public domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>presidential
</code></pre>


<h3>Format</h3>

<p>A data frame with 12 rows and 4 variables:
</p>

<dl>
<dt>name</dt><dd><p>Last name of president</p>
</dd>
<dt>start</dt><dd><p>Presidency start date</p>
</dd>
<dt>end</dt><dd><p>Presidency end date</p>
</dd>
<dt>party</dt><dd><p>Party of president</p>
</dd>
</dl>


<hr>
<h2 id='print.ggplot'>Explicitly draw plot</h2><span id='topic+print.ggplot'></span><span id='topic+plot.ggplot'></span>

<h3>Description</h3>

<p>Generally, you do not need to print or plot a ggplot2 plot explicitly: the
default top-level print method will do it for you. You will, however, need
to call <code>print()</code> explicitly if you want to draw a plot inside a
function or for loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggplot'
print(x, newpage = is.null(vp), vp = NULL, ...)

## S3 method for class 'ggplot'
plot(x, newpage = is.null(vp), vp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ggplot_+3A_x">x</code></td>
<td>
<p>plot to display</p>
</td></tr>
<tr><td><code id="print.ggplot_+3A_newpage">newpage</code></td>
<td>
<p>draw new (empty) page first?</p>
</td></tr>
<tr><td><code id="print.ggplot_+3A_vp">vp</code></td>
<td>
<p>viewport to draw plot in</p>
</td></tr>
<tr><td><code id="print.ggplot_+3A_...">...</code></td>
<td>
<p>other arguments not used by this method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colours &lt;- list(~class, ~drv, ~fl)

# Doesn't seem to do anything!
for (colour in colours) {
  ggplot(mpg, aes_(~ displ, ~ hwy, colour = colour)) +
    geom_point()
}

# Works when we explicitly print the plots
for (colour in colours) {
  print(ggplot(mpg, aes_(~ displ, ~ hwy, colour = colour)) +
    geom_point())
}
</code></pre>

<hr>
<h2 id='print.ggproto'>Format or print a ggproto object</h2><span id='topic+print.ggproto'></span><span id='topic+format.ggproto'></span>

<h3>Description</h3>

<p>If a ggproto object has a <code style="white-space: pre;">&#8288;$print&#8288;</code> method, this will call that method.
Otherwise, it will print out the members of the object, and optionally, the
members of the inherited objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggproto'
print(x, ..., flat = TRUE)

## S3 method for class 'ggproto'
format(x, ..., flat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ggproto_+3A_x">x</code></td>
<td>
<p>A ggproto object to print.</p>
</td></tr>
<tr><td><code id="print.ggproto_+3A_...">...</code></td>
<td>
<p>If the ggproto object has a <code>print</code> method, further arguments
will be passed to it. Otherwise, these arguments are unused.</p>
</td></tr>
<tr><td><code id="print.ggproto_+3A_flat">flat</code></td>
<td>
<p>If <code>TRUE</code> (the default), show a flattened list of all local
and inherited members. If <code>FALSE</code>, show the inheritance hierarchy.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Dog &lt;- ggproto(
  print = function(self, n) {
    cat("Woof!\n")
  }
 )
Dog
cat(format(Dog), "\n")
</code></pre>

<hr>
<h2 id='qplot'>Quick plot</h2><span id='topic+qplot'></span><span id='topic+quickplot'></span>

<h3>Description</h3>

<p><code>qplot()</code> is now deprecated in order to encourage the users to
learn <code><a href="#topic+ggplot">ggplot()</a></code> as it makes it easier to create complex graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qplot(
  x,
  y,
  ...,
  data,
  facets = NULL,
  margins = FALSE,
  geom = "auto",
  xlim = c(NA, NA),
  ylim = c(NA, NA),
  log = "",
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  asp = NA,
  stat = deprecated(),
  position = deprecated()
)

quickplot(
  x,
  y,
  ...,
  data,
  facets = NULL,
  margins = FALSE,
  geom = "auto",
  xlim = c(NA, NA),
  ylim = c(NA, NA),
  log = "",
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  asp = NA,
  stat = deprecated(),
  position = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qplot_+3A_x">x</code>, <code id="qplot_+3A_y">y</code>, <code id="qplot_+3A_...">...</code></td>
<td>
<p>Aesthetics passed into each layer</p>
</td></tr>
<tr><td><code id="qplot_+3A_data">data</code></td>
<td>
<p>Data frame to use (optional).  If not specified, will create
one, extracting vectors from the current environment.</p>
</td></tr>
<tr><td><code id="qplot_+3A_facets">facets</code></td>
<td>
<p>faceting formula to use. Picks <code><a href="#topic+facet_wrap">facet_wrap()</a></code> or
<code><a href="#topic+facet_grid">facet_grid()</a></code> depending on whether the formula is one-
or two-sided</p>
</td></tr>
<tr><td><code id="qplot_+3A_margins">margins</code></td>
<td>
<p>See <code>facet_grid()</code>: display marginal facets?</p>
</td></tr>
<tr><td><code id="qplot_+3A_geom">geom</code></td>
<td>
<p>Character vector specifying geom(s) to draw. Defaults to
&quot;point&quot; if x and y are specified, and &quot;histogram&quot; if only x is specified.</p>
</td></tr>
<tr><td><code id="qplot_+3A_xlim">xlim</code>, <code id="qplot_+3A_ylim">ylim</code></td>
<td>
<p>X and y axis limits</p>
</td></tr>
<tr><td><code id="qplot_+3A_log">log</code></td>
<td>
<p>Which variables to log transform (&quot;x&quot;, &quot;y&quot;, or &quot;xy&quot;)</p>
</td></tr>
<tr><td><code id="qplot_+3A_main">main</code>, <code id="qplot_+3A_xlab">xlab</code>, <code id="qplot_+3A_ylab">ylab</code></td>
<td>
<p>Character vector (or expression) giving plot title,
x axis label, and y axis label respectively.</p>
</td></tr>
<tr><td><code id="qplot_+3A_asp">asp</code></td>
<td>
<p>The y/x aspect ratio</p>
</td></tr>
<tr><td><code id="qplot_+3A_stat">stat</code>, <code id="qplot_+3A_position">position</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Use data from data.frame
qplot(mpg, wt, data = mtcars)
qplot(mpg, wt, data = mtcars, colour = cyl)
qplot(mpg, wt, data = mtcars, size = cyl)
qplot(mpg, wt, data = mtcars, facets = vs ~ am)


set.seed(1)
qplot(1:10, rnorm(10), colour = runif(10))
qplot(1:10, letters[1:10])
mod &lt;- lm(mpg ~ wt, data = mtcars)
qplot(resid(mod), fitted(mod))

f &lt;- function() {
   a &lt;- 1:10
   b &lt;- a ^ 2
   qplot(a, b)
}
f()

# To set aesthetics, wrap in I()
qplot(mpg, wt, data = mtcars, colour = I("red"))

# qplot will attempt to guess what geom you want depending on the input
# both x and y supplied = scatterplot
qplot(mpg, wt, data = mtcars)
# just x supplied = histogram
qplot(mpg, data = mtcars)
# just y supplied = scatterplot, with x = seq_along(y)
qplot(y = mpg, data = mtcars)

# Use different geoms
qplot(mpg, wt, data = mtcars, geom = "path")
qplot(factor(cyl), wt, data = mtcars, geom = c("boxplot", "jitter"))
qplot(mpg, data = mtcars, geom = "dotplot")

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+alpha'></span><span id='topic+unit'></span><span id='topic+arrow'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>grid</dt><dd><p><code><a href="grid.html#topic+arrow">arrow</a></code>, <code><a href="grid.html#topic+unit">unit</a></code></p>
</dd>
<dt>scales</dt><dd><p><code><a href="scales.html#topic+alpha">alpha</a></code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mpg, aes(displ, hwy)) +
  geom_point(alpha = 0.5, colour = "blue")

ggplot(mpg, aes(displ, hwy)) +
  geom_point(colour = alpha("blue", 0.5))
</code></pre>

<hr>
<h2 id='register_theme_elements'>Define and register new theme elements</h2><span id='topic+register_theme_elements'></span><span id='topic+reset_theme_settings'></span><span id='topic+get_element_tree'></span><span id='topic+el_def'></span>

<h3>Description</h3>

<p>The underlying structure of a ggplot2 theme is defined via the element tree, which
specifies for each theme element what type it should have and whether it inherits from
a parent element. In some use cases, it may be necessary to modify or extend this
element tree and provide default settings for newly defined theme elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_theme_elements(..., element_tree = NULL, complete = TRUE)

reset_theme_settings(reset_current = TRUE)

get_element_tree()

el_def(class = NULL, inherit = NULL, description = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_theme_elements_+3A_...">...</code></td>
<td>
<p>Element specifications</p>
</td></tr>
<tr><td><code id="register_theme_elements_+3A_element_tree">element_tree</code></td>
<td>
<p>Addition of or modification to the element tree, which specifies the
inheritance relationship of the theme elements. The element tree must be provided as
a list of named element definitions created with el_def().</p>
</td></tr>
<tr><td><code id="register_theme_elements_+3A_complete">complete</code></td>
<td>
<p>If <code>TRUE</code> (the default), elements are set to inherit from blank elements.</p>
</td></tr>
<tr><td><code id="register_theme_elements_+3A_reset_current">reset_current</code></td>
<td>
<p>If <code>TRUE</code> (the default), the currently active theme is
reset to the default theme.</p>
</td></tr>
<tr><td><code id="register_theme_elements_+3A_class">class</code></td>
<td>
<p>The name of the element class. Examples are &quot;element_line&quot; or
&quot;element_text&quot; or &quot;unit&quot;, or one of the two reserved keywords &quot;character&quot; or
&quot;margin&quot;. The reserved keyword &quot;character&quot; implies a character
or numeric vector, not a class called &quot;character&quot;. The keyword
&quot;margin&quot; implies a unit vector of length 4, as created by <code><a href="#topic+margin">margin()</a></code>.</p>
</td></tr>
<tr><td><code id="register_theme_elements_+3A_inherit">inherit</code></td>
<td>
<p>A vector of strings, naming the elements that this
element inherits from.</p>
</td></tr>
<tr><td><code id="register_theme_elements_+3A_description">description</code></td>
<td>
<p>An optional character vector providing a description
for the element.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>register_theme_elements()</code> provides the option to globally register new
theme elements with ggplot2. In general, for each new theme element both an element
definition and a corresponding entry in the element tree should be provided. See
examples for details. This function is meant primarily for developers of extension
packages, who are strongly urged to adhere to the following best practices:
</p>

<ol>
<li><p> Call <code>register_theme_elements()</code> from the <code>.onLoad()</code> function of your package, so
that the new theme elements are available to anybody using functions from your package,
irrespective of whether the package has been attached (with <code>library()</code> or <code>require()</code>)
or not.
</p>
</li>
<li><p> For any new elements you create, prepend them with the name of your package, to avoid
name clashes with other extension packages. For example, if you are working on a package
<strong>ggxyz</strong>, and you want it to provide a new element for plot panel annotations (as demonstrated
in the Examples below), name the new element <code>ggxyz.panel.annotation</code>.
</p>
</li></ol>

<p>The function <code>reset_theme_settings()</code> restores the default element tree, discards
all new element definitions, and (unless turned off) resets the currently active
theme to the default.
</p>
<p>The function <code>get_element_tree()</code> returns the currently active element tree.
</p>
<p>The function <code>el_def()</code> is used to define new or modified element types and
element inheritance relationships for the element tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's assume a package `ggxyz` wants to provide an easy way to add annotations to
# plot panels. To do so, it registers a new theme element `ggxyz.panel.annotation`
register_theme_elements(
  ggxyz.panel.annotation = element_text(color = "blue", hjust = 0.95, vjust = 0.05),
  element_tree = list(ggxyz.panel.annotation = el_def("element_text", "text"))
)

# Now the package can define a new coord that includes a panel annotation
coord_annotate &lt;- function(label = "panel annotation") {
  ggproto(NULL, CoordCartesian,
    limits = list(x = NULL, y = NULL),
    expand = TRUE,
    default = FALSE,
    clip = "on",
    render_fg = function(panel_params, theme) {
      element_render(theme, "ggxyz.panel.annotation", label = label)
    }
  )
}

# Example plot with this new coord
df &lt;- data.frame(x = 1:3, y = 1:3)
ggplot(df, aes(x, y)) +
  geom_point() +
  coord_annotate("annotation in blue")

# Revert to the original ggplot2 settings
reset_theme_settings()
</code></pre>

<hr>
<h2 id='remove_missing'>Convenience function to remove missing values from a data.frame</h2><span id='topic+remove_missing'></span>

<h3>Description</h3>

<p>Remove all non-complete rows, with a warning if <code>na.rm = FALSE</code>.
ggplot is somewhat more accommodating of missing values than R generally.
For those stats which require complete data, missing values will be
automatically removed with a warning. If <code>na.rm = TRUE</code> is supplied
to the statistic, the warning will be suppressed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_missing(df, na.rm = FALSE, vars = names(df), name = "", finite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_missing_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="remove_missing_+3A_na.rm">na.rm</code></td>
<td>
<p>If true, will suppress warning message.</p>
</td></tr>
<tr><td><code id="remove_missing_+3A_vars">vars</code></td>
<td>
<p>Character vector of variables to check for missings in</p>
</td></tr>
<tr><td><code id="remove_missing_+3A_name">name</code></td>
<td>
<p>Optional function name to improve error message.</p>
</td></tr>
<tr><td><code id="remove_missing_+3A_finite">finite</code></td>
<td>
<p>If <code>TRUE</code>, will also remove non-finite values.</p>
</td></tr>
</table>

<hr>
<h2 id='render_axes'>Render panel axes</h2><span id='topic+render_axes'></span>

<h3>Description</h3>

<p>These helpers facilitates generating theme compliant axes when
building up the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_axes(x = NULL, y = NULL, coord, theme, transpose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_axes_+3A_x">x</code>, <code id="render_axes_+3A_y">y</code></td>
<td>
<p>A list of ranges as available to the draw_panel method in
<code>Facet</code> subclasses.</p>
</td></tr>
<tr><td><code id="render_axes_+3A_coord">coord</code></td>
<td>
<p>A <code>Coord</code> object</p>
</td></tr>
<tr><td><code id="render_axes_+3A_theme">theme</code></td>
<td>
<p>A <code>theme</code> object</p>
</td></tr>
<tr><td><code id="render_axes_+3A_transpose">transpose</code></td>
<td>
<p>Should the output be transposed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the element &quot;x&quot; and &quot;y&quot; each containing axis
specifications for the ranges passed in. Each axis specification is a list
with a &quot;top&quot; and &quot;bottom&quot; element for x-axes and &quot;left&quot; and &quot;right&quot; element
for y-axis, holding the respective axis grobs. Depending on the content of x
and y some of the grobs might be zeroGrobs. If <code>transpose=TRUE</code> the
content of the x and y elements will be transposed so e.g. all left-axes are
collected in a left element as a list of grobs.
</p>

<hr>
<h2 id='render_strips'>Render panel strips</h2><span id='topic+render_strips'></span>

<h3>Description</h3>

<p>All positions are rendered and it is up to the facet to decide which to use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_strips(x = NULL, y = NULL, labeller, theme)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_strips_+3A_x">x</code>, <code id="render_strips_+3A_y">y</code></td>
<td>
<p>A data.frame with a column for each variable and a row for each
combination to draw</p>
</td></tr>
<tr><td><code id="render_strips_+3A_labeller">labeller</code></td>
<td>
<p>A labeller function</p>
</td></tr>
<tr><td><code id="render_strips_+3A_theme">theme</code></td>
<td>
<p>a <code>theme</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an &quot;x&quot; and a &quot;y&quot; element, each containing a &quot;top&quot; and
&quot;bottom&quot; or &quot;left&quot; and &quot;right&quot; element respectively. These contains a list of
rendered strips as gtables.
</p>

<hr>
<h2 id='resolution'>Compute the &quot;resolution&quot; of a numeric vector</h2><span id='topic+resolution'></span>

<h3>Description</h3>

<p>The resolution is the smallest non-zero distance between adjacent
values.  If there is only one unique value, then the resolution is defined
to be one. If x is an integer vector, then it is assumed to represent a
discrete variable, and the resolution is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolution(x, zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolution_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="resolution_+3A_zero">zero</code></td>
<td>
<p>should a zero value be automatically included in the
computation of resolution</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>resolution(1:10)
resolution((1:10) - 0.5)
resolution((1:10) - 0.5, FALSE)

# Note the difference between numeric and integer vectors
resolution(c(2, 10, 20, 50))
resolution(c(2L, 10L, 20L, 50L))
</code></pre>

<hr>
<h2 id='scale_alpha'>Alpha transparency scales</h2><span id='topic+scale_alpha'></span><span id='topic+scale_alpha_continuous'></span><span id='topic+scale_alpha_binned'></span><span id='topic+scale_alpha_discrete'></span><span id='topic+scale_alpha_ordinal'></span><span id='topic+scale_alpha_datetime'></span><span id='topic+scale_alpha_date'></span>

<h3>Description</h3>

<p>Alpha-transparency scales are not tremendously useful, but can be a
convenient way to visually down-weight less important observations.
<code>scale_alpha()</code> is an alias for <code>scale_alpha_continuous()</code> since
that is the most common use of alpha, and it saves a bit of typing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_alpha(name = waiver(), ..., range = c(0.1, 1))

scale_alpha_continuous(name = waiver(), ..., range = c(0.1, 1))

scale_alpha_binned(name = waiver(), ..., range = c(0.1, 1))

scale_alpha_discrete(...)

scale_alpha_ordinal(name = waiver(), ..., range = c(0.1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_alpha_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_alpha_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+continuous_scale">continuous_scale()</a></code>, <code><a href="#topic+binned_scale">binned_scale()</a></code>,
or <code><a href="#topic+discrete_scale">discrete_scale()</a></code> as appropriate, to control name, limits,
breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_alpha_+3A_range">range</code></td>
<td>
<p>Output range of alpha values. Must lie between 0 and 1.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The documentation on <a href="#topic+aes_colour_fill_alpha">colour aesthetics</a>.
</p>
<p>Other alpha scales: <code><a href="#topic+scale_alpha_manual">scale_alpha_manual()</a></code>, <code><a href="#topic+scale_alpha_identity">scale_alpha_identity()</a></code>.
</p>
<p>Other colour scales: 
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a>()</code>,
<code><a href="#topic+scale_colour_continuous">scale_colour_continuous</a>()</code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a>()</code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a>()</code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a>()</code>,
<code><a href="#topic+scale_colour_identity">scale_colour_identity</a>()</code>,
<code><a href="#topic+scale_colour_manual">scale_colour_manual</a>()</code>,
<code><a href="#topic+scale_colour_steps">scale_colour_steps</a>()</code>,
<code><a href="#topic+scale_colour_viridis_d">scale_colour_viridis_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(alpha = year))

p
p + scale_alpha("cylinders")
p + scale_alpha(range = c(0.4, 0.8))
</code></pre>

<hr>
<h2 id='scale_binned'>Positional scales for binning continuous data (x &amp; y)</h2><span id='topic+scale_x_binned'></span><span id='topic+scale_y_binned'></span>

<h3>Description</h3>

<p><code>scale_x_binned()</code> and <code>scale_y_binned()</code> are scales that discretize
continuous position data. You can use these scales to transform continuous
inputs before using it with a geom that requires discrete positions. An
example is using <code>scale_x_binned()</code> with <code><a href="#topic+geom_bar">geom_bar()</a></code> to create a histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_binned(
  name = waiver(),
  n.breaks = 10,
  nice.breaks = TRUE,
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = squish,
  na.value = NA_real_,
  right = TRUE,
  show.limits = FALSE,
  transform = "identity",
  trans = deprecated(),
  guide = waiver(),
  position = "bottom"
)

scale_y_binned(
  name = waiver(),
  n.breaks = 10,
  nice.breaks = TRUE,
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = squish,
  na.value = NA_real_,
  right = TRUE,
  show.limits = FALSE,
  transform = "identity",
  trans = deprecated(),
  guide = waiver(),
  position = "left"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_binned_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_binned_+3A_n.breaks">n.breaks</code></td>
<td>
<p>The number of break points to create if breaks are not given
directly.</p>
</td></tr>
<tr><td><code id="scale_binned_+3A_nice.breaks">nice.breaks</code></td>
<td>
<p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</td></tr>
<tr><td><code id="scale_binned_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_binned_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_binned_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_binned_+3A_expand">expand</code></td>
<td>
<p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</td></tr>
<tr><td><code id="scale_binned_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_binned_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
<tr><td><code id="scale_binned_+3A_right">right</code></td>
<td>
<p>Should the intervals be closed on the right (<code>TRUE</code>, default) or
should the intervals be closed on the left (<code>FALSE</code>)? 'Closed on the right'
means that values at break positions are part of the lower bin (open on the
left), whereas they are part of the upper bin when intervals are closed on
the left (open on the right).</p>
</td></tr>
<tr><td><code id="scale_binned_+3A_show.limits">show.limits</code></td>
<td>
<p>should the limits of the scale appear as ticks</p>
</td></tr>
<tr><td><code id="scale_binned_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_binned_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
<tr><td><code id="scale_binned_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_binned_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The <a href="#topic+aes_position">position documentation</a>.
</p>
<p>Other position scales: 
<code><a href="#topic+scale_x_continuous">scale_x_continuous</a>()</code>,
<code><a href="#topic+scale_x_date">scale_x_date</a>()</code>,
<code><a href="#topic+scale_x_discrete">scale_x_discrete</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a histogram by binning the x-axis
ggplot(mtcars) +
  geom_bar(aes(mpg)) +
  scale_x_binned()
</code></pre>

<hr>
<h2 id='scale_colour_brewer'>Sequential, diverging and qualitative colour scales from ColorBrewer</h2><span id='topic+scale_colour_brewer'></span><span id='topic+scale_fill_brewer'></span><span id='topic+scale_colour_distiller'></span><span id='topic+scale_fill_distiller'></span><span id='topic+scale_colour_fermenter'></span><span id='topic+scale_fill_fermenter'></span><span id='topic+scale_color_brewer'></span><span id='topic+scale_color_distiller'></span><span id='topic+scale_color_fermenter'></span>

<h3>Description</h3>

<p>The <code>brewer</code> scales provide sequential, diverging and qualitative
colour schemes from ColorBrewer. These are particularly well suited to
display discrete values on a map. See <a href="https://colorbrewer2.org">https://colorbrewer2.org</a> for
more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_brewer(
  name = waiver(),
  ...,
  type = "seq",
  palette = 1,
  direction = 1,
  aesthetics = "colour"
)

scale_fill_brewer(
  name = waiver(),
  ...,
  type = "seq",
  palette = 1,
  direction = 1,
  aesthetics = "fill"
)

scale_colour_distiller(
  name = waiver(),
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour"
)

scale_fill_distiller(
  name = waiver(),
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "fill"
)

scale_colour_fermenter(
  name = waiver(),
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  na.value = "grey50",
  guide = "coloursteps",
  aesthetics = "colour"
)

scale_fill_fermenter(
  name = waiver(),
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  na.value = "grey50",
  guide = "coloursteps",
  aesthetics = "fill"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_brewer_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale()</a></code>, <code><a href="#topic+continuous_scale">continuous_scale()</a></code>,
or <code><a href="#topic+binned_scale">binned_scale()</a></code>, for <code>brewer</code>, <code>distiller</code>, and <code>fermenter</code> variants
respectively, to control name, limits, breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_type">type</code></td>
<td>
<p>One of &quot;seq&quot; (sequential), &quot;div&quot; (diverging) or &quot;qual&quot;
(qualitative)</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_palette">palette</code></td>
<td>
<p>If a string, will use that named palette. If a number, will index into
the list of palettes of appropriate <code>type</code>. The list of available palettes can found
in the Palettes section.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colours in the scale. If 1, the default,
colours are as output by <code><a href="RColorBrewer.html#topic+ColorBrewer">RColorBrewer::brewer.pal()</a></code>. If -1, the
order of colours is reversed.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_space">space</code></td>
<td>
<p>colour space in which to calculate gradient. Must be &quot;Lab&quot; -
other values are deprecated.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_guide">guide</code></td>
<td>
<p>Type of legend. Use <code>"colourbar"</code> for continuous
colour bar, or <code>"legend"</code> for discrete colour legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>brewer</code> scales were carefully designed and tested on discrete data.
They were not designed to be extended to continuous data, but results often
look good. Your mileage may vary.
</p>


<h3>Palettes</h3>

<p>The following palettes are available for use with these scales:
</p>

<dl>
<dt>Diverging</dt><dd><p>BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral</p>
</dd>
<dt>Qualitative</dt><dd><p>Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3</p>
</dd>
<dt>Sequential</dt><dd><p>Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges,
OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd</p>
</dd>
</dl>

<p>Modify the palette through the <code>palette</code> argument.
</p>


<h3>Note</h3>

<p>The <code>distiller</code> scales extend <code>brewer</code> scales by smoothly
interpolating 7 colours from any palette to a continuous scale.
The <code>distiller</code> scales have a default direction = -1. To reverse, use direction = 1.
The <code>fermenter</code> scales provide binned versions of the <code>brewer</code> scales.
</p>


<h3>See Also</h3>

<p>The documentation on <a href="#topic+aes_colour_fill_alpha">colour aesthetics</a>.
</p>
<p>Other colour scales: 
<code><a href="#topic+scale_alpha">scale_alpha</a>()</code>,
<code><a href="#topic+scale_colour_continuous">scale_colour_continuous</a>()</code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a>()</code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a>()</code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a>()</code>,
<code><a href="#topic+scale_colour_identity">scale_colour_identity</a>()</code>,
<code><a href="#topic+scale_colour_manual">scale_colour_manual</a>()</code>,
<code><a href="#topic+scale_colour_steps">scale_colour_steps</a>()</code>,
<code><a href="#topic+scale_colour_viridis_d">scale_colour_viridis_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(596)
dsamp &lt;- diamonds[sample(nrow(diamonds), 1000), ]
(d &lt;- ggplot(dsamp, aes(carat, price)) +
  geom_point(aes(colour = clarity)))
d + scale_colour_brewer()

# Change scale label
d + scale_colour_brewer("Diamond\nclarity")

# Select brewer palette to use, see ?scales::pal_brewer for more details
d + scale_colour_brewer(palette = "Greens")
d + scale_colour_brewer(palette = "Set1")


# scale_fill_brewer works just the same as
# scale_colour_brewer but for fill colours
p &lt;- ggplot(diamonds, aes(x = price, fill = cut)) +
  geom_histogram(position = "dodge", binwidth = 1000)
p + scale_fill_brewer()
# the order of colour can be reversed
p + scale_fill_brewer(direction = -1)
# the brewer scales look better on a darker background
p +
  scale_fill_brewer(direction = -1) +
  theme_dark()


# Use distiller variant with continuous data
v &lt;- ggplot(faithfuld) +
  geom_tile(aes(waiting, eruptions, fill = density))
v
v + scale_fill_distiller()
v + scale_fill_distiller(palette = "Spectral")
# the order of colour can be reversed, but with scale_*_distiller(),
# the default direction = -1, so to reverse, use direction = 1.
v + scale_fill_distiller(palette = "Spectral", direction = 1)

# or use blender variants to discretise continuous data
v + scale_fill_fermenter()

</code></pre>

<hr>
<h2 id='scale_colour_continuous'>Continuous and binned colour scales</h2><span id='topic+scale_colour_continuous'></span><span id='topic+scale_fill_continuous'></span><span id='topic+scale_colour_binned'></span><span id='topic+scale_fill_binned'></span><span id='topic+scale_color_continuous'></span><span id='topic+scale_color_binned'></span>

<h3>Description</h3>

<p>The scales <code>scale_colour_continuous()</code> and <code>scale_fill_continuous()</code> are
the default colour scales ggplot2 uses when continuous data values are
mapped onto the <code>colour</code> or <code>fill</code> aesthetics, respectively. The scales
<code>scale_colour_binned()</code> and <code>scale_fill_binned()</code> are equivalent scale
functions that assign discrete color bins to the continuous values
instead of using a continuous color spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_continuous(..., type = getOption("ggplot2.continuous.colour"))

scale_fill_continuous(..., type = getOption("ggplot2.continuous.fill"))

scale_colour_binned(..., type = getOption("ggplot2.binned.colour"))

scale_fill_binned(..., type = getOption("ggplot2.binned.fill"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_continuous_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to the scale type</p>
</td></tr>
<tr><td><code id="scale_colour_continuous_+3A_type">type</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li><p> &quot;gradient&quot; (the default)
</p>
</li>
<li><p> &quot;viridis&quot;
</p>
</li>
<li><p> A function that returns a continuous colour scale.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>All these colour scales use the <code><a href="base.html#topic+options">options()</a></code> mechanism to determine
default settings. Continuous colour scales default to the values of the
<code>ggplot2.continuous.colour</code> and <code>ggplot2.continuous.fill</code> options, and
binned colour scales default to the values of the <code>ggplot2.binned.colour</code>
and <code>ggplot2.binned.fill</code> options. These option values default to
<code>"gradient"</code>, which means that the scale functions actually used are
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient()</a></code>/<code><a href="#topic+scale_fill_gradient">scale_fill_gradient()</a></code> for continuous scales and
<code><a href="#topic+scale_colour_steps">scale_colour_steps()</a></code>/<code><a href="#topic+scale_fill_steps">scale_fill_steps()</a></code> for binned scales.
Alternative option values are <code>"viridis"</code> or a different scale function.
See description of the <code>type</code> argument for details.
</p>
<p>Note that the binned colour scales will use the settings of
<code>ggplot2.continuous.colour</code> and <code>ggplot2.continuous.fill</code> as fallback,
respectively, if <code>ggplot2.binned.colour</code> or <code>ggplot2.binned.fill</code> are
not set.
</p>
<p>These scale functions are meant to provide simple defaults. If
you want to manually set the colors of a scale, consider using
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient()</a></code> or <code><a href="#topic+scale_colour_steps">scale_colour_steps()</a></code>.
</p>


<h3>Color Blindness</h3>

<p>Many color palettes derived from RGB combinations (like the &quot;rainbow&quot; color
palette) are not suitable to support all viewers, especially those with
color vision deficiencies. Using <code>viridis</code> type, which is perceptually
uniform in both colour and black-and-white display is an easy option to
ensure good perceptive properties of your visualizations.
The colorspace package offers functionalities
</p>

<ul>
<li><p> to generate color palettes with good perceptive properties,
</p>
</li>
<li><p> to analyse a given color palette, like emulating color blindness,
</p>
</li>
<li><p> and to modify a given color palette for better perceptivity.
</p>
</li></ul>

<p>For more information on color vision deficiencies and suitable color choices
see the <a href="https://arxiv.org/abs/1903.06490">paper on the colorspace package</a>
and references therein.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_colour_gradient">scale_colour_gradient()</a></code>, <code><a href="#topic+scale_colour_viridis_c">scale_colour_viridis_c()</a></code>,
<code><a href="#topic+scale_colour_steps">scale_colour_steps()</a></code>, <code><a href="#topic+scale_colour_viridis_b">scale_colour_viridis_b()</a></code>, <code><a href="#topic+scale_fill_gradient">scale_fill_gradient()</a></code>,
<code><a href="#topic+scale_fill_viridis_c">scale_fill_viridis_c()</a></code>, <code><a href="#topic+scale_fill_steps">scale_fill_steps()</a></code>, and <code><a href="#topic+scale_fill_viridis_b">scale_fill_viridis_b()</a></code>
</p>
<p>The documentation on <a href="#topic+aes_colour_fill_alpha">colour aesthetics</a>.
</p>
<p>Other colour scales: 
<code><a href="#topic+scale_alpha">scale_alpha</a>()</code>,
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a>()</code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a>()</code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a>()</code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a>()</code>,
<code><a href="#topic+scale_colour_identity">scale_colour_identity</a>()</code>,
<code><a href="#topic+scale_colour_manual">scale_colour_manual</a>()</code>,
<code><a href="#topic+scale_colour_steps">scale_colour_steps</a>()</code>,
<code><a href="#topic+scale_colour_viridis_d">scale_colour_viridis_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) +
geom_tile()
v

v + scale_fill_continuous(type = "gradient")
v + scale_fill_continuous(type = "viridis")

# The above are equivalent to
v + scale_fill_gradient()
v + scale_fill_viridis_c()

# To make a binned version of this plot
v + scale_fill_binned(type = "viridis")

# Set a different default scale using the options
# mechanism
tmp &lt;- getOption("ggplot2.continuous.fill") # store current setting
options(ggplot2.continuous.fill = scale_fill_distiller)
v
options(ggplot2.continuous.fill = tmp) # restore previous setting
</code></pre>

<hr>
<h2 id='scale_colour_discrete'>Discrete colour scales</h2><span id='topic+scale_colour_discrete'></span><span id='topic+scale_fill_discrete'></span><span id='topic+scale_color_discrete'></span>

<h3>Description</h3>

<p>The default discrete colour scale. Defaults to <code><a href="#topic+scale_fill_hue">scale_fill_hue()</a></code>/<code><a href="#topic+scale_fill_brewer">scale_fill_brewer()</a></code>
unless <code>type</code> (which defaults to the <code>ggplot2.discrete.fill</code>/<code>ggplot2.discrete.colour</code> options)
is specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_discrete(..., type = getOption("ggplot2.discrete.colour"))

scale_fill_discrete(..., type = getOption("ggplot2.discrete.fill"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_discrete_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to the scale type,</p>
</td></tr>
<tr><td><code id="scale_colour_discrete_+3A_type">type</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li><p> A character vector of color codes. The codes are used for a 'manual' color
scale as long as the number of codes exceeds the number of data levels
(if there are more levels than codes, <code><a href="#topic+scale_colour_hue">scale_colour_hue()</a></code>/<code><a href="#topic+scale_fill_hue">scale_fill_hue()</a></code>
are used to construct the default scale). If this is a named vector, then the color values
will be matched to levels based on the names of the vectors. Data values that
don't match will be set as <code>na.value</code>.
</p>
</li>
<li><p> A list of character vectors of color codes. The minimum length vector that exceeds the
number of data levels is chosen for the color scaling. This is useful if you
want to change the color palette based on the number of levels.
</p>
</li>
<li><p> A function that returns a discrete colour/fill scale (e.g., <code><a href="#topic+scale_fill_hue">scale_fill_hue()</a></code>,
<code><a href="#topic+scale_fill_brewer">scale_fill_brewer()</a></code>, etc).
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Template function for creating densities grouped by a variable
cty_by_var &lt;- function(var) {
  ggplot(mpg, aes(cty, colour = factor({{var}}), fill = factor({{var}}))) +
    geom_density(alpha = 0.2)
}

# The default, scale_fill_hue(), is not colour-blind safe
cty_by_var(class)

# (Temporarily) set the default to Okabe-Ito (which is colour-blind safe)
okabe &lt;- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
withr::with_options(
  list(ggplot2.discrete.fill = okabe),
  print(cty_by_var(class))
)

# Define a collection of palettes to alter the default based on number of levels to encode
discrete_palettes &lt;- list(
  c("skyblue", "orange"),
  RColorBrewer::brewer.pal(3, "Set2"),
  RColorBrewer::brewer.pal(6, "Accent")
)
withr::with_options(
  list(ggplot2.discrete.fill = discrete_palettes), {
  # 1st palette is used when there 1-2 levels (e.g., year)
  print(cty_by_var(year))
  # 2nd palette is used when there are 3 levels
  print(cty_by_var(drv))
  # 3rd palette is used when there are 4-6 levels
  print(cty_by_var(fl))
})

</code></pre>

<hr>
<h2 id='scale_colour_gradient'>Gradient colour scales</h2><span id='topic+scale_colour_gradient'></span><span id='topic+scale_fill_gradient'></span><span id='topic+scale_colour_gradient2'></span><span id='topic+scale_fill_gradient2'></span><span id='topic+scale_colour_gradientn'></span><span id='topic+scale_fill_gradientn'></span><span id='topic+scale_colour_datetime'></span><span id='topic+scale_color_datetime'></span><span id='topic+scale_colour_date'></span><span id='topic+scale_color_date'></span><span id='topic+scale_fill_datetime'></span><span id='topic+scale_fill_date'></span><span id='topic+scale_color_gradient'></span><span id='topic+scale_color_gradient2'></span><span id='topic+scale_color_gradientn'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;scale_*_gradient&#8288;</code> creates a two colour gradient (low-high),
<code style="white-space: pre;">&#8288;scale_*_gradient2&#8288;</code> creates a diverging colour gradient (low-mid-high),
<code style="white-space: pre;">&#8288;scale_*_gradientn&#8288;</code> creates a n-colour gradient. For binned variants of
these scales, see the <a href="#topic+scale_colour_steps">color steps</a> scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_gradient(
  name = waiver(),
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour"
)

scale_fill_gradient(
  name = waiver(),
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "fill"
)

scale_colour_gradient2(
  name = waiver(),
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  transform = "identity",
  guide = "colourbar",
  aesthetics = "colour"
)

scale_fill_gradient2(
  name = waiver(),
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  transform = "identity",
  guide = "colourbar",
  aesthetics = "fill"
)

scale_colour_gradientn(
  name = waiver(),
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour",
  colors
)

scale_fill_gradientn(
  name = waiver(),
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "fill",
  colors
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_gradient_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+continuous_scale">continuous_scale</a></code>
</p>

<dl>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a numeric vector with
values between 0 and 1 returns the corresponding output values
(e.g., <code><a href="scales.html#topic+pal_area">scales::pal_area()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</dd>
<dt><code>rescaler</code></dt><dd><p>A function used to scale the input values to the
range [0, 1]. This is always <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>, except for
diverging and n colour gradients (i.e., <code><a href="#topic+scale_colour_gradient2">scale_colour_gradient2()</a></code>,
<code><a href="#topic+scale_colour_gradientn">scale_colour_gradientn()</a></code>). The <code>rescaler</code> is ignored by position
scales, which always use <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>. Also accepts rlang
<a href="rlang.html#topic+as_function">lambda</a> function notation.</p>
</dd>
<dt><code>oob</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</dd>
<dt><code>trans</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_low">low</code>, <code id="scale_colour_gradient_+3A_high">high</code></td>
<td>
<p>Colours for low and high ends of the gradient.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_space">space</code></td>
<td>
<p>colour space in which to calculate gradient. Must be &quot;Lab&quot; -
other values are deprecated.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_guide">guide</code></td>
<td>
<p>Type of legend. Use <code>"colourbar"</code> for continuous
colour bar, or <code>"legend"</code> for discrete colour legend.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_mid">mid</code></td>
<td>
<p>colour for mid point</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_midpoint">midpoint</code></td>
<td>
<p>The midpoint (in data value) of the diverging scale.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_colours">colours</code>, <code id="scale_colour_gradient_+3A_colors">colors</code></td>
<td>
<p>Vector of colours to use for n-colour gradient.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default colours are generated with <span class="pkg">munsell</span> and
<code>mnsl(c("2.5PB 2/4", "2.5PB 7/10"))</code>. Generally, for continuous
colour scales you want to keep hue constant, but vary chroma and
luminance. The <span class="pkg">munsell</span> package makes this easy to do using the
Munsell colour system.
</p>


<h3>See Also</h3>

<p><code><a href="scales.html#topic+pal_seq_gradient">scales::pal_seq_gradient()</a></code> for details on underlying
palette, <code><a href="#topic+scale_colour_steps">scale_colour_steps()</a></code> for binned variants of these scales.
</p>
<p>The documentation on <a href="#topic+aes_colour_fill_alpha">colour aesthetics</a>.
</p>
<p>Other colour scales: 
<code><a href="#topic+scale_alpha">scale_alpha</a>()</code>,
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a>()</code>,
<code><a href="#topic+scale_colour_continuous">scale_colour_continuous</a>()</code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a>()</code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a>()</code>,
<code><a href="#topic+scale_colour_identity">scale_colour_identity</a>()</code>,
<code><a href="#topic+scale_colour_manual">scale_colour_manual</a>()</code>,
<code><a href="#topic+scale_colour_steps">scale_colour_steps</a>()</code>,
<code><a href="#topic+scale_colour_viridis_d">scale_colour_viridis_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
df &lt;- data.frame(
  x = runif(100),
  y = runif(100),
  z1 = rnorm(100),
  z2 = abs(rnorm(100))
)

df_na &lt;- data.frame(
  value = seq(1, 20),
  x = runif(20),
  y = runif(20),
  z1 = c(rep(NA, 10), rnorm(10))
)

# Default colour scale colours from light blue to dark blue
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z2))

# For diverging colour scales use gradient2
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z1)) +
  scale_colour_gradient2()

# Use your own colour scale with gradientn
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z1)) +
  scale_colour_gradientn(colours = terrain.colors(10))

# Equivalent fill scales do the same job for the fill aesthetic
ggplot(faithfuld, aes(waiting, eruptions)) +
  geom_raster(aes(fill = density)) +
  scale_fill_gradientn(colours = terrain.colors(10))

# Adjust colour choices with low and high
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z2)) +
  scale_colour_gradient(low = "white", high = "black")
# Avoid red-green colour contrasts because ~10% of men have difficulty
# seeing them

# Use `na.value = NA` to hide missing values but keep the original axis range
ggplot(df_na, aes(x = value, y)) +
  geom_bar(aes(fill = z1), stat = "identity") +
  scale_fill_gradient(low = "yellow", high = "red", na.value = NA)

 ggplot(df_na, aes(x, y)) +
   geom_point(aes(colour = z1)) +
   scale_colour_gradient(low = "yellow", high = "red", na.value = NA)

</code></pre>

<hr>
<h2 id='scale_colour_grey'>Sequential grey colour scales</h2><span id='topic+scale_colour_grey'></span><span id='topic+scale_fill_grey'></span><span id='topic+scale_color_grey'></span>

<h3>Description</h3>

<p>Based on <code><a href="grDevices.html#topic+gray.colors">gray.colors()</a></code>. This is black and white equivalent
of <code><a href="#topic+scale_colour_gradient">scale_colour_gradient()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_grey(
  name = waiver(),
  ...,
  start = 0.2,
  end = 0.8,
  na.value = "red",
  aesthetics = "colour"
)

scale_fill_grey(
  name = waiver(),
  ...,
  start = 0.2,
  end = 0.8,
  na.value = "red",
  aesthetics = "fill"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_grey_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_colour_grey_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code>
</p>

<dl>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>guide</code></dt><dd><p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_colour_grey_+3A_start">start</code></td>
<td>
<p>grey value at low end of palette</p>
</td></tr>
<tr><td><code id="scale_colour_grey_+3A_end">end</code></td>
<td>
<p>grey value at high end of palette</p>
</td></tr>
<tr><td><code id="scale_colour_grey_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="scale_colour_grey_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The documentation on <a href="#topic+aes_colour_fill_alpha">colour aesthetics</a>.
</p>
<p>Other colour scales: 
<code><a href="#topic+scale_alpha">scale_alpha</a>()</code>,
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a>()</code>,
<code><a href="#topic+scale_colour_continuous">scale_colour_continuous</a>()</code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a>()</code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a>()</code>,
<code><a href="#topic+scale_colour_identity">scale_colour_identity</a>()</code>,
<code><a href="#topic+scale_colour_manual">scale_colour_manual</a>()</code>,
<code><a href="#topic+scale_colour_steps">scale_colour_steps</a>()</code>,
<code><a href="#topic+scale_colour_viridis_d">scale_colour_viridis_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) + geom_point(aes(colour = factor(cyl)))
p + scale_colour_grey()
p + scale_colour_grey(end = 0)

# You may want to turn off the pale grey background with this scale
p + scale_colour_grey() + theme_bw()

# Colour of missing values is controlled with na.value:
miss &lt;- factor(sample(c(NA, 1:5), nrow(mtcars), replace = TRUE))
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = miss)) +
  scale_colour_grey()
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = miss)) +
  scale_colour_grey(na.value = "green")
</code></pre>

<hr>
<h2 id='scale_colour_hue'>Evenly spaced colours for discrete data</h2><span id='topic+scale_colour_hue'></span><span id='topic+scale_fill_hue'></span><span id='topic+scale_color_hue'></span>

<h3>Description</h3>

<p>Maps each level to an evenly spaced hue on the colour wheel.
It does not generate colour-blind safe palettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_hue(
  name = waiver(),
  ...,
  h = c(0, 360) + 15,
  c = 100,
  l = 65,
  h.start = 0,
  direction = 1,
  na.value = "grey50",
  aesthetics = "colour"
)

scale_fill_hue(
  name = waiver(),
  ...,
  h = c(0, 360) + 15,
  c = 100,
  l = 65,
  h.start = 0,
  direction = 1,
  na.value = "grey50",
  aesthetics = "fill"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_hue_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code>
</p>

<dl>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>guide</code></dt><dd><p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_h">h</code></td>
<td>
<p>range of hues to use, in [0, 360]</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_c">c</code></td>
<td>
<p>chroma (intensity of colour), maximum value varies depending on
combination of hue and luminance.</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_l">l</code></td>
<td>
<p>luminance (lightness), in [0, 100]</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_h.start">h.start</code></td>
<td>
<p>hue to start at</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_direction">direction</code></td>
<td>
<p>direction to travel around the colour wheel,
1 = clockwise, -1 = counter-clockwise</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The documentation on <a href="#topic+aes_colour_fill_alpha">colour aesthetics</a>.
</p>
<p>Other colour scales: 
<code><a href="#topic+scale_alpha">scale_alpha</a>()</code>,
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a>()</code>,
<code><a href="#topic+scale_colour_continuous">scale_colour_continuous</a>()</code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a>()</code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a>()</code>,
<code><a href="#topic+scale_colour_identity">scale_colour_identity</a>()</code>,
<code><a href="#topic+scale_colour_manual">scale_colour_manual</a>()</code>,
<code><a href="#topic+scale_colour_steps">scale_colour_steps</a>()</code>,
<code><a href="#topic+scale_colour_viridis_d">scale_colour_viridis_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(596)
dsamp &lt;- diamonds[sample(nrow(diamonds), 1000), ]
(d &lt;- ggplot(dsamp, aes(carat, price)) + geom_point(aes(colour = clarity)))

# Change scale label
d + scale_colour_hue()
d + scale_colour_hue("clarity")
d + scale_colour_hue(expression(clarity[beta]))

# Adjust luminosity and chroma
d + scale_colour_hue(l = 40, c = 30)
d + scale_colour_hue(l = 70, c = 30)
d + scale_colour_hue(l = 70, c = 150)
d + scale_colour_hue(l = 80, c = 150)

# Change range of hues used
d + scale_colour_hue(h = c(0, 90))
d + scale_colour_hue(h = c(90, 180))
d + scale_colour_hue(h = c(180, 270))
d + scale_colour_hue(h = c(270, 360))

# Vary opacity
# (only works with pdf, quartz and cairo devices)
d &lt;- ggplot(dsamp, aes(carat, price, colour = clarity))
d + geom_point(alpha = 0.9)
d + geom_point(alpha = 0.5)
d + geom_point(alpha = 0.2)

# Colour of missing values is controlled with na.value:
miss &lt;- factor(sample(c(NA, 1:5), nrow(mtcars), replace = TRUE))
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = miss))
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = miss)) +
  scale_colour_hue(na.value = "black")

</code></pre>

<hr>
<h2 id='scale_colour_steps'>Binned gradient colour scales</h2><span id='topic+scale_colour_steps'></span><span id='topic+scale_colour_steps2'></span><span id='topic+scale_colour_stepsn'></span><span id='topic+scale_fill_steps'></span><span id='topic+scale_fill_steps2'></span><span id='topic+scale_fill_stepsn'></span><span id='topic+scale_color_steps'></span><span id='topic+scale_color_steps2'></span><span id='topic+scale_color_stepsn'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;scale_*_steps&#8288;</code> creates a two colour binned gradient (low-high),
<code style="white-space: pre;">&#8288;scale_*_steps2&#8288;</code> creates a diverging binned colour gradient (low-mid-high),
and <code style="white-space: pre;">&#8288;scale_*_stepsn&#8288;</code> creates a n-colour binned gradient. These scales are
binned variants of the <a href="#topic+scale_colour_gradient">gradient scale</a> family and
works in the same way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_steps(
  name = waiver(),
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "coloursteps",
  aesthetics = "colour"
)

scale_colour_steps2(
  name = waiver(),
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  transform = "identity",
  guide = "coloursteps",
  aesthetics = "colour"
)

scale_colour_stepsn(
  name = waiver(),
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "coloursteps",
  aesthetics = "colour",
  colors
)

scale_fill_steps(
  name = waiver(),
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "coloursteps",
  aesthetics = "fill"
)

scale_fill_steps2(
  name = waiver(),
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  transform = "identity",
  guide = "coloursteps",
  aesthetics = "fill"
)

scale_fill_stepsn(
  name = waiver(),
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "coloursteps",
  aesthetics = "fill",
  colors
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_steps_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+binned_scale">binned_scale</a></code>
</p>

<dl>
<dt><code>n.breaks</code></dt><dd><p>The number of break points to create if breaks are not given
directly.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
<dt><code>right</code></dt><dd><p>Should the intervals be closed on the right (<code>TRUE</code>, default) or
should the intervals be closed on the left (<code>FALSE</code>)? 'Closed on the right'
means that values at break positions are part of the lower bin (open on the
left), whereas they are part of the upper bin when intervals are closed on
the left (open on the right).</p>
</dd>
<dt><code>show.limits</code></dt><dd><p>should the limits of the scale appear as ticks</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</dd>
<dt><code>oob</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</dd>
<dt><code>trans</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_low">low</code>, <code id="scale_colour_steps_+3A_high">high</code></td>
<td>
<p>Colours for low and high ends of the gradient.</p>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_space">space</code></td>
<td>
<p>colour space in which to calculate gradient. Must be &quot;Lab&quot; -
other values are deprecated.</p>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_guide">guide</code></td>
<td>
<p>Type of legend. Use <code>"colourbar"</code> for continuous
colour bar, or <code>"legend"</code> for discrete colour legend.</p>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_mid">mid</code></td>
<td>
<p>colour for mid point</p>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_midpoint">midpoint</code></td>
<td>
<p>The midpoint (in data value) of the diverging scale.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_colours">colours</code>, <code id="scale_colour_steps_+3A_colors">colors</code></td>
<td>
<p>Vector of colours to use for n-colour gradient.</p>
</td></tr>
<tr><td><code id="scale_colour_steps_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default colours are generated with <span class="pkg">munsell</span> and
<code>mnsl(c("2.5PB 2/4", "2.5PB 7/10"))</code>. Generally, for continuous
colour scales you want to keep hue constant, but vary chroma and
luminance. The <span class="pkg">munsell</span> package makes this easy to do using the
Munsell colour system.
</p>


<h3>See Also</h3>

<p><code><a href="scales.html#topic+pal_seq_gradient">scales::pal_seq_gradient()</a></code> for details on underlying
palette, <code><a href="#topic+scale_colour_gradient">scale_colour_gradient()</a></code> for continuous scales without binning.
</p>
<p>The documentation on <a href="#topic+aes_colour_fill_alpha">colour aesthetics</a>.
</p>
<p>Other colour scales: 
<code><a href="#topic+scale_alpha">scale_alpha</a>()</code>,
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a>()</code>,
<code><a href="#topic+scale_colour_continuous">scale_colour_continuous</a>()</code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a>()</code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a>()</code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a>()</code>,
<code><a href="#topic+scale_colour_identity">scale_colour_identity</a>()</code>,
<code><a href="#topic+scale_colour_manual">scale_colour_manual</a>()</code>,
<code><a href="#topic+scale_colour_viridis_d">scale_colour_viridis_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
df &lt;- data.frame(
  x = runif(100),
  y = runif(100),
  z1 = rnorm(100)
)

# Use scale_colour_steps for a standard binned gradient
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z1)) +
  scale_colour_steps()

# Get a divergent binned scale with the *2 variant
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z1)) +
  scale_colour_steps2()

# Define your own colour ramp to extract binned colours from
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z1)) +
  scale_colour_stepsn(colours = terrain.colors(10))
</code></pre>

<hr>
<h2 id='scale_colour_viridis_d'>Viridis colour scales from viridisLite</h2><span id='topic+scale_colour_viridis_d'></span><span id='topic+scale_fill_viridis_d'></span><span id='topic+scale_colour_viridis_c'></span><span id='topic+scale_fill_viridis_c'></span><span id='topic+scale_colour_viridis_b'></span><span id='topic+scale_fill_viridis_b'></span><span id='topic+scale_colour_ordinal'></span><span id='topic+scale_color_ordinal'></span><span id='topic+scale_fill_ordinal'></span><span id='topic+scale_color_viridis_d'></span><span id='topic+scale_color_viridis_c'></span><span id='topic+scale_color_viridis_b'></span>

<h3>Description</h3>

<p>The <code>viridis</code> scales provide colour maps that are perceptually uniform in both
colour and black-and-white. They are also designed to be perceived by viewers
with common forms of colour blindness. See also
<a href="https://bids.github.io/colormap/">https://bids.github.io/colormap/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_viridis_d(
  name = waiver(),
  ...,
  alpha = 1,
  begin = 0,
  end = 1,
  direction = 1,
  option = "D",
  aesthetics = "colour"
)

scale_fill_viridis_d(
  name = waiver(),
  ...,
  alpha = 1,
  begin = 0,
  end = 1,
  direction = 1,
  option = "D",
  aesthetics = "fill"
)

scale_colour_viridis_c(
  name = waiver(),
  ...,
  alpha = 1,
  begin = 0,
  end = 1,
  direction = 1,
  option = "D",
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "colour"
)

scale_fill_viridis_c(
  name = waiver(),
  ...,
  alpha = 1,
  begin = 0,
  end = 1,
  direction = 1,
  option = "D",
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  aesthetics = "fill"
)

scale_colour_viridis_b(
  name = waiver(),
  ...,
  alpha = 1,
  begin = 0,
  end = 1,
  direction = 1,
  option = "D",
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "coloursteps",
  aesthetics = "colour"
)

scale_fill_viridis_b(
  name = waiver(),
  ...,
  alpha = 1,
  begin = 0,
  end = 1,
  direction = 1,
  option = "D",
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "coloursteps",
  aesthetics = "fill"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_viridis_d_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_colour_viridis_d_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale()</a></code>,
<code><a href="#topic+continuous_scale">continuous_scale()</a></code>, or <code><a href="#topic+binned_scale">binned_scale()</a></code> to control name, limits, breaks,
labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_colour_viridis_d_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_colour_viridis_d_+3A_begin">begin</code>, <code id="scale_colour_viridis_d_+3A_end">end</code></td>
<td>
<p>The (corrected) hue in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> at which the color map
begins and ends.</p>
</td></tr>
<tr><td><code id="scale_colour_viridis_d_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_colour_viridis_d_+3A_option">option</code></td>
<td>
<p>A character string indicating the color map option to use.
Eight options are available:
</p>

<ul>
<li> <p><code>"magma"</code> (or <code>"A"</code>)
</p>
</li>
<li> <p><code>"inferno"</code> (or <code>"B"</code>)
</p>
</li>
<li> <p><code>"plasma"</code> (or <code>"C"</code>)
</p>
</li>
<li> <p><code>"viridis"</code> (or <code>"D"</code>)
</p>
</li>
<li> <p><code>"cividis"</code> (or <code>"E"</code>)
</p>
</li>
<li> <p><code>"rocket"</code> (or <code>"F"</code>)
</p>
</li>
<li> <p><code>"mako"</code> (or <code>"G"</code>)
</p>
</li>
<li> <p><code>"turbo"</code> (or <code>"H"</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_colour_viridis_d_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
<tr><td><code id="scale_colour_viridis_d_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_colour_viridis_d_+3A_space">space</code></td>
<td>
<p>colour space in which to calculate gradient. Must be &quot;Lab&quot; -
other values are deprecated.</p>
</td></tr>
<tr><td><code id="scale_colour_viridis_d_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
<tr><td><code id="scale_colour_viridis_d_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The documentation on <a href="#topic+aes_colour_fill_alpha">colour aesthetics</a>.
</p>
<p>Other colour scales: 
<code><a href="#topic+scale_alpha">scale_alpha</a>()</code>,
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a>()</code>,
<code><a href="#topic+scale_colour_continuous">scale_colour_continuous</a>()</code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a>()</code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a>()</code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a>()</code>,
<code><a href="#topic+scale_colour_identity">scale_colour_identity</a>()</code>,
<code><a href="#topic+scale_colour_manual">scale_colour_manual</a>()</code>,
<code><a href="#topic+scale_colour_steps">scale_colour_steps</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># viridis is the default colour/fill scale for ordered factors
set.seed(596)
dsamp &lt;- diamonds[sample(nrow(diamonds), 1000), ]
ggplot(dsamp, aes(carat, price)) +
  geom_point(aes(colour = clarity))

# Use viridis_d with discrete data
txsamp &lt;- subset(txhousing, city %in%
  c("Houston", "Fort Worth", "San Antonio", "Dallas", "Austin"))
(d &lt;- ggplot(data = txsamp, aes(x = sales, y = median)) +
   geom_point(aes(colour = city)))
d + scale_colour_viridis_d()

# Change scale label
d + scale_colour_viridis_d("City\nCenter")

# Select palette to use, see ?scales::pal_viridis for more details
d + scale_colour_viridis_d(option = "plasma")
d + scale_colour_viridis_d(option = "inferno")

# scale_fill_viridis_d works just the same as
# scale_colour_viridis_d but for fill colours
p &lt;- ggplot(txsamp, aes(x = median, fill = city)) +
  geom_histogram(position = "dodge", binwidth = 15000)
p + scale_fill_viridis_d()
# the order of colour can be reversed
p + scale_fill_viridis_d(direction = -1)

# Use viridis_c with continuous data
(v &lt;- ggplot(faithfuld) +
  geom_tile(aes(waiting, eruptions, fill = density)))
v + scale_fill_viridis_c()
v + scale_fill_viridis_c(option = "plasma")

# Use viridis_b to bin continuous data before mapping
v + scale_fill_viridis_b()

</code></pre>

<hr>
<h2 id='scale_continuous'>Position scales for continuous data (x &amp; y)</h2><span id='topic+scale_x_continuous'></span><span id='topic+scale_y_continuous'></span><span id='topic+scale_x_log10'></span><span id='topic+scale_y_log10'></span><span id='topic+scale_x_reverse'></span><span id='topic+scale_y_reverse'></span><span id='topic+scale_x_sqrt'></span><span id='topic+scale_y_sqrt'></span>

<h3>Description</h3>

<p><code>scale_x_continuous()</code> and <code>scale_y_continuous()</code> are the default
scales for continuous x and y aesthetics. There are three variants
that set the <code>transform</code> argument for commonly used transformations:
<code style="white-space: pre;">&#8288;scale_*_log10()&#8288;</code>, <code style="white-space: pre;">&#8288;scale_*_sqrt()&#8288;</code> and <code style="white-space: pre;">&#8288;scale_*_reverse()&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_continuous(
  name = waiver(),
  breaks = waiver(),
  minor_breaks = waiver(),
  n.breaks = NULL,
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = censor,
  na.value = NA_real_,
  transform = "identity",
  trans = deprecated(),
  guide = waiver(),
  position = "bottom",
  sec.axis = waiver()
)

scale_y_continuous(
  name = waiver(),
  breaks = waiver(),
  minor_breaks = waiver(),
  n.breaks = NULL,
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = censor,
  na.value = NA_real_,
  transform = "identity",
  trans = deprecated(),
  guide = waiver(),
  position = "left",
  sec.axis = waiver()
)

scale_x_log10(...)

scale_y_log10(...)

scale_x_reverse(...)

scale_y_reverse(...)

scale_x_sqrt(...)

scale_y_sqrt(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_continuous_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_continuous_+3A_minor_breaks">minor_breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_continuous_+3A_n.breaks">n.breaks</code></td>
<td>
<p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_continuous_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_continuous_+3A_expand">expand</code></td>
<td>
<p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_continuous_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_sec.axis">sec.axis</code></td>
<td>
<p><code><a href="#topic+sec_axis">sec_axis()</a></code> is used to specify a secondary axis.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code style="white-space: pre;">&#8288;scale_(x|y)_continuous()&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simple manipulation of labels and limits, you may wish to use
<code><a href="#topic+labs">labs()</a></code> and <code><a href="#topic+lims">lims()</a></code> instead.
</p>


<h3>See Also</h3>

<p>The <a href="#topic+aes_position">position documentation</a>.
</p>
<p>Other position scales: 
<code><a href="#topic+scale_x_binned">scale_x_binned</a>()</code>,
<code><a href="#topic+scale_x_date">scale_x_date</a>()</code>,
<code><a href="#topic+scale_x_discrete">scale_x_discrete</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- ggplot(mpg, aes(displ, hwy)) +
  geom_point()
p1

# Manipulating the default position scales lets you:
#  * change the axis labels
p1 +
  scale_x_continuous("Engine displacement (L)") +
  scale_y_continuous("Highway MPG")

# You can also use the short-cut labs().
# Use NULL to suppress axis labels
p1 + labs(x = NULL, y = NULL)

#  * modify the axis limits
p1 + scale_x_continuous(limits = c(2, 6))
p1 + scale_x_continuous(limits = c(0, 10))

# you can also use the short hand functions `xlim()` and `ylim()`
p1 + xlim(2, 6)

#  * choose where the ticks appear
p1 + scale_x_continuous(breaks = c(2, 4, 6))

#  * choose your own labels
p1 + scale_x_continuous(
  breaks = c(2, 4, 6),
  label = c("two", "four", "six")
)

# Typically you'll pass a function to the `labels` argument.
# Some common formats are built into the scales package:
set.seed(1)
df &lt;- data.frame(
  x = rnorm(10) * 100000,
  y = seq(0, 1, length.out = 10)
)
p2 &lt;- ggplot(df, aes(x, y)) + geom_point()
p2 + scale_y_continuous(labels = scales::label_percent())
p2 + scale_y_continuous(labels = scales::label_dollar())
p2 + scale_x_continuous(labels = scales::label_comma())

# You can also override the default linear mapping by using a
# transformation. There are three shortcuts:
p1 + scale_y_log10()
p1 + scale_y_sqrt()
p1 + scale_y_reverse()

# Or you can supply a transformation in the `trans` argument:
p1 + scale_y_continuous(transform = scales::transform_reciprocal())

# You can also create your own. See ?scales::new_transform

</code></pre>

<hr>
<h2 id='scale_date'>Position scales for date/time data</h2><span id='topic+scale_x_date'></span><span id='topic+scale_y_date'></span><span id='topic+scale_x_datetime'></span><span id='topic+scale_y_datetime'></span><span id='topic+scale_x_time'></span><span id='topic+scale_y_time'></span>

<h3>Description</h3>

<p>These are the default scales for the three date/time class. These will
usually be added automatically. To override manually, use
<code style="white-space: pre;">&#8288;scale_*_date&#8288;</code> for dates (class <code>Date</code>),
<code style="white-space: pre;">&#8288;scale_*_datetime&#8288;</code> for datetimes (class <code>POSIXct</code>), and
<code style="white-space: pre;">&#8288;scale_*_time&#8288;</code> for times (class <code>hms</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_date(
  name = waiver(),
  breaks = waiver(),
  date_breaks = waiver(),
  labels = waiver(),
  date_labels = waiver(),
  minor_breaks = waiver(),
  date_minor_breaks = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = censor,
  guide = waiver(),
  position = "bottom",
  sec.axis = waiver()
)

scale_y_date(
  name = waiver(),
  breaks = waiver(),
  date_breaks = waiver(),
  labels = waiver(),
  date_labels = waiver(),
  minor_breaks = waiver(),
  date_minor_breaks = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = censor,
  guide = waiver(),
  position = "left",
  sec.axis = waiver()
)

scale_x_datetime(
  name = waiver(),
  breaks = waiver(),
  date_breaks = waiver(),
  labels = waiver(),
  date_labels = waiver(),
  minor_breaks = waiver(),
  date_minor_breaks = waiver(),
  timezone = NULL,
  limits = NULL,
  expand = waiver(),
  oob = censor,
  guide = waiver(),
  position = "bottom",
  sec.axis = waiver()
)

scale_y_datetime(
  name = waiver(),
  breaks = waiver(),
  date_breaks = waiver(),
  labels = waiver(),
  date_labels = waiver(),
  minor_breaks = waiver(),
  date_minor_breaks = waiver(),
  timezone = NULL,
  limits = NULL,
  expand = waiver(),
  oob = censor,
  guide = waiver(),
  position = "left",
  sec.axis = waiver()
)

scale_x_time(
  name = waiver(),
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = censor,
  na.value = NA_real_,
  guide = waiver(),
  position = "bottom",
  sec.axis = waiver()
)

scale_y_time(
  name = waiver(),
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = censor,
  na.value = NA_real_,
  guide = waiver(),
  position = "left",
  sec.axis = waiver()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_date_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the breaks specified by <code>date_breaks</code>
</p>
</li>
<li><p> A <code>Date</code>/<code>POSIXct</code> vector giving positions of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_date_+3A_date_breaks">date_breaks</code></td>
<td>
<p>A string giving the distance between breaks like &quot;2
weeks&quot;, or &quot;10 years&quot;. If both <code>breaks</code> and <code>date_breaks</code> are
specified, <code>date_breaks</code> wins. Valid specifications are 'sec', 'min',
'hour', 'day', 'week', 'month' or 'year', optionally followed by 's'.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_date_+3A_date_labels">date_labels</code></td>
<td>
<p>A string giving the formatting specification for the
labels. Codes are defined in <code><a href="base.html#topic+strftime">strftime()</a></code>. If both <code>labels</code>
and <code>date_labels</code> are specified, <code>date_labels</code> wins.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_minor_breaks">minor_breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the breaks specified by <code>date_minor_breaks</code>
</p>
</li>
<li><p> A <code>Date</code>/<code>POSIXct</code> vector giving positions of minor breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns minor breaks as
output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_date_+3A_date_minor_breaks">date_minor_breaks</code></td>
<td>
<p>A string giving the distance between minor breaks
like &quot;2 weeks&quot;, or &quot;10 years&quot;. If both <code>minor_breaks</code> and
<code>date_minor_breaks</code> are specified, <code>date_minor_breaks</code> wins. Valid
specifications are 'sec', 'min', 'hour', 'day', 'week', 'month' or 'year',
optionally followed by 's'.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_date_+3A_expand">expand</code></td>
<td>
<p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_date_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_sec.axis">sec.axis</code></td>
<td>
<p><code><a href="#topic+sec_axis">sec_axis()</a></code> is used to specify a secondary axis.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_timezone">timezone</code></td>
<td>
<p>The timezone to use for display on the axes. The default
(<code>NULL</code>) uses the timezone encoded in the data.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sec_axis">sec_axis()</a></code> for how to specify secondary axes
</p>
<p>The <a href="#topic+aes_position">position documentation</a>.
</p>
<p>Other position scales: 
<code><a href="#topic+scale_x_binned">scale_x_binned</a>()</code>,
<code><a href="#topic+scale_x_continuous">scale_x_continuous</a>()</code>,
<code><a href="#topic+scale_x_discrete">scale_x_discrete</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>last_month &lt;- Sys.Date() - 0:29
set.seed(1)
df &lt;- data.frame(
  date = last_month,
  price = runif(30)
)
base &lt;- ggplot(df, aes(date, price)) +
  geom_line()

# The date scale will attempt to pick sensible defaults for
# major and minor tick marks. Override with date_breaks, date_labels
# date_minor_breaks arguments.
base + scale_x_date(date_labels = "%b %d")
base + scale_x_date(date_breaks = "1 week", date_labels = "%W")
base + scale_x_date(date_minor_breaks = "1 day")

# Set limits
base + scale_x_date(limits = c(Sys.Date() - 7, NA))

</code></pre>

<hr>
<h2 id='scale_identity'>Use values without scaling</h2><span id='topic+scale_colour_identity'></span><span id='topic+scale_fill_identity'></span><span id='topic+scale_shape_identity'></span><span id='topic+scale_linetype_identity'></span><span id='topic+scale_linewidth_identity'></span><span id='topic+scale_alpha_identity'></span><span id='topic+scale_size_identity'></span><span id='topic+scale_discrete_identity'></span><span id='topic+scale_continuous_identity'></span><span id='topic+scale_color_identity'></span>

<h3>Description</h3>

<p>Use this set of scales when your data has already been scaled, i.e. it
already represents aesthetic values that ggplot2 can handle directly.
These scales will not produce a legend unless you also supply the <code>breaks</code>,
<code>labels</code>, and type of <code>guide</code> you want.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_identity(
  name = waiver(),
  ...,
  guide = "none",
  aesthetics = "colour"
)

scale_fill_identity(name = waiver(), ..., guide = "none", aesthetics = "fill")

scale_shape_identity(name = waiver(), ..., guide = "none")

scale_linetype_identity(name = waiver(), ..., guide = "none")

scale_linewidth_identity(name = waiver(), ..., guide = "none")

scale_alpha_identity(name = waiver(), ..., guide = "none")

scale_size_identity(name = waiver(), ..., guide = "none")

scale_discrete_identity(aesthetics, name = waiver(), ..., guide = "none")

scale_continuous_identity(aesthetics, name = waiver(), ..., guide = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_identity_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_identity_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale()</a></code> or
<code><a href="#topic+continuous_scale">continuous_scale()</a></code></p>
</td></tr>
<tr><td><code id="scale_identity_+3A_guide">guide</code></td>
<td>
<p>Guide to use for this scale. Defaults to <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="scale_identity_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>scale_colour_identity()</code>, <code>scale_fill_identity()</code>, <code>scale_size_identity()</code>,
etc. work on the aesthetics specified in the scale name: <code>colour</code>, <code>fill</code>, <code>size</code>,
etc. However, the functions <code>scale_colour_identity()</code> and <code>scale_fill_identity()</code> also
have an optional <code>aesthetics</code> argument that can be used to define both <code>colour</code> and
<code>fill</code> aesthetic mappings via a single function call. The functions
<code>scale_discrete_identity()</code> and <code>scale_continuous_identity()</code> are generic scales that
can work with any aesthetic or set of aesthetics provided via the <code>aesthetics</code>
argument.
</p>


<h3>See Also</h3>

<p>Other shape scales: <code><a href="#topic+scale_shape">scale_shape()</a></code>, <code><a href="#topic+scale_shape_manual">scale_shape_manual()</a></code>.
</p>
<p>Other linetype scales: <code><a href="#topic+scale_linetype">scale_linetype()</a></code>, <code><a href="#topic+scale_linetype_manual">scale_linetype_manual()</a></code>.
</p>
<p>Other alpha scales: <code><a href="#topic+scale_alpha">scale_alpha()</a></code>, <code><a href="#topic+scale_alpha_manual">scale_alpha_manual()</a></code>.
</p>
<p>Other size scales: <code><a href="#topic+scale_size">scale_size()</a></code>, <code><a href="#topic+scale_size_manual">scale_size_manual()</a></code>.
</p>
<p>Other colour scales: 
<code><a href="#topic+scale_alpha">scale_alpha</a>()</code>,
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a>()</code>,
<code><a href="#topic+scale_colour_continuous">scale_colour_continuous</a>()</code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a>()</code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a>()</code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a>()</code>,
<code><a href="#topic+scale_colour_manual">scale_colour_manual</a>()</code>,
<code><a href="#topic+scale_colour_steps">scale_colour_steps</a>()</code>,
<code><a href="#topic+scale_colour_viridis_d">scale_colour_viridis_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(luv_colours, aes(u, v)) +
  geom_point(aes(colour = col), size = 3) +
  scale_color_identity() +
  coord_fixed()

df &lt;- data.frame(
  x = 1:4,
  y = 1:4,
  colour = c("red", "green", "blue", "yellow")
)
ggplot(df, aes(x, y)) + geom_tile(aes(fill = colour))
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = colour)) +
  scale_fill_identity()

# To get a legend guide, specify guide = "legend"
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = colour)) +
  scale_fill_identity(guide = "legend")
# But you'll typically also need to supply breaks and labels:
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = colour)) +
  scale_fill_identity("trt", labels = letters[1:4], breaks = df$colour,
  guide = "legend")

# cyl scaled to appropriate size
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(size = cyl))

# cyl used as point size
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(size = cyl)) +
  scale_size_identity()
</code></pre>

<hr>
<h2 id='scale_linetype'>Scale for line patterns</h2><span id='topic+scale_linetype'></span><span id='topic+scale_linetype_binned'></span><span id='topic+scale_linetype_continuous'></span><span id='topic+scale_linetype_discrete'></span>

<h3>Description</h3>

<p>Default line types based on a set supplied by Richard Pearson,
University of Manchester. Continuous values can not be mapped to
line types unless <code>scale_linetype_binned()</code> is used. Still, as linetypes has
no inherent order, this use is not advised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_linetype(name = waiver(), ..., na.value = "blank")

scale_linetype_binned(name = waiver(), ..., na.value = "blank")

scale_linetype_continuous(...)

scale_linetype_discrete(name = waiver(), ..., na.value = "blank")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_linetype_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_linetype_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code>
</p>

<dl>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>aesthetics</code></dt><dd><p>The names of the aesthetics that this scale works with.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>guide</code></dt><dd><p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_linetype_+3A_na.value">na.value</code></td>
<td>
<p>The linetype to use for <code>NA</code> values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The documentation for <a href="#topic+aes_linetype_size_shape">differentiation related aesthetics</a>.
</p>
<p>Other linetype scales: <code><a href="#topic+scale_linetype_manual">scale_linetype_manual()</a></code>, <code><a href="#topic+scale_linetype_identity">scale_linetype_identity()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>base &lt;- ggplot(economics_long, aes(date, value01))
base + geom_line(aes(group = variable))
base + geom_line(aes(linetype = variable))

# See scale_manual for more flexibility

# Common line types ----------------------------
df_lines &lt;- data.frame(
  linetype = factor(
    1:4,
    labels = c("solid", "longdash", "dashed", "dotted")
  )
)
ggplot(df_lines) +
  geom_hline(aes(linetype = linetype, yintercept = 0), linewidth = 2) +
  scale_linetype_identity() +
  facet_grid(linetype ~ .) +
  theme_void(20)
</code></pre>

<hr>
<h2 id='scale_linewidth'>Scales for line width</h2><span id='topic+scale_linewidth'></span><span id='topic+scale_linewidth_continuous'></span><span id='topic+scale_linewidth_binned'></span><span id='topic+scale_linewidth_discrete'></span><span id='topic+scale_linewidth_ordinal'></span><span id='topic+scale_linewidth_datetime'></span><span id='topic+scale_linewidth_date'></span>

<h3>Description</h3>

<p><code>scale_linewidth</code> scales the width of lines and polygon strokes. Due to
historical reasons, it is also possible to control this with the <code>size</code>
aesthetic, but using <code>linewidth</code> is encourage to clearly differentiate area
aesthetics from stroke width aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_linewidth(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  transform = "identity",
  trans = deprecated(),
  guide = "legend"
)

scale_linewidth_binned(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  n.breaks = NULL,
  nice.breaks = TRUE,
  transform = "identity",
  trans = deprecated(),
  guide = "bins"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_linewidth_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_linewidth_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_linewidth_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_linewidth_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_linewidth_+3A_range">range</code></td>
<td>
<p>a numeric vector of length 2 that specifies the minimum and
maximum size of the plotting symbol after transformation.</p>
</td></tr>
<tr><td><code id="scale_linewidth_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_linewidth_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
<tr><td><code id="scale_linewidth_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_linewidth_+3A_n.breaks">n.breaks</code></td>
<td>
<p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</td></tr>
<tr><td><code id="scale_linewidth_+3A_nice.breaks">nice.breaks</code></td>
<td>
<p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The documentation for <a href="#topic+aes_linetype_size_shape">differentiation related aesthetics</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(economics, aes(date, unemploy, linewidth = uempmed)) +
  geom_line(lineend = "round")
p
p + scale_linewidth("Duration of\nunemployment")
p + scale_linewidth(range = c(0, 4))

# Binning can sometimes make it easier to match the scaled data to the legend
p + scale_linewidth_binned()

</code></pre>

<hr>
<h2 id='scale_manual'>Create your own discrete scale</h2><span id='topic+scale_colour_manual'></span><span id='topic+scale_fill_manual'></span><span id='topic+scale_size_manual'></span><span id='topic+scale_shape_manual'></span><span id='topic+scale_linetype_manual'></span><span id='topic+scale_linewidth_manual'></span><span id='topic+scale_alpha_manual'></span><span id='topic+scale_discrete_manual'></span><span id='topic+scale_color_manual'></span>

<h3>Description</h3>

<p>These functions allow you to specify your own set of mappings from levels in the
data to aesthetic values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_manual(
  ...,
  values,
  aesthetics = "colour",
  breaks = waiver(),
  na.value = "grey50"
)

scale_fill_manual(
  ...,
  values,
  aesthetics = "fill",
  breaks = waiver(),
  na.value = "grey50"
)

scale_size_manual(..., values, breaks = waiver(), na.value = NA)

scale_shape_manual(..., values, breaks = waiver(), na.value = NA)

scale_linetype_manual(..., values, breaks = waiver(), na.value = "blank")

scale_linewidth_manual(..., values, breaks = waiver(), na.value = NA)

scale_alpha_manual(..., values, breaks = waiver(), na.value = NA)

scale_discrete_manual(aesthetics, ..., values, breaks = waiver())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_manual_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code>
</p>

<dl>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>guide</code></dt><dd><p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_manual_+3A_values">values</code></td>
<td>
<p>a set of aesthetic values to map data values to. The values
will be matched in order (usually alphabetical) with the limits of the
scale, or with <code>breaks</code> if provided. If this is a named vector, then the
values will be matched based on the names instead. Data values that don't
match will be given <code>na.value</code>.</p>
</td></tr>
<tr><td><code id="scale_manual_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful, for
example, to apply colour settings to the <code>colour</code> and <code>fill</code> aesthetics at the
same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
<tr><td><code id="scale_manual_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_manual_+3A_na.value">na.value</code></td>
<td>
<p>The aesthetic value to use for missing (<code>NA</code>) values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>scale_colour_manual()</code>, <code>scale_fill_manual()</code>, <code>scale_size_manual()</code>,
etc. work on the aesthetics specified in the scale name: <code>colour</code>, <code>fill</code>, <code>size</code>,
etc. However, the functions <code>scale_colour_manual()</code> and <code>scale_fill_manual()</code> also
have an optional <code>aesthetics</code> argument that can be used to define both <code>colour</code> and
<code>fill</code> aesthetic mappings via a single function call (see examples). The function
<code>scale_discrete_manual()</code> is a generic scale that can work with any aesthetic or set
of aesthetics provided via the <code>aesthetics</code> argument.
</p>


<h3>Color Blindness</h3>

<p>Many color palettes derived from RGB combinations (like the &quot;rainbow&quot; color
palette) are not suitable to support all viewers, especially those with
color vision deficiencies. Using <code>viridis</code> type, which is perceptually
uniform in both colour and black-and-white display is an easy option to
ensure good perceptive properties of your visualizations.
The colorspace package offers functionalities
</p>

<ul>
<li><p> to generate color palettes with good perceptive properties,
</p>
</li>
<li><p> to analyse a given color palette, like emulating color blindness,
</p>
</li>
<li><p> and to modify a given color palette for better perceptivity.
</p>
</li></ul>

<p>For more information on color vision deficiencies and suitable color choices
see the <a href="https://arxiv.org/abs/1903.06490">paper on the colorspace package</a>
and references therein.
</p>


<h3>See Also</h3>

<p>The documentation for <a href="#topic+aes_linetype_size_shape">differentiation related aesthetics</a>.
</p>
<p>The documentation on <a href="#topic+aes_colour_fill_alpha">colour aesthetics</a>.
</p>
<p>Other size scales: <code><a href="#topic+scale_size">scale_size()</a></code>, <code><a href="#topic+scale_size_identity">scale_size_identity()</a></code>.
</p>
<p>Other shape scales: <code><a href="#topic+scale_shape">scale_shape()</a></code>, <code><a href="#topic+scale_shape_identity">scale_shape_identity()</a></code>.
</p>
<p>Other linetype scales: <code><a href="#topic+scale_linetype">scale_linetype()</a></code>, <code><a href="#topic+scale_linetype_identity">scale_linetype_identity()</a></code>.
</p>
<p>Other alpha scales: <code><a href="#topic+scale_alpha">scale_alpha()</a></code>, <code><a href="#topic+scale_alpha_identity">scale_alpha_identity()</a></code>.
</p>
<p>Other colour scales: 
<code><a href="#topic+scale_alpha">scale_alpha</a>()</code>,
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a>()</code>,
<code><a href="#topic+scale_colour_continuous">scale_colour_continuous</a>()</code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a>()</code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a>()</code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a>()</code>,
<code><a href="#topic+scale_colour_identity">scale_colour_identity</a>()</code>,
<code><a href="#topic+scale_colour_steps">scale_colour_steps</a>()</code>,
<code><a href="#topic+scale_colour_viridis_d">scale_colour_viridis_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = factor(cyl)))
p + scale_colour_manual(values = c("red", "blue", "green"))

# It's recommended to use a named vector
cols &lt;- c("8" = "red", "4" = "blue", "6" = "darkgreen", "10" = "orange")
p + scale_colour_manual(values = cols)

# You can set color and fill aesthetics at the same time
ggplot(
  mtcars,
  aes(mpg, wt, colour = factor(cyl), fill = factor(cyl))
) +
  geom_point(shape = 21, alpha = 0.5, size = 2) +
  scale_colour_manual(
    values = cols,
    aesthetics = c("colour", "fill")
  )

# As with other scales you can use breaks to control the appearance
# of the legend.
p + scale_colour_manual(values = cols)
p + scale_colour_manual(
  values = cols,
  breaks = c("4", "6", "8"),
  labels = c("four", "six", "eight")
)

# And limits to control the possible values of the scale
p + scale_colour_manual(values = cols, limits = c("4", "8"))
p + scale_colour_manual(values = cols, limits = c("4", "6", "8", "10"))
</code></pre>

<hr>
<h2 id='scale_shape'>Scales for shapes, aka glyphs</h2><span id='topic+scale_shape'></span><span id='topic+scale_shape_binned'></span><span id='topic+scale_shape_discrete'></span><span id='topic+scale_shape_ordinal'></span><span id='topic+scale_shape_continuous'></span>

<h3>Description</h3>

<p><code>scale_shape()</code> maps discrete variables to six easily discernible shapes.
If you have more than six levels, you will get a warning message, and the
seventh and subsequent levels will not appear on the plot. Use
<code><a href="#topic+scale_shape_manual">scale_shape_manual()</a></code> to supply your own values. You can not map
a continuous variable to shape unless <code>scale_shape_binned()</code> is used. Still,
as shape has no inherent order, this use is not advised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_shape(name = waiver(), ..., solid = TRUE)

scale_shape_binned(name = waiver(), ..., solid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_shape_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_shape_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code>
</p>

<dl>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>na.value</code></dt><dd><p>If <code>na.translate = TRUE</code>, what aesthetic value should the
missing values be displayed as? Does not apply to position scales
where <code>NA</code> is always placed at the far right.</p>
</dd>
<dt><code>aesthetics</code></dt><dd><p>The names of the aesthetics that this scale works with.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>guide</code></dt><dd><p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_shape_+3A_solid">solid</code></td>
<td>
<p>Should the shapes be solid, <code>TRUE</code>, or hollow,
<code>FALSE</code>?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The documentation for <a href="#topic+aes_linetype_size_shape">differentiation related aesthetics</a>.
</p>
<p>Other shape scales: <code><a href="#topic+scale_shape_manual">scale_shape_manual()</a></code>, <code><a href="#topic+scale_shape_identity">scale_shape_identity()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(596)
dsmall &lt;- diamonds[sample(nrow(diamonds), 100), ]

(d &lt;- ggplot(dsmall, aes(carat, price)) + geom_point(aes(shape = cut)))
d + scale_shape(solid = TRUE) # the default
d + scale_shape(solid = FALSE)
d + scale_shape(name = "Cut of diamond")

# To change order of levels, change order of
# underlying factor
levels(dsmall$cut) &lt;- c("Fair", "Good", "Very Good", "Premium", "Ideal")

# Need to recreate plot to pick up new data
ggplot(dsmall, aes(price, carat)) + geom_point(aes(shape = cut))

# Show a list of available shapes
df_shapes &lt;- data.frame(shape = 0:24)
ggplot(df_shapes, aes(0, 0, shape = shape)) +
  geom_point(aes(shape = shape), size = 5, fill = 'red') +
  scale_shape_identity() +
  facet_wrap(~shape) +
  theme_void()
</code></pre>

<hr>
<h2 id='scale_size'>Scales for area or radius</h2><span id='topic+scale_size'></span><span id='topic+scale_size_continuous'></span><span id='topic+scale_radius'></span><span id='topic+scale_size_binned'></span><span id='topic+scale_size_discrete'></span><span id='topic+scale_size_ordinal'></span><span id='topic+scale_size_area'></span><span id='topic+scale_size_binned_area'></span><span id='topic+scale_size_datetime'></span><span id='topic+scale_size_date'></span>

<h3>Description</h3>

<p><code>scale_size()</code> scales area, <code>scale_radius()</code> scales radius. The size
aesthetic is most commonly used for points and text, and humans perceive
the area of points (not their radius), so this provides for optimal
perception. <code>scale_size_area()</code> ensures that a value of 0 is mapped
to a size of 0. <code>scale_size_binned()</code> is a binned version of <code>scale_size()</code> that
scales by area (but does not ensure 0 equals an area of zero). For a binned
equivalent of <code>scale_size_area()</code> use <code>scale_size_binned_area()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_size(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  transform = "identity",
  trans = deprecated(),
  guide = "legend"
)

scale_radius(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  transform = "identity",
  trans = deprecated(),
  guide = "legend"
)

scale_size_binned(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  n.breaks = NULL,
  nice.breaks = TRUE,
  transform = "identity",
  trans = deprecated(),
  guide = "bins"
)

scale_size_area(name = waiver(), ..., max_size = 6)

scale_size_binned_area(name = waiver(), ..., max_size = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_size_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_size_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_size_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_size_+3A_range">range</code></td>
<td>
<p>a numeric vector of length 2 that specifies the minimum and
maximum size of the plotting symbol after transformation.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_n.breaks">n.breaks</code></td>
<td>
<p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_nice.breaks">nice.breaks</code></td>
<td>
<p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+continuous_scale">continuous_scale</a></code>
</p>

<dl>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>oob</code></dt><dd><p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</dd>
<dt><code>na.value</code></dt><dd><p>Missing values will be replaced with this value.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_size_+3A_max_size">max_size</code></td>
<td>
<p>Size of largest points.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Historically the size aesthetic was used for two different things:
Scaling the size of object (like points and glyphs) and scaling the width
of lines. From ggplot2 3.4.0 the latter has been moved to its own linewidth
aesthetic. For backwards compatibility using size is still possible, but it
is highly advised to switch to the new linewidth aesthetic for these cases.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_size_area">scale_size_area()</a></code> if you want 0 values to be mapped
to points with size 0. <code><a href="#topic+scale_linewidth">scale_linewidth()</a></code> if you want to scale the width
of lines.
</p>
<p>The documentation for <a href="#topic+aes_linetype_size_shape">differentiation related aesthetics</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mpg, aes(displ, hwy, size = hwy)) +
   geom_point()
p
p + scale_size("Highway mpg")
p + scale_size(range = c(0, 10))

# If you want zero value to have zero size, use scale_size_area:
p + scale_size_area()

# Binning can sometimes make it easier to match the scaled data to the legend
p + scale_size_binned()

# This is most useful when size is a count
ggplot(mpg, aes(class, cyl)) +
  geom_count() +
  scale_size_area()

# If you want to map size to radius (usually bad idea), use scale_radius
p + scale_radius()
</code></pre>

<hr>
<h2 id='scale_type'>Determine default scale type</h2><span id='topic+scale_type'></span>

<h3>Description</h3>

<p>You will need to define a method for this method if you want to extend
ggplot2 to handle new types of data. If you simply want to pass the vector
through as an additional aesthetic, return <code>"identity"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_type_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of scale types. These will be tried in turn
to find a default scale. For example, if <code>scale_type()</code> returns
<code>c("foo", "bar")</code> and the vector is used with the colour aesthetic,
ggplot2 will first look for <code>scale_colour_foo</code> then
<code>scale_colour_bar</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scale_type(1:5)
scale_type("test")
scale_type(Sys.Date())
</code></pre>

<hr>
<h2 id='scale_x_discrete'>Position scales for discrete data</h2><span id='topic+scale_x_discrete'></span><span id='topic+scale_y_discrete'></span>

<h3>Description</h3>

<p><code>scale_x_discrete()</code> and <code>scale_y_discrete()</code> are used to set the values for
discrete x and y scale aesthetics. For simple manipulation of scale labels
and limits, you may wish to use <code><a href="#topic+labs">labs()</a></code> and <code><a href="#topic+lims">lims()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_discrete(
  name = waiver(),
  ...,
  expand = waiver(),
  guide = waiver(),
  position = "bottom"
)

scale_y_discrete(
  name = waiver(),
  ...,
  expand = waiver(),
  guide = waiver(),
  position = "left"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_discrete_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_x_discrete_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code>
</p>

<dl>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>na.value</code></dt><dd><p>If <code>na.translate = TRUE</code>, what aesthetic value should the
missing values be displayed as? Does not apply to position scales
where <code>NA</code> is always placed at the far right.</p>
</dd>
<dt><code>aesthetics</code></dt><dd><p>The names of the aesthetics that this scale works with.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_x_discrete_+3A_expand">expand</code></td>
<td>
<p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</td></tr>
<tr><td><code id="scale_x_discrete_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_x_discrete_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can use continuous positions even with a discrete position scale -
this allows you (e.g.) to place labels between bars in a bar chart.
Continuous positions are numeric values starting at one for the first
level, and increasing by one for each level (i.e. the labels are placed
at integer positions).  This is what allows jittering to work.
</p>


<h3>See Also</h3>

<p>The <a href="#topic+aes_position">position documentation</a>.
</p>
<p>Other position scales: 
<code><a href="#topic+scale_x_binned">scale_x_binned</a>()</code>,
<code><a href="#topic+scale_x_continuous">scale_x_continuous</a>()</code>,
<code><a href="#topic+scale_x_date">scale_x_date</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(diamonds, aes(cut)) + geom_bar()


# The discrete position scale is added automatically whenever you
# have a discrete position.

(d &lt;- ggplot(subset(diamonds, carat &gt; 1), aes(cut, clarity)) +
      geom_jitter())

d + scale_x_discrete("Cut")
d +
  scale_x_discrete(
    "Cut",
    labels = c(
      "Fair" = "F",
      "Good" = "G",
      "Very Good" = "VG",
      "Perfect" = "P",
      "Ideal" = "I"
    )
  )

# Use limits to adjust the which levels (and in what order)
# are displayed
d + scale_x_discrete(limits = c("Fair","Ideal"))

# you can also use the short hand functions xlim and ylim
d + xlim("Fair","Ideal", "Good")
d + ylim("I1", "IF")

# See ?reorder to reorder based on the values of another variable
ggplot(mpg, aes(manufacturer, cty)) +
  geom_point()
ggplot(mpg, aes(reorder(manufacturer, cty), cty)) +
  geom_point()
ggplot(mpg, aes(reorder(manufacturer, displ), cty)) +
  geom_point()

# Use abbreviate as a formatter to reduce long names
ggplot(mpg, aes(reorder(manufacturer, displ), cty)) +
  geom_point() +
  scale_x_discrete(labels = abbreviate)

</code></pre>

<hr>
<h2 id='seals'>Vector field of seal movements</h2><span id='topic+seals'></span>

<h3>Description</h3>

<p>This vector field was produced from the data described in Brillinger, D.R.,
Preisler, H.K., Ager, A.A. and Kie, J.G. &quot;An exploratory data analysis
(EDA) of the paths of moving animals&quot;. J. Statistical Planning and
Inference 122 (2004), 43-63, using the methods of Brillinger, D.R.,
&quot;Learning a potential function from a trajectory&quot;, Signal Processing
Letters. December (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seals
</code></pre>


<h3>Format</h3>

<p>A data frame with 1155 rows and 4 variables
</p>


<h3>References</h3>

<p><a href="https://www.stat.berkeley.edu/~brill/Papers/jspifinal.pdf">https://www.stat.berkeley.edu/~brill/Papers/jspifinal.pdf</a>
</p>

<hr>
<h2 id='sec_axis'>Specify a secondary axis</h2><span id='topic+sec_axis'></span><span id='topic+dup_axis'></span><span id='topic+derive'></span>

<h3>Description</h3>

<p>This function is used in conjunction with a position scale to create a
secondary axis, positioned opposite of the primary axis. All secondary
axes must be based on a one-to-one transformation of the primary axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sec_axis(
  transform = NULL,
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  guide = waiver(),
  trans = deprecated()
)

dup_axis(
  transform = ~.,
  name = derive(),
  breaks = derive(),
  labels = derive(),
  guide = derive(),
  trans = deprecated()
)

derive()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sec_axis_+3A_transform">transform</code></td>
<td>
<p>A formula or function of transformation</p>
</td></tr>
<tr><td><code id="sec_axis_+3A_name">name</code></td>
<td>
<p>The name of the secondary axis</p>
</td></tr>
<tr><td><code id="sec_axis_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the transformation object
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="sec_axis_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="sec_axis_+3A_guide">guide</code></td>
<td>
<p>A position guide that will be used to render
the axis on the plot. Usually this is <code><a href="#topic+guide_axis">guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="sec_axis_+3A_trans">trans</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sec_axis()</code> is used to create the specifications for a secondary axis.
Except for the <code>trans</code> argument any of the arguments can be set to
<code>derive()</code> which would result in the secondary axis inheriting the
settings from the primary axis.
</p>
<p><code>dup_axis()</code> is provide as a shorthand for creating a secondary axis that
is a duplication of the primary axis, effectively mirroring the primary axis.
</p>
<p>As of v3.1, date and datetime scales have limited secondary axis capabilities.
Unlike other continuous scales, secondary axis transformations for date and datetime scales
must respect their primary POSIX data structure.
This means they may only be transformed via addition or subtraction, e.g.
<code>~ . + hms::hms(days = 8)</code>, or
<code>~ . - 8*60*60</code>. Nonlinear transformations will return an error.
To produce a time-since-event secondary axis in this context, users
may consider adapting secondary axis labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(cyl, mpg)) +
  geom_point()

# Create a simple secondary axis
p + scale_y_continuous(sec.axis = sec_axis(~ . + 10))

# Inherit the name from the primary axis
p + scale_y_continuous("Miles/gallon", sec.axis = sec_axis(~ . + 10, name = derive()))

# Duplicate the primary axis
p + scale_y_continuous(sec.axis = dup_axis())

# You can pass in a formula as a shorthand
p + scale_y_continuous(sec.axis = ~ .^2)

# Secondary axes work for date and datetime scales too:
df &lt;- data.frame(
  dx = seq(
    as.POSIXct("2012-02-29 12:00:00", tz = "UTC"),
    length.out = 10,
    by = "4 hour"
  ),
  price = seq(20, 200000, length.out = 10)
 )

# This may useful for labelling different time scales in the same plot
ggplot(df, aes(x = dx, y = price)) +
  geom_line() +
  scale_x_datetime(
    "Date",
    date_labels = "%b %d",
    date_breaks = "6 hour",
    sec.axis = dup_axis(
      name = "Time of Day",
      labels = scales::label_time("%I %p")
    )
  )

# or to transform axes for different timezones
ggplot(df, aes(x = dx, y = price)) +
  geom_line() +
  scale_x_datetime("
    GMT",
    date_labels = "%b %d %I %p",
    sec.axis = sec_axis(
      ~ . + 8 * 3600,
      name = "GMT+8",
      labels = scales::label_time("%b %d %I %p")
    )
  )

</code></pre>

<hr>
<h2 id='set_last_plot'>Set the last plot to be fetched by lastplot()</h2><span id='topic+set_last_plot'></span>

<h3>Description</h3>

<p>Set the last plot to be fetched by lastplot()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_last_plot(value)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+last_plot">last_plot()</a></code>
</p>

<hr>
<h2 id='sf_transform_xy'>Transform spatial position data</h2><span id='topic+sf_transform_xy'></span>

<h3>Description</h3>

<p>Helper function that can transform spatial position data (pairs of x, y
values) among coordinate systems. This is implemented as a thin wrapper
around <code><a href="sf.html#topic+sf_project">sf::sf_project()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_transform_xy(data, target_crs, source_crs, authority_compliant = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_transform_xy_+3A_data">data</code></td>
<td>
<p>Data frame or list containing numerical columns <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="sf_transform_xy_+3A_target_crs">target_crs</code>, <code id="sf_transform_xy_+3A_source_crs">source_crs</code></td>
<td>
<p>Target and source coordinate reference systems.
If <code>NULL</code> or <code>NA</code>, the data is not transformed.</p>
</td></tr>
<tr><td><code id="sf_transform_xy_+3A_authority_compliant">authority_compliant</code></td>
<td>
<p>logical; <code>TRUE</code> means handle axis order authority
compliant (e.g. EPSG:4326 implying <code>x = lat</code>, <code>y = lon</code>), <code>FALSE</code> means use
visualisation order (i.e. always <code>x = lon</code>, <code>y = lat</code>). Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of the input data with <code>x</code> and <code>y</code> replaced by transformed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("sf", quietly = TRUE)) {
# location of cities in NC by long (x) and lat (y)
data &lt;- data.frame(
  city = c("Charlotte", "Raleigh", "Greensboro"),
  x =  c(-80.843, -78.639, -79.792),
  y = c(35.227, 35.772, 36.073)
)

# transform to projected coordinates
data_proj &lt;- sf_transform_xy(data, 3347, 4326)
data_proj

# transform back
sf_transform_xy(data_proj, 4326, 3347)
}
</code></pre>

<hr>
<h2 id='should_stop'>Used in examples to illustrate when errors should occur.</h2><span id='topic+should_stop'></span>

<h3>Description</h3>

<p>Used in examples to illustrate when errors should occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>should_stop(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="should_stop_+3A_expr">expr</code></td>
<td>
<p>code to evaluate.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>should_stop(stop("Hi!"))
should_stop(should_stop("Hi!"))
</code></pre>

<hr>
<h2 id='standardise_aes_names'>Standardise aesthetic names</h2><span id='topic+standardise_aes_names'></span>

<h3>Description</h3>

<p>This function standardises aesthetic names by converting <code>color</code> to <code>colour</code>
(also in substrings, e.g. <code>point_color</code> to <code>point_colour</code>) and translating old style
R names to ggplot names (eg. <code>pch</code> to <code>shape</code>, <code>cex</code> to <code>size</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardise_aes_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardise_aes_names_+3A_x">x</code></td>
<td>
<p>Character vector of aesthetics names, such as <code>c("colour", "size", "shape")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of standardised names.
</p>

<hr>
<h2 id='stat_ecdf'>Compute empirical cumulative distribution</h2><span id='topic+stat_ecdf'></span>

<h3>Description</h3>

<p>The empirical cumulative distribution function (ECDF) provides an alternative
visualisation of distribution. Compared to other visualisations that rely on
density (like <code><a href="#topic+geom_histogram">geom_histogram()</a></code>), the ECDF doesn't require any
tuning parameters and handles both continuous and categorical variables.
The downside is that it requires more training to accurately interpret,
and the underlying visual tasks are somewhat more challenging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_ecdf(
  mapping = NULL,
  data = NULL,
  geom = "step",
  position = "identity",
  ...,
  n = NULL,
  pad = TRUE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_ecdf_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_n">n</code></td>
<td>
<p>if NULL, do not interpolate. If not NULL, this is the number
of points to interpolate with.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_pad">pad</code></td>
<td>
<p>If <code>TRUE</code>, pad the ecdf with additional points (-Inf, 0)
and (Inf, 1)</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic relies on the aesthetics assignment to guess which variable to
use as the input and which to use as the output. Either x or y must be provided
and one of them must be unused. The ECDF will be calculated on the given aesthetic
and will be output on the unused one.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(ecdf)</code><br /> Cumulative density corresponding to <code>x</code>.
</p>
</li>
<li> <p><code>after_stat(y)</code><br /> <a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a> For backward compatibility.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
df &lt;- data.frame(
  x = c(rnorm(100, 0, 3), rnorm(100, 0, 10)),
  g = gl(2, 100)
)
ggplot(df, aes(x)) +
  stat_ecdf(geom = "step")

# Don't go to positive/negative infinity
ggplot(df, aes(x)) +
  stat_ecdf(geom = "step", pad = FALSE)

# Multiple ECDFs
ggplot(df, aes(x, colour = g)) +
  stat_ecdf()
</code></pre>

<hr>
<h2 id='stat_ellipse'>Compute normal data ellipses</h2><span id='topic+stat_ellipse'></span>

<h3>Description</h3>

<p>The method for calculating the ellipses has been modified from
<code>car::dataEllipse</code> (Fox and Weisberg 2011, Friendly and Monette 2013)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_ellipse(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  ...,
  type = "t",
  level = 0.95,
  segments = 51,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_ellipse_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_type">type</code></td>
<td>
<p>The type of ellipse.
The default <code>"t"</code> assumes a multivariate t-distribution, and
<code>"norm"</code> assumes a multivariate normal distribution.
<code>"euclid"</code> draws a circle with the radius equal to <code>level</code>,
representing the euclidean distance from the center.
This ellipse probably won't appear circular unless <code>coord_fixed()</code> is applied.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_level">level</code></td>
<td>
<p>The level at which to draw an ellipse,
or, if <code>type="euclid"</code>, the radius of the circle to be drawn.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_segments">segments</code></td>
<td>
<p>The number of segments to be used in drawing the ellipse.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>John Fox and Sanford Weisberg (2011). An <span class="rlang"><b>R</b></span> Companion to
Applied Regression, Second Edition. Thousand Oaks CA: Sage. URL:
<a href="https://socialsciences.mcmaster.ca/jfox/Books/Companion/">https://socialsciences.mcmaster.ca/jfox/Books/Companion/</a>
</p>
<p>Michael Friendly. Georges Monette. John Fox. &quot;Elliptical Insights: Understanding Statistical Methods through Elliptical Geometry.&quot;
Statist. Sci. 28 (1) 1 - 39, February 2013. URL: <a href="https://projecteuclid.org/journals/statistical-science/volume-28/issue-1/Elliptical-Insights-Understanding-Statistical-Methods-through-Elliptical-Geometry/10.1214/12-STS402.full">https://projecteuclid.org/journals/statistical-science/volume-28/issue-1/Elliptical-Insights-Understanding-Statistical-Methods-through-Elliptical-Geometry/10.1214/12-STS402.full</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(faithful, aes(waiting, eruptions)) +
  geom_point() +
  stat_ellipse()

ggplot(faithful, aes(waiting, eruptions, color = eruptions &gt; 3)) +
  geom_point() +
  stat_ellipse()

ggplot(faithful, aes(waiting, eruptions, color = eruptions &gt; 3)) +
  geom_point() +
  stat_ellipse(type = "norm", linetype = 2) +
  stat_ellipse(type = "t")

ggplot(faithful, aes(waiting, eruptions, color = eruptions &gt; 3)) +
  geom_point() +
  stat_ellipse(type = "norm", linetype = 2) +
  stat_ellipse(type = "euclid", level = 3) +
  coord_fixed()

ggplot(faithful, aes(waiting, eruptions, fill = eruptions &gt; 3)) +
  stat_ellipse(geom = "polygon")
</code></pre>

<hr>
<h2 id='stat_identity'>Leave data as is</h2><span id='topic+stat_identity'></span>

<h3>Description</h3>

<p>The identity statistic leaves the data unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_identity(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_identity_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg))
p + stat_identity()
</code></pre>

<hr>
<h2 id='stat_sf_coordinates'>Extract coordinates from 'sf' objects</h2><span id='topic+stat_sf_coordinates'></span><span id='topic+StatSfCoordinates'></span>

<h3>Description</h3>

<p><code>stat_sf_coordinates()</code> extracts the coordinates from 'sf' objects and
summarises them to one pair of coordinates (x and y) per geometry. This is
convenient when you draw an sf object as geoms like text and labels (so
<code><a href="#topic+geom_sf_text">geom_sf_text()</a></code> and <code><a href="#topic+geom_sf_label">geom_sf_label()</a></code> relies on this).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_sf_coordinates(
  mapping = aes(),
  data = NULL,
  geom = "point",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  fun.geometry = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_sf_coordinates_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_sf_coordinates_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_sf_coordinates_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_sf_coordinates_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_sf_coordinates_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_sf_coordinates_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_sf_coordinates_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_sf_coordinates_+3A_fun.geometry">fun.geometry</code></td>
<td>
<p>A function that takes a <code>sfc</code> object and returns a <code>sfc_POINT</code> with the
same length as the input. If <code>NULL</code>, <code>function(x) sf::st_point_on_surface(sf::st_zm(x))</code>
will be used. Note that the function may warn about the incorrectness of
the result if the data is not projected, but you can ignore this except
when you really care about the exact locations.</p>
</td></tr>
<tr><td><code id="stat_sf_coordinates_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>coordinates of an <code>sf</code> object can be retrieved by <code>sf::st_coordinates()</code>.
But, we cannot simply use <code>sf::st_coordinates()</code> because, whereas text and
labels require exactly one coordinate per geometry, it returns multiple ones
for a polygon or a line. Thus, these two steps are needed:
</p>

<ol>
<li><p> Choose one point per geometry by some function like <code>sf::st_centroid()</code>
or <code>sf::st_point_on_surface()</code>.
</p>
</li>
<li><p> Retrieve coordinates from the points by <code>sf::st_coordinates()</code>.
</p>
</li></ol>

<p>For the first step, you can use an arbitrary function via <code>fun.geometry</code>.
By default, <code>function(x) sf::st_point_on_surface(sf::st_zm(x))</code> is used;
<code>sf::st_point_on_surface()</code> seems more appropriate than <code>sf::st_centroid()</code>
since labels and text usually are intended to be put within the polygon or
the line. <code>sf::st_zm()</code> is needed to drop Z and M dimension beforehand,
otherwise <code>sf::st_point_on_surface()</code> may fail when the geometries have M
dimension.
</p>


<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(x)</code><br /> X dimension of the simple feature.
</p>
</li>
<li> <p><code>after_stat(y)</code><br /> Y dimension of the simple feature.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("sf", quietly = TRUE)) {
nc &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"))

ggplot(nc) +
  stat_sf_coordinates()

ggplot(nc) +
  geom_errorbarh(
    aes(geometry = geometry,
        xmin = after_stat(x) - 0.1,
        xmax = after_stat(x) + 0.1,
        y = after_stat(y),
        height = 0.04),
    stat = "sf_coordinates"
  )
}

</code></pre>

<hr>
<h2 id='stat_summary_2d'>Bin and summarise in 2d (rectangle &amp; hexagons)</h2><span id='topic+stat_summary_2d'></span><span id='topic+stat_summary2d'></span><span id='topic+stat_summary_hex'></span>

<h3>Description</h3>

<p><code>stat_summary_2d()</code> is a 2d variation of <code><a href="#topic+stat_summary">stat_summary()</a></code>.
<code>stat_summary_hex()</code> is a hexagonal variation of
<code><a href="#topic+stat_summary_2d">stat_summary_2d()</a></code>. The data are divided into bins defined
by <code>x</code> and <code>y</code>, and then the values of <code>z</code> in each cell is
are summarised with <code>fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_summary_2d(
  mapping = NULL,
  data = NULL,
  geom = "tile",
  position = "identity",
  ...,
  bins = 30,
  binwidth = NULL,
  drop = TRUE,
  fun = "mean",
  fun.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_summary_hex(
  mapping = NULL,
  data = NULL,
  geom = "hex",
  position = "identity",
  ...,
  bins = 30,
  binwidth = NULL,
  drop = TRUE,
  fun = "mean",
  fun.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_summary_2d_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_bins">bins</code></td>
<td>
<p>numeric vector giving number of bins in both vertical and
horizontal directions. Set to 30 by default.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_binwidth">binwidth</code></td>
<td>
<p>Numeric vector giving bin width in both vertical and
horizontal directions. Overrides <code>bins</code> if both set.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_drop">drop</code></td>
<td>
<p>drop if the output of <code>fun</code> is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_fun">fun</code></td>
<td>
<p>function for summary.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_fun.args">fun.args</code></td>
<td>
<p>A list of extra arguments to pass to <code>fun</code></p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>


<ul>
<li> <p><code>x</code>: horizontal position
</p>
</li>
<li> <p><code>y</code>: vertical position
</p>
</li>
<li> <p><code>z</code>: value passed to the summary function
</p>
</li></ul>



<h3>Computed variables</h3>

<p>These are calculated by the 'stat' part of layers and can be accessed with <a href="#topic+aes_eval">delayed evaluation</a>.
</p>

<ul>
<li> <p><code>after_stat(x)</code>, <code>after_stat(y)</code><br /> Location.
</p>
</li>
<li> <p><code>after_stat(value)</code><br /> Value of summary statistic.
</p>
</li></ul>



<h3>Dropped variables</h3>


<dl>
<dt><code>z</code></dt><dd><p>After binning, the z values of individual data points are no longer available.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+stat_summary_hex">stat_summary_hex()</a></code> for hexagonal summarization.
<code><a href="#topic+stat_bin_2d">stat_bin_2d()</a></code> for the binning options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- ggplot(diamonds, aes(carat, depth, z = price))
d + stat_summary_2d()

# Specifying function
d + stat_summary_2d(fun = function(x) sum(x^2))
d + stat_summary_2d(fun = ~ sum(.x^2))
d + stat_summary_2d(fun = var)
d + stat_summary_2d(fun = "quantile", fun.args = list(probs = 0.1))

if (requireNamespace("hexbin")) {
d + stat_summary_hex()
d + stat_summary_hex(fun = ~ sum(.x^2))
}
</code></pre>

<hr>
<h2 id='stat_summary_bin'>Summarise y values at unique/binned x</h2><span id='topic+stat_summary_bin'></span><span id='topic+stat_summary'></span>

<h3>Description</h3>

<p><code>stat_summary()</code> operates on unique <code>x</code> or <code>y</code>; <code>stat_summary_bin()</code>
operates on binned <code>x</code> or <code>y</code>. They are more flexible versions of
<code><a href="#topic+stat_bin">stat_bin()</a></code>: instead of just counting, they can compute any
aggregate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_summary_bin(
  mapping = NULL,
  data = NULL,
  geom = "pointrange",
  position = "identity",
  ...,
  fun.data = NULL,
  fun = NULL,
  fun.max = NULL,
  fun.min = NULL,
  fun.args = list(),
  bins = 30,
  binwidth = NULL,
  breaks = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  fun.y = deprecated(),
  fun.ymin = deprecated(),
  fun.ymax = deprecated()
)

stat_summary(
  mapping = NULL,
  data = NULL,
  geom = "pointrange",
  position = "identity",
  ...,
  fun.data = NULL,
  fun = NULL,
  fun.max = NULL,
  fun.min = NULL,
  fun.args = list(),
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  fun.y = deprecated(),
  fun.ymin = deprecated(),
  fun.ymax = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_summary_bin_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_fun.data">fun.data</code></td>
<td>
<p>A function that is given the complete data and should
return a data frame with variables <code>ymin</code>, <code>y</code>, and <code>ymax</code>.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_fun.min">fun.min</code>, <code id="stat_summary_bin_+3A_fun">fun</code>, <code id="stat_summary_bin_+3A_fun.max">fun.max</code></td>
<td>
<p>Alternatively, supply three individual
functions that are each passed a vector of values and should return a
single number.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_fun.args">fun.args</code></td>
<td>
<p>Optional additional arguments passed on to the functions.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_bins">bins</code></td>
<td>
<p>Number of bins. Overridden by <code>binwidth</code>. Defaults to 30.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the bins. Can be specified as a numeric value
or as a function that calculates width from unscaled x. Here, &quot;unscaled x&quot;
refers to the original x values in the data, before application of any
scale transformation. When specifying a function along with a grouping
structure, the function will be called once per group.
The default is to use the number of bins in <code>bins</code>,
covering the range of the data. You should always override
this value, exploring multiple widths to find the best to illustrate the
stories in your data.
</p>
<p>The bin width of a date variable is the number of days in each time; the
bin width of a time variable is the number of seconds.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_breaks">breaks</code></td>
<td>
<p>Alternatively, you can supply a numeric vector giving
the bin boundaries. Overrides <code>binwidth</code>, <code>bins</code>, <code>center</code>,
and <code>boundary</code>.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_fun.ymin">fun.ymin</code>, <code id="stat_summary_bin_+3A_fun.y">fun.y</code>, <code id="stat_summary_bin_+3A_fun.ymax">fun.ymax</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use the
versions specified above instead.</p>
</td></tr>
</table>


<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Aesthetics</h3>

<p><code>stat_summary()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Summary functions</h3>

<p>You can either supply summary functions individually (<code>fun</code>,
<code>fun.max</code>, <code>fun.min</code>), or as a single function (<code>fun.data</code>):
</p>

<dl>
<dt>fun.data</dt><dd><p>Complete summary function. Should take numeric vector as
input and return data frame as output</p>
</dd>
<dt>fun.min</dt><dd><p>min summary function (should take numeric vector and
return single number)</p>
</dd>
<dt>fun</dt><dd><p>main summary function (should take numeric vector and return
single number)</p>
</dd>
<dt>fun.max</dt><dd><p>max summary function (should take numeric vector and
return single number)</p>
</dd>
</dl>

<p>A simple vector function is easiest to work with as you can return a single
number, but is somewhat less flexible. If your summary function computes
multiple values at once (e.g. min and max), use <code>fun.data</code>.
</p>
<p><code>fun.data</code> will receive data as if it was oriented along the x-axis and
should return a data.frame that corresponds to that orientation. The layer
will take care of flipping the input and output if it is oriented along the
y-axis.
</p>
<p>If no aggregation functions are supplied, will default to
<code><a href="#topic+mean_se">mean_se()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_errorbar">geom_errorbar()</a></code>, <code><a href="#topic+geom_pointrange">geom_pointrange()</a></code>,
<code><a href="#topic+geom_linerange">geom_linerange()</a></code>, <code><a href="#topic+geom_crossbar">geom_crossbar()</a></code> for geoms to
display summarised data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- ggplot(mtcars, aes(cyl, mpg)) + geom_point()
d + stat_summary(fun.data = "mean_cl_boot", colour = "red", linewidth = 2, size = 3)

# Orientation follows the discrete axis
ggplot(mtcars, aes(mpg, factor(cyl))) +
  geom_point() +
  stat_summary(fun.data = "mean_cl_boot", colour = "red", linewidth = 2, size = 3)

# You can supply individual functions to summarise the value at
# each x:
d + stat_summary(fun = "median", colour = "red", size = 2, geom = "point")
d + stat_summary(fun = "mean", colour = "red", size = 2, geom = "point")
d + aes(colour = factor(vs)) + stat_summary(fun = mean, geom="line")

d + stat_summary(fun = mean, fun.min = min, fun.max = max, colour = "red")

d &lt;- ggplot(diamonds, aes(cut))
d + geom_bar()
d + stat_summary(aes(y = price), fun = "mean", geom = "bar")

# Orientation of stat_summary_bin is ambiguous and must be specified directly
ggplot(diamonds, aes(carat, price)) +
  stat_summary_bin(fun = "mean", geom = "bar", orientation = 'y')


# Don't use ylim to zoom into a summary plot - this throws the
# data away
p &lt;- ggplot(mtcars, aes(cyl, mpg)) +
  stat_summary(fun = "mean", geom = "point")
p
p + ylim(15, 30)
# Instead use coord_cartesian
p + coord_cartesian(ylim = c(15, 30))

# A set of useful summary functions is provided from the Hmisc package:
stat_sum_df &lt;- function(fun, geom="crossbar", ...) {
  stat_summary(fun.data = fun, colour = "red", geom = geom, width = 0.2, ...)
}
d &lt;- ggplot(mtcars, aes(cyl, mpg)) + geom_point()
# The crossbar geom needs grouping to be specified when used with
# a continuous x axis.
d + stat_sum_df("mean_cl_boot", mapping = aes(group = cyl))
d + stat_sum_df("mean_sdl", mapping = aes(group = cyl))
d + stat_sum_df("mean_sdl", fun.args = list(mult = 1), mapping = aes(group = cyl))
d + stat_sum_df("median_hilow", mapping = aes(group = cyl))

# An example with highly skewed distributions:
if (require("ggplot2movies")) {
set.seed(596)
mov &lt;- movies[sample(nrow(movies), 1000), ]
 m2 &lt;-
   ggplot(mov, aes(x = factor(round(rating)), y = votes)) +
   geom_point()
 m2 &lt;-
   m2 +
   stat_summary(
     fun.data = "mean_cl_boot",
     geom = "crossbar",
     colour = "red", width = 0.3
   ) +
   xlab("rating")
m2
# Notice how the overplotting skews off visual perception of the mean
# supplementing the raw data with summary statistics is _very_ important

# Next, we'll look at votes on a log scale.

# Transforming the scale means the data are transformed
# first, after which statistics are computed:
m2 + scale_y_log10()
# Transforming the coordinate system occurs after the
# statistic has been computed. This means we're calculating the summary on the raw data
# and stretching the geoms onto the log scale.  Compare the widths of the
# standard errors.
m2 + coord_trans(y="log10")
}

</code></pre>

<hr>
<h2 id='stat_unique'>Remove duplicates</h2><span id='topic+stat_unique'></span>

<h3>Description</h3>

<p>Remove duplicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_unique(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_unique_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_unique()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><code><a href="#topic+aes_group_order">group</a></code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars, aes(vs, am)) +
  geom_point(alpha = 0.1)
ggplot(mtcars, aes(vs, am)) +
  geom_point(alpha = 0.1, stat = "unique")
</code></pre>

<hr>
<h2 id='summarise_plot'>Summarise built plot objects</h2><span id='topic+summarise_plot'></span><span id='topic+summarise_layout'></span><span id='topic+summarise_coord'></span><span id='topic+summarise_layers'></span>

<h3>Description</h3>

<p>These functions provide summarised information about built ggplot objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_layout(p)

summarise_coord(p)

summarise_layers(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_plot_+3A_p">p</code></td>
<td>
<p>A ggplot_built object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three types of summary that can be obtained: A summary of the plot layout,
a summary of the plot coord, and a summary of plot layers.
</p>


<h3>Layout summary</h3>

<p>The function <code>summarise_layout()</code> returns a table that provides information about
the plot panel(s) in the built plot. The table has the following columns:
</p>

<dl>
<dt><code>panel</code></dt><dd><p>A factor indicating the individual plot panels.</p>
</dd>
<dt><code>row</code></dt><dd><p>Row number in the grid of panels.</p>
</dd>
<dt><code>col</code></dt><dd><p>Column number in the grid of panels.</p>
</dd>
<dt><code>vars</code></dt><dd><p>A list of lists. For each panel, the respective list
provides the variables and their values that specify the panel.</p>
</dd>
<dt><code>xmin</code>, <code>xmax</code></dt><dd><p>The minimum and maximum values of the variable mapped to
the x aesthetic, in transformed coordinates.</p>
</dd>
<dt><code>ymin</code>, <code>ymax</code></dt><dd><p>The minimum and maximum values of the variable mapped to
the y aesthetic, in transformed coordinates.</p>
</dd>
<dt><code>xscale</code></dt><dd><p>The scale object applied to the x aesthetic.</p>
</dd>
<dt><code>yscale</code></dt><dd><p>The scale object applied to the y aesthetic.</p>
</dd>
</dl>

<p>Importantly, the values for <code>xmin</code>, <code>xmax</code>, <code>ymin</code>, <code>ymax</code>, <code>xscale</code>, and <code>yscale</code>
are determined by the variables that are mapped to <code>x</code> and <code>y</code> in the <code>aes()</code> call.
So even if a coord changes how x and y are shown in the final plot (as is the case
for <code>coord_flip()</code> or <code>coord_polar()</code>), these changes have no effect on the results
returned by <code>summarise_plot()</code>.
</p>


<h3>Coord summary</h3>

<p>The function <code>summarise_coord()</code> returns information about the log base for
coordinates that are log-transformed in <code>coord_trans()</code>, and it also indicates
whether the coord has flipped the x and y axes.
</p>


<h3>Layer summary</h3>

<p>The function <code>summarise_layers()</code> returns a table with a single column, <code>mapping</code>, which
contains information about aesthetic mapping for each layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;-
  ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(~class)
b &lt;- ggplot_build(p)

summarise_layout(b)
summarise_coord(b)
summarise_layers(b)

</code></pre>

<hr>
<h2 id='summary.ggplot'>Displays a useful description of a ggplot object</h2><span id='topic+summary.ggplot'></span>

<h3>Description</h3>

<p>Displays a useful description of a ggplot object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggplot'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ggplot_+3A_object">object</code></td>
<td>
<p>ggplot2 object to summarise</p>
</td></tr>
<tr><td><code id="summary.ggplot_+3A_...">...</code></td>
<td>
<p>other arguments ignored (for compatibility with generic)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) +
  geom_point()
summary(p)
</code></pre>

<hr>
<h2 id='theme'>Modify components of a theme</h2><span id='topic+theme'></span>

<h3>Description</h3>

<p>Themes are a powerful way to customize the non-data components of your plots:
i.e. titles, labels, fonts, background, gridlines, and legends. Themes can be
used to give plots a consistent customized look. Modify a single plot's theme
using <code>theme()</code>; see <code><a href="#topic+theme_update">theme_update()</a></code> if you want modify the active theme, to
affect all subsequent plots. Use the themes available in <a href="#topic+theme_bw">complete themes</a> if you would like to use a complete theme such as
<code>theme_bw()</code>, <code>theme_minimal()</code>, and more. Theme elements are documented
together according to inheritance, read more about theme inheritance below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme(
  ...,
  line,
  rect,
  text,
  title,
  aspect.ratio,
  axis.title,
  axis.title.x,
  axis.title.x.top,
  axis.title.x.bottom,
  axis.title.y,
  axis.title.y.left,
  axis.title.y.right,
  axis.text,
  axis.text.x,
  axis.text.x.top,
  axis.text.x.bottom,
  axis.text.y,
  axis.text.y.left,
  axis.text.y.right,
  axis.text.theta,
  axis.text.r,
  axis.ticks,
  axis.ticks.x,
  axis.ticks.x.top,
  axis.ticks.x.bottom,
  axis.ticks.y,
  axis.ticks.y.left,
  axis.ticks.y.right,
  axis.ticks.theta,
  axis.ticks.r,
  axis.minor.ticks.x.top,
  axis.minor.ticks.x.bottom,
  axis.minor.ticks.y.left,
  axis.minor.ticks.y.right,
  axis.minor.ticks.theta,
  axis.minor.ticks.r,
  axis.ticks.length,
  axis.ticks.length.x,
  axis.ticks.length.x.top,
  axis.ticks.length.x.bottom,
  axis.ticks.length.y,
  axis.ticks.length.y.left,
  axis.ticks.length.y.right,
  axis.ticks.length.theta,
  axis.ticks.length.r,
  axis.minor.ticks.length,
  axis.minor.ticks.length.x,
  axis.minor.ticks.length.x.top,
  axis.minor.ticks.length.x.bottom,
  axis.minor.ticks.length.y,
  axis.minor.ticks.length.y.left,
  axis.minor.ticks.length.y.right,
  axis.minor.ticks.length.theta,
  axis.minor.ticks.length.r,
  axis.line,
  axis.line.x,
  axis.line.x.top,
  axis.line.x.bottom,
  axis.line.y,
  axis.line.y.left,
  axis.line.y.right,
  axis.line.theta,
  axis.line.r,
  legend.background,
  legend.margin,
  legend.spacing,
  legend.spacing.x,
  legend.spacing.y,
  legend.key,
  legend.key.size,
  legend.key.height,
  legend.key.width,
  legend.key.spacing,
  legend.key.spacing.x,
  legend.key.spacing.y,
  legend.frame,
  legend.ticks,
  legend.ticks.length,
  legend.axis.line,
  legend.text,
  legend.text.position,
  legend.title,
  legend.title.position,
  legend.position,
  legend.position.inside,
  legend.direction,
  legend.byrow,
  legend.justification,
  legend.justification.top,
  legend.justification.bottom,
  legend.justification.left,
  legend.justification.right,
  legend.justification.inside,
  legend.location,
  legend.box,
  legend.box.just,
  legend.box.margin,
  legend.box.background,
  legend.box.spacing,
  panel.background,
  panel.border,
  panel.spacing,
  panel.spacing.x,
  panel.spacing.y,
  panel.grid,
  panel.grid.major,
  panel.grid.minor,
  panel.grid.major.x,
  panel.grid.major.y,
  panel.grid.minor.x,
  panel.grid.minor.y,
  panel.ontop,
  plot.background,
  plot.title,
  plot.title.position,
  plot.subtitle,
  plot.caption,
  plot.caption.position,
  plot.tag,
  plot.tag.position,
  plot.tag.location,
  plot.margin,
  strip.background,
  strip.background.x,
  strip.background.y,
  strip.clip,
  strip.placement,
  strip.text,
  strip.text.x,
  strip.text.x.bottom,
  strip.text.x.top,
  strip.text.y,
  strip.text.y.left,
  strip.text.y.right,
  strip.switch.pad.grid,
  strip.switch.pad.wrap,
  complete = FALSE,
  validate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_+3A_...">...</code></td>
<td>
<p>additional element specifications not part of base ggplot2. In general,
these should also be defined in the <code style="white-space: pre;">&#8288;element tree&#8288;</code> argument.</p>
</td></tr>
<tr><td><code id="theme_+3A_line">line</code></td>
<td>
<p>all line elements (<code><a href="#topic+element_line">element_line()</a></code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_rect">rect</code></td>
<td>
<p>all rectangular elements (<code><a href="#topic+element_rect">element_rect()</a></code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_text">text</code></td>
<td>
<p>all text elements (<code><a href="#topic+element_text">element_text()</a></code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_title">title</code></td>
<td>
<p>all title elements: plot, axes, legends (<code><a href="#topic+element_text">element_text()</a></code>;
inherits from <code>text</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_aspect.ratio">aspect.ratio</code></td>
<td>
<p>aspect ratio of the panel</p>
</td></tr>
<tr><td><code id="theme_+3A_axis.title">axis.title</code>, <code id="theme_+3A_axis.title.x">axis.title.x</code>, <code id="theme_+3A_axis.title.y">axis.title.y</code>, <code id="theme_+3A_axis.title.x.top">axis.title.x.top</code>, <code id="theme_+3A_axis.title.x.bottom">axis.title.x.bottom</code>, <code id="theme_+3A_axis.title.y.left">axis.title.y.left</code>, <code id="theme_+3A_axis.title.y.right">axis.title.y.right</code></td>
<td>
<p>labels of axes (<code><a href="#topic+element_text">element_text()</a></code>). Specify all axes' labels (<code>axis.title</code>),
labels by plane (using <code>axis.title.x</code> or <code>axis.title.y</code>), or individually
for each axis (using <code>axis.title.x.bottom</code>, <code>axis.title.x.top</code>,
<code>axis.title.y.left</code>, <code>axis.title.y.right</code>). <code style="white-space: pre;">&#8288;axis.title.*.*&#8288;</code> inherits from
<code style="white-space: pre;">&#8288;axis.title.*&#8288;</code> which inherits from <code>axis.title</code>, which in turn inherits
from <code>text</code></p>
</td></tr>
<tr><td><code id="theme_+3A_axis.text">axis.text</code>, <code id="theme_+3A_axis.text.x">axis.text.x</code>, <code id="theme_+3A_axis.text.y">axis.text.y</code>, <code id="theme_+3A_axis.text.x.top">axis.text.x.top</code>, <code id="theme_+3A_axis.text.x.bottom">axis.text.x.bottom</code>, <code id="theme_+3A_axis.text.y.left">axis.text.y.left</code>, <code id="theme_+3A_axis.text.y.right">axis.text.y.right</code>, <code id="theme_+3A_axis.text.theta">axis.text.theta</code>, <code id="theme_+3A_axis.text.r">axis.text.r</code></td>
<td>
<p>tick labels along axes (<code><a href="#topic+element_text">element_text()</a></code>). Specify all axis tick labels (<code>axis.text</code>),
tick labels by plane (using <code>axis.text.x</code> or <code>axis.text.y</code>), or individually
for each axis (using <code>axis.text.x.bottom</code>, <code>axis.text.x.top</code>,
<code>axis.text.y.left</code>, <code>axis.text.y.right</code>). <code style="white-space: pre;">&#8288;axis.text.*.*&#8288;</code> inherits from
<code style="white-space: pre;">&#8288;axis.text.*&#8288;</code> which inherits from <code>axis.text</code>, which in turn inherits
from <code>text</code></p>
</td></tr>
<tr><td><code id="theme_+3A_axis.ticks">axis.ticks</code>, <code id="theme_+3A_axis.ticks.x">axis.ticks.x</code>, <code id="theme_+3A_axis.ticks.x.top">axis.ticks.x.top</code>, <code id="theme_+3A_axis.ticks.x.bottom">axis.ticks.x.bottom</code>, <code id="theme_+3A_axis.ticks.y">axis.ticks.y</code>, <code id="theme_+3A_axis.ticks.y.left">axis.ticks.y.left</code>, <code id="theme_+3A_axis.ticks.y.right">axis.ticks.y.right</code>, <code id="theme_+3A_axis.ticks.theta">axis.ticks.theta</code>, <code id="theme_+3A_axis.ticks.r">axis.ticks.r</code></td>
<td>
<p>tick marks along axes (<code><a href="#topic+element_line">element_line()</a></code>). Specify all tick marks (<code>axis.ticks</code>),
ticks by plane (using <code>axis.ticks.x</code> or <code>axis.ticks.y</code>), or individually
for each axis (using <code>axis.ticks.x.bottom</code>, <code>axis.ticks.x.top</code>,
<code>axis.ticks.y.left</code>, <code>axis.ticks.y.right</code>). <code style="white-space: pre;">&#8288;axis.ticks.*.*&#8288;</code> inherits from
<code style="white-space: pre;">&#8288;axis.ticks.*&#8288;</code> which inherits from <code>axis.ticks</code>, which in turn inherits
from <code>line</code></p>
</td></tr>
<tr><td><code id="theme_+3A_axis.minor.ticks.x.top">axis.minor.ticks.x.top</code>, <code id="theme_+3A_axis.minor.ticks.x.bottom">axis.minor.ticks.x.bottom</code>, <code id="theme_+3A_axis.minor.ticks.y.left">axis.minor.ticks.y.left</code>, <code id="theme_+3A_axis.minor.ticks.y.right">axis.minor.ticks.y.right</code>, <code id="theme_+3A_axis.minor.ticks.theta">axis.minor.ticks.theta</code>, <code id="theme_+3A_axis.minor.ticks.r">axis.minor.ticks.r</code></td>
<td>
<p>minor tick marks along axes (<code><a href="#topic+element_line">element_line()</a></code>). <code style="white-space: pre;">&#8288;axis.minor.ticks.*.*&#8288;</code>
inherit from the corresponding major ticks <code style="white-space: pre;">&#8288;axis.ticks.*.*&#8288;</code>.</p>
</td></tr>
<tr><td><code id="theme_+3A_axis.ticks.length">axis.ticks.length</code>, <code id="theme_+3A_axis.ticks.length.x">axis.ticks.length.x</code>, <code id="theme_+3A_axis.ticks.length.x.top">axis.ticks.length.x.top</code>, <code id="theme_+3A_axis.ticks.length.x.bottom">axis.ticks.length.x.bottom</code>, <code id="theme_+3A_axis.ticks.length.y">axis.ticks.length.y</code>, <code id="theme_+3A_axis.ticks.length.y.left">axis.ticks.length.y.left</code>, <code id="theme_+3A_axis.ticks.length.y.right">axis.ticks.length.y.right</code>, <code id="theme_+3A_axis.ticks.length.theta">axis.ticks.length.theta</code>, <code id="theme_+3A_axis.ticks.length.r">axis.ticks.length.r</code></td>
<td>
<p>length of tick marks (<code>unit</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_axis.minor.ticks.length">axis.minor.ticks.length</code>, <code id="theme_+3A_axis.minor.ticks.length.x">axis.minor.ticks.length.x</code>, <code id="theme_+3A_axis.minor.ticks.length.x.top">axis.minor.ticks.length.x.top</code>, <code id="theme_+3A_axis.minor.ticks.length.x.bottom">axis.minor.ticks.length.x.bottom</code>, <code id="theme_+3A_axis.minor.ticks.length.y">axis.minor.ticks.length.y</code>, <code id="theme_+3A_axis.minor.ticks.length.y.left">axis.minor.ticks.length.y.left</code>, <code id="theme_+3A_axis.minor.ticks.length.y.right">axis.minor.ticks.length.y.right</code>, <code id="theme_+3A_axis.minor.ticks.length.theta">axis.minor.ticks.length.theta</code>, <code id="theme_+3A_axis.minor.ticks.length.r">axis.minor.ticks.length.r</code></td>
<td>
<p>length of minor tick marks (<code>unit</code>), or relative to <code>axis.ticks.length</code> when provided with <code>rel()</code>.</p>
</td></tr>
<tr><td><code id="theme_+3A_axis.line">axis.line</code>, <code id="theme_+3A_axis.line.x">axis.line.x</code>, <code id="theme_+3A_axis.line.x.top">axis.line.x.top</code>, <code id="theme_+3A_axis.line.x.bottom">axis.line.x.bottom</code>, <code id="theme_+3A_axis.line.y">axis.line.y</code>, <code id="theme_+3A_axis.line.y.left">axis.line.y.left</code>, <code id="theme_+3A_axis.line.y.right">axis.line.y.right</code>, <code id="theme_+3A_axis.line.theta">axis.line.theta</code>, <code id="theme_+3A_axis.line.r">axis.line.r</code></td>
<td>
<p>lines along axes (<code><a href="#topic+element_line">element_line()</a></code>). Specify lines along all axes (<code>axis.line</code>),
lines for each plane (using <code>axis.line.x</code> or <code>axis.line.y</code>), or individually
for each axis (using <code>axis.line.x.bottom</code>, <code>axis.line.x.top</code>,
<code>axis.line.y.left</code>, <code>axis.line.y.right</code>). <code style="white-space: pre;">&#8288;axis.line.*.*&#8288;</code> inherits from
<code style="white-space: pre;">&#8288;axis.line.*&#8288;</code> which inherits from <code>axis.line</code>, which in turn inherits
from <code>line</code></p>
</td></tr>
<tr><td><code id="theme_+3A_legend.background">legend.background</code></td>
<td>
<p>background of legend (<code><a href="#topic+element_rect">element_rect()</a></code>; inherits
from <code>rect</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.margin">legend.margin</code></td>
<td>
<p>the margin around each legend (<code><a href="#topic+margin">margin()</a></code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.spacing">legend.spacing</code>, <code id="theme_+3A_legend.spacing.x">legend.spacing.x</code>, <code id="theme_+3A_legend.spacing.y">legend.spacing.y</code></td>
<td>
<p>the spacing between legends (<code>unit</code>). <code>legend.spacing.x</code> &amp; <code>legend.spacing.y</code>
inherit from <code>legend.spacing</code> or can be specified separately</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.key">legend.key</code></td>
<td>
<p>background underneath legend keys (<code><a href="#topic+element_rect">element_rect()</a></code>;
inherits from <code>rect</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.key.size">legend.key.size</code>, <code id="theme_+3A_legend.key.height">legend.key.height</code>, <code id="theme_+3A_legend.key.width">legend.key.width</code></td>
<td>
<p>size of legend keys (<code>unit</code>); key background height &amp; width inherit from
<code>legend.key.size</code> or can be specified separately</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.key.spacing">legend.key.spacing</code>, <code id="theme_+3A_legend.key.spacing.x">legend.key.spacing.x</code>, <code id="theme_+3A_legend.key.spacing.y">legend.key.spacing.y</code></td>
<td>
<p>spacing
between legend keys given as a <code>unit</code>. Spacing in the horizontal (x) and
vertical (y) direction inherit from <code>legend.key.spacing</code> or can be
specified separately.</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.frame">legend.frame</code></td>
<td>
<p>frame drawn around the bar (<code><a href="#topic+element_rect">element_rect()</a></code>).</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.ticks">legend.ticks</code></td>
<td>
<p>tick marks shown along bars or axes (<code><a href="#topic+element_line">element_line()</a></code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.ticks.length">legend.ticks.length</code></td>
<td>
<p>length of tick marks in legend (<code>unit</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.axis.line">legend.axis.line</code></td>
<td>
<p>lines along axes in legends (<code><a href="#topic+element_line">element_line()</a></code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.text">legend.text</code></td>
<td>
<p>legend item labels (<code><a href="#topic+element_text">element_text()</a></code>; inherits from
<code>text</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.text.position">legend.text.position</code></td>
<td>
<p>placement of legend text relative to legend keys
or bars (&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot; or &quot;left&quot;). The legend text placement
might be incompatible with the legend's direction for some guides.</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.title">legend.title</code></td>
<td>
<p>title of legend (<code><a href="#topic+element_text">element_text()</a></code>; inherits from
<code>title</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.title.position">legend.title.position</code></td>
<td>
<p>placement of legend title relative to the main
legend (&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot; or &quot;left&quot;).</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.position">legend.position</code></td>
<td>
<p>the default position of legends (&quot;none&quot;, &quot;left&quot;,
&quot;right&quot;, &quot;bottom&quot;, &quot;top&quot;, &quot;inside&quot;)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.position.inside">legend.position.inside</code></td>
<td>
<p>A numeric vector of length two setting the
placement of legends that have the <code>"inside"</code> position.</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.direction">legend.direction</code></td>
<td>
<p>layout of items in legends (&quot;horizontal&quot; or
&quot;vertical&quot;)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.byrow">legend.byrow</code></td>
<td>
<p>whether the legend-matrix is filled by columns
(<code>FALSE</code>, the default) or by rows (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.justification">legend.justification</code></td>
<td>
<p>anchor point for positioning legend inside plot
(&quot;center&quot; or two-element numeric vector) or the justification according to
the plot area when positioned outside the plot</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.justification.top">legend.justification.top</code>, <code id="theme_+3A_legend.justification.bottom">legend.justification.bottom</code>, <code id="theme_+3A_legend.justification.left">legend.justification.left</code>, <code id="theme_+3A_legend.justification.right">legend.justification.right</code>, <code id="theme_+3A_legend.justification.inside">legend.justification.inside</code></td>
<td>
<p>Same as <code>legend.justification</code> but specified per <code>legend.position</code> option.</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.location">legend.location</code></td>
<td>
<p>Relative placement of legends outside the plot as a
string. Can be <code>"panel"</code> (default) to align legends to the panels or
<code>"plot"</code> to align legends to the plot as a whole.</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.box">legend.box</code></td>
<td>
<p>arrangement of multiple legends (&quot;horizontal&quot; or
&quot;vertical&quot;)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.box.just">legend.box.just</code></td>
<td>
<p>justification of each legend within the overall
bounding box, when there are multiple legends (&quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, or
&quot;right&quot;)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.box.margin">legend.box.margin</code></td>
<td>
<p>margins around the full legend area, as specified
using <code><a href="#topic+margin">margin()</a></code></p>
</td></tr>
<tr><td><code id="theme_+3A_legend.box.background">legend.box.background</code></td>
<td>
<p>background of legend area (<code><a href="#topic+element_rect">element_rect()</a></code>;
inherits from <code>rect</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_legend.box.spacing">legend.box.spacing</code></td>
<td>
<p>The spacing between the plotting area and the
legend box (<code>unit</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_panel.background">panel.background</code></td>
<td>
<p>background of plotting area, drawn underneath plot
(<code><a href="#topic+element_rect">element_rect()</a></code>; inherits from <code>rect</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_panel.border">panel.border</code></td>
<td>
<p>border around plotting area, drawn on top of plot so that
it covers tick marks and grid lines. This should be used with
<code>fill = NA</code>
(<code><a href="#topic+element_rect">element_rect()</a></code>; inherits from <code>rect</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_panel.spacing">panel.spacing</code>, <code id="theme_+3A_panel.spacing.x">panel.spacing.x</code>, <code id="theme_+3A_panel.spacing.y">panel.spacing.y</code></td>
<td>
<p>spacing between facet
panels (<code>unit</code>). <code>panel.spacing.x</code> &amp; <code>panel.spacing.y</code> inherit from <code>panel.spacing</code>
or can be specified separately.</p>
</td></tr>
<tr><td><code id="theme_+3A_panel.grid">panel.grid</code>, <code id="theme_+3A_panel.grid.major">panel.grid.major</code>, <code id="theme_+3A_panel.grid.minor">panel.grid.minor</code>, <code id="theme_+3A_panel.grid.major.x">panel.grid.major.x</code>, <code id="theme_+3A_panel.grid.major.y">panel.grid.major.y</code>, <code id="theme_+3A_panel.grid.minor.x">panel.grid.minor.x</code>, <code id="theme_+3A_panel.grid.minor.y">panel.grid.minor.y</code></td>
<td>
<p>grid lines (<code><a href="#topic+element_line">element_line()</a></code>). Specify major grid lines,
or minor grid lines separately (using <code>panel.grid.major</code> or <code>panel.grid.minor</code>)
or individually for each axis (using <code>panel.grid.major.x</code>, <code>panel.grid.minor.x</code>,
<code>panel.grid.major.y</code>, <code>panel.grid.minor.y</code>).  Y axis grid lines are horizontal
and x axis grid lines are vertical. <code style="white-space: pre;">&#8288;panel.grid.*.*&#8288;</code> inherits from
<code style="white-space: pre;">&#8288;panel.grid.*&#8288;</code> which inherits from <code>panel.grid</code>, which in turn inherits
from <code>line</code></p>
</td></tr>
<tr><td><code id="theme_+3A_panel.ontop">panel.ontop</code></td>
<td>
<p>option to place the panel (background, gridlines) over
the data layers (<code>logical</code>). Usually used with a transparent or blank
<code>panel.background</code>.</p>
</td></tr>
<tr><td><code id="theme_+3A_plot.background">plot.background</code></td>
<td>
<p>background of the entire plot (<code><a href="#topic+element_rect">element_rect()</a></code>;
inherits from <code>rect</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_plot.title">plot.title</code></td>
<td>
<p>plot title (text appearance) (<code><a href="#topic+element_text">element_text()</a></code>; inherits
from <code>title</code>) left-aligned by default</p>
</td></tr>
<tr><td><code id="theme_+3A_plot.title.position">plot.title.position</code>, <code id="theme_+3A_plot.caption.position">plot.caption.position</code></td>
<td>
<p>Alignment of the plot title/subtitle
and caption.  The setting for <code>plot.title.position</code> applies to both
the title and the subtitle. A value of &quot;panel&quot; (the default) means that
titles and/or caption are aligned to the plot panels. A value of &quot;plot&quot; means
that titles and/or caption are aligned to the entire plot (minus any space
for margins and plot tag).</p>
</td></tr>
<tr><td><code id="theme_+3A_plot.subtitle">plot.subtitle</code></td>
<td>
<p>plot subtitle (text appearance) (<code><a href="#topic+element_text">element_text()</a></code>;
inherits from <code>title</code>) left-aligned by default</p>
</td></tr>
<tr><td><code id="theme_+3A_plot.caption">plot.caption</code></td>
<td>
<p>caption below the plot (text appearance)
(<code><a href="#topic+element_text">element_text()</a></code>; inherits from <code>title</code>) right-aligned by default</p>
</td></tr>
<tr><td><code id="theme_+3A_plot.tag">plot.tag</code></td>
<td>
<p>upper-left label to identify a plot (text appearance)
(<code><a href="#topic+element_text">element_text()</a></code>; inherits from <code>title</code>) left-aligned by default</p>
</td></tr>
<tr><td><code id="theme_+3A_plot.tag.position">plot.tag.position</code></td>
<td>
<p>The position of the tag as a string (&quot;topleft&quot;,
&quot;top&quot;, &quot;topright&quot;, &quot;left&quot;, &quot;right&quot;, &quot;bottomleft&quot;, &quot;bottom&quot;, &quot;bottomright&quot;)
or a coordinate. If a coordinate, can be a numeric vector of length 2 to
set the x,y-coordinate relative to the whole plot. The coordinate option
is unavailable for <code>plot.tag.location = "margin"</code>.</p>
</td></tr>
<tr><td><code id="theme_+3A_plot.tag.location">plot.tag.location</code></td>
<td>
<p>The placement of the tag as a string, one of
<code>"panel"</code>, <code>"plot"</code> or <code>"margin"</code>. Respectively, these will place the tag
inside the panel space, anywhere in the plot as a whole, or in the margin
around the panel space.</p>
</td></tr>
<tr><td><code id="theme_+3A_plot.margin">plot.margin</code></td>
<td>
<p>margin around entire plot (<code>unit</code> with the sizes of
the top, right, bottom, and left margins)</p>
</td></tr>
<tr><td><code id="theme_+3A_strip.background">strip.background</code>, <code id="theme_+3A_strip.background.x">strip.background.x</code>, <code id="theme_+3A_strip.background.y">strip.background.y</code></td>
<td>
<p>background of facet labels (<code><a href="#topic+element_rect">element_rect()</a></code>;
inherits from <code>rect</code>). Horizontal facet background (<code>strip.background.x</code>)
&amp; vertical facet background (<code>strip.background.y</code>) inherit from
<code>strip.background</code> or can be specified separately</p>
</td></tr>
<tr><td><code id="theme_+3A_strip.clip">strip.clip</code></td>
<td>
<p>should strip background edges and strip labels be clipped
to the extend of the strip background? Options are <code>"on"</code> to clip, <code>"off"</code>
to disable clipping or <code>"inherit"</code> (default) to take the clipping setting
from the parent viewport.</p>
</td></tr>
<tr><td><code id="theme_+3A_strip.placement">strip.placement</code></td>
<td>
<p>placement of strip with respect to axes,
either &quot;inside&quot; or &quot;outside&quot;. Only important when axes and strips are
on the same side of the plot.</p>
</td></tr>
<tr><td><code id="theme_+3A_strip.text">strip.text</code>, <code id="theme_+3A_strip.text.x">strip.text.x</code>, <code id="theme_+3A_strip.text.y">strip.text.y</code>, <code id="theme_+3A_strip.text.x.top">strip.text.x.top</code>, <code id="theme_+3A_strip.text.x.bottom">strip.text.x.bottom</code>, <code id="theme_+3A_strip.text.y.left">strip.text.y.left</code>, <code id="theme_+3A_strip.text.y.right">strip.text.y.right</code></td>
<td>
<p>facet labels (<code><a href="#topic+element_text">element_text()</a></code>; inherits from  <code>text</code>). Horizontal facet labels (<code>strip.text.x</code>) &amp; vertical
facet labels (<code>strip.text.y</code>) inherit from <code>strip.text</code> or can be specified
separately. Facet strips have dedicated position-dependent theme elements
(<code>strip.text.x.top</code>, <code>strip.text.x.bottom</code>, <code>strip.text.y.left</code>, <code>strip.text.y.right</code>)
that inherit from <code>strip.text.x</code> and <code>strip.text.y</code>, respectively.
As a consequence, some theme stylings need to be applied to
the position-dependent elements rather than to the parent elements</p>
</td></tr>
<tr><td><code id="theme_+3A_strip.switch.pad.grid">strip.switch.pad.grid</code></td>
<td>
<p>space between strips and axes when strips are
switched (<code>unit</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_strip.switch.pad.wrap">strip.switch.pad.wrap</code></td>
<td>
<p>space between strips and axes when strips are
switched (<code>unit</code>)</p>
</td></tr>
<tr><td><code id="theme_+3A_complete">complete</code></td>
<td>
<p>set this to <code>TRUE</code> if this is a complete theme, such as
the one returned by <code><a href="#topic+theme_grey">theme_grey()</a></code>. Complete themes behave
differently when added to a ggplot object. Also, when setting
<code>complete = TRUE</code> all elements will be set to inherit from blank
elements.</p>
</td></tr>
<tr><td><code id="theme_+3A_validate">validate</code></td>
<td>
<p><code>TRUE</code> to run <code>validate_element()</code>, <code>FALSE</code> to bypass checks.</p>
</td></tr>
</table>


<h3>Theme inheritance</h3>

<p>Theme elements inherit properties from other theme elements hierarchically.
For example, <code>axis.title.x.bottom</code> inherits from <code>axis.title.x</code> which inherits
from <code>axis.title</code>, which in turn inherits from <code>text</code>. All text elements inherit
directly or indirectly from <code>text</code>; all lines inherit from
<code>line</code>, and all rectangular objects inherit from <code>rect</code>.
This means that you can modify the appearance of multiple elements by
setting a single high-level component.
</p>
<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++2B.gg">+.gg()</a></code> and <a href="#topic++25+2Breplace+25">%+replace%</a>,
<code><a href="#topic+element_blank">element_blank()</a></code>, <code><a href="#topic+element_line">element_line()</a></code>,
<code><a href="#topic+element_rect">element_rect()</a></code>, and <code><a href="#topic+element_text">element_text()</a></code> for
details of the specific theme elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  labs(title = "Fuel economy declines as weight increases")
p1

# Plot ---------------------------------------------------------------------
p1 + theme(plot.title = element_text(size = rel(2)))
p1 + theme(plot.background = element_rect(fill = "green"))

# Panels --------------------------------------------------------------------

p1 + theme(panel.background = element_rect(fill = "white", colour = "grey50"))
p1 + theme(panel.border = element_rect(linetype = "dashed", fill = NA))
p1 + theme(panel.grid.major = element_line(colour = "black"))
p1 + theme(
  panel.grid.major.y = element_blank(),
  panel.grid.minor.y = element_blank()
)

# Put gridlines on top of data
p1 + theme(
  panel.background = element_rect(fill = NA),
  panel.grid.major = element_line(colour = "grey50"),
  panel.ontop = TRUE
)

# Axes ----------------------------------------------------------------------
# Change styles of axes texts and lines
p1 + theme(axis.line = element_line(linewidth = 3, colour = "grey80"))
p1 + theme(axis.text = element_text(colour = "blue"))
p1 + theme(axis.ticks = element_line(linewidth = 2))

# Change the appearance of the y-axis title
p1 + theme(axis.title.y = element_text(size = rel(1.5), angle = 90))

# Make ticks point outwards on y-axis and inwards on x-axis
p1 + theme(
  axis.ticks.length.y = unit(.25, "cm"),
  axis.ticks.length.x = unit(-.25, "cm"),
  axis.text.x = element_text(margin = margin(t = .3, unit = "cm"))
)


# Legend --------------------------------------------------------------------
p2 &lt;- ggplot(mtcars, aes(wt, mpg)) +
  geom_point(aes(colour = factor(cyl), shape = factor(vs))) +
  labs(
    x = "Weight (1000 lbs)",
    y = "Fuel economy (mpg)",
    colour = "Cylinders",
    shape = "Transmission"
   )
p2

# Position
p2 + theme(legend.position = "none")
p2 + theme(legend.justification = "top")
p2 + theme(legend.position = "bottom")

# Or place legends inside the plot using relative coordinates between 0 and 1
# legend.justification sets the corner that the position refers to
p2 + theme(
  legend.position = c(.95, .95),
  legend.justification = c("right", "top"),
  legend.box.just = "right",
  legend.margin = margin(6, 6, 6, 6)
)

# The legend.box properties work similarly for the space around
# all the legends
p2 + theme(
  legend.box.background = element_rect(),
  legend.box.margin = margin(6, 6, 6, 6)
)

# You can also control the display of the keys
# and the justification related to the plot area can be set
p2 + theme(legend.key = element_rect(fill = "white", colour = "black"))
p2 + theme(legend.text = element_text(size = 8, colour = "red"))
p2 + theme(legend.title = element_text(face = "bold"))

# Strips --------------------------------------------------------------------

p3 &lt;- ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  facet_wrap(~ cyl)
p3

p3 + theme(strip.background = element_rect(colour = "black", fill = "white"))
p3 + theme(strip.text.x = element_text(colour = "white", face = "bold"))
# More direct strip.text.x here for top
# as in the facet_wrap the default strip.position is "top"
p3 + theme(strip.text.x.top = element_text(colour = "white", face = "bold"))
p3 + theme(panel.spacing = unit(1, "lines"))

</code></pre>

<hr>
<h2 id='theme_get'>Get, set, and modify the active theme</h2><span id='topic+theme_get'></span><span id='topic+theme_set'></span><span id='topic+theme_update'></span><span id='topic+theme_replace'></span><span id='topic++25+2Breplace+25'></span>

<h3>Description</h3>

<p>The current/active theme (see <code><a href="#topic+theme">theme()</a></code>) is automatically applied to every
plot you draw. Use <code>theme_get()</code> to get the current theme, and <code>theme_set()</code> to
completely override it. <code>theme_update()</code> and <code>theme_replace()</code> are shorthands for
changing individual elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_get()

theme_set(new)

theme_update(...)

theme_replace(...)

e1 %+replace% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_get_+3A_new">new</code></td>
<td>
<p>new theme (a list of theme elements)</p>
</td></tr>
<tr><td><code id="theme_get_+3A_...">...</code></td>
<td>
<p>named list of theme settings</p>
</td></tr>
<tr><td><code id="theme_get_+3A_e1">e1</code>, <code id="theme_get_+3A_e2">e2</code></td>
<td>
<p>Theme and element to combine</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>theme_set()</code>, <code>theme_update()</code>, and <code>theme_replace()</code>
invisibly return the previous theme so you can easily save it, then
later restore it.
</p>


<h3>Adding on to a theme</h3>

<p><code>+</code> and <code style="white-space: pre;">&#8288;%+replace%&#8288;</code> can be used to modify elements in themes.
</p>
<p><code>+</code> updates the elements of e1 that differ from elements specified (not
NULL) in e2. Thus this operator can be used to incrementally add or modify
attributes of a ggplot theme.
</p>
<p>In contrast, <code style="white-space: pre;">&#8288;%+replace%&#8288;</code> replaces the entire element; any element of a
theme not specified in e2 will not be present in the resulting theme (i.e.
NULL). Thus this operator can be used to overwrite an entire theme.
</p>
<p><code>theme_update()</code> uses the <code>+</code> operator, so that any unspecified values in the
theme element will default to the values they are set in the theme.
<code>theme_replace()</code> uses <code style="white-space: pre;">&#8288;%+replace%&#8288;</code> to completely replace the element, so any
unspecified values will overwrite the current value in the theme with
<code>NULL</code>.
</p>
<p>In summary, the main differences between <code>theme_set()</code>, <code>theme_update()</code>,
and <code>theme_replace()</code> are:
</p>

<ul>
<li> <p><code>theme_set()</code> completely overrides the current theme.
</p>
</li>
<li> <p><code>theme_update()</code> modifies a particular element of the current theme
using the <code>+</code> operator.
</p>
</li>
<li> <p><code>theme_replace()</code> modifies a particular element of the current theme
using the <code style="white-space: pre;">&#8288;%+replace%&#8288;</code> operator.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic++2B.gg">+.gg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) +
  geom_point()
p

# Use theme_set() to completely override the current theme.
# theme_update() and theme_replace() are similar except they
# apply directly to the current/active theme.
# theme_update() modifies a particular element of the current theme.
# Here we have the old theme so we can later restore it.
# Note that the theme is applied when the plot is drawn, not
# when it is created.
old &lt;- theme_set(theme_bw())
p

theme_set(old)
theme_update(panel.grid.minor = element_line(colour = "red"))
p

theme_set(old)
theme_replace(panel.grid.minor = element_line(colour = "red"))
p

theme_set(old)
p


# Modifying theme objects -----------------------------------------
# You can use + and %+replace% to modify a theme object.
# They differ in how they deal with missing arguments in
# the theme elements.

add_el &lt;- theme_grey() +
  theme(text = element_text(family = "Times"))
add_el$text

rep_el &lt;- theme_grey() %+replace%
  theme(text = element_text(family = "Times"))
rep_el$text

</code></pre>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+expr'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+.data'></span><span id='topic+as_label'></span><span id='topic+quo_name'></span><span id='topic+quo'></span><span id='topic+quos'></span><span id='topic+enexpr'></span><span id='topic+enexprs'></span><span id='topic+ensym'></span><span id='topic+ensyms'></span>

<h3>Description</h3>

<p>This page lists the tidy eval tools reexported in this package from
rlang. To learn about using tidy eval in scripts and packages at a
high level, see the <a href="https://dplyr.tidyverse.org/articles/programming.html">dplyr programming vignette</a>
and the <a href="https://ggplot2.tidyverse.org/articles/ggplot2-in-packages.html">ggplot2 in packages vignette</a>.
The <a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming section</a> of <a href="https://adv-r.hadley.nz">Advanced R</a> may also be useful for a deeper dive.
</p>

<ul>
<li><p> The tidy eval operators <code style="white-space: pre;">&#8288;{{&#8288;</code>, <code style="white-space: pre;">&#8288;!!&#8288;</code>, and <code style="white-space: pre;">&#8288;!!!&#8288;</code> are syntactic
constructs which are specially interpreted by tidy eval functions.
You will mostly need <code style="white-space: pre;">&#8288;{{&#8288;</code>, as <code style="white-space: pre;">&#8288;!!&#8288;</code> and <code style="white-space: pre;">&#8288;!!!&#8288;</code> are more advanced
operators which you should not have to use in simple cases.
</p>
<p>The curly-curly operator <code style="white-space: pre;">&#8288;{{&#8288;</code> allows you to tunnel data-variables
passed from function arguments inside other tidy eval functions.
<code style="white-space: pre;">&#8288;{{&#8288;</code> is designed for individual arguments. To pass multiple
arguments contained in dots, use <code>...</code> in the normal way.
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, ...) {
  data %&gt;%
    group_by(...) %&gt;%
    summarise(mean = mean({{ var }}))
}
</pre></div>
</li>
<li> <p><code><a href="#topic+enquo">enquo()</a></code> and <code><a href="#topic+enquos">enquos()</a></code> delay the execution of one or several
function arguments. The former returns a single expression, the
latter returns a list of expressions. Once defused, expressions
will no longer evaluate on their own. They must be injected back
into an evaluation context with <code style="white-space: pre;">&#8288;!!&#8288;</code> (for a single expression) and
<code style="white-space: pre;">&#8288;!!!&#8288;</code> (for a list of expressions).
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, ...) {
  # Defuse
  var &lt;- enquo(var)
  dots &lt;- enquos(...)

  # Inject
  data %&gt;%
    group_by(!!!dots) %&gt;%
    summarise(mean = mean(!!var))
}
</pre></div>
<p>In this simple case, the code is equivalent to the usage of <code style="white-space: pre;">&#8288;{{&#8288;</code>
and <code>...</code> above. Defusing with <code>enquo()</code> or <code>enquos()</code> is only
needed in more complex cases, for instance if you need to inspect
or modify the expressions in some way.
</p>
</li>
<li><p> The <code>.data</code> pronoun is an object that represents the current
slice of data. If you have a variable name in a string, use the
<code>.data</code> pronoun to subset that variable with <code>[[</code>.
</p>
<div class="sourceCode"><pre>my_var &lt;- "disp"
mtcars %&gt;% summarise(mean = mean(.data[[my_var]]))
</pre></div>
</li>
<li><p> Another tidy eval operator is <code style="white-space: pre;">&#8288;:=&#8288;</code>. It makes it possible to use
glue and curly-curly syntax on the LHS of <code>=</code>. For technical
reasons, the R language doesn't support complex expressions on
the left of <code>=</code>, so we use <code style="white-space: pre;">&#8288;:=&#8288;</code> as a workaround.
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, suffix = "foo") {
  # Use `{{` to tunnel function arguments and the usual glue
  # operator `{` to interpolate plain strings.
  data %&gt;%
    summarise("{{ var }}_mean_{suffix}" := mean({{ var }}))
}
</pre></div>
</li>
<li><p> Many tidy eval functions like <code>dplyr::mutate()</code> or
<code>dplyr::summarise()</code> give an automatic name to unnamed inputs. If
you need to create the same sort of automatic names by yourself,
use <code>as_label()</code>. For instance, the glue-tunnelling syntax above
can be reproduced manually with:
</p>
<div class="sourceCode"><pre>my_function &lt;- function(data, var, suffix = "foo") {
  var &lt;- enquo(var)
  prefix &lt;- as_label(var)
  data %&gt;%
    summarise("{prefix}_mean_{suffix}" := mean(!!var))
}
</pre></div>
<p>Expressions defused with <code>enquo()</code> (or tunnelled with <code style="white-space: pre;">&#8288;{{&#8288;</code>) need
not be simple column names, they can be arbitrarily complex.
<code>as_label()</code> handles those cases gracefully. If your code assumes
a simple column name, use <code>as_name()</code> instead. This is safer
because it throws an error if the input is not a name as expected.
</p>
</li></ul>


<hr>
<h2 id='transform_position'>Convenience function to transform all position variables.</h2><span id='topic+transform_position'></span>

<h3>Description</h3>

<p>Convenience function to transform all position variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_position(df, trans_x = NULL, trans_y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_position_+3A_trans_x">trans_x</code>, <code id="transform_position_+3A_trans_y">trans_y</code></td>
<td>
<p>Transformation functions for x and y aesthetics.
(will transform x, xmin, xmax, xend etc)</p>
</td></tr>
<tr><td><code id="transform_position_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>trans_x</code> and <code>trans_y</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='translate_shape_string'>Translating shape strings</h2><span id='topic+translate_shape_string'></span>

<h3>Description</h3>

<p><code>translate_shape_string()</code> is a helper function for translating point shapes
given as a character vector into integers that are interpreted by the
grid system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_shape_string(shape_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_shape_string_+3A_shape_string">shape_string</code></td>
<td>
<p>A character vector giving point shapes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector with translated shapes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>translate_shape_string(c("circle", "square", "triangle"))

# Strings with 1 or less characters are interpreted as symbols
translate_shape_string(c("a", "b", "?"))
</code></pre>

<hr>
<h2 id='txhousing'>Housing sales in TX</h2><span id='topic+txhousing'></span>

<h3>Description</h3>

<p>Information about the housing market in Texas provided by the TAMU
real estate center, <a href="https://www.recenter.tamu.edu/">https://www.recenter.tamu.edu/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>txhousing
</code></pre>


<h3>Format</h3>

<p>A data frame with 8602 observations and 9 variables:
</p>

<dl>
<dt>city</dt><dd><p>Name of multiple listing service (MLS) area</p>
</dd>
<dt>year,month,date</dt><dd><p>Date</p>
</dd>
<dt>sales</dt><dd><p>Number of sales</p>
</dd>
<dt>volume</dt><dd><p>Total value of sales</p>
</dd>
<dt>median</dt><dd><p>Median sale price</p>
</dd>
<dt>listings</dt><dd><p>Total active listings</p>
</dd>
<dt>inventory</dt><dd><p>&quot;Months inventory&quot;: amount of time it would take to sell
all current listings at current pace of sales.</p>
</dd>
</dl>


<hr>
<h2 id='update_geom_defaults'>Modify geom/stat aesthetic defaults for future plots</h2><span id='topic+update_geom_defaults'></span><span id='topic+update_stat_defaults'></span>

<h3>Description</h3>

<p>Modify geom/stat aesthetic defaults for future plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_geom_defaults(geom, new)

update_stat_defaults(stat, new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_geom_defaults_+3A_new">new</code></td>
<td>
<p>Named list of aesthetics.</p>
</td></tr>
<tr><td><code id="update_geom_defaults_+3A_stat">stat</code>, <code id="update_geom_defaults_+3A_geom">geom</code></td>
<td>
<p>Name of geom/stat to modify (like <code>"point"</code> or
<code>"bin"</code>), or a Geom/Stat object (like <code>GeomPoint</code> or
<code>StatBin</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# updating a geom's default aesthetic settings
# example: change geom_point()'s default color
GeomPoint$default_aes
update_geom_defaults("point", aes(color = "red"))
GeomPoint$default_aes
ggplot(mtcars, aes(mpg, wt)) + geom_point()

# reset default
update_geom_defaults("point", aes(color = "black"))


# updating a stat's default aesthetic settings
# example: change stat_bin()'s default y-axis to the density scale
StatBin$default_aes
update_stat_defaults("bin", aes(y = after_stat(density)))
StatBin$default_aes
ggplot(data.frame(x = rnorm(1e3)), aes(x)) +
  geom_histogram() +
  geom_function(fun = dnorm, color = "red")

# reset default
update_stat_defaults("bin", aes(y = after_stat(count)))

</code></pre>

<hr>
<h2 id='update_labels'>Update axis/legend labels</h2><span id='topic+update_labels'></span>

<h3>Description</h3>

<p>Update axis/legend labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_labels(p, labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_labels_+3A_p">p</code></td>
<td>
<p>plot to modify</p>
</td></tr>
<tr><td><code id="update_labels_+3A_labels">labels</code></td>
<td>
<p>named list of new labels</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) + geom_point()
update_labels(p, list(x = "New x"))
update_labels(p, list(x = expression(x / y ^ 2)))
update_labels(p, list(x = "New x", y = "New Y"))
update_labels(p, list(colour = "Fail silently"))
</code></pre>

<hr>
<h2 id='vars'>Quote faceting variables</h2><span id='topic+vars'></span>

<h3>Description</h3>

<p>Just like <code><a href="#topic+aes">aes()</a></code>, <code>vars()</code> is a <a href="rlang.html#topic+topic-defuse">quoting function</a>
that takes inputs to be evaluated in the context of a dataset.
These inputs can be:
</p>

<ul>
<li><p> variable names
</p>
</li>
<li><p> complex expressions
</p>
</li></ul>

<p>In both cases, the results (the vectors that the variable
represents or the results of the expressions) are used to form
faceting groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vars_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+topic-data-mask">data-masking</a></code>&gt; Variables or
expressions automatically quoted. These are evaluated in the context of the
data to form faceting groups. Can be named (the names are passed to a
<a href="#topic+labellers">labeller</a>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+aes">aes()</a></code>, <code><a href="#topic+facet_wrap">facet_wrap()</a></code>, <code><a href="#topic+facet_grid">facet_grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, disp)) + geom_point()
p + facet_wrap(vars(vs, am))

# vars() makes it easy to pass variables from wrapper functions:
wrap_by &lt;- function(...) {
  facet_wrap(vars(...), labeller = label_both)
}
p + wrap_by(vs)
p + wrap_by(vs, am)

# You can also supply expressions to vars(). In this case it's often a
# good idea to supply a name as well:
p + wrap_by(drat = cut_number(drat, 3))

# Let's create another function for cutting and wrapping a
# variable. This time it will take a named argument instead of dots,
# so we'll have to use the "enquote and unquote" pattern:
wrap_cut &lt;- function(var, n = 3) {
  # Let's enquote the named argument `var` to make it auto-quoting:
  var &lt;- enquo(var)

  # `as_label()` will create a nice default name:
  nm &lt;- as_label(var)

  # Now let's unquote everything at the right place. Note that we also
  # unquote `n` just in case the data frame has a column named
  # `n`. The latter would have precedence over our local variable
  # because the data is always masking the environment.
  wrap_by(!!nm := cut_number(!!var, !!n))
}

# Thanks to tidy eval idioms we now have another useful wrapper:
p + wrap_cut(drat)
</code></pre>

<hr>
<h2 id='waiver'>A waiver object.</h2><span id='topic+waiver'></span>

<h3>Description</h3>

<p>A waiver is a &quot;flag&quot; object, similar to <code>NULL</code>, that indicates the
calling function should just use the default value.  It is used in certain
functions to distinguish between displaying nothing (<code>NULL</code>) and
displaying a default value calculated elsewhere (<code>waiver()</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waiver()
</code></pre>

<hr>
<h2 id='wrap_dims'>Arrange 1d structure into a grid</h2><span id='topic+wrap_dims'></span>

<h3>Description</h3>

<p>Arrange 1d structure into a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_dims(n, nrow = NULL, ncol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_dims_+3A_n">n</code></td>
<td>
<p>length of structure</p>
</td></tr>
<tr><td><code id="wrap_dims_+3A_nrow">nrow</code>, <code id="wrap_dims_+3A_ncol">ncol</code></td>
<td>
<p>desired dimensions for the grid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the grid dimension as a vector with nrow and then ncol
</p>

<hr>
<h2 id='zeroGrob'>The zero grob draws nothing and has zero size.</h2><span id='topic+zeroGrob'></span>

<h3>Description</h3>

<p>The zero grob draws nothing and has zero size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeroGrob()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
