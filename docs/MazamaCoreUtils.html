<!DOCTYPE html><html><head><title>Help for package MazamaCoreUtils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MazamaCoreUtils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MazamaCoreUtils'><p>Utility Functions for Production R Code</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#APIKeys'><p>API keys for data services.</p></a></li>
<li><a href='#createLocationID'><p>Create one or more unique locationIDs</p></a></li>
<li><a href='#createLocationMask'><p>Create a mask of valid locations</p></a></li>
<li><a href='#dateRange'><p>Create a POSIXct date range</p></a></li>
<li><a href='#dateSequence'><p>Create a POSIXct date sequence</p></a></li>
<li><a href='#flog.appender'><p>Manage appenders for loggers</p></a></li>
<li><a href='#flog.layout'><p>Manage logger layouts</p></a></li>
<li><a href='#flog.logger'><p>Manage loggers</p></a></li>
<li><a href='#getAPIKey'><p>Get API key</p></a></li>
<li><a href='#html_getLinks'><p>Find all links in an html page</p></a></li>
<li><a href='#html_getTables'><p>Find all tables in an html page</p></a></li>
<li><a href='#initializeLogging'><p>Initialize standard log files</p></a></li>
<li><a href='#lintFunctionArgs'><p>Lint a source file's function arguments</p></a></li>
<li><a href='#loadDataFile'><p>Load data from URL or local file</p></a></li>
<li><a href='#logger.debug'><p>Python-style logging statements</p></a></li>
<li><a href='#logger.error'><p>Python-style logging statements</p></a></li>
<li><a href='#logger.fatal'><p>Python-style logging statements</p></a></li>
<li><a href='#logger.info'><p>Python-style logging statements</p></a></li>
<li><a href='#logger.isInitialized'><p>Check for initialization of loggers</p></a></li>
<li><a href='#logger.setLevel'><p>Set console log level</p></a></li>
<li><a href='#logger.setup'><p>Set up python-style logging</p></a></li>
<li><a href='#logger.trace'><p>Python-style logging statements</p></a></li>
<li><a href='#logger.warn'><p>Python-style logging statements</p></a></li>
<li><a href='#logLevels'><p>Log levels</p></a></li>
<li><a href='#manageCache'><p>Manage the size of a cache</p></a></li>
<li><a href='#packageCheck'><p>Run package checks</p></a></li>
<li><a href='#parseDatetime'><p>Parse datetime strings</p></a></li>
<li><a href='#setAPIKey'><p>Set APIKey</p></a></li>
<li><a href='#setIfNull'><p>Set a variable to a default value if it is NULL</p></a></li>
<li><a href='#showAPIKeys'><p>Show API keys</p></a></li>
<li><a href='#stopIfNull'><p>Stop if an object is NULL</p></a></li>
<li><a href='#stopOnError'><p>Error message generator</p></a></li>
<li><a href='#tidyeval-data'><p>Data pronoun for tidy evaluation</p></a></li>
<li><a href='#timeRange'><p>Create a POSIXct time range</p></a></li>
<li><a href='#timeStamp'><p>Character representation of a POSIXct</p></a></li>
<li><a href='#timezoneLintRules'><p>Rules for timezone linting.</p></a></li>
<li><a href='#validateLonLat'><p>Validate longitude and latitude values</p></a></li>
<li><a href='#validateLonsLats'><p>Validate longitude and latitude vectors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Utility Functions for Production R Code</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Callahan &lt;jonathan.s.callahan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of utility functions providing functionality commonly
    needed for production level projects such as logging, error handling,
    cache management and date-time parsing. Functions for date-time parsing and 
    formatting require that time zones be specified explicitly, avoiding a common 
    source of error when working with environmental time series.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MazamaScience/MazamaCoreUtils">https://github.com/MazamaScience/MazamaCoreUtils</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MazamaScience/MazamaCoreUtils/issues">https://github.com/MazamaScience/MazamaCoreUtils/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>devtools, digest, dplyr, futile.logger, geohashTools,
lubridate, magrittr, purrr, rlang (&ge; 1.1.0), rvest, stringr,
tibble, xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, testthat (&ge; 3.1.7), rmarkdown, roxygen2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 17:52:16 UTC; jonathancallahan</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Callahan [aut, cre],
  Eli Grosman [ctb],
  Spencer Pease [ctb],
  Thomas Bergamaschi [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MazamaCoreUtils'>Utility Functions for Production R Code</h2><span id='topic+MazamaCoreUtils'></span><span id='topic+MazamaCoreUtils-package'></span>

<h3>Description</h3>

<p>The MazamaCoreUtils package was created by MazamaScience to
regularize our work building R-based web services.
</p>
<p>The main goal of this package is to create an internally standardized set of
functions that we can use in various systems that are being run
operationally. Areas of functionality supported by this package include:
</p>

<ul>
<li><p> python style logging 
</p>
</li>
<li><p> simple error messaging 
</p>
</li>
<li><p> cache management 
</p>
</li>
<li><p> API key handling 
</p>
</li>
<li><p> date parsing and formatting 
</p>
</li>
<li><p> lat/lon validation and uniqueID creation 
</p>
</li>
<li><p> source code linting 
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='APIKeys'>API keys for data services.</h2><span id='topic+APIKeys'></span>

<h3>Description</h3>

<p>This package maintains an internal set of API keys which
users can set using <code>setAPIKey()</code>. These keys will be remembered for
the duration of an R session. This functionality provides an abstraction
layer in dependent packages so that data access functions can test for and
access specific API keys with generic code.
</p>


<h3>Format</h3>

<p>List of character strings.
</p>


<h3>See Also</h3>

<p><a href="#topic+getAPIKey">getAPIKey</a>
</p>
<p><a href="#topic+setAPIKey">setAPIKey</a>
</p>
<p><a href="#topic+showAPIKeys">showAPIKeys</a>
</p>

<hr>
<h2 id='createLocationID'>Create one or more unique locationIDs</h2><span id='topic+createLocationID'></span>

<h3>Description</h3>

<p>A locationID is created for each incoming <code>longitude</code> and
<code>latitude</code>. Each locationID is unique to within a certain spatial scale.
With <code>algorithm = "geohash"</code>, the
<code>precision</code> argument determines the size of a geohash grid cell. At the
equator, the following grid cell sizes apply for different precision levels:
</p>
<pre>
precision   (maximum grid cell X axis, in m)
        5   ± 2400
        6   ± 610
        7   ± 76
        8   ± 19
        9   ± 2.4
       10   ± 0.6
</pre>
<p>Invalid locations will be assigned a locationID specified by the user with
the <code>invalidID</code> argument, typically <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLocationID(
  longitude = NULL,
  latitude = NULL,
  algorithm = c("geohash", "digest"),
  precision = 10,
  invalidID = as.character(NA)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createLocationID_+3A_longitude">longitude</code></td>
<td>
<p>Vector of longitudes in decimal degrees E.</p>
</td></tr>
<tr><td><code id="createLocationID_+3A_latitude">latitude</code></td>
<td>
<p>Vector of latitudes in decimal degrees N.</p>
</td></tr>
<tr><td><code id="createLocationID_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm to use &ndash; either <code>"geohash"</code> or <code>"digest"</code>.</p>
</td></tr>
<tr><td><code id="createLocationID_+3A_precision">precision</code></td>
<td>
<p><code>precision</code> argument used when encoding with <code>"geohash"</code>.</p>
</td></tr>
<tr><td><code id="createLocationID_+3A_invalidid">invalidID</code></td>
<td>
<p>Identifier to use for invalid locations. This can be a
character string or <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the <code>"geohash"</code> algorithm is specified,
the following code is used to generate each locationID:
</p>
<pre>
  locationID &lt;-
    geohashTools::gh_encode(latitude, longitude, precision)
</pre>
<p>When the <code>"digest"</code> algorithm is specified,
the following code is used:
</p>
<pre>
# Retain accuracy up to ~.1m
locationString &lt;- paste0(
  sprintf("%.7f", longitude),
  "_",
  sprintf("%.7f", latitude)
)
# Avoid collisions until billions of records
locationID &lt;- digest::digest(locationString, algo = "xxhash64")
</pre>
<p>See the references for details on either algorithm.
</p>


<h3>Value</h3>

<p>Vector of character locationIDs.
</p>


<h3>Note</h3>

<p>The <code>"geohash"</code> algorithm is preferred but the <code>"digest"</code>
algorithm is retained because several existing databases
use the <code>"digest"</code> algorithm as a unique identifier.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Decimal_degrees">https://en.wikipedia.org/wiki/Decimal_degrees</a>
</p>
<p><a href="https://www.johndcook.com/blog/2017/01/10/probability-of-secure-hash-collisions/">https://www.johndcook.com/blog/2017/01/10/probability-of-secure-hash-collisions/</a>
</p>
<p><a href="https://michaelchirico.github.io/geohashTools/index.html">https://michaelchirico.github.io/geohashTools/index.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

longitude &lt;- c(-122.5, 0, NA, -122.5, -122.5)
latitude &lt;- c( 47.5, 0, 47.5, NA, 47.5)

createLocationID(longitude, latitude)
createLocationID(longitude, latitude, invalidID = "bad")
createLocationID(longitude, latitude, algorithm = "digest")

</code></pre>

<hr>
<h2 id='createLocationMask'>Create a mask of valid locations</h2><span id='topic+createLocationMask'></span>

<h3>Description</h3>

<p>A logical vector is created with either <code>TRUE</code> or
<code>FALSE</code> for each incoming <code>longitude, latitude</code> pair with
<code>TRUE</code> indicating a valid location. This can be used to filter dataframes
to retain only records with valid locations.
</p>
<p><code>lonRange</code> and <code>latRange</code> can be used to create a valid-mask for
locations within a rectangular area.
</p>
<p><code>removeZeroZero</code> will invalidate the location <code>0.0, 0.0</code> which is
sometimes seen in poorly QC'ed datasets.
</p>
<p><code>NA</code> values found in <code>longitude</code> or <code>latitude</code> will result
in a mask value of <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLocationMask(
  longitude = NULL,
  latitude = NULL,
  lonRange = c(-180, 180),
  latRange = c(-90, 90),
  removeZeroZero = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createLocationMask_+3A_longitude">longitude</code></td>
<td>
<p>Vector of longitudes in decimal degrees E.</p>
</td></tr>
<tr><td><code id="createLocationMask_+3A_latitude">latitude</code></td>
<td>
<p>Vector of latitudes in decimal degrees N.</p>
</td></tr>
<tr><td><code id="createLocationMask_+3A_lonrange">lonRange</code></td>
<td>
<p>Range of valid longitudes.</p>
</td></tr>
<tr><td><code id="createLocationMask_+3A_latrange">latRange</code></td>
<td>
<p>Range of valid latitudes.</p>
</td></tr>
<tr><td><code id="createLocationMask_+3A_removezerozero">removeZeroZero</code></td>
<td>
<p>Logical indicating whether locations at <code>0.0, 0.0</code>
should be marked as invalid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of logical values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

createLocationMask(
  longitude = c(-120, NA, -120, -220, -120, 0),
  latitude = c(45, 45, NA, 45, 100, 0)
)

createLocationMask(
  longitude = c(-120:-90),
  latitude = c(20:50),
  lonRange = c(-110, -100),
  latRange = c(30, 40)
)

</code></pre>

<hr>
<h2 id='dateRange'>Create a POSIXct date range</h2><span id='topic+dateRange'></span>

<h3>Description</h3>

<p>Uses incoming parameters to return a pair of <code>POSIXct</code> times in the
proper order. The first returned time will be midnight of the desired
starting date. The second returned time will represent the &quot;end of the day&quot;
of the requested or calculated <code>enddate</code> boundary.
</p>
<p>Note that the returned end date will be one <code>unit</code> prior to the start
of the requested <code>enddate</code> unless <code>ceilingEnd = TRUE</code> in
which case the entire <code>enddate</code> will be included up to the last
<code>unit</code>.
</p>
<p>The <code>ceilingEnd</code> argument addresses the ambiguity of a phrase like:
&quot;August 1-8&quot;. With <code>ceilingEnd = FALSE</code> (default) this pharse means
&quot;through the beginning of Aug 8&quot;. With <code>ceilingEnd = TRUE</code> it means
&quot;through the end of Aug 8&quot;.
</p>
<p>So, to get 24 hours of data staring on Jan 01, 2019 you would specify:
</p>
<pre>
&gt; MazamaCoreUtils::dateRange(20190101, 20190102, timezone = "UTC")
[1] "2019-01-01 00:00:00 UTC" "2019-01-01 23:59:59 UTC"
</pre>
<p>or
</p>
<pre>
&gt; MazamaCoreUtils::dateRange(20190101, 20190101,
                             timezone = "UTC", ceilingEnd = TRUE)
[1] "2019-01-01 00:00:00 UTC" "2019-01-01 23:59:59 UTC"
</pre>
<p>The required <code>timezone</code> parameter must be one of those found in
<code><a href="base.html#topic+OlsonNames">OlsonNames</a></code>.
</p>
<p>Dates can be anything that is understood by
<code>lubrdiate::parse_date_time()</code> using the <code>Ymd[HMS]</code> orders. This
includes:
</p>

<ul>
<li><p><code>"YYYYmmdd"</code>
</p>
</li>
<li><p><code>"YYYYmmddHHMMSS"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd H"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd H:M"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd H:M:S"</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dateRange(
  startdate = NULL,
  enddate = NULL,
  timezone = NULL,
  unit = "sec",
  ceilingStart = FALSE,
  ceilingEnd = FALSE,
  days = 7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dateRange_+3A_startdate">startdate</code></td>
<td>
<p>Desired start datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="dateRange_+3A_enddate">enddate</code></td>
<td>
<p>Desired end datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="dateRange_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates (required).</p>
</td></tr>
<tr><td><code id="dateRange_+3A_unit">unit</code></td>
<td>
<p>Units used to determine time at end-of-day.</p>
</td></tr>
<tr><td><code id="dateRange_+3A_ceilingstart">ceilingStart</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>startdate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code></p>
</td></tr>
<tr><td><code id="dateRange_+3A_ceilingend">ceilingEnd</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>enddate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code></p>
</td></tr>
<tr><td><code id="dateRange_+3A_days">days</code></td>
<td>
<p>Number of days of data to include.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of two <code>POSIXct</code>s.
</p>


<h3>Default Arguments</h3>

<p>In the case when either <code>startdate</code> or <code>enddate</code> is missing, it is
created from the non-missing values plus/minus <code>days</code>. If both
<code>startdate</code> and <code>enddate</code> are misssing, <code>enddate</code> is set to
<code><a href="lubridate.html#topic+now">now</a></code> (with the given <code>timezone</code>), and then
<code>startdate</code> is calculated using <code>enddate - days</code>.
</p>


<h3>End-of-Day Units</h3>

<p>The second of the returned <code>POSIXct</code>s will end one <code>unit</code> before
the specified <code>enddate</code>. Acceptable units are <code>"day",
"hour", "min", "sec"</code>.
</p>
<p>The aim is to quickly calculate full-day date ranges for time series whose
values are binned at different units. Thus, if <code>unit = "min"</code>, the
returned value associated with <code>enddate</code> will always be at 23:59:00
in the requested time zone.
</p>


<h3>POSIXct inputs</h3>

<p>When <code>startdate</code> or <code>enddate</code> are already <code>POSIXct</code> values,
they are converted to the timezone specified by <code>timezone</code> without
altering the physical instant in time the input represents. This is different
from the behavior of <code><a href="lubridate.html#topic+parse_date_time">parse_date_time</a></code> (which powers
this function), which will force <code>POSIXct</code> inputs into a new timezone,
altering the physical moment of time the input represents.
</p>


<h3>Parameter precedence</h3>

<p>It is possible to supply input paramters that are in conflict. For example:
</p>
<p><code>dateRange("2019-01-01", "2019-01-08", days = 3, timezone = "UTC")</code>
</p>
<p>The <code>startdate</code> and <code>enddate</code> parameters would imply a 7-day range
which is in conflict with <code>days = 3</code>. The following rules resolve
conflicts of this nature:
</p>

<ol>
<li><p>When <code>startdate</code> and <code>enddate</code> are both specified, the
<code>days</code> parameter is ignored.
</p>
</li>
<li><p>When <code>startdate</code> is missing, <code>ceilingStart</code> is ignored and
the first returned time will depend on the combination of <code>enddate</code>,
<code>days</code> and <code>ceilingEnd</code>.
</p>
</li>
<li><p>When <code>enddate</code> is missing, <code>ceilingEnd</code> is ignored and the
second returned time depends on <code>ceilingStart</code> and <code>days</code>.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

dateRange("2019-01-08", timezone = "UTC")
dateRange("2019-01-08", unit = "min", timezone = "UTC")
dateRange("2019-01-08", unit = "hour", timezone = "UTC")
dateRange("2019-01-08", unit = "day", timezone = "UTC")
dateRange("2019-01-08", "2019-01-11", timezone = "UTC")
dateRange(enddate = 20190112, days = 3,
          unit = "day", timezone = "America/Los_Angeles")
</code></pre>

<hr>
<h2 id='dateSequence'>Create a POSIXct date sequence</h2><span id='topic+dateSequence'></span>

<h3>Description</h3>

<p>Uses incoming parameters to return a seqeunce of <code>POSIXct</code> times at
local midnight in the specified <code>timezone</code>. The first returned time will
be midnight of the requested <code>startdate</code>. The final returned time will
be midnight (<em>at the beginning</em>) of the requested <code>enddate</code>.
</p>
<p>The <code>ceilingEnd</code> argument addresses the ambiguity of a phrase like:
&quot;August 1-8&quot;. With <code>ceilingEnd = FALSE</code> (default) this pharse means
&quot;through the beginning of Aug 8&quot;. With <code>ceilingEnd = TRUE</code> it means
&quot;through the end of Aug 8&quot;.
</p>
<p>The required <code>timezone</code> parameter must be one of those found in
<code><a href="base.html#topic+OlsonNames">OlsonNames</a></code>.
</p>
<p>Dates can be anything that is understood by
<code>lubrdiate::parse_date_time()</code> using the <code>Ymd[HMS]</code> orders. This
includes:
</p>

<ul>
<li><p><code>"YYYYmmdd"</code>
</p>
</li>
<li><p><code>"YYYYmmddHHMMSS"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd H"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd H:M"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd H:M:S"</code>
</p>
</li></ul>

<p>All hour-minute-second information is removed after parsing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateSequence(
  startdate = NULL,
  enddate = NULL,
  timezone = NULL,
  ceilingEnd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dateSequence_+3A_startdate">startdate</code></td>
<td>
<p>Desired start datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="dateSequence_+3A_enddate">enddate</code></td>
<td>
<p>Desired end datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="dateSequence_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates (required).</p>
</td></tr>
<tr><td><code id="dateSequence_+3A_ceilingend">ceilingEnd</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>enddate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>POSIXct</code>s at midnight local time.
</p>


<h3>POSIXct inputs</h3>

<p>When <code>startdate</code> or <code>enddate</code> are already <code>POSIXct</code> values,
they are converted to the timezone specified by <code>timezone</code> without
altering the physical instant in time the input represents. Only after
conversion are they floored to midnight local time
</p>


<h3>Note</h3>

<p>The main utility of this function is that it respects &quot;clock time&quot; and
returns times associated with midnight regardless of daylight savings. This
is in contrast to 'seq.Date(from, to, by = &quot;day&quot;)' which creates a sequence
of datetimes always separated by 24 hours.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

dateSequence("2019-11-01", "2019-11-08", timezone = "America/Los_Angeles")
dateSequence("2019-11-01", "2019-11-07", timezone = "America/Los_Angeles",
             ceilingEnd = TRUE)

# Observe the handling of daylight savings
datetime &lt;- dateSequence("2019-11-01", "2019-11-08",
                         timezone = "America/Los_Angeles")

datetime
lubridate::with_tz(datetime, "UTC")

# Passing in POSIXct values preserves the instant in time before flooring --
#   midnight Tokyo time is the day before in UTC
jst &lt;- dateSequence(20190307, 20190315, timezone = "Asia/Tokyo")
jst
dateSequence(jst[1], jst[7], timezone = "UTC")

</code></pre>

<hr>
<h2 id='flog.appender'>Manage appenders for loggers</h2><span id='topic+flog.appender'></span>

<h3>Description</h3>

<p>See <code>futile.logger::<a href="futile.logger.html#topic+flog.appender">flog.appender</a></code> for details.
</p>

<hr>
<h2 id='flog.layout'>Manage logger layouts</h2><span id='topic+flog.layout'></span>

<h3>Description</h3>

<p>See <code>futile.logger::<a href="futile.logger.html#topic+flog.layout">flog.layout</a></code> for details.
</p>

<hr>
<h2 id='flog.logger'>Manage loggers</h2><span id='topic+flog.logger'></span>

<h3>Description</h3>

<p>See <code>futile.logger::<a href="futile.logger.html#topic+flog.logger">flog.logger</a></code> for details.
</p>

<hr>
<h2 id='getAPIKey'>Get API key</h2><span id='topic+getAPIKey'></span>

<h3>Description</h3>

<p>Returns the API key associated with a web service.
If <code>provider == NULL</code> a list is returned containing all recognized
API keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAPIKey(provider = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAPIKey_+3A_provider">provider</code></td>
<td>
<p>Web service provider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>API key string or a list of provider:key pairs.
</p>


<h3>See Also</h3>

<p><a href="#topic+APIKeys">APIKeys</a>
</p>
<p><a href="#topic+setAPIKey">setAPIKey</a>
</p>
<p><a href="#topic+showAPIKeys">showAPIKeys</a>
</p>

<hr>
<h2 id='html_getLinks'>Find all links in an html page</h2><span id='topic+html_getLinks'></span><span id='topic+html_getLinkNames'></span><span id='topic+html_getLinkUrls'></span>

<h3>Description</h3>

<p>Parses an html page to extract all <code>&lt;a href="..."&gt;...&lt;/a&gt;</code>
links and return them in a dataframe where <code>linkName</code> is the human
readable name and <code>linkUrl</code> is the <code>href</code> portion. By default this
function will return relative URLs.
</p>
<p>This is especially useful for extracting data from an index page that shows
the contents of a web accessible directory.
</p>
<p>Wrapper functions <code>html_getLinkNames()</code> and <code>html_getLinkUrls()</code>
return the appropriate columns as vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_getLinks(url = NULL, relative = TRUE)

html_getLinkNames(url = NULL)

html_getLinkUrls(url = NULL, relative = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_getLinks_+3A_url">url</code></td>
<td>
<p>URL or file path of an html page.</p>
</td></tr>
<tr><td><code id="html_getLinks_+3A_relative">relative</code></td>
<td>
<p>Logical instruction to return relative URLs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with <code>linkName</code> and/or <code>linkUrl</code> columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

# Fail gracefully if the resource is not available
try({

  # US Census 2019 shapefiles
  url &lt;- "https://www2.census.gov/geo/tiger/GENZ2019/shp/"

  # Extract links
  dataLinks &lt;- html_getLinks(url)

  dataLinks &lt;- dataLinks %&gt;%
    dplyr::filter(stringr::str_detect(linkName, "us_county"))
  head(dataLinks, 10)

}, silent = FALSE)

</code></pre>

<hr>
<h2 id='html_getTables'>Find all tables in an html page</h2><span id='topic+html_getTables'></span><span id='topic+html_getTable'></span>

<h3>Description</h3>

<p>Parses an html page to extract all <code>&lt;table&gt;</code> elements and
return them in a list of dataframes representing each table. The columns and
rows of these dataframes are that of the table it represents. A single table
can be extracted as a dataframe by passing the index of the table in addition
to the url to <code>html_getTable()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_getTables(url = NULL, header = NA)

html_getTable(url = NULL, header = NA, index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_getTables_+3A_url">url</code></td>
<td>
<p>URL or file path of an html page.</p>
</td></tr>
<tr><td><code id="html_getTables_+3A_header">header</code></td>
<td>
<p>Use first row as header? If NA, will use first row if it
consists of &lt;th&gt; tags.</p>
</td></tr>
<tr><td><code id="html_getTables_+3A_index">index</code></td>
<td>
<p>Index identifying which table to to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dataframes representing each table on a html page.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

# Fail gracefully if the resource is not available
try({

  # Wikipedia's list of timezones
  url &lt;- "http://en.wikipedia.org/wiki/List_of_tz_database_time_zones"

  # Extract tables
  tables &lt;- html_getTables(url)

  # Extract the first table
  # NOTE: Analogous to firstTable &lt;- html_getTable(url, index = 1)
  firstTable &lt;- tables[[1]]

  head(firstTable)
  nrow(firstTable)

}, silent = FALSE)

</code></pre>

<hr>
<h2 id='initializeLogging'>Initialize standard log files</h2><span id='topic+initializeLogging'></span>

<h3>Description</h3>

<p>Convenience function that wraps common logging initialization steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initializeLogging(logDir = NULL, filePrefix = "", createDir = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initializeLogging_+3A_logdir">logDir</code></td>
<td>
<p>Directory in which to write log files.</p>
</td></tr>
<tr><td><code id="initializeLogging_+3A_fileprefix">filePrefix</code></td>
<td>
<p>Character string prepended to log files.</p>
</td></tr>
<tr><td><code id="initializeLogging_+3A_createdir">createDir</code></td>
<td>
<p>Logical specifying whether to create a missing <code>logDir</code>
or issue an error message.</p>
</td></tr>
</table>

<hr>
<h2 id='lintFunctionArgs'>Lint a source file's function arguments</h2><span id='topic+lintFunctionArgs'></span><span id='topic+lintFunctionArgs_file'></span><span id='topic+lintFunctionArgs_dir'></span>

<h3>Description</h3>

<p>This function parses an R Script file, grouping function calls and the named
arguments passed to those functions. Then, based on a set of rules, it is
determined if functions of interest have specific named arguments specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lintFunctionArgs_file(filePath = NULL, rules = NULL, fullPath = FALSE)

lintFunctionArgs_dir(dirPath = "./R", rules = NULL, fullPath = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lintFunctionArgs_+3A_filepath">filePath</code></td>
<td>
<p>Path to a file, given as a length one character vector.</p>
</td></tr>
<tr><td><code id="lintFunctionArgs_+3A_rules">rules</code></td>
<td>
<p>A named list where the name of each element is a function name,
and the value is a character vector of the named argument to check for. All
arguments must be specified for a function to &quot;pass&quot;.</p>
</td></tr>
<tr><td><code id="lintFunctionArgs_+3A_fullpath">fullPath</code></td>
<td>
<p>Logical specifying whether to display absolute paths.</p>
</td></tr>
<tr><td><code id="lintFunctionArgs_+3A_dirpath">dirPath</code></td>
<td>
<p>Path to a directory, given as a length one character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> detailing the results of the lint.
</p>


<h3>Linting Output</h3>

<p>The output of the function argument linter is a tibble with the following
columns:
</p>

<dl>
<dt>file_path</dt><dd><p>path to the source file</p>
</dd>
<dt>line_number</dt><dd><p>Line of the source file the function is on</p>
</dd>
<dt>column_number</dt><dd><p>Column of the source file the function starts at</p>
</dd>
<dt>function_name</dt><dd><p>The name of the function</p>
</dd>
<dt>named_args</dt><dd><p>A vector of the named arguments passed to the function</p>
</dd>
<dt>includes_required</dt><dd><p>True iff the function specifies all of the named
arguments required by the given rules</p>
</dd>
</dl>



<h3>Limitations</h3>

<p>This function is only able to test for named arguments passed to a function.
For example, it would report that <code>foo(x = bar, "baz")</code> has specified
the named argument <code>x</code>, but not that <code>bar</code> was the value of the
argument, or that <code>"baz"</code> had been passed as an unnamed argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(MazamaCoreUtils)

# Example rule list for checking
exRules &lt;- list(
  "fn_one" = "x",
  "fn_two" = c("foo", "bar")
)

# Example of using included timezone argument linter
lintFunctionArgs_file(
  "local_test/timezone_lint_test_script.R",
  MazamaCoreUtils::timezoneLintRules
)

## End(Not run)
</code></pre>

<hr>
<h2 id='loadDataFile'>Load data from URL or local file</h2><span id='topic+loadDataFile'></span>

<h3>Description</h3>

<p>Loads pre-generated R binary files from a URL or a local
directory. This function is intended to be called by other <code>~_load()</code>
functions and can remove internet latencies when local versions of data are
available.
</p>
<p>For this reason, specification of <code>dataDir</code> always takes precedence over
<code>dataUrl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadDataFile(filename = NULL, dataUrl = NULL, dataDir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadDataFile_+3A_filename">filename</code></td>
<td>
<p>Name of the data file to be loaded.</p>
</td></tr>
<tr><td><code id="loadDataFile_+3A_dataurl">dataUrl</code></td>
<td>
<p>Remote URL directory for data files.</p>
</td></tr>
<tr><td><code id="loadDataFile_+3A_datadir">dataDir</code></td>
<td>
<p>Local directory containing data files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data object.
</p>

<hr>
<h2 id='logger.debug'>Python-style logging statements</h2><span id='topic+logger.debug'></span>

<h3>Description</h3>

<p>After initializing the level-specific log files with <code>logger.setup(...)</code>,
this function will generate <code>DEBUG</code> level log statements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger.debug(msg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logger.debug_+3A_msg">msg</code></td>
<td>
<p>Message with format strings applied to additional arguments.</p>
</td></tr>
<tr><td><code id="logger.debug_+3A_...">...</code></td>
<td>
<p>Additional arguments to be formatted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>All functionality is built on top of the excellent <span class="pkg">futile.logger</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger.setup">logger.setup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Only save three log files
logger.setup(
  debugLog = "debug.log",
  infoLog = "info.log",
  errorLog = "error.log"
)

# But allow log statements at all levels within the code
logger.trace("trace statement #%d", 1)
logger.debug("debug statement")
logger.info("info statement %s %s", "with", "arguments")
logger.warn("warn statement %s", "about to try something dumb")
result &lt;- try(1/"a", silent=TRUE)
logger.error("error message: %s", geterrmessage())
logger.fatal("fatal statement %s", "THE END")

## End(Not run)
</code></pre>

<hr>
<h2 id='logger.error'>Python-style logging statements</h2><span id='topic+logger.error'></span>

<h3>Description</h3>

<p>After initializing the level-specific log files with <code>logger.setup(...)</code>,
this function will generate <code>ERROR</code> level log statements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger.error(msg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logger.error_+3A_msg">msg</code></td>
<td>
<p>Message with format strings applied to additional arguments.</p>
</td></tr>
<tr><td><code id="logger.error_+3A_...">...</code></td>
<td>
<p>Additional arguments to be formatted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>All functionality is built on top of the excellent <span class="pkg">futile.logger</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger.setup">logger.setup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Only save three log files
logger.setup(
  debugLog = "debug.log",
  infoLog = "info.log",
  errorLog = "error.log"
)

# But allow log statements at all levels within the code
logger.trace("trace statement #%d", 1)
logger.debug("debug statement")
logger.info("info statement %s %s", "with", "arguments")
logger.warn("warn statement %s", "about to try something dumb")
result &lt;- try(1/"a", silent=TRUE)
logger.error("error message: %s", geterrmessage())
logger.fatal("fatal statement %s", "THE END")

## End(Not run)
</code></pre>

<hr>
<h2 id='logger.fatal'>Python-style logging statements</h2><span id='topic+logger.fatal'></span>

<h3>Description</h3>

<p>After initializing the level-specific log files with <code>logger.setup(...)</code>,
this function will generate <code>FATAL</code> level log statements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger.fatal(msg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logger.fatal_+3A_msg">msg</code></td>
<td>
<p>Message with format strings applied to additional arguments.</p>
</td></tr>
<tr><td><code id="logger.fatal_+3A_...">...</code></td>
<td>
<p>Additional arguments to be formatted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>All functionality is built on top of the excellent <span class="pkg">futile.logger</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger.setup">logger.setup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Only save three log files
logger.setup(
  debugLog = "debug.log",
  infoLog = "info.log",
  errorLog = "error.log"
)

# But allow log statements at all levels within the code
logger.trace("trace statement #%d", 1)
logger.debug("debug statement")
logger.info("info statement %s %s", "with", "arguments")
logger.warn("warn statement %s", "about to try something dumb")
result &lt;- try(1/"a", silent=TRUE)
logger.error("error message: %s", geterrmessage())
logger.fatal("fatal statement %s", "THE END")

## End(Not run)
</code></pre>

<hr>
<h2 id='logger.info'>Python-style logging statements</h2><span id='topic+logger.info'></span>

<h3>Description</h3>

<p>After initializing the level-specific log files with <code>logger.setup(...)</code>,
this function will generate <code>INFO</code> level log statements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger.info(msg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logger.info_+3A_msg">msg</code></td>
<td>
<p>Message with format strings applied to additional arguments.</p>
</td></tr>
<tr><td><code id="logger.info_+3A_...">...</code></td>
<td>
<p>Additional arguments to be formatted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>All functionality is built on top of the excellent <span class="pkg">futile.logger</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger.setup">logger.setup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Only save three log files
logger.setup(
  debugLog = "debug.log",
  infoLog = "info.log",
  errorLog = "error.log"
)

# But allow log statements at all levels within the code
logger.trace("trace statement #%d", 1)
logger.debug("debug statement")
logger.info("info statement %s %s", "with", "arguments")
logger.warn("warn statement %s", "about to try something dumb")
result &lt;- try(1/"a", silent=TRUE)
logger.error("error message: %s", geterrmessage())
logger.fatal("fatal statement %s", "THE END")

## End(Not run)
</code></pre>

<hr>
<h2 id='logger.isInitialized'>Check for initialization of loggers</h2><span id='topic+logger.isInitialized'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if logging has been initialized. This allows packages
to emit logging statements only if logging has already been set up,
potentially avoiding 'futile.log' errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger.isInitialized()
</code></pre>


<h3>Value</h3>

<p><code>TRUE</code> if logging has already been initialized.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger.setup">logger.setup</a></code>
</p>
<p><code><a href="#topic+initializeLogging">initializeLogging</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
logger.isInitialized()
logger.setup()
logger.isInitialized()

## End(Not run)

</code></pre>

<hr>
<h2 id='logger.setLevel'>Set console log level</h2><span id='topic+logger.setLevel'></span>

<h3>Description</h3>

<p>By default, the logger threshold is set to <code>FATAL</code> so that the console
will typically receive no log messages. By setting the level to one of the
other log levels: <code>TRACE, DEBUG, INFO, WARN, ERROR</code> users can see
logging messages while running commands at the command line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger.setLevel(level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logger.setLevel_+3A_level">level</code></td>
<td>
<p>Threshold level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>All functionality is built on top of the excellent <span class="pkg">futile.logger</span>
package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger.setup">logger.setup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Set up console logging only
logger.setup()
logger.setLevel(DEBUG)

## End(Not run)

</code></pre>

<hr>
<h2 id='logger.setup'>Set up python-style logging</h2><span id='topic+logger.setup'></span>

<h3>Description</h3>

<p>Good logging allows package developers and users to create log files at
different levels to track and debug lengthy or complex calculations.
&quot;Python-style&quot; logging is intended to suggest that users should set up
multiple log files for different log severities so that the <code>errorLog</code>
will contain only log messages at or above the <code>ERROR</code> level while a
<code>debugLog</code> will contain log messages at the <code>DEBUG</code> level as well
as all higher levels.
</p>
<p>Python-style log files are set up with <code>logger.setup()</code>. Logs can be set
up for any combination of log levels. Accepting the default <code>NULL</code>
setting for any log file simply means that log file will not be created.
</p>
<p>Python-style logging requires the use of <code>logger.debug()</code> style logging
statements as seen in the example below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger.setup(
  traceLog = NULL,
  debugLog = NULL,
  infoLog = NULL,
  warnLog = NULL,
  errorLog = NULL,
  fatalLog = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logger.setup_+3A_tracelog">traceLog</code></td>
<td>
<p>File name or full path where <code>logger.trace()</code> messages
will be sent.</p>
</td></tr>
<tr><td><code id="logger.setup_+3A_debuglog">debugLog</code></td>
<td>
<p>File name or full path where <code>logger.debug()</code> messages
will be sent.</p>
</td></tr>
<tr><td><code id="logger.setup_+3A_infolog">infoLog</code></td>
<td>
<p>File name or full path where <code>logger.info()</code> messages
will be sent.</p>
</td></tr>
<tr><td><code id="logger.setup_+3A_warnlog">warnLog</code></td>
<td>
<p>File name or full path where <code>logger.warn()</code> messages
will be sent.</p>
</td></tr>
<tr><td><code id="logger.setup_+3A_errorlog">errorLog</code></td>
<td>
<p>File name or full path where <code>logger.error()</code> messages
will be sent.</p>
</td></tr>
<tr><td><code id="logger.setup_+3A_fatallog">fatalLog</code></td>
<td>
<p>File name or full path where <code>logger.fatal()</code> messages
will be sent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>All functionality is built on top of the excellent <span class="pkg">futile.logger</span>
package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger.trace">logger.trace</a></code> <code><a href="#topic+logger.debug">logger.debug</a></code>
<code><a href="#topic+logger.info">logger.info</a></code> <code><a href="#topic+logger.warn">logger.warn</a></code>
<code><a href="#topic+logger.error">logger.error</a></code> <code><a href="#topic+logger.fatal">logger.fatal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(MazamaCoreUtils)

# Only save three log files
logger.setup(
  debugLog = "debug.log",
  infoLog = "info.log",
  errorLog = "error.log"
)

# But allow lot statements at all levels within the code
logger.trace("trace statement #%d", 1)
logger.debug("debug statement")
logger.info("info statement %s %s", "with", "arguments")
logger.warn("warn statement %s", "about to try something dumb")
result &lt;- try(1/"a", silent=TRUE)
logger.error("error message: %s", geterrmessage())
logger.fatal("fatal statement %s", "THE END")

## End(Not run)

</code></pre>

<hr>
<h2 id='logger.trace'>Python-style logging statements</h2><span id='topic+logger.trace'></span>

<h3>Description</h3>

<p>After initializing the level-specific log files with <code>logger.setup(...)</code>,
this function will generate <code>TRACE</code> level log statements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger.trace(msg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logger.trace_+3A_msg">msg</code></td>
<td>
<p>Message with format strings applied to additional arguments.</p>
</td></tr>
<tr><td><code id="logger.trace_+3A_...">...</code></td>
<td>
<p>Additional arguments to be formatted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>All functionality is built on top of the excellent <span class="pkg">futile.logger</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger.setup">logger.setup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Only save three log files
logger.setup(
  debugLog = "debug.log",
  infoLog = "info.log",
  errorLog = "error.log"
)

# But allow log statements at all levels within the code
logger.trace("trace statement #%d", 1)
logger.debug("debug statement")
logger.info("info statement %s %s", "with", "arguments")
logger.warn("warn statement %s", "about to try something dumb")
result &lt;- try(1/"a", silent=TRUE)
logger.error("error message: %s", geterrmessage())
logger.fatal("fatal statement %s", "THE END")

## End(Not run)
</code></pre>

<hr>
<h2 id='logger.warn'>Python-style logging statements</h2><span id='topic+logger.warn'></span>

<h3>Description</h3>

<p>After initializing the level-specific log files with <code>logger.setup(...)</code>,
this function will generate <code>WARN</code> level log statements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger.warn(msg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logger.warn_+3A_msg">msg</code></td>
<td>
<p>Message with format strings applied to additional arguments.</p>
</td></tr>
<tr><td><code id="logger.warn_+3A_...">...</code></td>
<td>
<p>Additional arguments to be formatted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>All functionality is built on top of the excellent <span class="pkg">futile.logger</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger.setup">logger.setup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Only save three log files
logger.setup(
  debugLog = "debug.log",
  infoLog = "info.log",
  errorLog = "error.log"
)

# But allow log statements at all levels within the code
logger.trace("trace statement #%d", 1)
logger.debug("debug statement")
logger.info("info statement %s %s", "with", "arguments")
logger.warn("warn statement %s", "about to try something dumb")
result &lt;- try(1/"a", silent=TRUE)
logger.error("error message: %s", geterrmessage())
logger.fatal("fatal statement %s", "THE END")

## End(Not run)
</code></pre>

<hr>
<h2 id='logLevels'>Log levels</h2><span id='topic+logLevels'></span><span id='topic+FATAL'></span><span id='topic+ERROR'></span><span id='topic+WARN'></span><span id='topic+INFO'></span><span id='topic+DEBUG'></span><span id='topic+TRACE'></span>

<h3>Description</h3>

<p>Log levels matching those found in <span class="pkg">futile.logger</span>.
Available levels include:
</p>
<p><code>FATAL ERROR WARN INFO DEBUG TRACE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FATAL
</code></pre>


<h3>Format</h3>

<p>An object of class <code>integer</code> of length 1.
</p>

<hr>
<h2 id='manageCache'>Manage the size of a cache</h2><span id='topic+manageCache'></span>

<h3>Description</h3>

<p>If <code>cacheDir</code> takes up more than <code>maxCacheSize</code>
megabytes on disk, files will be removed in order of access time by
default. Only files matching <code>extensions</code> are eligible for removal.
Files can also be removed in order of change time with <code>sortBy='ctime'</code>
or modification time with <code>sortBy='mtime'</code>.
</p>
<p>The <code>maxFileAge</code> parameter can also be used to remove files that haven't
been modified in a certain number of days. Fractional days are allowed. This
removal happens without regard to the size of the cache and is useful for
removing out-of-date data.
</p>
<p>It is important to understand precisely what these timestamps
represent:
</p>

<ul>
<li><p><code>atime</code> &ndash; File access time: updated whenever a file is opened.
</p>
</li>
<li><p><code>ctime</code> &ndash; File change time: updated whenever a file's metadata
changes e.g. name, permission, ownership.
</p>
</li>
<li><p><code>mtime</code> &ndash; file modification time: updated whenever a file's
contents change.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>manageCache(
  cacheDir = NULL,
  extensions = c("html", "json", "pdf", "png"),
  maxCacheSize = 100,
  sortBy = "atime",
  maxFileAge = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manageCache_+3A_cachedir">cacheDir</code></td>
<td>
<p>Location of cache directory.</p>
</td></tr>
<tr><td><code id="manageCache_+3A_extensions">extensions</code></td>
<td>
<p>Vector of file extensions eligible for removal.</p>
</td></tr>
<tr><td><code id="manageCache_+3A_maxcachesize">maxCacheSize</code></td>
<td>
<p>Maximum cache size in megabytes.</p>
</td></tr>
<tr><td><code id="manageCache_+3A_sortby">sortBy</code></td>
<td>
<p>Timestamp to sort by when sorting files eligible for removal.
One of <code>atime|ctime|mtime</code>.</p>
</td></tr>
<tr><td><code id="manageCache_+3A_maxfileage">maxFileAge</code></td>
<td>
<p>Maximum age in days of files allowed in the cache.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the number of files removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

# Create a cache directory and fill it with 1.6 MB of data
CACHE_DIR &lt;- tempdir()
write.csv(matrix(1,400,500), file=file.path(CACHE_DIR,'m1.csv'))
write.csv(matrix(2,400,500), file=file.path(CACHE_DIR,'m2.csv'))
write.csv(matrix(3,400,500), file=file.path(CACHE_DIR,'m3.csv'))
write.csv(matrix(4,400,500), file=file.path(CACHE_DIR,'m4.csv'))
for (file in list.files(CACHE_DIR, full.names=TRUE)) {
  print(file.info(file)[,c(1,6)])
}

# Remove files based on access time until we get under 1 MB
manageCache(CACHE_DIR, extensions='csv', maxCacheSize=1, sortBy='atime')
for (file in list.files(CACHE_DIR, full.names=TRUE)) {
  print(file.info(file)[,c(1,6)])
}

# Or remove files based on modification time
manageCache(CACHE_DIR, extensions='csv', maxCacheSize=1, sortBy='mtime')
for (file in list.files(CACHE_DIR, full.names=TRUE)) {
  print(file.info(file)[,c(1,6)])
}
</code></pre>

<hr>
<h2 id='packageCheck'>Run package checks</h2><span id='topic+packageCheck'></span><span id='topic+check_slow'></span><span id='topic+check'></span><span id='topic+check_fast'></span><span id='topic+check_faster'></span><span id='topic+check_fastest'></span><span id='topic+check_slower'></span><span id='topic+check_slowest'></span>

<h3>Description</h3>

<p>When multiple developers are working on a package, it is
crucially important that they check their code changes <em>often</em>.  After
merging changes from multiple developers it is equally important to check the
package <em>thoroughly</em>.
</p>
<p>The problem is that frequent checks should be quick or developers won't do
them while thorough checks are, by nature, slow.
</p>
<p>Our solution is to provide shorthand functions that wrap
<code>devtools::check()</code> and pass it a variety of different arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check(pkg = ".")

check_fast(pkg = ".")

check_faster(pkg = ".")

check_fastest(pkg = ".")

check_slow(pkg = ".")

check_slower(pkg = ".")

check_slowest(pkg = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="packageCheck_+3A_pkg">pkg</code></td>
<td>
<p>Package location passed to <code>devtools::check()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The table below describes the <code>args</code> passed to
<code>devtools::check()</code>:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>check_slowest()</code> </td><td style="text-align: left;"> | <code>manual = TRUE, run_dont_test = TRUE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> | <code>args = c("--run-dontrun", "--use-gct")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>check_slower()</code> </td><td style="text-align: left;"> | <code>manual = TRUE, run_dont_test = TRUE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> | <code>args = c("--run-dontrun")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>check_slow()</code> </td><td style="text-align: left;"> | <code>manual = TRUE, run_dont_test = TRUE</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> | <code>args = c()</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>check()</code> </td><td style="text-align: left;"> | <code>manual = FALSE, run_dont_test = FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> | <code>args = c()</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>check_fast()</code> </td><td style="text-align: left;"> | <code>manual = FALSE, run_dont_test = FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> | <code>build_args = c("--no-build-vignettes")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> | <code>args = c("--ignore-vignettes")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>check_faster()</code> </td><td style="text-align: left;"> | <code>manual = FALSE, run_dont_test = FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> | <code>build_args = c("--no-build-vignettes")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> | <code>args = c("--ignore-vignettes", "--no-examples")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>check_fastest()</code> </td><td style="text-align: left;"> | <code>manual = FALSE, run_dont_test = FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> | <code>build_args = c("--no-build-vignettes")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> | <code>args = c("--ignore-vignettes", "--no-examples", "--no-tests")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>No return.
</p>


<h3>See Also</h3>

<p><code><a href="devtools.html#topic+check">check</a></code>
</p>

<hr>
<h2 id='parseDatetime'>Parse datetime strings</h2><span id='topic+parseDatetime'></span>

<h3>Description</h3>

<p>Transforms numeric and string representations of Ymd[HMS] datetimes to
<code>POSIXct</code> format.
</p>
<p>Y, Ym, Ymd, YmdH, YmdHM, and YmdHMS formats are understood, where:
</p>

<dl>
<dt>Y</dt><dd><p>four digit year</p>
</dd>
<dt>m</dt><dd><p>month number (1-12, 01-12) or english name month (October, oct.)</p>
</dd>
<dt>d</dt><dd><p>day number of the month (0-31 or 01-31)</p>
</dd>
<dt>H</dt><dd><p>hour number (0-24 or 00-24)</p>
</dd>
<dt>M</dt><dd><p>minute number (0-59 or 00-59)</p>
</dd>
<dt>S</dt><dd><p>second number (0-61 or 00-61)</p>
</dd>
</dl>

<p>This allows for mixed inputs. For example, 20181012130900,
&quot;2018-10-12-13-09-00&quot;, and &quot;2018 Oct. 12 13:09:00&quot; will all be converted to
the same <code>POSIXct</code> datetime. The incoming datetime vector does not need
to have a homogeneous format either &ndash; &quot;20181012&quot; and &quot;2018-10-12 13:09&quot; can
exist in the same vector without issue. All incoming datetimes will be
interpreted in the specified timezone.
</p>
<p>If <code>datetime</code> is a <code>POSIXct</code> it will be returned unmodified, and
formats not recognized will be returned as <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseDatetime(
  datetime = NULL,
  timezone = NULL,
  expectAll = FALSE,
  isJulian = FALSE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseDatetime_+3A_datetime">datetime</code></td>
<td>
<p>Vector of character or integer datetimes in Ymd[HMS] format
(or POSIXct).</p>
</td></tr>
<tr><td><code id="parseDatetime_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates (required).</p>
</td></tr>
<tr><td><code id="parseDatetime_+3A_expectall">expectAll</code></td>
<td>
<p>Logical value determining if the function should fail if
any elements fail to parse (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="parseDatetime_+3A_isjulian">isJulian</code></td>
<td>
<p>Logical value determining whether <code>datetime</code> should be
interpreted as a Julian date with day of year as a decimal number.</p>
</td></tr>
<tr><td><code id="parseDatetime_+3A_quiet">quiet</code></td>
<td>
<p>Logical value passed on to <code>lubridate::parse_date_time</code> to
optionally suppress warning messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of POSIXct datetimes.
</p>


<h3>Mazama Science Conventions</h3>

<p>Within Mazama Science package, datetimes not in <code>POSIXct</code> format are
often represented as decimal values with no separation (ex: 20181012,
20181012130900), either as numerics or strings.
</p>


<h3>Implementation</h3>

<p><code>parseDatetime</code> is essentially a wrapper around
<code><a href="lubridate.html#topic+parse_date_time">parse_date_time</a></code>, handling which formats we want to
account for.
</p>


<h3>Note</h3>

<p>If <code>datetime</code> is a character string containing signed offset
information, <em>e.g.</em> &quot;-07:00&quot;, this information is used to generate an
equivalent UTC time which is then assigned to the timezone specified by
the <code>timezone</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="lubridate.html#topic+parse_date_time">parse_date_time</a></code> for implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

# All y[md-hms] formats are accepted
parseDatetime(2018, timezone = "America/Los_Angeles")
parseDatetime(201808, timezone = "America/Los_Angeles")
parseDatetime(20180807, timezone = "America/Los_Angeles")
parseDatetime(2018080718, timezone = "America/Los_Angeles")
parseDatetime(201808071812, timezone = "America/Los_Angeles")
parseDatetime(20180807181215, timezone = "America/Los_Angeles")
parseDatetime("2018-08-07 18:12:15", timezone = "America/Los_Angeles")
parseDatetime("2018-08-07 18:12:15-07:00", timezone = "America/Los_Angeles")
parseDatetime("2018-08-07 18:12:15-07:00", timezone = "UTC")

# Julian days are accepeted
parseDatetime(2018219181215, timezone = "America/Los_Angeles",
              isJulian = TRUE)

# Vector dates are accepted and daylight savings is respected
parseDatetime(
  c("2018-10-24 12:00", "2018-10-31 12:00",
    "2018-11-07 12:00", "2018-11-08 12:00"),
  timezone = "America/New_York"
)

badInput &lt;- c("20181013", NA, "20181015", "181016", "10172018")

# Return a vector with \code{NA} for dates that could not be parsed
parseDatetime(badInput, timezone = "UTC", expectAll = FALSE)

## Not run: 
# Fail if any dates cannot be parsed
parseDatetime(badInput, timezone = "UTC", expectAll = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='setAPIKey'>Set APIKey</h2><span id='topic+setAPIKey'></span>

<h3>Description</h3>

<p>Sets the API key associated with a web service.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setAPIKey(provider = NULL, key = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setAPIKey_+3A_provider">provider</code></td>
<td>
<p>Web service provider.</p>
</td></tr>
<tr><td><code id="setAPIKey_+3A_key">key</code></td>
<td>
<p>API key.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently returns previous value of the API key.
</p>


<h3>See Also</h3>

<p><a href="#topic+getAPIKey">getAPIKey</a>
</p>
<p><a href="#topic+showAPIKeys">showAPIKeys</a>
</p>

<hr>
<h2 id='setIfNull'>Set a variable to a default value if it is NULL</h2><span id='topic+setIfNull'></span>

<h3>Description</h3>

<p>This function attempts to set a default value for a given target object. If
the object is <code>NULL</code>, a default value is returned.
</p>
<p>When the target object is not <code>NULL</code>, this function will try and coerce
it to match the type of the default (given by <code><a href="base.html#topic+typeof">typeof</a></code>).
This is useful in situations where we are looking to parse the input as well,
such at looking at elements of an API call string and wanting to set the
character numbers as actual numeric types.
</p>
<p>Not all coercions are possible, however, and if the function encounters one
of these (ex: <code>setIfNull("foo", 5)</code>) the function will fail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setIfNull(target, default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setIfNull_+3A_target">target</code></td>
<td>
<p>Object to test if <code>NULL</code> (must be length 1).</p>
</td></tr>
<tr><td><code id="setIfNull_+3A_default">default</code></td>
<td>
<p>Object to return if <code>target</code> is <code>NULL</code> (must be
length one).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>target</code> is not <code>NULL</code>, then <code>target</code> is coerced to
the type of <code>default</code>. Otherwise, <code>default</code> is returned.
</p>


<h3>Possible Coercions</h3>

<p>This function checks the type of the target and default as given by
<code><a href="base.html#topic+typeof">typeof</a></code>. Specifically, it accounts for the types:
</p>

<ul>
<li> <p><code>character</code>
</p>
</li>
<li> <p><code>integer</code>
</p>
</li>
<li> <p><code>double</code>
</p>
</li>
<li> <p><code>complex</code>
</p>
</li>
<li> <p><code>logical</code>
</p>
</li>
<li> <p><code>list</code>
</p>
</li></ul>

<p><em>R</em> tries to intelligently coerce types, but some coercions from one
type to another won't always be possible. Everything can be turned into a
character, but only some character objects can become numeric (&quot;7&quot; can,
while &quot;hello&quot; cannot). Some other coercions work, but you will lose
information in the process. For example, the <em>double</em> 5.7 can be coerced
into an <em>integer</em>, but the decimal portion will be dropped with no
rounding. It is important to realize that while it is possible to move
between most types, the results are not always meaningful.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

setIfNull(NULL, "foo")
setIfNull(10, 0)
setIfNull("15", 0)


# This function can be useful for adding elements to a list
testList &lt;- list("a" = 1, "b" = "baz", "c" = "4")

testList$a &lt;- setIfNull(testList$a, 0)
testList$b &lt;- setIfNull(testList$c, 0)
testList$d &lt;- setIfNull(testList$d, 6)


# Be careful about unintended results
setIfNull("T", FALSE) # This returns `TRUE`
setIfNull(12.8, 5L)   # This returns the integer 12


## Not run: 
# Not all coercions are possible
setIfNull("bar", 5)
setIfNull("t", FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='showAPIKeys'>Show API keys</h2><span id='topic+showAPIKeys'></span>

<h3>Description</h3>

<p>Returns a list of all currently set API keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showAPIKeys()
</code></pre>


<h3>Value</h3>

<p>List of provider:key pairs.
</p>


<h3>See Also</h3>

<p><a href="#topic+getAPIKey">getAPIKey</a>
</p>
<p><a href="#topic+setAPIKey">setAPIKey</a>
</p>

<hr>
<h2 id='stopIfNull'>Stop if an object is NULL</h2><span id='topic+stopIfNull'></span>

<h3>Description</h3>

<p>This is a convenience function for testing if an object is <code>NULL</code>, and
providing a custom error message if it is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopIfNull(target, msg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopIfNull_+3A_target">target</code></td>
<td>
<p>Object to test if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="stopIfNull_+3A_msg">msg</code></td>
<td>
<p>Optional custom message to display when <code>target</code> is
<code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>target</code> is not <code>NULL</code>, <code>target</code> is returned
invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

# Return input invisibly if not NULL
x &lt;- stopIfNull(5, msg = "Custom message")
print(x)

# This can be useful when building pipelines
y &lt;- 1:10
y_mean &lt;-
  y %&gt;%
  stopIfNull() %&gt;%
  mean()

## Not run: 
testVar &lt;- NULL
stopIfNull(testVar)
stopIfNull(testVar, msg = "This is NULL")

# Make a failing pipeline
z &lt;- NULL
z_mean &lt;-
  z %&gt;%
  stopIfNull("This has failed.") %&gt;%
  mean()

## End(Not run)
</code></pre>

<hr>
<h2 id='stopOnError'>Error message generator</h2><span id='topic+stopOnError'></span>

<h3>Description</h3>

<p>When writing R code for use in production systems, it is
important to enclose chunks of code inside of <code>try()</code> blocks. This is
especially important when processing user input or data obtained from web
services which may fail for a variety of reasons. If any problems arise
within a <code>try()</code> block, it is important to generate informative and
consistent error messages.
</p>
<p>Over the years, we have developed our own standard protocol for error handling
that is easy to understand, easy to implement, and allows for consistent
generation of error messages. To goal is to make it easy for developers to test
sections of code that might fail and to create more uniform, more informative
error messages than those that might come from deep within the <span class="rlang"><b>R</b></span> execution stack.
</p>
<p>In addition to the generation of custom error messages, use of <code>prefix</code>
allows for the creation of classes of errors that can be detected and handled
appropriately as errors propagate to other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopOnError(
  result,
  err_msg = "",
  prefix = "",
  maxLength = 500,
  truncatedLength = 120,
  call. = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopOnError_+3A_result">result</code></td>
<td>
<p>Return from a <code>try()</code> block.</p>
</td></tr>
<tr><td><code id="stopOnError_+3A_err_msg">err_msg</code></td>
<td>
<p>Custom error message.</p>
</td></tr>
<tr><td><code id="stopOnError_+3A_prefix">prefix</code></td>
<td>
<p>Text string to add in front of the error message.</p>
</td></tr>
<tr><td><code id="stopOnError_+3A_maxlength">maxLength</code></td>
<td>
<p>Maximum length of an error message. Error messages
beyond this limit will be truncated.</p>
</td></tr>
<tr><td><code id="stopOnError_+3A_truncatedlength">truncatedLength</code></td>
<td>
<p>Length of the output error message.</p>
</td></tr>
<tr><td><code id="stopOnError_+3A_call.">call.</code></td>
<td>
<p>Logical indicating whether the call should become part of the error message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Issues a <code>stop()</code> with an appropriate error message.
</p>


<h3>Note</h3>

<p>If logging has been initialized, the customized/modified error message
will be logged with <code>logger.error(err_msg)</code> before issuing
<code>stop(err_msg)</code>.
</p>
<p>The following examples show how to use this function:
</p>
<pre>
library(MazamaCoreUtils)

# Arbitrarily deep in the stack we might have:

myFunc &lt;- function(x) {
  a &lt;- log(x)
}


# Simple usage

userInput &lt;- 10
result &lt;- try({
  myFunc(x = userInput)
}, silent = TRUE)
stopOnError(result)

userInput &lt;- "ten"
result &lt;- try({
  myFunc(x = userInput)
}, silent = TRUE)
stopOnError(result)


# More concise code with the '%&gt;%' operator

try({
  myFunc(x = userInput)
}, silent = TRUE) %&gt;%
stopOnError(err_msg = "Unable to process user input")

try({
  myFunc(x = userInput)
}, silent = TRUE) %&gt;%
stopOnError(prefix = "USER_INPUT_ERROR")


# Truncating error message length

try({
  myFunc(x = userInput)
}, silent = TRUE) %&gt;%
stopOnError(
  prefix = "USER_INPUT_ERROR",
  maxLength = 40,
  truncatedLength = 32
)

</pre>

<hr>
<h2 id='tidyeval-data'>Data pronoun for tidy evaluation</h2><span id='topic+tidyeval-data'></span><span id='topic+.data'></span>

<h3>Description</h3>

<p>See <code>rlang::<a href="rlang.html#topic+.data">.data</a></code> for details.
</p>

<hr>
<h2 id='timeRange'>Create a POSIXct time range</h2><span id='topic+timeRange'></span>

<h3>Description</h3>

<p>Uses incoming parameters to return a pair of <code>POSIXct</code> times in the
proper order. Both start and end times will have <code>lubridate::floor_date()</code>
applied to get the nearest <code>unit</code>. This can be modified by specifying
<code>ceilingStart = TRUE</code> or <code>ceilingEnd = TRUE</code> in which case
<code>lubridate::ceiling_date()</code> will be applied.
</p>
<p>The required <code>timezone</code> parameter must be one of those found in
<code><a href="base.html#topic+OlsonNames">OlsonNames</a></code>.
</p>
<p>Dates can be anything that is understood by
<code>lubrdiate::parse_date_time()</code> including either of the following
recommended formats:
</p>

<ul>
<li><p><code>"YYYYmmddHH[MMSS]"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd HH:MM:SS"</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>timeRange(
  starttime = NULL,
  endtime = NULL,
  timezone = NULL,
  unit = "sec",
  ceilingStart = FALSE,
  ceilingEnd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeRange_+3A_starttime">starttime</code></td>
<td>
<p>Desired start datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="timeRange_+3A_endtime">endtime</code></td>
<td>
<p>Desired end datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="timeRange_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates (required).</p>
</td></tr>
<tr><td><code id="timeRange_+3A_unit">unit</code></td>
<td>
<p>Units used to determine time at end-of-day.</p>
</td></tr>
<tr><td><code id="timeRange_+3A_ceilingstart">ceilingStart</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>startdate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code></p>
</td></tr>
<tr><td><code id="timeRange_+3A_ceilingend">ceilingEnd</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>enddate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of two <code>POSIXct</code>s.
</p>


<h3>POSIXct inputs</h3>

<p>When <code>startdate</code> or <code>enddate</code> are already <code>POSIXct</code> values,
they are converted to the timezone specified by <code>timezone</code> without
altering the physical instant in time the input represents. This is different
from the behavior of <code><a href="lubridate.html#topic+parse_date_time">parse_date_time</a></code> (which powers
this function), which will force <code>POSIXct</code> inputs into a new timezone,
altering the physical moment of time the input represents.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

timeRange("2019-01-08 10:12:15", 20190109102030, timezone = "UTC")

</code></pre>

<hr>
<h2 id='timeStamp'>Character representation of a POSIXct</h2><span id='topic+timeStamp'></span>

<h3>Description</h3>

<p>Converts a vector of incoming date times (as <code>POSIXct</code> or character
strings), into equivalent character representations in one of several
formats appropriate for use in naming files or labeling plots.
</p>
<p>When <code>datetime</code> is not provided, defaults to <code>lubridate::now()</code>.
</p>
<p>The required <code>timezone</code> parameter must be one of those found in
<code><a href="base.html#topic+OlsonNames">OlsonNames</a></code>.
</p>
<p>Formatting output is are affected by both <code>style</code>:
</p>

<ul>
<li><p><code>"ymdhms"</code>
</p>
</li>
<li><p><code>"ymdThms"</code>
</p>
</li>
<li><p><code>"julian"</code>
</p>
</li>
<li><p><code>"clock"</code>
</p>
</li></ul>

<p>and <code>unit</code> which determines the temporal precision of the generated
representation:
</p>

<ul>
<li><p><code>"year"</code>
</p>
</li>
<li><p><code>"month"</code>
</p>
</li>
<li><p><code>"day"</code>
</p>
</li>
<li><p><code>"hour"</code>
</p>
</li>
<li><p><code>"min"</code>
</p>
</li>
<li><p><code>"sec"</code>
</p>
</li>
<li><p><code>"msec"</code>
</p>
</li></ul>

<p>If <code>style == "julian"</code> &amp;&amp; <code>unit = "month"</code>, the timestamp will contain the
Julian day associated with the beginning of the month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeStamp(datetime = NULL, timezone = NULL, unit = "sec", style = "ymdhms")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeStamp_+3A_datetime">datetime</code></td>
<td>
<p>Vector of character or integer datetimes in Ymd[HMS] format
(or POSIXct).</p>
</td></tr>
<tr><td><code id="timeStamp_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret incoming dates (required).</p>
</td></tr>
<tr><td><code id="timeStamp_+3A_unit">unit</code></td>
<td>
<p>Units used to determine precision of generated time stamps.</p>
</td></tr>
<tr><td><code id="timeStamp_+3A_style">style</code></td>
<td>
<p>Style of representation, Default = &quot;ymdhms&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of time stamps.
</p>


<h3>POSIXct inputs</h3>

<p>When <code>startdate</code> or <code>enddate</code> are already <code>POSIXct</code> values,
they are converted to the timezone specified by <code>timezone</code> without
altering the physical instant in time the input represents. This is different
from the behavior of <code><a href="lubridate.html#topic+parse_date_time">parse_date_time</a></code> (which powers
this function), which will force <code>POSIXct</code> inputs into a new timezone,
altering the physical moment of time the input represents.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaCoreUtils)

datetime &lt;- parseDatetime("2019-01-08 12:30:15", timezone = "UTC")

timeStamp()
timeStamp(datetime, "UTC", unit = "year")
timeStamp(datetime, "UTC", unit = "month")
timeStamp(datetime, "UTC", unit = "month", style = "julian")
timeStamp(datetime, "UTC", unit = "day")
timeStamp(datetime, "UTC", unit = "day", style = "julian")
timeStamp(datetime, "UTC", unit = "hour")
timeStamp(datetime, "UTC", unit = "min")
timeStamp(datetime, "UTC", unit = "sec")
timeStamp(datetime, "UTC", unit = "sec", style = "ymdThms")
timeStamp(datetime, "UTC", unit = "sec", style = "julian")
timeStamp(datetime, "UTC", unit = "sec", style = "clock")
timeStamp(datetime, "America/Los_Angeles", unit = "sec", style = "clock")
timeStamp(datetime, "America/Los_Angeles", unit = "msec", style = "clock")

</code></pre>

<hr>
<h2 id='timezoneLintRules'>Rules for timezone linting.</h2><span id='topic+timezoneLintRules'></span>

<h3>Description</h3>

<p>This set of rules is for use with the
<code>lintFunctionArgs_~()</code>. functions. It includes all time-related
functions from the <span class="pkg">base</span> and <span class="pkg">lubridate</span> packages that are involved
with parsing or formatting datetimes and helps check whether the appropriate
timezone arguments are being explicitly used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timezoneLintRules
</code></pre>


<h3>Format</h3>

<p>A list of function = argument pairs.
</p>

<hr>
<h2 id='validateLonLat'>Validate longitude and latitude values</h2><span id='topic+validateLonLat'></span>

<h3>Description</h3>

<p>Longitude and latitude are validated to be parseable as numeric
and within the bounds -180:180 and -90:90. If validation fails, an error is
generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateLonLat(longitude = NULL, latitude = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateLonLat_+3A_longitude">longitude</code></td>
<td>
<p>Single longitude in decimal degrees E.</p>
</td></tr>
<tr><td><code id="validateLonLat_+3A_latitude">latitude</code></td>
<td>
<p>Single latitude in decimal degrees N.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if no error message has been generated.
</p>

<hr>
<h2 id='validateLonsLats'>Validate longitude and latitude vectors</h2><span id='topic+validateLonsLats'></span>

<h3>Description</h3>

<p>Longitude and latitude vectors validated to be parseable as numeric
and within the bounds -180:180 and -90:90. If validation fails, an error is
generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateLonsLats(longitude = NULL, latitude = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateLonsLats_+3A_longitude">longitude</code></td>
<td>
<p>Vector of longitudes in decimal degrees E.</p>
</td></tr>
<tr><td><code id="validateLonsLats_+3A_latitude">latitude</code></td>
<td>
<p>Vector of latitudes in decimal degrees N.</p>
</td></tr>
<tr><td><code id="validateLonsLats_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether to remove <code>NA</code> values before
validation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if no error message has been generated.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
