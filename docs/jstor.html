<!DOCTYPE html><html><head><title>Help for package jstor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jstor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jst_add_total_pages'><p>Add total count of pages</p></a></li>
<li><a href='#jst_augment'><p>Clean data from DfR</p></a></li>
<li><a href='#jst_clean_page'><p>Clean a character vector of pages</p></a></li>
<li><a href='#jst_combine_outputs'><p>Combine outputs from converted files</p></a></li>
<li><a href='#jst_define_import'><p>Define an import specification</p></a></li>
<li><a href='#jst_example'><p>Get path to jstor example</p></a></li>
<li><a href='#jst_get_article'><p>Extract meta information for articles</p></a></li>
<li><a href='#jst_get_authors'><p>Extract author information</p></a></li>
<li><a href='#jst_get_book'><p>Extract meta information for books</p></a></li>
<li><a href='#jst_get_chapters'><p>Extract information on book chapters</p></a></li>
<li><a href='#jst_get_file_name'><p>Extract the basename of a path</p></a></li>
<li><a href='#jst_get_footnotes'><p>Extract all footnotes</p></a></li>
<li><a href='#jst_get_full_text'><p>Import full-text</p></a></li>
<li><a href='#jst_get_journal_overview'><p>Get table with information on journals</p></a></li>
<li><a href='#jst_get_ngram'><p>Read ngram data</p></a></li>
<li><a href='#jst_get_references'><p>Extract all references</p></a></li>
<li><a href='#jst_get_total_pages'><p>Calculate total pages</p></a></li>
<li><a href='#jst_import'><p>Wrapper for file import</p></a></li>
<li><a href='#jst_preview_zip'><p>Preview content of zip files</p></a></li>
<li><a href='#jst_re_import'><p>Re-import files</p></a></li>
<li><a href='#jst_subset_ngrams'><p>Define a subset of ngrams</p></a></li>
<li><a href='#jst_unify_journal_id'><p>Unify journal IDs</p></a></li>
<li><a href='#jstor'><p>jstor: Read Data from JSTOR/DfR</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Read Data from JSTOR/DfR</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.11</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and helpers to import metadata, ngrams and full-texts 
    delivered by Data for Research by JSTOR. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.0), tidyr (&ge; 0.7.2), purrr (&ge; 0.2.4), xml2 (&ge;
1.2.0), magrittr, stringr (&ge; 1.3.0), readr (&ge; 2.0.0), tibble
(&ge; 3.0.0), rlang (&ge; 0.2.0), furrr (&ge; 0.1.0), pryr, crayon,
cli</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown, future</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/jstor/issues">https://github.com/ropensci/jstor/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/jstor">https://github.com/ropensci/jstor</a>,
<a href="https://docs.ropensci.org/jstor/">https://docs.ropensci.org/jstor/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-15 12:06:58 UTC; tklebel</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Klebel <a href="https://orcid.org/0000-0002-7331-4751"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Klebel &lt;t.klebel@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-16 13:14:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='jst_add_total_pages'>Add total count of pages</h2><span id='topic+jst_add_total_pages'></span>

<h3>Description</h3>

<p>This function adds a column with the total count of pages. It calls
<code><a href="#topic+jst_get_total_pages">jst_get_total_pages()</a></code> which does the main work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_add_total_pages(meta_data, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_add_total_pages_+3A_meta_data">meta_data</code></td>
<td>
<p>Data which was processed via <code><a href="#topic+jst_get_article">jst_get_article()</a></code>.</p>
</td></tr>
<tr><td><code id="jst_add_total_pages_+3A_quietly">quietly</code></td>
<td>
<p>Should warnings from converting page ranges be suppressed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code>, as provided with in <code>meta_data</code>, with an additional
column on total number of pages.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jst_get_total_pages">jst_get_total_pages()</a></code>
</p>

<hr>
<h2 id='jst_augment'>Clean data from DfR</h2><span id='topic+jst_augment'></span>

<h3>Description</h3>

<p>This function takes data from <code><a href="#topic+jst_get_article">jst_get_article()</a></code> and
applies helper functions for cleaning the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_augment(meta_data, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_augment_+3A_meta_data">meta_data</code></td>
<td>
<p>Data which was processed via <code><a href="#topic+jst_get_article">jst_get_article()</a></code>.</p>
</td></tr>
<tr><td><code id="jst_augment_+3A_quietly">quietly</code></td>
<td>
<p>Should warnings from converting page ranges be suppressed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data from DfR is inherently messy. For many examples see
<code>vignette("known-quirks", package = "jstor")</code>. <code>jst_augment()</code> is a
convenience function that tries to deal with a few common tasks to
clean the data.
</p>
<p>For journal articles, it calls <code><a href="#topic+jst_clean_page">jst_clean_page()</a></code> to convert first and last
page, <code><a href="#topic+jst_unify_journal_id">jst_unify_journal_id()</a></code> and <code><a href="#topic+jst_add_total_pages">jst_add_total_pages()</a></code>.
</p>


<h3>Value</h3>

<p>A cleaned tibble.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jst_clean_page">jst_clean_page()</a></code> <code><a href="#topic+jst_unify_journal_id">jst_unify_journal_id()</a></code> <code><a href="#topic+jst_add_total_pages">jst_add_total_pages()</a></code>
<code><a href="#topic+jst_get_total_pages">jst_get_total_pages()</a></code>
</p>

<hr>
<h2 id='jst_clean_page'>Clean a character vector of pages</h2><span id='topic+jst_clean_page'></span>

<h3>Description</h3>

<p>This function tries to convert character vectors into integers. This function
should not be called on page ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_clean_page(page)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_clean_page_+3A_page">page</code></td>
<td>
<p>A character vector for pages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector, cleaned and converted from the input vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jst_clean_page("2")

# anything that is not a digit gets removed
jst_clean_page("A2-")

# a weird format from the American Journal of Sociology is convered correctly
jst_clean_page("AJSv104p126")
# this is done by searching for "p", and if it is found, extracting the
# content after "p".
</code></pre>

<hr>
<h2 id='jst_combine_outputs'>Combine outputs from converted files</h2><span id='topic+jst_combine_outputs'></span>

<h3>Description</h3>

<p><code>jst_combine_outputs()</code> helps you to manage the multitude of files you might
receive after running <code><a href="#topic+jst_import">jst_import()</a></code> or <code><a href="#topic+jst_import_zip">jst_import_zip()</a></code> with more than
one batch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_combine_outputs(
  path,
  write_to_file = TRUE,
  out_path = NULL,
  overwrite = FALSE,
  clean_up = FALSE,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_combine_outputs_+3A_path">path</code></td>
<td>
<p>A path to a directory, containing .csv-files from
<code><a href="#topic+jst_import">jst_import()</a></code> or <code><a href="#topic+jst_import_zip">jst_import_zip()</a></code>, or a vector of files which are to be
imported.</p>
</td></tr>
<tr><td><code id="jst_combine_outputs_+3A_write_to_file">write_to_file</code></td>
<td>
<p>Should combined data be written to a file?</p>
</td></tr>
<tr><td><code id="jst_combine_outputs_+3A_out_path">out_path</code></td>
<td>
<p>A directory where to write the combined files. If no
directory is supplied and <code>write_to_file</code> is <code>TRUE</code>, the combined files are
written to <code>path</code>.</p>
</td></tr>
<tr><td><code id="jst_combine_outputs_+3A_overwrite">overwrite</code></td>
<td>
<p>Should files be overwritten?</p>
</td></tr>
<tr><td><code id="jst_combine_outputs_+3A_clean_up">clean_up</code></td>
<td>
<p>Do you want to remove the original batch files? Use with
caution.</p>
</td></tr>
<tr><td><code id="jst_combine_outputs_+3A_warn">warn</code></td>
<td>
<p>Should warnings be raised, if the file type cannot be determined?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Splitting the output of <code><a href="#topic+jst_import">jst_import()</a></code> or <code><a href="#topic+jst_import_zip">jst_import_zip()</a></code> might be done
for multiple reasons, but in the end you possibly want to combine all outputs
into one file/data.frame. This function makes a few assumptions in order to
combine files:
</p>

<ul>
<li><p> Files with similar names (except for trailing dashes with numbers) belong
together and will be combined into one file.
</p>
</li>
<li><p> The names of the combined files can be determined from the original files.
If you want to combine <code style="white-space: pre;">&#8288;foo-1.csv&#8288;</code> and <code style="white-space: pre;">&#8288;foo-2.csv&#8288;</code>, the combined file will
be <code>combined_foo.csv</code>.
</p>
</li>
<li><p> The directory only contains files which were imported via
<code><a href="#topic+jst_import">jst_import()</a></code> or <code><a href="#topic+jst_import_zip">jst_import_zip()</a></code>. If the directory contains other
<code>.csv</code> files, you should supply a character vector with paths to only those
files, which you want to import.
</p>
</li></ul>



<h3>Value</h3>

<p>Either writes to disk, or returns a list with all combined files.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jst_re_import">jst_re_import()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up a temporary directory
tmp &lt;- tempdir()

# find multiple files
file_list &lt;- rep(jst_example("article_with_references.xml"), 2)

# convert and write to file
jst_import(file_list, "article", out_path = tmp, .f = jst_get_article,
             n_batches = 2, show_progress = FALSE)
             
# combine outputs
jst_combine_outputs(tmp)
list.files(tmp, "csv")

## Not run: 
# Trying to combine the files again raises an error.
jst_combine_outputs(tmp)

## End(Not run)

# this doesn't
jst_combine_outputs(tmp, overwrite = TRUE)

# we can remove the original files too
jst_combine_outputs(tmp, overwrite = TRUE, clean_up = TRUE)
list.files(tmp, "csv")

</code></pre>

<hr>
<h2 id='jst_define_import'>Define an import specification</h2><span id='topic+jst_define_import'></span>

<h3>Description</h3>

<p>Define which parts of a zip file should be converted via which functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_define_import(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_define_import_+3A_...">...</code></td>
<td>
<p>Named arguments with bare function names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function accepts the following names: article, book, report, pamphlet,
ngram1, ngram2, ngram3.
The corresponding files from a .zip-archive will be imported via the supplied
functions.
</p>


<h3>Value</h3>

<p>A specification of imports which is necessary for
<code><a href="#topic+jst_import_zip">jst_import_zip()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># articles will be imported via `jst_get_article()` and `jst_get_authors()`
jst_define_import(article = c(jst_get_article, jst_get_authors))

# define a specification for importing article metadata and unigrams (ngram1)
jst_define_import(article = jst_get_article,
                  ngram1 = jst_get_ngram)
                  
                  
# import all four types with one function each
jst_define_import(article = jst_get_article,
                  book = jst_get_book,
                  report = jst_get_book,
                  pamphlet = jst_get_article)
                  
# import all four types with multiple functions
jst_define_import(article = c(jst_get_article, jst_get_authors, jst_get_references),
                  book = c(jst_get_book, jst_get_chapters),
                  report = jst_get_book,
                  pamphlet = jst_get_article)

# if you want to import chapters with authors, you can use an anonymous
# function

chapters_w_authors &lt;- function(x) jst_get_chapters(x, authors = TRUE)
jst_define_import(book = chapters_w_authors)


## Not run: 
# define imports
imports &lt;- jst_define_import(article = c(jst_get_article, jst_get_authors))

# convert the files to .csv
jst_import_zip("my_archive.zip", out_file = "my_out_file", 
                 import_spec = imports)

## End(Not run)
</code></pre>

<hr>
<h2 id='jst_example'>Get path to jstor example</h2><span id='topic+jst_example'></span>

<h3>Description</h3>

<p>jstor includes several sample files for demonstration purposes. This helper
makes them easy to access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_example(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_example_+3A_path">path</code></td>
<td>
<p>Name of the example file. If <code>NULL</code>, the example files will be
listed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code for this function was adapted from the package <code>readr</code>.
</p>


<h3>Value</h3>

<p>Either a character vector with the names of example files (if
<code>jst_example()</code> is called without supplying an argument), or a character
vector indicating the path to the example file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jst_example()
jst_example("article_with_references.xml") 
</code></pre>

<hr>
<h2 id='jst_get_article'>Extract meta information for articles</h2><span id='topic+jst_get_article'></span>

<h3>Description</h3>

<p><code>jst_get_article()</code> extracts meta-data from JSTOR-XML files for journal
articles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_article(file_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_article_+3A_file_path">file_path</code></td>
<td>
<p>A <code>.xml</code>-file for a journal-article.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> containing the extracted meta-data with the following
columns:
</p>

<ul>
<li><p> file_name <em>(chr)</em>: The file_name of the original .xml-file. Can be used
for joining with other parts (authors, references, footnotes, full-texts).
</p>
</li>
<li><p> journal_doi <em>(chr)</em>: A registered identifier for the journal.
</p>
</li>
<li><p> journal_jcode <em>(chr)</em>: A identifier for the journal like &quot;amerjsoci&quot; for
the &quot;American Journal of Sociology&quot;.
</p>
</li>
<li><p> journal_pub_id <em>(chr)</em>: Similar to journal_jcode. Most of the time either
one is present.
</p>
</li>
<li><p> journal_title <em>(chr)</em>: The title of the journal.
</p>
</li>
<li><p> article_doi <em>(chr)</em>: A registered unique identifier for the article.
</p>
</li>
<li><p> article_jcode <em>(chr)</em>: A unique identifier for the article (not a DOI).
</p>
</li>
<li><p> article_pub_id <em>(chr)</em>: Infrequent, either part of the DOI or the
article_jcode.
</p>
</li>
<li><p> article_type <em>(chr)</em>: The type of article (research-article, book-review,
etc.).
</p>
</li>
<li><p> article_title <em>(chr)</em>: The title of the article.
</p>
</li>
<li><p> volume <em>(chr)</em>: The volume the article was published in.
</p>
</li>
<li><p> issue <em>(chr)</em>: The issue the article was published in.
</p>
</li>
<li><p> language <em>(chr)</em>: The language of the article.
</p>
</li>
<li><p> pub_day <em>(chr)</em>: Publication day, if specified.
</p>
</li>
<li><p> pub_month <em>(chr)</em>: Publication month, if specified.
</p>
</li>
<li><p> pub_year <em>(int)</em>: Year of publication.
</p>
</li>
<li><p> first_page <em>(int)</em>: Page number for the first page of the article.
</p>
</li>
<li><p> last_page <em>(int)</em>: Page number for the last page of the article.
</p>
</li>
<li><p> page_range <em>(chr)</em>: The range of pages for the article.
</p>
</li></ul>

<p>A note about publication dates: always the first entry is being extracted,
which should correspond to the oldest date, in case there is more than one
date.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jst_get_article(jst_example("article_with_references.xml"))
</code></pre>

<hr>
<h2 id='jst_get_authors'>Extract author information</h2><span id='topic+jst_get_authors'></span>

<h3>Description</h3>

<p><code>jst_get_authors()</code> extracts information about authors from JSTOR-XML files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_authors(file_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_authors_+3A_file_path">file_path</code></td>
<td>
<p>A <code>.xml</code>-file from JSTOR containing meta-data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a <code>tibble</code> with the following six columns:
</p>

<ul>
<li> <p><em>prefix</em>: in case there was a prefix to the name, like <code>"Dr."</code>.
</p>
</li>
<li> <p><em>given_name</em>: The author's given name, like <code>"Albert"</code>.
</p>
</li>
<li> <p><em>surname</em>: The author's surname like <code>"Einstein"</code>.
</p>
</li>
<li> <p><em>string_name</em>: In some cases data the name is not available in separate
fields, but just as a complete string: <code>"Albert Einstein"</code>.
</p>
</li>
<li> <p><em>suffix</em>: a suffix to the name, like <code>"Jr."</code>.
</p>
</li>
<li> <p><em>author_number</em>: The authors are enumerated in the order they appear in the
data.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code> containing the extracted authors. All empty fields are
<code>NA_character</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jst_get_authors(jst_example("article_with_references.xml"))
</code></pre>

<hr>
<h2 id='jst_get_book'>Extract meta information for books</h2><span id='topic+jst_get_book'></span>

<h3>Description</h3>

<p><code>jst_get_book()</code> extracts meta-data from JSTOR-XML files for book chapters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_book(file_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_book_+3A_file_path">file_path</code></td>
<td>
<p>A <code>.xml</code>-file for a book or research report.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> containing the extracted meta-data with the following
columns:
</p>

<ul>
<li><p> file_name <em>(chr)</em>: The filename of the original .xml-file. Can be used
for joining with other data for the same file.
</p>
</li>
<li><p> discipline <em>(chr)</em>: The discipline from the discipline names used on JSTOR.
</p>
</li>
<li><p> book_id <em>(chr)</em>: The book id of type &quot;jstor&quot;, which is not a registered
DOI.
</p>
</li>
<li><p> book_title <em>(chr)</em>: The title of the book.
</p>
</li>
<li><p> book_subtitle <em>(chr)</em>: The subtitle of the book.
</p>
</li>
<li><p> pub_day <em>(int)</em>: Publication day, if specified.
</p>
</li>
<li><p> pub_month <em>(int)</em>: Publication month, if specified.
</p>
</li>
<li><p> pub_year <em>(int)</em>: Year of publication.
</p>
</li>
<li><p> isbn <em>(chr)</em>: One or more entries for the book's ISBN. If two or more,
separated by <code>"; "</code>.
</p>
</li>
<li><p> publisher_name <em>(chr)</em>: The name of the publisher.
</p>
</li>
<li><p> publisher_loc <em>(chr)</em>: The location of the publisher.
</p>
</li>
<li><p> n_pages <em>(int)</em>: The number of pages.
</p>
</li>
<li><p> language <em>(chr)</em>: The language of the book.
</p>
</li></ul>

<p>A note about publication dates: always the first entry is being extracted,
which should correspond to the oldest date, in case there is more than one
date.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jst_get_book(jst_example("book.xml"))
</code></pre>

<hr>
<h2 id='jst_get_chapters'>Extract information on book chapters</h2><span id='topic+jst_get_chapters'></span>

<h3>Description</h3>

<p><code>jst_get_chapters()</code> extracts meta-data from JSTOR-XML files for book
chapters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_chapters(file_path, authors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_chapters_+3A_file_path">file_path</code></td>
<td>
<p>The path to a <code>.xml</code>-file for a book or research report.</p>
</td></tr>
<tr><td><code id="jst_get_chapters_+3A_authors">authors</code></td>
<td>
<p>Extracting the authors is an expensive operation which makes
the function ~3 times slower, depending on the number of chapters and
the number of authors. Defaults to <code>FALSE</code>. Use <code>authors = TRUE</code> to
import the authors too.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, <code>jst_get_chapters()</code> is quite a lot slower than most of the other
functions. It is roughly 10 times slower than <code>jst_get_book</code>, depending on
the number of chapters to extract.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> containing the extracted meta-data with the following
columns:
</p>

<ul>
<li><p> book_id <em>(chr)</em>: The book id of type &quot;jstor&quot;, which is not a registered
DOI.
</p>
</li>
<li><p> file_name <em>(chr)</em>: The filename of the original .xml-file. Can be used
for joining with other data for the same file.
</p>
</li>
<li><p> part_id <em>(chr)</em>: The id of the part.
</p>
</li>
<li><p> part_label <em>(chr)</em>: A label for the part, if specified.
</p>
</li>
<li><p> part_title <em>(chr)</em>: The title of the part.
</p>
</li>
<li><p> part_subtitle <em>(chr)</em>: The subtitle of the part, if specified.
</p>
</li>
<li><p> authors <em>(list)</em>: A list-column with information on the authors. Can be
unnested with <code><a href="tidyr.html#topic+nest">tidyr::unnest()</a></code>. See the examples and <code><a href="#topic+jst_get_authors">jst_get_authors()</a></code>.
</p>
</li>
<li><p> abstract <em>(chr)</em>: The abstract to the part.
</p>
</li>
<li><p> part_first_page <em>(chr)</em>: The page where the part begins.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># extract parts without authors
jst_get_chapters(jst_example("book.xml"))

# import authors too
parts &lt;- jst_get_chapters(jst_example("book.xml"), authors = TRUE)
parts

tidyr::unnest(parts)
</code></pre>

<hr>
<h2 id='jst_get_file_name'>Extract the basename of a path</h2><span id='topic+jst_get_file_name'></span>

<h3>Description</h3>

<p>This helper simply extracts the basename of a path and removes the extension,
e.g. <code>foo/bar.txt</code> is shortened to <code>bar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_file_name(file_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_file_name_+3A_file_path">file_path</code></td>
<td>
<p>A path to a file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector, containing the basename of the file without an
extension.
</p>

<hr>
<h2 id='jst_get_footnotes'>Extract all footnotes</h2><span id='topic+jst_get_footnotes'></span>

<h3>Description</h3>

<p>This function extracts the content of <code>fn-group</code> from journal-articles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_footnotes(file_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_footnotes_+3A_file_path">file_path</code></td>
<td>
<p>The path to the <code>.xml</code>-file from which footnotes should be
extracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fn-group</code> usually contains footnotes corresponding to the article.
However, since footnotes are currently not fully supported by DfR,
there is no comprehensive documentation on the different variants. <code>jstor</code>
therefore extracts the content of <code>fn-group</code> exactly as it appears in the
data. Because of this, there might be other content present than footnotes.
</p>
<p>In order to get all available information on citation data, you might need to
combine <code>jst_get_footnotes()</code> with <code>jst_get_references()</code>.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> containing the content from <code>fn-group</code> (usually the
footnotes). If there were no footnotes, <code>NA_character</code> is returned for the
column <code>footnotes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jst_get_footnotes(jst_example("article_with_footnotes.xml"))
</code></pre>

<hr>
<h2 id='jst_get_full_text'>Import full-text</h2><span id='topic+jst_get_full_text'></span>

<h3>Description</h3>

<p>This function imports the full_text contents of a JSTOR-article.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_full_text(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_full_text_+3A_filename">filename</code></td>
<td>
<p>The path to the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code>, containing the file-path as id, the full content of
the file, and the encoding which was used to read it.
</p>

<hr>
<h2 id='jst_get_journal_overview'>Get table with information on journals</h2><span id='topic+jst_get_journal_overview'></span>

<h3>Description</h3>

<p>Download most recent or display cached version of data on journals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_journal_overview(most_recent = FALSE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_journal_overview_+3A_most_recent">most_recent</code></td>
<td>
<p>Should the most recent version be downloaded from DfR?
(Currently disabled due to changes on the JSTOR-servers).</p>
</td></tr>
<tr><td><code id="jst_get_journal_overview_+3A_quiet">quiet</code></td>
<td>
<p>Should status messages about the download be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When analysing your sample of articles from DfR, it might be helpful to have
some context about the journals in your sample. This function provides a
<code>tibble</code> with various information like the full name of the journal, the
short version of the name (sometimes referred to as <code>JCODE</code>), dates on where
the first
and last (available) issues were published, etc.
</p>
<p>The data on journals might change. Therefore this function provides two
sources of data: a cached version which gets updated with every release, and
the ability to pull the most recent version directly from DfR (this had to
be temporarily disabled.)
</p>
<p>The cached version was updated on 2020-04-03.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> with various information about journals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use the function without arguments to get a tibble from disk
jst_get_journal_overview()

## Not run: 
# download the most recent version from DfR
jst_get_journal_overview(most_recent = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='jst_get_ngram'>Read ngram data</h2><span id='topic+jst_get_ngram'></span>

<h3>Description</h3>

<p>Read in data on ngrams via <code><a href="readr.html#topic+read_delim">readr::read_tsv()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_ngram(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_ngram_+3A_file">file</code></td>
<td>
<p>A path to a file or a zip location from <code><a href="#topic+jst_subset_ngrams">jst_subset_ngrams()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly useful when it is used in together with
<a href="#topic+jst_import_zip">jst_import_zip</a>, where you can use it to specify reading in ngram data.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with two columns:
</p>

<ul>
<li> <p><em>ngram</em>: the ngram term (unigram, bigram, trigram)
</p>
</li>
<li> <p><em>n</em>: an integer for the number of times the term occurred in the original
file
</p>
</li></ul>


<hr>
<h2 id='jst_get_references'>Extract all references</h2><span id='topic+jst_get_references'></span>

<h3>Description</h3>

<p>This function extracts the content of <code>ref-list</code> from the <code>xml</code>-file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_references(file_path, parse_refs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_references_+3A_file_path">file_path</code></td>
<td>
<p>The path to the <code>.xml</code>-file from which references should be
extracted.</p>
</td></tr>
<tr><td><code id="jst_get_references_+3A_parse_refs">parse_refs</code></td>
<td>
<p>Should references be parsed, if available?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This content may contain references or endnotes, depending on how the article
used citations. Since references are currently not fully supported by DfR,
there is no comprehensive documentation on the different variants. <code>jstor</code>
therefore extracts the content of <code>ref-list</code> exactly as it appears in the
data. Because of this, there might be other content present than references.
</p>
<p>In order to get all available information on citation data, you might need to
combine <code>jst_get_references()</code> with <code>jst_get_footnotes()</code>.
</p>
<p>For newer <code>xml</code>-files, there would be the option to extract single elements
like authors, title or date of the source, but this is not yet implemented.
</p>
<p>In general, the implementation is not as fast as <code>jst_get_article()</code> -
articles with many references slow the process down.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> with the following columns:
</p>

<ul>
<li> <p><code>file_name</code>: the identifier for the article the references come from.
</p>
</li>
<li> <p><code>ref_title</code>: the title of the references sections.
</p>
</li>
<li> <p><code>ref_authors</code>: a string of authors. Several authors are separated with <code style="white-space: pre;">&#8288;;&#8288;</code>.
</p>
</li>
<li> <p><code>ref_editors</code>: a string of editors, if available.
</p>
</li>
<li> <p><code>ref_collab</code>: a field that may contain information on the authors, if authors
are not available.
</p>
</li>
<li> <p><code>ref_item_title</code>: the title of the cited entry. For books this is often
empty, with the title being in <code>ref_source</code>.
</p>
</li>
<li> <p><code>ref_year</code>: a year, often the article's publication year, but not always.
</p>
</li>
<li> <p><code>ref_source</code>: the source of the cited entry. For books often the title of the
book, for articles the publisher of the journal.
</p>
</li>
<li> <p><code>ref_volume</code>: the volume of the journal article.
</p>
</li>
<li> <p><code>ref_first_page</code>: the first page of the article/chapter.
</p>
</li>
<li> <p><code>ref_last_page</code>: the last page of the article/chapter.
</p>
</li>
<li> <p><code>ref_publisher</code>: For books the publisher, for articles often missing.
</p>
</li>
<li> <p><code>ref_publication_type</code>: Known types: <code>book</code>, <code>journal</code>, <code>web</code>, <code>other</code>.
</p>
</li>
<li> <p><code>ref_unparsed</code>: The full references entry in unparsed form.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>jst_get_references(jst_example("article_with_references.xml"))

# import parsed references
jst_get_references(
  jst_example("parsed_references.xml"),
  parse_refs = TRUE
) 
</code></pre>

<hr>
<h2 id='jst_get_total_pages'>Calculate total pages</h2><span id='topic+jst_get_total_pages'></span>

<h3>Description</h3>

<p>This function is a simple helper to calculate the total number of pages of
an article.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_get_total_pages(first_page, last_page, page_range, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_get_total_pages_+3A_first_page">first_page</code></td>
<td>
<p>The first page of an article (numeric).</p>
</td></tr>
<tr><td><code id="jst_get_total_pages_+3A_last_page">last_page</code></td>
<td>
<p>The last page of an article (numeric).</p>
</td></tr>
<tr><td><code id="jst_get_total_pages_+3A_page_range">page_range</code></td>
<td>
<p>The page range of an article (character).</p>
</td></tr>
<tr><td><code id="jst_get_total_pages_+3A_quietly">quietly</code></td>
<td>
<p>Sometimes page ranges contain roman numerals like <code>xiv</code>. These
are not recognized, return <code>NA</code> and raise a warning. If set to <code>TRUE</code>, this
warning not raised.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deals with four cases:
</p>

<ul>
<li><p> if all three arguments are missing, NA is returned.
</p>
</li>
<li><p> if page_range is supplied, the number of pages is calculated from it.
</p>
</li>
<li><p> if only the first page is supplied, NA is returned.
</p>
</li>
<li><p> if first and last page are supplied, the number of pages is calculated as
<code>last_page - first_page + 1</code>.
</p>
</li></ul>

<p>The algorithm to parse page ranges works as follows: A typical page range is
<code style="white-space: pre;">&#8288;1-10, 200&#8288;</code> where the article starts at page 1, ends at page 10, and has an
erratum at page 200. For this case, the range is calculated as
<code>range + single_page</code>, as in<code>(10 - 1 + 1) + 1 = 11</code>. Sometimes multiple
ranges are given: <code style="white-space: pre;">&#8288;1-10, 11-20&#8288;</code>. For those cases all ranges are summed:
<code>(10 - 1 + 1) + (20 - 11 + 1) = 20</code>. Another specification for multiple
ranges is <code>1-10+11-20</code>, which is treated similarly.
</p>


<h3>Value</h3>

<p>A vector with the calculated total pages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate pages from first and last page
first_pages &lt;- sample(30:50, 10)
last_pages &lt;- first_pages + sample(5:20, 10)
page_ranges &lt;- rep(NA_character_, 10)

jst_get_total_pages(first_pages, last_pages, page_ranges)

# get pages from page range
jst_get_total_pages(NA_real_, NA_real_, "51 - 70")
jst_get_total_pages(NA_real_, NA_real_, "51 - 70, 350")
jst_get_total_pages(NA_real_, NA_real_, "350, 51 - 70")
jst_get_total_pages(NA_real_, NA_real_, "51 - 70, 80-100")
jst_get_total_pages(NA_real_, NA_real_, "51-70+350")
</code></pre>

<hr>
<h2 id='jst_import'>Wrapper for file import</h2><span id='topic+jst_import'></span><span id='topic+jst_import_zip'></span>

<h3>Description</h3>

<p>This function applies an import function to a list of <code>xml</code>-files
or a .zip-archive in case of <code>jst_import_zip</code> and saves
the output in batches of <code>.csv</code>-files to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_import(
  in_paths,
  out_file,
  out_path = NULL,
  .f,
  col_names = TRUE,
  n_batches = NULL,
  files_per_batch = NULL,
  show_progress = TRUE
)

jst_import_zip(
  zip_archive,
  import_spec,
  out_file,
  out_path = NULL,
  col_names = TRUE,
  n_batches = NULL,
  files_per_batch = NULL,
  show_progress = TRUE,
  rows = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_import_+3A_in_paths">in_paths</code></td>
<td>
<p>A character vector to the <code>xml</code>-files which should be
imported</p>
</td></tr>
<tr><td><code id="jst_import_+3A_out_file">out_file</code></td>
<td>
<p>Name of files to export to. Each batch gets appended by an
increasing number.</p>
</td></tr>
<tr><td><code id="jst_import_+3A_out_path">out_path</code></td>
<td>
<p>Path to export files to (combined with filename).</p>
</td></tr>
<tr><td><code id="jst_import_+3A_.f">.f</code></td>
<td>
<p>Function to use for import. Can be one of <code>jst_get_article</code>,
<code>jst_get_authors</code>, <code>jst_get_references</code>, <code>jst_get_footnotes</code>, <code>jst_get_book</code>
or <code>jst_get_chapter</code>.</p>
</td></tr>
<tr><td><code id="jst_import_+3A_col_names">col_names</code></td>
<td>
<p>Should column names be written to file? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="jst_import_+3A_n_batches">n_batches</code></td>
<td>
<p>Number of batches, defaults to 1.</p>
</td></tr>
<tr><td><code id="jst_import_+3A_files_per_batch">files_per_batch</code></td>
<td>
<p>Number of files for each batch. Can be used instead of
n_batches, but not in conjunction.</p>
</td></tr>
<tr><td><code id="jst_import_+3A_show_progress">show_progress</code></td>
<td>
<p>Displays a progress bar for each batch, if the session
is interactive.</p>
</td></tr>
<tr><td><code id="jst_import_+3A_zip_archive">zip_archive</code></td>
<td>
<p>A path to a .zip-archive from DfR</p>
</td></tr>
<tr><td><code id="jst_import_+3A_import_spec">import_spec</code></td>
<td>
<p>A specification from <a href="#topic+jst_define_import">jst_define_import</a>
for which parts of a .zip-archive should be imported via which functions.</p>
</td></tr>
<tr><td><code id="jst_import_+3A_rows">rows</code></td>
<td>
<p>Mainly used for testing, to decrease the number of files which
are imported (i.e. 1:100).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Along the way, we wrap three functions, which make the process of converting
many files easier:
</p>

<ul>
<li> <p><code><a href="purrr.html#topic+safely">purrr::safely()</a></code>
</p>
</li>
<li> <p><code><a href="furrr.html#topic+future_map">furrr::future_map()</a></code>
</p>
</li>
<li> <p><code><a href="readr.html#topic+write_delim">readr::write_csv()</a></code>
</p>
</li></ul>

<p>When using one of the <code style="white-space: pre;">&#8288;find_*&#8288;</code> functions, there should usually be no errors.
To avoid the whole computation to fail in the unlikely event that an error
occurs, we use <code>safely()</code> which let's us
continue the process, and catch the error along the way.
</p>
<p>If you have many files to import, you might benefit from executing the
function in parallel. We use futures for this to give you maximum
flexibility. By default the code is executed sequentially. If you want to
run it in parallel, simply call <code><a href="future.html#topic+plan">future::plan()</a></code> with
<code><a href="future.html#topic+multisession">future::multisession()</a></code> as an argument before
running <code>jst_import</code> or <code>jst_import_zip</code>.
</p>
<p>After importing all files, they are written to disk with
<code><a href="readr.html#topic+write_delim">readr::write_csv()</a></code>.
</p>
<p>Since you might run out of memory when importing a large quantity of files,
you can split up the files to import  into batches. Each batch is being
treated separately, therefore for each batch multiple processes from
<code><a href="future.html#topic+multisession">future::multisession()</a></code> are spawned, if you added this plan.
For this reason, it is not recommended to have very small batches,
as there is an overhead for starting and ending the processes. On the other
hand, the batches should not be too large, to not exceed memory limitations.
A value of 10000 to 20000 for <code>files_per_batch</code> should work fine on most
machines. If the session is interactive and <code>show_progress</code> is <code>TRUE</code>, a
progress bar is displayed for each batch.
</p>


<h3>Value</h3>

<p>Writes <code>.csv</code>-files to disk.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jst_combine_outputs">jst_combine_outputs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# read from file list --------
# find all files
meta_files &lt;- list.files(pattern = "xml", full.names = TRUE)

# import them via `jst_get_article`
jst_import(meta_files, out_file = "imported_metadata", .f = jst_get_article,
           files_per_batch = 25000)
           
# do the same, but in parallel
library(future)
plan(multiprocess)
jst_import(meta_files, out_file = "imported_metadata", .f = jst_get_article,
           files_per_batch = 25000)

# read from zip archive ------ 
# define imports
imports &lt;- jst_define_import(article = c(jst_get_article, jst_get_authors))

# convert the files to .csv
jst_import_zip("my_archive.zip", out_file = "my_out_file", 
                 import_spec = imports)

## End(Not run) 
</code></pre>

<hr>
<h2 id='jst_preview_zip'>Preview content of zip files</h2><span id='topic+jst_preview_zip'></span>

<h3>Description</h3>

<p>This function gives you a quick preview about what a .zip-file from DfR
contains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_preview_zip(zip_archive)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_preview_zip_+3A_zip_archive">zip_archive</code></td>
<td>
<p>A path to a .zip-file from DfR</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a tibble with three columns:
</p>

<ul>
<li> <p><em>type</em>: metadata or some form of ngram
</p>
</li>
<li> <p><em>meta_type</em>: which type of metadata (book_chapter, journal article, ...)
</p>
</li>
<li> <p><em>n</em>: a count for each category
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>jst_preview_zip(jst_example("pseudo_dfr.zip"))
</code></pre>

<hr>
<h2 id='jst_re_import'>Re-import files</h2><span id='topic+jst_re_import'></span>

<h3>Description</h3>

<p><code>jst_re_import()</code> lets you re-import a file which was exported via
<code><a href="#topic+jst_import">jst_import()</a></code> or <code><a href="#topic+jst_import_zip">jst_import_zip()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_re_import(file, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_re_import_+3A_file">file</code></td>
<td>
<p>A path to a .csv file.</p>
</td></tr>
<tr><td><code id="jst_re_import_+3A_warn">warn</code></td>
<td>
<p>Should warnings be emitted, if the type of file cannot be
determined?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When attempting to re-import, a heuristic is applied. If the file has column
names which match the names from any of the <code style="white-space: pre;">&#8288;find_*&#8288;</code> functions, the file
is read with the corresponding specifications. If no column names are
recognized, files are recognized based on the number of columns. Since both
references and footnotes have only two columns, the first line is inspected
for either <code>"Referenc...|Bilbio...|Endnote..."</code> or <code>"Footnote..."</code>.
In case there is still no match, the file is read with
<code><a href="readr.html#topic+read_delim">readr::read_csv()</a></code> with <code>guess_max = 5000</code> and a warning is raised.
</p>


<h3>Value</h3>

<p>A <code>tibble</code>, with the columns determined based on heuristics applied
to the input file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jst_combine_outputs">jst_combine_outputs()</a></code>
</p>

<hr>
<h2 id='jst_subset_ngrams'>Define a subset of ngrams</h2><span id='topic+jst_subset_ngrams'></span>

<h3>Description</h3>

<p>This function helps in defining a subset of ngram files which should be
imported, since importing all ngrams at once can be very expensive (in
terms of cpu and memory).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_subset_ngrams(zip_archives, ngram_type, selection, by = file_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_subset_ngrams_+3A_zip_archives">zip_archives</code></td>
<td>
<p>A character vector of one or multiple zip-files.</p>
</td></tr>
<tr><td><code id="jst_subset_ngrams_+3A_ngram_type">ngram_type</code></td>
<td>
<p>One of <code>"ngram1"</code>, <code>"ngram2"</code> or <code>"ngram3"</code></p>
</td></tr>
<tr><td><code id="jst_subset_ngrams_+3A_selection">selection</code></td>
<td>
<p>A data.frame with the articles/books which are to be
selected.</p>
</td></tr>
<tr><td><code id="jst_subset_ngrams_+3A_by">by</code></td>
<td>
<p>A column name for matching.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of zip-locations which can be read via <code><a href="#topic+jst_get_ngram">jst_get_ngram()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create sample output
tmp &lt;- tempdir()
jst_import_zip(jst_example("pseudo_dfr.zip"),
               import_spec = jst_define_import(book = jst_get_book),
               out_file = "test", out_path = tmp)

# re-import as our selection for which we would like to import ngrams
selection &lt;- jst_re_import(file.path(tmp, 
                                     "test_book_chapter_jst_get_book-1.csv"))

# get location of file
zip_loc &lt;- jst_subset_ngrams(jst_example("pseudo_dfr.zip"), "ngram1",
                             selection) 

# import ngram
jst_get_ngram(zip_loc[[1]])
unlink(tmp)
</code></pre>

<hr>
<h2 id='jst_unify_journal_id'>Unify journal IDs</h2><span id='topic+jst_unify_journal_id'></span>

<h3>Description</h3>

<p>This function is a simple wrapper to unify journal ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jst_unify_journal_id(meta_data, remove_cols = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jst_unify_journal_id_+3A_meta_data">meta_data</code></td>
<td>
<p>Data which was processed via <code><a href="#topic+jst_get_article">jst_get_article()</a></code>.</p>
</td></tr>
<tr><td><code id="jst_unify_journal_id_+3A_remove_cols">remove_cols</code></td>
<td>
<p>Should the original columns be removed after unifying?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Date on journal ids can be found in three columns:
<code>journal_pub_id</code>, <code>journal_jcode</code> and <code>journal_doi</code>. From my experience,
most of the time the relevant dat ais present in <code>journal_pub_id</code> or
<code>journal_jcode</code>, with <code>journal_jcode</code> being to most common identifier.
This function takes the value from <code>journal_pub_id</code>, and if it is missing,
that from <code>journal_jcode</code>. <code>journal_doi</code> is currently disregarded.
</p>


<h3>Value</h3>

<p>A modified <code>tibble</code>.
</p>
<p>A modified tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>article &lt;- jst_get_article(jst_example("article_with_references.xml"))

jst_unify_journal_id(article)


# per default, original columns with data on the journal are removed
library(dplyr)

jst_unify_journal_id(article) %&gt;% 
  select(contains("journal")) %&gt;% 
  names()
  
# you can keep them by setting `remove_cols` to `FALSE`
jst_unify_journal_id(article, remove_cols = FALSE) %&gt;%  
  select(contains("journal")) %&gt;%
  names()
</code></pre>

<hr>
<h2 id='jstor'>jstor: Read Data from JSTOR/DfR</h2><span id='topic+jstor'></span>

<h3>Description</h3>

<p>The tool <a href="https://www.jstor.org/dfr/">Data for Research (DfR)</a> by JSTOR is a
valuable source for citation analysis and text mining. <code>jstor</code>
provides functions and suggests workflows for importing
datasets from DfR.
</p>


<h3>Details</h3>

<p>Please refer to the vignettes for information on how to use the package:
</p>
<p><code>browseVignettes("jstor")</code>
</p>
<p>If you encounter any issues or have ideas for new features, please file an
issue at <a href="https://github.com/ropensci/jstor/issues">https://github.com/ropensci/jstor/issues</a>.
</p>


<h3>Author(s)</h3>

<p>Thomas Klebel
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
