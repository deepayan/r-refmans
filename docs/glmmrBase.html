<!DOCTYPE html><html><head><title>Help for package glmmrBase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glmmrBase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#glmmrBase-package'>
<p>Generalised Linear Mixed Models in R</p></a></li>
<li><a href='#Beta'><p>Beta distribution declaration</p></a></li>
<li><a href='#coef.mcml'><p>Extracts fixed effect coefficients from a mcml object</p></a></li>
<li><a href='#coef.Model'><p>Extracts coefficients from a Model object</p></a></li>
<li><a href='#confint.mcml'><p>Fixed effect confidence intervals for a 'mcml' object</p></a></li>
<li><a href='#Covariance'><p>R6 Class representing a covariance function and data</p></a></li>
<li><a href='#cross_df'><p>Generate crossed block structure</p></a></li>
<li><a href='#cycles'><p>Generates all the orderings of a</p></a></li>
<li><a href='#family.mcml'><p>Extracts the family from a 'mcml' object.</p></a></li>
<li><a href='#family.Model'><p>Extracts the family from a 'Model' object. This information can also be</p>
accessed directly from the Model as 'Model$family'</a></li>
<li><a href='#fitted.mcml'><p>Fitted values from a 'mcml' object</p></a></li>
<li><a href='#fitted.Model'><p>Extract or generate fitted values from a 'Model' object</p></a></li>
<li><a href='#fixed.effects'><p>Extracts the fixed effect estimates</p></a></li>
<li><a href='#formula.mcml'><p>Extracts the formula from a 'mcml' object.</p></a></li>
<li><a href='#formula.Model'><p>Extracts the formula from a 'Model' object</p></a></li>
<li><a href='#logLik.mcml'><p>Extracts the log-likelihood from an mcml object</p></a></li>
<li><a href='#logLik.Model'><p>Extracts the log-likelihood from an mcml object</p></a></li>
<li><a href='#match_rows'><p>Generate matrix mapping between data frames</p></a></li>
<li><a href='#mcnr_family'><p>Returns the file name and type for MCNR function</p></a></li>
<li><a href='#MeanFunction'><p>R6 Class representing a mean function/linear predictor</p></a></li>
<li><a href='#Model'><p>A GLMM Model</p></a></li>
<li><a href='#nelder'><p>Generates a block experimental structure using Nelder's formula</p></a></li>
<li><a href='#nest_df'><p>Generate nested block structure</p></a></li>
<li><a href='#predict.mcml'><p>Predict from a 'mcml' object</p></a></li>
<li><a href='#predict.Model'><p>Generate predictions at new values from a 'Model' object</p></a></li>
<li><a href='#print.mcml'><p>Prints an mcml fit output</p></a></li>
<li><a href='#progress_bar'><p>Generates a progress bar</p></a></li>
<li><a href='#random.effects'><p>Extracts the random effect estimates</p></a></li>
<li><a href='#residuals.mcml'><p>Residuals method for a 'mcml' object</p></a></li>
<li><a href='#residuals.Model'><p>Extract residuals from a 'Model' object</p></a></li>
<li><a href='#setParallel'><p>Disable or enable parallelised computing</p></a></li>
<li><a href='#summary.mcml'><p>Summarises an mcml fit output</p></a></li>
<li><a href='#summary.Model'><p>Summarizes a 'Model' object</p></a></li>
<li><a href='#vcov.mcml'><p>Extract the Variance-Covariance matrix for a 'mcml' object</p></a></li>
<li><a href='#vcov.Model'><p>Calculate Variance-Covariance matrix for a 'Model' object</p></a></li>
<li><a href='#yexample312a'><p>Data for first example in Section 3.12 of JSS paper</p></a></li>
<li><a href='#yexample312b'><p>Data for second example in Section 3.12 of JSS paper</p></a></li>
<li><a href='#yexample312c'><p>Data for third example in Section 3.12 of JSS paper</p></a></li>
<li><a href='#ytest1'><p>Data for model tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalised Linear Mixed Models in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-31</td>
</tr>
<tr>
<td>Description:</td>
<td>Specification, analysis, simulation, and fitting of generalised linear mixed models. 
  Includes Markov Chain Monte Carlo Maximum likelihood and Laplace approximation model fitting for a range of models, 
  non-linear fixed effect specifications, a wide range of flexible covariance functions that can be combined arbitrarily,
  robust and bias-corrected standard error estimation, power calculation, data simulation, and more. 
  See <a href="https://samuel-watson.github.io/glmmr-web/">https://samuel-watson.github.io/glmmr-web/</a> for a detailed manual.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 1.0.11), R6, rstan (&ge; 2.32.1), rstantools
(&ge; 2.3.1.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.11), RcppEigen, SparseChol (&ge; 0.3.1), BH,
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.32.1), StanHeaders (&ge;
2.32.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Sam Watson [aut, cre]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/samuel-watson/glmmrBase">https://github.com/samuel-watson/glmmrBase</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/samuel-watson/glmmrBase/issues">https://github.com/samuel-watson/glmmrBase/issues</a></td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Matrix (&ge; 1.3-1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-08 17:11:32 UTC; WatsonSI</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sam Watson &lt;S.I.Watson@bham.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-08 19:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='glmmrBase-package'>
Generalised Linear Mixed Models in R
</h2><span id='topic+glmmrBase-package'></span><span id='topic+glmmrBase'></span>

<h3>Description</h3>

<p>Specification, analysis, simulation, and fitting of generalised linear mixed models. 
  Includes Markov Chain Monte Carlo Maximum likelihood and Laplace approximation model fitting for a range of models, 
  non-linear fixed effect specifications, a wide range of flexible covariance functions that can be combined arbitrarily,
  robust and bias-corrected standard error estimation, power calculation, data simulation, and more. 
  See &lt;https://samuel-watson.github.io/glmmr-web/&gt; for a detailed manual.
<code>glmmrBase</code> provides functions for specifying, analysing, fitting, and simulating mixed models including linear, generalised linear, and models non-linear in fixed effects.. 
</p>


<h3>Differences between <span class="pkg">glmmrBase</span> and <span class="pkg">lme4</span> and related packages.</h3>

<p><span class="pkg">glmmrBase</span> is intended to be a broad package to support statistical work with generalised linear mixed models. While there are Laplace Approximation methods in the package, it does not intend to replace or supplant popular mixed model packages like <span class="pkg">lme4</span>. Rather it provides broader functionality around simulation and analysis methods, and a range of model fitting algorithms not found in other mixed model packages. The key features are:
</p>

<ul>
<li><p> Stochastic maximum likelihood methods. The most widely used methods for mixed model fitting are penalised quasi-likelihood, Laplace approximation, and Gaussian quadrature methods. These methods are widely available in other packages. We provide Markov Chain Monte Carlo (MCMC) Maximum Likelihood and Stochastic Approximation Expectation Maximisation algorithms for model fitting, with various features. These algorithms approximate the intractable GLMM likelihood using MCMC and so can provide an arbitrary level of precision. These methods may provide better maximum likelihood performance than other approximations in settings with high-dimensional or complex random effects, small sample sizes, or non-linear models.
</p>
</li>
<li><p> Flexible support for a wide range of covariance functions. The support for different covariance functions can be limited in other packages. For example, <span class="pkg">lme4</span> only provides exchangeable random effects structures. We include multiple different functions that can be combined arbitrarily.
</p>
</li>
<li><p> We similarly use model, efficient linear algebra methods with the <span class="pkg">Eigen</span> package along with <span class="pkg">Stan</span> to provide MCMC sampling.
</p>
</li>
<li><p> Gaussian Process approximations. We include Hibert Space and Nearest Neighbour Gaussian Process approximations for high dimensional random effects.
</p>
</li>
<li><p> The <code>Model</code> class includes methods for power estimation, data simulation, MCMC sampling, and calculation of a wide range of matrices and values associated with the models.
</p>
</li>
<li><p> We include natively a range of small sample corrections to information matrices, including Kenward-Roger, Box, Satterthwaite, and others, which typically require add-on packages for <span class="pkg">lme4</span>.
</p>
</li>
<li><p> The package provides a flexible class system for specifying mixed models that can be incorporated into other packages and settings. The linked package <span class="pkg">glmmrOptim</span> provides optimal experimental design algorithms for mixed models.
</p>
</li></ul>



<h3>Package development</h3>

<p>The package is still in development and there may still be bugs and errors. While we do not expect the general user interface to change there may be changes to the underlying library as well as new additions and functionality.
</p>


<h3>Author(s)</h3>

<p>Sam Watson [aut, cre]
</p>
<p>Maintainer: NA
</p>

<hr>
<h2 id='Beta'>Beta distribution declaration</h2><span id='topic+Beta'></span>

<h3>Description</h3>

<p>Skeleton list to declare a Beta distribution in a 'Model' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Beta(link = "logit")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Beta_+3A_link">link</code></td>
<td>
<p>Name of link function. Only accepts 'logit' currently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements naming the family and link function
</p>

<hr>
<h2 id='coef.mcml'>Extracts fixed effect coefficients from a mcml object</h2><span id='topic+coef.mcml'></span>

<h3>Description</h3>

<p>Extracts the fitted fixed effect coefficients from an 'mcml' object returned from a call of 'MCML' or 'LA' in the <a href="#topic+Model">Model</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.mcml_+3A_object">object</code></td>
<td>
<p>An 'mcml' model fit.</p>
</td></tr>
<tr><td><code id="coef.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector.
</p>

<hr>
<h2 id='coef.Model'>Extracts coefficients from a Model object</h2><span id='topic+coef.Model'></span>

<h3>Description</h3>

<p>Extracts the coefficients from a 'Model' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Model'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.Model_+3A_object">object</code></td>
<td>
<p>A 'Model' object.</p>
</td></tr>
<tr><td><code id="coef.Model_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fixed effect and covariance parameters extracted from the model object.
</p>

<hr>
<h2 id='confint.mcml'>Fixed effect confidence intervals for a 'mcml' object</h2><span id='topic+confint.mcml'></span>

<h3>Description</h3>

<p>Returns the computed confidence intervals for a 'mcml' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
confint(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.mcml_+3A_object">object</code></td>
<td>
<p>A 'mcml' object.</p>
</td></tr>
<tr><td><code id="confint.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper confidence limits for each parameter.
</p>

<hr>
<h2 id='Covariance'>R6 Class representing a covariance function and data</h2><span id='topic+Covariance'></span>

<h3>Description</h3>

<p>R6 Class representing a covariance function and data
</p>
<p>R6 Class representing a covariance function and data
</p>


<h3>Details</h3>

<p>For the generalised linear mixed model
</p>
<p style="text-align: center;"><code class="reqn">Y \sim F(\mu,\sigma)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu = h^-1(X\beta + Z\gamma)</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma \sim MVN(0,D)</code>
</p>

<p>where h is the link function, this class defines Z and D. The covariance is defined by a covariance function, data, and parameters.
A new instance can be generated with $new(). The class will generate the
relevant matrices Z and D automatically. See <a href="https://github.com/samuel-watson/glmmrBase/blob/master/README.md">glmmrBase</a> for a
detailed guide on model specification.
</p>
<p>**Intitialisation**
A covariance function is specified as an additive formula made up of
components with structure <code>(1|f(j))</code>. The left side of the vertical bar
specifies the covariates in the model that have a random effects structure.
The right side of the vertical bar specify the covariance function 'f' for
that term using variable named in the data 'j'.
Covariance functions on the right side of the vertical bar are multiplied
together, i.e. <code>(1|f(j)*g(t))</code>.
</p>
<p>There are several common functions included for a named variable in data <code>x</code>.
A non-exhaustive list (see <a href="https://github.com/samuel-watson/glmmrBase/blob/master/README.md">glmmrBase</a> for a full list):
* <code>gr(x)</code>: Indicator function (1 parameter)
* <code>fexp(x)</code>: Exponential function (2 parameters)
* <code>ar(x)</code>: AR function (2 parameters)
* <code>sqexp(x)</code>: Squared exponential (1 parameter)
* <code>matern(x)</code>: Matern function (2 parameters)
* <code>bessel(x)</code>: Modified Bessel function of the 2nd kind (1 parameter)
For many 2 parameter functions, such as 'ar' and 'fexp', alternative one parameter 
versions are also available as 'ar0' and 'fexp0'. These function omit the variance 
parameter and so can be used in combination with 'gr' functions such as 'gr(j)*ar0(t)'.
</p>
<p>Parameters are provided to the covariance function as a vector.
The parameters in the vector for each function should be provided
in the order the covariance functions are written are written.
For example,
* Formula: '~(1|gr(j))+(1|gr(j*t))'; parameters: 'c(0.05,0.01)'
* Formula: '~(1|gr(j)*fexp0(t))'; parameters: 'c(0.05,0.5)'
</p>
<p>Updating of parameters is automatic if using the 'update_parameters()' member function.
</p>
<p>Using 'update_parameters()' is the preferred way of updating the parameters of the
mean or covariance objects as opposed to direct assignment, e.g. 'self$parameters &lt;- c(...)'.
The function calls check functions to automatically update linked matrices with the new parameters.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>data</code></dt><dd><p>Data frame with data required to build covariance</p>
</dd>
<dt><code>formula</code></dt><dd><p>Covariance function formula.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>Model parameters specified in order of the functions in the formula.</p>
</dd>
<dt><code>Z</code></dt><dd><p>Design matrix</p>
</dd>
<dt><code>D</code></dt><dd><p>Covariance matrix of the random effects</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Covariance-n"><code>Covariance$n()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-new"><code>Covariance$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-update_parameters"><code>Covariance$update_parameters()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-print"><code>Covariance$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-subset"><code>Covariance$subset()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-chol_D"><code>Covariance$chol_D()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-log_likelihood"><code>Covariance$log_likelihood()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-simulate_re"><code>Covariance$simulate_re()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-sparse"><code>Covariance$sparse()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-parameter_table"><code>Covariance$parameter_table()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-nngp"><code>Covariance$nngp()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-hsgp"><code>Covariance$hsgp()</code></a>
</p>
</li>
<li> <p><a href="#method-Covariance-clone"><code>Covariance$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Covariance-n"></a>



<h4>Method <code>n()</code></h4>

<p>Return the size of the design
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$n()</pre></div>



<h5>Returns</h5>

<p>Scalar
</p>


<hr>
<a id="method-Covariance-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Covariance object
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$new(formula, data = NULL, parameters = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>formula</code></dt><dd><p>Formula describing the covariance function. See Details</p>
</dd>
<dt><code>data</code></dt><dd><p>(Optional) Data frame with data required for constructing the covariance.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>(Optional) Vector with parameter values for the functions in the model
formula. See Details.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A Covariance object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
df &lt;- nelder(~(cl(5)*t(5)) &gt; ind(5))
cov &lt;- Covariance$new(formula = ~(1|gr(cl)*ar0(t)),
                      parameters = c(0.05,0.7),
                      data= df)
</pre>
</div>


<hr>
<a id="method-Covariance-update_parameters"></a>



<h4>Method <code>update_parameters()</code></h4>

<p>Updates the covariance parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$update_parameters(parameters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameters</code></dt><dd><p>A vector of parameters for the covariance function(s). See Details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Covariance-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show details of Covariance object
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$print()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
df &lt;- nelder(~(cl(5)*t(5)) &gt; ind(5))
Covariance$new(formula = ~(1|gr(cl)*ar0(t)),
                      parameters = c(0.05,0.8),
                      data= df)
</pre>
</div>


<hr>
<a id="method-Covariance-subset"></a>



<h4>Method <code>subset()</code></h4>

<p>Keep specified indices and removes the rest
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$subset(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>vector of indices to keep</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
cov &lt;- Covariance$new(formula = ~(1|gr(cl)*ar0(t)),
                      parameters = c(0.05,0.8),
                      data= df)
cov$subset(1:100)
</pre>
</div>


<hr>
<a id="method-Covariance-chol_D"></a>



<h4>Method <code>chol_D()</code></h4>

<p>Returns the Cholesky decomposition of the covariance matrix D
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$chol_D()</pre></div>



<h5>Returns</h5>

<p>A matrix
</p>


<hr>
<a id="method-Covariance-log_likelihood"></a>



<h4>Method <code>log_likelihood()</code></h4>

<p>The function returns the values of the multivariate Gaussian log likelihood
with mean zero and covariance D for a given vector of random effect terms.
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$log_likelihood(u)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>u</code></dt><dd><p>Vector of random effects</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Value of the log likelihood
</p>


<hr>
<a id="method-Covariance-simulate_re"></a>



<h4>Method <code>simulate_re()</code></h4>

<p>Simulates a set of random effects from the multivariate Gaussian distribution
with mean zero and covariance D.
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$simulate_re()</pre></div>



<h5>Returns</h5>

<p>A vector of random effect values
</p>


<hr>
<a id="method-Covariance-sparse"></a>



<h4>Method <code>sparse()</code></h4>

<p>If this function is called then sparse matrix methods will be used for calculations involving D
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$sparse(sparse = TRUE, amd = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sparse</code></dt><dd><p>Logical. Whether to use sparse methods (TRUE) or not (FALSE)</p>
</dd>
<dt><code>amd</code></dt><dd><p>Logical indicating whether to use and Approximate Minimum Degree algorithm to calculate an efficient permutation matrix so 
that the Cholesky decomposition of PAP^T is calculated rather than A.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None. Called for effects.
</p>


<hr>
<a id="method-Covariance-parameter_table"></a>



<h4>Method <code>parameter_table()</code></h4>

<p>Returns a table showing which parameters are members of which covariance
function term.
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$parameter_table()</pre></div>



<h5>Returns</h5>

<p>A data frame
</p>


<hr>
<a id="method-Covariance-nngp"></a>



<h4>Method <code>nngp()</code></h4>

<p>Reports or sets the parameters for the nearest neighbour Gaussian process
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$nngp(nn = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nn</code></dt><dd><p>Integer. Number of nearest neighbours. Optional - leave as NULL to return
details of the NNGP instead.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If 'nn' is NULL then the function will either return FALSE if not using a 
Nearest neighbour approximation, or TRUE and the number of nearest neighbours, otherwise
it will return nothing.
</p>


<hr>
<a id="method-Covariance-hsgp"></a>



<h4>Method <code>hsgp()</code></h4>

<p>Reports or sets the parameters for the Hilbert Space Gaussian process
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$hsgp(m = NULL, L = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>m</code></dt><dd><p>Integer or vector of integers. Number of basis functions per dimension. If only
a single number is provided and there is more than one dimension the same number will be applied
to all dimensions.</p>
</dd>
<dt><code>L</code></dt><dd><p>Decimal. The boundary extension.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If 'm' and 'L' are NULL then the function will either return FALSE if not using a 
Hilbert space approximation, or TRUE and the number of bases functions and boundary value, otherwise
it will return nothing.
</p>


<hr>
<a id="method-Covariance-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Covariance$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Covariance$new`
## ------------------------------------------------


df &lt;- nelder(~(cl(5)*t(5)) &gt; ind(5))
cov &lt;- Covariance$new(formula = ~(1|gr(cl)*ar0(t)),
                      parameters = c(0.05,0.7),
                      data= df)

## ------------------------------------------------
## Method `Covariance$print`
## ------------------------------------------------


df &lt;- nelder(~(cl(5)*t(5)) &gt; ind(5))
Covariance$new(formula = ~(1|gr(cl)*ar0(t)),
                      parameters = c(0.05,0.8),
                      data= df)

## ------------------------------------------------
## Method `Covariance$subset`
## ------------------------------------------------


df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
cov &lt;- Covariance$new(formula = ~(1|gr(cl)*ar0(t)),
                      parameters = c(0.05,0.8),
                      data= df)
cov$subset(1:100)
</code></pre>

<hr>
<h2 id='cross_df'>Generate crossed block structure</h2><span id='topic+cross_df'></span>

<h3>Description</h3>

<p>Generate a data frame with crossed rows from two other data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_df(df1, df2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_df_+3A_df1">df1</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="cross_df_+3A_df2">df2</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two data frames 'df1' and 'df2', the function will return another data frame
that crosses them, which has rows with every unique combination of the input data frames
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cross_df(data.frame(t=1:4),data.frame(cl=1:3))
</code></pre>

<hr>
<h2 id='cycles'>Generates all the orderings of a</h2><span id='topic+cycles'></span>

<h3>Description</h3>

<p>Given input a, returns a length(a)^2 vector by cycling through the values of a
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cycles(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cycles_+3A_a">a</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>

<hr>
<h2 id='family.mcml'>Extracts the family from a 'mcml' object.</h2><span id='topic+family.mcml'></span>

<h3>Description</h3>

<p>Extracts the <a href="stats.html#topic+family">family</a> from a 'mcml' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
family(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family.mcml_+3A_object">object</code></td>
<td>
<p>A 'mcml' object.</p>
</td></tr>
<tr><td><code id="family.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="stats.html#topic+family">family</a> object.
</p>

<hr>
<h2 id='family.Model'>Extracts the family from a 'Model' object. This information can also be
accessed directly from the Model as 'Model$family'</h2><span id='topic+family.Model'></span>

<h3>Description</h3>

<p>Extracts the <a href="stats.html#topic+family">family</a> from a 'Model' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Model'
family(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family.Model_+3A_object">object</code></td>
<td>
<p>A 'Model' object.</p>
</td></tr>
<tr><td><code id="family.Model_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="stats.html#topic+family">family</a> object.
</p>

<hr>
<h2 id='fitted.mcml'>Fitted values from a 'mcml' object</h2><span id='topic+fitted.mcml'></span>

<h3>Description</h3>

<p>Fitted values should not be generated directly from an 'mcml' object, rather fitted values should be
generated using the original 'Model'. A message is printed to the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.mcml_+3A_object">object</code></td>
<td>
<p>A 'mcml' object.</p>
</td></tr>
<tr><td><code id="fitted.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for effects, unless 'override' is TRUE, when it will return a vector of fitted values.
</p>

<hr>
<h2 id='fitted.Model'>Extract or generate fitted values from a 'Model' object</h2><span id='topic+fitted.Model'></span>

<h3>Description</h3>

<p>Return fitted values. Does not account for the random effects. This function is a wrapper for 'Model$fitted()', which 
also provides a variety of additional options for generating fitted values from mixed models. 
For simulated values based on resampling random effects, see also 'Model$sim_data()'. To predict the values including random effects at a new location see also
'Model$predict()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Model'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.Model_+3A_object">object</code></td>
<td>
<p>A 'Model' object.</p>
</td></tr>
<tr><td><code id="fitted.Model_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitted values
</p>

<hr>
<h2 id='fixed.effects'>Extracts the fixed effect estimates</h2><span id='topic+fixed.effects'></span>

<h3>Description</h3>

<p>Extracts the fixed effect estimates from an mcml object returned from call of 'MCML' or 'LA' in the <a href="#topic+Model">Model</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed.effects(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed.effects_+3A_object">object</code></td>
<td>
<p>An 'mcml' model fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named, numeric vector of fixed-effects estimates.
</p>

<hr>
<h2 id='formula.mcml'>Extracts the formula from a 'mcml' object.</h2><span id='topic+formula.mcml'></span>

<h3>Description</h3>

<p>Extracts the <a href="stats.html#topic+formula">formula</a> from a 'mcml' object. Separate formulae are 
specified for the fixed and random effects in the model, either of which can be
returned. The complete formula is available from the generating 'Model' object as 
'Model$formula' or 'formula(Model)'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.mcml_+3A_x">x</code></td>
<td>
<p>A 'mcml' object.</p>
</td></tr>
<tr><td><code id="formula.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="stats.html#topic+formula">formula</a> object.
</p>

<hr>
<h2 id='formula.Model'>Extracts the formula from a 'Model' object</h2><span id='topic+formula.Model'></span>

<h3>Description</h3>

<p>Extracts the <a href="stats.html#topic+formula">formula</a> from a 'Model' object. This information can also be
accessed directly from the Model as 'Model$formula'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Model'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.Model_+3A_x">x</code></td>
<td>
<p>A 'Model' object.</p>
</td></tr>
<tr><td><code id="formula.Model_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="stats.html#topic+formula">formula</a> object.
</p>

<hr>
<h2 id='logLik.mcml'>Extracts the log-likelihood from an mcml object</h2><span id='topic+logLik.mcml'></span>

<h3>Description</h3>

<p>Extracts the final log-likelihood value from an mcml object returned from call of 'MCML' or 'LA' in the <a href="#topic+Model">Model</a> class. The fitting algorithm estimates
the fixed effects, random effects, and covariance parameters all separately. The log-likelihood is separable in the fixed and covariance parameters, so one can return 
the log-likelihood for either component, or the overall log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
logLik(object, fixed = TRUE, covariance = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.mcml_+3A_object">object</code></td>
<td>
<p>An 'mcml' model fit.</p>
</td></tr>
<tr><td><code id="logLik.mcml_+3A_fixed">fixed</code></td>
<td>
<p>Logical whether to include the log-likelihood value from the fixed effects.</p>
</td></tr>
<tr><td><code id="logLik.mcml_+3A_covariance">covariance</code></td>
<td>
<p>Logical whether to include the log-likelihood value from the covariance parameters.</p>
</td></tr>
<tr><td><code id="logLik.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'logLik'. If both 'fixed' and 'covariance' are FALSE then it returns NA.
</p>

<hr>
<h2 id='logLik.Model'>Extracts the log-likelihood from an mcml object</h2><span id='topic+logLik.Model'></span>

<h3>Description</h3>

<p>Extracts the log-likelihood value from an 'Model' object. If no data 'y' are specified then it returns NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Model'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.Model_+3A_object">object</code></td>
<td>
<p>An 'Model' object.</p>
</td></tr>
<tr><td><code id="logLik.Model_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'logLik'. If both 'fixed' and 'covariance' are FALSE then it returns NA.
</p>

<hr>
<h2 id='match_rows'>Generate matrix mapping between data frames</h2><span id='topic+match_rows'></span>

<h3>Description</h3>

<p>For a data frames 'x' and 'target', the function will return a matrix mapping the rows of
'x' to those of 'target'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_rows(x, target, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_rows_+3A_x">x</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="match_rows_+3A_target">target</code></td>
<td>
<p>data.frame to map to</p>
</td></tr>
<tr><td><code id="match_rows_+3A_by">by</code></td>
<td>
<p>vector of strings naming columns in 'x' and 'target'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'x' is a data frame with n rows and 'target' a data frame with m rows. This function will
return a n times m matrix that maps the rows of 'x' to those of 'target' based on the values
in the columns specified by the argument 'by'
</p>


<h3>Value</h3>

<p>A matrix with nrow(x) rows and nrow(target) columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
df_unique &lt;- df[!duplicated(df[,c('cl','t')]),]
match_rows(df,df_unique,c('cl','t'))
</code></pre>

<hr>
<h2 id='mcnr_family'>Returns the file name and type for MCNR function</h2><span id='topic+mcnr_family'></span>

<h3>Description</h3>

<p>Returns the file name and type for MCNR function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcnr_family(family, cmdstan)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcnr_family_+3A_family">family</code></td>
<td>
<p>family object</p>
</td></tr>
<tr><td><code id="mcnr_family_+3A_cmdstan">cmdstan</code></td>
<td>
<p>Logical indicating whether cmdstan is being used and the function will return the filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with filename and type
</p>

<hr>
<h2 id='MeanFunction'>R6 Class representing a mean function/linear predictor</h2><span id='topic+MeanFunction'></span>

<h3>Description</h3>

<p>R6 Class representing a mean function/linear predictor
</p>
<p>R6 Class representing a mean function/linear predictor
</p>


<h3>Details</h3>

<p>For the generalised linear mixed model 
</p>
<p style="text-align: center;"><code class="reqn">Y \sim F(\mu,\sigma)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu = h^-1(X\beta + Z\gamma)</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma \sim MVN(0,D)</code>
</p>

<p>this class defines the fixed effects design matrix X. 
The mean function is defined by a model formula, data, and parameters.
A new instance can be generated with $new(). The class will generate the 
relevant matrix X automatically. See <a href="https://github.com/samuel-watson/glmmrBase/blob/master/README.md">glmmrBase</a> for a 
detailed guide on model specification.
</p>
<p>Specification of the mean function follows standard model formulae in R. 
For example for a stepped-wedge cluster trial model, a typical mean model is 
<code class="reqn">E(y_{ijt}|\delta)=\beta_0 + \tau_t + \beta_1 d_{jt} + z_{ijt}\delta</code> where <code class="reqn">\tau_t</code> 
are fixed effects for each time period. The formula specification for this would be '~ factor(t) + int' 
where 'int' is the name of the variable indicating the treatment.
</p>
<p>One can also include non-linear functions of variables in the mean function, and name the parameters. 
The resulting X matrix is then a matrix of first-order partial derivatives. For example, one can
specify '~ int + b_1*exp(b_2*x)'.
</p>
<p>Using 'update_parameters()' is the preferred way of updating the parameters of the 
mean or covariance objects as opposed to direct assignment, e.g. 'self$parameters &lt;- c(...)'. 
The function calls check functions to automatically update linked matrices with the new parameters.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>formula</code></dt><dd><p>model formula for the fixed effects</p>
</dd>
<dt><code>data</code></dt><dd><p>Data frame with data required to build X</p>
</dd>
<dt><code>parameters</code></dt><dd><p>A vector of parameter values for <code class="reqn">\beta</code> used for simulating data and calculating
covariance matrix of observations for non-linear models.</p>
</dd>
<dt><code>offset</code></dt><dd><p>An optional vector specifying the offset values</p>
</dd>
<dt><code>X</code></dt><dd><p>the fixed effects design matrix</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MeanFunction-n"><code>MeanFunction$n()</code></a>
</p>
</li>
<li> <p><a href="#method-MeanFunction-new"><code>MeanFunction$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MeanFunction-print"><code>MeanFunction$print()</code></a>
</p>
</li>
<li> <p><a href="#method-MeanFunction-update_parameters"><code>MeanFunction$update_parameters()</code></a>
</p>
</li>
<li> <p><a href="#method-MeanFunction-colnames"><code>MeanFunction$colnames()</code></a>
</p>
</li>
<li> <p><a href="#method-MeanFunction-subset_rows"><code>MeanFunction$subset_rows()</code></a>
</p>
</li>
<li> <p><a href="#method-MeanFunction-linear_predictor"><code>MeanFunction$linear_predictor()</code></a>
</p>
</li>
<li> <p><a href="#method-MeanFunction-any_nonlinear"><code>MeanFunction$any_nonlinear()</code></a>
</p>
</li>
<li> <p><a href="#method-MeanFunction-clone"><code>MeanFunction$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MeanFunction-n"></a>



<h4>Method <code>n()</code></h4>

<p>Returns the number of observations
</p>


<h5>Usage</h5>

<div class="r"><pre>MeanFunction$n()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The number of observations in the model
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
df &lt;- nelder(~(cl(4)*t(5)) &gt; ind(5))
df$int &lt;- 0
df[df$cl &lt;= 2, 'int'] &lt;- 1
mf1 &lt;- MeanFunction$new(formula = ~ int ,
                        data=df,
                        parameters = c(-1,1)
                        )
mf1$n()
</pre>
</div>


<hr>
<a id="method-MeanFunction-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new MeanFunction object
</p>


<h5>Usage</h5>

<div class="r"><pre>MeanFunction$new(
  formula,
  data,
  parameters = NULL,
  offset = NULL,
  verbose = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>formula</code></dt><dd><p>A <a href="stats.html#topic+formula">formula</a> object that describes the mean function, see Details</p>
</dd>
<dt><code>data</code></dt><dd><p>(Optional) A data frame containing the covariates in the model, named in the model formula</p>
</dd>
<dt><code>parameters</code></dt><dd><p>(Optional) A vector with the values of the parameters <code class="reqn">\beta</code> to use in data simulation and covariance calculations.
If the parameters are not specified then they are initialised to 0.</p>
</dd>
<dt><code>offset</code></dt><dd><p>A vector of offset values (optional)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Logical indicating whether to report detailed output</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A MeanFunction object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
df &lt;- nelder(~(cl(4)*t(5)) &gt; ind(5))
df$int &lt;- 0
df[df$cl &lt;= 2, 'int'] &lt;- 1
mf1 &lt;- MeanFunction$new(formula = ~ int ,
                        data=df,
                        parameters = c(-1,1),
                        )
</pre>
</div>


<hr>
<a id="method-MeanFunction-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints details about the object
</p>


<h5>Usage</h5>

<div class="r"><pre>MeanFunction$print()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MeanFunction-update_parameters"></a>



<h4>Method <code>update_parameters()</code></h4>

<p>Updates the model parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>MeanFunction$update_parameters(parameters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameters</code></dt><dd><p>A vector of parameters for the mean function.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Logical indicating whether to provide more detailed feedback</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MeanFunction-colnames"></a>



<h4>Method <code>colnames()</code></h4>

<p>Returns or replaces the column names of the data in the object
</p>


<h5>Usage</h5>

<div class="r"><pre>MeanFunction$colnames(names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>names</code></dt><dd><p>If NULL then the function prints the column names, if a vector of names, then it attempts to 
replace the current column names of the data</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
df &lt;- nelder(~(cl(4)*t(5)) &gt; ind(5))
df$int &lt;- 0
df[df$cl &lt;= 5, 'int'] &lt;- 1
mf1 &lt;- MeanFunction$new(formula = ~ int ,
                        data=df,
                        parameters = c(-1,1)
                        )
mf1$colnames(c("cluster","time","individual","treatment"))
mf1$colnames()
</pre>
</div>


<hr>
<a id="method-MeanFunction-subset_rows"></a>



<h4>Method <code>subset_rows()</code></h4>

<p>Keeps a subset of the data and removes the rest
</p>
<p>All indices not in the provided vector of row numbers will be removed from both the data and fixed effects 
design matrix X.
</p>


<h5>Usage</h5>

<div class="r"><pre>MeanFunction$subset_rows(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>Rows of the data to keep</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
df &lt;- nelder(~(cl(4)*t(5)) &gt; ind(5))
df$int &lt;- 0
df[df$cl &lt;= 5, 'int'] &lt;- 1
mf1 &lt;- MeanFunction$new(formula = ~ int ,
                        data=df,
                        parameters = c(-1,1)
                        )
mf1$subset_rows(1:20) 
</pre>
</div>


<hr>
<a id="method-MeanFunction-linear_predictor"></a>



<h4>Method <code>linear_predictor()</code></h4>

<p>Returns the linear predictor 
</p>
<p>Returns the linear predictor, X * beta
</p>


<h5>Usage</h5>

<div class="r"><pre>MeanFunction$linear_predictor()</pre></div>



<h5>Returns</h5>

<p>A vector
</p>


<hr>
<a id="method-MeanFunction-any_nonlinear"></a>



<h4>Method <code>any_nonlinear()</code></h4>

<p>Returns a logical indicating whether the mean function contains non-linear functions of model parameters.
Mainly used internally.
</p>


<h5>Usage</h5>

<div class="r"><pre>MeanFunction$any_nonlinear()</pre></div>



<h5>Returns</h5>

<p>None. Called for effects
</p>


<hr>
<a id="method-MeanFunction-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MeanFunction$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `MeanFunction$n`
## ------------------------------------------------


df &lt;- nelder(~(cl(4)*t(5)) &gt; ind(5))
df$int &lt;- 0
df[df$cl &lt;= 2, 'int'] &lt;- 1
mf1 &lt;- MeanFunction$new(formula = ~ int ,
                        data=df,
                        parameters = c(-1,1)
                        )
mf1$n()

## ------------------------------------------------
## Method `MeanFunction$new`
## ------------------------------------------------


df &lt;- nelder(~(cl(4)*t(5)) &gt; ind(5))
df$int &lt;- 0
df[df$cl &lt;= 2, 'int'] &lt;- 1
mf1 &lt;- MeanFunction$new(formula = ~ int ,
                        data=df,
                        parameters = c(-1,1),
                        )

## ------------------------------------------------
## Method `MeanFunction$colnames`
## ------------------------------------------------


df &lt;- nelder(~(cl(4)*t(5)) &gt; ind(5))
df$int &lt;- 0
df[df$cl &lt;= 5, 'int'] &lt;- 1
mf1 &lt;- MeanFunction$new(formula = ~ int ,
                        data=df,
                        parameters = c(-1,1)
                        )
mf1$colnames(c("cluster","time","individual","treatment"))
mf1$colnames()

## ------------------------------------------------
## Method `MeanFunction$subset_rows`
## ------------------------------------------------


df &lt;- nelder(~(cl(4)*t(5)) &gt; ind(5))
df$int &lt;- 0
df[df$cl &lt;= 5, 'int'] &lt;- 1
mf1 &lt;- MeanFunction$new(formula = ~ int ,
                        data=df,
                        parameters = c(-1,1)
                        )
mf1$subset_rows(1:20) 
</code></pre>

<hr>
<h2 id='Model'>A GLMM Model</h2><span id='topic+Model'></span>

<h3>Description</h3>

<p>A GLMM Model
</p>
<p>A GLMM Model
</p>


<h3>Details</h3>

<p>A generalised linear mixed model and a range of associated functions
</p>
<p>A detailed vingette for this package is available online<a href="doi:10.48550/arXiv.2303.12657">doi:10.48550/arXiv.2303.12657</a>. Briefly, for the generalised linear mixed model
</p>
<p style="text-align: center;"><code class="reqn">Y \sim F(\mu,\sigma)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu = h^-1(X\beta + Zu)</code>
</p>

<p style="text-align: center;"><code class="reqn">u \sim MVN(0,D)</code>
</p>

<p>where h is the link function. The class provides access to all of the matrices above and associated calculations and functions including model fitting, power analysis,
and various relevant decompositions. The object is an R6 class and so can serve as a parent class for extended functionality.
</p>
<p>Many calculations use the covariance matrix of the observations, such as the information matrix, which is used in power calculations and
other functions. For non-Gaussian models, the class uses the first-order approximation proposed by Breslow and Clayton (1993) based on the
marginal quasilikelihood:
</p>
<p style="text-align: center;"><code class="reqn">\Sigma = W^{-1} + ZDZ^T</code>
</p>

<p>where <em>W</em> is a diagonal matrix with the GLM iterated weights for each observation equal
to, for individual <em>i</em> <code class="reqn">\left( \frac{(\partial h^{-1}(\eta_i))}{\partial \eta_i}\right) ^2 Var(y|u)</code>
(see Table 2.1 in McCullagh and Nelder (1989)). The modification proposed by Zegers et al to the linear predictor to
improve the accuracy of approximations based on the marginal quasilikelihood is also available, see <code>use_attenuation()</code>.
</p>
<p>See <a href="https://github.com/samuel-watson/glmmrBase/blob/master/README.md">glmmrBase</a> for a
detailed guide on model specification.
</p>
<p>The class also includes model fitting with Markov Chain Monte Carlo Maximum Likelihood implementing the algorithms described by McCulloch (1997),
and fast model fitting using Laplace approximation. Functions for returning related values such as the log gradient, log probability, and other
matrices are also available.
</p>
<p><strong>Attenuation</strong>
For calculations such as the information matrix, the first-order approximation to the covariance matrix
proposed by Breslow and Clayton (1993), described above, is used. The approximation is based on the
marginal quasilikelihood. Zegers, Liang, and Albert (1988) suggest that a better approximation to the
marginal mean is achieved by &quot;attenuating&quot; the linear predictor. Setting <code>use</code> equal to TRUE uses this
adjustment for calculations using the covariance matrix for non-linear models.
</p>
<p>Calls the respective print methods of the linked covariance and mean function objects.
</p>
<p>The matrices X and Z both have n rows, where n is the number of observations in the model/design.
</p>
<p>Using <code>update_parameters()</code> is the preferred way of updating the parameters of the
mean or covariance objects as opposed to direct assignment, e.g. <code>self$covariance$parameters &lt;- c(...)</code>.
The function calls check functions to automatically update linked matrices with the new parameters.
</p>
<p><strong>Stochastic maximum likelihood</strong>
Fits generalised linear mixed models using one of several algorithms: Markov Chain Newton
Raphson (MCNR), Markov Chain Expectation Maximisation (MCEM), or stochastic approximation expectation
maximisation (SAEM) with or without Polyak-Ruppert averaging. MCNR and MCEM are described by McCulloch (1997)
<a href="doi:10.1080/01621459.1997.10473613">doi:10.1080/01621459.1997.10473613</a>. For each iteration
of the algorithms the unobserved random effect terms (<code class="reqn">\gamma</code>) are simulated
using Markov Chain Monte Carlo (MCMC) methods,
and then these values are conditioned on in the subsequent steps to estimate the covariance
parameters and the mean function parameters (<code class="reqn">\beta</code>). SAEM uses a Robbins-Munroe approach to approximating
the likelihood and requires fewer MCMC samples and may have lower Monte Carlo error, see Jank (2006)<a href="doi:10.1198/106186006X157469">doi:10.1198/106186006X157469</a>.
The option <code>alpha</code> determines the rate at which succesive iterations &quot;forget&quot; the past and must be between 0.5 and 1. Higher values
will result in lower Monte Carlo error but slower convergence. The options <code>mcem.adapt</code> and <code>mcnr.adapt</code> will modify the number of MCMC samples during each step of model fitting
using the suggested values in Caffo, Jank, and Jones (2006)<a href="doi:10.1111/j.1467-9868.2005.00499.x">doi:10.1111/j.1467-9868.2005.00499.x</a>
as the estimates converge.
</p>
<p>The accuracy of the algorithm depends on the user specified tolerance. For higher levels of
tolerance, larger numbers of MCMC samples are likely need to sufficiently reduce Monte Carlo error. However,
the SAEM approach does overcome reduce the required samples, especially with R-P averaging. As such a lower number (20-50)
samples per iteration is normally sufficient to get convergence.
</p>
<p>There are several stopping rules for the algorithm. Either the algorithm will terminate when succesive parameter estimates are
all within a specified tolerance of each other (<code>conv.criterion = 1</code>), or when there is a high probability that the estimated
log-likelihood has not been improved. This latter criterion can be applied to either the overall log-likelihood (<code>conv.criterion = 2</code>),
the likelihood just for the fixed effects (<code>conv.criterion = 3</code>), or both the likelihoods for the fixed effects and covariance parameters
(<code>conv.criterion = 4</code>; default).
</p>
<p>Options for the MCMC sampler are set by changing the values in <code>self$mcmc_options</code>. The information printed to the console
during model fitting can be controlled with the <code>self$set_trace()</code> function.
</p>
<p>To provide weights for the model fitting, store them in self$weights. To set the number of
trials for binomial models, set self$trials.
</p>
<p><strong>Laplace approximation</strong>
Fits generalised linear mixed models using Laplace approximation to the log likelihood. For non-Gaussian models
the covariance matrix is approximated using the first order approximation based on the marginal
quasilikelihood proposed by Breslow and Clayton (1993). The marginal mean in this approximation
can be further adjusted following the proposal of Zeger et al (1988), use the member function <code>use_attenuated()</code> in this
class, see <a href="#topic+Model">Model</a>. To provide weights for the model fitting, store them in self$weights. To
set the number of trials for binomial models, set self$trials. To control the information printed to the console
during model fitting use the <code>self$set_trace()</code> function.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>covariance</code></dt><dd><p>A <a href="#topic+Covariance">Covariance</a> object defining the random effects covariance.</p>
</dd>
<dt><code>mean</code></dt><dd><p>A <a href="#topic+MeanFunction">MeanFunction</a> object, defining the mean function for the model, including the data and covariate design matrix X.</p>
</dd>
<dt><code>family</code></dt><dd><p>One of the family function used in R's glm functions. See <a href="stats.html#topic+family">family</a> for details</p>
</dd>
<dt><code>weights</code></dt><dd><p>A vector indicting the weights for the observations.</p>
</dd>
<dt><code>trials</code></dt><dd><p>For binomial family models, the number of trials for each observation. The default is 1 (bernoulli).</p>
</dd>
<dt><code>formula</code></dt><dd><p>The formula for the model. May be empty if separate formulae are specified for the mean and covariance components.</p>
</dd>
<dt><code>var_par</code></dt><dd><p>Scale parameter required for some distributions (Gaussian, Gamma, Beta).</p>
</dd>
<dt><code>mcmc_options</code></dt><dd><p>There are five options for MCMC sampling that are specified in this list:
</p>

<ul>
<li> <p><code>warmup</code> The number of warmup iterations. Note that if using the internal HMC
sampler, this only applies to the first iteration of the MCML algorithm, as the
values from the previous iteration are carried over.
</p>
</li>
<li> <p><code>samps</code> The number of MCMC samples drawn in the MCML algorithms. For
smaller tolerance values larger numbers of samples are required. For the internal
HMC sampler, larger numbers of samples are generally required than if using Stan since
the samples generally exhibit higher autocorrealtion, especially for more complex
covariance structures. For SAEM a small number is recommended as all samples are stored and used
from every iteration.
</p>
</li>
<li> <p><code>lambda</code> (Only relevant for the internal HMC sampler) Value of the trajectory length of the leapfrog integrator in Hamiltonian Monte Carlo
(equal to number of steps times the step length). Larger values result in lower correlation in samples, but
require larger numbers of steps and so is slower. Smaller numbers are likely required for non-linear GLMMs.
</p>
</li>
<li> <p><code>refresh</code> How frequently to print to console MCMC progress if displaying verbose output.
</p>
</li>
<li> <p><code>maxsteps</code> (Only relevant for the internal HMC sampler) Integer. The maximum number of steps of the leapfrom integrator
</p>
</li></ul>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Model-use_attenuation"><code>Model$use_attenuation()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-fitted"><code>Model$fitted()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-residuals"><code>Model$residuals()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-predict"><code>Model$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-new"><code>Model$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-print"><code>Model$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-n"><code>Model$n()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-subset_rows"><code>Model$subset_rows()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-sim_data"><code>Model$sim_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-update_parameters"><code>Model$update_parameters()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-information_matrix"><code>Model$information_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-sandwich"><code>Model$sandwich()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-small_sample_correction"><code>Model$small_sample_correction()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-box"><code>Model$box()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-power"><code>Model$power()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-w_matrix"><code>Model$w_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-dh_deta"><code>Model$dh_deta()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-Sigma"><code>Model$Sigma()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-MCML"><code>Model$MCML()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-LA"><code>Model$LA()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-sparse"><code>Model$sparse()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-mcmc_sample"><code>Model$mcmc_sample()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-gradient"><code>Model$gradient()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-partial_sigma"><code>Model$partial_sigma()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-u"><code>Model$u()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-log_likelihood"><code>Model$log_likelihood()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-calculator_instructions"><code>Model$calculator_instructions()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-marginal"><code>Model$marginal()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-update_y"><code>Model$update_y()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-set_trace"><code>Model$set_trace()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-clone"><code>Model$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Model-use_attenuation"></a>



<h4>Method <code>use_attenuation()</code></h4>

<p>Sets the model to use or not use &quot;attenuation&quot; when calculating the first-order approximation to
the covariance matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$use_attenuation(use)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use</code></dt><dd><p>Logical indicating whether to use &quot;attenuation&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None. Used for effects.
</p>


<hr>
<a id="method-Model-fitted"></a>



<h4>Method <code>fitted()</code></h4>

<p>Return fitted values. Does not account for the random effects. For simulated values based
on resampling random effects, see also <code>sim_data()</code>. To predict the values including random effects at a new location see also
<code>predict()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$fitted(type = "link", X, u, sample = FALSE, sample_n = 100)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>One of either &quot;<code>link</code>&quot; for values on the scale of the link function, or &quot;<code>response</code>&quot;
for values on the scale of the response</p>
</dd>
<dt><code>X</code></dt><dd><p>(Optional) Fixed effects matrix to generate fitted values</p>
</dd>
<dt><code>u</code></dt><dd><p>(Optional) Random effects values at which to generate fitted values</p>
</dd>
<dt><code>sample</code></dt><dd><p>Logical. If TRUE then the parameters will be re-sampled from their sampling distribution. Currently only works
with existing X matrix and not user supplied matrix X and this will also ignore any provided random effects.</p>
</dd>
<dt><code>sample_n</code></dt><dd><p>Integer. If sample is TRUE, then this is the number of samples.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Fitted values as either a vector or matrix depending on the number of samples
</p>


<hr>
<a id="method-Model-residuals"></a>



<h4>Method <code>residuals()</code></h4>

<p>Generates the residuals for the model
</p>
<p>Generates one of several types of residual for the model. If conditional = TRUE then
the residuals include the random effects, otherwise only the fixed effects are included. For type,
there are raw, pearson, and standardized residuals. For conditional residuals a matrix is returned
with each column corresponding to a sample of the random effects.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$residuals(type = "standardized", conditional = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>Either &quot;standardized&quot;, &quot;raw&quot; or &quot;pearson&quot;</p>
</dd>
<dt><code>conditional</code></dt><dd><p>Logical indicating whether to condition on the random effects (TRUE) or not (FALSE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix with either one column is conditional is false, or with number of columns corresponding
to the number of MCMC samples.
</p>


<hr>
<a id="method-Model-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Generate predictions at new values
</p>
<p>Generates predicted values using a new data set to specify covariance
values and values for the variables that define the covariance function.
The function will return a list with the linear predictor, conditional
distribution of the new random effects term conditional on the current estimates
of the random effects, and some simulated values of the random effects if requested.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$predict(newdata, offset = rep(0, nrow(newdata)), m = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newdata</code></dt><dd><p>A data frame specifying the new data at which to generate predictions</p>
</dd>
<dt><code>offset</code></dt><dd><p>Optional vector of offset values for the new data</p>
</dd>
<dt><code>m</code></dt><dd><p>Number of samples of the random effects to draw</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the linear predictor, parameters (mean and covariance matrices) for
the conditional distribution of the random effects, and any random effect samples.
</p>


<hr>
<a id="method-Model-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Model object. Typically, a model is generated from a formula and data. However, it can also be
generated from a previous model fit.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$new(
  formula,
  covariance,
  mean,
  data = NULL,
  family = NULL,
  var_par = NULL,
  offset = NULL,
  weights = NULL,
  trials = NULL,
  model_fit = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>formula</code></dt><dd><p>An optional model formula containing fixed and random effect terms. If not specified, then
separate formulae need to be provided to the covariance and mean arguments below.</p>
</dd>
<dt><code>covariance</code></dt><dd><p>(Optional) Either a <a href="#topic+Covariance">Covariance</a> object, an equivalent list of arguments
that can be passed to <code>Covariance</code> to create a new object, or a vector of parameter values. At a minimum the list must specify a formula.
If parameters are not included then they are initialised to 0.5.</p>
</dd>
<dt><code>mean</code></dt><dd><p>(Optional) Either a <a href="#topic+MeanFunction">MeanFunction</a> object, an equivalent list of arguments
that can be passed to <code>MeanFunction</code> to create a new object, or a vector of parameter values. At a minimum the list must specify a formula.
If parameters are not included then they are initialised to 0.</p>
</dd>
<dt><code>data</code></dt><dd><p>A data frame with the data required for the mean function and covariance objects. This argument
can be ignored if data are provided to the covariance or mean arguments either via <code>Covariance</code> and <code>MeanFunction</code>
object, or as a member of the list of arguments to both <code>covariance</code> and <code>mean</code>.</p>
</dd>
<dt><code>family</code></dt><dd><p>A family object expressing the distribution and link function of the model, see <a href="stats.html#topic+family">family</a>. This
argument is optional if the family is provided either via a <code>MeanFunction</code> or <code>MeanFunction</code>
objects, or as members of the list of arguments to <code>mean</code>. Current accepts <a href="stats.html#topic+binomial">binomial</a>,
<a href="stats.html#topic+gaussian">gaussian</a>, <a href="stats.html#topic+Gamma">Gamma</a>, <a href="stats.html#topic+poisson">poisson</a>, and <a href="#topic+Beta">Beta</a>.</p>
</dd>
<dt><code>var_par</code></dt><dd><p>(Optional) Scale parameter required for some distributions, including Gaussian. Default is NULL.</p>
</dd>
<dt><code>offset</code></dt><dd><p>(Optional) A vector of offset values. Optional - could be provided to the argument to mean instead.</p>
</dd>
<dt><code>weights</code></dt><dd><p>(Optional) A vector of weights.</p>
</dd>
<dt><code>trials</code></dt><dd><p>(Optional) For binomial family models, the number of trials for each observation. If it is not set, then it will
default to 1 (a bernoulli model).</p>
</dd>
<dt><code>model_fit</code></dt><dd><p>(optional) A <code>mcml</code> model fit resulting from a call to <code>MCML</code> or <code>LA</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new Model class object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
#create a data frame describing a cross-sectional parallel cluster
#randomised trial
df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
df$int &lt;- 0
df[df$cl &gt; 5, 'int'] &lt;- 1
mod &lt;- Model$new(
  formula = ~ factor(t) + int - 1 + (1|gr(cl)) + (1|gr(cl,t)),
  data = df,
  family = stats::gaussian()
)

#here we will specify a cohort study and provide parameter values
df &lt;- nelder(~ind(20) * t(6))
df$int &lt;- 0
df[df$t &gt; 3, 'int'] &lt;- 1
# the preferred way of specifying with parameter values
des &lt;- Model$new(
  formula = ~ int + (1|gr(ind)),
  covariance = c(0.05),
  mean = c(1,0.5),
  data = df,
  family = stats::poisson()
  )
# also works:
des &lt;- Model$new(
  covariance = list(
    formula = ~ (1|gr(ind)),
    parameters = c(0.05)),
  mean = list(
    formula = ~ int,
    parameters = c(1,0.5)),
  data = df,
  family = stats::poisson())

#an example of a spatial grid with two time points
df &lt;- nelder(~ (x(10)*y(10))*t(2))
spt_design &lt;- Model$new(formula = ~ 1 + (1|ar0(t)*fexp(x,y)),
                        data = df,
                        family = stats::gaussian())
</pre>
</div>


<hr>
<a id="method-Model-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method for <code>Model</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$print()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Model-n"></a>



<h4>Method <code>n()</code></h4>

<p>Returns the number of observations in the model
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$n(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Model-subset_rows"></a>



<h4>Method <code>subset_rows()</code></h4>

<p>Subsets the design keeping specified observations only
</p>
<p>Given a vector of row indices, the corresponding rows will be kept and the
other rows will be removed from the mean function and covariance
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$subset_rows(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>Integer or vector integers listing the rows to keep</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The function updates the object and nothing is returned.
</p>


<hr>
<a id="method-Model-sim_data"></a>



<h4>Method <code>sim_data()</code></h4>

<p>Generates a realisation of the design
</p>
<p>Generates a single vector of outcome data based upon the
specified GLMM design.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$sim_data(type = "y")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>Either 'y' to return just the outcome data, 'data'
to return a data frame with the simulated outcome data alongside the model data,
or 'all', which will return a list with simulated outcomes y, matrices X and Z,
parameters beta, and the values of the simulated random effects.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Either a vector, a data frame, or a list
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
df$int &lt;- 0
df[df$cl &gt; 5, 'int'] &lt;- 1
\dontshow{
setParallel(FALSE) # for the CRAN check
}
des &lt;- Model$new(
  covariance = list(
    formula = ~ (1|gr(cl)*ar0(t)),
    parameters = c(0.05,0.8)),
  mean = list(
    formula = ~ factor(t) + int - 1,
    parameters = c(rep(0,5),0.6)),
  data = df,
  family = stats::binomial()
)
ysim &lt;- des$sim_data()
</pre>
</div>


<hr>
<a id="method-Model-update_parameters"></a>



<h4>Method <code>update_parameters()</code></h4>

<p>Updates the parameters of the mean function and/or the covariance function
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$update_parameters(mean.pars = NULL, cov.pars = NULL, var.par = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mean.pars</code></dt><dd><p>(Optional) Vector of new mean function parameters</p>
</dd>
<dt><code>cov.pars</code></dt><dd><p>(Optional) Vector of new covariance function(s) parameters</p>
</dd>
<dt><code>var.par</code></dt><dd><p>(Optional) A scalar value for var_par</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
df$int &lt;- 0
df[df$cl &gt; 5, 'int'] &lt;- 1
des &lt;- Model$new(
  formula = ~ factor(t) + int - 1 + (1|gr(cl)*ar0(t)),
  data = df,
  family = stats::binomial()
)
des$update_parameters(cov.pars = c(0.1,0.9))
</pre>
</div>


<hr>
<a id="method-Model-information_matrix"></a>



<h4>Method <code>information_matrix()</code></h4>

<p>Generates the information matrix of the mixed model GLS estimator (X'S^-1X). The inverse of this matrix is an
estimator for the variance-covariance matrix of the fixed effect parameters. For various small sample corrections
see <code>small_sample_correction()</code> and <code>box()</code>. For models with non-linear functions of fixed effect parameters,
a correction to the Hessian matrix is required, which is automatically calculated or optionally returned or disabled.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$information_matrix(
  include.re = FALSE,
  theta = FALSE,
  hessian.corr = "add",
  adj.nonpsd = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include.re</code></dt><dd><p>logical indicating whether to return the information matrix including the random effects components (TRUE),
or the mixed model information matrix for beta only (FALSE).</p>
</dd>
<dt><code>theta</code></dt><dd><p>Logical. If TRUE the function will return the variance-coviariance matrix for the covariance parameters and ignore the first argument. Otherwise, the fixed effect
parameter information matrix is returned.</p>
</dd>
<dt><code>hessian.corr</code></dt><dd><p>String. If there are non-linear functions of fixed effect parameters then a correction to the Hessian can be applied (&quot;add&quot;), returned on its
own (&quot;return&quot;), or ignored (&quot;none&quot;)</p>
</dd>
<dt><code>adj.nonspd</code></dt><dd><p>Logical. For models nonlinear in fixed effect parameters, the Hessian of the linear predictor with respect to the
model parameters is often not positive semi-definite, which can cause a singular matrix and failure to calculate valid standard errors.
The adjustment matrix will be corrected if it is not positive semi-definite and this option is TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix
</p>


<hr>
<a id="method-Model-sandwich"></a>



<h4>Method <code>sandwich()</code></h4>

<p>Returns the robust sandwich variance-covariance matrix for the fixed effect parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$sandwich()</pre></div>



<h5>Returns</h5>

<p>A PxP matrix
</p>


<hr>
<a id="method-Model-small_sample_correction"></a>



<h4>Method <code>small_sample_correction()</code></h4>

<p>Returns a small sample correction. The option &quot;KR&quot; returns the Kenward-Roger bias-corrected variance-covariance matrix
for the fixed effect parameters and degrees of freedom. Option &quot;KR2&quot;  returns an improved correction given
in Kenward &amp; Roger (2009) <a href="doi:j.csda.2008.12.013">doi:j.csda.2008.12.013</a>. Note, that the corrected/improved version is invariant
under reparameterisation of the covariance, and it will also make no difference if the covariance is linear
in parameters. Exchangeable covariance structures in this package (i.e. <code>gr()</code>) are parameterised in terms of
the variance rather than standard deviation, so the results will be unaffected. Option &quot;sat&quot; returns the &quot;Satterthwaite&quot;
correction, which only includes corrected degrees of freedom, along with the GLS standard errors.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$small_sample_correction(type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>Either &quot;KR&quot;, &quot;KR2&quot;, or &quot;sat&quot;, see description.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A PxP matrix
</p>


<hr>
<a id="method-Model-box"></a>



<h4>Method <code>box()</code></h4>

<p>Returns the inferential statistics (F-stat, p-value) for a modified Box correction <a href="doi:10.1002/sim.4072">doi:10.1002/sim.4072</a> for
Gaussian-identity models.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$box(y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>y</code></dt><dd><p>Optional. If provided, will update the vector of outcome data. Otherwise it will use the data from
the previous model fit.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A data frame.
</p>


<hr>
<a id="method-Model-power"></a>



<h4>Method <code>power()</code></h4>

<p>Estimates the power of the design described by the model using the square root
of the relevant element of the GLS variance matrix:
</p>
<p style="text-align: center;"><code class="reqn">(X^T\Sigma^{-1}X)^{-1}</code>
</p>

<p>Note that this is equivalent to using the &quot;design effect&quot; for many
models.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$power(alpha = 0.05, two.sided = TRUE, alternative = "pos")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>Numeric between zero and one indicating the type I error rate.
Default of 0.05.</p>
</dd>
<dt><code>two.sided</code></dt><dd><p>Logical indicating whether to use a two sided test</p>
</dd>
<dt><code>alternative</code></dt><dd><p>For a one-sided test whether the alternative hypothesis is that the
parameter is positive &quot;pos&quot; or negative &quot;neg&quot;</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A data frame describing the parameters, their values, expected standard
errors and estimated power.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
df$int &lt;- 0
df[df$cl &gt; 5, 'int'] &lt;- 1
des &lt;- Model$new(
  formula = ~ factor(t) + int - 1 + (1|gr(cl)) + (1|gr(cl,t)),
  covariance = c(0.05,0.1),
  mean = c(rep(0,5),0.6),
  data = df,
  family = stats::gaussian(),
  var_par = 1
)
des$power() #power of 0.90 for the int parameter
</pre>
</div>


<hr>
<a id="method-Model-w_matrix"></a>



<h4>Method <code>w_matrix()</code></h4>

<p>Returns the diagonal of the matrix W used to calculate the covariance matrix approximation
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$w_matrix()</pre></div>



<h5>Returns</h5>

<p>A vector with values of the glm iterated weights
</p>


<hr>
<a id="method-Model-dh_deta"></a>



<h4>Method <code>dh_deta()</code></h4>

<p>Returns the derivative of the link function with respect to the linear preditor
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$dh_deta()</pre></div>



<h5>Returns</h5>

<p>A vector
</p>


<hr>
<a id="method-Model-Sigma"></a>



<h4>Method <code>Sigma()</code></h4>

<p>Returns the (approximate) covariance matrix of y
</p>
<p>Returns the covariance matrix Sigma. For non-linear models this is an approximation. See Details.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$Sigma(inverse = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inverse</code></dt><dd><p>Logical indicating whether to provide the covariance matrix or its inverse</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix.
</p>


<hr>
<a id="method-Model-MCML"></a>



<h4>Method <code>MCML()</code></h4>

<p>Stochastic Maximum Likelihood model fitting
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$MCML(
  y,
  method = "saem",
  tol = 0.01,
  max.iter = 50,
  se = "gls",
  mcmc.pkg = "rstan",
  se.theta = TRUE,
  algo = ifelse(self$mean$any_nonlinear(), 2, 3),
  lower.bound = NULL,
  upper.bound = NULL,
  lower.bound.theta = NULL,
  upper.bound.theta = NULL,
  alpha = 0.8,
  convergence.prob = 0.95,
  pr.average = FALSE,
  conv.criterion = 2
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>y</code></dt><dd><p>A numeric vector of outcome data</p>
</dd>
<dt><code>method</code></dt><dd><p>The MCML algorithm to use, either <code>mcem</code> or <code>mcnr</code>, or <code>saem</code> see Details. Default is <code>saem</code>. <code>mcem.adapt</code> and <code>mcnr.adapt</code> will use adaptive
MCMC sample sizes starting small and increasing to the the maximum value specified in <code>mcmc_options$sampling</code>, which results in faster convergence. <code>saem</code> uses a
stochastic approximation expectation maximisation algorithm. MCMC samples are kept from all iterations and so a smaller number of samples are needed per iteration.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Numeric value, tolerance of the MCML algorithm, the maximum difference in parameter estimates
between iterations at which to stop the algorithm. If two values are provided then different tolerances will be
applied to the fixed effect and covariance parameters.</p>
</dd>
<dt><code>max.iter</code></dt><dd><p>Integer. The maximum number of iterations of the MCML algorithm.</p>
</dd>
<dt><code>se</code></dt><dd><p>String. Type of standard error and/or inferential statistics to return. Options are &quot;gls&quot; for GLS standard errors (the default),
&quot;robust&quot; for robust standard errors, &quot;kr&quot; for original Kenward-Roger bias corrected standard errors,
&quot;kr2&quot; for the improved Kenward-Roger correction, &quot;sat&quot; for Satterthwaite degrees of freedom correction (this is the same
degrees of freedom correction as Kenward-Roger, but with GLS standard errors), &quot;box&quot; to use a modified Box correction (does not return confidence intervals),
&quot;bw&quot; to use GLS standard errors with a between-within correction to the degrees of freedom, &quot;bwrobust&quot; to use robust
standard errors with between-within correction to the degrees of freedom.</p>
</dd>
<dt><code>mcmc.pkg</code></dt><dd><p>String. Either <code>cmdstan</code> for cmdstan (requires the package <code>cmdstanr</code>), <code>rstan</code> to use rstan sampler, or
<code>hmc</code> to use a cruder Hamiltonian Monte Carlo sampler. cmdstan is recommended as it has by far the best number
of effective samples per unit time. cmdstanr will compile the MCMC programs to the library folder the first time they are run,
so may not currently be an option for some users.</p>
</dd>
<dt><code>se.theta</code></dt><dd><p>Logical. Whether to calculate the standard errors for the covariance parameters. This step is a slow part
of the calculation, so can be disabled if required in larger models. Has no effect for Kenward-Roger standard errors.</p>
</dd>
<dt><code>algo</code></dt><dd><p>Integer. 1 = L-BFGS for beta and BOBYQA for theta, 2 = BOBYQA for both, 3 = L-BFGS for both (default). The L-BFGS algorithm
may perform poorly with some covariance structures, in this case select 1 or 2, or apply an upper bound.</p>
</dd>
<dt><code>lower.bound</code></dt><dd><p>Optional. Vector of lower bounds for the fixed effect parameters. To apply bounds use MCEM.</p>
</dd>
<dt><code>upper.bound</code></dt><dd><p>Optional. Vector of upper bounds for the fixed effect parameters. To apply bounds use MCEM.</p>
</dd>
<dt><code>lower.bound.theta</code></dt><dd><p>Optional. Vector of lower bounds for the covariance parameters (default is 0; negative values will cause an error)</p>
</dd>
<dt><code>upper.bound.theta</code></dt><dd><p>Optional. Vector of upper bounds for the covariance parameters.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>If using SAEM then this parameter controls the step size. On each iteration i the step size is (1/alpha)^i, default is 0.8. Values around 0.5
will result in lower bias but slower convergence, values closer to 1 will result in higher convergence but potentially higher error.</p>
</dd>
<dt><code>convergence.prob</code></dt><dd><p>Numeric value in (0,1) indicating the probability of convergence if using convergence criteria 2, 3, or 4.</p>
</dd>
<dt><code>pr.average</code></dt><dd><p>Logical indicating whether to use Polyak-Ruppert averaging if using the SAEM algorithm (default is TRUE)</p>
</dd>
<dt><code>conv.criterion</code></dt><dd><p>Integer. The convergence criterion for the algorithm. 1 = the maximum difference between parameter estimates between iterations as defined by <code>tol</code>,
2 = The probability of improvement in the overall log-likelihood is less than 1 - <code>convergence.prob</code>
3 = The probability of improvement in the log-likelihood for the fixed effects is less than 1 - <code>convergence.prob</code>
4 = The probabilities of improvement in the log-likelihood the fixed effects and covariance parameters are both less than 1 - <code>convergence.prob</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>mcml</code> object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
#create example data with six clusters, five time periods, and five people per cluster-period
df &lt;- nelder(~(cl(6)*t(5)) &gt; ind(5))
# parallel trial design intervention indicator
df$int &lt;- 0
df[df$cl &gt; 3, 'int'] &lt;- 1 
# specify parameter values in the call for the data simulation below
des &lt;- Model$new(
  formula= ~ factor(t) + int - 1 +(1|gr(cl)*ar0(t)),
  covariance = c(0.05,0.7),
  mean = c(rep(0,5),0.2),
  data = df,
  family = gaussian()
)
ysim &lt;- des$sim_data() # simulate some data from the model
fit1 &lt;- des$MCML(y = ysim) # Default model fitting with SAEM-PR
# use MCEM instead and stop when parameter values are within 1e-2 on successive iterations
fit2 &lt;- des$MCML(y = ysim, method="mcem",tol=1e-2,conv.criterion = 1)
}
</pre>
</div>


<hr>
<a id="method-Model-LA"></a>



<h4>Method <code>LA()</code></h4>

<p>Maximum Likelihood model fitting with Laplace Approximation
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$LA(
  y,
  start,
  method = "nr",
  se = "gls",
  max.iter = 40,
  tol = 1e-04,
  se.theta = TRUE,
  algo = 2,
  lower.bound = NULL,
  upper.bound = NULL,
  lower.bound.theta = NULL,
  upper.bound.theta = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>y</code></dt><dd><p>A numeric vector of outcome data</p>
</dd>
<dt><code>start</code></dt><dd><p>Optional. A numeric vector indicating starting values for the model parameters.</p>
</dd>
<dt><code>method</code></dt><dd><p>String. Either &quot;nloptim&quot; for non-linear optimisation, or &quot;nr&quot; for Newton-Raphson (default) algorithm</p>
</dd>
<dt><code>se</code></dt><dd><p>String. Type of standard error and/or inferential statistics to return. Options are &quot;gls&quot; for GLS standard errors (the default),
&quot;robust&quot; for robust standard errors, &quot;kr&quot; for original Kenward-Roger bias corrected standard errors,
&quot;kr2&quot; for the improved Kenward-Roger correction, &quot;sat&quot; for Satterthwaite degrees of freedom correction (this is the same
degrees of freedom correction as Kenward-Roger, but with GLS standard errors)&quot;box&quot; to use a modified Box correction (does not return confidence intervals),
&quot;bw&quot; to use GLS standard errors with a between-within correction to the degrees of freedom, &quot;bwrobust&quot; to use robust
standard errors with between-within correction to the degrees of freedom.
Note that Kenward-Roger assumes REML estimates, which are not currently provided by this function.</p>
</dd>
<dt><code>max.iter</code></dt><dd><p>Maximum number of algorithm iterations, default 20.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Maximum difference between successive iterations at which to terminate the algorithm</p>
</dd>
<dt><code>se.theta</code></dt><dd><p>Logical. Whether to calculate the standard errors for the covariance parameters. This step is a slow part
of the calculation, so can be disabled if required in larger models. Has no effect for Kenward-Roger standard errors.</p>
</dd>
<dt><code>algo</code></dt><dd><p>Integer. 1 = L-BFGS for beta-u and BOBYQA for theta (default), 2 = BOBYQA for both.</p>
</dd>
<dt><code>lower.bound</code></dt><dd><p>Optional. Vector of lower bounds for the fixed effect parameters. To apply bounds use nloptim.</p>
</dd>
<dt><code>upper.bound</code></dt><dd><p>Optional. Vector of upper bounds for the fixed effect parameters. To apply bounds use nloptim.</p>
</dd>
<dt><code>lower.bound.theta</code></dt><dd><p>Optional. Vector of lower bounds for the covariance parameters.</p>
</dd>
<dt><code>upper.bound.theta</code></dt><dd><p>Optional. Vector of upper bounds for the covariance parameters.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>mcml</code> object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontshow{
setParallel(FALSE) # for the CRAN check
}
#create example data with six clusters, five time periods, and five people per cluster-period
df &lt;- nelder(~(cl(6)*t(5)) &gt; ind(5))
# parallel trial design intervention indicator
df$int &lt;- 0
df[df$cl &gt; 3, 'int'] &lt;- 1 
# specify parameter values in the call for the data simulation below
des &lt;- Model$new(
  formula = ~ factor(t) + int - 1 + (1|gr(cl)*ar0(t)),
  covariance = c(0.05,0.7),
  mean = c(rep(0,5),-0.2),
  data = df,
  family = stats::binomial()
)
ysim &lt;- des$sim_data() # simulate some data from the model
fit1 &lt;- des$LA(y = ysim)
</pre>
</div>


<hr>
<a id="method-Model-sparse"></a>



<h4>Method <code>sparse()</code></h4>

<p>Set whether to use sparse matrix methods for model calculations and fitting.
By default the model does not use sparse matrix methods.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$sparse(sparse = TRUE, amd = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sparse</code></dt><dd><p>Logical indicating whether to use sparse matrix methods</p>
</dd>
<dt><code>amd</code></dt><dd><p>Logical indicating whether to use and Approximate Minimum Degree algorithm to calculate an efficient permutation matrix so
that the Cholesky decomposition of PAP^T is calculated rather than A.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None, called for effects
</p>


<hr>
<a id="method-Model-mcmc_sample"></a>



<h4>Method <code>mcmc_sample()</code></h4>

<p>Generate an MCMC sample of the random effects
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$mcmc_sample(mcmc.pkg = "rstan")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mcmc.pkg</code></dt><dd><p>String. Either <code>cmdstan</code> for cmdstan (requires the package <code>cmdstanr</code>), <code>rstan</code> to use rstan sampler, or
<code>hmc</code> to use a cruder Hamiltonian Monte Carlo sampler. cmdstan is recommended as it has by far the best number
of effective samples per unit time. cmdstanr will compile the MCMC programs to the library folder the first time they are run,
so may not currently be an option for some users.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix of samples of the random effects
</p>


<hr>
<a id="method-Model-gradient"></a>



<h4>Method <code>gradient()</code></h4>

<p>The gradient of the log-likelihood with respect to either the random effects or
the model parameters. The random effects are on the N(0,I) scale, i.e. scaled by the
Cholesky decomposition of the matrix D. To obtain the random effects from the last
model fit, see member function <code style="white-space: pre;">&#8288;$u&#8288;</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$gradient(y, u, beta = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>y</code></dt><dd><p>(optional) Vector of outcome data, if not specified then data must have been set in another function.</p>
</dd>
<dt><code>u</code></dt><dd><p>(optional) Vector of random effects scaled by the Cholesky decomposition of D</p>
</dd>
<dt><code>beta</code></dt><dd><p>Logical. Whether the log gradient for the random effects (FALSE) or for the linear predictor parameters (TRUE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of the gradient
</p>


<hr>
<a id="method-Model-partial_sigma"></a>



<h4>Method <code>partial_sigma()</code></h4>

<p>The partial derivatives of the covariance matrix Sigma with respect to the covariance
parameters. The function returns a list in order: Sigma, first order derivatives, second
order derivatives. The second order derivatives are ordered as the lower-triangular matrix
in column major order. Letting 'd(i)' mean the first-order partial derivative with respect
to parameter i, and d2(i,j) mean the second order derivative with respect to parameters i
and j, then if there were three covariance parameters the order of the output would be:
(sigma, d(1), d(2), d(3), d2(1,1), d2(1,2), d2(1,3), d2(2,2), d2(2,3), d2(3,3)).
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$partial_sigma()</pre></div>



<h5>Returns</h5>

<p>A list of matrices, see description for contents of the list.
</p>


<hr>
<a id="method-Model-u"></a>



<h4>Method <code>u()</code></h4>

<p>Returns the sample of random effects from the last model fit, or updates the samples for the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$u(scaled = TRUE, u)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scaled</code></dt><dd><p>Logical indicating whether the samples are on the N(0,I) scale (<code>scaled=FALSE</code>) or
N(0,D) scale (<code>scaled=TRUE</code>)</p>
</dd>
<dt><code>u</code></dt><dd><p>(optional) Matrix of random effect samples. If provided then the internal samples are replaced with these values. These samples should be N(0,I).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix of random effect samples
</p>


<hr>
<a id="method-Model-log_likelihood"></a>



<h4>Method <code>log_likelihood()</code></h4>

<p>The log likelihood for the GLMM. The random effects can be left
unspecified. If no random effects are provided, and there was a previous model fit with the same data <code>y</code>
then the random effects will be taken from that model. If there was no
previous model fit then the random effects are assumed to be all zero.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$log_likelihood(y, u)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>y</code></dt><dd><p>A vector of outcome data</p>
</dd>
<dt><code>u</code></dt><dd><p>An optional matrix of random effect samples. This can be a single column.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The log-likelihood of the model parameters
</p>


<hr>
<a id="method-Model-calculator_instructions"></a>



<h4>Method <code>calculator_instructions()</code></h4>

<p>Prints the internal instructions and data used to calculate the linear predictor.
Internally the class uses a reverse polish notation to store and
calculate different functions, including user-specified non-linear mean functions. This
function will print all the steps. Mainly used for debugging and determining how the
class has interpreted non-linear model specifications.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$calculator_instructions()</pre></div>



<h5>Returns</h5>

<p>None. Called for effects.
</p>


<hr>
<a id="method-Model-marginal"></a>



<h4>Method <code>marginal()</code></h4>

<p>Calculates the marginal effect of variable x. There are several options for
marginal effect and several types of conditioning or averaging. The type of marginal
effect can be the derivative of the mean with respect to x (<code>dydx</code>), the expected
difference E(y|x=a)-E(y|x=b) (<code>diff</code>), or the expected log ratio log(E(y|x=a)/E(y|x=b)) (<code>ratio</code>).
Other fixed effect variables can be set at specific values (<code>at</code>), set at their mean values
(<code>atmeans</code>), or averaged over (<code>average</code>). Averaging over a fixed effects variable here means
using all observed values of the variable in the relevant calculation.
The random effects can similarly be set at their
estimated value (<code>re="estimated"</code>), set to zero (<code>re="zero"</code>), set to a specific value
(<code>re="at"</code>), or averaged over (<code>re="average"</code>). Estimates of the expected values over the random
effects are generated using MCMC samples. MCMC samples are generated either through
MCML model fitting or using <code>mcmc_sample</code>. In the absence of samples <code>average</code> and <code>estimated</code>
will produce the same result. The standard errors are calculated using the delta method with one
of several options for the variance matrix of the fixed effect parameters.
Several of the arguments require the names
of the variables as given to the model object. Most variables are as specified in the formula,
factor variables are specified as the name of the <code>variable_value</code>, e.g. <code>t_1</code>. To see the names
of the stored parameters and data variables see the member function <code>names()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$marginal(
  x,
  type,
  re,
  se,
  at = c(),
  atmeans = c(),
  average = c(),
  xvals = c(1, 0),
  atvals = c(),
  revals = c()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>String. Name of the variable to calculate the marginal effect for.</p>
</dd>
<dt><code>type</code></dt><dd><p>String. Either <code>dydx</code> for derivative, <code>diff</code> for difference, or <code>ratio</code> for log ratio. See description.</p>
</dd>
<dt><code>re</code></dt><dd><p>String. Either <code>estimated</code> to condition on estimated values, <code>zero</code> to set to zero, <code>at</code> to
provide specific values, or <code>average</code> to average over the random effects.</p>
</dd>
<dt><code>se</code></dt><dd><p>String. Type of standard error to use, either <code>GLS</code> for the GLS standard errors, <code>KR</code> for
Kenward-Roger estimated standard errors, <code>KR2</code> for the improved Kenward-Roger correction (see <code>small_sample_correction()</code>),
or <code>robust</code> to use a robust sandwich estimator.</p>
</dd>
<dt><code>at</code></dt><dd><p>Optional. A vector of strings naming the fixed effects for which a specified value is given.</p>
</dd>
<dt><code>atmeans</code></dt><dd><p>Optional. A vector of strings naming the fixed effects that will be set at their mean value.</p>
</dd>
<dt><code>average</code></dt><dd><p>Optional. A vector of strings naming the fixed effects which will be averaged over.</p>
</dd>
<dt><code>xvals</code></dt><dd><p>Optional. A vector specifying the values of <code>a</code> and <code>b</code> for <code>diff</code> and <code>ratio</code>. The default is (1,0).</p>
</dd>
<dt><code>atvals</code></dt><dd><p>Optional. A vector specifying the values of fixed effects specified in <code>at</code> (in the same order).</p>
</dd>
<dt><code>revals</code></dt><dd><p>Optional. If <code>re="at"</code> then this argument provides a vector of values for the random effects.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A named vector with elements <code>margin</code> specifying the point estimate and <code>se</code> giving the standard error.
</p>


<hr>
<a id="method-Model-update_y"></a>



<h4>Method <code>update_y()</code></h4>

<p>Updates the outcome data y
</p>
<p>Some functions require outcome data, which is by default set to all zero if no model fitting function
has been run. This function can update the interval y data.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$update_y(y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>y</code></dt><dd><p>Vector of outcome data</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None. Called for effects
</p>


<hr>
<a id="method-Model-set_trace"></a>



<h4>Method <code>set_trace()</code></h4>

<p>Controls the information printed to the console for other functions.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$set_trace(trace)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>trace</code></dt><dd><p>Integer, either 0 = no information, 1 = some information, 2 = all information</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None. Called for effects.
</p>


<hr>
<a id="method-Model-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Breslow, N. E., Clayton, D. G. (1993). Approximate Inference in Generalized Linear Mixed Models.
Journal of the American Statistical Association&lt;, 88(421), 9–25. <a href="doi:10.1080/01621459.1993.10594284">doi:10.1080/01621459.1993.10594284</a>
</p>
<p>McCullagh P, Nelder JA (1989). Generalized linear models, 2nd Edition. Routledge.
</p>
<p>McCulloch CE (1997). “Maximum Likelihood Algorithms for Generalized Linear Mixed Models.”
Journal of the American statistical Association, 92(437), 162–170.<a href="doi:10.2307/2291460">doi:10.2307/2291460</a>
</p>
<p>Zeger, S. L., Liang, K.-Y., Albert, P. S. (1988). Models for Longitudinal Data: A Generalized Estimating Equation Approach.
Biometrics, 44(4), 1049.<a href="doi:10.2307/2531734">doi:10.2307/2531734</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+nelder">nelder</a>, <a href="#topic+MeanFunction">MeanFunction</a>, <a href="#topic+Covariance">Covariance</a>
</p>
<p><a href="#topic+Model">Model</a>, <a href="#topic+Covariance">Covariance</a>, <a href="#topic+MeanFunction">MeanFunction</a>
</p>
<p><a href="#topic+Model">Model</a>, <a href="#topic+Covariance">Covariance</a>, <a href="#topic+MeanFunction">MeanFunction</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Model$new`
## ------------------------------------------------


#create a data frame describing a cross-sectional parallel cluster
#randomised trial
df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
df$int &lt;- 0
df[df$cl &gt; 5, 'int'] &lt;- 1
mod &lt;- Model$new(
  formula = ~ factor(t) + int - 1 + (1|gr(cl)) + (1|gr(cl,t)),
  data = df,
  family = stats::gaussian()
)

#here we will specify a cohort study and provide parameter values
df &lt;- nelder(~ind(20) * t(6))
df$int &lt;- 0
df[df$t &gt; 3, 'int'] &lt;- 1
# the preferred way of specifying with parameter values
des &lt;- Model$new(
  formula = ~ int + (1|gr(ind)),
  covariance = c(0.05),
  mean = c(1,0.5),
  data = df,
  family = stats::poisson()
  )
# also works:
des &lt;- Model$new(
  covariance = list(
    formula = ~ (1|gr(ind)),
    parameters = c(0.05)),
  mean = list(
    formula = ~ int,
    parameters = c(1,0.5)),
  data = df,
  family = stats::poisson())

#an example of a spatial grid with two time points
df &lt;- nelder(~ (x(10)*y(10))*t(2))
spt_design &lt;- Model$new(formula = ~ 1 + (1|ar0(t)*fexp(x,y)),
                        data = df,
                        family = stats::gaussian())

## ------------------------------------------------
## Method `Model$sim_data`
## ------------------------------------------------

df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
df$int &lt;- 0
df[df$cl &gt; 5, 'int'] &lt;- 1

des &lt;- Model$new(
  covariance = list(
    formula = ~ (1|gr(cl)*ar0(t)),
    parameters = c(0.05,0.8)),
  mean = list(
    formula = ~ factor(t) + int - 1,
    parameters = c(rep(0,5),0.6)),
  data = df,
  family = stats::binomial()
)
ysim &lt;- des$sim_data()

## ------------------------------------------------
## Method `Model$update_parameters`
## ------------------------------------------------


df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
df$int &lt;- 0
df[df$cl &gt; 5, 'int'] &lt;- 1
des &lt;- Model$new(
  formula = ~ factor(t) + int - 1 + (1|gr(cl)*ar0(t)),
  data = df,
  family = stats::binomial()
)
des$update_parameters(cov.pars = c(0.1,0.9))

## ------------------------------------------------
## Method `Model$power`
## ------------------------------------------------


df &lt;- nelder(~(cl(10)*t(5)) &gt; ind(10))
df$int &lt;- 0
df[df$cl &gt; 5, 'int'] &lt;- 1
des &lt;- Model$new(
  formula = ~ factor(t) + int - 1 + (1|gr(cl)) + (1|gr(cl,t)),
  covariance = c(0.05,0.1),
  mean = c(rep(0,5),0.6),
  data = df,
  family = stats::gaussian(),
  var_par = 1
)
des$power() #power of 0.90 for the int parameter

## ------------------------------------------------
## Method `Model$MCML`
## ------------------------------------------------

## Not run: 
#create example data with six clusters, five time periods, and five people per cluster-period
df &lt;- nelder(~(cl(6)*t(5)) &gt; ind(5))
# parallel trial design intervention indicator
df$int &lt;- 0
df[df$cl &gt; 3, 'int'] &lt;- 1 
# specify parameter values in the call for the data simulation below
des &lt;- Model$new(
  formula= ~ factor(t) + int - 1 +(1|gr(cl)*ar0(t)),
  covariance = c(0.05,0.7),
  mean = c(rep(0,5),0.2),
  data = df,
  family = gaussian()
)
ysim &lt;- des$sim_data() # simulate some data from the model
fit1 &lt;- des$MCML(y = ysim) # Default model fitting with SAEM-PR
# use MCEM instead and stop when parameter values are within 1e-2 on successive iterations
fit2 &lt;- des$MCML(y = ysim, method="mcem",tol=1e-2,conv.criterion = 1)

## End(Not run)

## ------------------------------------------------
## Method `Model$LA`
## ------------------------------------------------


#create example data with six clusters, five time periods, and five people per cluster-period
df &lt;- nelder(~(cl(6)*t(5)) &gt; ind(5))
# parallel trial design intervention indicator
df$int &lt;- 0
df[df$cl &gt; 3, 'int'] &lt;- 1 
# specify parameter values in the call for the data simulation below
des &lt;- Model$new(
  formula = ~ factor(t) + int - 1 + (1|gr(cl)*ar0(t)),
  covariance = c(0.05,0.7),
  mean = c(rep(0,5),-0.2),
  data = df,
  family = stats::binomial()
)
ysim &lt;- des$sim_data() # simulate some data from the model
fit1 &lt;- des$LA(y = ysim)
</code></pre>

<hr>
<h2 id='nelder'>Generates a block experimental structure using Nelder's formula</h2><span id='topic+nelder'></span>

<h3>Description</h3>

<p>Generates a data frame expressing a block experimental structure using Nelder's formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nelder(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nelder_+3A_formula">formula</code></td>
<td>
<p>A model formula. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nelder (1965) suggested a simple notation that could express a large variety of different blocked designs. 
The function 'nelder()' that generates a data frame of a design using the notation. 
There are two operations:
</p>
<p>'&gt;' (or <code class="reqn">\to</code> in Nelder's notation) indicates &quot;clustered in&quot;.
</p>
<p>'*' (or <code class="reqn">\times</code> in Nelder's notation) indicates a crossing that generates all combinations of two factors.
</p>
<p>The implementation of this notation includes a string indicating the name of the variable and a number for the number of levels, 
such as 'abc(12)'. So for example '~cl(4) &gt; ind(5)' means in each of five levels of 'cl' there are five levels of 'ind', and 
the individuals are different between clusters. The formula '~cl(4) * t(3)' indicates that each of the four levels of 'cl' are 
observed for each of the three levels of 't'. Brackets are used to indicate the order of evaluation. Some specific examples:
</p>
<p>'~person(5) * time(10)': A cohort study with five people, all observed in each of ten periods 'time'
</p>
<p>'~(cl(4) * t(3)) &gt; ind(5)': A repeated-measures cluster study with four clusters (labelled 'cl'), each observed in each time 
period 't' with cross-sectional sampling and five indviduals (labelled 'ind') in each cluster-period.
</p>
<p>'~(cl(4) &gt; ind(5)) * t(3)': A repeated-measures cluster cohort study with four clusters (labelled 'cl') wth five 
individuals per cluster, and each cluster-individual combination is observed in each time period 't'.
</p>
<p>'~((x(100) * y(100)) &gt; hh(4)) * t(2)': A spatio-temporal grid of 100x100 and two time points, with 4  households per spatial 
grid cell.
</p>


<h3>Value</h3>

<p>A list with the first member being the data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nelder(~(j(4) * t(5)) &gt; i(5))
nelder(~person(5) * time(10))
</code></pre>

<hr>
<h2 id='nest_df'>Generate nested block structure</h2><span id='topic+nest_df'></span>

<h3>Description</h3>

<p>Generate a data frame that nests one data frame in another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_df(df1, df2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_df_+3A_df1">df1</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="nest_df_+3A_df2">df2</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two data frames 'df1' and 'df2', the function will return another data frame
that nests 'df2' in 'df1'. So each row of 'df1' will be duplicated 'nrow(df2)' times 
and matched with 'df2'. The values of each 'df2' will be unique for each row of 'df1'
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nest_df(data.frame(t=1:4),data.frame(cl=1:3))
</code></pre>

<hr>
<h2 id='predict.mcml'>Predict from a 'mcml' object</h2><span id='topic+predict.mcml'></span>

<h3>Description</h3>

<p>Predictions cannot be generated directly from an 'mcml' object, rather new predictions should be
generated using the original 'Model'. A message is printed to the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mcml_+3A_object">object</code></td>
<td>
<p>A 'mcml' object.</p>
</td></tr>
<tr><td><code id="predict.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Called for effects.
</p>

<hr>
<h2 id='predict.Model'>Generate predictions at new values from a 'Model' object</h2><span id='topic+predict.Model'></span>

<h3>Description</h3>

<p>Generates predicted values from a 'Model' object using a new data set to specify covariance 
values and values for the variables that define the covariance function.
The function will return a list with the linear predictor, conditional 
distribution of the new random effects term conditional on the current estimates
of the random effects, and some simulated values of the random effects if requested. Typically 
this functionality is accessed using 'Model$predict()', which this function provides a wrapper for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Model'
predict(object, newdata, offset = rep(0, nrow(newdata)), m = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.Model_+3A_object">object</code></td>
<td>
<p>A 'Model' object.</p>
</td></tr>
<tr><td><code id="predict.Model_+3A_newdata">newdata</code></td>
<td>
<p>A data frame specifying the new data at which to generate predictions</p>
</td></tr>
<tr><td><code id="predict.Model_+3A_offset">offset</code></td>
<td>
<p>Optional vector of offset values for the new data</p>
</td></tr>
<tr><td><code id="predict.Model_+3A_m">m</code></td>
<td>
<p>Number of samples of the random effects to draw</p>
</td></tr>
<tr><td><code id="predict.Model_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the linear predictor, parameters (mean and covariance matrices) for
the conditional distribution of the random effects, and any random effect samples.
</p>

<hr>
<h2 id='print.mcml'>Prints an mcml fit output</h2><span id='topic+print.mcml'></span>

<h3>Description</h3>

<p>Print method for class &quot;'mcml'&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mcml_+3A_x">x</code></td>
<td>
<p>an object of class &quot;'mcml'&quot; as a result of a call to MCML, see <a href="#topic+Model">Model</a></p>
</td></tr>
<tr><td><code id="print.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'print.mcml' tries to replicate the output of other regression functions, such
as 'lm' and 'lmer' reporting parameters, standard errors, and z- and p- statistics.
The z- and p- statistics should be interpreted cautiously however, as generalised
linear miobjected models can suffer from severe small sample biases where the effective
sample size relates more to the higher levels of clustering than individual observations.
</p>
<p>Parameters 'b' are the mean function beta parameters, parameters 'cov' are the
covariance function parameters in the same order as '$covariance$parameters', and
parameters 'd' are the estimated random effects.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='progress_bar'>Generates a progress bar</h2><span id='topic+progress_bar'></span>

<h3>Description</h3>

<p>Prints a progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress_bar(i, n, len = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progress_bar_+3A_i">i</code></td>
<td>
<p>integer. The current iteration.</p>
</td></tr>
<tr><td><code id="progress_bar_+3A_n">n</code></td>
<td>
<p>integer. The total number of interations</p>
</td></tr>
<tr><td><code id="progress_bar_+3A_len">len</code></td>
<td>
<p>integer. Length of the progress a number of characters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>progress_bar(10,100)
</code></pre>

<hr>
<h2 id='random.effects'>Extracts the random effect estimates</h2><span id='topic+random.effects'></span>

<h3>Description</h3>

<p>Extracts the random effect estimates or samples from an mcml object returned from call of 'MCML' or 'LA' in the <a href="#topic+Model">Model</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.effects(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.effects_+3A_object">object</code></td>
<td>
<p>An 'mcml' model fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension (number of fixed effects ) x (number of MCMC samples). For Laplace approximation, the number of &quot;samples&quot; equals one.
</p>

<hr>
<h2 id='residuals.mcml'>Residuals method for a 'mcml' object</h2><span id='topic+residuals.mcml'></span>

<h3>Description</h3>

<p>Calling residuals on an 'mcml' object directly is not recommended. This function will currently only generate marginal residuals.
It will generate a new 'Model' object internally, thus copying 
all the data, which is not ideal for larger models. The preferred method is to call residuals on either the 'Model' 
object or using 'Model$residuals()', both of which will also generate conditional residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
residuals(object, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.mcml_+3A_object">object</code></td>
<td>
<p>A 'mcml' object.</p>
</td></tr>
<tr><td><code id="residuals.mcml_+3A_type">type</code></td>
<td>
<p>Either &quot;standardized&quot;, &quot;raw&quot; or &quot;pearson&quot;</p>
</td></tr>
<tr><td><code id="residuals.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with either one column is conditional is false, or with number of columns corresponding 
to the number of MCMC samples.
</p>

<hr>
<h2 id='residuals.Model'>Extract residuals from a 'Model' object</h2><span id='topic+residuals.Model'></span>

<h3>Description</h3>

<p>Return the residuals from a 'Model' object. This function is a wrapper for 'Model$residuals()'.
Generates one of several types of residual for the model. If conditional = TRUE then 
the residuals include the random effects, otherwise only the fixed effects are included. For type,
there are raw, pearson, and standardized residuals. For conditional residuals a matrix is returned 
with each column corresponding to a sample of the random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Model'
residuals(object, type, conditional, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.Model_+3A_object">object</code></td>
<td>
<p>A 'Model' object.</p>
</td></tr>
<tr><td><code id="residuals.Model_+3A_type">type</code></td>
<td>
<p>Either &quot;standardized&quot;, &quot;raw&quot; or &quot;pearson&quot;</p>
</td></tr>
<tr><td><code id="residuals.Model_+3A_conditional">conditional</code></td>
<td>
<p>Logical indicating whether to condition on the random effects (TRUE) or not (FALSE)</p>
</td></tr>
<tr><td><code id="residuals.Model_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with either one column is conditional is false, or with number of columns corresponding 
to the number of MCMC samples.
</p>

<hr>
<h2 id='setParallel'>Disable or enable parallelised computing</h2><span id='topic+setParallel'></span>

<h3>Description</h3>

<p>By default, the package will use multithreading for many calculations if OpenMP is 
available on the system. For multi-user systems this may not be desired, so parallel
execution can be disabled with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setParallel(parallel_, cores_ = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setParallel_+3A_parallel_">parallel_</code></td>
<td>
<p>Logical indicating whether to use parallel computation (TRUE) or disable it (FALSE)</p>
</td></tr>
<tr><td><code id="setParallel_+3A_cores_">cores_</code></td>
<td>
<p>Number of cores for parallel execution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, called for effects
</p>

<hr>
<h2 id='summary.mcml'>Summarises an mcml fit output</h2><span id='topic+summary.mcml'></span>

<h3>Description</h3>

<p>Summary method for class &quot;'mcml'&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mcml_+3A_object">object</code></td>
<td>
<p>an object of class &quot;'mcml'&quot; as a result of a call to MCML, see <a href="#topic+Model">Model</a></p>
</td></tr>
<tr><td><code id="summary.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'print.mcml' tries to replicate the output of other regression functions, such
as 'lm' and 'lmer' reporting parameters, standard errors, and z- and p- statistics.
The z- and p- statistics should be interpreted cautiously however, as generalised
linear miobjected models can suffer from severe small sample biases where the effective
sample size relates more to the higher levels of clustering than individual observations.
</p>
<p>Parameters 'b' are the mean function beta parameters, parameters 'cov' are the
covariance function parameters in the same order as '$covariance$parameters', and
parameters 'd' are the estimated random effects.
</p>


<h3>Value</h3>

<p>A list with random effect names and a data frame with random effect mean and credible intervals
</p>

<hr>
<h2 id='summary.Model'>Summarizes a 'Model' object</h2><span id='topic+summary.Model'></span>

<h3>Description</h3>

<p>Summarizes 'Model' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Model'
summary(object, max_n = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Model_+3A_object">object</code></td>
<td>
<p>An 'Model' object.</p>
</td></tr>
<tr><td><code id="summary.Model_+3A_max_n">max_n</code></td>
<td>
<p>Integer. The maximum number of rows to print.</p>
</td></tr>
<tr><td><code id="summary.Model_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'logLik'. If both 'fixed' and 'covariance' are FALSE then it returns NA.
</p>

<hr>
<h2 id='vcov.mcml'>Extract the Variance-Covariance matrix for a 'mcml' object</h2><span id='topic+vcov.mcml'></span>

<h3>Description</h3>

<p>Returns the calculated variance-covariance matrix for a 'mcml' object. The generating Model object 
has several methods to calculate the variance-convaariance matrix. For the standard GLS information matrix see
'Model$information_matrix()'. Small sample corrections 
can be accessed directly from the generating Model using 'Model$small_sample_correction()'. The varaince-covariance 
matrix including the random effects can be accessed using 'Model$information_matrix(include.re = TRUE)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcml'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mcml_+3A_object">object</code></td>
<td>
<p>A 'mcml' object.</p>
</td></tr>
<tr><td><code id="vcov.mcml_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance-covariance matrix.
</p>

<hr>
<h2 id='vcov.Model'>Calculate Variance-Covariance matrix for a 'Model' object</h2><span id='topic+vcov.Model'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix for a 'Model' object. Specifically, this function will 
return the inverse GLS information matrix for the fixed effect parameters. Small sample corrections 
can be accessed directly from the Model using 'Model$small_sample_correction()'. The varaince-covariance 
matrix including the random effects can be accessed using 'Model$information_matrix(include.re = TRUE)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Model'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.Model_+3A_object">object</code></td>
<td>
<p>A 'Model' object.</p>
</td></tr>
<tr><td><code id="vcov.Model_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance-covariance matrix.
</p>

<hr>
<h2 id='yexample312a'>Data for first example in Section 3.12 of JSS paper</h2><span id='topic+yexample312a'></span>

<h3>Description</h3>

<p>Data for first example in Section 3.12 of JSS paper
</p>

<hr>
<h2 id='yexample312b'>Data for second example in Section 3.12 of JSS paper</h2><span id='topic+yexample312b'></span>

<h3>Description</h3>

<p>Data for second example in Section 3.12 of JSS paper
</p>

<hr>
<h2 id='yexample312c'>Data for third example in Section 3.12 of JSS paper</h2><span id='topic+yexample312c'></span>

<h3>Description</h3>

<p>Data for third example in Section 3.12 of JSS paper
</p>

<hr>
<h2 id='ytest1'>Data for model tests</h2><span id='topic+ytest1'></span>

<h3>Description</h3>

<p>Data for model tests
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
