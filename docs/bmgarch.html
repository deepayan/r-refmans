<!DOCTYPE html><html><head><title>Help for package bmgarch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bmgarch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bmgarch-package'><p>The 'bmgarch' package.</p></a></li>
<li><a href='#.colQTs'><p>Quantiles within lists</p></a></li>
<li><a href='#.cp'><p>Internal function</p></a></li>
<li><a href='#.f_array_x_mat'><p>Multiply matrices in array with a vector &ndash; generic</p></a></li>
<li><a href='#.f_MA'><p>Multiply matrices in array with a vector</p></a></li>
<li><a href='#.get_stan_summary'><p>Get stan summaries.</p></a></li>
<li><a href='#.newline'><p>Print helper - Return new line(s).</p></a></li>
<li><a href='#.pred_array_to_df'><p>Convert predictive array to data.frame.</p></a></li>
<li><a href='#.print.config'><p>Print helper for Sampling Config.</p></a></li>
<li><a href='#.print.summary.bekk'><p>Print helper for BEKK/pdBEKK.</p></a></li>
<li><a href='#.print.summary.beta'><p>Print helper for beta component.</p></a></li>
<li><a href='#.print.summary.ccc'><p>Print helper for CCC.</p></a></li>
<li><a href='#.print.summary.dcc'><p>Print helper for DCC.</p></a></li>
<li><a href='#.print.summary.lp'><p>Print helper for LP component.</p></a></li>
<li><a href='#.print.summary.means'><p>Print helper for means component.</p></a></li>
<li><a href='#.print.summary.nu'><p>Print helper for nu component.</p></a></li>
<li><a href='#.qtile'><p>Internal function to be used</p></a></li>
<li><a href='#.refit'><p>Refit model</p></a></li>
<li><a href='#.sep'><p>Print helper - Separator, new line</p></a></li>
<li><a href='#.sim.bekk'><p>Simulate BEKK data.</p></a></li>
<li><a href='#.square'><p>Internal function to be used in sweep()</p></a></li>
<li><a href='#.tab'><p>Print helper - tab</p></a></li>
<li><a href='#as.data.frame.fitted.bmgarch'><p>as.data.frame method for fitted.bmgarch objects.</p></a></li>
<li><a href='#as.data.frame.forecast.bmgarch'><p>as.data.frame method for forecast.bmgarch objects.</p></a></li>
<li><a href='#bmgarch'><p>Estimate Bayesian Multivariate GARCH</p></a></li>
<li><a href='#bmgarch_list'><p>Collect bmgarch objects into list.</p></a></li>
<li><a href='#fitted.bmgarch'><p>Fitted (backcasting) method for bmgarch objects.</p></a></li>
<li><a href='#forecast.bmgarch'><p>Forecast method for bmgarch objects.</p></a></li>
<li><a href='#loo.bmgarch'><p>Leave-Future-Out Cross Validation (LFO-CV)</p></a></li>
<li><a href='#model_weights'><p>Model weights</p></a></li>
<li><a href='#panas'><p>Positive and Negative Affect Scores.</p></a></li>
<li><a href='#plot.bmgarch'><p>Plot method for bmgarch objects.</p></a></li>
<li><a href='#plot.forecast.bmgarch'><p>Plot method for forecast.bmgarch objects.</p></a></li>
<li><a href='#print.fitted.bmgarch'><p>Print method for fitted.bmgarch objects.</p></a></li>
<li><a href='#print.forecast.bmgarch'><p>Print method for forecast.bmgarch objects.</p></a></li>
<li><a href='#print.loo.bmgarch'><p>print method for lfocv</p></a></li>
<li><a href='#print.model_weights'><p>Print method for model_weights</p></a></li>
<li><a href='#print.summary.bmgarch'><p>Print method for bmgarch.summary objects.</p></a></li>
<li><a href='#standat'><p>Standardize input data to facilitate computation</p></a></li>
<li><a href='#stocks'><p>Daily data on returns of Toyota, Nissan, and Honda stocks.</p></a></li>
<li><a href='#summary.bmgarch'><p>Summary method for bmgarch objects.</p></a></li>
<li><a href='#supported_models'><p>Models supported by bmgarch</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Multivariate GARCH Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Bayesian multivariate GARCH models using 'Stan' for full Bayesian inference. Generate (weighted) forecasts for means, variances (volatility) and correlations. Currently DCC(P,Q), CCC(P,Q), pdBEKK(P,Q), and BEKK(P,Q) parameterizations are implemented, based either on a multivariate gaussian normal or student-t distribution. DCC and CCC models are based on Engle (2002) &lt;<a href="https://doi.org/10.1198%2F073500102288618487">doi:10.1198/073500102288618487</a>&gt; and Bollerslev (1990). The BEKK parameterization follows Engle and Kroner (1995) &lt;<a href="https://doi.org/10.1017%2FS0266466600009063">doi:10.1017/S0266466600009063</a>&gt; while the pdBEKK as well as the estimation approach for this package is described in Rast et al. (2020) &lt;<a href="https://doi.org/10.31234%2Fosf.io%2Fj57pk">doi:10.31234/osf.io/j57pk</a>&gt;. The fitted models contain 'rstan' objects and can be examined with 'rstan' functions.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 4.0.0), Rcpp (&ge; 1.0.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>forecast, ggplot2, loo, MASS, Rdpack, rstan (&ge; 2.26.0),
rstantools (&ge; 2.1.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.72.0-0), Rcpp (&ge; 1.0.5), RcppParallel (&ge; 5.0.1),
RcppEigen (&ge; 0.3.3.7.0), RcppParallel (&ge; 5.0.1), rstan (&ge;
2.26.0), StanHeaders (&ge; 2.26.0)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.3.2)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ph-rast/bmgarch/issues">https://github.com/ph-rast/bmgarch/issues</a></td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-11 23:22:51 UTC; philippe</td>
</tr>
<tr>
<td>Author:</td>
<td>Philippe Rast <a href="https://orcid.org/0000-0003-3630-6629"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Stephen Martin <a href="https://orcid.org/0000-0001-8085-2390"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philippe Rast &lt;rast.ph@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-12 00:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bmgarch-package'>The 'bmgarch' package.</h2><span id='topic+bmgarch-package'></span>

<h3>Description</h3>

<p>The *bmgarch* package fits Bayesian multivariate GARCH models specified via stan,
a C++ package providing HMC methods for full Bayesian inference (cf. [http://mc-stan.org]). The currently implemented parameterizations are DCC(Q,P),
CCC(Q,P), and BEKK(Q,P) with arbitrary lags defined in Q, and P. The package provides summaries and plots for the estimates as well
as forecasted series with corresponding plots. The fitted objects are rstan class objects that can be inspected and manipulated
accordingly.
</p>


<h3>Author(s)</h3>

<p>Philippe Rast
</p>


<h3>References</h3>

<p>Stan Development Team (2018). RStan: the R interface to Stan. R package version 2.18.2. http://mc-stan.org
</p>

<hr>
<h2 id='.colQTs'>Quantiles within lists</h2><span id='topic+.colQTs'></span>

<h3>Description</h3>

<p>Obtain quantiles over columns in lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.colQTs(x, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".colQTs_+3A_x">x</code></td>
<td>
</td></tr>
<tr><td><code id=".colQTs_+3A_probs">probs</code></td>
<td>
<p>Quantile(s). Inherits from <code>forecast</code> which defaults to <code>c(.025, .975)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Quantiles at the column level within lists
</p>


<h3>Author(s)</h3>

<p>philippe
</p>

<hr>
<h2 id='.cp'>Internal function</h2><span id='topic+.cp'></span>

<h3>Description</h3>

<p>Internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cp_+3A_x">x</code></td>
<td>
<p>stan objec</p>
</td></tr>
</table>

<hr>
<h2 id='.f_array_x_mat'>Multiply matrices in array with a vector &ndash; generic</h2><span id='topic+.f_array_x_mat'></span>

<h3>Description</h3>

<p>Multiply matrices in array with a vector &ndash; generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.f_array_x_mat(mat_out, array_obj, mat_obj, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".f_array_x_mat_+3A_mat_out">mat_out</code></td>
<td>
</td></tr>
<tr><td><code id=".f_array_x_mat_+3A_array_obj">array_obj</code></td>
<td>
</td></tr>
<tr><td><code id=".f_array_x_mat_+3A_mat_obj">mat_obj</code></td>
<td>
</td></tr>
<tr><td><code id=".f_array_x_mat_+3A_i">i</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p>Philippe Rast
</p>

<hr>
<h2 id='.f_MA'>Multiply matrices in array with a vector</h2><span id='topic+.f_MA'></span>

<h3>Description</h3>

<p>Multiply matrices in array with a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.f_MA(MA, theta, mu, rts, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".f_MA_+3A_ma">MA</code></td>
<td>
</td></tr>
<tr><td><code id=".f_MA_+3A_theta">theta</code></td>
<td>
</td></tr>
<tr><td><code id=".f_MA_+3A_mu">mu</code></td>
<td>
</td></tr>
<tr><td><code id=".f_MA_+3A_rts">rts</code></td>
<td>
</td></tr>
<tr><td><code id=".f_MA_+3A_i">i</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p>Philippe Rast
</p>

<hr>
<h2 id='.get_stan_summary'>Get stan summaries.</h2><span id='topic+.get_stan_summary'></span>

<h3>Description</h3>

<p>Get stan summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_stan_summary(model_fit, params, CrI, weights = NULL, sampling_algorithm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_stan_summary_+3A_model_fit">model_fit</code></td>
<td>
<p>stanfit object or list of stanfit objects.</p>
</td></tr>
<tr><td><code id=".get_stan_summary_+3A_params">params</code></td>
<td>
<p>Character vector. Names of params to pull from stan summary.</p>
</td></tr>
<tr><td><code id=".get_stan_summary_+3A_cri">CrI</code></td>
<td>
<p>Numeric vector (length 2).</p>
</td></tr>
<tr><td><code id=".get_stan_summary_+3A_weights">weights</code></td>
<td>
<p>Numeric vector. Weights for each model in model_fit, if list.</p>
</td></tr>
<tr><td><code id=".get_stan_summary_+3A_sampling_algorithm">sampling_algorithm</code></td>
<td>
<p>Character vector for sampling method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stan summary for parameters. Columns: mean, sd, mdn, and CrIs.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin, Philippe Rast
</p>

<hr>
<h2 id='.newline'>Print helper - Return new line(s).</h2><span id='topic+.newline'></span>

<h3>Description</h3>

<p>Print helper - Return new line(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newline(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newline_+3A_n">n</code></td>
<td>
<p>Integer (Default: 1). Number of new lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints new lines.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.pred_array_to_df'>Convert predictive array to data.frame.</h2><span id='topic+.pred_array_to_df'></span>

<h3>Description</h3>

<p>Helper function for as.data.frame.fitted, forecast. Converts predictive array to data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pred_array_to_df(arr, type = "backcast", param = "var")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".pred_array_to_df_+3A_arr">arr</code></td>
<td>
<p>Array to convert into data frame.</p>
</td></tr>
<tr><td><code id=".pred_array_to_df_+3A_type">type</code></td>
<td>
<p>String. &quot;backcast&quot; or &quot;forecast&quot;.</p>
</td></tr>
<tr><td><code id=".pred_array_to_df_+3A_param">param</code></td>
<td>
<p>String. &quot;var&quot;, &quot;mean&quot;, or &quot;cor&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame. Columns: period, type (backcast, forecast), param (var, mean, cor), TS (which time series, or which correlation for param = cor), summary columns.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.print.config'>Print helper for Sampling Config.</h2><span id='topic+.print.config'></span>

<h3>Description</h3>

<p>Print helper for Sampling Config.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.print.config(bmsum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".print.config_+3A_bmsum">bmsum</code></td>
<td>
<p>summary.bmgarch object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Void.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin, Philippe Rast
</p>

<hr>
<h2 id='.print.summary.bekk'>Print helper for BEKK/pdBEKK.</h2><span id='topic+.print.summary.bekk'></span>

<h3>Description</h3>

<p>Print helper for BEKK/pdBEKK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.print.summary.bekk(bmsum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".print.summary.bekk_+3A_bmsum">bmsum</code></td>
<td>
<p>summary.bmgarch object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Void.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin, Philippe Rast
</p>

<hr>
<h2 id='.print.summary.beta'>Print helper for beta component.</h2><span id='topic+.print.summary.beta'></span>

<h3>Description</h3>

<p>Print helper for beta component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.print.summary.beta(bmsum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".print.summary.beta_+3A_bmsum">bmsum</code></td>
<td>
<p>summary.bmgarch object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Void.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin, Philippe Rast
</p>

<hr>
<h2 id='.print.summary.ccc'>Print helper for CCC.</h2><span id='topic+.print.summary.ccc'></span>

<h3>Description</h3>

<p>Print helper for CCC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.print.summary.ccc(bmsum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".print.summary.ccc_+3A_bmsum">bmsum</code></td>
<td>
<p>summary.bmgarch object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Void.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin, Philippe Rast
</p>

<hr>
<h2 id='.print.summary.dcc'>Print helper for DCC.</h2><span id='topic+.print.summary.dcc'></span>

<h3>Description</h3>

<p>Print helper for DCC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.print.summary.dcc(bmsum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".print.summary.dcc_+3A_bmsum">bmsum</code></td>
<td>
<p>summary.bmgarch object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Void.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin, Philippe Rast
</p>

<hr>
<h2 id='.print.summary.lp'>Print helper for LP component.</h2><span id='topic+.print.summary.lp'></span>

<h3>Description</h3>

<p>Print helper for LP component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.print.summary.lp(bmsum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".print.summary.lp_+3A_bmsum">bmsum</code></td>
<td>
<p>summary.bmgarch object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Void.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin, Philippe Rast
</p>

<hr>
<h2 id='.print.summary.means'>Print helper for means component.</h2><span id='topic+.print.summary.means'></span>

<h3>Description</h3>

<p>Print helper for means component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.print.summary.means(bmsum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".print.summary.means_+3A_bmsum">bmsum</code></td>
<td>
<p>summary.bmgarch object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Void.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin, Philippe Rast
</p>

<hr>
<h2 id='.print.summary.nu'>Print helper for nu component.</h2><span id='topic+.print.summary.nu'></span>

<h3>Description</h3>

<p>Print helper for nu component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.print.summary.nu(bmsum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".print.summary.nu_+3A_bmsum">bmsum</code></td>
<td>
<p>summary.bmgarch object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Void.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin, Philippe Rast
</p>

<hr>
<h2 id='.qtile'>Internal function to be used</h2><span id='topic+.qtile'></span>

<h3>Description</h3>

<p>Internal function to be used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.qtile(x, CrI = c(0.025, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".qtile_+3A_x">x</code></td>
<td>
</td></tr>
</table>

<hr>
<h2 id='.refit'>Refit model</h2><span id='topic+.refit'></span>

<h3>Description</h3>

<p>Refit model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.refit(object, data, xC_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".refit_+3A_object">object</code></td>
<td>
<p>bmgarch model object</p>
</td></tr>
<tr><td><code id=".refit_+3A_data">data</code></td>
<td>
<p>new data</p>
</td></tr>
<tr><td><code id=".refit_+3A_xc_data">xC_data</code></td>
<td>
<p>new predictor</p>
</td></tr>
</table>

<hr>
<h2 id='.sep'>Print helper - Separator, new line</h2><span id='topic+.sep'></span>

<h3>Description</h3>

<p>Print helper - Separator, new line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sep()
</code></pre>


<h3>Value</h3>

<p>Prints &quot;&mdash;&quot; and a new line.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.sim.bekk'>Simulate BEKK data.</h2><span id='topic+.sim.bekk'></span>

<h3>Description</h3>

<p>Simulates time series data from specified BEKK model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sim.bekk(N, C, A, B, phi = NULL, theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sim.bekk_+3A_n">N</code></td>
<td>
<p>Integer. Length of time series.</p>
</td></tr>
<tr><td><code id=".sim.bekk_+3A_c">C</code></td>
<td>
<p>Numeric square matrix. Constant covariance matrix (C). Must be symmetric.</p>
</td></tr>
<tr><td><code id=".sim.bekk_+3A_a">A</code></td>
<td>
<p>Numeric square matrix. Moving average GARCH matrix (A).</p>
</td></tr>
<tr><td><code id=".sim.bekk_+3A_b">B</code></td>
<td>
<p>Numeric square matrix. Autoregressive ARCH matrix (B).</p>
</td></tr>
<tr><td><code id=".sim.bekk_+3A_phi">phi</code></td>
<td>
<p>Numeric square matrix (Optional). Autoregressive coefficients (Phi).</p>
</td></tr>
<tr><td><code id=".sim.bekk_+3A_theta">theta</code></td>
<td>
<p>Numeric square matrix (Optional). Moving average coefficients (Theta).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates timeseries data from specified BEKK model.
Number of time series computed from the number of columns in C.
All matrices must be of the same dimension.
If ARMA parameters (phi, theta) unspecified (NULL), then assumes a constant mean of zero.
</p>


<h3>Value</h3>

<p>Matrix of observations.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.square'>Internal function to be used in sweep()</h2><span id='topic+.square'></span>

<h3>Description</h3>

<p>Internal function to be used in sweep()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.square(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".square_+3A_x">x</code></td>
<td>
<p>Value to be squared</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Squared value
</p>


<h3>Author(s)</h3>

<p>Philippe Rast
</p>

<hr>
<h2 id='.tab'>Print helper - tab</h2><span id='topic+.tab'></span>

<h3>Description</h3>

<p>Print helper - tab
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.tab()
</code></pre>


<h3>Value</h3>

<p>Prints tab.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='as.data.frame.fitted.bmgarch'>as.data.frame method for fitted.bmgarch objects.</h2><span id='topic+as.data.frame.fitted.bmgarch'></span>

<h3>Description</h3>

<p>as.data.frame method for fitted.bmgarch objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted.bmgarch'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.fitted.bmgarch_+3A_x">x</code></td>
<td>
<p>fitted.bmgarch object.</p>
</td></tr>
<tr><td><code id="as.data.frame.fitted.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='as.data.frame.forecast.bmgarch'>as.data.frame method for forecast.bmgarch objects.</h2><span id='topic+as.data.frame.forecast.bmgarch'></span>

<h3>Description</h3>

<p>as.data.frame method for forecast.bmgarch objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecast.bmgarch'
as.data.frame(x, ..., backcast = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.forecast.bmgarch_+3A_x">x</code></td>
<td>
<p>forecast.bmgarch object.</p>
</td></tr>
<tr><td><code id="as.data.frame.forecast.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.data.frame.forecast.bmgarch_+3A_backcast">backcast</code></td>
<td>
<p>Logical (Default: True). Whether to include &quot;backcasted&quot; values from <code><a href="#topic+fitted.bmgarch">fitted.bmgarch</a></code> in data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='bmgarch'>Estimate Bayesian Multivariate GARCH</h2><span id='topic+bmgarch'></span>

<h3>Description</h3>

<p>Draw samples from a specified multivariate GARCH model using 'Stan', given multivariate time-series. Currently supports CCC, DCC, BEKK, and pdBEKK model parameterizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmgarch(
  data,
  xC = NULL,
  parameterization = "CCC",
  P = 1,
  Q = 1,
  iterations = 2000,
  chains = 4,
  standardize_data = FALSE,
  distribution = "Student_t",
  meanstructure = "constant",
  sampling_algorithm = "MCMC",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmgarch_+3A_data">data</code></td>
<td>
<p>Time-series or matrix object. A time-series or matrix object containing observations at the same interval.</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_xc">xC</code></td>
<td>
<p>Numeric vector or matrix. Covariates(s) for the constant variance terms in C, or c, used in a log-linear model on the constant variance terms (Rast et al. 2020). If vector, then it acts as a covariate for all constant variance terms. If matrix, must have columns equal to number of time series, and each column acts as a covariate for the respective time series (e.g., column 1 predicts constant variance for time series 1).</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_parameterization">parameterization</code></td>
<td>
<p>Character (Default: &quot;CCC&quot;). The type of of parameterization. Must be one of &quot;CCC&quot;, &quot;DCC&quot;, &quot;BEKK&quot;, or &quot;pdBEKK&quot;.</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_p">P</code></td>
<td>
<p>Integer. Dimension of GARCH component in MGARCH(P,Q).</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_q">Q</code></td>
<td>
<p>Integer. Dimension of ARCH component in MGARCH(P,Q).</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_iterations">iterations</code></td>
<td>
<p>Integer (Default: 2000). Number of iterations for each chain (including warmup).</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_chains">chains</code></td>
<td>
<p>Integer (Default: 4). The number of Markov chains.</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_standardize_data">standardize_data</code></td>
<td>
<p>Logical (Default: FALSE). Whether data should be standardized to easy computations.</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_distribution">distribution</code></td>
<td>
<p>Character (Default: &quot;Student_t&quot;). Distribution of innovation: &quot;Student_t&quot;  or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_meanstructure">meanstructure</code></td>
<td>
<p>Character (Default: &quot;constant&quot;). Defines model for means. Either 'constant'  or 'ARMA'. Currently ARMA(1,1) only. OR 'VAR' (VAR1).</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_sampling_algorithm">sampling_algorithm</code></td>
<td>
<p>Character (Default&quot; &quot;MCMC&quot;). Define sampling algorithm. Either 'MCMC'for Hamiltonian Monte Carlo or 'VB' for variational Bayes. 'VB' is inherited from stan and is currently in heavy development &ndash; do not trust estimates.</p>
</td></tr>
<tr><td><code id="bmgarch_+3A_...">...</code></td>
<td>
<p>Additional arguments can be ‘chain_id’, ‘init_r’, ‘test_grad’, ‘append_samples’, ‘refresh’, ‘enable_random_init’ etc. See the documentation in <code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four types of paramerizations are implemented. The constant conditional correlation (CCC) and the dynamic conditional correlation (DCC; Engle2002,Engle2001a), as well as  BEKK (Engle and Kroner 1995) and a BEKK model with positivity constraints on the diagonals of the ARCH and GARCH parameters &quot;pdBEKK&quot; (Rast et al. 2020).
</p>
<p>The fitted models are 'rstan' objects and all posterior parameter estimates can be obtained and can be examined with either the 'rstan' toolbox, plotted and printed using generic functions  or passed to 'bmgarch' functions to 'forecast' or compute 'model_weights' or compute fit statistics based on leave-future-out cross-validation.
</p>


<h3>Value</h3>

<p><code>bmgarch</code> object.
</p>


<h3>Author(s)</h3>

<p>Philippe Rast, Stephen R. Martin
</p>


<h3>References</h3>

<p>Engle RF, Kroner KF (1995).
&ldquo;Multivariate simultaneous generalized arch.&rdquo;
<em>Econometric Theory</em>, <b>11</b>(1), 122&ndash;150.
<a href="https://doi.org/10.1017/S0266466600009063">doi:10.1017/S0266466600009063</a>.<br /><br /> Rast P, Martin SR, Liu S, Williams DR (2020).
&ldquo;A New Frontier for Studying Within-Person Variability: Bayesian Multivariate Generalized Autoregressive Conditional Heteroskedasticity Models.&rdquo;
<em>Psychological Methods</em>.
<a href="https://psyarxiv.com/j57pk/">https://psyarxiv.com/j57pk/</a>.()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(panas)
# Fit BEKK(1,1) mgarch model with a ARMA(1,1) meanstructure,
# and student-t residual distribution
fit &lt;- bmgarch(panas, parameterization = "BEKK",
               P = 1, Q = 1,
               meanstructure = "arma",
               distribution = "Student_t")

# Summarize the parameters
summary(fit)

# Forecast 5 ahead
fit.fc &lt;- forecast(fit, ahead = 5)
print(fit.fc)

# Plot mean forecasts
plot(fit.fc, type = "mean")

# Plot variance forecasts
plot(fit.fc, type = "var")

# Plot correlation forecasts
plot(fit.fc, type = "cor")

# Plot modeled data ("backcasted values").
plot(fit, type = "mean")

# Save "backcasted" values
fit.bc &lt;- fitted(fit)

# Save estimated and forecasted data as a data.frame
df.fc &lt;- as.data.frame(fit.fc)

# Access rstan's model fit object
mf &lt;- fit$model_fit

# Return diagnostics and a plot of the first 10 parameters
rstan::check_hmc_diagnostics(mf)
rstan::plot(mf)

## End(Not run)
</code></pre>

<hr>
<h2 id='bmgarch_list'>Collect bmgarch objects into list.</h2><span id='topic+bmgarch_list'></span>

<h3>Description</h3>

<p>Collect bmgarch objects into list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmgarch_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmgarch_list_+3A_...">...</code></td>
<td>
<p>bmgarch objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of bmgarch objects. Class: bmgarch_list and bmgarch.
</p>

<hr>
<h2 id='fitted.bmgarch'>Fitted (backcasting) method for bmgarch objects.</h2><span id='topic+fitted.bmgarch'></span>

<h3>Description</h3>

<p>Extracts the model-predicted means, variances, and correlations for the fitted data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmgarch'
fitted(
  object,
  CrI = c(0.025, 0.975),
  digits = 2,
  weights = NULL,
  inc_samples = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.bmgarch_+3A_object">object</code></td>
<td>
<p>bmgarch object.</p>
</td></tr>
<tr><td><code id="fitted.bmgarch_+3A_cri">CrI</code></td>
<td>
<p>Numeric vector (Default: <code>c(.025, .975)</code>). Lower and upper bound of predictive credible interval.</p>
</td></tr>
<tr><td><code id="fitted.bmgarch_+3A_digits">digits</code></td>
<td>
<p>Integer (Default: 2, optional). Number of digits to round to when printing.</p>
</td></tr>
<tr><td><code id="fitted.bmgarch_+3A_weights">weights</code></td>
<td>
<p>Takes weights from model_weight function. Defaults to 1 &ndash; this parameter is not typically set by user.</p>
</td></tr>
<tr><td><code id="fitted.bmgarch_+3A_inc_samples">inc_samples</code></td>
<td>
<p>Logical (Default: FALSE). Whether to return the MCMC samples for the fitted values.</p>
</td></tr>
<tr><td><code id="fitted.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whereas <code><a href="#topic+forecast.bmgarch">forecast.bmgarch</a></code> computes the <em>forecasted</em> values for future time periods, <code>fitted.bmgarch</code> computes the <em>backcasted</em> (model-predicted) values for the observed time periods.
</p>


<h3>Value</h3>

<p>fitted.bmgarch object. List containing <code>meta</code>data and the <code>backcast</code>. Backcast is a list containing three elements:
</p>

<dl>
<dt>mean</dt><dd><p><code>[N, 7, TS]</code> array of mean backcasts, where N is the timeseries length, and TS is the number of time series. E.g., <code>bc$backcast$mean[3,,"tsA"]</code> is the mean backcast for the third observation in time series &quot;tsA&quot;.</p>
</dd>
<dt>var</dt><dd><p><code>[N, 7, TS]</code> array of variance backcasts, where N is the timeseries length, and TS is the number of time series. E.g., <code>bc$backcast$var[3,,"tsA"]</code> is the variance backcast for the third observation in time series &quot;tsA&quot;.</p>
</dd>
<dt>cor</dt><dd><p><code>[N, 7, TS(TS - 1)/2]</code> array of correlation backcasts, where N is the timeseries length, and <code>TS(TS - 1)/2</code> is the number of correlations. E.g., <code>bc$backcast$cor[3,, "tsB_tsA"]</code> is the backcast for the correlation between &quot;tsB&quot; and &quot;tsA&quot; on the third observation. Lower triangular correlations are saved.</p>
</dd>
<dt>samples</dt><dd><p>List</p>
</dd></dl>
<p>. If inc_samples is <code>TRUE</code>, then a list of arrays of MCMC samples for means, vars, and cors. Each array is [Iteration, Period, ..., ...].

</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(panas)
# Fit CCC(1,1) and constant meanstructure.
fit &lt;- bmgarch(panas, parameterization = "CCC", meanstructure = "constant")

# Obtain fitted values
fit.bc &lt;- fitted(fit)

# Print fitted values
print(fit.bc)

# Plot fitted values (plot.bmgarch calls fitted internally)
plot(fit, type = "var")

# Save fitted values as data frame
fit.bc.df &lt;- as.data.frame(fit.bc)

## End(Not run)
</code></pre>

<hr>
<h2 id='forecast.bmgarch'>Forecast method for bmgarch objects.</h2><span id='topic+forecast.bmgarch'></span><span id='topic+forecast'></span>

<h3>Description</h3>

<p>Estimates (weighted) forecasted means, variances, and correlations from a fitted bmgarch model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmgarch'
forecast(
  object,
  ahead = 1,
  xC = NULL,
  newdata = NULL,
  CrI = c(0.025, 0.975),
  seed = NA,
  digits = 2,
  weights = NULL,
  L = NA,
  method = "stacking",
  inc_samples = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.bmgarch_+3A_object">object</code></td>
<td>
<p>bmgarch object.</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_ahead">ahead</code></td>
<td>
<p>Integer (Default: 1). Periods to be forecasted ahead.</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_xc">xC</code></td>
<td>
<p>Numeric vector or matrix. Covariates(s) for the constant variance terms in C, or c. Used in a log-linear model on the constant variance terms. If vector, then it acts as a covariate for all constant variance terms. If matrix, must have columns equal to number of time series, and each column acts as a covariate for the respective time series (e.g., column 1 predicts constant variance for time series 1).</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_newdata">newdata</code></td>
<td>
<p>Future datapoints for LFO-CV computation</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_cri">CrI</code></td>
<td>
<p>Numeric vector (Default: <code>c(.025, .975)</code>). Lower and upper bound of predictive credible interval.</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_seed">seed</code></td>
<td>
<p>Integer (Optional). Specify seed for <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_digits">digits</code></td>
<td>
<p>Integer (Default: 2, optional). Number of digits to round to when printing.</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_weights">weights</code></td>
<td>
<p>Takes weights from model_weight function. Defaults to 1 &ndash; this parameter is not typically set by user.</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_l">L</code></td>
<td>
<p>Minimal length of time series before engaging in lfocv</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_method">method</code></td>
<td>
<p>Ensemble methods, 'stacking' (default) or 'pseudobma'</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_inc_samples">inc_samples</code></td>
<td>
<p>Logical (Default: FALSE). Whether to return the MCMC samples for the fitted values.</p>
</td></tr>
<tr><td><code id="forecast.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>forecast.bmgarch object. List containing <code>forecast</code>, <code>backcast</code>, and <code>meta</code>data.
See <code><a href="#topic+fitted.bmgarch">fitted.bmgarch</a></code> for information on <code>backcast</code>.
<code>forecast</code> is a list of four components:
</p>

<dl>
<dt>mean</dt><dd><p><code>[N, 7, TS]</code> array of mean forecasts, where N is the timeseries length, and TS is the number of time series. E.g., <code>fc$forecast$mean[3,,"tsA"]</code> is the 3-ahead mean forecast for time series &quot;tsA&quot;.</p>
</dd>
<dt>var</dt><dd><p><code>[N, 7, TS]</code> array of variance forecasts, where N is the timeseries length, and TS is the number of time series. E.g., <code>fc$forecast$var[3,,"tsA"]</code> is the 3-ahead variance forecast for time series &quot;tsA&quot;.</p>
</dd>
<dt>cor</dt><dd><p><code>[N, 7, TS(TS - 1)/2]</code> array of correlation forecasts, where N is the timeseries length, and <code>TS(TS - 1)/2</code> is the number of correlations. E.g., <code>fc$forecast$cor[3,, "tsB_tsA"]</code> is the 3-ahead forecast for the correlation between &quot;tsB&quot; and &quot;tsA&quot;. Lower triangular correlations are saved.</p>
</dd>
<dt>meta</dt><dd><p>Meta-data specific to the forecast. I.e., TS_length (number ahead) and xC.</p>
</dd>
<dt>samples</dt><dd><p>List</p>
</dd></dl>
<p>. If inc_samples is <code>TRUE</code>, then a list of arrays of MCMC samples for means, vars, and cors. Each array is [Iteration, Period, ..., ...].

</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(panas)
# Fit DCC(2,2) with constant mean structure.
fit &lt;- bmgarch(panas, parameterization = "DCC", P = 2, Q = 2, meanstructure = "constant")

# Forecast 8 ahead
fit.fc &lt;- forecast(fit, ahead = 8)

# Print forecasts
fit.fc
print(fit.fc)

# Plot variance forecasts
plot(fit.fc, type = "var")

# Plot correlation forecasts
plot(fit.fc, type = "cor")

# Save backcasted and forecasted values as data frame.
fit.fc.df &lt;- as.data.frame(fit.fc)

# Save only forecasted values as data frame.
fit.fc.df &lt;- as.data.frame(fit.fc, backcast = FALSE)

# Add another model, compute model weights and perform a model weighted forecast

# Fit a DCC(1,1) model
fit1 &lt;- bmgarch(panas, parameterization = "DCC", P = 1, Q = 1, meanstructure = "constant")

# Compute model stacking weights based on the last 19 time points (with L = 80)
blist &lt;- bmgarch_list( fit1, fit )
mw &lt;- model_weights(blist, L = 80)

# Weighted forecasts:
w.fc &lt;- forecast(object = blist, ahead = 8, weights = mw)

## End(Not run)
</code></pre>

<hr>
<h2 id='loo.bmgarch'>Leave-Future-Out Cross Validation (LFO-CV)</h2><span id='topic+loo.bmgarch'></span><span id='topic+loo'></span>

<h3>Description</h3>

<p><code>lfocv</code> returns the LFO-CV ELPD by either computing the exact ELDP or
by approximating it via
forward or backward approximation strategies based on Pareto smoothed
importance sampling
described in (Bürkner et al. 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmgarch'
loo(x, ..., type = "lfo", L = NULL, M = 1, mode = "backward")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.bmgarch_+3A_x">x</code></td>
<td>
<p>Fitted bmgarch model. <code>lfocv</code> inherits all attributes
from the bmgarch object</p>
</td></tr>
<tr><td><code id="loo.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="loo.bmgarch_+3A_type">type</code></td>
<td>
<p>Takes <code>lfo</code> (default) or <code>loo</code>. LFO-CV is recommended
for time-series but LOO-CV may be obtained to assess the structural part of the model.</p>
</td></tr>
<tr><td><code id="loo.bmgarch_+3A_l">L</code></td>
<td>
<p>Minimal length of times series before computing LFO</p>
</td></tr>
<tr><td><code id="loo.bmgarch_+3A_m">M</code></td>
<td>
<p>M step head predictions. Defines to what period the LFO-CV should be tuned to. Defaults to M=1.</p>
</td></tr>
<tr><td><code id="loo.bmgarch_+3A_mode">mode</code></td>
<td>
<p>backward elpd_lfo approximation, or exact elpd-lfo; 
Takes 'backward', and 'exact'. 'exact' fits N-L models and may
take a <em>very</em> long time to complete. <code>forward</code> works too but is not
complete yet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Approximate LFO-CV value and log-likelihood values across (L+1):N
timepoints
</p>


<h3>References</h3>

<p>Bürkner P, Gabry J, Vehtari A (2020).
&ldquo;Approximate leave-future-out cross-validation for Bayesian time series models.&rdquo;
<em>Journal of Statistical Computation and Simulation</em>, 1&ndash;25.
<a href="https://doi.org/10.1080/00949655.2020.1783262">doi:10.1080/00949655.2020.1783262</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(stocks)
# Fit a DCC model 
fit &lt;- bmgarch(data = stocks[1:100, c("toyota",  "nissan" )],
               parameterization = "DCC", standardize_data = TRUE,
               iterations = 500)

# Compute expected log-predictive density (elpd) using the backward mode
# L is the upper boundary of the time-series before we engage in LFO-CV
lfob &lt;- loo(fit, mode = 'backward',  L = 50 )
print(lfob)

## End(Not run)
</code></pre>

<hr>
<h2 id='model_weights'>Model weights</h2><span id='topic+model_weights'></span>

<h3>Description</h3>

<p>Compute model weights for a list of candidate models based on leave-future-out
cross validation (lfocv) expected log-predictive density (elpd).
elpd can be approximated via the 'backward' mode described in Bürkner et al. (2020) or via exact cross-validation.    
The obtained weights can be passed to the forecast function to obtain weighted forecasts.
<code>bmgarch_objects</code> takes a <code>bmgarch_object</code> lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_weights(
  bmgarch_objects = NULL,
  L = NULL,
  M = 1,
  method = "stacking",
  mode = "backward"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_weights_+3A_bmgarch_objects">bmgarch_objects</code></td>
<td>
<p>list of bmgarch model objects in <code>bmgarch_object</code></p>
</td></tr>
<tr><td><code id="model_weights_+3A_l">L</code></td>
<td>
<p>Minimal length of time series before engaging in lfocv</p>
</td></tr>
<tr><td><code id="model_weights_+3A_m">M</code></td>
<td>
<p>M step head predictions. Defines to what period the LFO-CV should be tuned to. Defaults to M=1.</p>
</td></tr>
<tr><td><code id="model_weights_+3A_method">method</code></td>
<td>
<p>Ensemble methods, 'stacking' (default) or 'pseudobma'</p>
</td></tr>
<tr><td><code id="model_weights_+3A_mode">mode</code></td>
<td>
<p>Either 'backward' (default) or 'exact'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;model_weights()' is a wrapper around the leave-future-out &rsquo;lfo' type in 'loo.bmgarch()'.
The weights can be either obtained from an approximate or exact leave-future-out cross-validation
to compute expected log predictive density (ELPD).
</p>
<p>We can either obtain stacking weights or pseudo-BMA+ weigths as described in (Yao et al. 2018).
</p>


<h3>Value</h3>

<p>Model weights
</p>


<h3>References</h3>

<p>Bürkner P, Gabry J, Vehtari A (2020).
&ldquo;Approximate leave-future-out cross-validation for Bayesian time series models.&rdquo;
<em>Journal of Statistical Computation and Simulation</em>, 1&ndash;25.
<a href="https://doi.org/10.1080/00949655.2020.1783262">doi:10.1080/00949655.2020.1783262</a>.<br /><br /> Yao Y, Vehtari A, Simpson D, Gelman A (2018).
&ldquo;Using Stacking to Average Bayesian Predictive Distributions.&rdquo;
<em>Bayesian Analysis</em>, <b>13</b>(3), 917&ndash;1007.
<a href="https://doi.org/10.1214/17-BA1091">doi:10.1214/17-BA1091</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(stocks)
# Fit at least two models on a subset of the stocks data
# to compute model weights
fit &lt;- bmgarch(data = stocks[1:100, c("toyota",  "nissan" )],
               parameterization = "DCC", standardize_data = TRUE,
               iterations = 500)

fit2 &lt;- bmgarch(data = stocks[1:100, c("toyota",  "nissan" )],
                P = 2, Q =  2,
               parameterization = "DCC", standardize_data = TRUE,
               iterations = 500)
# create a bmgarch_list object
blist &lt;- bmgarch_list(fit, fit2 )

# Compute model weights with the default stacking metod
# L is the upper boundary of the time-series before we engage in LFO-CV
mw &lt;- model_weights( blist, L =  50, method = 'stacking', order = 'backwards' )

# Print model weights in the ordert of the bmgarch_list()
print(mw)

## End(Not run)
</code></pre>

<hr>
<h2 id='panas'>Positive and Negative Affect Scores.</h2><span id='topic+panas'></span>

<h3>Description</h3>

<p>A dataset containing simulated values for Positive and Negative Affect scores across 200 measurement occasions for a single individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panas
</code></pre>


<h3>Format</h3>

<p>Data frame with 200 rows and 2 variables:
</p>

<dl>
<dt>Pos</dt><dd><p>Positive Affect score</p>
</dd>
<dt>Neg</dt><dd><p>Negative Affect score</p>
</dd>
</dl>


<hr>
<h2 id='plot.bmgarch'>Plot method for bmgarch objects.</h2><span id='topic+plot.bmgarch'></span>

<h3>Description</h3>

<p>Plot method for bmgarch objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmgarch'
plot(x, type = "mean", askNewPage = TRUE, CrI = c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bmgarch_+3A_x">x</code></td>
<td>
<p>bmgarch object.</p>
</td></tr>
<tr><td><code id="plot.bmgarch_+3A_type">type</code></td>
<td>
<p>String (Default: &quot;mean&quot;). Whether to plot conditional means (&quot;mean&quot;), variance (&quot;var&quot;), or correlations (&quot;cor&quot;).</p>
</td></tr>
<tr><td><code id="plot.bmgarch_+3A_asknewpage">askNewPage</code></td>
<td>
<p>askNewPage Logical (Default: True). Whether to ask for new plotting page.</p>
</td></tr>
<tr><td><code id="plot.bmgarch_+3A_cri">CrI</code></td>
<td>
<p>CrI Numeric vector (Default: <code>c(.025, .975)</code>). Lower and upper bound of predictive credible interval.</p>
</td></tr>
<tr><td><code id="plot.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of ggplot objects (one per time series).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='plot.forecast.bmgarch'>Plot method for forecast.bmgarch objects.</h2><span id='topic+plot.forecast.bmgarch'></span>

<h3>Description</h3>

<p>Plot method for forecast.bmgarch objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecast.bmgarch'
plot(x, type = "mean", askNewPage = TRUE, last_t = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.forecast.bmgarch_+3A_x">x</code></td>
<td>
<p>forecast.bmgarch object. See <code><a href="#topic+forecast.bmgarch">forecast.bmgarch</a></code>.</p>
</td></tr>
<tr><td><code id="plot.forecast.bmgarch_+3A_type">type</code></td>
<td>
<p>String (Default: &quot;mean&quot;). Whether to plot conditional means (&quot;mean&quot;), variance (&quot;var&quot;), or correlations (&quot;cor&quot;).</p>
</td></tr>
<tr><td><code id="plot.forecast.bmgarch_+3A_asknewpage">askNewPage</code></td>
<td>
<p>Logical (Default: True). Whether to ask for new plotting page.</p>
</td></tr>
<tr><td><code id="plot.forecast.bmgarch_+3A_last_t">last_t</code></td>
<td>
<p>Integer (Default: 100). Only show <code>last_t</code> observations in plot.</p>
</td></tr>
<tr><td><code id="plot.forecast.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of ggplot objects (one per time series).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='print.fitted.bmgarch'>Print method for fitted.bmgarch objects.</h2><span id='topic+print.fitted.bmgarch'></span>

<h3>Description</h3>

<p>Print method for fitted.bmgarch objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted.bmgarch'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fitted.bmgarch_+3A_x">x</code></td>
<td>
<p>fitted.bmgarch object.</p>
</td></tr>
<tr><td><code id="print.fitted.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object (invisible).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='print.forecast.bmgarch'>Print method for forecast.bmgarch objects.</h2><span id='topic+print.forecast.bmgarch'></span>

<h3>Description</h3>

<p>Print method for forecast.bmgarch objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecast.bmgarch'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.forecast.bmgarch_+3A_x">x</code></td>
<td>
<p>forecast.bmgarch object. See <code><a href="#topic+forecast.bmgarch">forecast.bmgarch</a></code></p>
</td></tr>
<tr><td><code id="print.forecast.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x (invisible).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='print.loo.bmgarch'>print method for lfocv</h2><span id='topic+print.loo.bmgarch'></span>

<h3>Description</h3>

<p>print method for lfocv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loo.bmgarch'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.loo.bmgarch_+3A_x">x</code></td>
<td>
<p>lfo object</p>
</td></tr>
<tr><td><code id="print.loo.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible lfocv object
</p>


<h3>Author(s)</h3>

<p>philippe
</p>

<hr>
<h2 id='print.model_weights'>Print method for model_weights</h2><span id='topic+print.model_weights'></span>

<h3>Description</h3>

<p>Print method for model_weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model_weights'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.model_weights_+3A_x">x</code></td>
<td>
<p>Model weights object</p>
</td></tr>
<tr><td><code id="print.model_weights_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model_weights objects with weights, list of log-likelihoods, and r_eff_list
</p>


<h3>Author(s)</h3>

<p>philippe
</p>

<hr>
<h2 id='print.summary.bmgarch'>Print method for bmgarch.summary objects.</h2><span id='topic+print.summary.bmgarch'></span>

<h3>Description</h3>

<p>Print method for bmgarch.summary objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.bmgarch'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.bmgarch_+3A_x">x</code></td>
<td>
<p>summary.bmgarch object.</p>
</td></tr>
<tr><td><code id="print.summary.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x (invisible).
</p>


<h3>Author(s)</h3>

<p>Philippe Rast, Stephen R. Martin
</p>

<hr>
<h2 id='standat'>Standardize input data to facilitate computation</h2><span id='topic+standat'></span>

<h3>Description</h3>

<p>Standardize input data to facilitate computation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standat(data, xC, P, Q, standardize_data, distribution, meanstructure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standat_+3A_data">data</code></td>
<td>
<p>Time-series data</p>
</td></tr>
<tr><td><code id="standat_+3A_xc">xC</code></td>
<td>
<p>Numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="standat_+3A_p">P</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="standat_+3A_q">Q</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="standat_+3A_standardize_data">standardize_data</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="standat_+3A_distribution">distribution</code></td>
<td>
<p>Character.</p>
</td></tr>
<tr><td><code id="standat_+3A_meanstructure">meanstructure</code></td>
<td>
<p>Character.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bmgarch stan data list.
</p>

<hr>
<h2 id='stocks'>Daily data on returns of Toyota, Nissan, and Honda stocks.</h2><span id='topic+stocks'></span>

<h3>Description</h3>

<p>A dataset used by Stata to illustrate MGARCH models containing daily data on returns of Toyota, Nissan, and Honda stocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stocks
</code></pre>


<h3>Format</h3>

<p>Data frame with 2015 rows and 5 variables:
</p>

<dl>
<dt>date</dt><dd><p>Date</p>
</dd>
<dt>t</dt><dd><p>Sequential time index</p>
</dd>
<dt>toyota</dt><dd><p>Daily returns for Toyota stock</p>
</dd>
<dt>nissan</dt><dd><p>Daily returns for Nissan stock</p>
</dd>
<dt>honda</dt><dd><p>Daily returns for Honda stock</p>
</dd>
</dl>


<hr>
<h2 id='summary.bmgarch'>Summary method for bmgarch objects.</h2><span id='topic+summary.bmgarch'></span>

<h3>Description</h3>

<p>Computes posterior summaries for all parameters of interest for bmgarch objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmgarch'
summary(object, CrI = c(0.025, 0.975), digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bmgarch_+3A_object">object</code></td>
<td>
<p>bmgarch object.</p>
</td></tr>
<tr><td><code id="summary.bmgarch_+3A_cri">CrI</code></td>
<td>
<p>Numeric vector (Default: <code>c(.025, .975)</code>). Lower and upper bound of predictive credible interval.</p>
</td></tr>
<tr><td><code id="summary.bmgarch_+3A_digits">digits</code></td>
<td>
<p>Integer (Default: 2, optional). Number of digits to round to when printing.</p>
</td></tr>
<tr><td><code id="summary.bmgarch_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary.bmgarch object. A named list containing &quot;meta&quot; and &quot;model_summary&quot;. <code>model_summary</code> contains summary table for all model parameters.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin, Philippe Rast
</p>

<hr>
<h2 id='supported_models'>Models supported by bmgarch</h2><span id='topic+supported_models'></span>

<h3>Description</h3>

<p>To be used when checking whether a parameterization or object type is a supported type.
May facilitate more parameterizations, as we only have to update these, and the switch statements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supported_models
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 4.
</p>


<h3>Author(s)</h3>

<p>Philippe Rast and Stephen R. Martin
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
