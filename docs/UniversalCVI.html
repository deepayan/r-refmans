<!DOCTYPE html><html><head><title>Help for package UniversalCVI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {UniversalCVI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AccClust'><p>Accuracy detection for a clustering result with known classes</p></a></li>
<li><a href='#CCV.IDX'><p>Correlation Cluster Validity (CCV) index</p></a></li>
<li><a href='#CH.IDX'>
<p>Calinski–Harabasz (CH) index</p></a></li>
<li><a href='#CSL.IDX'>
<p>Chou-Su-Lai (CSL) index</p></a></li>
<li><a href='#D1_data'><p>D1 Artificial Dataset</p></a></li>
<li><a href='#D10_data'><p>D10 Artificial Dataset</p></a></li>
<li><a href='#D2_data'><p>D2 Artificial Dataset</p></a></li>
<li><a href='#D3_data'><p>D3 Artificial Dataset</p></a></li>
<li><a href='#D4_data'><p>D4 Artificial Dataset</p></a></li>
<li><a href='#D5_data'><p>D5 Artificial Dataset</p></a></li>
<li><a href='#D6_data'><p>D6 Artificial Dataset</p></a></li>
<li><a href='#D7_data'><p>D7 Artificial Dataset</p></a></li>
<li><a href='#D8_data'><p>D8 Artificial Dataset</p></a></li>
<li><a href='#D9_data'><p>D9 Artificial Dataset</p></a></li>
<li><a href='#DB.IDX'>
<p>Davies–Bouldin (DB) and DB* (DBs) indexes</p></a></li>
<li><a href='#DI.IDX'>
<p>Dunn index</p></a></li>
<li><a href='#FzzyCVIs'>
<p>Fuzzy cluster validity indexes used in Wiroonsri and Preedasawakul (2023)</p></a></li>
<li><a href='#GC.IDX'><p>The generalized C index</p></a></li>
<li><a href='#HF.IDX'>
<p>HF index</p></a></li>
<li><a href='#Hvalid'>
<p>Wiroonsri(2024) correlation-based cluster validity indices and other well-known cluster validity indices</p></a></li>
<li><a href='#KPBM.IDX'>
<p>Modified Kernel form of Pakhira-Bandyopadhyay-Maulik (KPBM) index</p></a></li>
<li><a href='#KWON.IDX'>
<p>KWON index</p></a></li>
<li><a href='#KWON2.IDX'>
<p>KWON2 index</p></a></li>
<li><a href='#PB.IDX'>
<p>Point biserial correlation (PB)</p></a></li>
<li><a href='#PBM.IDX'>
<p>Pakhira-Bandyopadhyay-Maulik (PBM) index</p></a></li>
<li><a href='#plot_idx'>
<p>Plots for visualizing CVIs</p></a></li>
<li><a href='#R1_data'><p>R1 Artificial Dataset</p></a></li>
<li><a href='#R2_data'><p>R2 Artificial Dataset</p></a></li>
<li><a href='#R3_data'><p>R3 Artificial Dataset</p></a></li>
<li><a href='#R4_data'><p>R4 Artificial Dataset</p></a></li>
<li><a href='#R5_data'><p>R5 Artificial Dataset</p></a></li>
<li><a href='#R6_data'><p>R6 Artificial Dataset</p></a></li>
<li><a href='#R7_data'><p>R7 Artificial Dataset</p></a></li>
<li><a href='#SF.IDX'><p>The score function</p></a></li>
<li><a href='#STRPBM.IDX'>
<p>Starczewski and Pakhira-Bandyopadhyay-Maulik for crisp clustering indexes</p></a></li>
<li><a href='#TANG.IDX'>
<p>Tang index</p></a></li>
<li><a href='#WL.IDX'>
<p>Wu and Li (WL) index</p></a></li>
<li><a href='#WP.IDX'>
<p>Wiroonsri and Preedasawakul (WP) index</p>
</p></a></li>
<li><a href='#Wvalid'>
<p>Wiroonsri(2024) correlation-based cluster validity indices</p></a></li>
<li><a href='#XB.IDX'><p>Xie and Beni (XB) index</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hard and Soft Cluster Validity Indices</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>e1071, mclust</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for checking the accuracy of a clustering result with known classes, computing cluster validity indices, and generating plots for comparing them.
    The package is compatible with K-means, fuzzy C means, EM clustering, and hierarchical clustering (single, average, and complete linkage).
    The details of the indices in this package can be found in:
    C. Alok. (2010) <a href="https://hdl.handle.net/10603/93443">https://hdl.handle.net/10603/93443</a>,
    J. C. Bezdek, M. Moshtaghi, T. Runkler, C. Leckie (2016) &lt;<a href="https://doi.org/10.1109%2FTFUZZ.2016.2540063">doi:10.1109/TFUZZ.2016.2540063</a>&gt;,
    T. Calinski, J. Harabasz (1974) &lt;<a href="https://doi.org/10.1080%2F03610927408827101">doi:10.1080/03610927408827101</a>&gt;,
    C. H. Chou, M. C. Su, E. Lai (2004) &lt;<a href="https://doi.org/10.1007%2Fs10044-004-0218-1">doi:10.1007/s10044-004-0218-1</a>&gt;,
    D. L. Davies, D. W. Bouldin (1979) &lt;<a href="https://doi.org/10.1109%2FTPAMI.1979.4766909">doi:10.1109/TPAMI.1979.4766909</a>&gt;,
    J. C. Dunn (1973) &lt;<a href="https://doi.org/10.1080%2F01969727308546046">doi:10.1080/01969727308546046</a>&gt;,
    F. Haouas, Z. Ben Dhiaf, A. Hammouda, B. Solaiman (2017) &lt;<a href="https://doi.org/10.1109%2FFUZZ-IEEE.2017.8015651">doi:10.1109/FUZZ-IEEE.2017.8015651</a>&gt;,
    M. Kim, R. S. Ramakrishna (2005) &lt;<a href="https://doi.org/10.1016%2Fj.patrec.2005.04.007">doi:10.1016/j.patrec.2005.04.007</a>&gt;,
    S. H. Kwon (1998) &lt;<a href="https://doi.org/10.1049%2FEL%3A19981523">doi:10.1049/EL:19981523</a>&gt;,
    S. H. Kwon, J. Kim, S. H. Son (2021) &lt;<a href="https://doi.org/10.1049%2Fell2.12249">doi:10.1049/ell2.12249</a>&gt;,
    G. W. Miligan (1980) &lt;<a href="https://doi.org/10.1007%2FBF02293907">doi:10.1007/BF02293907</a>&gt;,
    M. K. Pakhira, S. Bandyopadhyay, U. Maulik (2004) &lt;<a href="https://doi.org/10.1016%2Fj.patcog.2003.06.005">doi:10.1016/j.patcog.2003.06.005</a>&gt;,
    M. Popescu, J. C. Bezdek, T. C. Havens, J. M. Keller (2013) &lt;<a href="https://doi.org/10.1109%2FTSMCB.2012.2205679">doi:10.1109/TSMCB.2012.2205679</a>&gt;,
    S. Saitta, B. Raphael, I. Smith (2007) &lt;<a href="https://doi.org/10.1007%2F978-3-540-73499-4_14">doi:10.1007/978-3-540-73499-4_14</a>&gt;,
    A. Starczewski (2017) &lt;<a href="https://doi.org/10.1007%2Fs10044-015-0525-8">doi:10.1007/s10044-015-0525-8</a>&gt;,
    Y. Tang, F. Sun, Z. Sun (2005) &lt;<a href="https://doi.org/10.1109%2FACC.2005.1470111">doi:10.1109/ACC.2005.1470111</a>&gt;,
    N. Wiroonsri (2024) &lt;<a href="https://doi.org/10.1016%2Fj.patcog.2023.109910">doi:10.1016/j.patcog.2023.109910</a>&gt;,
    N. Wiroonsri, O. Preedasawakul (2023) &lt;<a href="https://arxiv.org/abs/2308.14785">arXiv:2308.14785</a>&gt;,
    C. H. Wu, C. S. Ouyang, L. W. Chen, L. W. Lu (2015) &lt;<a href="https://doi.org/10.1109%2FTFUZZ.2014.2322495">doi:10.1109/TFUZZ.2014.2322495</a>&gt; and
    X. Xie, G. Beni (1991) &lt;<a href="https://doi.org/10.1109%2F34.85677">doi:10.1109/34.85677</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 13:29:22 UTC; lenovo</td>
</tr>
<tr>
<td>Author:</td>
<td>Nathakhun Wiroonsri
    <a href="https://orcid.org/0000-0003-2167-9641"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Onthada Preedasawakul
    <a href="https://orcid.org/0000-0002-4186-3158"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathakhun Wiroonsri &lt;nathakhun.wir@kmutt.ac.th&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 13:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='AccClust'>Accuracy detection for a clustering result with known classes
</h2><span id='topic+AccClust'></span>

<h3>Description</h3>

<p>Computes the accuracy of a clustering result of a dataset with known classes from the k-means, fuzzy c-means, or EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AccClust(x, label.names = "label", algorithm = "FCM", fzm = 2,
  scale = TRUE, nstart = 100, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AccClust_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="AccClust_+3A_label.names">label.names</code></td>
<td>
<p>a character string indicating the true label column name. The default is <code>"label"</code>
</p>
</td></tr>
<tr><td><code id="AccClust_+3A_algorithm">algorithm</code></td>
<td>
<p>a character string indicating which clustering methods to be used (<code>"FCM"</code>, <code>"EM"</code>, <code>"Kmeans"</code>). More than one methods may be selected. The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="AccClust_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="AccClust_+3A_scale">scale</code></td>
<td>
<p>logical, if <code>TRUE</code> (default), the dataset is normalized before clustering.</p>
</td></tr>
<tr><td><code id="AccClust_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM" or "Kmeans" or c("Kmeans","FCM")</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="AccClust_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>kmeans</code></td>
<td>
<p>Accuracy score from <code>0</code> to <code>1</code> of the k-means result</p>
</td></tr>
<tr><td><code>FCM</code></td>
<td>
<p>Accuracy score from <code>0</code> to <code>1</code> of the FCM result</p>
</td></tr>
<tr><td><code>EM</code></td>
<td>
<p>Accuracy score from <code>0</code> to <code>1</code> of the EM result</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+D1_data">D1_data</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+XB.IDX">XB.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data

# Check accuracy of clustering results obtained by kmeans, FCM, and EM clustering
AccClust(x, label.names = "label",algorithm = c("Kmeans","FCM","EM"), fzm = 2,
  scale = TRUE, nstart = 20,iter = 100)

# Check accuracy of a clustering result obtained by the FCM algoritm
AccClust(x, label.names = "label",algorithm = "FCM", fzm = 2,
  scale = TRUE, nstart = 20,iter = 100)
</code></pre>

<hr>
<h2 id='CCV.IDX'>Correlation Cluster Validity (CCV) index
</h2><span id='topic+CCV.IDX'></span>

<h3>Description</h3>

<p>Computes the CCVP and CCVS (M. Popescu et al., 2013) indexes for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCV.IDX(x, cmax, cmin = 2, indexlist = "all", method = 'FCM', fzm = 2,
  iter = 100, nstart = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCV.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="CCV.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="CCV.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="CCV.IDX_+3A_indexlist">indexlist</code></td>
<td>
<p>a character string indicating which The generalized C index be computed (&quot;<code>all</code>&quot;,&quot;<code>CCVP</code>&quot;,&quot;<code>CCVS</code>&quot;). More than one indexes can be selected.
</p>
</td></tr>
<tr><td><code id="CCV.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="CCV.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="CCV.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="CCV.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A new cluster validity framework that compares the structure in the data to the structure of dissimilarity matrices induced by a matrix transformation of the partition being tested.  The largest value of <code class="reqn">CCV(c)</code> indicates a valid optimal partition.
</p>


<h3>Value</h3>

<p>Each of the followings shows the values of each index for <code>c</code> from <code>cmin</code> to <code>cmax</code> in a data frame.
</p>
<table>
<tr><td><code>CCVP</code></td>
<td>
<p>the Pearson Correlation Cluster Validity index.</p>
</td></tr>
<tr><td><code>CCVS</code></td>
<td>
<p>the Spearman’s (rho) Correlation Cluster Validity index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>M. Popescu, J. C. Bezdek, T. C. Havens and J. M. Keller (2013). &quot;A Cluster Validity Framework Based on Induced Partition Dissimilarity.&quot; <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6246717&amp;isnumber=6340245">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6246717&amp;isnumber=6340245</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# Iris data
x = iris[,1:4]

# ---- FCM algorithm ----


# Compute all the indices by CCV.IDX
FCM.ALL.CCV = CCV.IDX(scale(x), cmax = 10, cmin = 2, indexlist = "all",
  method =  'FCM', fzm = 2, iter = 100, nstart = 20)
print(FCM.ALL.CCV)

# Compute CCVP index
FCM.CCVP = CCV.IDX(scale(x), cmax = 10, cmin = 2, indexlist = "CCVP",
  method =  'FCM', fzm = 2, iter = 100, nstart = 20)
print(FCM.CCVP)


# ---- EM algorithm ----

# Compute all the indices by CCV.IDX
EM.ALL.CCV = CCV.IDX(scale(x), cmax = 10, cmin = 2, indexlist = "all",
  method =  'EM', iter = 100, nstart = 20)
print(EM.ALL.CCV)

# Compute CCVP index
EM.CCVP = CCV.IDX(scale(x), cmax = 10, cmin = 2, indexlist = "CCVP",
  method =  'EM', iter = 100, nstart = 20)
print(EM.CCVP)
</code></pre>

<hr>
<h2 id='CH.IDX'>
Calinski–Harabasz (CH) index
</h2><span id='topic+CH.IDX'></span>

<h3>Description</h3>

<p>Computes the CH (T. Calinski and J. Harabasz, 1974) index for a result either kmeans or hierarchical clustering from user specified <code>kmin</code> to <code>kmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CH.IDX(x, kmax, kmin = 2, method = "kmeans", nstart = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CH.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="CH.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="CH.IDX_+3A_kmin">kmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="CH.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="CH.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CH index is defined as <br />
</p>
<p style="text-align: center;"><code class="reqn">CH(k) = \frac{n-k}{k-1}\frac{\sum_{i=1}^k|C|_id(v_i,\bar{x})}{\sum_{i=1}^k\sum_{x_j\in C_i}d(x_j,v_i)}</code>
</p>

<p>The largest value of <code class="reqn">CH(k)</code> indicates a valid optimal partition.
</p>


<h3>Value</h3>

<table>
<tr><td><code>CH</code></td>
<td>
<p>the CH index for <code>k</code> from <code>kmin</code> to <code>kmax</code> shown in a data frame where the first and the second columns are <code>k</code> and the CH index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>T. Calinski, J. Harabasz, &quot;A dendrite method for cluster analysis,&quot; <em>Communications in Statistics</em>, 3, 1-27 (1974).</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+Wvalid">Wvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+R1_data">R1_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- Kmeans ----

# Compute the CH index
K.CH = CH.IDX(scale(x), kmax = 15, kmin = 2, method = "kmeans", nstart = 100)
print(K.CH)

# The optimal number of cluster
K.CH[which.max(K.CH$CH),]

# ---- Hierarchical ----

# Average linkage

# Compute the CH index
H.CH = CH.IDX(scale(x), kmax = 15, kmin = 2, method = "hclust_average")
print(H.CH)

# The optimal number of cluster
H.CH[which.max(H.CH$CH),]
</code></pre>

<hr>
<h2 id='CSL.IDX'>
Chou-Su-Lai (CSL) index
</h2><span id='topic+CSL.IDX'></span>

<h3>Description</h3>

<p>Computes the CSL (C. H. Chou et al., 2004) index for a result either kmeans or hierarchical clustering from user specified <code>kmin</code> to <code>kmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSL.IDX(x, kmax, kmin = 2, method = "kmeans", nstart = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSL.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="CSL.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="CSL.IDX_+3A_kmin">kmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="CSL.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="CSL.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CSL index is defined as <br />
</p>
<p style="text-align: center;"><code class="reqn">CSL(k) = \frac{\sum_{i=1}^k \left\{\frac{1}{|C_i|}\sum_{x_j \in C_i} \max_{x_l \in C_i} d(x_j,x_l)\right\}}{\sum_{i=1}^k \left\{\min_{j:j \ne i}d(v_i,v_j)\right\}}.
   </code>
</p>

<p>The smallest value of <code class="reqn">CSL(k)</code> indicates a valid optimal partition.
</p>


<h3>Value</h3>

<table>
<tr><td><code>CSL</code></td>
<td>
<p>the CSL index for <code>k</code> from <code>kmin</code> to <code>kmax</code> shown in a data frame where the first and the second columns are <code>k</code> and the CSL index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>C. H. Chou, M. C. Su, E. Lai, &quot;A new cluster validity measure and its application to image compression,&quot; <em>Pattern Anal Applic</em>, 7, 205-220 (2004).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+Wvalid">Wvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+R1_data">R1_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- Kmeans ----

# Compute the CSL index
K.CSL = CSL.IDX(scale(x), kmax = 15, kmin = 2, method = "kmeans", nstart = 100)
print(K.CSL)

# The optimal number of cluster
K.CSL[which.min(K.CSL$CSL),]

# ---- Hierarchical ----

# Average linkage

# Compute the CSL index
H.CSL = CSL.IDX(scale(x), kmax = 15, kmin = 2, method = "hclust_average")
print(H.CSL)

# The optimal number of cluster
H.CSL[which.min(H.CSL$CSL),]
</code></pre>

<hr>
<h2 id='D1_data'>D1 Artificial Dataset</h2><span id='topic+D1_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>6</code> different Gaussian distributions labeled as <code>1-6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D1_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1500 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5,6</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='D10_data'>D10 Artificial Dataset</h2><span id='topic+D10_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>3</code> different Gaussian and <code>2</code> Uniform distributions labeled as <code>1-5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D10_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1250 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='D2_data'>D2 Artificial Dataset</h2><span id='topic+D2_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>6</code> different Gaussian distributions labeled as <code>1-6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D2_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1200 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5,6</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='D3_data'>D3 Artificial Dataset</h2><span id='topic+D3_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>4</code> different Gaussian distributions labeled as <code>1-4</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D3_data
</code></pre>


<h3>Format</h3>

<p>A <code>data frame</code> with 1400 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='D4_data'>D4 Artificial Dataset</h2><span id='topic+D4_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>4</code> different Gaussian distributions labeled as <code>1-4</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D4_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 2400 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='D5_data'>D5 Artificial Dataset</h2><span id='topic+D5_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>5</code> different Gaussian distributions labeled as <code>1-5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D5_data
</code></pre>


<h3>Format</h3>

<p>A <code>data frame</code> with 350 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='D6_data'>D6 Artificial Dataset</h2><span id='topic+D6_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>5</code> different Gaussian distributions labeled as <code>1-5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D6_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1100 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='D7_data'>D7 Artificial Dataset</h2><span id='topic+D7_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>6</code> different Gaussian distributions labeled as <code>1-6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D7_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1500 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5,6</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='D8_data'>D8 Artificial Dataset</h2><span id='topic+D8_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>6</code> different Gaussian distributions labeled as <code>1-6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D8_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5,6</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='D9_data'>D9 Artificial Dataset</h2><span id='topic+D9_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>3</code> different Uniform distributions labeled as <code>1-3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D9_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Uniform distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Uniform distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='DB.IDX'>
Davies–Bouldin (DB) and DB* (DBs) indexes
</h2><span id='topic+DB.IDX'></span>

<h3>Description</h3>

<p>Computes the DB (D. L. Davies and D. W. Bouldin, 1979) and DBs (M. Kim and R. S. Ramakrishna, 2005) indexes for a result either kmeans or hierarchical clustering from user specified <code>kmin</code> to <code>kmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DB.IDX(x, kmax, kmin = 2, method = "kmeans",
  indexlist = "all", p = 2, q = 2, nstart = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DB.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="DB.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="DB.IDX_+3A_kmin">kmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="DB.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="DB.IDX_+3A_indexlist">indexlist</code></td>
<td>
<p>a character string indicating which cluster validity indexes to be computed (<code>"all"</code>, <code>"DB"</code>, <code>"DBs"</code>). More than one indexes can be selected.
</p>
</td></tr>
<tr><td><code id="DB.IDX_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance between centroids of clusters. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="DB.IDX_+3A_q">q</code></td>
<td>
<p>the power of dispersion measure of a cluster. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="DB.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lowest value of <code class="reqn">DB(k),DBs(k)</code> indicates a valid optimal partition.
</p>


<h3>Value</h3>

<table>
<tr><td><code>DB</code></td>
<td>
<p>the DB index for <code>k</code> from <code>kmin</code> to <code>kmax</code> shown in a data frame where the first and the second columns are <code>k</code> and the DB index, respectively.</p>
</td></tr>
<tr><td><code>DBs</code></td>
<td>
<p>the DBs index for <code>k</code> from <code>kmin</code> to <code>kmax</code> shown in a data frame where the first and the second columns are <code>k</code> and the DBs index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>D. L. Davies, D. W. Bouldin, &quot;A cluster separation measure,&quot; <em>IEEE Trans Pattern Anal Machine Intell</em>, 1, 224-227 (1979).
</p>
<p>M. Kim, R. S. Ramakrishna, &quot;New indices for cluster validity assessment,&quot; <em>Pattern Recognition Letters</em>, 26, 2353-2363 (2005).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+Wvalid">Wvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+R1_data">R1_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- Kmeans ----

# Compute all the indices by DB.IDX
K.ALL = DB.IDX(scale(x), kmax = 15, kmin = 2, method = "kmeans",
  indexlist = "all", p = 2, q = 2, nstart = 100)
print(K.ALL)

# Compute DB index
K.DB = DB.IDX(scale(x), kmax = 15, kmin = 2, method = "kmeans",
  indexlist = "DB", p = 2, q = 2, nstart = 100)
print(K.DB)

# ---- Hierarchical ----

# Average linkage

# Compute all the indices by DB.IDX
H.ALL = DB.IDX(scale(x), kmax = 15, kmin = 2, method = "hclust_average",
  indexlist = "all", p = 2, q = 2)
print(H.ALL)

# Compute DB index
H.DB = DB.IDX(scale(x), kmax = 15, kmin = 2, method = "hclust_average",
  indexlist = "DB", p = 2, q = 2)
print(H.DB)
</code></pre>

<hr>
<h2 id='DI.IDX'>
Dunn index
</h2><span id='topic+DI.IDX'></span>

<h3>Description</h3>

<p>Computes the DI (J. C. Dunn, 1973) index for a result either kmeans or hierarchical clustering from user specified <code>kmin</code> to <code>kmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DI.IDX(x, kmax, kmin = 2, method = "kmeans", nstart = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DI.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="DI.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="DI.IDX_+3A_kmin">kmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="DI.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="DI.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DI index is defined as <br />
</p>
<p style="text-align: center;"><code class="reqn">DI(k) = \min_{i \ne j \in [k]}\left\{\frac{\min\left\{d(x_u,x_v)|x_u\in C_i,x_v \in C_j\right\}}{\max_{l \in [k]}\max\left\{d(x_u,x_v)|x_u,x_v \in C_l\right\}}\right\}.</code>
</p>

<p>The largest value of <code class="reqn">DI(k)</code> indicates a valid optimal partition.
</p>


<h3>Value</h3>

<table>
<tr><td><code>DI</code></td>
<td>
<p>the DI index for <code>k</code> from <code>kmin</code> to <code>kmax</code> shown in a data frame where the first and the second columns are <code>k</code> and the DI index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>J. C. Dunn, &quot;A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,&quot; <em>J Cybern</em>, 3(3), 32-57 (1973).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+Wvalid">Wvalid</a>, <a href="#topic+DB.IDX">DB.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+R1_data">R1_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- Kmeans ----

# Compute the DI index
K.DI = DI.IDX(scale(x), kmax = 15, kmin = 2, method = "kmeans", nstart = 100)
print(K.DI)

# The optimal number of cluster
K.DI[which.max(K.DI$DI),]

# ---- Hierarchical ----

# Average linkage

# Compute the DI index
H.DI = DI.IDX(scale(x), kmax = 15, kmin = 2, method = "hclust_average")
print(H.DI)

# The optimal number of cluster
H.DI[which.max(H.DI$DI),]
</code></pre>

<hr>
<h2 id='FzzyCVIs'>
Fuzzy cluster validity indexes used in Wiroonsri and Preedasawakul (2023)
</h2><span id='topic+FzzyCVIs'></span>

<h3>Description</h3>

<p>Computes the cluster validity indexes for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code> used in Wiroonsri and Preedasawakul (2023). It includes the XB (X. L. Xie and G. Beni, 1991) index, KWON (S. H. Kwon, 1998) index, KWON2 (S. H. Kwon et al., 2021) index, TANG (Y. Tang et al., 2005) index , HF (F. Haouas et al., 2017) index, WL (C. H. Wu et al., 2015) index, PBM (M. K. Pakhira et al., 2004) index, KPBM (C. Alok, 2010) index, CCVP and CCVS (M. Popescu et al., 2013) index, GC1, GC2, GC3, and GC4 (J. C. Bezdek et al., 2016) indexes , WPC, WP, WPCI1, and, WPCI2 (N. Wiroonsri and O. Preedasawakul, 2023) indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FzzyCVIs(x, cmax, cmin = 2, indexlist = 'all', corr = 'pearson',
  method = 'FCM', fzm = 2, gamma = (fzm^2*7)/4, sampling = 1,
  iter = 100, nstart = 20, NCstart = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FzzyCVIs_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_indexlist">indexlist</code></td>
<td>
<p>a character string indicating which cluster validity indexes to be computed (<code>"all"</code>, <code>"WPC"</code>, <code>"WP"</code>, <code>"WPCI1"</code>, <code>"WPCI2"</code>, <code>"XB"</code>, &quot;<code>"KWON"</code>&quot;, &quot;<code>"KWON2"</code>&quot;, &quot;<code>"TANG"</code>&quot;, &quot;<code>"HF"</code>&quot;, <code>"WL"</code>, <code>"PBM"</code>, <code>"KPBM"</code>, <code>"CCVP"</code>, <code>"CCVS"</code>, <code>"GC1"</code>, <code>"GC2"</code>, <code>"GC3"</code>, <code>"GC4"</code>). More than one indexes can be selected.
</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_corr">corr</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed (<code>"pearson"</code>, <code>"kendall"</code> or <code>"spearman"</code>) for <code>indexlist</code> = (<code>"WP"</code>, <code>"WPC"</code>, <code>"WPCI1"</code>,<code>"WPCI2"</code>, <code>"CCVP"</code>, <code>"CCVS"</code>, <code>"GC1"</code>, <code>"GC2"</code>, <code>"GC3"</code> or <code>"GC4"</code>). The default is <code>"pearson"</code>.
</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_gamma">gamma</code></td>
<td>
<p>adjusted fuzziness parameter for <code>indexlist</code> = (<code>"WP"</code>, <code>"WPC"</code>, <code>"WPCI1"</code>, <code>"WPCI2"</code>). The default is <code class="reqn">7fzm^2/4</code>.
</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_sampling">sampling</code></td>
<td>
<p>a number greater than 0 and less than or equal to 1 indicating the undersampling proportion of data to be used. This argument is intended for handling a large dataset. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="FzzyCVIs_+3A_ncstart">NCstart</code></td>
<td>
<p>logical for <code>indexlist</code> includes either of the <code>"WP"</code>, <code>"WPC"</code>, <code>"WPCI1"</code>, and <code>"WPCI2"</code>), if <code>TRUE</code>, the WP correlation at <code>c=1</code> is defined as the ratio introduced in the reference. Otherwise, it is assigned as <code>0</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The well-known cluster validity indexes for either FCM or EM clustering. It includes the XB (X. L. Xie and G. Beni., 1991) index, KWON (S. H. Kwon, 1998) index, KWON2 (S. H. Kwon et al., 2021) index, TANG (Y. Tang et al., 2005) index , HF (F. Haouas et al., 2017) index, WL (C. H. Wu et al., 2015) index, PBM (M. K. Pakhira et al., 2004) index, KPBM (C. Alok, 2010) index, CCVP and CCVS (M. Popescu et al., 2013) index, GC1, GC2, GC3, and GC4 (J. C. Bezdek et al., 2016) indexes , WPC, WP, WPCI1, and, WPCI2 (N. Wiroonsri and O. Preedasawakul, 2023) indexes.
</p>
<p>The WPC computes the correlation between the actual distance between a pair of data points and the distance between adjusted centroids with respect to the pair. WPCI1 and WPCI2 are the proportion and the subtraction, respectively, of the same two ratios. The first ratio is the WPC improvement from <code>c-1</code> clusters to <code>c</code> clusters over the entire room for improvement. The second ratio is the WPC improvement from <code>c</code> clusters to <code>c+1</code> clusters over the entire room for improvement. <code>WP</code> is defined as a combination of <code>WPCI1</code> and <code>WPCI2</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>WPC</code></td>
<td>
<p>the WP correlation from <code>c</code> from <code>cmin-1</code> to <code>cmax+1</code> shown in a data frame.</p>
</td></tr>
</table>
<p>Each of the followings shows the values of each index for <code>c</code> from <code>cmin</code> to <code>cmax</code> in a data frame.
</p>
<table>
<tr><td><code>WP</code></td>
<td>
<p>the WP index.</p>
</td></tr>
<tr><td><code>WPCI1</code></td>
<td>
<p>the WPCI1 index.</p>
</td></tr>
<tr><td><code>WPCI2</code></td>
<td>
<p>the WPCI2 index.</p>
</td></tr>
<tr><td><code>XB</code></td>
<td>
<p>the XB index.</p>
</td></tr>
<tr><td><code>KWON</code></td>
<td>
<p>the KWON index.</p>
</td></tr>
<tr><td><code>KWON2</code></td>
<td>
<p>the KWON2 index.</p>
</td></tr>
<tr><td><code>TANG</code></td>
<td>
<p>the TANG index.</p>
</td></tr>
<tr><td><code>HF</code></td>
<td>
<p>the HF index.</p>
</td></tr>
<tr><td><code>WL</code></td>
<td>
<p>the WL index.</p>
</td></tr>
<tr><td><code>PBM</code></td>
<td>
<p>the PBM index</p>
</td></tr>
<tr><td><code>KPBM</code></td>
<td>
<p>the KPBM index</p>
</td></tr>
<tr><td><code>CCVP</code></td>
<td>
<p>the Pearson Correlation Cluster Validity index.</p>
</td></tr>
<tr><td><code>CCVS</code></td>
<td>
<p>the Spearman’s (rho) Correlation Cluster Validity index.</p>
</td></tr>
<tr><td><code>GC1</code></td>
<td>
<p>the generalized C index (<code class="reqn">\sum\cdot \sim</code> Sum-Product).</p>
</td></tr>
<tr><td><code>GC2</code></td>
<td>
<p>the generalized C index (<code class="reqn">\sum\wedge \sim</code> Sum-Min).</p>
</td></tr>
<tr><td><code>GC3</code></td>
<td>
<p>the generalized C index (<code class="reqn">\vee\cdot \sim</code> Max-Product).</p>
</td></tr>
<tr><td><code>GC4</code></td>
<td>
<p>the generalized C index (<code class="reqn">\vee\wedge \sim</code> Max-Min).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>C. Alok. (2010). &quot;An investigation of clustering algorithms and soft computing approaches for pattern recognition,&quot; Department of Computer Science, Assam University.<br /><br />
</p>
<p>J. C. Bezdek, M. Moshtaghi, T. Runkler, C. Leckie, “The generalized
c index for internal fuzzy cluster validity,” IEEE Transactions on Fuzzy
Systems, vol. 24, no. 6, pp. 1500–1512, 2016. <br /><br />
</p>
<p>F. Haouas, Z. Ben Dhiaf, A. Hammouda, B. Solaiman, &quot;A new efficient fuzzy cluster validity index: Application to images clustering,&quot; 2017 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE), Naples, Italy, 2017, pp. 1-6.<br /><br />
</p>
<p>S. H. Kwon, “Cluster validity index for fuzzy clustering,” Electronics
letters, vol. 34, no. 22, pp. 2176–2177, 1998. <br /><br />
</p>
<p>S. H. Kwon, J. Kim, S. H. Son, “Improved cluster validity index
for fuzzy clustering,” Electronics Letters, vol. 57, no. 21, pp. 792–794,
2021. <br /><br />
</p>
<p>M. K. Pakhira, S. Bandyopadhyay, U. Maulik, “Validity index for crisp and fuzzy clusters,” Pattern recognition, vol. 37, no. 3, pp. 487–501, 2004.<br /><br />
</p>
<p>M. Popescu, J. C. Bezdek, T. C. Havens, J. M. Keller, &quot;A Cluster Validity Framework Based on Induced Partition Dissimilarity,&quot; in IEEE Transactions on Cybernetics, vol. 43, no. 1, pp. 308-320, Feb. 2013.<br /><br />
</p>
<p>Y. Tang, F. Sun, Z. Sun, “Improved validation index for fuzzy clustering,” in Proceedings of the 2005, American Control Conference, 2005., pp. 1120–1125 vol. 2, 2005.<br /><br />
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A correlation-based fuzzy cluster validity index with secondary options detector,&quot; arXiv:2308.14785, 2023 <br /><br />
</p>
<p>C. H. Wu, C. S. Ouyang, L. W. Chen, L. W. Lu, “A new
fuzzy clustering validity index with a median factor for centroid-based clustering,” IEEE Transactions on Fuzzy Systems, vol. 23, no. 3, pp. 701–718, 2015.<br /><br />
</p>
<p>X. Xie, G. Beni, “A validity measure for fuzzy clustering,” IEEE
Transactions on Pattern Analysis and Machine Intelligence, vol. 13, no. 8,
pp. 841–847, 1991.<br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+GC.IDX">GC.IDX</a>, <a href="#topic+CCV.IDX">CCV.IDX</a>,  <a href="#topic+R1_data">R1_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# Iris data
x = iris[,1:4]

# ---- FCM algorithm ----


# Compute selected a set of indices ("WPC","WP","XB") using default gamma
F.s = FzzyCVIs(scale(x), cmax = 10, cmin = 2, indexlist = c("WPC","WP","XB"),
  corr = 'pearson', method = 'FCM', fzm = 2, iter = 100, nstart = 20, NCstart = TRUE)

# Plot the computed indexes
plot_idx(F.s)

# ---- EM algorithm ----

# Compute all the indices by FzzyCVIs using default gamma
E.all = FzzyCVIs(scale(x), cmax = 10, cmin = 2, indexlist = 'all', corr = 'pearson',
  method = 'EM', iter = 100, nstart = 20, NCstart = TRUE)

# Plot the computed indexes
plot_idx(E.all)

</code></pre>

<hr>
<h2 id='GC.IDX'>The generalized C index
</h2><span id='topic+GC.IDX'></span>

<h3>Description</h3>

<p>Computes the GC1 GC2 GC3 and GC4 (J. C. Bezdek et al., 2016) indexes for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GC.IDX(x, cmax, cmin = 2, indexlist = "all", method = 'FCM', fzm = 2,
  iter = 100, nstart = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GC.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="GC.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="GC.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="GC.IDX_+3A_indexlist">indexlist</code></td>
<td>
<p>a character string indicating which The generalized C index be computed (&quot;<code>all</code>&quot;,&quot;<code>GC1</code>&quot;,&quot;<code>GC2</code>&quot;,&quot;<code>GC3</code>&quot;,&quot;<code>GC4</code>&quot;). More than one indexes can be selected.
</p>
</td></tr>
<tr><td><code id="GC.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="GC.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="GC.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="GC.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GC index is a soft version of the C-index, formulated based on relational transformations of the membership degree matrix <code class="reqn">\mu</code>. It comprises four distinct variants, each with its own definition.<br />
The smallest value of <code class="reqn">GC(c)</code> indicates a valid optimal partition.
</p>


<h3>Value</h3>

<p>Each of the followings shows the values of each index for <code>c</code> from <code>cmin</code> to <code>cmax</code> in a data frame.
</p>
<table>
<tr><td><code>GC1</code></td>
<td>
<p>the generalized C index (<code class="reqn">\sum\cdot \sim</code> Sum-Product).</p>
</td></tr>
<tr><td><code>GC2</code></td>
<td>
<p>the generalized C index (<code class="reqn">\sum\wedge \sim</code> Sum-Min).</p>
</td></tr>
<tr><td><code>GC3</code></td>
<td>
<p>the generalized C index (<code class="reqn">\vee\cdot \sim</code> Max-Product).</p>
</td></tr>
<tr><td><code>GC4</code></td>
<td>
<p>the generalized C index (<code class="reqn">\vee\wedge \sim</code> Max-Min).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>J. C. Bezdek, M. Moshtaghi, T. Runkler, and C. Leckie, “The generalized
c index for internal fuzzy cluster validity,” IEEE Transactions on Fuzzy
Systems, vol. 24, no. 6, pp. 1500–1512, 2016. <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7429723&amp;isnumber=7797168">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7429723&amp;isnumber=7797168</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# Iris data
x = iris[,1:4]

# ---- FCM algorithm ----

# Compute all the indices by GC.IDX
FCM.all.GC = GC.IDX(scale(x), cmax = 10, cmin = 2, indexlist = "all",
  method =  'FCM', fzm = 2, iter = 100, nstart = 5)
print(FCM.all.GC)

# Compute GC2 index
FCM.GC2 = GC.IDX(scale(x), cmax = 10, cmin = 2, indexlist = "GC2",
  method = 'FCM', fzm = 2, iter = 100, nstart = 5)
print(FCM.GC2)

# ---- EM algorithm ----

# Compute all the indices by GC.IDX
EM.all.GC = GC.IDX(scale(x), cmax = 10, cmin = 2, indexlist = "all",
  method =  'EM', iter = 100, nstart = 5)
print(EM.all.GC)

# Compute GC2 index
EM.GC2 = GC.IDX(scale(x), cmax = 10, cmin = 2, indexlist = "GC2",
  method =  'EM', iter = 100, nstart = 5)
print(EM.GC2)
</code></pre>

<hr>
<h2 id='HF.IDX'>
HF index
</h2><span id='topic+HF.IDX'></span>

<h3>Description</h3>

<p>Computes the HF (F. Haouas et al., 2017) index for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HF.IDX(x, cmax, cmin = 2, method = "FCM", fzm = 2, nstart = 20, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HF.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="HF.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="HF.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="HF.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="HF.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="HF.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="HF.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The HF index is defined as <br />
</p>
<p style="text-align: center;"><code class="reqn">HF(c) = \frac{\sum_{j=1}^c \sum_{i=1}^n\mu_{ij}^m\| {x}_i-{v}_j\|^2 + \frac{1}{c(c-1)}\sum_{j\neq k}\| {v}_j-{v}_k\|^2}{\frac{n}{2c}\left(\min_{j \neq k}\{\| {v}_j-{v}_k\|^2\} +\text{median}_{j \neq k }\{\| {v}_j-{v}_k\|^2\}\right)}.</code>
</p>

<p>The smallest value of <code class="reqn">HF(c)</code> indicates a valid optimal partition.<br />
</p>


<h3>Value</h3>

<table>
<tr><td><code>HF</code></td>
<td>
<p>the HF index for <code>c</code> from <code>cmin</code> to <code>cmax</code> shown in a data frame where the first and the second columns are <code>c</code> and the HF index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>F. Haouas, Z. Ben Dhiaf, A. Hammouda and B. Solaiman, &quot;A new efficient fuzzy cluster validity index: Application to images clustering,&quot; 2017 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE), Naples, Italy, 2017, pp. 1-6.  <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8015651&amp;isnumber=8015374">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8015651&amp;isnumber=8015374</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- FCM algorithm ----

# Compute the HF index
FCM.HF = HF.IDX(scale(x), cmax = 15, cmin = 2, method = "FCM",
  fzm = 2, nstart = 20, iter = 100)
print(FCM.HF)

# The optimal number of cluster
FCM.HF[which.min(FCM.HF$HF),]

# ---- EM algorithm ----

# Compute the HF index
EM.HF = HF.IDX(scale(x), cmax = 15, cmin = 2, method = "EM",
  nstart = 20, iter = 100)
print(EM.HF)

# The optimal number of cluster
EM.HF[which.min(EM.HF$HF),]
</code></pre>

<hr>
<h2 id='Hvalid'>
Wiroonsri(2024) correlation-based cluster validity indices and other well-known cluster validity indices
</h2><span id='topic+Hvalid'></span>

<h3>Description</h3>

<p>Computes the cluster validity indexes for a result of either kmeans or hierarchical clustering from user specified <code>kmin</code> to <code>kmax</code> used in Wiroonsri(2024). It includes the DI (J. C. Dunn, 1973) index, CH (T. Calinski and J. Harabasz, 1974) index, DB (D. L. Davies and D. W. Bouldin, 1979) index, PB (G. W. Miligan, 1985) index, CSL (C. H. Chou et al., 2004) index, PBM (M. K. Pakhira et al., 2004) index, DBs (M. Kim and R. S. Ramakrishna, 2005), Score function (S. Saitta et al., 2007), STR (A. Starczewski, 2017) index, NC, NCI, NCI1, and, NCI2 (N. Wiroonsri, 2024) indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hvalid(x, kmax, kmin = 2, indexlist = "all", method = "kmeans",
  p = 2, q = 2, corr = "pearson", nstart = 100, sampling = 1, NCstart = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hvalid_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="Hvalid_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="Hvalid_+3A_kmin">kmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="Hvalid_+3A_indexlist">indexlist</code></td>
<td>
<p>a character string indicating which cluster validity indexes to be computed (<code>"all"</code>, <code>"NC"</code>, <code>"NCI"</code>, <code>"NCI1"</code>, <code>"NCI2"</code>, <code>"PB"</code>, <code>"CSL"</code>, <code>"CH"</code>, <code>"DB"</code>, <code>"DBs"</code>, <code>"SF"</code>, <code>"DI"</code>, <code>"STR"</code>, <code>"PBM"</code>). More than one indexes can be selected.
</p>
</td></tr>
<tr><td><code id="Hvalid_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="Hvalid_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance between centroids of clusters for <code>indexlist = c("DB","DBs")</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="Hvalid_+3A_q">q</code></td>
<td>
<p>the power of dispersion measure of a cluster for <code>indexlist = c("DB","DBs")</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="Hvalid_+3A_corr">corr</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed (<code>"pearson"</code>, <code>"kendall"</code> or <code>"spearman"</code>). The default is <code>"pearson"</code>.
</p>
</td></tr>
<tr><td><code id="Hvalid_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="Hvalid_+3A_sampling">sampling</code></td>
<td>
<p>a number greater than 0 and less than or equal to 1 indicating the undersampling proportion of data to be used. This argument is intended for handling a large dataset. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="Hvalid_+3A_ncstart">NCstart</code></td>
<td>
<p>logical for <code>indexlist</code> includes the <code>"NC"</code>, <code>"NCI"</code>, <code>"NCI1"</code>, and <code>"NCI2"</code>), if <code>TRUE</code>, the NC correlation at <code>k=1</code> is defined as the ratio introduced in the reference. Otherwise, it is assigned as <code>0</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The well-known cluster validity indices used in Wiroonsri(2024). It includes the DI (J. C. Dunn, 1973) index, CH (T. Calinski and J. Harabasz, 1974) index, DB (D. L. Davies and D. W. Bouldin, 1979) index, PB (G. W. Miligan, 1980) index, CSL (C. H. Chou et al., 2004) index, PBM (M. K. Pakhira et al., 2004) index, DBs (M. Kim and R. S. Ramakrishna, 2005), Score function (S. Saitta et al., 2007), STR (A. Starczewski, 2017), NC, NCI, NCI1, and, NCI2 (N. Wiroonsri, 2024) indexes.
</p>
<p>The NC correlation computes the correlation between an actual distance between a pair of data points and a centroid distance of clusters that the two points locate in. NCI1 and NCI2 are the proportion and the subtraction, respectively, of the same two ratios. The first ratio is the NC improvement from <code>k-1</code> clusters to <code>k</code> clusters over the entire room for improvement. The second ratio is the NC improvement from <code>k</code> clusters to <code>k+1</code> clusters over the entire room for improvement. NCI is a combination of NCI1 and NCI2.
</p>


<h3>Value</h3>

<table>
<tr><td><code>NC</code></td>
<td>
<p>the NC correlations for <code>k</code> from <code>kmin-1</code> to <code>kmax+1</code> shown in a data frame where the first and the second columns are <code>k</code> and the NC, respectively.</p>
</td></tr>
</table>
<p>Each of the followings shows the values of each index for <code>k</code> from <code>kmin</code> to <code>kmax</code> in a data frame.
</p>
<table>
<tr><td><code>NCI</code></td>
<td>
<p>the NCI index.</p>
</td></tr>
<tr><td><code>NCI1</code></td>
<td>
<p>the NCI1 index.</p>
</td></tr>
<tr><td><code>NCI2</code></td>
<td>
<p>the NCI2 index.</p>
</td></tr>
<tr><td><code>PB</code></td>
<td>
<p>the PB index.</p>
</td></tr>
<tr><td><code>DI</code></td>
<td>
<p>the DI index.</p>
</td></tr>
<tr><td><code>DB</code></td>
<td>
<p>the DB index.</p>
</td></tr>
<tr><td><code>DBs</code></td>
<td>
<p>the DBs index.</p>
</td></tr>
<tr><td><code>CSL</code></td>
<td>
<p>the CSL index.</p>
</td></tr>
<tr><td><code>CH</code></td>
<td>
<p>the CH index.</p>
</td></tr>
<tr><td><code>SF</code></td>
<td>
<p>the Score function.</p>
</td></tr>
<tr><td><code>STR</code></td>
<td>
<p>the STR index.</p>
</td></tr>
<tr><td><code>PBM</code></td>
<td>
<p>the PBM index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>J. C. Bezdek, N. R. Pal, &quot;Some new indexes of cluster validity,&quot; <em>IEEE Transactions on Systems, Man, and Cybernetics</em>, Part B, 28, 301-315 (1998).
</p>
<p>T. Calinski, J. Harabasz, &quot;A dendrite method for cluster analysis,&quot; <em>Communications in Statistics</em>, 3, 1-27 (1974).
</p>
<p>C. H. Chou, M. C. Su, E. Lai, &quot;A new cluster validity measure and its application to image compression,&quot; <em>Pattern Anal Applic</em>, 7, 205-220 (2004).
</p>
<p>D. L. Davies, D. W. Bouldin, &quot;A cluster separation measure,&quot; <em>IEEE Trans Pattern Anal Machine Intell</em>, 1, 224-227 (1979).
</p>
<p>J. C. Dunn, &quot;A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,&quot; <em>J Cybern</em>, 3(3), 32-57 (1973).
</p>
<p>M. Kim, R. S. Ramakrishna, &quot;New indices for cluster validity assessment,&quot; <em>Pattern Recognition Letters</em>, 26, 2353-2363 (2005).
</p>
<p>G. W. Miligan, &quot;An examination of the effect of six types of error perturbation on fifteen clustering algorithms,&quot; <em>Psychometrika</em>, 45, 325-342 (1980).
</p>
<p>M. K. Pakhira, S. Bandyopadhyay and U. Maulik, &quot;Validity index for crisp and fuzzy clusters,&quot; <em>Pattern Recogn</em> 37(3):487–501 (2004).
</p>
<p>S. Saitta, B. Raphael, I. Smith, &quot;A bounded index for cluster validity,&quot; <em>In Perner, P.: Machine Learning and Data Mining in Pattern Recognition, Lecture Notes in Computer Science</em>, 4571, Springer (2007).
</p>
<p>A. Starczewski, &quot;A new validity index for crisp clusters,&quot; <em>Pattern Anal Applic</em> 20, 687–700 (2017).
</p>
<p>N. Wiroonsri, &quot;Clustering performance analysis using a new correlation based cluster validity index,&quot; Pattern Recognition, 145, 109910, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Wvalid">Wvalid</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+DI.IDX">DI.IDX</a>,  <a href="#topic+R1_data">R1_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]


# ---- Kmeans ----

# Compute all the indices by Hvalid
Hvalid(scale(x), kmax = 15, kmin = 2, indexlist = "all",
  method = "kmeans", p = 2, q = 2, corr = "pearson", nstart = 100, NCstart = TRUE)

# Compute selected a set of indices ("NC","NCI","DI","DB")
Hvalid(scale(x), kmax = 15, kmin = 2, indexlist = c("NC","NCI","DI","DB"),
  method = "kmeans", p = 2, q = 2, corr = "pearson", nstart = 100, NCstart = TRUE)

# ---- Hierarchical ----

# Average linkage

# Compute all the indices by Hvalid
Hvalid(scale(x), kmax = 15, kmin = 2, indexlist = "all",
  method = "hclust_average", p = 2, q = 2, corr = "pearson", nstart = 100, NCstart = TRUE)

# Compute selected a set of indices ("NC","NCI","DI","DB")
Hvalid(scale(x), kmax = 15, kmin = 2, indexlist = c("NC","NCI","DI","DB"),
  method = "hclust_average", p = 2, q = 2, corr = "pearson", nstart = 100, NCstart = TRUE)

#---Plot and compare the indexes---

# Compute six cluster validity indexes of a kmeans clustering result for k from 2 to 15
IDX.list = c("NCI", "DI", "DB", "DBs", "CSL", "CH")

Hvalid.result = Hvalid(scale(x), kmax = 15, kmin = 2, indexlist = IDX.list,
  method = "hclust_average", p = 2, q = 2, corr = "pearson", nstart = 100, NCstart = TRUE)

# Plot the computed indexes
plot_idx(Hvalid.result)
</code></pre>

<hr>
<h2 id='KPBM.IDX'>
Modified Kernel form of Pakhira-Bandyopadhyay-Maulik (KPBM) index
</h2><span id='topic+KPBM.IDX'></span>

<h3>Description</h3>

<p>Computes the KPBM (C. Alok, 2010) index for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KPBM.IDX(x, cmax, cmin = 2, method = "FCM", fzm = 2, nstart = 20, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KPBM.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="KPBM.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="KPBM.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="KPBM.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="KPBM.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="KPBM.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="KPBM.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The KPBM index is defined as <br />
</p>
<p style="text-align: center;"><code class="reqn">KPBM(c) = \left(\frac{\max_{j \neq k}\| {v}_j-{v}_k\|}{c\sum_{j=1}^c\sum_{i=1}^n\mu_{ij}\| {x}_i-{v}_j\|}\right)^2.</code>
</p>

<p>The largest value of <code class="reqn">KPBM(c)</code> indicates a valid optimal partition.<br />
</p>


<h3>Value</h3>

<table>
<tr><td><code>KPBM</code></td>
<td>
<p>the KPBM index for <code>c</code> from <code>cmin</code> to <code>cmax</code> shown in a data frame where the first and the second columns are <code>c</code> and the KPBM index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul</p>


<h3>References</h3>

<p>C. Alok. (2010). &quot;An investigation of clustering algorithms and soft computing approaches for pattern recognition,&quot; Department of Computer Science, Assam University. <a href="http://hdl.handle.net/10603/93443">http://hdl.handle.net/10603/93443</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- FCM algorithm ----

# Compute the KPBM index
FCM.KPBM = KPBM.IDX(scale(x), cmax = 15, cmin = 2, method = "FCM",
  fzm = 2, nstart = 20, iter = 100)
print(FCM.KPBM)

# The optimal number of cluster
FCM.KPBM[which.max(FCM.KPBM$KPBM),]

# ---- EM algorithm ----

# Compute the KPBM index
EM.KPBM = KPBM.IDX(scale(x), cmax = 15, cmin = 2, method = "EM",
  nstart = 20, iter = 100)
print(EM.KPBM)

# The optimal number of cluster
EM.KPBM[which.max(EM.KPBM$KPBM),]
</code></pre>

<hr>
<h2 id='KWON.IDX'>
KWON index
</h2><span id='topic+KWON.IDX'></span>

<h3>Description</h3>

<p>Computes the KWON (S. H. Kwon, 1998) index for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KWON.IDX(x, cmax, cmin = 2, method = "FCM", fzm = 2, nstart = 20, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KWON.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="KWON.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="KWON.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="KWON.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="KWON.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="KWON.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="KWON.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The KWON index is defined as <br />
</p>
<p style="text-align: center;"><code class="reqn">KWON(c) = \frac{\sum_{j=1}^c\sum_{i=1}^n \mu_{ij}^2  \|{x}_i-{v}_j\|^2 +\frac{1}{c}\sum_{j=1}^c\| {v}_j-{v}_0\|^2}{\min_{i \neq j} \| {v}_i-{v}_j\|^2}.
</code>
</p>

<p>The smallest value of <code class="reqn">KWON(c)</code> indicates a valid optimal partition.<br />
</p>


<h3>Value</h3>

<table>
<tr><td><code>KWON</code></td>
<td>
<p>the KWON index for <code>c</code> from <code>cmin</code> to <code>cmax</code> shown in a data frame where the first and the second columns are <code>c</code> and the KWON index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>S. H. Kwon, “Cluster validity index for fuzzy clustering,” Electronics
letters, vol. 34, no. 22, pp. 2176–2177, 1998. <a href="https://doi.org/10.1049/el%3A19981523">doi:10.1049/el:19981523</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- FCM algorithm ----

# Compute the KWON index
FCM.KWON = KWON.IDX(scale(x), cmax = 15, cmin = 2, method = "FCM",
  fzm = 2, nstart = 20, iter = 100)
print(FCM.KWON)
# The optimal number of cluster
FCM.KWON[which.min(FCM.KWON$KWON),]

# ---- EM algorithm ----

# Compute the KWON index
EM.KWON = KWON.IDX(scale(x), cmax = 15, cmin = 2, method = "EM",
  nstart = 20, iter = 100)
print(EM.KWON)
# The optimal number of cluster
EM.KWON[which.min(EM.KWON$KWON),]
</code></pre>

<hr>
<h2 id='KWON2.IDX'>
KWON2 index
</h2><span id='topic+KWON2.IDX'></span>

<h3>Description</h3>

<p>Computes the KWON2 (S. H. Kwon et al., 2021) index for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KWON2.IDX(x, cmax, cmin = 2, method = "FCM", fzm = 2, nstart = 20, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KWON2.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="KWON2.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="KWON2.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="KWON2.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="KWON2.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="KWON2.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="KWON2.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>KWON2 is defined as <br />
</p>
<p style="text-align: center;"><code class="reqn">KWON2(c) = \frac{w_1\left[w_2\sum_{j=1}^c\sum_{i=1}^n \mu_{ij}^{2^{\sqrt{\frac{m}{2}}}}  \|{x}_i-{v}_j\|^2  + \frac{\sum_{j=1}^c\| {v}_j-{v}_0\|^2}{\max_j \|{v}_j-{v}_0\|^2 } + w_3 \right]}{\min_{i \neq j} \| {v}_i-{v}_j\|^2 + \frac{1}{c}+\frac{1}{c^m-1}}.
</code>
</p>

<p>where <code class="reqn">w_1 = \frac{n-c+1}{n}</code>, <code class="reqn">w_2 = \left(\frac{c}{c-1}\right)^{\sqrt{2}}</code> and <code class="reqn">w_3=\frac{nc}{(n-c+1)^2}</code>.<br /><br />
The smallest value of  <code class="reqn">KWON2(c)</code> indicates a valid optimal partition.<br />
</p>


<h3>Value</h3>

<table>
<tr><td><code>KWON2</code></td>
<td>
<p>the KWON2 index for <code>c</code> from <code>cmin</code> to <code>cmax</code> shown in a data frame where the first and the second columns are <code>c</code> and the KWON2 index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>S. H. Kwon, J. Kim, and S. H. Son, “Improved cluster validity index
for fuzzy clustering,” Electronics Letters, vol. 57, no. 21, pp. 792–794,
2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- FCM algorithm ----

# Compute the KWON2 index
FCM.KWON2 = KWON2.IDX(scale(x), cmax = 15, cmin = 2, method = "FCM",
  fzm = 2, nstart = 20, iter = 100)
print(FCM.KWON2)

# The optimal number of cluster
FCM.KWON2[which.min(FCM.KWON2$KWON2),]

# ---- EM algorithm ----

# Compute the KWON2 index
EM.KWON2 = KWON2.IDX(scale(x), cmax = 15, cmin = 2, method = "EM",
  nstart = 20, iter = 100)
print(EM.KWON2)

# The optimal number of cluster
EM.KWON2[which.min(EM.KWON2$KWON2),]
</code></pre>

<hr>
<h2 id='PB.IDX'>
Point biserial correlation (PB)
</h2><span id='topic+PB.IDX'></span>

<h3>Description</h3>

<p>Computes the PB (G. W. Miligan, 1980) index for a result either kmeans or hierarchical clustering from user specified <code>kmin</code> to <code>kmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PB.IDX(x, kmax, kmin = 2, method = "kmeans", corr = "pearson", nstart = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PB.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="PB.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="PB.IDX_+3A_kmin">kmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="PB.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="PB.IDX_+3A_corr">corr</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed (<code>"pearson"</code>, <code>"kendall"</code> or <code>"spearman"</code>). The default is <code>"pearson"</code>.
</p>
</td></tr>
<tr><td><code id="PB.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The largest value of <code class="reqn">PB(k)</code> indicates a valid optimal partition.
</p>


<h3>Value</h3>

<table>
<tr><td><code>PB</code></td>
<td>
<p>the PB index for <code>k</code> from <code>kmin</code> to <code>kmax</code> shown in a data frame where the first and the second columns are <code>k</code> and the PB index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>G. W. Miligan, &quot;An examination of the effect of six types of error perturbation on fifteen clustering algorithms,&quot; <em>Psychometrika</em>, 45, 325-342 (1980).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+Wvalid">Wvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+R1_data">R1_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- Kmeans ----

# Compute PB index
K.PB = PB.IDX(scale(x), kmax = 15, kmin = 2, method = "kmeans",
  corr = "pearson", nstart = 100)
print(K.PB)

# The optimal number of cluster
K.PB[which.max(K.PB$PB),]

# ---- Hierarchical ----

# Average linkage

# Compute PB index
H.PB = PB.IDX(scale(x), kmax = 15, kmin = 2, method = "hclust_average",
  corr = "pearson")
print(H.PB)

# The optimal number of cluster
H.PB[which.max(H.PB$PB),]
</code></pre>

<hr>
<h2 id='PBM.IDX'>
Pakhira-Bandyopadhyay-Maulik (PBM) index
</h2><span id='topic+PBM.IDX'></span>

<h3>Description</h3>

<p>Computes the PBM (M. K. Pakhira et al., 2004) index for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PBM.IDX(x, cmax, cmin = 2, method = "FCM", fzm = 2, nstart = 20, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PBM.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="PBM.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="PBM.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="PBM.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="PBM.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="PBM.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="PBM.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PBM index is defined as<br />
</p>
<p style="text-align: center;"><code class="reqn">PBM(c) = \left(\frac{\sum_{i=1}^n \| {x}_i-{v}_0\| \cdot \max_{j \neq k}\| {v}_j-{v}_k\|}{c\sum_{j=1}^c\sum_{i=1}^n\mu_{ij}\| {x}_i-{v}_j\|}\right)^2.</code>
</p>

<p>The largest value of <code class="reqn">PBM(c)</code> indicates a valid optimal partition.<br />
</p>


<h3>Value</h3>

<table>
<tr><td><code>PBM</code></td>
<td>
<p>the PBM index for <code>c</code> from <code>cmin</code> to <code>cmax</code> shown in a data frame where the first and the second columns are <code>c</code> and the PBM index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>M. K. Pakhira, S. Bandyopadhyay, and U. Maulik, “Validity index for crisp and fuzzy clusters,” Pattern recognition, vol. 37, no. 3, pp. 487–501, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- FCM algorithm ----

# Compute the PBM index
FCM.PBM = PBM.IDX(scale(x), cmax = 15, cmin = 2, method = "FCM",
  fzm = 2, nstart = 20, iter = 100)
print(FCM.PBM)

# The optimal number of cluster
FCM.PBM[which.max(FCM.PBM$PBM),]

# ---- EM algorithm ----

# Compute the PBM index
EM.PBM = PBM.IDX(scale(x), cmax = 15, cmin = 2, method = "EM",
  nstart = 20, iter = 100)
print(EM.PBM)

# The optimal number of cluster
EM.PBM[which.max(EM.PBM$PBM),]
</code></pre>

<hr>
<h2 id='plot_idx'>
Plots for visualizing CVIs
</h2><span id='topic+plot_idx'></span>

<h3>Description</h3>

<p>Plot and compare upto 8 indices computed by the algorithms in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_idx(idxresult,selected.idx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_idx_+3A_idxresult">idxresult</code></td>
<td>
<p>a result from one of the algorithms <code>FzzyCVIs, WP.IDX, GC.IDX, CCV.IDX, XB.IDX, WL.IDX, TANG.IDX, PBM.IDX, KWON.IDX, KWON2.IDX, KPBM.IDX, HF.IDX, Hvalid, Wvalid, SF.IDX, PB.IDX, DI.IDX, DB.IDX, CSL.IDX, CH.IDX or STRPBM.IDX</code>.
</p>
</td></tr>
<tr><td><code id="plot_idx_+3A_selected.idx">selected.idx</code></td>
<td>
<p>a numeric vector indicates a part of the indexes from the <code>idxresult</code> in respective order selected by a user. For instance, <code>selected.idx = 3</code> or <code>selected.idx = c(1,3,5)</code> may be selected. If not specified, the full idxresult will be considered.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots of upto 8 cluster validity indices computed from <code>FzzyCVIs, WP.IDX, GC.IDX, CCV.IDX, XB.IDX, WL.IDX, TANG.IDX, PBM.IDX, KWON.IDX, KWON2.IDX, KPBM.IDX, HF.IDX, Hvalid, Wvalid, SF.IDX, PB.IDX, DI.IDX, DB.IDX, CSL.IDX, CH.IDX or STRPBM.IDX</code>. When using the isolated index algorithm, all the plots computed by that algorithm will be shown. When using <code>FzzyCVIs or Hvalid</code> with more than 8 selected indices, the first 8 indices will be plotted.
</p>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, &quot;A correlation-based fuzzy cluster validity index with secondary options detector,&quot; arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+XB.IDX">XB.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# Iris data
x = iris[,1:4]

# ----Compute all the indices by FzzyCVIs ----
FCVIs = FzzyCVIs(scale(x), cmax = 10, cmin = 2, indexlist = 'all', corr = 'pearson',
                 method = 'FCM', fzm = 2, iter = 100, nstart = 20, NCstart = TRUE)

# plots of the eight indices by default
plot_idx(idxresult = FCVIs)

# plots of a specific selected.idx
plot_idx(idxresult = FCVIs, selected.idx = c(2,5,7))

# ----Compute all the indices by Wvalid ----
FCM.NC = Wvalid(scale(x), kmax = 10, kmin=2, method = 'kmeans',
  corr='pearson', nstart=100, NCstart = TRUE)

# plots of the four indices by default
plot_idx(idxresult = FCM.NC)

# ----Compute all the indices by XB.IDX ----

FCM.XB = XB.IDX(scale(x), cmax = 10, cmin = 2, method = "FCM",
  fzm = 2, nstart = 20, iter = 100)
plot_idx(idxresult = FCM.XB)
</code></pre>

<hr>
<h2 id='R1_data'>R1 Artificial Dataset</h2><span id='topic+R1_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>9</code> different Gaussian distributions labeled as <code>1-9</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R1_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 450 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5,6,7,8,9</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='R2_data'>R2 Artificial Dataset</h2><span id='topic+R2_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>7</code> different Gaussian distributions labeled as <code>1-7</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1750 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5,6,7</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='R3_data'>R3 Artificial Dataset</h2><span id='topic+R3_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>16</code> different Gaussian distributions labeled as <code>1-16</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R3_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1600 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,...,16</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='R4_data'>R4 Artificial Dataset</h2><span id='topic+R4_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>5</code> different Gaussian distributions labeled as <code>1-5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R4_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1250 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='R5_data'>R5 Artificial Dataset</h2><span id='topic+R5_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>6</code> different Gaussian distributions labeled as <code>1-6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R5_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1200 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5,6</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='R6_data'>R6 Artificial Dataset</h2><span id='topic+R6_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>6</code> different Gaussian distributions labeled as <code>1-6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R6_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1500 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5,6</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='R7_data'>R7 Artificial Dataset</h2><span id='topic+R7_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2023) generated from <code>6</code> different Gaussian and <code>3</code> Uniform distributions labeled as <code>1-3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R7_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1200 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A correlation-based fuzzy cluster validity index with secondary options detector, arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+WP.IDX">WP.IDX</a>,  <a href="#topic+D1_data">D1_data</a>, <a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>
</p>

<hr>
<h2 id='SF.IDX'>The score function
</h2><span id='topic+SF.IDX'></span>

<h3>Description</h3>

<p>Computes the SF (S. Saitta et al., 2007) index for a result either kmeans or hierarchical clustering from user specified <code>kmin</code> to <code>kmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SF.IDX(x, kmax, kmin = 2, method = "kmeans", nstart = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SF.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="SF.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="SF.IDX_+3A_kmin">kmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="SF.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="SF.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The smallest value of <code class="reqn">SF(k)</code> indicates a valid optimal partition.
</p>


<h3>Value</h3>

<table>
<tr><td><code>SF</code></td>
<td>
<p>the Score function index for <code>k</code> from <code>kmin</code> to <code>kmax</code> shown in a data frame where the first and the second columns are <code>k</code> and the SF index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>S. Saitta, B. Raphael, I. Smith, &quot;A bounded index for cluster validity,&quot; <em>In Perner, P.: Machine Learning and Data Mining in Pattern Recognition, Lecture Notes in Computer Science</em>, 4571, Springer (2007).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+Wvalid">Wvalid</a>, <a href="#topic+DI.IDX">DI.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>,  <a href="#topic+R1_data">R1_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- Kmeans ----

# Compute the SF index
K.SF = SF.IDX(scale(x), kmax = 15, kmin = 2, method = "kmeans", nstart = 100)
print(K.SF)

# The optimal number of cluster
K.SF[which.min(K.SF$SF),]

# ---- Hierarchical ----

# Average linkage

# Compute the SF index
H.SF = SF.IDX(scale(x), kmax = 15, kmin = 2, method = "hclust_average")
print(H.SF)

# The optimal number of cluster
H.SF[which.min(H.SF$SF),]
</code></pre>

<hr>
<h2 id='STRPBM.IDX'>
Starczewski and Pakhira-Bandyopadhyay-Maulik for crisp clustering indexes
</h2><span id='topic+STRPBM.IDX'></span>

<h3>Description</h3>

<p>Computes the STR (A. Starczewski, 2017) and PBM (M. K. Pakhira et al., 2004) indexes for a result either kmeans or hierarchical clustering from user specified <code>kmin</code> to <code>kmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STRPBM.IDX(x, kmax, kmin = 2, method = "kmeans", indexlist = "all", nstart = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STRPBM.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="STRPBM.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="STRPBM.IDX_+3A_kmin">kmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="STRPBM.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="STRPBM.IDX_+3A_indexlist">indexlist</code></td>
<td>
<p>a character string indicating which cluster validity indexes to be computed (<code>"all"</code>, <code>"STR"</code>, <code>"PBM"</code>). More than one indexes can be selected.
</p>
</td></tr>
<tr><td><code id="STRPBM.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PBM index can be used with both crisp and fuzzy clustering algorithms.<br />
The largest value of <code class="reqn">STR(k)</code> indicates a valid optimal partition.<br />
The largest value of <code class="reqn">PBM(k)</code> indicates a valid optimal partition.
</p>


<h3>Value</h3>

<table>
<tr><td><code>STR</code></td>
<td>
<p>the STR index for <code>k</code> from <code>kmin</code> to <code>kmax</code> shown in a data frame where the first and the second columns are <code>k</code> and the STR index, respectively.</p>
</td></tr>
<tr><td><code>PBM</code></td>
<td>
<p>the PBM index for <code>k</code> from <code>kmin</code> to <code>kmax</code> shown in a data frame where the first and the second columns are <code>k</code> and the PBM index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>M. K. Pakhira, S. Bandyopadhyay and U. Maulik, &quot;Validity index for crisp and fuzzy clusters,&quot; <em>Pattern Recogn</em> 37(3):487–501 (2004).
</p>
<p>A. Starczewski, &quot;A new validity index for crisp clusters,&quot; <em>Pattern Anal Applic</em> 20, 687–700 (2017).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Wvalid">Wvalid</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+DI.IDX">DI.IDX</a>,  <a href="#topic+R1_data">R1_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- Kmeans ----

# Compute all the indices by STRPBM.IDX
K.ALL = STRPBM.IDX(scale(x), kmax = 15, kmin = 2, method = "kmeans",
  indexlist = "all", nstart = 100)
print(K.ALL)

# Compute STR index
K.STR = STRPBM.IDX(scale(x), kmax = 15, kmin = 2, method = "kmeans",
  indexlist = "STR", nstart = 100)
print(K.STR)

# ---- Hierarchical ----

# Average linkage

# Compute all the indices by STRPBM.IDX
H.ALL = STRPBM.IDX(scale(x), kmax = 15, kmin = 2, method = "hclust_average",
  indexlist = "all")
print(H.ALL)

# Compute STR index
H.STR = STRPBM.IDX(scale(x), kmax = 15, kmin = 2, method = "hclust_average",
  indexlist = "STR")
print(H.STR)

</code></pre>

<hr>
<h2 id='TANG.IDX'>
Tang index
</h2><span id='topic+TANG.IDX'></span>

<h3>Description</h3>

<p>Computes the TANG (Y. Tang et al., 2005) index for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TANG.IDX(x, cmax, cmin = 2, method = "FCM", fzm = 2, nstart = 20, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TANG.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="TANG.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="TANG.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="TANG.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="TANG.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="TANG.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="TANG.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Tang index  is defined as <br />
</p>
<p style="text-align: center;"><code class="reqn">TANG(c) = \frac{\sum_{j=1}^c \sum_{i=1}^n\mu_{ij}^2\| {x}_i-{v}_j\|^2 + \frac{1}{c(c-1)}\sum_{j\neq k}\| {v}_j-{v}_k\|^2}{\min_{j\neq k} \{ \| {v}_j-{v}_k\|^2 \}+\frac{1}{c}}.</code>
</p>

<p>The smallest value of <code class="reqn">TANG(c)</code> indicates a valid optimal partition.<br />
</p>


<h3>Value</h3>

<table>
<tr><td><code>TANG</code></td>
<td>
<p>the TANG index for <code>c</code> from <code>cmin</code> to <code>cmax</code> shown in a data frame where the first and the second columns are <code>c</code> and the TANG index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>Y. Tang, F. Sun, and Z. Sun, “Improved validation index for fuzzy clustering,” in Proceedings of the 2005, American Control Conference, 2005., pp. 1120–1125 vol. 2, 2005. <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=1470111&amp;isnumber=31519">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=1470111&amp;isnumber=31519</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- FCM algorithm ----

# Compute the TANG index
FCM.TANG = TANG.IDX(scale(x), cmax = 15, cmin = 2, method = "FCM",
  fzm = 2, nstart = 20, iter = 100)
print(FCM.TANG)

# The optimal number of cluster
FCM.TANG[which.min(FCM.TANG$TANG),]

# ---- EM algorithm ----

# Compute the TANG index
EM.TANG = TANG.IDX(scale(x), cmax = 15, cmin = 2, method = "EM",
  nstart = 20, iter = 100)
print(EM.TANG)

# The optimal number of cluster
EM.TANG[which.min(EM.TANG$TANG),]
</code></pre>

<hr>
<h2 id='WL.IDX'>
Wu and Li (WL) index
</h2><span id='topic+WL.IDX'></span>

<h3>Description</h3>

<p>Computes the WL (C. H. Wu et al., 2015) index for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WL.IDX(x, cmax, cmin = 2, method = "FCM", fzm = 2, nstart = 20, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WL.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="WL.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="WL.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="WL.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="WL.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="WL.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="WL.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The WL index is defined as <br />
</p>
<p style="text-align: center;"><code class="reqn">WL(c) = \frac{\sum_{j=1}^c\left(\frac{\sum_{i=1}^n\mu_{ij}^2\| {x}_i-{v}_j\|^2}{\sum_{i=1}^n\mu_{ij}}\right)}{min_{j \neq k}\{\| {v}_j-{v}_k\|^2\} +median_{j \neq k }\{\| {v}_j-{v}_k\|^2\}}.</code>
</p>

<p>The smallest value of <code class="reqn">WL(c)</code> indicates a valid optimal partition.<br />
</p>


<h3>Value</h3>

<table>
<tr><td><code>WL</code></td>
<td>
<p>the WL index for <code>c</code> from <code>cmin</code> to <code>cmax</code> shown in a data frame where the first and the second columns are <code>c</code> and the WL index, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>C. H. Wu, C. S. Ouyang, L. W. Chen, and L. W. Lu, “A new
fuzzy clustering validity index with a median factor for centroid-based clustering,” IEEE Transactions on Fuzzy Systems, vol. 23, no. 3, pp. 701–718, 2015.<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6811211&amp;isnumber=7115244">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6811211&amp;isnumber=7115244</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- FCM algorithm ----

# Compute the WL index
FCM.WL = WL.IDX(scale(x), cmax = 15, cmin = 2, method = "FCM",
  fzm = 2, nstart = 20, iter = 100)
print(FCM.WL)

# The optimal number of cluster
FCM.WL[which.min(FCM.WL$WL),]

# ---- EM algorithm ----

# Compute the WL index
EM.WL = WL.IDX(scale(x), cmax = 15, cmin = 2, method = "EM",
  nstart = 20, iter = 100)
print(EM.WL)

# The optimal number of cluster
EM.WL[which.min(EM.WL$WL),]
</code></pre>

<hr>
<h2 id='WP.IDX'>
Wiroonsri and Preedasawakul (WP) index
</h2><span id='topic+WP.IDX'></span>

<h3>Description</h3>

<p>Computes the WPC (WP correlation), WP, WPCI1 and WPCI2 (N. Wiroonsri and O. Preedasawakul, 2023) indexes for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WP.IDX(x, cmax, cmin = 2, corr = 'pearson', method = 'FCM', fzm = 2,
  gamma = (fzm^2*7)/4, sampling = 1, iter = 100, nstart = 20, NCstart = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WP.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="WP.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="WP.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="WP.IDX_+3A_corr">corr</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed (<code>"pearson"</code>, <code>"kendall"</code> or <code>"spearman"</code>). The default is <code>"pearson"</code>.
</p>
</td></tr>
<tr><td><code id="WP.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="WP.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="WP.IDX_+3A_gamma">gamma</code></td>
<td>
<p>adjusted fuzziness parameter for <code>indexlist</code> = (<code>"WP"</code>, <code>"WPC"</code>, <code>"WPCI1"</code>, <code>"WPCI2"</code>). The default is computed from <code class="reqn">7fzm^2/4</code>.
</p>
</td></tr>
<tr><td><code id="WP.IDX_+3A_sampling">sampling</code></td>
<td>
<p>a number greater than 0 and less than or equal to 1 indicating the undersampling proportion of data to be used. This argument is intended for handling a large dataset. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="WP.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="WP.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="WP.IDX_+3A_ncstart">NCstart</code></td>
<td>
<p>logical for <code>indexlist</code> = (<code>"WP"</code>, <code>"WPC"</code>, <code>"WPCI1"</code>,<code>"WPCI2"</code>), if <code>TRUE</code>, the WP correlation at c=1 is defined as an adjusted sd of the distances between all data points and their mean. Otherwise, the WP correlation at c=1 is defined as 0.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The newly introduced index was inspired by the recently introduced Wiroonsri index which is only compatible with hard clustering methods. <br /><br />
</p>
<p>The WPC computes the correlation between the actual distance between a pair of data points and the distance between adjusted centroids with respect to the pair. WPCI1 and WPCI2 are the proportion and the subtraction, respectively, of the same two ratios. The first ratio is the WPC improvement from <code>c-1</code> clusters to <code>c</code> clusters over the entire room for improvement. The second ratio is the WPC improvement from <code>c</code> clusters to <code>c+1</code> clusters over the entire room for improvement. <code>WP</code> is defined as a combination of <code>WPCI1</code> and <code>WPCI2</code>.<br /><br />
The largest value of <code>WP(c)</code> indicates a valid optimal partition.
</p>


<h3>Value</h3>

<table>
<tr><td><code>WPC</code></td>
<td>
<p>the WP correlations for <code>c</code> from <code>cmin-1</code> to <code>cmax+1</code> shown in a data frame where the first and the second columns are <code>c</code> and the WPC, respectively.</p>
</td></tr>
</table>
<p>Each of the followings show the value of each index for <code>c</code> from <code>cmin</code> to <code>cmax</code> in a data frame.
</p>
<table>
<tr><td><code>WP</code></td>
<td>
<p>the WP index.</p>
</td></tr>
<tr><td><code>WPCI1</code></td>
<td>
<p>the WPCI1 index.</p>
</td></tr>
<tr><td><code>WPCI2</code></td>
<td>
<p>the WPCI2 index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, &quot;A correlation-based fuzzy cluster validity index with secondary options detector,&quot; arXiv:2308.14785, 2023
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- FCM algorithm ----

# Compute all the indices by WP.IDX using default gamma
FCM.WP = WP.IDX(scale(x), cmax = 10, cmin = 2, corr = 'pearson', method = 'FCM', fzm = 2,
  iter = 100, nstart = 20, NCstart = TRUE)
print(FCM.WP$WP)

# The optimal number of cluster
FCM.WP$WP[which.max(FCM.WP$WP$WPI),]


# ---- EM algorithm ----

# Compute all the indices by WP.IDX using default gamma
EM.WP = WP.IDX(scale(x), cmax = 10, cmin = 2, corr = 'pearson', method = 'EM',
  iter = 100, nstart = 20, NCstart = TRUE)
print(EM.WP$WP)

# The optimal number of cluster
EM.WP$WP[which.max(EM.WP$WP$WPI),]
</code></pre>

<hr>
<h2 id='Wvalid'>
Wiroonsri(2024) correlation-based cluster validity indices
</h2><span id='topic+Wvalid'></span>

<h3>Description</h3>

<p>Computes the NC correlation, NCI, NCI1 and NCI2 cluster validity indices for the number of clusters from user specified <code>kmin</code> to <code>kmax</code> obtained from either K-means or hierarchical clustering based on the recent paper by Wiroonsri(2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wvalid(x, kmax, kmin = 2, method = "kmeans",
  corr = "pearson", nstart = 100, sampling = 1, NCstart = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wvalid_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="Wvalid_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="Wvalid_+3A_kmin">kmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="Wvalid_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="Wvalid_+3A_corr">corr</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed (<code>"pearson"</code>, <code>"kendall"</code> or <code>"spearman"</code>). The default is <code>"pearson"</code>.
</p>
</td></tr>
<tr><td><code id="Wvalid_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="Wvalid_+3A_sampling">sampling</code></td>
<td>
<p>a number greater than 0 and less than or equal to 1 indicating the undersampling proportion of data to be used. This argument is intended for handling a large dataset. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="Wvalid_+3A_ncstart">NCstart</code></td>
<td>
<p>logical for <code>indexlist</code> includes the <code>"NC"</code>, <code>"NCI"</code>, <code>"NCI1"</code>, and <code>"NCI2"</code>), if <code>TRUE</code>, the NC correlation at <code>k=1</code> is defined as the ratio introduced in the reference. Otherwise, it is assigned as <code>0</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NC correlation computes the correlation between an actual distance between a pair of data points and a centroid distance of clusters that the two points locate in. NCI1 and NCI2 are the proportion and the subtraction, respectively, of the same two ratios. The first ratio is the NC improvement from <code>k-1</code> clusters to <code>k</code> clusters over the entire room for improvement. The second ratio is the NC improvement from <code>k</code> clusters to <code>k+1</code> clusters over the entire room for improvement. NCI is a combination of NCI1 and NCI2.
</p>


<h3>Value</h3>

<table>
<tr><td><code>NC</code></td>
<td>
<p>the NC correlations for <code>k</code> from <code>kmin-1</code> to <code>kmax+1</code> shown in a data frame where the first and the second columns are <code>k</code> and the NC, respectively.</p>
</td></tr>
</table>
<p>Each of the followings shows the values of each index for <code>k</code> from <code>kmin</code> to <code>kmax</code> in a data frame.
</p>
<table>
<tr><td><code>NCI</code></td>
<td>
<p>the NCI index.</p>
</td></tr>
<tr><td><code>NCI1</code></td>
<td>
<p>the NCI1 index.</p>
</td></tr>
<tr><td><code>NCI2</code></td>
<td>
<p>the NCI2 index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, &quot;Clustering performance analysis using a new correlation based cluster validity index,&quot; Pattern Recognition, 145, 109910, 2024. <a href="https://doi.org/10.1016/j.patcog.2023.109910">doi:10.1016/j.patcog.2023.109910</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hvalid">Hvalid</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+DB.IDX">DB.IDX</a>,  <a href="#topic+R1_data">R1_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- Kmeans ----

# Compute all the indices by Wvalid
K.NC = Wvalid(scale(x), kmax = 15, kmin=2, method = 'kmeans',
  corr='pearson', nstart=100, NCstart = TRUE)
print(K.NC)

# The optimal number of cluster
K.NC$NCI[which.max(K.NC$NCI$NCI),]

# ---- Hierarchical ----

# Average linkage

# Compute all the indices by Wvalid
H.NC = Wvalid(scale(x), kmax = 15, kmin=2, method = 'hclust_average',
  corr='pearson', nstart=100, NCstart = TRUE)
print(H.NC)

# The optimal number of cluster
H.NC$NCI[which.max(H.NC$NCI$NCI),]
</code></pre>

<hr>
<h2 id='XB.IDX'>Xie and Beni (XB) index
</h2><span id='topic+XB.IDX'></span>

<h3>Description</h3>

<p>Computes the XB (X. L. Xie and G. Beni, 1991) index for a result of either FCM or EM clustering from user specified <code>cmin</code> to <code>cmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XB.IDX(x, cmax, cmin = 2, method = "FCM", fzm = 2, nstart = 20, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XB.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="XB.IDX_+3A_cmax">cmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="XB.IDX_+3A_cmin">cmin</code></td>
<td>
<p>a minimum number of clusters to be considered. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="XB.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="XB.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="XB.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="XB.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The XB index is defined as <br />
</p>
<p style="text-align: center;"><code class="reqn"> XB(c) = \frac{\sum_{j=1}^c\sum_{i=1}^n\mu_{ij}^2\| {x}_i-{v}_j\|^2}
             {n \cdot \min_{j\neq k} \{ \| {v}_j-{v}_k\|^2 \}}.</code>
</p>

<p>The lowest value of <code class="reqn">XB(c)</code> indicates a valid optimal partition.<br />
</p>


<h3>Value</h3>

<table>
<tr><td><code>XB</code></td>
<td>
<p>the XB index for <code>c</code> from <code>cmin</code> to <code>cmax</code> shown in a data frame where the first and the second columns are <code>c</code> and the XB index, respectively.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>X. Xie and G. Beni, “A validity measure for fuzzy clustering,” IEEE
Transactions on Pattern Analysis and Machine Intelligence, vol. 13, no. 8,
pp. 841–847, 1991.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R1_data">R1_data</a>, <a href="#topic+TANG.IDX">TANG.IDX</a>, <a href="#topic+FzzyCVIs">FzzyCVIs</a>, <a href="#topic+WP.IDX">WP.IDX</a>, <a href="#topic+Hvalid">Hvalid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(UniversalCVI)

# The data is from Wiroonsri (2024).
x = R1_data[,1:2]

# ---- FCM algorithm ----

# Compute the XB index
FCM.XB = XB.IDX(scale(x), cmax = 15, cmin = 2, method = "FCM",
  fzm = 2, nstart = 20, iter = 100)
print(FCM.XB)

# The optimal number of cluster
FCM.XB[which.min(FCM.XB$XB),]

# ---- EM algorithm ----

# Compute the XB index
EM.XB = XB.IDX(scale(x), cmax = 15, cmin = 2, method = "EM",
  nstart = 20, iter = 100)
print(EM.XB)

# The optimal number of cluster
EM.XB[which.min(EM.XB$XB),]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
