<!DOCTYPE html><html><head><title>Help for package HMP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HMP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HMP-package'><p>Hypothesis Testing and Power Calculations for Comparing Metagenomics Samples</p></a></li>
<li><a href='#Barchart.data'><p>A Graphical Representation of Taxa Proportions</p></a></li>
<li><a href='#C.alpha.multinomial'><p><code class="reqn">C(\alpha)</code> - Optimal Test for Assessing Multinomial Goodness of Fit Versus Dirichlet-Multinomial Alternative</p></a></li>
<li><a href='#Data.filter'><p>A Data Filter</p></a></li>
<li><a href='#Dirichlet.multinomial'><p>Generation of Dirichlet-Multinomial Random Samples</p></a></li>
<li><a href='#DM.MoM'><p>Method-of-Moments (MoM) Estimators of the Dirichlet-Multinomial Parameters</p></a></li>
<li><a href='#DM.Rpart'><p>Dirichlet-Multinomial RPart</p></a></li>
<li><a href='#dmrp_covars'><p>Paper Covariate Set</p></a></li>
<li><a href='#dmrp_data'><p>Paper Taxa Data Set</p></a></li>
<li><a href='#Est.PI'><p>Estimate the Pi Vector</p></a></li>
<li><a href='#formatDataSets'><p>Format Data</p></a></li>
<li><a href='#Gen.Alg'><p>Find Taxa Separating Two Groups using Genetic Algorithm (GA)</p></a></li>
<li><a href='#Gen.Alg.Consensus'><p>Find Taxa Separating Two Groups using Multiple Genetic Algorithm's (GA) Consensus</p></a></li>
<li><a href='#HMP-internal'><p>Internal Functions</p></a></li>
<li><a href='#Kullback.Leibler'><p>Kullback Leibler</p></a></li>
<li><a href='#MC.Xdc.statistics'><p>Size and Power for the Several-Sample DM Parameter Test Comparison</p></a></li>
<li><a href='#MC.Xmc.statistics'><p>Size and Power of Several Sample RAD-Probability Mean Test Comparison</p></a></li>
<li><a href='#MC.Xmcupo.statistics'><p>Size and Power of Several Sample RAD-Probability Mean Test Comparisons: Unknown Vector of Proportion</p></a></li>
<li><a href='#MC.Xoc.statistics'><p>Size and Power of Several Sample-Overdispersion Test Comparisons</p></a></li>
<li><a href='#MC.Xsc.statistics'><p>Size and Power for the One Sample RAD Probability-Mean Test Comparison</p></a></li>
<li><a href='#MC.ZT.statistics'><p>Size and Power of Goodness of Fit Test: Multinomial vs. Dirichlet-Multinomial</p></a></li>
<li><a href='#Multinomial'><p>Generation of Multinomial Random Samples</p></a></li>
<li><a href='#Plot.MDS'><p>Multidimensional Scaling Plot of Microbiome Data</p></a></li>
<li><a href='#Plot.PI'><p>Plot the Pi Vector</p></a></li>
<li><a href='#Plot.RM.Barchart'><p>Plot the Pi Vector for Repeated Measures</p></a></li>
<li><a href='#Plot.RM.Dotplot'><p>Plot the Pi Vector for Repeated Measures</p></a></li>
<li><a href='#saliva'><p>Saliva Data Set</p></a></li>
<li><a href='#Test.Paired'><p>Test Paired Data Sets</p></a></li>
<li><a href='#throat'><p>Throat Data Set</p></a></li>
<li><a href='#tongue'><p>Tongue Data Set</p></a></li>
<li><a href='#tonsils'><p>Palatine Tonsil Data Set</p></a></li>
<li><a href='#Xdc.sevsample'><p>Likelihood-Ratio-Test Statistics: Several Sample Dirichlet-Multinomial Test Comparison</p></a></li>
<li><a href='#Xmc.sevsample'><p>Generalized Wald-type Statistics: Several Sample RAD Probability-Mean Test Comparison with a Known Common Vector</p></a></li>
<li><a href='#Xmcupo.effectsize'><p>Effect Size for Xmcupo Statistic</p></a></li>
<li><a href='#Xmcupo.sevsample'><p>Generalized Wald-type Statistics: Several Sample RAD Probability-Mean Test Comparison with an Unknown Common Vector</p></a></li>
<li><a href='#Xoc.sevsample'><p>Likelihood-Ratio-Test Statistics: Several Sample Overdispersion Test Comparison</p></a></li>
<li><a href='#Xsc.onesample'><p>Generalized Wald-Type Statistics: One Sample RAD Probability-Mean Test Comparison</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hypothesis Testing and Power Calculations for Comparing
Metagenomic Samples from HMP</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-08-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Patricio S. La Rosa, Elena Deych, Sharina Carter, Berkley Shands, Dake Yang, William D. Shannon</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Berkley Shands &lt;rpackages@biorankings.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), dirmult</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, stats, foreach, doParallel, MASS, vegan, gplots,
rpart, rpart.plot, parallel, graphics, lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>Using Dirichlet-Multinomial distribution to provide several functions for formal hypothesis testing, power and sample size calculations for human microbiome experiments.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-08-29 15:38:19 UTC; Berkley</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-08-31 11:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='HMP-package'>Hypothesis Testing and Power Calculations for Comparing Metagenomics Samples</h2><span id='topic+HMP-package'></span><span id='topic+HMP'></span>

<h3>Description</h3>

<p>This package provides tools for Generating data matrices following Multinomial and Dirichlet-Multinomial distributions, 
Computing the following test-statistics and their corresponding p-values, and Computing the power and size 
of the tests described above using Monte-Carlo simulations.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
		<code class="reqn">\textbf{Hypothesis Test}</code>	</td><td style="text-align: left;"> <code class="reqn">\textbf{Test Statistics Function}</code>	</td><td style="text-align: left;"> <code class="reqn">\textbf{Power Calculation Function}</code>	</td>
</tr>
<tr>
 <td style="text-align: left;">
		2+ Sample Means w/ Reference Vector	</td><td style="text-align: left;"> <code>Xmc.sevsample</code>	</td><td style="text-align: left;"> <code>MC.Xmc.statistics</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
		1 Sample Mean w/ Reference Vector	</td><td style="text-align: left;"> <code>Xsc.onesample</code>	</td><td style="text-align: left;"> <code>MC.Xsc.statistics</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
		2+ Sample Means w/o Reference Vector	</td><td style="text-align: left;"> <code>Xmcupo.sevsample</code>	</td><td style="text-align: left;"> <code>MC.Xmcupo.statistics</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
		2+ Sample Overdispersions	</td><td style="text-align: left;"> <code>Xoc.sevsample</code>	</td><td style="text-align: left;"> <code>MC.Xoc.statistics</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
		2+ Sample DM-Distribution	</td><td style="text-align: left;"> <code>Xdc.sevsample</code>	</td><td style="text-align: left;"> <code>MC.Xdc.statistics</code>	</td>
</tr>
<tr>
 <td style="text-align: left;">
		Multinomial vs DM	</td><td style="text-align: left;"> <code>C.alpha.multinomial</code>	</td><td style="text-align: left;"> <code>MC.ZT.statistics</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>

<p>In addition to hypothesis testing and power calculations you can: <br />
</p>

<ol>
<li><p> Perform basic data management to exclude samples with fewer than pre-specified number of reads, 
collapse rare taxa and order the taxa by frequency. This is useful to exclude failed samples 
(i.e. samples with very few reads) - <code>Data.filter</code>
</p>
</li>
<li><p> Plot your data - <code>Barchart.data</code> 
</p>
</li>
<li><p> Generate random sample of Dirichlet Multinomial data with pre-specified parameters - <code>Dirichlet.multinomial</code>
</p>
</li></ol>
	
<p>Note: Thought the description of the functions refer its application to ranked abundance distributions (RAD) data, 
every function is also applicable to model species abundance data. See references for a discussion and application to both 
type of ecological data.
</p>


<h3>Author(s)</h3>

<p>Patricio S. La Rosa, Elena Deych, Berkley Shands, Sharina Carter, Dake Yang, William D. Shannon
</p>


<h3>References</h3>

<p>La Rosa PS, Brooks JP, Deych E, Boone EL, Edwards DJ, et al. (2012) Hypothesis Testing and Power Calculations for 
Taxonomic-Based Human Microbiome Data. PLoS ONE 7(12): e52078. doi:10.1371/journal.pone.0052078
</p>
<p>Yang D, Johnson J, Zhou X, Deych E, et al. (2019) Microbiome Recursive Partitioning. Currently Under Review.
</p>

<hr>
<h2 id='Barchart.data'>A Graphical Representation of Taxa Proportions</h2><span id='topic+Barchart.data'></span>

<h3>Description</h3>

<p>Creates a bar plot of taxonomic proportions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Barchart.data(data, title = "Taxa Proportions")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Barchart.data_+3A_data">data</code></td>
<td>
<p>A matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Barchart.data_+3A_title">title</code></td>
<td>
<p>A string to be used as the plots title. The default is &quot;Taxa Proportions&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bar plot of taxonomic proportions for all samples at a given taxonomic level.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	
	Barchart.data(saliva)
</code></pre>

<hr>
<h2 id='C.alpha.multinomial'><code class="reqn">C(\alpha)</code> - Optimal Test for Assessing Multinomial Goodness of Fit Versus Dirichlet-Multinomial Alternative</h2><span id='topic+C.alpha.multinomial'></span>

<h3>Description</h3>

<p>A function to compute the <code class="reqn">C(\alpha)</code>-optimal test statistics of Kim and Margolin (1992) 
for evaluating the Goodness-of-Fit of a Multinomial distribution (null hypothesis) versus a Dirichlet-Multinomial 
distribution (alternative hypothesis).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C.alpha.multinomial(data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C.alpha.multinomial_+3A_data">data</code></td>
<td>
<p>A matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to test if a set of ranked-abundance distribution(RAD) from microbiome samples can be modeled better using a multinomial or Dirichlet-Multinomial 
distribution, we test the hypothesis <code class="reqn">\mathrm{H}: \theta = 0</code> versus  <code class="reqn">\mathrm{H}: \theta \ne 0</code>, 
where the null hypothesis  implies a multinomial distribution and the alternative hypothesis  implies a DM distribution. 
Kim and Margolin (Kim and Margolin, 1992) proposed a <code class="reqn">C(\alpha)</code>-optimal test- statistics given by,
</p>
<p style="text-align: center;"><code class="reqn">T = \sum_{j=1}^{K} \sum_{i=1}^{P} \frac{1}{\sum_{i=1}^{P} x_{ij}}\left (x_{ij}-\frac{N_{i}\sum_{i=1}^{P} x_{ij}}{N_{\mathrm{g}}} \right )^2</code>
</p>
 
<p>Where <code class="reqn">K</code> is the number of taxa, <code class="reqn">P</code> is the number of samples, <code class="reqn">x_{ij}</code> is the taxon <code class="reqn">j</code>, <code class="reqn">j = 1,\ldots,K</code> from sample <code class="reqn">i</code>, 
<code class="reqn">i=1,\ldots,P</code>, <code class="reqn">N_{i}</code> is the number of reads in sample <code class="reqn">i</code>, and   <code class="reqn">N_{\mathrm{g}}</code> is the total number of reads across samples. 
</p>
<p>As the number of reads increases, the distribution of the <code class="reqn">T</code> statistic converges to a Chi-square with degrees of freedom 
equal to <code class="reqn">(P-1)(K-1)</code>, when the number of sequence reads is the same in all samples. When the number of reads is not the same in all samples, 
the distribution becomes a weighted Chi-square with a modified degree of freedom (see (Kim and Margolin, 1992) for more details).
</p>
<p>Note: Each taxa in <code>data</code> should be present in at least 1 sample, a column with all 0's may result in errors and/or invalid results.
</p>


<h3>Value</h3>

<p>A list containing the <code class="reqn">C(\alpha)</code>-optimal test statistic and p-value.</p>


<h3>References</h3>

<p>Kim, B. S., and Margolin, B. H. (1992). Testing Goodness of Fit of a Multinomial Model Against Overdispersed Alternatives. Biometrics 48, 711-719.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	
	calpha &lt;- C.alpha.multinomial(saliva)
	calpha
</code></pre>

<hr>
<h2 id='Data.filter'>A Data Filter</h2><span id='topic+Data.filter'></span>

<h3>Description</h3>

<p>This function creates a new dataset from an existing one by ordering taxa in order of decreasing abundance, 
collapsing less-abundant taxa into one category as	specified by the user and excluding samples with a 
total number of reads fewer than the user-specified value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Data.filter(data, order.type = "data", minReads = 0, numTaxa = NULL, 
		perTaxa = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Data.filter_+3A_data">data</code></td>
<td>
<p>A matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Data.filter_+3A_order.type">order.type</code></td>
<td>

<p>If <code>"sample"</code>: Rank taxa based on its taxonomic frequency. <br />
If <code>"data"</code>: Rank taxa based on cumulative taxonomic counts across all samples (default).</p>
</td></tr>
<tr><td><code id="Data.filter_+3A_minreads">minReads</code></td>
<td>
<p>Samples with a total number of reads less than read.crit value will be deleted.</p>
</td></tr>
<tr><td><code id="Data.filter_+3A_numtaxa">numTaxa</code></td>
<td>
<p>The number of taxa to keep, while collapsing the other (less abundant) taxa. 
Only one argument, numTaxa or perTaxa should be specified.</p>
</td></tr>
<tr><td><code id="Data.filter_+3A_pertaxa">perTaxa</code></td>
<td>
<p>The combined percentage of data to keep, while collapsing the remaining taxa. 
Only one argument, numTaxa or perTaxa should be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of taxa and samples with a total number of reads greater than the minimum value. The last taxon labeled 
'Other' contains the sum of the least abundant taxa collapsed by setting 'numTaxa' or 'perTaxa'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva) 
	
	### Excludes all samples with fewer than 1000 reads and collapses
	### taxa with 11th or smaller abundance into one category 
	filterDataNum &lt;- Data.filter(saliva, "data", 1000, numTaxa=10) 
	
	### Excludes all samples with fewer than 1000 reads and collapses
	### the least abundant taxa to keep as close to 95% of the data as
	### possible
	filterDataPer &lt;- Data.filter(saliva, "data", 1000, perTaxa=.95) 
	
	dim(saliva)
	dim(filterDataNum)
	dim(filterDataPer)
</code></pre>

<hr>
<h2 id='Dirichlet.multinomial'>Generation of Dirichlet-Multinomial Random Samples</h2><span id='topic+Dirichlet.multinomial'></span>

<h3>Description</h3>

<p>Random generation of Dirichlet-Multinomial samples.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dirichlet.multinomial(Nrs, shape)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dirichlet.multinomial_+3A_nrs">Nrs</code></td>
<td>
<p>A vector specifying the number of reads or sequence depth for each sample.</p>
</td></tr>
<tr><td><code id="Dirichlet.multinomial_+3A_shape">shape</code></td>
<td>
<p>A vector of Dirichlet parameters for each taxa.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dirichlet-Multinomial distribution is given by (Mosimann, J. E. (1962); Tvedebrink, T. (2010)),
</p>
<p style="text-align: center;"><code class="reqn">\textbf{P}\left ({\textbf{X}_i}=x_{i};\left \{ \pi_j \right \},\theta\right )=\frac{N_{i}!}{x_{i1} !,\ldots,x_{iK} !}\frac{\prod_{j=1}^K \prod_{r=1}^{x_{ij}} \left \{ \pi_j \left ( 1-\theta \right )+\left ( r-1 \right )\theta\right \}}{\prod_{r=1}^{N_i}\left ( 1-\theta\right )+\left ( r-1 \right) \theta}</code>
</p>

<p>where <code class="reqn">\textbf{x}_{i}= \left [ x_{i1}, \ldots, x_{iK} \right ]</code> is the random vector formed by K taxa (features) counts (RAD vector), <code class="reqn">N_{i}= \sum_{j=1}^K x_{ij}</code> is the total number of reads (sequence depth), <code class="reqn"> \left\{ \pi_j \right\}</code> are the mean of taxa-proportions (RAD-probability mean), and <code class="reqn">\theta</code> is the overdispersion parameter.
</p>
<p>Note: Though the test statistic supports an unequal number of reads across samples, the performance has not yet been fully tested.
</p>


<h3>Value</h3>

<p>A data matrix of taxa counts where the rows are samples and columns are the taxa.</p>


<h3>References</h3>

<p>Mosimann, J. E. (1962). On the compound multinomial distribution, the multivariate <code class="reqn">\beta</code>-distribution, and correlations among proportions. Biometrika 49, 65-82.<br /> 
Tvedebrink, T. (2010). Overdispersion in allelic counts and theta-correction in forensic genetics. Theor Popul Biol 78, 200-210.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	
	### Generate a the number of reads per sample
	### The first number is the number of reads and the second is the number of subjects
	nrs &lt;- rep(15000, 20) 
	
	### Get gamma from the dirichlet-multinomial parameters
	shape &lt;- dirmult(saliva)$gamma
	
	dmData &lt;- Dirichlet.multinomial(nrs, shape)
	dmData[1:5, 1:5]
</code></pre>

<hr>
<h2 id='DM.MoM'>Method-of-Moments (MoM) Estimators of the Dirichlet-Multinomial Parameters</h2><span id='topic+DM.MoM'></span>

<h3>Description</h3>

<p>Method-of-Moments (MoM) estimators of the Dirichlet-multinomial parameters: taxa proportions and overdispersion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DM.MoM(data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DM.MoM_+3A_data">data</code></td>
<td>
<p>A matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of taxa-count vectors <code class="reqn">\left\{\textbf{x}_{i},\ldots, \textbf{x}_{P} \right\}</code>,  the methods of moments (MoM) estimator of the set of parameters <code class="reqn">\theta</code> and  <code class="reqn">\left\{\pi_{j}  \right\}_{j=1}^K </code> is given as follows (Mosimann, 1962; Tvedebrink, 2010): 
</p>
<p style="text-align: center;"><code class="reqn">\hat{\pi}_{j}=\frac{\sum_{i=1}^P x_{ij}}{\sum_{i=1}^P N_{i}},</code>
</p>
<p> and 
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta} = \sum_{j=1}^K \frac{S_{j}-G_{j}}{\sum_{j=1}^{K}\left ( S_{j}+\left ( N_{c}-1 \right )G_{j} \right )},</code>
</p>

<p>where <code class="reqn">N_{c}=\left( P -1 \right)^{-1} \left(\sum_{i=1}^P N_{i}-\left (\sum_{i=1}^P N_{i}  \right )^{-1} \sum_{i=1}^P N_{i}^2\right)</code>, 
and <code class="reqn">S_{j}=\left( P -1 \right)^{-1} \sum_{i=1}^P N_{i} \left ( \hat{\pi}_{ij} -\hat{\pi}_{j} \right )^{2}</code>, 
and <code class="reqn">G_{j}=\left( \sum_{i=1}^P \left (N_i-1 \right ) \right)^{-1} \sum_{i=1}^P N_{i} \hat{\pi}_{ij} \left (1- \hat{\pi}_{ij}\right)</code> with <code class="reqn">\hat{\pi}_{ij}=\frac{x_{ij}}{N_{i}}</code>.
</p>


<h3>Value</h3>

<p>A list providing the MoM estimator for overdispersion, the MoM estimator of the RAD-probability mean vector, 
and the corresponding loglikelihood value for the given data set and estimated parameters.
</p>


<h3>References</h3>

<p>Mosimann, J. E. (1962). On the compound multinomial distribution, the multivariate <code class="reqn">\beta</code>-distribution, and correlations among proportions. Biometrika 49, 65-82. <br />
Tvedebrink, T. (2010). Overdispersion in allelic counts and theta-correction in forensic genetics. Theor Popul Biol 78, 200-210.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(throat)
	
	fit.throat &lt;- DM.MoM(throat)
	fit.throat
</code></pre>

<hr>
<h2 id='DM.Rpart'>Dirichlet-Multinomial RPart</h2><span id='topic+DM.Rpart'></span><span id='topic+DM.Rpart.Base'></span><span id='topic+DM.Rpart.CV'></span><span id='topic+DM.Rpart.CV.Consensus'></span>

<h3>Description</h3>

<p>This function combines recursive partitioning and the Dirichlet-Multinomial distribution to identify homogeneous 
subgroups of microbiome taxa count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DM.Rpart(data, covars, plot = TRUE, minsplit = 1, minbucket = 1, cp = 0, numCV = 10, 
	numCon = 100, parallel = FALSE, cores = 3, use1SE = FALSE, lowerSE = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DM.Rpart_+3A_data">data</code></td>
<td>
<p>A matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_covars">covars</code></td>
<td>
<p>A matrix of covariates(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_plot">plot</code></td>
<td>
<p>When 'TRUE' a tree plot of the results will be generated.</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimum number of observations to split on, see <a href="rpart.html#topic+rpart.control">rpart.control</a>.</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_minbucket">minbucket</code></td>
<td>
<p>The minimum number of observations in any terminal node, see <a href="rpart.html#topic+rpart.control">rpart.control</a>.</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_cp">cp</code></td>
<td>
<p>The complexity parameter, see <a href="rpart.html#topic+rpart.control">rpart.control</a>.</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_numcv">numCV</code></td>
<td>
<p>The number folds for a k-fold cross validation. A value less than 2 will return the rpart result without any cross validation.</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_numcon">numCon</code></td>
<td>
<p>The number of cross validations to repeat to achieve a consensus solution.</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_parallel">parallel</code></td>
<td>
<p>When this is 'TRUE' it allows for parallel calculation of consensus. Requires the package <code>doParallel</code>.</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_cores">cores</code></td>
<td>
<p>The number of parallel processes to run if parallel is 'TRUE'.</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_use1se">use1SE</code></td>
<td>
<p>See details.</p>
</td></tr>
<tr><td><code id="DM.Rpart_+3A_lowerse">lowerSE</code></td>
<td>
<p>See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 3 ways to run this function.  The first is setting numCV to less than 2, which will run rpart once
using the DM distribution and the specified minsplit, minbucket and cp.  This result will not have any kind 
of branch pruning and the objects returned 'fullTree' and 'bestTree' will be the same.
</p>
<p>The second way is setting numCV to 2 or greater (we recommend 10) and setting numCon to less than 2.  This will 
run rpart several times using a k-fold cross validation to prune the tree to its optimal size.  This is the best method to use.
</p>
<p>The third way is setting both numCV and numCon to 2 or greater (We recommend at least 100 for numCon).  This will
repeat the second way numCon times and build a consensus solution.  This method is ONLY needed for low sample sizes.
</p>
<p>When the argument 'use1SE' is 'FALSE', the returned object 'bestTree' is the pruned tree with the lowest MSE. 
When it is 'TRUE', 'bestTree' is either the biggest pruned tree (lowerSE = FALSE) or the smallest pruned tree (lowerSE = TRUE),
that is within 1 standard error of the lowest MSE.
</p>


<h3>Value</h3>

<p>The 3 main things returned are:
</p>
<table>
<tr><td><code>fullTree</code></td>
<td>
<p>An rpart object without any pruning.</p>
</td></tr>
<tr><td><code>bestTree</code></td>
<td>
<p>A pruned rpart object based on use1SE and lowerSE's settings.</p>
</td></tr>
<tr><td><code>cpTable</code></td>
<td>
<p>Information about the fullTree rpart object and how it splits.</p>
</td></tr>
</table>
<p>The other variables returned include surrogate/competing splits, error rates and a plot of the bestTree if plot is TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat)
	data(tonsils)
	
	### Create some covariates for our data set
	site &lt;- c(rep("Saliva", nrow(saliva)), rep("Throat", nrow(throat)), 
			rep("Tonsils", nrow(tonsils)))
	covars &lt;- data.frame(Group=site)
	
	### Combine our data into a single object
	data &lt;- rbind(saliva, throat, tonsils)
	
	### For a single rpart tree
	numCV &lt;- 0
	numCon &lt;- 0
	rpartRes &lt;- DM.Rpart(data, covars, numCV=numCV, numCon=numCon)
	
	## Not run: 
		### For a cross validated rpart tree
		numCon &lt;- 0
		rpartRes &lt;- DM.Rpart(data, covars, numCon=numCon)
		
		### For a cross validated rpart tree with consensus
		numCon &lt;- 2 # Note this is set to 2 for speed and should be at least 100
		rpartRes &lt;- DM.Rpart(data, covars, numCon=numCon)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='dmrp_covars'>Paper Covariate Set</h2><span id='topic+dmrp_covars'></span>

<h3>Description</h3>

<p>This data set is used in the paper Microbiome Recursive Partitioning 2019.  It contains 128 subjects and 11 cytokines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dmrp_covars)</code></pre>


<h3>Format</h3>

<p>The format is a data frame of 128 rows by 11 columns, with the each row being a separate subject and each column being a different cytokine.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(dmrp_covars)
</code></pre>

<hr>
<h2 id='dmrp_data'>Paper Taxa Data Set</h2><span id='topic+dmrp_data'></span>

<h3>Description</h3>

<p>This data set is used in the paper Microbiome Recursive Partitioning 2019.  It contains 128 subjects and 29 genus level taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dmrp_data)</code></pre>


<h3>Format</h3>

<p>The format is a data frame of 128 rows by 29 columns, with the each row being a separate subject and each column being a different taxa.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(dmrp_data)
</code></pre>

<hr>
<h2 id='Est.PI'>Estimate the Pi Vector</h2><span id='topic+Est.PI'></span>

<h3>Description</h3>

<p>Calculates Dirichlet-Multinomial parameters for every group using Maximum 
Likelihood and Method of Moments estimates: Taxa proportion estimates (PI vector) 
with standard errors and Confidence intervals, as well as theta values with 
standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Est.PI(group.data, conf = .95)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Est.PI_+3A_group.data">group.data</code></td>
<td>
<p>A list of matrices of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Est.PI_+3A_conf">conf</code></td>
<td>
<p>The desired confidence limits. The default is 95%</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the parameters: PI, SE and the upper/lower bounds of the confidence interval for every taxa, 
and the theta values with standard errors for both MLE and MOM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
		data(saliva)
		data(throat)
		data(tonsils)
		
		### Combine the data sets into a single list
		group.data &lt;- list(saliva, throat, tonsils)
		
		### Get PI using MLE and MOM with CI
		piEsts &lt;- Est.PI(group.data)
		
		mle &lt;- piEsts$MLE
		mom &lt;- piEsts$MOM
	
## End(Not run)
</code></pre>

<hr>
<h2 id='formatDataSets'>Format Data</h2><span id='topic+formatDataSets'></span>

<h3>Description</h3>

<p>For a list of datasets, this function finds the union of taxa across all datasets and 
transforms them such that they all have the same columns of taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatDataSets(group.data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatDataSets_+3A_group.data">group.data</code></td>
<td>
<p>A list where each element is a matrix of taxonomic counts(columns) for each sample(rows). 
Note that the row names should correspond to sample names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will also sort all the columns into the same order for every 
dataset and remove any columns that have 0's for every sample.
</p>
<p>E.g. For two datasets, any taxa present in dataset1 but not dataset2 will be 
added to dataset2 with a 0 count for all samples and vice versa.
</p>


<h3>Value</h3>

<p>The list given, but modified so every data set has the same ordering and number of columns</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat)
	
	### Set each data set to have 10 different columns
	saliva2 &lt;- saliva[,1:10]
	throat2 &lt;- throat[,11:20]
	
	### Combine the data sets into a single list
	group.data &lt;- list(saliva2, throat2)
	
	formattedData &lt;- formatDataSets(group.data)
	formattedData[[1]][1:5, 1:5]
</code></pre>

<hr>
<h2 id='Gen.Alg'>Find Taxa Separating Two Groups using Genetic Algorithm (GA)</h2><span id='topic+Gen.Alg'></span>

<h3>Description</h3>

<p>GA-Mantel is a fully multivariate method that uses a genetic algorithm to search over 
possible taxa subsets using the Mantel correlation as the scoring measure for assessing 
the quality of any given taxa subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Gen.Alg(data, covars, iters = 50, popSize = 200, earlyStop = 0, 
	dataDist = "euclidean", covarDist = "gower", verbose = FALSE, 
	plot = TRUE, minSolLen = NULL, maxSolLen = NULL, custCovDist = NULL,
	penalty = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gen.Alg_+3A_data">data</code></td>
<td>
<p>A  matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_covars">covars</code></td>
<td>
<p>A  matrix of covariates(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_iters">iters</code></td>
<td>
<p>The number of times to run through the GA.</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_popsize">popSize</code></td>
<td>
<p>The number of solutions to test on each iteration.</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_earlystop">earlyStop</code></td>
<td>

<p>The number of consecutive iterations without finding a better solution before stopping 
regardless of the number of iterations remaining. A value of '0' will prevent early 
stopping.
</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_datadist">dataDist</code></td>
<td>
<p>The distance metric to use for the data. Either &quot;euclidean&quot; or &quot;gower&quot;.</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_covardist">covarDist</code></td>
<td>
<p>The distance metric to use for the covariates. Either &quot;euclidean&quot; or &quot;gower&quot;.</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_verbose">verbose</code></td>
<td>
<p>While 'TRUE' the current status of the GA will be printed periodically.</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_plot">plot</code></td>
<td>
<p>A boolean to plot the progress of the scoring statistics by iteration.</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_minsollen">minSolLen</code></td>
<td>
<p>The minimum number of columns to select.</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_maxsollen">maxSolLen</code></td>
<td>
<p>The maximum number of columns to select.</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_custcovdist">custCovDist</code></td>
<td>
<p>A custom covariate distance matrix to use in place of calculating one from covars.</p>
</td></tr>
<tr><td><code id="Gen.Alg_+3A_penalty">penalty</code></td>
<td>
<p>A number between 0 and 1 used to penalize the solutions based on the number of selected 
taxa using the following formula: score - penalty * ((number of selected taxa)/(number of taxa)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use a GA approach to find taxa that separate subjects based on group membership or set of covariates.
</p>
<p>The data and covariates should be normalized BEFORE use with this function because of distance
functions.
</p>
<p>This function uses modified code from the rbga function in the genalg package. <a href="genalg.html#topic+rbga">rbga</a>
</p>
<p>Because the GA looks at combinations and uses the raw data, taxa with a small difference 
in their PIs may be selected and large differences may not be.
</p>
<p>The distance calculations use the vegdist package. <a href="vegan.html#topic+vegdist">vegdist</a>
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>scoreSumm</code></td>
<td>

<p>A matrix summarizing the score of the population.  This can be used to figure out if the ga has 
come to a final solution or not. This data is also plotted if plot is 'TRUE'.
</p>
</td></tr>
<tr><td><code>solutions</code></td>
<td>
<p>The final set of solutions, sorted with the highest scoring first.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>The scores for the final set of solutions.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>How long in seconds the ga took to run.</p>
</td></tr>
<tr><td><code>selected</code></td>
<td>
<p>The selected columns by name.</p>
</td></tr>
<tr><td><code>nonSelected</code></td>
<td>
<p>The columns that were NOT selected by name.</p>
</td></tr>
<tr><td><code>selectedIndex</code></td>
<td>
<p>The selected taxa by column number.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
		data(saliva)
		data(throat)
		
		### Combine the data into a single data frame
		group.data &lt;- list(saliva, throat)
		group.data &lt;- formatDataSets(group.data)
		data &lt;- do.call("rbind", group.data)
		
		### Normalize the data by subject
		dataNorm &lt;- t(apply(data, 1, function(x){x/sum(x)}))
		
		### Set covars to just be group membership
		memb &lt;- c(rep(0, nrow(saliva)), rep(1, nrow(throat)))
		covars &lt;- matrix(memb, length(memb), 1)
		
		### We use low numbers for speed. The exact numbers to use depend
		### on the data being used, but generally the higher iters and popSize 
		### the longer it will take to run.  earlyStop is then used to stop the
		### run early if the results aren't improving.
		iters &lt;- 500
		popSize &lt;- 200
		earlyStop &lt;- 250
		
		gaRes &lt;- Gen.Alg(dataNorm, covars, iters, popSize, earlyStop)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='Gen.Alg.Consensus'>Find Taxa Separating Two Groups using Multiple Genetic Algorithm's (GA) Consensus</h2><span id='topic+Gen.Alg.Consensus'></span>

<h3>Description</h3>

<p>GA-Mantel is a fully multivariate method that uses a genetic algorithm to search over 
possible taxa subsets using the Mantel correlation as the scoring measure for assessing 
the quality of any given taxa subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Gen.Alg.Consensus(data, covars, consensus = .5, numRuns = 10, 
		parallel = FALSE, cores = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gen.Alg.Consensus_+3A_data">data</code></td>
<td>
<p>A  matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Gen.Alg.Consensus_+3A_covars">covars</code></td>
<td>
<p>A  matrix of covariates(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Gen.Alg.Consensus_+3A_consensus">consensus</code></td>
<td>
<p>The required fraction (0, 1] of solutions containing an edge in order to keep it.</p>
</td></tr>
<tr><td><code id="Gen.Alg.Consensus_+3A_numruns">numRuns</code></td>
<td>

<p>Number of runs to do.  In practice the number of runs needed varies based on data set size
and the GA parameters set.
</p>
</td></tr>
<tr><td><code id="Gen.Alg.Consensus_+3A_parallel">parallel</code></td>
<td>
<p>When this is 'TRUE' it allows for parallel calculation of the bootstraps. Requires the package <code>doParallel</code>.</p>
</td></tr>
<tr><td><code id="Gen.Alg.Consensus_+3A_cores">cores</code></td>
<td>
<p>The number of parallel processes to run if parallel is 'TRUE'.</p>
</td></tr>
<tr><td><code id="Gen.Alg.Consensus_+3A_...">...</code></td>
<td>
<p>Other arguments for the GA function see <a href="#topic+Gen.Alg">Gen.Alg</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use a GA consensus approach to find taxa that separate subjects based on group membership 
or set of covariates if you cannot run the GA long enough to get a final solution.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>solutions</code></td>
<td>
<p>The best solution from each run.</p>
</td></tr>
<tr><td><code>consSol</code></td>
<td>
<p>The consensus solution.</p>
</td></tr>
<tr><td><code>selectedIndex</code></td>
<td>
<p>The selected taxa by column number.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
		data(saliva)
		data(throat)
		
		### Combine the data into a single data frame
		group.data &lt;- list(saliva, throat)
		group.data &lt;- formatDataSets(group.data)
		data &lt;- do.call("rbind", group.data)
		
		### Normalize the data by subject
		dataNorm &lt;- t(apply(data, 1, function(x){x/sum(x)}))
		
		### Set covars to just be group membership
		memb &lt;- c(rep(0, nrow(saliva)), rep(1, nrow(throat)))
		covars &lt;- matrix(memb, length(memb), 1)
		
		### We use low numbers for speed. The exact numbers to use depend
		### on the data being used, but generally the higher iters and popSize 
		### the longer it will take to run.  earlyStop is then used to stop the
		### run early if the results aren't improving.
		iters &lt;- 500
		popSize &lt;- 200
		earlyStop &lt;- 250
		numRuns &lt;- 3
		
		gaRes &lt;- Gen.Alg.Consensus(dataNorm, covars, .5, numRuns, FALSE, 3, 
				iters, popSize, earlyStop)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='HMP-internal'>Internal Functions</h2><span id='topic+HMP-internal'></span><span id='topic+loglikDM'></span><span id='topic+weirMoM'></span><span id='topic+getBC'></span><span id='topic+pioest'></span><span id='topic+gaScoring'></span><span id='topic+gaCreation'></span><span id='topic+gaPlot'></span><span id='topic+hmp.pkg.env'></span><span id='topic+rpartInit'></span><span id='topic+rpartEval'></span><span id='topic+rpartSplit'></span><span id='topic+rpartCVSingle'></span><span id='topic+rpartCV'></span><span id='topic+rpartCI'></span><span id='topic+rpartCS'></span><span id='topic+Xmcupo.statistics'></span><span id='topic+Z.statistics'></span><span id='topic+T.statistics'></span><span id='topic+Xmc.statistics'></span><span id='topic+Xsc.statistics'></span><span id='topic+Xoc.statistics'></span><span id='topic+Xdc.statistics'></span><span id='topic+Xdc.statistics.MoM'></span><span id='topic+Xmcupo.statistics.Hnull.Ha'></span><span id='topic+ZT.statistics.Hnull.Ha'></span><span id='topic+Xmc.statistics.Hnull.Ha'></span><span id='topic+Xsc.statistics.Hnull.Ha'></span><span id='topic+Xoc.statistics.Hnull.Ha'></span><span id='topic+Xdc.statistics.Hnull.Ha'></span><span id='topic+DM.Rpart.Base.Old'></span><span id='topic+rpartSplitOld'></span>

<h3>Description</h3>

<p>These files are only called from inside other functions and are therefore not documented here.</p>

<hr>
<h2 id='Kullback.Leibler'>Kullback Leibler</h2><span id='topic+Kullback.Leibler'></span><span id='topic+kullbackLeiber'></span>

<h3>Description</h3>

<p>Calculates Kullback Leibler divergence for all pairs of the datasets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Kullback.Leibler(group.data, plot = TRUE, main="Kullback Leibler Divergences", 
		parallel = FALSE, cores = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kullback.Leibler_+3A_group.data">group.data</code></td>
<td>
<p>A list where each element is a matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Kullback.Leibler_+3A_plot">plot</code></td>
<td>
<p>When 'TRUE' a heatmap of the results will also be generated.</p>
</td></tr>
<tr><td><code id="Kullback.Leibler_+3A_main">main</code></td>
<td>
<p>A string to be used as the plots title.</p>
</td></tr>
<tr><td><code id="Kullback.Leibler_+3A_parallel">parallel</code></td>
<td>
<p>When this is 'TRUE' it allows for parallel calculation of the KL distances. Requires the package <code>doParallel</code>.</p>
</td></tr>
<tr><td><code id="Kullback.Leibler_+3A_cores">cores</code></td>
<td>
<p>The number of parallel processes to run if parallel is 'TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of Kullback Leibler divergence values and a heatmap if plot is TRUE.</p>


<h3>References</h3>

<p>Kotz S, Johnson N.L (1981) Encyclopedia Of Statistical Sciences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat)
	data(tonsils)
	
	### Combine the data sets into a single list
	group.data &lt;- list(saliva, throat, tonsils)
	
	## Not run: 
		kl &lt;- Kullback.Leibler(group.data)
		kl
	
## End(Not run)
</code></pre>

<hr>
<h2 id='MC.Xdc.statistics'>Size and Power for the Several-Sample DM Parameter Test Comparison</h2><span id='topic+MC.Xdc.statistics'></span>

<h3>Description</h3>

<p>This Monte-Carlo simulation procedure provides the power and size of the several sample Dirichlet-Multinomial parameter test comparison, 
using the likelihood-ratio-test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	MC.Xdc.statistics(group.Nrs, numMC = 10, alphap, type = "ha", 
		siglev = 0.05, est = "mom")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC.Xdc.statistics_+3A_group.nrs">group.Nrs</code></td>
<td>
<p>A list specifying the number of reads/sequence depth for each sample in a group with one group per list entry.</p>
</td></tr>
<tr><td><code id="MC.Xdc.statistics_+3A_nummc">numMC</code></td>
<td>
<p>Number of Monte-Carlo experiments.  In practice this should be at least 1,000.</p>
</td></tr>
<tr><td><code id="MC.Xdc.statistics_+3A_alphap">alphap</code></td>
<td>

<p>If <code>"hnull"</code>: A matrix where rows are vectors of alpha parameters for the reference group. <br />
If <code>"ha"</code>: A matrix consisting of vectors of alpha parameters for each taxa in each group.</p>
</td></tr>
<tr><td><code id="MC.Xdc.statistics_+3A_type">type</code></td>
<td>

<p>If <code>"hnull"</code>: Computes the size of the test.<br />
If <code>"ha"</code>: Computes the power of the test. (default)</p>
</td></tr>
<tr><td><code id="MC.Xdc.statistics_+3A_siglev">siglev</code></td>
<td>
<p>Significance level for size of the test / power calculation. The default is 0.05.</p>
</td></tr>
<tr><td><code id="MC.Xdc.statistics_+3A_est">est</code></td>
<td>

<p>The type of parameter estimator to be used with the Likelihood-ratio-test statistics, 'mle' or 'mom'. Default value is 'mom'.  (See Note 2 in details)</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> Note 1: Though the test statistic supports an unequal number of reads across samples, the performance has not yet been fully tested.
</p>
</li>
<li><p> Note 2: 'mle' will take significantly longer time and may not be optimal for small sample sizes; 'mom' will provide a more conservative result in such a case.
</p>
</li>
<li><p> Note 3: All components of <code>alphap</code> should be non-zero or it may result in errors and/or invalid results.
</p>
</li></ol>



<h3>Value</h3>

<p>Size of the test statistics (under <code>"hnull"</code>) or power (under <code>"ha"</code>) of the test.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat)
	data(tonsils)
	
	### Get a list of dirichlet-multinomial parameters for the data
	fit.saliva &lt;- DM.MoM(saliva) 
	fit.throat &lt;- DM.MoM(throat)
	fit.tonsils &lt;- DM.MoM(tonsils)
	
	### Set up the number of Monte-Carlo experiments
	### We use 1 for speed, should be at least 1,000
	numMC &lt;- 1
	
	### Generate the number of reads per sample
	### The first number is the number of reads and the second is the number of subjects
	nrsGrp1 &lt;- rep(12000, 9)
	nrsGrp2 &lt;- rep(12000, 11)
	nrsGrp3 &lt;- rep(12000, 12)
	group.Nrs &lt;- list(nrsGrp1, nrsGrp2, nrsGrp3)
	
	### Computing size of the test statistics (Type I error)
	alphap &lt;- fit.saliva$gamma
	pval1 &lt;- MC.Xdc.statistics(group.Nrs, numMC, alphap, "hnull")
	pval1
	
	### Computing Power of the test statistics (Type II error)
	alphap &lt;- rbind(fit.saliva$gamma, fit.throat$gamma, fit.tonsils$gamma)
	pval2 &lt;- MC.Xdc.statistics(group.Nrs, numMC, alphap)
	pval2
</code></pre>

<hr>
<h2 id='MC.Xmc.statistics'>Size and Power of Several Sample RAD-Probability Mean Test Comparison</h2><span id='topic+MC.Xmc.statistics'></span>

<h3>Description</h3>

<p>This Monte-Carlo simulation procedure provides the power and size of the several sample RAD-probability mean test 
comparison with known reference vector of proportions, using the Generalized Wald-type statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	MC.Xmc.statistics(group.Nrs, numMC = 10, pi0, group.pi, group.theta, 
		type = "ha", siglev = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC.Xmc.statistics_+3A_group.nrs">group.Nrs</code></td>
<td>
<p>A list specifying the number of reads/sequence depth for each sample in a group with one group per list entry.</p>
</td></tr>
<tr><td><code id="MC.Xmc.statistics_+3A_nummc">numMC</code></td>
<td>
<p>Number of Monte-Carlo experiments.  In practice this should be at least 1,000.</p>
</td></tr>
<tr><td><code id="MC.Xmc.statistics_+3A_pi0">pi0</code></td>
<td>
<p>The RAD-probability mean vector.</p>
</td></tr>
<tr><td><code id="MC.Xmc.statistics_+3A_group.pi">group.pi</code></td>
<td>

<p>If <code>"hnull"</code>: This argument is ignored. <br />
If <code>"ha"</code>: A matrix where each row is a vector pi values for each group.</p>
</td></tr>
<tr><td><code id="MC.Xmc.statistics_+3A_group.theta">group.theta</code></td>
<td>
<p>A vector of overdispersion values for each group.</p>
</td></tr>
<tr><td><code id="MC.Xmc.statistics_+3A_type">type</code></td>
<td>

<p>If <code>"hnull"</code>: Computes the size of the test.<br />
If <code>"ha"</code>: Computes the power of the test. (default)</p>
</td></tr>
<tr><td><code id="MC.Xmc.statistics_+3A_siglev">siglev</code></td>
<td>
<p>Significance level for size of the test / power calculation. The default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Though the test statistic supports an unequal number of reads across samples, the performance has not yet been fully tested.
</p>


<h3>Value</h3>

<p>Size of the test statistics (under <code>"hnull"</code>) or power (under <code>"ha"</code>) of the test.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat) 
	data(tonsils)
	
	### Get a list of dirichlet-multinomial parameters for the data
	fit.saliva &lt;- DM.MoM(saliva) 
	fit.throat &lt;- DM.MoM(throat)
	fit.tonsils &lt;- DM.MoM(tonsils) 
	
	### Set up the number of Monte-Carlo experiments
	### We use 1 for speed, should be at least 1,000
	numMC &lt;- 1 
	
	### Generate the number of reads per sample
	### The first number is the number of reads and the second is the number of subjects
	nrsGrp1 &lt;- rep(12000, 9)
	nrsGrp2 &lt;- rep(12000, 11)
	group.Nrs &lt;- list(nrsGrp1, nrsGrp2)
	
	group.theta &lt;- c(0.01, 0.05)
	pi0 &lt;- fit.saliva$pi
	
	### Computing size of the test statistics (Type I error)
	pval1 &lt;- MC.Xmc.statistics(group.Nrs, numMC, pi0, group.theta=group.theta, type="hnull")
	pval1
	
	### Computing Power of the test statistics (Type II error)
	group.pi &lt;- rbind(fit.throat$pi, fit.tonsils$pi)
	pval2 &lt;- MC.Xmc.statistics(group.Nrs, numMC, pi0, group.pi, group.theta)
	pval2
</code></pre>

<hr>
<h2 id='MC.Xmcupo.statistics'>Size and Power of Several Sample RAD-Probability Mean Test Comparisons: Unknown Vector of Proportion</h2><span id='topic+MC.Xmcupo.statistics'></span>

<h3>Description</h3>

<p>This Monte-Carlo simulation procedure provides the power and size of the several sample RAD-probability mean test 
comparisons without reference vector of proportions, using the Generalized Wald-type statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	MC.Xmcupo.statistics(group.Nrs, numMC = 10, pi0, group.pi, group.theta, 
		type = "ha", siglev = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC.Xmcupo.statistics_+3A_group.nrs">group.Nrs</code></td>
<td>
<p>A list specifying the number of reads/sequence depth for each sample in a group with one group per list entry.</p>
</td></tr>
<tr><td><code id="MC.Xmcupo.statistics_+3A_nummc">numMC</code></td>
<td>
<p>Number of Monte-Carlo experiments.  In practice this should be at least 1,000.</p>
</td></tr>
<tr><td><code id="MC.Xmcupo.statistics_+3A_pi0">pi0</code></td>
<td>
<p>The RAD-probability mean vector.</p>
</td></tr>
<tr><td><code id="MC.Xmcupo.statistics_+3A_group.pi">group.pi</code></td>
<td>

<p>If <code>"hnull"</code>: This argument is ignored. <br />
If <code>"ha"</code>: A matrix where each row is a vector pi values for each group.</p>
</td></tr>
<tr><td><code id="MC.Xmcupo.statistics_+3A_group.theta">group.theta</code></td>
<td>
<p>A vector of overdispersion values for each group.</p>
</td></tr>
<tr><td><code id="MC.Xmcupo.statistics_+3A_type">type</code></td>
<td>

<p>If <code>"hnull"</code>: Computes the size of the test.<br />
If <code>"ha"</code>: Computes the power of the test. (default)</p>
</td></tr>
<tr><td><code id="MC.Xmcupo.statistics_+3A_siglev">siglev</code></td>
<td>
<p>Significance level for size of the test / power calculation. The default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Though the test statistic supports an unequal number of reads across samples, the performance has not yet been fully tested.
</p>


<h3>Value</h3>

<p>Size of the test statistics (under <code>"hnull"</code>) or power (under <code>"ha"</code>) of the test.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva) 
	data(throat) 
	data(tonsils)
	
	### Get a list of dirichlet-multinomial parameters for the data
	fit.saliva &lt;- DM.MoM(saliva) 
	fit.throat &lt;- DM.MoM(throat)
	fit.tonsils &lt;- DM.MoM(tonsils) 
	
	### Set up the number of Monte-Carlo experiments
	### We use 1 for speed, should be at least 1,000
	numMC &lt;- 1
	
	### Generate the number of reads per sample
	### The first number is the number of reads and the second is the number of subjects
	Nrs1 &lt;- rep(12000, 10)
	Nrs2 &lt;- rep(12000, 19)
	group.Nrs &lt;- list(Nrs1, Nrs2)
	
	group.theta &lt;- c(fit.throat$theta, fit.tonsils$theta)
	pi0 &lt;- fit.saliva$pi
	
	### Computing size of the test statistics (Type I error)
	pval1 &lt;- MC.Xmcupo.statistics(group.Nrs, numMC, pi0, group.theta=group.theta, type="hnull")
	pval1
	
	### Computing Power of the test statistics (Type II error)
	group.pi &lt;- rbind(fit.throat$pi, fit.tonsils$pi)
	pval2 &lt;- MC.Xmcupo.statistics(group.Nrs, numMC, group.pi=group.pi, group.theta=group.theta)
	pval2
</code></pre>

<hr>
<h2 id='MC.Xoc.statistics'>Size and Power of Several Sample-Overdispersion Test Comparisons</h2><span id='topic+MC.Xoc.statistics'></span>

<h3>Description</h3>

<p>This Monte-Carlo simulation procedure provides the power and size of the several sample-overdispersion 
test comparison, using the likelihood-ratio-test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	MC.Xoc.statistics(group.Nrs, numMC = 10, group.alphap, type = "ha", siglev = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC.Xoc.statistics_+3A_group.nrs">group.Nrs</code></td>
<td>
<p>A list specifying the number of reads/sequence depth for each sample in a group with one group per list entry.</p>
</td></tr>
<tr><td><code id="MC.Xoc.statistics_+3A_nummc">numMC</code></td>
<td>
<p>Number of Monte-Carlo experiments.  In practice this should be at least 1,000.</p>
</td></tr>
<tr><td><code id="MC.Xoc.statistics_+3A_group.alphap">group.alphap</code></td>
<td>

<p>If <code>"hnull"</code>: A vector of alpha parameters for each taxa.<br />
If <code>"ha"</code>: A list consisting of vectors of alpha parameters for each taxa.</p>
</td></tr>
<tr><td><code id="MC.Xoc.statistics_+3A_type">type</code></td>
<td>

<p>If <code>"hnull"</code>: Computes the size of the test.<br />
If <code>"ha"</code>: Computes the power of the test. (default)</p>
</td></tr>
<tr><td><code id="MC.Xoc.statistics_+3A_siglev">siglev</code></td>
<td>
<p>Significance level for size of the test / power calculation. The default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> Note 1: Though the test statistic supports an unequal number of reads across samples, the performance has not yet been fully tested.
</p>
</li>
<li><p> Note 2: All components of <code>group.alphap</code> should be non-zero or it may result in errors and/or invalid results.
</p>
</li></ol>



<h3>Value</h3>

<p>Size of the test statistics (under <code>"hnull"</code>) or power (under <code>"ha"</code>) of the test.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat)
	data(tonsils)
	
	### Get a list of dirichlet-multinomial parameters for the data
	fit.saliva &lt;- DM.MoM(saliva) 
	fit.throat &lt;- DM.MoM(throat)
	fit.tonsils &lt;- DM.MoM(tonsils)
	
	### Set up the number of Monte-Carlo experiments
	### We use 1 for speed, should be at least 1,000
	numMC &lt;- 1
	
	### Generate the number of reads per sample
	### The first number is the number of reads and the second is the number of subjects
	nrsGrp1 &lt;- rep(12000, 9)
	nrsGrp2 &lt;- rep(12000, 11)
	nrsGrp3 &lt;- rep(12000, 12)
	group.Nrs &lt;- list(nrsGrp1, nrsGrp2, nrsGrp3)
	
	### Computing size of the test statistics (Type I error)
	alphap &lt;- fit.tonsils$gamma
	pval1 &lt;- MC.Xoc.statistics(group.Nrs, numMC, alphap, "hnull")
	pval1
	
	## Not run: 
		### Computing Power of the test statistics (Type II error)
		alphap &lt;- rbind(fit.saliva$gamma, fit.throat$gamma, fit.tonsils$gamma)
		pval2 &lt;- MC.Xoc.statistics(group.Nrs, numMC, alphap, "ha")
		pval2
	
## End(Not run)
</code></pre>

<hr>
<h2 id='MC.Xsc.statistics'>Size and Power for the One Sample RAD Probability-Mean Test Comparison</h2><span id='topic+MC.Xsc.statistics'></span>

<h3>Description</h3>

<p>This Monte-Carlo simulation procedure provides the power and size of the one sample RAD probability-mean test, using the Generalized Wald-type statistic.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC.Xsc.statistics(Nrs, numMC = 10, fit, pi0 = NULL, type = "ha", siglev = 0.05)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC.Xsc.statistics_+3A_nrs">Nrs</code></td>
<td>
<p>A vector specifying the number of reads/sequence depth for each sample.</p>
</td></tr>
<tr><td><code id="MC.Xsc.statistics_+3A_nummc">numMC</code></td>
<td>
<p>Number of Monte-Carlo experiments.  In practice this should be at least 1,000.</p>
</td></tr>
<tr><td><code id="MC.Xsc.statistics_+3A_fit">fit</code></td>
<td>
<p>A list (in the format of the output of dirmult function) containing the data parameters for evaluating either the size or power of the test.</p>
</td></tr>
<tr><td><code id="MC.Xsc.statistics_+3A_pi0">pi0</code></td>
<td>
<p>The RAD-probability mean vector. If the type is set to <code>"hnull"</code> then pi0 is set by the sample in fit.</p>
</td></tr>
<tr><td><code id="MC.Xsc.statistics_+3A_type">type</code></td>
<td>

<p>If <code>"hnull"</code>: Computes the size of the test.<br />
If <code>"ha"</code>: Computes the power of the test. (default)</p>
</td></tr>
<tr><td><code id="MC.Xsc.statistics_+3A_siglev">siglev</code></td>
<td>
<p>Significance level for size of the test / power calculation. The default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Though the test statistic supports an unequal number of reads across samples, the performance has not yet been fully tested.
</p>


<h3>Value</h3>

<p>Size of the test statistics (under <code>"hnull"</code>) or power (under <code>"ha"</code>) of the test.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat) 
	data(tonsils)
	
	### Get a list of dirichlet-multinomial parameters for the data
	fit.saliva &lt;- DM.MoM(saliva) 
	fit.throat &lt;- DM.MoM(throat)
	fit.tonsils &lt;- DM.MoM(tonsils) 
	
	### Set up the number of Monte-Carlo experiments
	### We use 1 for speed, should be at least 1,000
	numMC &lt;- 1
	
	### Generate the number of reads per sample
	### The first number is the number of reads and the second is the number of subjects
	nrs &lt;- rep(15000, 25)
	
	### Computing size of the test statistics (Type I error)
	pval1 &lt;- MC.Xsc.statistics(nrs, numMC, fit.tonsils, fit.saliva$pi, "hnull")
	pval1
	
	### Computing Power of the test statistics (Type II error)
	pval2 &lt;- MC.Xsc.statistics(nrs, numMC, fit.throat, fit.tonsils$pi)
	pval2
</code></pre>

<hr>
<h2 id='MC.ZT.statistics'>Size and Power of Goodness of Fit Test: Multinomial vs. Dirichlet-Multinomial</h2><span id='topic+MC.ZT.statistics'></span>

<h3>Description</h3>

<p>This Monte-Carlo simulation procedure provides the power and size of the Multinomial vs. Dirichlet-Multinomial goodness of fit test, using the 
C(<code class="reqn">\alpha</code>)-optimal test statistics of Kim and Margolin (1992) (t statistics) and the C(<code class="reqn">\alpha</code>)-optimal test statistics of (Paul et al., 1989).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC.ZT.statistics(Nrs, numMC = 10, fit, type = "ha", siglev = 0.05)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC.ZT.statistics_+3A_nrs">Nrs</code></td>
<td>
<p>A vector specifying the number of reads/sequence depth for each sample.</p>
</td></tr>
<tr><td><code id="MC.ZT.statistics_+3A_nummc">numMC</code></td>
<td>
<p>Number of Monte-Carlo experiments.  In practice this should be at least 1,000.</p>
</td></tr>
<tr><td><code id="MC.ZT.statistics_+3A_fit">fit</code></td>
<td>
<p>A list (in the format of the output of dirmult function) containing the data parameters for evaluating either the size or power of the test.</p>
</td></tr>
<tr><td><code id="MC.ZT.statistics_+3A_type">type</code></td>
<td>

<p>If <code>"hnull"</code>: Computes the size of the test.<br />
If <code>"ha"</code>: Computes the power of the test. (default)</p>
</td></tr>
<tr><td><code id="MC.ZT.statistics_+3A_siglev">siglev</code></td>
<td>
<p>Significance level for size of the test / power calculation. The default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Though the test statistic supports an unequal number of reads across samples, the performance has not yet been fully tested.
</p>


<h3>Value</h3>

<p>A vector containing both the size of the test statistics (under <code>"hnull"</code>) or power (under <code>"ha"</code>) of the test for both the z and t statistics.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva) 
	
	### Get a list of dirichlet-multinomial parameters for the data
	fit.saliva &lt;- DM.MoM(saliva) 
	
	### Set up the number of Monte-Carlo experiments
	### We use 1 for speed, should be at least 1,000
	numMC &lt;- 1
	
	### Generate the number of reads per sample
	### The first number is the number of reads and the second is the number of subjects
	nrs &lt;- rep(15000, 25)
	
	### Computing size of the test statistics (Type I error)
	pval1 &lt;- MC.ZT.statistics(nrs, numMC, fit.saliva, "hnull") 
	pval1
	
	### Computing Power of the test statistics (Type II error)
	pval2 &lt;- MC.ZT.statistics(nrs, numMC, fit.saliva)
	pval2
</code></pre>

<hr>
<h2 id='Multinomial'>Generation of Multinomial Random Samples</h2><span id='topic+Multinomial'></span>

<h3>Description</h3>

<p>It generates a data matrix with random samples from a multinomial distribution where the rows are the samples and the columns are the taxa.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Multinomial(Nrs, probs)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Multinomial_+3A_nrs">Nrs</code></td>
<td>
<p>A vector specifying the number of reads or sequence depth for each sample.</p>
</td></tr>
<tr><td><code id="Multinomial_+3A_probs">probs</code></td>
<td>
<p>A vector specifying taxa probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Though the test statistic supports an unequal number of reads across samples, the performance has not yet been fully tested.
</p>


<h3>Value</h3>

<p>A data matrix of taxa counts where the rows are the samples and the columns are the taxa.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	### Generate the number of reads per sample
	### The first number is the number of reads and the second is the number of subjects
	nrs &lt;- rep(15000, 25)
	
	### Create a probability vector
	probs &lt;- c(0.4, 0.3, 0.2, .05, 0.04, .01)
	
	mData &lt;- Multinomial(nrs, probs)
	mData[1:5, 1:5]
</code></pre>

<hr>
<h2 id='Plot.MDS'>Multidimensional Scaling Plot of Microbiome Data</h2><span id='topic+Plot.MDS'></span>

<h3>Description</h3>

<p>Plots any number of data sets on an MDS plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.MDS(group.data, main = "Group MDS", retCords = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot.MDS_+3A_group.data">group.data</code></td>
<td>
<p>A list of matrices of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Plot.MDS_+3A_main">main</code></td>
<td>
<p>A string to be used as the plots title.</p>
</td></tr>
<tr><td><code id="Plot.MDS_+3A_retcords">retCords</code></td>
<td>
<p>A boolean to return the mds coordinates or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MDS plot and possibly the x-y coordinates for every point.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat)
	data(tonsils)
	
	### Combine the data sets into a single list
	group.data &lt;- list(saliva, throat, tonsils)
	
	Plot.MDS(group.data)
</code></pre>

<hr>
<h2 id='Plot.PI'>Plot the Pi Vector</h2><span id='topic+Plot.PI'></span>

<h3>Description</h3>

<p>Plots the taxa proportions for every group.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Plot.PI(estPi, errorBars = TRUE, logScale = FALSE, 
		main = "PI Vector", ylab = "Fractional Abundance")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot.PI_+3A_estpi">estPi</code></td>
<td>
<p>The results for either MLE or MOM from the function 'Est.Pi'.</p>
</td></tr>
<tr><td><code id="Plot.PI_+3A_errorbars">errorBars</code></td>
<td>
<p>A boolean to display the error bars or not.</p>
</td></tr>
<tr><td><code id="Plot.PI_+3A_logscale">logScale</code></td>
<td>
<p>A boolean to log the y scale or not.</p>
</td></tr>
<tr><td><code id="Plot.PI_+3A_main">main</code></td>
<td>
<p>A string to be used as the plots title.</p>
</td></tr>
<tr><td><code id="Plot.PI_+3A_ylab">ylab</code></td>
<td>
<p>A string to be used as the plots y-axis title.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the pi vectors for every group.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
		data(saliva)
		data(throat)
		data(tonsils)
		
		### Combine the data sets into a single list
		group.data &lt;- list(saliva, throat, tonsils)
		
		### Get PI using MLE with CI
		mle &lt;- Est.PI(group.data)$MLE
		
		### Plot with Error Bars
		Plot.PI(mle)
		
		### Plot without Error Bars
		Plot.PI(mle, FALSE)
		
		### Plot with Error Bars and scaling
		Plot.PI(mle, TRUE, TRUE)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='Plot.RM.Barchart'>Plot the Pi Vector for Repeated Measures</h2><span id='topic+Plot.RM.Barchart'></span>

<h3>Description</h3>

<p>Plots the taxa proportions for every group/time as a barchart.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Plot.RM.Barchart(group.data, groups, times, plotByGrp = TRUE, 
		col = NULL, conf = .95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot.RM.Barchart_+3A_group.data">group.data</code></td>
<td>
<p>A list of matrices of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Plot.RM.Barchart_+3A_groups">groups</code></td>
<td>
<p>A vector indicating group membership.</p>
</td></tr>
<tr><td><code id="Plot.RM.Barchart_+3A_times">times</code></td>
<td>
<p>A vector indicating time.</p>
</td></tr>
<tr><td><code id="Plot.RM.Barchart_+3A_plotbygrp">plotByGrp</code></td>
<td>
<p>When 'TRUE', the plot will be split by group rather than time.</p>
</td></tr>
<tr><td><code id="Plot.RM.Barchart_+3A_col">col</code></td>
<td>
<p>A vector of colors to use to denote taxa.</p>
</td></tr>
<tr><td><code id="Plot.RM.Barchart_+3A_conf">conf</code></td>
<td>
<p>The desired confidence limits. The default is 95%</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A barchart of the pi vectors for every group/time.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
		data(saliva)
		data(throat)
		
		### Reduce the size of the data
		saliva &lt;- Data.filter(saliva, numTaxa=9)
		throat &lt;- Data.filter(throat, numTaxa=9)
		
		### Get the gamma value for the data
		saliva.gamma &lt;- DM.MoM(saliva)$gamma
		throat.gamma &lt;- DM.MoM(throat)$gamma
		mid.gamma &lt;- (saliva.gamma + throat.gamma)/2
		
		### Generate a the number of reads per sample
		### The first number is the number of reads and the second is the number of subjects
		nrs &lt;- rep(10000, 20)
		
		### Create data sets to be our time series in a list
		group.data &lt;- list(
				Dirichlet.multinomial(nrs, saliva.gamma),
				Dirichlet.multinomial(nrs, saliva.gamma),
				Dirichlet.multinomial(nrs, saliva.gamma),
				Dirichlet.multinomial(nrs, saliva.gamma),
				Dirichlet.multinomial(nrs, mid.gamma),
				Dirichlet.multinomial(nrs, throat.gamma)
		)
		names(group.data) &lt;- c(
				"Group 1, Time 1", "Group 2, Time 1",
				"Group 1, Time 2", "Group 2, Time 2",
				"Group 1, Time 3", "Group 2, Time 3"
		)
		
		### Set the group and time information for each list element
		groups &lt;- c(1, 2, 1, 2, 1, 2)
		times &lt;- c(1, 2, 3, 1, 2, 3)
		
		### Plot the data by Group
		Plot.RM.Barchart(group.data, groups, times)
		
		### Plot the data by Time
		Plot.RM.Barchart(group.data, groups, times, FALSE)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='Plot.RM.Dotplot'>Plot the Pi Vector for Repeated Measures</h2><span id='topic+Plot.RM.Dotplot'></span>

<h3>Description</h3>

<p>Plots the taxa proportions for every group/time as a dot plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Plot.RM.Dotplot(group.data, groups, times, errorBars = TRUE, 
		col = NULL, conf = .95, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot.RM.Dotplot_+3A_group.data">group.data</code></td>
<td>
<p>A list of matrices of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Plot.RM.Dotplot_+3A_groups">groups</code></td>
<td>
<p>A vector indicating group membership.</p>
</td></tr>
<tr><td><code id="Plot.RM.Dotplot_+3A_times">times</code></td>
<td>
<p>A vector indicating time.</p>
</td></tr>
<tr><td><code id="Plot.RM.Dotplot_+3A_errorbars">errorBars</code></td>
<td>
<p>When 'TRUE', error bars will also be displayed.</p>
</td></tr>
<tr><td><code id="Plot.RM.Dotplot_+3A_col">col</code></td>
<td>
<p>A vector of colors to use to denote taxa.</p>
</td></tr>
<tr><td><code id="Plot.RM.Dotplot_+3A_conf">conf</code></td>
<td>
<p>The desired confidence limits. The default is 95%</p>
</td></tr>
<tr><td><code id="Plot.RM.Dotplot_+3A_alpha">alpha</code></td>
<td>
<p>The desired alpha level for the colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the pi vectors for every group/time.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
		data(saliva)
		data(throat)
		
		### Reduce the size of the data
		saliva &lt;- Data.filter(saliva, numTaxa=9)
		throat &lt;- Data.filter(throat, numTaxa=9)
		
		### Get the gamma value for the data
		saliva.gamma &lt;- DM.MoM(saliva)$gamma
		throat.gamma &lt;- DM.MoM(throat)$gamma
		mid.gamma &lt;- (saliva.gamma + throat.gamma)/2
		
		### Generate a the number of reads per sample
		### The first number is the number of reads and the second is the number of subjects
		nrs &lt;- rep(10000, 20)
		
		### Create data sets to be our time series in a list
		group.data &lt;- list(
				Dirichlet.multinomial(nrs, saliva.gamma),
				Dirichlet.multinomial(nrs, saliva.gamma),
				Dirichlet.multinomial(nrs, saliva.gamma),
				Dirichlet.multinomial(nrs, saliva.gamma),
				Dirichlet.multinomial(nrs, mid.gamma),
				Dirichlet.multinomial(nrs, throat.gamma)
		)
		names(group.data) &lt;- c(
				"Group 1, Time 1", "Group 2, Time 1",
				"Group 1, Time 2", "Group 2, Time 2",
				"Group 1, Time 3", "Group 2, Time 3"
		)
		
		### Set the group and time information for each list element
		groups &lt;- c(1, 2, 1, 2, 1, 2)
		times &lt;- c(1, 2, 3, 1, 2, 3)
		
		### Plot the data with error bars
		Plot.RM.Dotplot(group.data, groups, times)
		
		### Plot the data without error bars
		Plot.RM.Dotplot(group.data, groups, times, FALSE)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='saliva'>Saliva Data Set</h2><span id='topic+saliva'></span>

<h3>Description</h3>

<p>The saliva data set formed by the Ranked-abundance distribution vectors of 24 subjects. 
The RAD vectors contains 21 elements formed by the 20 most abundant taxa at the genus level and additional 
taxa containing the sum of the remaining less abundant taxa per sample. Note that the incorporation of the 
additional taxon (taxon 21) in the analysis allows for estimating the RAD proportional-mean of taxa with respect 
to all the taxa within the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(saliva)</code></pre>


<h3>Format</h3>

<p>The format is a matrix of 24 rows by 21 columns, with the each row being a separate subject and each column being a different taxa.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
</code></pre>

<hr>
<h2 id='Test.Paired'>Test Paired Data Sets</h2><span id='topic+Test.Paired'></span>

<h3>Description</h3>

<p>Tests two paired data sets for similarity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Test.Paired(group.data, numPerms = 1000, parallel = FALSE, cores = 3)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Test.Paired_+3A_group.data">group.data</code></td>
<td>
<p>A list of 2 matrices of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Test.Paired_+3A_numperms">numPerms</code></td>
<td>
<p>Number of permutations.  In practice this should be at least 1,000.</p>
</td></tr>
<tr><td><code id="Test.Paired_+3A_parallel">parallel</code></td>
<td>
<p>When this is 'TRUE' it allows for parallel calculation of the permutations. Requires the package <code>doParallel</code>.</p>
</td></tr>
<tr><td><code id="Test.Paired_+3A_cores">cores</code></td>
<td>
<p>The number of parallel processes to run if parallel is 'TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pvalue.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat)
	
	
	### Since saliva and throat come from same subjects, the data is paired 
	saliva1 &lt;- saliva[-24,] # Make saliva 23 subjects to match throat
	group.data &lt;- list(throat, saliva1)
	
	### We use 1 for speed, should be at least 1,000
	numPerms &lt;- 1
	
	pval &lt;- Test.Paired(group.data, numPerms)
	pval
</code></pre>

<hr>
<h2 id='throat'>Throat Data Set</h2><span id='topic+throat'></span>

<h3>Description</h3>

<p>The throat data set formed by the Ranked-abundance distribution vectors of 24 subjects. 
The RAD vectors contains 21 elements formed by the 20 most abundant taxa at the genus level and additional 
taxa containing the sum of the remaining less abundant taxa per sample. Note that the incorporation of the 
additional taxon (taxon 21) in the analysis allows for estimating the RAD proportional-mean of taxa with respect 
to all the taxa within the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(throat)</code></pre>


<h3>Format</h3>

<p>The format is a matrix of 24 rows by 21 columns, with the each row being a separate subject and each column being a different taxa.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(throat)
</code></pre>

<hr>
<h2 id='tongue'>Tongue Data Set</h2><span id='topic+tongue'></span>

<h3>Description</h3>

<p>The tongue data set formed by the Ranked-abundance distribution vectors of 24 subjects. 
The RAD vectors contains 21 elements formed by the 20 most abundant taxa at the genus level and additional 
taxa containing the sum of the remaining less abundant taxa per sample. Note that the incorporation of the 
additional taxon (taxon 21) in the analysis allows for estimating the RAD proportional-mean of taxa with respect 
to all the taxa within the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tongue)</code></pre>


<h3>Format</h3>

<p>The format is a matrix of 24 rows by 21 columns, with the each row being a separate subject and each column being a different taxa.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(tongue)
</code></pre>

<hr>
<h2 id='tonsils'>Palatine Tonsil Data Set</h2><span id='topic+tonsils'></span>

<h3>Description</h3>

<p>The palatine tonsil data set formed by the Ranked-abundance distribution vectors of 24 subjects. 
The RAD vectors contains 21 elements formed by the 20 most abundant taxa at the genus level and additional 
taxa containing the sum of the remaining less abundant taxa per sample. Note that the incorporation of the 
additional taxon (taxon 21) in the analysis allows for estimating the RAD proportional-mean of taxa with respect 
to all the taxa within the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tonsils)</code></pre>


<h3>Format</h3>

<p>The format is a matrix of 24 rows by 21 columns, with the each row being a separate subject and each column being a different taxa.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(tonsils)
</code></pre>

<hr>
<h2 id='Xdc.sevsample'>Likelihood-Ratio-Test Statistics: Several Sample Dirichlet-Multinomial Test Comparison</h2><span id='topic+Xdc.sevsample'></span>

<h3>Description</h3>

<p>This routine provides the value of the Likelihood-Ratio-Test Statistics and the corresponding p-value for evaluating the several 
sample Dirichlet-Multinomial parameter test comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xdc.sevsample(group.data, epsilon = 10^(-4), est = "mom")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xdc.sevsample_+3A_group.data">group.data</code></td>
<td>
<p>A list where each element is a matrix of taxonomic counts(columns) for each sample(rows). (See Notes 1 and 2 in details)</p>
</td></tr>
<tr><td><code id="Xdc.sevsample_+3A_epsilon">epsilon</code></td>
<td>
<p>Convergence tolerance. To terminate, the difference between two succeeding log-likelihoods must be smaller than epsilon. Default value is 10^(-4).</p>
</td></tr>
<tr><td><code id="Xdc.sevsample_+3A_est">est</code></td>
<td>

<p>The type of parameter estimator to be used with the Likelihood-ratio-test statistics, 'mle' or 'mom'. Default value is 'mom'.  (See Note 3 in details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To assess whether the Dirichlet parameter vector, <code class="reqn">\mathbf{\alpha}_{\mathrm{m}}=\mathbf{\pi}_{\mathrm{m}} \frac{1-\theta_{\mathrm{m}}}{\theta_{\mathrm{m}}}</code>(a  function of the RAD probability-mean vector  and overdispersion), observed in <code class="reqn">J</code> groups  of microbiome samples are equal to each other, the following hypothesis 
<code class="reqn">\mathrm{H}_{\mathrm{o}}: \mathbf{\alpha}_{\mathrm{1}} = \cdots =\mathbf{\alpha}_{\mathrm{m}}=\cdots= \mathbf{\alpha}_{\mathrm{J}}=\mathbf{\alpha}_{\mathrm{o}}</code> 
versus <code class="reqn">\mathrm{H}_{\mathrm{a}}:  \mathbf{\alpha}_{\mathrm{m}} \ne \mathbf{\alpha}_{\mathrm{o}}, m=1, \ldots, J</code> can be tested. The null hypothesis implies that the HMP samples across groups have the same mean and overdispersion, indicating that the RAD models are identical. In particular, the likelihood-ratio test statistic is used, which is given by, 
</p>
<p style="text-align: center;"><code class="reqn">x_{\mathrm{dc}}=-2 \log\left\{\frac{L\left(\mathbf{\alpha}_{\mathrm{o}}; \mathbf{X}_{\mathrm{1}},\ldots, \mathbf{X}_{\mathrm{J}} \right)}{L\left(\mathbf{\alpha}_{\mathrm{1}},\ldots,\mathbf{\alpha}_{\mathrm{J}}; \mathbf{X}_{\mathrm{1}},\ldots, \mathbf{X}_{\mathrm{J}} \right)}\right\}.</code>
</p>
 
<p>The asymptotic null distribution of <code class="reqn">x_{\mathrm{dc}}</code> follows a Chi-square with degrees of freedom equal to (J-1)*K, where K is the number of taxa (Wilks, 1938).
</p>

<ol>
<li><p> Note 1: The matrices in <code>group.data</code> must contain the same taxa, in the same order.
</p>
</li>
<li><p> Note 2: Each taxa should be present in at least 1 sample, a column with all 0's may result in errors and/or invalid results.
</p>
</li>
<li><p> Note 3: 'mle' will take significantly longer time and may not be optimal for small sample sizes; 'mom' will provide more conservative results in such a case.
</p>
</li></ol>



<h3>Value</h3>

<p>A list containing the Xdc statistics and p-value.</p>


<h3>References</h3>

<p>Wilks, S. S. (1938). The Large-Sample Distribution of the Likelihood Ratio for Testing Composite Hypotheses. The Annals of Mathematical Statistics 9, 60-62.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva) 
	data(throat)
	
	### Combine the data sets into a single list
	group.data &lt;- list(saliva, throat)
	
	xdc &lt;- Xdc.sevsample(group.data)
	xdc
</code></pre>

<hr>
<h2 id='Xmc.sevsample'>Generalized Wald-type Statistics: Several Sample RAD Probability-Mean Test Comparison with a Known Common Vector</h2><span id='topic+Xmc.sevsample'></span>

<h3>Description</h3>

<p>This function computes the Generalized Wald-type test statistic (Wilson and Koehler, 1984) and corresponding p-value to assess whether the sample 
RAD probability-means from multiple populations are the same or different. The statistics assumes that a common RAD probability-mean vector for comparison under the null 
hypothesis is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xmc.sevsample(group.data, pi0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xmc.sevsample_+3A_group.data">group.data</code></td>
<td>
<p>A list where each element is a matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Xmc.sevsample_+3A_pi0">pi0</code></td>
<td>
<p>The RAD-probability mean vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: The matrices in <code>group.data</code> must contain the same taxa, in the same order.</p>


<h3>Value</h3>

<p>A list containing the Generalized Wald-type statistics and p-value.</p>


<h3>References</h3>

<p>Wilson, J. R., and Koehler, K. J. (1984). Testing of equality of vectors of proportions for several cluster samples. 
Proceedings of Joint Statistical Association Meetings. Survey Research Methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva) 
	data(throat)
	data(tonsils)
	
	### Get pi from the dirichlet-multinomial parameters
	pi0 &lt;- dirmult(saliva)$pi
	
	### Combine the data sets into a single list
	group.data &lt;- list(throat, tonsils)
	
	xmc &lt;- Xmc.sevsample(group.data, pi0)
	xmc
</code></pre>

<hr>
<h2 id='Xmcupo.effectsize'>Effect Size for Xmcupo Statistic</h2><span id='topic+Xmcupo.effectsize'></span>

<h3>Description</h3>

<p>This function computes the Cramer's Phi and Modified Cramer's Phi Criterion for the test statistic <code>Xmcupo.sevsample</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xmcupo.effectsize(group.data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xmcupo.effectsize_+3A_group.data">group.data</code></td>
<td>
<p>A list where each element is a matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: The matrices in <code>group.data</code> must contain the same taxa, in the same order.</p>


<h3>Value</h3>

<p>A vector containing the Chi-Squared statistic value, the Cramer's Phi Criterion, and the modified Cramer's Phi Criterion.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat)

	### Combine the data sets into a single list
	group.data &lt;- list(saliva, throat)
	
	effect &lt;- Xmcupo.effectsize(group.data)
	effect
</code></pre>

<hr>
<h2 id='Xmcupo.sevsample'>Generalized Wald-type Statistics: Several Sample RAD Probability-Mean Test Comparison with an Unknown Common Vector</h2><span id='topic+Xmcupo.sevsample'></span>

<h3>Description</h3>

<p>This function computes the Generalized Wald-type test statistic (Wilson and Koehler, 1984) 
and corresponding p-value to assess whether the sample RAD probability-means from multiple populations are same or different. 
The statistics assumes that a common RAD probability-mean vector for comparison under the null hypothesis is unknown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xmcupo.sevsample(group.data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xmcupo.sevsample_+3A_group.data">group.data</code></td>
<td>
<p>A list where each element is a matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: The matrices in <code>group.data</code> must contain the same taxa, in the same order.</p>


<h3>Value</h3>

<p>A list containing the Generalized Wald-type statistics and p-value.</p>


<h3>References</h3>

<p>Wilson, J. R., and Koehler, K. J. (1984). Testing of equality of vectors of proportions for several cluster samples. 
Proceedings of Joint Statistical Association Meetings. Survey Research Methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva) 
	data(tonsils)
	data(throat)
	
	### Combine the data sets into a single list
	group.data &lt;- list(saliva, throat, tonsils)
	
	xmcupo &lt;- Xmcupo.sevsample(group.data)
	xmcupo
</code></pre>

<hr>
<h2 id='Xoc.sevsample'>Likelihood-Ratio-Test Statistics: Several Sample Overdispersion Test Comparison</h2><span id='topic+Xoc.sevsample'></span>

<h3>Description</h3>

<p>This routine provides the value of the likelihood-ratio-test statistic and the corresponding p-value to 
assess whether the overdispersion observed in multiple groups of microbiome samples are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xoc.sevsample(group.data, epsilon = 10^(-4))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xoc.sevsample_+3A_group.data">group.data</code></td>
<td>
<p>A list where each element is a matrix of taxonomic counts(columns) for each sample(rows). (See Notes 1 and 2 in details)</p>
</td></tr>
<tr><td><code id="Xoc.sevsample_+3A_epsilon">epsilon</code></td>
<td>
<p>Convergence tolerance. To terminate, the difference between two succeeding log-likelihoods must be smaller than epsilon. Default value is 10^(-4).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To assess whether the over dispersion parameter vectors <code class="reqn">\theta_{\mathrm{m}}</code> observed in <code class="reqn">J</code> groups of microbiome samples are equal to each other, the following hypothesis 
<code class="reqn">\mathrm{H}_{\mathrm{o}}: \theta_{\mathrm{1}} = \cdots =\theta_{\mathrm{m}} =\cdots=\theta_{\mathrm{J}}=\theta_{\mathrm{o}}</code> versus <code class="reqn">\mathrm{H}_{\mathrm{a}}: \theta_{\mathrm{m}} \ne \theta_{\mathrm{o}}, m=1, \ldots, J</code> 
can be tested. In particular, the likelihood-ratio test statistic is used (Tvedebrink, 2010), which is given by,
</p>
<p style="text-align: center;"><code class="reqn">x_{\mathrm{oc}}=-2 \log\left\{\frac{L\left(\theta_{\mathrm{o}}; \mathbf{X}_{\mathrm{1}},\ldots, \mathbf{X}_{\mathrm{J}} \right)}{L\left(\theta_{\mathrm{1}},\ldots, \theta_{\mathrm{J}}; \mathbf{X}_{\mathrm{1}},\ldots, \mathbf{X}_{\mathrm{J}} \right)}\right\} .</code>
</p>
 
<p>The asymptotic null distribution of <code class="reqn">x_{\mathrm{oc}}</code> follows a Chi-square with degrees of freedom equal to (J-1) (Wilks, 1938).
</p>

<ol>
<li><p> Note 1: The matrices in <code>group.data</code> must contain the same taxa, in the same order.
</p>
</li>
<li><p> Note 2: Each taxa should be present in at least 1 sample, a column with all 0's may result in errors and/or invalid results.
</p>
</li></ol>



<h3>Value</h3>

<p>A list containing the Xoc statistics and p-value.</p>


<h3>References</h3>

<p>Tvedebrink, T. (2010). Overdispersion in allelic counts and theta-correction in forensic genetics. Theor Popul Biol 78, 200-210. <br />
Wilks, S. S. (1938). The Large-Sample Distribution of the Likelihood Ratio for Testing Composite Hypotheses. The Annals of Mathematical Statistics 9, 60-62.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva) 
	data(tonsils)
	
	### Combine the data sets into a single list
	group.data &lt;- list(saliva, tonsils)
	
	## Not run: 
		xoc &lt;- Xoc.sevsample(group.data)
		xoc
	
## End(Not run)
</code></pre>

<hr>
<h2 id='Xsc.onesample'>Generalized Wald-Type Statistics: One Sample RAD Probability-Mean Test Comparison</h2><span id='topic+Xsc.onesample'></span>

<h3>Description</h3>

<p>This routine provides the value of the Generalized Wald-type statistic to assess whether the RAD probability-mean observed in 
one group of samples is equal to a known RAD probability-mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xsc.onesample(data, pi0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xsc.onesample_+3A_data">data</code></td>
<td>
<p>A matrix of taxonomic counts(columns) for each sample(rows).</p>
</td></tr>
<tr><td><code id="Xsc.onesample_+3A_pi0">pi0</code></td>
<td>
<p>The RAD-probability mean vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing Generalized Wald-type statistics and p-value.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(saliva)
	data(throat)
	
	### Get pi from the dirichlet-multinomial parameters
	pi0 &lt;- dirmult(saliva)$pi
	
	xsc &lt;- Xsc.onesample(throat, pi0)
	xsc
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
