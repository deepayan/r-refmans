<!DOCTYPE html><html><head><title>Help for package leastcostpath</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {leastcostpath}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_dem_error'><p>Incorporate vertical error into a Digital Elevation Model</p></a></li>
<li><a href='#add_global_stochasticity'><p>Add global stochasticity to a conductanceMatrix</p></a></li>
<li><a href='#buffer_validation'><p>Calculate the similarity of a least-cost path to a known route</p></a></li>
<li><a href='#calculate_distance'><p>calculate distance between adjacent cells</p></a></li>
<li><a href='#check_locations'><p>check supplied locations</p></a></li>
<li><a href='#create_accum_cost'><p>creates an accumulated cost surface</p></a></li>
<li><a href='#create_cost_corridor'><p>creates a cost corridor</p></a></li>
<li><a href='#create_cs'><p>Creates a cost surface from a SpatRaster</p></a></li>
<li><a href='#create_distance_cs'><p>Creates a distance-based conductance matrix</p></a></li>
<li><a href='#create_FETE_lcps'><p>Calculate Least-cost Paths from each location to all other locations</p></a></li>
<li><a href='#create_lcp'><p>Calculate Least-cost Path from Origin to Destinations</p></a></li>
<li><a href='#create_lcp_density'><p>creates a cumulative least-cost path raster</p></a></li>
<li><a href='#create_slope_cs'><p>Creates a slope-based cost surface</p></a></li>
<li><a href='#crop_cs'><p>Crop conductanceMatrix to extent</p></a></li>
<li><a href='#force_isotropy'><p>Coerce an anisotropic cost surface to an isotropic cost surface</p></a></li>
<li><a href='#get_coordinates'><p>get coordinates from a variety of different object classes</p></a></li>
<li><a href='#neighbourhood'><p>neighbourhood matrix to represent adjacent cells</p></a></li>
<li><a href='#PDI_validation'><p>Calculate the similarity of a least-cost path to a known route</p></a></li>
<li><a href='#plot.conductanceMatrix'><p>plot conductanceMatrix</p></a></li>
<li><a href='#rasterise'><p>converts conductanceMatrix to SpatRaster</p></a></li>
<li><a href='#replace_values'><p>replace values with values from another object</p></a></li>
<li><a href='#update_values'><p>update values in a conductanceMatrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Modelling Pathways and Movement Potential Within a Landscape</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.12</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-09</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph Lewis &lt;josephlewis1992@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td>Available at: <a href="https://CRAN.R-project.org/package=leastcostpath">https://CRAN.R-project.org/package=leastcostpath</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates cost surfaces based on slope to be used when modelling pathways and movement potential within a landscape (Lewis, 2021) &lt;<a href="https://doi.org/10.1007%2Fs10816-021-09522-w">doi:10.1007/s10816-021-09522-w</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>terra (&ge; 1.5-34), sf (&ge; 1.0-8), igraph (&ge; 1.3.0), foreach
(&ge; 1.5.2), gstat (&ge; 2.0-9), methods, stats, Matrix (&ge;
1.4-1), parallel, doParallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-09 21:00:40 UTC; Joe</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Lewis [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-09 22:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_dem_error'>Incorporate vertical error into a Digital Elevation Model</h2><span id='topic+add_dem_error'></span>

<h3>Description</h3>

<p>Incorporate vertical error into a Digital Elevation Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dem_error(x, rmse, type = "u", samples = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_dem_error_+3A_x">x</code></td>
<td>
<p><code>spatRaster</code></p>
</td></tr>
<tr><td><code id="add_dem_error_+3A_rmse">rmse</code></td>
<td>
<p><code>numeric</code>. Vertical Root Mean Square Error of the Digital Elevation Model</p>
</td></tr>
<tr><td><code id="add_dem_error_+3A_type">type</code></td>
<td>
<p><code>character</code> type 'u' (unfiltered), 'n' (neighbourhood autocorrelation), and 'd' (mean spatial dependence) implemented. See details for more information</p>
</td></tr>
<tr><td><code id="add_dem_error_+3A_samples">samples</code></td>
<td>
<p><code>numeric</code> number of random spatial data locations sampled when using type 'd'. This can be used to overcome issues with computing time and memory limits</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Digital Elevation Models (DEMs) are representations of the earth's surface and are subject to error (Wechsler and Kroll, 2006)
</p>
<p>The add_dem_error function incorporates vertical error into the supplied DEM. Three methods are implemented:
</p>
<p>Unfiltered: Random error based on DEM RMSE range. Autocorrelation between random error is not accounted for. This can be interpreted as the worst case scenario
</p>
<p>Neighbourhood autocorrelation: Random error is spatially autocorrelated by passing a mean low pass filter in a 3x3 neighbourhood over the surface
</p>
<p>Mean Spatial Dependence: Random error is spatially autocorrelated by passing a DxD kernel over each cell. The centre cell of each kernel is replaced by the mean of the surrounding DxD cells. Distance of spatial dependence (D) is estimated by calcualting the semi-variogram nugget using the gstat package  
</p>
<p>Examples of RMSE for various datasets:
</p>
<p>Shuttle Radar Topography Mission (SRTM) has a RMSE of 9.73m
</p>
<p>Advanced Spaceborne Thermal Emission and Reflection Radiometer (ASTER) Global Digital Elevation Model (GDEM) has a RMSE of 10.20m
</p>
<p>Ordnance Survey OS Terrain 5 has a maximum RMSE of 2.5m
</p>
<p>Ordnance Survey OS Terrain 50 has a maximum RMSE of 4m
</p>
<p>TINITALY DEM has a RMSE of 4.3m
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>References</h3>

<p>Wechsler, S. P., &amp; Kroll, C. N. (2006). Quantifying DEM Uncertainty and its Effect on Topographic Parameters. Photogrammetric Engineering &amp; Remote Sensing, 72(9), 1081-1090. https://doi.org/10.14358/PERS.72.9.1081
</p>
<p>Fisher, P., &amp; Tate, N. J. (2006). Causes and consequences of error in digital elevation models. Progress in Physical Geography: Earth and Environment, 30(4), 467-489. https://doi.org/10.1191/0309133306pp492ra
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

r2 &lt;- add_dem_error(x = r, rmse = 4.3, type = "u")
</code></pre>

<hr>
<h2 id='add_global_stochasticity'>Add global stochasticity to a conductanceMatrix</h2><span id='topic+add_global_stochasticity'></span>

<h3>Description</h3>

<p>Add stochasticity to a conductanceMatrix based on a global value. This method is based on 'Multiple shortest paths (MSPs)' as proposed by Pinto and Keitt (2009)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_global_stochasticity(x, percent_quantile = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_global_stochasticity_+3A_x">x</code></td>
<td>
<p><code>conductanceMatrix</code></p>
</td></tr>
<tr><td><code id="add_global_stochasticity_+3A_percent_quantile">percent_quantile</code></td>
<td>
<p><code>numeric</code> value between 0 and 1. See details for more information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The add_global_stochasticity to a conductanceMatrix is based on the method proposed by Pinto and Keitt (2009). Rather than using a static neighbourhood (for example as supplied in the neighbours function in the create_slope_cs), the neighbourhood is redefined such that the adjacency is non-deterministic and is instead determined randomly based on the threshold value.
</p>
<p>The algorithm proceeds as follows:
</p>
<p>1. With a percent_quantile supplied, draw a random value between the minimum value in the conductanceMatrix and the supplied percent quantile
</p>
<p>2. Replace values in conductanceMatrix below this random value with 0. This ensures that the conductance between the neighbours are 0, and thus deemed non-adjacent
</p>
<p>Supplying a percent_quantile of 0 is equivalent to incorporating no stochasticity into the conductanceMatrix. That is, if the supplied percent_quantile is 0, then no values are below this value and thus no values will be replaced with 0 (see step 2). This therefore does not change the neigbourhood adjacency
</p>
<p>The closer the percent_quantile is to 0, the less stochasticity is incorporated. For example, a percent_quantile value of 0.2 will result in the threshold being a random value between the minimum value in the conductanceMatrix and the 0.2 percent quantile of the values in the conductanceMatrix. All values in the conductanceMatrix below the random value will be replaced with 0 (i.e. the neighbours are no longer adjacent). In contrast, a percent_quantile value of 0.8 will result in the threshold being a random value between the minimum value in the conductanceMatrix and the 0.8 percent quantile of the values in the conductanceMatrix. In this case, there is greater probability that the random value will result in an increased number of values in the conductanceMatrix being replaced with 0.
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>References</h3>

<p>Pinto, N., &amp; Keitt, T. H. (2009). Beyond the least-cost path: evaluating corridor redundancy using a graph-theoretic approach. Landscape Ecology, 24(2), 253-266. https://doi.org/10.1007/s10980-008-9303-y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

slope_cs2 &lt;- add_global_stochasticity(slope_cs, percent_quantile = 0.2)
</code></pre>

<hr>
<h2 id='buffer_validation'>Calculate the similarity of a least-cost path to a known route</h2><span id='topic+buffer_validation'></span>

<h3>Description</h3>

<p>Calculates the similarity of a least-cost path to a known route using the buffer method proposed by Goodchild and Hunter (1997)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buffer_validation(lcp, comparison, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buffer_validation_+3A_lcp">lcp</code></td>
<td>
<p><code>sf</code> or <code>spatVector</code></p>
</td></tr>
<tr><td><code id="buffer_validation_+3A_comparison">comparison</code></td>
<td>
<p><code>sf</code> or <code>spatVector</code></p>
</td></tr>
<tr><td><code id="buffer_validation_+3A_dist">dist</code></td>
<td>
<p><code>numeric</code> buffer distances to assess similarity</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

locs &lt;- sf::st_sf(geometry = sf::st_sfc(
sf::st_point(c(839769, 4199443)),
sf::st_point(c(1038608, 4100024)),
crs = terra::crs(r)))

lcp1 &lt;- create_lcp(x = slope_cs, origin = locs[1,], destination = locs[2,])

lcp2 &lt;- create_lcp(x = slope_cs, origin = locs[2,], destination = locs[1,])

buffer_validation(lcp = lcp1, comparison = lcp2, dist = c(1000, 2500, 5000, 10000))
</code></pre>

<hr>
<h2 id='calculate_distance'>calculate distance between adjacent cells</h2><span id='topic+calculate_distance'></span>

<h3>Description</h3>

<p>calculate distance between adjacent cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_distance(x, adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_distance_+3A_x">x</code></td>
<td>
<p><code>spatRaster</code></p>
</td></tr>
<tr><td><code id="calculate_distance_+3A_adj">adj</code></td>
<td>
<p><code>matrix</code> of adjacent cells</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calculate_distance function allows for both projected and geographic coordinate systems. If the coordinate system is geographic (e.g. wgs84) the distance is calculated using the sf::st_distance function else distance calculated using Pythagorean theorem
</p>


<h3>Value</h3>

<p><code>matrix</code> euclidean distances between adjacent cells
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>

<hr>
<h2 id='check_locations'>check supplied locations</h2><span id='topic+check_locations'></span>

<h3>Description</h3>

<p>checks that locations can be reached when calculating least-cost paths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_locations(x, locations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_locations_+3A_x">x</code></td>
<td>
<p><code>conductanceMatrix</code></p>
</td></tr>
<tr><td><code id="check_locations_+3A_locations">locations</code></td>
<td>
<p><code>sf</code> 'POINT' or 'MULTIPOINT', <code>SpatVector</code>, <code>data.frame</code> or <code>matrix</code> containing the locations coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the supplied conductanceMatrix and locations, the function checks whether:
(1) the supplied locations are traversable from at least one adjacent cell
(2) the supplied locations are within the extent of the supplied conductanceMatrix
</p>


<h3>Value</h3>

<p><code>message</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler")

locs &lt;- sf::st_sf(geometry = sf::st_sfc(
sf::st_point(c(861534, 4173726)),
sf::st_point(c(897360, 4155813)),
sf::st_point(c(928364, 4138588)),
crs = terra::crs(r)))

check_locations(x = slope_cs, locations = locs)
</code></pre>

<hr>
<h2 id='create_accum_cost'>creates an accumulated cost surface</h2><span id='topic+create_accum_cost'></span>

<h3>Description</h3>

<p>Creates an accumulated cost surfaces from one or more origins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_accum_cost(
  x,
  origins,
  FUN = mean,
  rescale = FALSE,
  check_locations = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_accum_cost_+3A_x">x</code></td>
<td>
<p><code>SpatRaster</code></p>
</td></tr>
<tr><td><code id="create_accum_cost_+3A_origins">origins</code></td>
<td>
<p><code>sf</code> 'POINT' or 'MULTIPOINT', <code>SpatVector</code>, <code>data.frame</code> or <code>matrix</code> containing the origins coordinates. If multiple origins are supplied then the multiple accumulated cost surfaces will be summarised using the FUN argument</p>
</td></tr>
<tr><td><code id="create_accum_cost_+3A_fun">FUN</code></td>
<td>
<p><code>function</code> Apply a function to the cells of a SpatRaster. Default applied function is 'mean'. See terra::app() for more information</p>
</td></tr>
<tr><td><code id="create_accum_cost_+3A_rescale">rescale</code></td>
<td>
<p><code>logical</code>. if TRUE, values scaled to between 0 and 1. FALSE (default)</p>
</td></tr>
<tr><td><code id="create_accum_cost_+3A_check_locations">check_locations</code></td>
<td>
<p><code>logical</code> if TRUE checks if origins are traversable. FALSE (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatRaster</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

locs &lt;- sf::st_sf(geometry = sf::st_sfc(
sf::st_point(c(839769, 4199443)),
sf::st_point(c(1038608, 4100024)),
sf::st_point(c(907695, 4145478)),
crs = terra::crs(r)))

cc &lt;- create_accum_cost(x = slope_cs, origins = locs, FUN = mean, rescale = FALSE)
</code></pre>

<hr>
<h2 id='create_cost_corridor'>creates a cost corridor</h2><span id='topic+create_cost_corridor'></span>

<h3>Description</h3>

<p>Combines and averages the accumulated cost surfaces from origin-to-destination and destination-to-origin to identify areas of preferential movement that takes into account both directions of movement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_cost_corridor(x, origin, destination, rescale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_cost_corridor_+3A_x">x</code></td>
<td>
<p><code>SpatRaster</code></p>
</td></tr>
<tr><td><code id="create_cost_corridor_+3A_origin">origin</code></td>
<td>
<p><code>sf</code> 'POINT' or 'MULTIPOINT', <code>SpatVector</code>, <code>data.frame</code> or <code>matrix</code> containing the origin coordinates. Only the first row of the supplied object is used as the origin.</p>
</td></tr>
<tr><td><code id="create_cost_corridor_+3A_destination">destination</code></td>
<td>
<p><code>sf</code> 'POINT' or 'MULTIPOINT', <code>SpatVector</code>, <code>data.frame</code> or <code>matrix</code> containing the destination coordinates.  Only the first row of the supplied object is used as the destination.</p>
</td></tr>
<tr><td><code id="create_cost_corridor_+3A_rescale">rescale</code></td>
<td>
<p><code>logical</code>. if TRUE, values scaled to between 0 and 1. FALSE (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatRaster</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

locs &lt;- sf::st_sf(geometry = sf::st_sfc(
sf::st_point(c(839769, 4199443)),
sf::st_point(c(1038608, 4100024)),
crs = terra::crs(r)))

cc &lt;- create_cost_corridor(x = slope_cs, origin = locs[1,], destination = locs[2,], rescale = TRUE)
</code></pre>

<hr>
<h2 id='create_cs'>Creates a cost surface from a SpatRaster</h2><span id='topic+create_cs'></span>

<h3>Description</h3>

<p>Creates a cost surface using the values in the supplied SpatRaster. This function also provides for the inclusion of maximum slope traversable
</p>
<p>The supplied 'spatRaster' object must have a projected CRS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_cs(
  x,
  neighbours = 16,
  dem = NULL,
  max_slope = NULL,
  exaggeration = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_cs_+3A_x">x</code></td>
<td>
<p><code>SpatRaster</code></p>
</td></tr>
<tr><td><code id="create_cs_+3A_neighbours">neighbours</code></td>
<td>
<p><code>numeric</code> value. Number of directions used in the conductance matrix calculation. Expected numeric values are 4, 8, 16, 32, 48, or matrix object. 16 (default)</p>
</td></tr>
<tr><td><code id="create_cs_+3A_dem">dem</code></td>
<td>
<p><code>SpatRaster</code> Digital Elevation Model (DEM)</p>
</td></tr>
<tr><td><code id="create_cs_+3A_max_slope">max_slope</code></td>
<td>
<p><code>numeric</code> value. Maximum percentage slope that is traversable. Slope values that are greater than the specified max_slope are given a conductivity value of 0. If cost_function argument is 'campbell 2019' then max_slope is fixed at 30 degrees slope to reflect the maximum slope that the cost function is parametised to. NULL (default)</p>
</td></tr>
<tr><td><code id="create_cs_+3A_exaggeration">exaggeration</code></td>
<td>
<p><code>logical</code>. if TRUE, positive slope values (up-hill movement) multiplied by 1.99 and negative slope values (down-hill movement) multiplied by 2.31</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>conductanceMatrix</code> that numerically expresses the difficulty of moving across a surface based on the provided SpatRaster
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

cs1 &lt;- create_cs(x = r, neighbours = 16, dem = NULL, max_slope = NULL)
cs2 &lt;- create_cs(x = r, neighbours = 16, dem = r, max_slope = 10)
</code></pre>

<hr>
<h2 id='create_distance_cs'>Creates a distance-based conductance matrix</h2><span id='topic+create_distance_cs'></span>

<h3>Description</h3>

<p>Creates a conductance matrix based on the distance between neighbouring cells. Distance corrected for if neighbours value is greater than 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_distance_cs(x, neighbours = 16, max_slope = NULL, exaggeration = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_distance_cs_+3A_x">x</code></td>
<td>
<p><code>SpatRaster</code>. Digital Elevation Model (DEM)</p>
</td></tr>
<tr><td><code id="create_distance_cs_+3A_neighbours">neighbours</code></td>
<td>
<p><code>numeric</code> value. Number of directions used in the conductance matrix calculation. Expected numeric values are 4, 8, 16, 32, 48, or matrix object. 16 (default)</p>
</td></tr>
<tr><td><code id="create_distance_cs_+3A_max_slope">max_slope</code></td>
<td>
<p><code>numeric</code> value. Maximum percentage slope that is traversable. Slope values that are greater than the specified max_slope are given a conductivity value of 0. If cost_function argument is 'campbell 2019' then max_slope is fixed at 30 degrees slope to reflect the maximum slope that the cost function is parametised to. NULL (default)</p>
</td></tr>
<tr><td><code id="create_distance_cs_+3A_exaggeration">exaggeration</code></td>
<td>
<p><code>logical</code>. if TRUE, positive slope values (up-hill movement) multiplied by 1.99 and negative slope values (down-hill movement) multiplied by 2.31</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>conductanceMatrix</code> that numerically expresses the difficulty of moving across slope based on the provided cost function
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

distance_cs &lt;- create_distance_cs(x = r, neighbours = 4)
</code></pre>

<hr>
<h2 id='create_FETE_lcps'>Calculate Least-cost Paths from each location to all other locations</h2><span id='topic+create_FETE_lcps'></span>

<h3>Description</h3>

<p>Calculates Least-cost paths from-everywhere-to-everywhere. This is based on the approach proposed by White and Barber (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_FETE_lcps(x, locations, cost_distance = FALSE, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_FETE_lcps_+3A_x">x</code></td>
<td>
<p><code>conductanceMatrix</code></p>
</td></tr>
<tr><td><code id="create_FETE_lcps_+3A_locations">locations</code></td>
<td>
<p><code>sf</code> 'POINT' or 'MULTIPOINT', <code>SpatVector</code>, <code>data.frame</code> or <code>matrix</code> containing the locations coordinates</p>
</td></tr>
<tr><td><code id="create_FETE_lcps_+3A_cost_distance">cost_distance</code></td>
<td>
<p><code>logical</code> if TRUE computes total accumulated cost from origin to destination. FALSE (default)</p>
</td></tr>
<tr><td><code id="create_FETE_lcps_+3A_ncores">ncores</code></td>
<td>
<p><code>numeric</code> Number of cores used when calculating least-cost paths from-everywhere-to-everywhere. 1 (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> or <code>spatVector</code> Least-cost paths from-everywhere-to-everywhere based on the supplied <code>conductanceMatrix</code>. If supplied <code>locations</code> is a <code>spatVector</code> object then <code>spatVector</code> object returned else <code>sf</code> object
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

locs &lt;- sf::st_sf(geometry = sf::st_sfc(
sf::st_point(c(839769, 4199443)),
sf::st_point(c(1038608, 4100024)),
sf::st_point(c(907695, 4145478)),
sf::st_point(c(907695, 4145478)),
crs = terra::crs(r)))

lcps &lt;- create_FETE_lcps(x = slope_cs, locations = locs)
</code></pre>

<hr>
<h2 id='create_lcp'>Calculate Least-cost Path from Origin to Destinations</h2><span id='topic+create_lcp'></span>

<h3>Description</h3>

<p>Calculates the Least-cost path from an origin location to one or more destination locations. Applies Dijkstra's algorithm as implemented in the igraph R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_lcp(
  x,
  origin,
  destination,
  cost_distance = FALSE,
  check_locations = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_lcp_+3A_x">x</code></td>
<td>
<p><code>conductanceMatrix</code></p>
</td></tr>
<tr><td><code id="create_lcp_+3A_origin">origin</code></td>
<td>
<p><code>sf</code> 'POINT' or 'MULTIPOINT', <code>SpatVector</code>, <code>data.frame</code> or <code>matrix</code> containing the origin coordinates. Only the first row of the supplied object is used as the origin.</p>
</td></tr>
<tr><td><code id="create_lcp_+3A_destination">destination</code></td>
<td>
<p><code>sf</code> 'POINT' or 'MULTIPOINT', <code>SpatVector</code>, <code>data.frame</code> or <code>matrix</code> containing the destination coordinates. If the object contains multiple coordinates then least-cost paths will be calculated from the origin to all destinations</p>
</td></tr>
<tr><td><code id="create_lcp_+3A_cost_distance">cost_distance</code></td>
<td>
<p><code>logical</code> if TRUE computes total accumulated cost from origin to the destinations. FALSE (default)</p>
</td></tr>
<tr><td><code id="create_lcp_+3A_check_locations">check_locations</code></td>
<td>
<p><code>logical</code> if TRUE checks if origin and destination are traversable by the least-cost path. FALSE (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code>  Least-cost path from origin and destinations based on the supplied <code>conductanceMatrix</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

locs &lt;- sf::st_sf(geometry = sf::st_sfc(
sf::st_point(c(839769, 4199443)),
sf::st_point(c(1038608, 4100024)),
sf::st_point(c(1017819, 4206255)),
sf::st_point(c(1017819, 4206255)),
crs = terra::crs(r)))

lcps &lt;- create_lcp(x = slope_cs, origin = locs[1,], destination = locs)
</code></pre>

<hr>
<h2 id='create_lcp_density'>creates a cumulative least-cost path raster</h2><span id='topic+create_lcp_density'></span>

<h3>Description</h3>

<p>Cumulatively combines least-cost paths to idenify routes of preferential movement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_lcp_density(x, lcps, rescale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_lcp_density_+3A_x">x</code></td>
<td>
<p><code>SpatRaster</code></p>
</td></tr>
<tr><td><code id="create_lcp_density_+3A_lcps">lcps</code></td>
<td>
<p><code>sf</code> or <code>spatVector</code></p>
</td></tr>
<tr><td><code id="create_lcp_density_+3A_rescale">rescale</code></td>
<td>
<p><code>logical</code>. if TRUE, values scaled to between 0 and 1. FALSE (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatRaster</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

locs &lt;- sf::st_sf(geometry = sf::st_sfc(
sf::st_point(c(839769, 4199443)),
sf::st_point(c(1038608, 4100024)),
sf::st_point(c(907695, 4145478)),
crs = terra::crs(r)))

lcps &lt;- create_FETE_lcps(x = slope_cs, locations = locs)

lcps_dens &lt;- create_lcp_density(x = r, lcps = lcps)
</code></pre>

<hr>
<h2 id='create_slope_cs'>Creates a slope-based cost surface</h2><span id='topic+create_slope_cs'></span>

<h3>Description</h3>

<p>Creates a cost surface based on the difficulty of moving up and down slope. This function implements multiple isotropic and anisotropic cost functions that estimate the 'cost' of human movement when traversing a landscape
</p>
<p>The supplied 'spatRaster' object can have a projected or geographic coordinate system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_slope_cs(
  x,
  cost_function = "tobler",
  neighbours = 16,
  crit_slope = 12,
  max_slope = NULL,
  exaggeration = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_slope_cs_+3A_x">x</code></td>
<td>
<p><code>SpatRaster</code> Digital Elevation Model (DEM)</p>
</td></tr>
<tr><td><code id="create_slope_cs_+3A_cost_function">cost_function</code></td>
<td>
<p><code>character</code> or <code>function</code>. Cost function applied to slope values. See details for implemented cost functions. tobler (default)</p>
</td></tr>
<tr><td><code id="create_slope_cs_+3A_neighbours">neighbours</code></td>
<td>
<p><code>numeric</code> value. Number of directions used in the conductance matrix calculation. Expected numeric values are 4, 8, 16, 32, 48, or matrix object. 16 (default)</p>
</td></tr>
<tr><td><code id="create_slope_cs_+3A_crit_slope">crit_slope</code></td>
<td>
<p><code>numeric</code> value. Critical Slope (in percentage) is 'the transition where switchbacks become more effective than direct uphill or downhill paths'. Cost of climbing the critical slope is twice as high as those for moving on flat terrain and is used for estimating the cost of using wheeled vehicles. Default value is 12, which is the postulated maximum gradient traversable by ancient transport (Verhagen and Jeneson, 2012). Critical slope only used in 'wheeled transport' cost function</p>
</td></tr>
<tr><td><code id="create_slope_cs_+3A_max_slope">max_slope</code></td>
<td>
<p><code>numeric</code> value. Maximum percentage slope that is traversable. Slope values that are greater than the specified max_slope are given a conductivity value of 0. If cost_function argument is 'campbell 2019' or 'campbell' then max_slope is fixed at 30 degrees slope to reflect the maximum slope that the cost function is parametised to. NULL (default)</p>
</td></tr>
<tr><td><code id="create_slope_cs_+3A_exaggeration">exaggeration</code></td>
<td>
<p><code>logical</code>. if TRUE, positive slope values (up-hill movement) multiplied by 1.99 and negative slope values (down-hill movement) multiplied by 2.31</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following cost functions have been implemented however users may also supply their own cost function (see Examples):
</p>
<p>&quot;tobler&quot;, &quot;tobler offpath&quot;, &quot;davey&quot;, 'rees', &quot;irmischer-clarke male&quot;, &quot;irmischer-clarke offpath male&quot;, &quot;irmischer-clarke female&quot;, &quot;irmischer-clarke offpath female&quot;, &quot;modified tobler&quot;, 'garmy', 'kondo-saino', &quot;wheeled transport&quot;, &quot;herzog&quot;, &quot;llobera-sluckin&quot;, &quot;naismith&quot;, &quot;minetti&quot;, &quot;campbell&quot;,&quot;campbell 2019 1&quot;,&quot;campbell 2019 5&quot; ,&quot;campbell 2019 10&quot;,&quot;campbell 2019 15&quot;,&quot;campbell 2019 20&quot;,&quot;campbell 2019 25&quot;,&quot;campbell 2019 30&quot;,&quot;campbell 2019 35&quot;,&quot;campbell 2019 40&quot;,&quot;campbell 2019 45&quot;,&quot;campbell 2019 50&quot;,&quot;campbell 2019 55&quot;,&quot;campbell 2019 60&quot;,&quot;campbell 2019 65&quot;,&quot;campbell 2019 70&quot;,&quot;campbell 2019 75&quot;,&quot;campbell 2019 80&quot;,&quot;campbell 2019 85&quot;,&quot;campbell 2019 90&quot;,&quot;campbell 2019 95&quot;,&quot;campbell 2019 99&quot;, &quot;sullivan 167&quot;,&quot;sullivan 5&quot;, &quot;sullivan 833&quot;
</p>
<p>Multiple travel rate percentiles implemented for campbell 2019 and sullivan, e.g. &quot;campbell 2019 50&quot; is the 50th percentile
</p>


<h3>Value</h3>

<p><code>conductanceMatrix</code> that numerically expresses the difficulty of moving across slope based on the provided cost function
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>References</h3>

<p>Tobler, W. 1993. Three Presentations on Geographical Analysis and Modeling. Technical Report 93-1 (Santa Barbara, CA)
</p>
<p>Davey, R.C., M. Hayes and J.M. Norman 1994. “Running Uphill: An Experimental Result and Its Applications,” The Journal of the Operational Research Society 45, 25
</p>
<p>Rees, W.G. 2004. “Least-cost paths in mountainous terrain,” Computers &amp; Geosciences 30, 203–09
</p>
<p>Irmischer, I.J. and K.C. Clarke 2018. “Measuring and modeling the speed of human navigation,” Cartography and Geographic Information Science 45, 177–86
</p>
<p>Márquez-Pérez, J., I. Vallejo-Villalta and J.I. Álvarez-Francoso 2017. “Estimated travel time for walking trails in natural areas,” Geografisk Tidsskrift-Danish Journal of Geography 117, 53–62
</p>
<p>Garmy, P. et al. 2005. “Logiques spatiales et ‘systèmes de villes’ en Lodévois de l’Antiquité à la période moderne,” Temps et espaces de l’homme en société, analyses et modèles spatiaux en archéologie 335–46
</p>
<p>Kondo, Y. and Y. Seino 2010. “GPS-aided walking experiments and data-driven travel cost modeling on the historical road of Nakasendō-Kisoji (Central Highland Japan),” Making History Interactive (Proceedings of the 37th International Conference, Williamsburg, Virginia, United States of America) 158–65
</p>
<p>Herzog, I. 2013. “The potential and limits of Optimal Path Analysis,” in Bevan, A. and M. Lake (edd.), Computational approaches to archaeological spaces (Publications of the Institute of Archaeology, University College London) 179–211
</p>
<p>Llobera, M. and T.J. Sluckin 2007. “Zigzagging: Theoretical insights on climbing strategies,” Journal of Theoretical Biology 249, 206–17
</p>
<p>Naismith, W. 1892. “Excursions: Cruach Ardran, Stobinian, and Ben More,” Scottish Mountaineering club journal 2, 136
</p>
<p>Minetti, A.E. et al. 2002. “Energy cost of walking and running at extreme uphill and downhill slopes,” Journal of Applied Physiology 93, 1039–46
</p>
<p>Campbell, M.J., P.E. Dennison and B.W. Butler 2017. “A LiDAR-based analysis of the effects of slope, vegetation density, and ground surface roughness on travel rates for wildland firefighter escape route mapping,” Int. J. Wildland Fire 26, 884
</p>
<p>Campbell, M.J. et al. 2019. “Using crowdsourced fitness tracker data to model the relationship between slope and travel rates,” Applied Geography 106, 93–107
</p>
<p>Sullivan, P.R. et al. 2020. “Modeling Wildland Firefighter Travel Rates by Terrain Slope: Results from GPS-Tracking of Type 1 Crew Movement,” Fire 3, 52
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)
slope_cs &lt;- create_slope_cs(x = r, cost_function = "campbell 2019 50", neighbours = 4)
slope_cs2 &lt;- create_slope_cs(x = r, 
cost_function = function(x) {(6 * exp(-3.5 * abs(x + 0.05))) / 3.6}, neighbours = 4)

</code></pre>

<hr>
<h2 id='crop_cs'>Crop conductanceMatrix to extent</h2><span id='topic+crop_cs'></span>

<h3>Description</h3>

<p>Crop conductanceMatrix to extent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_cs(x, extent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_cs_+3A_x">x</code></td>
<td>
<p><code>spatRaster</code></p>
</td></tr>
<tr><td><code id="crop_cs_+3A_extent">extent</code></td>
<td>
<p><code>sf object or terra SpatRaster</code>. Extent obtained from object using terra::ext</p>
</td></tr>
</table>


<h3>Details</h3>

<p>conductanceMatrix cropped to extent of supplied <code>Sf object</code> or <code>terra SpatRaster</code>. conductanceMatrix spatRaster dimensions and Matrix dimensions update to reflect cropped extent
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

ext &lt;- sf::st_as_sfc(sf::st_bbox(rasterise(slope_cs)))
ext &lt;- sf::st_buffer(ext, dist = -75000)
ext &lt;- sf::st_as_sf(ext)

slope_cs_cropped &lt;- crop_cs(slope_cs, extent = ext)
</code></pre>

<hr>
<h2 id='force_isotropy'>Coerce an anisotropic cost surface to an isotropic cost surface</h2><span id='topic+force_isotropy'></span>

<h3>Description</h3>

<p>Averages conductance values from-to adjacent cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force_isotropy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="force_isotropy_+3A_x">x</code></td>
<td>
<p><code>conductanceMatrix</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>conductanceMatrix</code> 
</p>
<p>r &lt;- terra::rast(system.file(&quot;extdata/SICILY_1000m.tif&quot;, package=&quot;leastcostpath&quot;))
</p>
<p>slope_cs_aniso &lt;- create_slope_cs(x = r, cost_function = &quot;tobler&quot;, neighbours = 4)
</p>
<p>slope_cs_iso &lt;- force_isotropy(x = slope_cs_aniso)
</p>

<hr>
<h2 id='get_coordinates'>get coordinates from a variety of different object classes</h2><span id='topic+get_coordinates'></span>

<h3>Description</h3>

<p>get coordinates from a variety of different object classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_coordinates(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_coordinates_+3A_x">x</code></td>
<td>
<p>coordinates. <code>sf</code> 'POINT' or 'MULTIPOINT', <code>SpatVector</code>, <code>data.frame</code> or <code>matrix</code> containing the locations coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> matrix of coordinates
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>

<hr>
<h2 id='neighbourhood'>neighbourhood matrix to represent adjacent cells</h2><span id='topic+neighbourhood'></span>

<h3>Description</h3>

<p>neighbourhood matrix to represent adjacent cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbourhood(neighbours)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbourhood_+3A_neighbours">neighbours</code></td>
<td>
<p><code>numeric</code> or <code>matrix</code> Expected numeric values are 4, 8, 16, 32, or 48. A user-supplied matrix of 0 and 1s can be supplied. Here, 0 denotes non-adjaency and 1 denotes adjacency</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> neighbourhood matrix
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>

<hr>
<h2 id='PDI_validation'>Calculate the similarity of a least-cost path to a known route</h2><span id='topic+PDI_validation'></span>

<h3>Description</h3>

<p>Calculates the similarity of a least-cost path to a known route using the path deviation index method proposed by Jan et al. (1999)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PDI_validation(lcp, comparison)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PDI_validation_+3A_lcp">lcp</code></td>
<td>
<p><code>sf</code></p>
</td></tr>
<tr><td><code id="PDI_validation_+3A_comparison">comparison</code></td>
<td>
<p><code>sf</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Path Deviation Index (pdi) measures the spatial separation between a pair of paths and aims to overcome the shortcomings of measuring the percentage of coverage of a least cost path from a comparison path (e.g. as implemented in the buffer_validation function).
</p>
<p>The pdi index is defined as the area between paths divided by the Euclidean distance of the shortest path between the origin and destination of the paths. The index can be interpreted as the average distance between the paths.
</p>
<p><code>pdi  = area / length</code>
</p>
<p>The value of the pdi depends on the length of the path and makes comparison of pdis difficult for paths with different origins and destinations. This is overcome by normalising the pdi by the Euclidean distance of the shortest path between the origin and destination of the paths
</p>
<p><code>Normalised pdi = pdi / length * 100</code>
</p>
<p>The normalised pdi is the percent of spatial separation between the two paths over the shortest path. For example, if a normalised pdi is 30 percent, it means that the average distance between two paths is 30 percent of the length of the shortest path. With normalised pdi, the spatial separations of all paths  can be compared regardless of the length of the shortest path.
</p>
<p>Note: If the lcp path has a different origin and destination than the comparison path, the origin and destination of the lcp path are replaced with the origin and destination of the comparison path. This to ensure that a polygon can be created between the two paths which is required for calculating the area of spatial separation.
</p>


<h3>Value</h3>

<p><code>sf</code> POLYGON of the area between the lcp and comparison with data.frame of area, pdi, max distance, and normalised pdi
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

locs &lt;- sf::st_sf(geometry = sf::st_sfc(
sf::st_point(c(839769, 4199443)),
sf::st_point(c(1038608, 4100024)),
crs = terra::crs(r)))

lcp1 &lt;- create_lcp(x = slope_cs, origin = locs[1,], destination = locs[2,], 
cost_distance = TRUE)

lcp2 &lt;- create_lcp(x = slope_cs, origin = locs[2,], destination = locs[1,], 
cost_distance = TRUE)

pdi_val &lt;- PDI_validation(lcp = lcp1, comparison = lcp2)
</code></pre>

<hr>
<h2 id='plot.conductanceMatrix'>plot conductanceMatrix</h2><span id='topic+plot.conductanceMatrix'></span>

<h3>Description</h3>

<p>plot conductanceMatrix for visualisation. Conductivity values are the mean conductivity for each cell
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conductanceMatrix'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.conductanceMatrix_+3A_x">x</code></td>
<td>
<p><code>conductanceMatrix</code></p>
</td></tr>
<tr><td><code id="plot.conductanceMatrix_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>terra::plot</code></p>
</td></tr>
</table>

<hr>
<h2 id='rasterise'>converts conductanceMatrix to SpatRaster</h2><span id='topic+rasterise'></span>

<h3>Description</h3>

<p>converts conductanceMatrix to SpatRaster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterise(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterise_+3A_x">x</code></td>
<td>
<p><code>conductanceMatrix</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>spatRaster</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

cs_rast &lt;- rasterise(slope_cs)
</code></pre>

<hr>
<h2 id='replace_values'>replace values with values from another object</h2><span id='topic+replace_values'></span>

<h3>Description</h3>

<p>Replace values of <code>conductanceMatrix</code> x with the values of <code>conductanceMatrix</code> y that coincide with the supplied sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_values(x, y, sf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_values_+3A_x">x</code></td>
<td>
<p><code>conductanceMatrix</code></p>
</td></tr>
<tr><td><code id="replace_values_+3A_y">y</code></td>
<td>
<p><code>conductanceMatrix</code></p>
</td></tr>
<tr><td><code id="replace_values_+3A_sf">sf</code></td>
<td>
<p><code>sf</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>conductanceMatrix</code> x are replaced with the values from <code>conductanceMatrix</code> y that coincide with the supplied sf object
</p>


<h3>Value</h3>

<p><code>conductanceMatrix</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

x &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

locs &lt;- sf::st_sf(geometry = sf::st_sfc(
sf::st_point(c(960745, 4166836)),
crs = terra::crs(r)))
locs &lt;- sf::st_buffer(x = locs, dist = 25000)

y &lt;- update_values(x = x, sf = locs, FUN = function(j) { j + 10})

output &lt;- replace_values(x = x, y = y, sf = locs)

identical(y$conductanceMatrix, output$conductanceMatrix)
</code></pre>

<hr>
<h2 id='update_values'>update values in a conductanceMatrix</h2><span id='topic+update_values'></span>

<h3>Description</h3>

<p>Apply a function to values in the <code>conductanceMatrix</code> that coincide with the supplied sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_values(x, sf, FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_values_+3A_x">x</code></td>
<td>
<p><code>conductanceMatrix</code></p>
</td></tr>
<tr><td><code id="update_values_+3A_sf">sf</code></td>
<td>
<p><code>sf</code></p>
</td></tr>
<tr><td><code id="update_values_+3A_fun">FUN</code></td>
<td>
<p><code>function</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An updated conductanceMatrix is produced by assessing which areas of the conductanceMatrix coincide with the supplied sf object. The values within the areas that coincide with the sf object are modified based on the supplied function
</p>


<h3>Value</h3>

<p><code>conductanceMatrix</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Lewis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- terra::rast(system.file("extdata/SICILY_1000m.tif", package="leastcostpath"))

slope_cs &lt;- create_slope_cs(x = r, cost_function = "tobler", neighbours = 4)

locs &lt;- sf::st_sf(geometry = sf::st_sfc(
sf::st_point(c(960745, 4166836)),
crs = terra::crs(r)))

locs &lt;- sf::st_buffer(x = locs, dist = 25000)

slope_cs2 &lt;- update_values(x = slope_cs, sf = locs, 
FUN = function(j) { j * 0.6})

slope_cs3 &lt;- update_values(x = slope_cs, sf = locs, 
FUN = function(j) { j + 10})

slope_cs4 &lt;- update_values(x = slope_cs, sf = locs, 
FUN = function(j) { replace(x = j, values = 0)})
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
