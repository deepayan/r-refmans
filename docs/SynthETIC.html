<!DOCTYPE html><html><head><title>Help for package SynthETIC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SynthETIC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_relativity'><p>Function to check the input Covariate Relativities</p></a></li>
<li><a href='#claim_closure'><p>Claim Closure</p></a></li>
<li><a href='#claim_frequency'><p>Claim Frequency</p></a></li>
<li><a href='#claim_notification'><p>Claim Notification</p></a></li>
<li><a href='#claim_occurrence'><p>Claim Occurrence Times</p></a></li>
<li><a href='#claim_output'><p>Loss Reserving Output</p></a></li>
<li><a href='#claim_payment_delay'><p>Inter-Partial Delays</p></a></li>
<li><a href='#claim_payment_inflation'><p>Size of Partial Payments (With Inflation)</p></a></li>
<li><a href='#claim_payment_no'><p>Number of Partial Payments</p></a></li>
<li><a href='#claim_payment_size'><p>Size of Partial Payments (Without Inflation)</p></a></li>
<li><a href='#claim_payment_time'><p>Partial Payment Times (in Continuous Time Scale)</p></a></li>
<li><a href='#claim_size'><p>Claim Size</p></a></li>
<li><a href='#claim_size_adj'><p>Covariates Claim Size Adjustment</p></a></li>
<li><a href='#claim_size_adj.fit'><p>Covariates Claim Size Adjustment</p></a></li>
<li><a href='#claims'><p>Construction of a <code>claims</code> Object</p></a></li>
<li><a href='#covariates'><p>Construction of a <code>covariates</code> Object</p></a></li>
<li><a href='#covariates_data'><p>Construction of a <code>covariates_data</code> Object</p></a></li>
<li><a href='#covariates_relativity'><p>Calculates Relativities</p></a></li>
<li><a href='#cv'><p>Coefficient of Variation</p></a></li>
<li><a href='#generate_claim_dataset'><p>Generate a Claims Dataset</p></a></li>
<li><a href='#generate_transaction_dataset'><p>Generate a Transactions Dataset</p></a></li>
<li><a href='#get_Beta_parameters'><p>Estimating Beta Parameters</p></a></li>
<li><a href='#get_Weibull_parameters'><p>Estimating Weibull Parameters</p></a></li>
<li><a href='#plot_transaction_dataset'><p>Plot of Cumulative Claims Payments (Incurred Pattern)</p></a></li>
<li><a href='#plot.claims'><p>Plot of Cumulative Claims Payments (Incurred Pattern)</p></a></li>
<li><a href='#relativity_template'><p>Template to input Covariate Relativities</p></a></li>
<li><a href='#return_parameters'><p>Get Current Parameters</p></a></li>
<li><a href='#set_parameters'><p>Set Packagewise Global Parameters for the Claims Simulator</p></a></li>
<li><a href='#set.covariates_relativity'><p>Sets the claims relativity for a <code>covariates</code> object.</p></a></li>
<li><a href='#simulate_cdf'><p>Inverse Tranform Sampling</p></a></li>
<li><a href='#simulate_covariates'><p>Covariates Simulation</p></a></li>
<li><a href='#SynthETIC-package'><p>SynthETIC: Synthetic Experience Tracking Insurance Claims</p></a></li>
<li><a href='#test_claim_dataset'><p>Claims Dataset</p></a></li>
<li><a href='#test_claim_dataset_cov'><p>Claims Dataset</p></a></li>
<li><a href='#test_claims_object'><p>Claims Data in List Format</p></a></li>
<li><a href='#test_claims_object_cov'><p>Claims Data in List Format</p></a></li>
<li><a href='#test_covariates_dataset'><p>Covariates Data Object</p></a></li>
<li><a href='#test_covariates_obj'><p>Covariates Object</p></a></li>
<li><a href='#test_transaction_dataset'><p>Transactions Dataset</p></a></li>
<li><a href='#test_transaction_dataset_cov'><p>Transactions Dataset</p></a></li>
<li><a href='#to_SynthETIC'><p>Conversion to SynthETIC Format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Synthetic Experience Tracking Insurance Claims</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Avanzi [aut],
  William Ho [aut],
  Greg Taylor [aut],
  Melantha Wang [aut, cre],
  Bernard Wong [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Melantha Wang &lt;wang.melantha@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ggplot2, magrittr, rlang, methods, dplyr</td>
</tr>
<tr>
<td>Description:</td>
<td>Creation of an individual claims simulator which generates various
    features of non-life insurance claims. An initial set of test parameters,
    designed to mirror the experience of an Auto Liability portfolio, were set
    up and applied by default to generate a realistic test data set of
    individual claims (see vignette). The simulated data set then allows
    practitioners to back-test the validity of various reserving models and to
    prove and/or disprove certain actuarial assumptions made in claims
    modelling. The distributional assumptions used to generate this data set can
    be easily modified by users to match their experiences. Reference: Avanzi B,
    Taylor G, Wang M, Wong B (2020) "SynthETIC: an individual insurance claim
    simulator with feature control" &lt;<a href="https://arxiv.org/abs/2008.05693">arXiv:2008.05693</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/agi-lab/SynthETIC">https://github.com/agi-lab/SynthETIC</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/agi-lab/SynthETIC/issues">https://github.com/agi-lab/SynthETIC/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, RColorBrewer, actuar</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-27 13:23:47 UTC; melantha</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-27 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_relativity'>Function to check the input Covariate Relativities</h2><span id='topic+check_relativity'></span>

<h3>Description</h3>

<p>Performs assertions on inputted relativities, will raise an error if any checks
fail. Currently checks on the: necessary column names used in dataframe,
required factors and levels based on inputted <code>factors</code>, inputted relativities
being non-negative numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_relativity(factors, relativity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_relativity_+3A_factors">factors</code></td>
<td>
<p>named list of vectors, containing the name of the covariates
and associated factors in vector form.</p>
</td></tr>
<tr><td><code id="check_relativity_+3A_relativity">relativity</code></td>
<td>
<p>relativity dataframe as defined in <code><a href="#topic+relativity_template">relativity_template</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='claim_closure'>Claim Closure</h2><span id='topic+claim_closure'></span>

<h3>Description</h3>

<p>Simulates and returns the closure/settlement delays of each of the claims
occurring in each of the periods, assuming a Weibull distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_closure(frequency_vector, claim_size_list, rfun, paramfun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_closure_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="claim_closure_+3A_claim_size_list">claim_size_list</code></td>
<td>
<p>list of claim sizes.</p>
</td></tr>
<tr><td><code id="claim_closure_+3A_rfun">rfun</code></td>
<td>
<p>optional alternative random sampling function; if not specified,
assumes Weibull.</p>
</td></tr>
<tr><td><code id="claim_closure_+3A_paramfun">paramfun</code></td>
<td>
<p>parameters for the random sampling function, as a function of
<code>claim_size</code> and <code>occurrence_period</code>; see Details.</p>
</td></tr>
<tr><td><code id="claim_closure_+3A_...">...</code></td>
<td>
<p>other arguments/parameters to be passed onto <code>paramfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Claim settlement delay represents the delay from claim notification
to closure. The epoch of closure is the sum of occurrence time, notification
delay and settlement delay.
</p>
<p>By default, it is assumed that the settlement delay follows a Weibull
distribution. The default Weibull parameters have been set up such that
the mean settlement delay (in quarters, but automatically converted to the
relevant <code>time_unit</code> as defined in <code><a href="#topic+set_parameters">set_parameters</a></code>) is
porportional to
</p>
<p style="text-align: center;"><code class="reqn">min(25, max(1, 6 + 4 log[claim_size/(0.10 * ref_claim)]))</code>
</p>
<p> (where
<code>ref_claim</code> is a packagewise-global variable that user is required to define
by <code><a href="#topic+set_parameters">set_parameters</a></code>) up to a scaling factor &quot;<code class="reqn">a</code>&quot;, which is
dependent on <code>occurrence_perid</code>. Specifically,
</p>
<p style="text-align: center;"><code class="reqn">a = min(0.85, 0.65 + 0.02 * (occurrence_period - 21))</code>
</p>
<p> if
<code>claim_size</code> &lt; (0.10 * ref_claim) and <code>occurrence_period</code> <code class="reqn">\ge</code>
21, and </p>
<p style="text-align: center;"><code class="reqn">a = max(0.85, 1 - 0.0075 * occurrence_period)</code>
</p>
<p> otherwise.
The CoV of the settlement delay is constant at 60%, independent of the size
and occurrence period of the claim.
</p>
<p>Note that this function can create out-of-bound settlement dates. In these
cases, the simulated epoch of occurrence of the transaction is maintained
throughout the simulation of details of the claim concerned. Adjustments will
only be made for the tabulation of results in <code><a href="#topic+claim_output">claim_output</a></code> and
payment inflation.
</p>
<p>Of course, like any other <code>SynthETIC</code> modules, the user may wish to
sample from a different distribution <code>rfun</code> and/or a different set of
parameters. The <code>paramfun</code> should return the distribution parameters in a
<strong>vector</strong>, e.g. for gamma distribution <code>paramfun</code> should return a value in
the format of <code>c(shape = , scale = )</code>, for exponential distribution this
should return <code>c(rate = )</code>. See Examples. If a <code>rfun</code> is specified without
a <code>paramfun</code>, <code>SynthETIC</code> will try to proceed without parameterisation (i.e.
directly calling <code>rfun</code> with claim size and occurrence period), and if it
fails, then return an error message.
</p>


<h3>Value</h3>

<p>A list of settlement delays such that the <code class="reqn">i</code>th component of
the list gives the settlement delays for all claims that occurred in period
<code class="reqn">i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_vector &lt;- c(90, 79, 102, 78, 86, 88, 116, 84, 93, 104)

# Try a constant Weibull distribution
# (i.e. independent of claim size and occurrence period)
setldel_param &lt;- function(claim_size, occurrence_period) {
  mean &lt;- 10; cv &lt;- 0.70
  shape &lt;- get_Weibull_parameters(mean, cv)[1, ]
  scale &lt;- get_Weibull_parameters(mean, cv)[2, ]
  c(shape = shape, scale = scale)
}

setldel &lt;- claim_closure(n_vector, claim_size(n_vector),
                         paramfun = setldel_param)
setldel[[1]] # show settlement delay of claims originating from period 1
</code></pre>

<hr>
<h2 id='claim_frequency'>Claim Frequency</h2><span id='topic+claim_frequency'></span>

<h3>Description</h3>

<p>Returns the number of insurance claims occurring in each of the periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_frequency(
  I = 40,
  E = 12000,
  freq = 0.03,
  simfun,
  type = c("r", "p"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_frequency_+3A_i">I</code></td>
<td>
<p>number of claims development periods considered.</p>
</td></tr>
<tr><td><code id="claim_frequency_+3A_e">E</code></td>
<td>
<p><strong>effective annual</strong> exposure associated with each period (vector).</p>
</td></tr>
<tr><td><code id="claim_frequency_+3A_freq">freq</code></td>
<td>
<p>expected frequency per unit exposure for each period (vector).</p>
</td></tr>
<tr><td><code id="claim_frequency_+3A_simfun">simfun</code></td>
<td>
<p>optional alternative sampling distribution; see Details.</p>
</td></tr>
<tr><td><code id="claim_frequency_+3A_type">type</code></td>
<td>
<p>the type of <code>simfun</code> provided. The default is a random generation
function (e.g. <code>rpois</code>); the alternative <code>"p"</code> is any valid cumulative
distribution function (e.g. <code>ppois</code>).</p>
</td></tr>
<tr><td><code id="claim_frequency_+3A_...">...</code></td>
<td>
<p>other arguments/parameters to be passed onto <code>simfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unless otherwise specified, <code>claim_frequency()</code> assumes the
claim frequency follows a Poisson distribution with mean equal to the
product of exposure <code>E</code> associated with period <code class="reqn">i</code> and expected
claim frequency <code>freq</code> per unit exposure for that period. <br /> <br />
If no arguments are provided, by default <code>claim_frequency()</code> assumes
a total of 40 development periods, constant exposure rate at 12000 per year
and constant frequency at 0.03 per unit of exposure. <br /> <br />
If one wishes to use an alternative sampling distribution for claim
frequency, they could declare such specification through the <code>simfun</code>
argument. The <code>simfun</code> argument takes both random generation functions
(<code>type = "r"</code>, the default) and cumulative distribution functions
(<code>type = "p"</code>). For the latter, <code>claim_frequency()</code> will first search for the
existence of the corresponding <code>r</code>-function. If it notes the existence of
such an <code>r</code>-function (e.g. <code>rpois</code> for <code>simfun = ppois</code>), it will directly
apply the <code>r</code>-function to optimise simulation efficiency. Otherwise, the
function uses a numerical inverse transform method for simulation (see
<code><a href="#topic+simulate_cdf">simulate_cdf</a></code>), which may not be the most efficient and can
potentially result in errors if an appropriate <code>range</code> is not specified in
the optional arguments. <br /> <br />
Pre-defined distribution functions such as <code>ppois</code> are supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>no_period &lt;- 40
exposure &lt;- c(rep(12000, no_period))
exp_freq &lt;- c(rep(0.03, no_period))
# returns the same result as claim_frequency()
claim_frequency(I = no_period, E = exposure, freq = exp_freq)

# use a pre-defined random generation function
claim_frequency(I = 10, simfun = rpois, lambda = 80)
# or equivalently, through a distribution function
claim_frequency(I = 10, simfun = ppois, type = "p", lambda = 80)
</code></pre>

<hr>
<h2 id='claim_notification'>Claim Notification</h2><span id='topic+claim_notification'></span>

<h3>Description</h3>

<p>Simulates and returns the notification/reporting delays of each of the
claims occurring in each of the periods, according to a user-specified
distribution (by default a Weibull).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_notification(frequency_vector, claim_size_list, rfun, paramfun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_notification_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="claim_notification_+3A_claim_size_list">claim_size_list</code></td>
<td>
<p>list of claim sizes.</p>
</td></tr>
<tr><td><code id="claim_notification_+3A_rfun">rfun</code></td>
<td>
<p>optional alternative random sampling function; if not specified,
assumes Weibull.</p>
</td></tr>
<tr><td><code id="claim_notification_+3A_paramfun">paramfun</code></td>
<td>
<p>parameters for the random sampling function, as a function of
<code>claim_size</code> and <code>occurrence_period</code>; see Details.</p>
</td></tr>
<tr><td><code id="claim_notification_+3A_...">...</code></td>
<td>
<p>other arguments/parameters to be passed onto <code>paramfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Claim notification delay represents the delay from claim occurrence
to reporting. <code>SynthETIC</code> assumes the (removable) dependence of notification
delay on claim size and occurrence period of the claim, thus requiring the
user to specify a <code>paramfun</code> of <code>claim_size</code> and <code>occurrrence_period</code> (with
the option to add more arguments as needed).
</p>
<p>The <code>paramfun</code> should return the distribution parameters in a <strong>vector</strong>,
e.g. for gamma distribution <code>paramfun</code> should return a value in the format of
<code>c(shape = , scale = )</code>, for exponential distribution this should return
<code>c(rate = )</code>. See Examples. If a <code>rfun</code> is specified without a <code>paramfun</code>,
<code>SynthETIC</code> will try to proceed without parameterisation (i.e. directly
calling <code>rfun</code> with claim size and occurrence period), and if it fails,
return an error message.
</p>
<p>By default, it is assumed that the notification delay follows a Weibull
distribution, and that the mean notification delay (in quarters) is given by
</p>
<p style="text-align: center;"><code class="reqn">min(3, max(1, 2-[log(claim_size/(0.50*ref_claim))]/3))</code>
</p>

<p>automatically converted to the relevant <code>time_unit</code> defined by user at the
top of their script through <code><a href="#topic+set_parameters">set_parameters</a></code>. Note that the
<code>ref_claim</code> in the equation is another package-wise global variable that the
user needs to define through <code><a href="#topic+set_parameters">set_parameters</a></code> as it determines
the monetary scale of the simulator. The CoV (Coefficient of Variation)
of the notification delay is assumed to be constant at 70%, independent of
the size and occurrence period of the claim.
</p>
<p>Of course, the user may wish to sample from a different distribution <code>rfun</code>
and/or a different set of parameters. An example is given below.
</p>


<h3>Value</h3>

<p>A list of notification delays such that the <code class="reqn">i</code>th component of
the list gives the notification delays for all claims that occurred in
period <code class="reqn">i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_vector &lt;- c(90, 79, 102, 78, 86, 88, 116, 84, 93, 104)

# Try a constant Weibull distribution
# (i.e. independent of claim size and occurrence period)
notidel_param &lt;- function(claim_size, occurrence_period) {
  mean &lt;- 2; cv &lt;- 0.70
  shape &lt;- get_Weibull_parameters(mean, cv)[1, ]
  scale &lt;- get_Weibull_parameters(mean, cv)[2, ]
  c(shape = shape, scale = scale)
}

notidel &lt;- claim_notification(n_vector, claim_size(n_vector),
                              paramfun = notidel_param)
notidel[[1]] # show notification for claims originating from period 1
</code></pre>

<hr>
<h2 id='claim_occurrence'>Claim Occurrence Times</h2><span id='topic+claim_occurrence'></span>

<h3>Description</h3>

<p>Returns the occurrence times of each of the claims occurring in each of
the periods, assuming the occurrence time of any claim in period <code class="reqn">i</code>
is uniformly distributed between times <code class="reqn">i - 1</code> and <code class="reqn">i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_occurrence(frequency_vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_occurrence_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of occurrence times such that the <code class="reqn">i</code>th component of the
list gives the claim occurrence time for all claims that occurred in period
<code class="reqn">i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_vector &lt;- c(90, 79, 102, 78, 86, 88, 116, 84, 93, 104)
# occurrence time for all claims originating from period 1
claim_occurrence(n_vector)[[1]]
</code></pre>

<hr>
<h2 id='claim_output'>Loss Reserving Output</h2><span id='topic+claim_output'></span>

<h3>Description</h3>

<p>Outputs the full (or past) square of claim payments by occurrence period and
development period. The upper left triangle represents the past, and the
lower right triangle the unseen future. <br /> <br />
Users can modify the aggregate level by providing an <code>aggregate_level</code>
argument to the function. For example, setting <code>aggregate_level = 4</code> when
working with calendar <em>quarters</em> produces a payment square by occurrence and
development <em>year</em>. <br /> <br />
Users will also have the option to decide whether to include the out-of-bound
transactions to the maximum DQ, or to leave them in a separate &quot;tail&quot; cell,
see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_output(
  frequency_vector,
  payment_time_list,
  payment_size_list,
  aggregate_level = 1,
  incremental = TRUE,
  future = TRUE,
  adjust = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_output_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="claim_output_+3A_payment_time_list">payment_time_list</code></td>
<td>
<p>(compound) list of payment times (both the continous
time scale and the discrete period versions work).</p>
</td></tr>
<tr><td><code id="claim_output_+3A_payment_size_list">payment_size_list</code></td>
<td>
<p>(compound) list of payment size pattern (can be
either with or without inflation).</p>
</td></tr>
<tr><td><code id="claim_output_+3A_aggregate_level">aggregate_level</code></td>
<td>
<p>number of periods to be aggregated together; must be
a divisor of the total number of periods under consideration (default 1).</p>
</td></tr>
<tr><td><code id="claim_output_+3A_incremental">incremental</code></td>
<td>
<p>logical; if true returns the incremental payment square,
else returns the cumulative payment square.</p>
</td></tr>
<tr><td><code id="claim_output_+3A_future">future</code></td>
<td>
<p>logical; if true shows the full claim triangle (i.e. including
claim payments in future periods), else shows only the past triangle (default
TRUE).</p>
</td></tr>
<tr><td><code id="claim_output_+3A_adjust">adjust</code></td>
<td>
<p>logical; if true accumulates all payments beyond the max
development period to the last development period, else shows a separate
&quot;tail&quot; column for all the out-of-bound transactions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Remark on out-of-bound payment times</strong>: This function allows adjustment
for out-of-bound transaction dates, by forcing payments that were projected
to fall out of the maximum development period to be paid at the exact end of
the maximum development period allowed (when we set <code>adjust = TRUE</code>, which is
the default behaviour). For example, if we consider 40 periods of development
and a claim incurred in the interval (20, 21] was projected to have a payment
at time 62.498210, then for the purpose of tabulation, we can
</p>

<ul>
<li><p> treat such a payment as if it occurred at time 60 (<code>adjust = TRUE</code>);
</p>
</li>
<li><p> leave the payment in the &quot;tail&quot; cell, so the user can see the proportion of
payments beyond the maximum development period (<code>adjust = FALSE</code>).
</p>
</li></ul>



<h3>Value</h3>

<p>An array of claims payments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>attach(test_claims_object)
# a square of cumulative claims payments by accident and development quarters
CL &lt;- claim_output(frequency_vector, payment_time_list, payment_size_list,
                   aggregate_level = 1, incremental = FALSE)
detach(test_claims_object)
</code></pre>

<hr>
<h2 id='claim_payment_delay'>Inter-Partial Delays</h2><span id='topic+claim_payment_delay'></span>

<h3>Description</h3>

<p>Simulates and returns the inter-partial delays (i.e. the delay of one
partial payment relative to the previous) of each payment for each of the
claims occurring in each of the periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_payment_delay(
  frequency_vector,
  claim_size_list,
  no_payments_list,
  settlement_list,
  rfun,
  paramfun,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_payment_delay_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="claim_payment_delay_+3A_claim_size_list">claim_size_list</code></td>
<td>
<p>list of claim sizes.</p>
</td></tr>
<tr><td><code id="claim_payment_delay_+3A_no_payments_list">no_payments_list</code></td>
<td>
<p>list of number of partial payments.</p>
</td></tr>
<tr><td><code id="claim_payment_delay_+3A_settlement_list">settlement_list</code></td>
<td>
<p>list of settlement delays.</p>
</td></tr>
<tr><td><code id="claim_payment_delay_+3A_rfun">rfun</code></td>
<td>
<p>optional alternative random sampling function; see Details for
default.</p>
</td></tr>
<tr><td><code id="claim_payment_delay_+3A_paramfun">paramfun</code></td>
<td>
<p>parameters for the random sampling function, as a function of
<code>claim_size</code>, <code>setldel</code>; see Details.</p>
</td></tr>
<tr><td><code id="claim_payment_delay_+3A_...">...</code></td>
<td>
<p>other arguments/parameters to be passed onto <code>paramfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a compound list structure such that the <code class="reqn">j</code>th component
of the <code class="reqn">i</code>th sub-list gives the payment delay pattern (as a vector) for
the <code class="reqn">j</code>th claim of occurrence period <code class="reqn">i</code>.
</p>
<p>The default <code>rfun</code> is split into 2 cases.
</p>
<p><strong>Case 1: claims with at least 4 partial payments.</strong> The simulation takes
2 steps.
First we sample the last payment delay from a Weibull distribution with
mean = 1 quarter (automatically converted to the relevant <code>time_unit</code>, a
global variable that the user is required to define at the top of their code)
and CoV = 20%. Then we sample the remaining payment delays from a second
Weibull distribution with CoV at 35% and mean = target mean settlement delay
(see <code><a href="#topic+claim_closure">claim_closure</a></code>) divided by the number of payments.
</p>
<p><strong>Case 2: claims with less than 4 partial payments.</strong> Proceed as in Case 1
but without separating out the simulation of the last payment delay (i.e.
ignore step 1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up
n_vector &lt;- claim_frequency(I = 10)
claim_sizes &lt;- claim_size(n_vector)
no_payments &lt;- claim_payment_no(n_vector, claim_sizes)
setldel &lt;- claim_closure(n_vector, claim_sizes)

# with default setting
pmtdel &lt;- claim_payment_delay(n_vector, claim_sizes, no_payments, setldel)
pmtdel[[1]][[1]] # payment delays for claim 1 of occurrence period 1

# with some custom rfun
# simplistic case: payments times are uniformly distributed
my_func &lt;- function(n, setldel) {
  prop &lt;- runif(n)
  prop &lt;- prop / sum(prop)
  setldel * prop
}
mypayments &lt;- claim_payment_delay(n_vector, claim_sizes, no_payments, setldel,
                                  rfun = my_func)
# inter-partial delays for claim 1 of occurrence period 1
mypayments[[1]][[1]]
</code></pre>

<hr>
<h2 id='claim_payment_inflation'>Size of Partial Payments (With Inflation)</h2><span id='topic+claim_payment_inflation'></span>

<h3>Description</h3>

<p>Converts the (compound) list of constant-dollar-value payment sizes to a
(compound) list of inflated payment sizes by applying inflation rates on a
continuous time scale. <br /> <br />
Compare with <code>claim_payment_size()</code> which generates the constant dollar
amount of partial payment sizes. Note that the constant dollar values are as
of time 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_payment_inflation(
  frequency_vector,
  payment_size_list,
  payment_time_list,
  occurrence_list,
  claim_size_list,
  base_inflation_vector,
  si_occurrence_function,
  si_payment_funtion
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_payment_inflation_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the occurrence
periods.</p>
</td></tr>
<tr><td><code id="claim_payment_inflation_+3A_payment_size_list">payment_size_list</code></td>
<td>
<p>(compound) list of payment size pattern (without
inflation).</p>
</td></tr>
<tr><td><code id="claim_payment_inflation_+3A_payment_time_list">payment_time_list</code></td>
<td>
<p>(compound) list of payment times on a <strong>continuous</strong>
time scale.</p>
</td></tr>
<tr><td><code id="claim_payment_inflation_+3A_occurrence_list">occurrence_list</code></td>
<td>
<p>(compound) list of occurrence times on a
<strong>continuous</strong> time scale.</p>
</td></tr>
<tr><td><code id="claim_payment_inflation_+3A_claim_size_list">claim_size_list</code></td>
<td>
<p>list of claim sizes.</p>
</td></tr>
<tr><td><code id="claim_payment_inflation_+3A_base_inflation_vector">base_inflation_vector</code></td>
<td>
<p>vector showing <strong>quarterly</strong> base inflation
rates (quarterly effective) for all the periods under consideration (default
at nil base inflation).</p>
</td></tr>
<tr><td><code id="claim_payment_inflation_+3A_si_occurrence_function">si_occurrence_function</code></td>
<td>
<p>function of <code>occurrence_time</code> and
<code>claim_size</code> that outputs the superimposed inflation index with respect
to claim occurrence time (see Details for the default inflation function).</p>
</td></tr>
<tr><td><code id="claim_payment_inflation_+3A_si_payment_funtion">si_payment_funtion</code></td>
<td>
<p>function of <code>payment_time</code> and
<code>claim_size</code> that outputs the superimposed inflation index with respect
to payment time (see Details for the default inflation function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a compound list structure such that the <code class="reqn">j</code>th component
of the <code class="reqn">i</code>th sub-list gives the <strong>inflated</strong> payment pattern (as a
vector) for the <code class="reqn">j</code>th claim of occurrence period <code class="reqn">i</code>. <br /> <br />
By default we assume
</p>

<ul>
<li><p> Nil base inflation.
</p>
</li>
<li><p> No superimposed inflation by (continuous) occurrence time for the first 20
quarters (converted to the relevant <code>time_unit</code>); beyond 20 quarters, the
inflation index is given by
</p>
<p style="text-align: center;"><code class="reqn">1 - 0.4 max(0, 1 - claim_size/(0.25 * ref_claim))</code>
</p>

<p>where <code>ref_claim</code> is a package-wise global variable that user is required to
define at the top of their code using <code><a href="#topic+set_parameters">set_parameters</a></code>. The
interpretation is that, due to some external change to the insurance scheme
at the end of occurrence quarter 20, the smallest claims will reduce by up to
40% in size. This change will not impact claims exceeding <code>0.25*ref_claim</code> in
size. The reduction varies linearly between these claim sizes.
</p>
</li>
<li><p> Superimposed inflation by (continuous) payment time operates at a period
rate of </p>
<p style="text-align: center;"><code class="reqn">\gamma * max(0, 1 - claim_size/ref_claim)</code>
</p>
<p> where <code class="reqn">\gamma</code> is
equivalent to a 30% p.a. inflation rate (converted to the relevant
<code>time_unit</code>). The interpretation is that, for claims of small size the
payment time superimposed inflation tends to be very high (30% p.a.);
whereas for claims exceeding <code>ref_claim</code> in dollar values as of <code class="reqn">t = 0</code>,
the payment time superimposed inflation is nil. The rate of inflation
varies linearly between claim sizes of zero and <code>ref_claim</code>. <br /> <br />
</p>
</li></ul>

<p><strong>Remark on continuous inflation</strong>: We note that <code>SynthETIC</code> works with
exact transaction times, so time has been measured continuously throughout
the program. This allows us to apply inflation on a continous time scale too.
For example, we asked the users to provide base inflation as a vector of
quarterly base inflation rates, quarterly effective for all the periods under
consideration. This data is generally available online (e.g. the Australian
quarterly inflation is available on RBA's website - see
<a href="https://www.rba.gov.au/inflation/measures-cpi.html#quarterly">link</a>). We
then interpolate the quarterly inflation rates to compute the addition of
inflation by exact times. In the case of above, if we observed quarterly
inflation rates of 0.6%, 0.5%, 0.7% and 0.3% for one particular year, then
the base inflation applied to a payment at time <code class="reqn">t = 1.82</code> quarters will
be <code class="reqn">1.006 * 1.005^{0.82}</code>.
</p>
<p><strong>Remark on out-of-bound payment times</strong>: This function includes adjustment
for out-of-bound transaction dates, by forcing payments that were projected
to fall out of the maximum development period to be paid at the exact end of
the maximum development period allowed. For example, if we consider 40
periods of development and a claim incurred in the interval (20, 21] was
projected to have a payment at time 62.498210, then we would treat such a
payment as if it occurred at time 60 for the purpose of inflation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># remove SI occurrence and SI payment
SI_occurrence &lt;- function(occurrence_time, claim_size) {1}
SI_payment &lt;- function(payment_time, claim_size) {1}
# base inflation constant at 0.02 p.a. effective
# (length is 80 to cover the maximum time period)
base_inflation_vector &lt;- rep((1 + 0.02)^(1/4) - 1, times = 80)
attach(test_claims_object)
payment_inflated_list &lt;- claim_payment_inflation(
  frequency_vector, payment_size_list, payment_time_list,
  occurrence_list, claim_size_list, base_inflation_vector,
  SI_occurrence, SI_payment
)
detach(test_claims_object) # undo the attach
# inflated payments for claim 1 of occurrence period 1
payment_inflated_list[[1]][[1]]
</code></pre>

<hr>
<h2 id='claim_payment_no'>Number of Partial Payments</h2><span id='topic+claim_payment_no'></span>

<h3>Description</h3>

<p>Simulates and returns the number of partial payments required to settle each
of the claims occurring in each of the periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_payment_no(frequency_vector, claim_size_list, rfun, paramfun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_payment_no_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="claim_payment_no_+3A_claim_size_list">claim_size_list</code></td>
<td>
<p>list of claim sizes.</p>
</td></tr>
<tr><td><code id="claim_payment_no_+3A_rfun">rfun</code></td>
<td>
<p>optional alternative random sampling function; see Details for
default.</p>
</td></tr>
<tr><td><code id="claim_payment_no_+3A_paramfun">paramfun</code></td>
<td>
<p>parameters for the random sampling function, as a function of
<code>claim_size</code>; see Details.</p>
</td></tr>
<tr><td><code id="claim_payment_no_+3A_...">...</code></td>
<td>
<p>other arguments/parameters to be passed onto <code>paramfun</code>, e.g.
if going with the default sampling distribution, you can specify a
<code>claim_size_benchmark_1</code> (below which claims are assumed to be settled with 1
or 2 payments) and <code>claim_size_benchmark_2</code> (below which claims are assumed
to be settled with 2 or 3 payments).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a list structure such that the <code class="reqn">i</code>th component of the
list gives the number of partial payments required to settle each of the
claims that occurred in period <code class="reqn">i</code>. It is assumed that at least one
payment is required i.e. no claims are settled without any single cash
payment.
</p>
<p>Let <code class="reqn">M</code> represent the number of partial payments associated with a
particular claim. The default <code>simulate_no_pmt_function</code> is set up
such that if <code>claim_size</code> <code class="reqn">\le</code> <code>claim_size_benchmark_1</code>,
</p>
<p style="text-align: center;"><code class="reqn">Pr(M = 1) = Pr(M = 2) = 1/2;</code>
</p>
<p> if <code>claim_size_benchmark_1</code> &lt;
<code>claim_size</code> <code class="reqn">\le</code> <code>claim_size_benchmark_2</code>,
</p>
<p style="text-align: center;"><code class="reqn">Pr(M = 2) = 1/3, Pr(M = 3) = 2/3;</code>
</p>

<p>if <code>claim_size</code> &gt; <code>claim_size_benchmark_2</code>
then <code class="reqn">M</code> is geometric with minimum 4 and mean
</p>
<p style="text-align: center;"><code class="reqn">min(8, 4 + log(claim_size/claim_size_benchmark_2)).</code>
</p>

<p>Alternative sampling distributions are supported through <code>rfun</code> (the random
generation function) and <code>paramfun</code> (which returns the parameters of <code>rfun</code>
as a function of <code>claim_size</code>). The <code>paramfun</code> should return the distribution
parameters in a <strong>vector</strong>, e.g. for gamma distribution <code>paramfun</code> should
return a value in the format of <code>c(shape = , scale = )</code>. If a <code>rfun</code> is
specified without a <code>paramfun</code>, <code>SynthETIC</code> will try to proceed without
parameterisation (i.e. directly calling <code>rfun</code> with <code>claim_size</code>), and if it
fails, then return an error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_vector &lt;- claim_frequency(I = 10)
# with default simulation function
no_payments &lt;- claim_payment_no(n_vector, claim_size(n_vector))
no_payments[[1]] # number of payments for claims incurred in period 1

# modify the lower benchmark value
claim_payment_no(n_vector, claim_size(n_vector),
                 claim_size_benchmark_1 = 5000)
</code></pre>

<hr>
<h2 id='claim_payment_size'>Size of Partial Payments (Without Inflation)</h2><span id='topic+claim_payment_size'></span>

<h3>Description</h3>

<p>Simulates and returns the constant dollar amount of each partial payment
(i.e.<strong>without inflation</strong>) for each of the claims occurring in each of
the periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_payment_size(
  frequency_vector,
  claim_size_list,
  no_payments_list,
  rfun,
  paramfun,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_payment_size_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="claim_payment_size_+3A_claim_size_list">claim_size_list</code></td>
<td>
<p>list of claim sizes.</p>
</td></tr>
<tr><td><code id="claim_payment_size_+3A_no_payments_list">no_payments_list</code></td>
<td>
<p>list of number of partial payments.</p>
</td></tr>
<tr><td><code id="claim_payment_size_+3A_rfun">rfun</code></td>
<td>
<p>optional alternative random sampling function; see Details for
default.</p>
</td></tr>
<tr><td><code id="claim_payment_size_+3A_paramfun">paramfun</code></td>
<td>
<p>parameters for the random sampling function, as a function of
<code>claim_size</code>; see Details.</p>
</td></tr>
<tr><td><code id="claim_payment_size_+3A_...">...</code></td>
<td>
<p>other arguments/parameters to be passed onto <code>paramfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a compound list structure such that the <code class="reqn">j</code>th component
of the <code class="reqn">i</code>th sub-list gives the payment pattern (as a vector) for the
<code class="reqn">j</code>th claim of occurrence period <code class="reqn">i</code>.
</p>
<p>The default <code>rfun</code> is set up in three steps. First
we sample the <strong>complement</strong> of the proportion of total claim size
represented by the last two payments, from a Beta distribution with mean
</p>
<p style="text-align: center;"><code class="reqn">1 - min(0.95, 0.75 + 0.04log[claim_size/(0.10 * ref_claim)])</code>
</p>
<p> where
<code>ref_claim</code> is a package-wise global variable that we ask the user to define
at the top of their code using <code><a href="#topic+set_parameters">set_parameters</a></code>. CoV is assumed
constant at 20%.
</p>
<p>Next we simulate the proportion of last_two_pmts paid in the second last
payment (<em>settlement of the claim</em>) from a Beta distribution with
mean = 0.90 and CoV = 3%.
</p>
<p>Lastly we sample the remaining payment proportions from a Beta distribution
with mean </p>
<p style="text-align: center;"><code class="reqn">(1 - last_two_payments)/(no_pmt - 2)</code>
</p>
<p> and CoV = 10%, which
is followed by a normalisation such that the proportions add up to 1.
</p>
<p>In the cases where there are only 2 or 3 partial payments, proceed as if
there were 4 or 5 payments respectively with last_two_payments = 0. The
trivial case is when the claim is settled with a single payment, which must
be of the same amount as the total claim size.
</p>
<p>Alternative sampling distributions are supported through <code>rfun</code> (the random
generation function) and <code>paramfun</code> (which returns the parameters of <code>rfun</code>
as a function of <code>claim_size</code>). The <code>paramfun</code> should return the distribution
parameters in a <strong>vector</strong>, e.g. for gamma distribution <code>paramfun</code> should
return a value in the format of <code>c(shape = , scale = )</code>. If a <code>rfun</code> is
specified without a <code>paramfun</code>, <code>SynthETIC</code> will try to proceed without
parameterisation (i.e. directly calling <code>rfun</code> with <code>claim_size</code>), and if it
fails, then return an error message.
</p>


<h3>Explanation</h3>

<p>Why did we set up a payment pattern as above?
</p>
<p>The payment pattern is set up to reflect the typical pattern of a claim from
an Auto liability line of business, which usually consists of:
</p>

<ol>
<li><p> (possibly) some small payments such as police reports, medical
consultations and reports;
</p>
</li>
<li><p> some more substantial payments such as hospitalisation, specialist
medical procedures, equipment (e.g. prosthetics);
</p>
</li>
<li><p> a final settlement with the claimant (usually the second last payment);
</p>
</li>
<li><p> a smaller final payment, usually covering legal costs.
</p>
</li></ol>

<p>Claims in a number of other lines of business exhibit a similar structure,
albeit with possible differences in the types of payment made.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up
n_vector &lt;- claim_frequency(I = 10)
claim_sizes &lt;- claim_size(n_vector)
no_payments &lt;- claim_payment_no(n_vector, claim_sizes)

# with default rfun
payments &lt;- claim_payment_size(n_vector, claim_sizes, no_payments)
# partial payment sizes for claim 1 of occurrence period 1
payments[[1]][[1]]

# with some custom rfun
# simplistic case: (stochastically) equal amounts
my_func &lt;- function(n, claim_size) {
  prop &lt;- runif(n)
  prop &lt;- prop / sum(prop)
  claim_size * prop
}
mypayments &lt;- claim_payment_size(n_vector, claim_sizes, no_payments, my_func)
# partial payment sizes for claim 1 of occurrence period 1
mypayments[[1]][[1]]
</code></pre>

<hr>
<h2 id='claim_payment_time'>Partial Payment Times (in Continuous Time Scale)</h2><span id='topic+claim_payment_time'></span>

<h3>Description</h3>

<p>Converts the list of inter-partial delays to a list of payment times in
continuous time scale. Set <code>discrete = TRUE</code> to get the payment times in
calendar periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_payment_time(
  frequency_vector,
  occurrence_list,
  notification_list,
  payment_delay_list,
  discrete = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_payment_time_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="claim_payment_time_+3A_occurrence_list">occurrence_list</code></td>
<td>
<p>list of claim occurrence times.</p>
</td></tr>
<tr><td><code id="claim_payment_time_+3A_notification_list">notification_list</code></td>
<td>
<p>list of notification delays.</p>
</td></tr>
<tr><td><code id="claim_payment_time_+3A_payment_delay_list">payment_delay_list</code></td>
<td>
<p>(compound) list of inter partial delays.</p>
</td></tr>
<tr><td><code id="claim_payment_time_+3A_discrete">discrete</code></td>
<td>
<p>logical; if TRUE returns integer-valued payment times
(default FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a compound list structure such that the <code class="reqn">j</code>th component
of the <code class="reqn">i</code>th sub-list gives the payment time pattern (as a vector) for
the <code class="reqn">j</code>th claim of occurrence period <code class="reqn">i</code>. <br /> <br />
Note that, as in the case of <code><a href="#topic+claim_closure">claim_closure</a></code>, this function can
result in out-of-bound payment dates (i.e. payment times beyond the maximum
number of development periods under consideration). In these cases, we retain
the original simulated values for the simulation of other quantities, but we
will make adjustments for such claims in the tabulation of results in
<code><a href="#topic+claim_output">claim_output</a></code> and the payment inflation function
<code><a href="#topic+claim_payment_inflation">claim_payment_inflation</a></code>.
</p>

<hr>
<h2 id='claim_size'>Claim Size</h2><span id='topic+claim_size'></span>

<h3>Description</h3>

<p>Simulates and returns the size of each of the claims occurring in each of
the periods, given its cumulative distribution function.
<br /> <br /> Note that <code>claim_size()</code> aims to model the claim sizes
<strong>without inflation</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_size(frequency_vector, simfun, type = c("r", "p"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_size_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="claim_size_+3A_simfun">simfun</code></td>
<td>
<p>optional alternative sampling distribution; see Details.</p>
</td></tr>
<tr><td><code id="claim_size_+3A_type">type</code></td>
<td>
<p>the type of <code>simfun</code> provided. The default is a random generation
function (e.g. <code>rweibull</code>); the alternative <code>"p"</code> is any valid cumulative
distribution function (e.g. <code>pweibull</code>).</p>
</td></tr>
<tr><td><code id="claim_size_+3A_...">...</code></td>
<td>
<p>other arguments/parameters to be passed onto <code>simfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default <code>claim_size()</code> assumes a left truncated power
normal distribution: <code class="reqn">S^0.2 ~ Normal (9.5, sd = 3)</code>, left truncated
at 30. The truncation is done via resampling for rejected values. <br /> <br />
Users can opt to use alternative distributions if desired. As discussed in
<code><a href="#topic+claim_frequency">claim_frequency</a></code>, users can declare such specification through
the <code>simfun</code> argument, which takes both random generation functions
(<code>type = "r"</code>, the default) and cumulative distribution functions
(<code>type = "p"</code>). See Examples. <br /> <br />
For the latter, <code>claim_size()</code> will first search for the existence of the
corresponding <code>r</code>-function. If it notes the existence of such an <code>r</code>-function
(e.g. <code>rweibull</code> for <code>simfun = pweibull</code>), it will directly apply the
<code>r</code>-function to optimise simulation efficiency. Otherwise, the function uses
a numerical inverse transform method for simulation (see
<code><a href="#topic+simulate_cdf">simulate_cdf</a></code>), which may not be the most efficient and can
potentially result in errors if an appropriate <code>range</code> is not specified in
the optional arguments.
</p>


<h3>Value</h3>

<p>A list of claim sizes such that the <code class="reqn">i</code>th component of the
list gives the sizes for all claims that occurred in period <code class="reqn">i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_vector &lt;- c(90, 79, 102, 78, 86, 88, 116, 84, 93, 104)
claim_size(n_vector)[[1]] # gives the sizes for all
                          # all claims incurred in period 1

# use some custom pre-defined distribution function
claim_size(n_vector, stats::rweibull, shape = 4, scale = 100000)[[1]]
# equivalently
claim_size(n_vector, stats::pweibull, "p", shape = 4, scale = 100000)[[1]]
</code></pre>

<hr>
<h2 id='claim_size_adj'>Covariates Claim Size Adjustment</h2><span id='topic+claim_size_adj'></span>

<h3>Description</h3>

<p>Adjusts claim sizes given a set of covariates. Note that this function firstly simulates covariate levels for each claim, see <code><a href="#topic+simulate_covariates">simulate_covariates</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_size_adj(covariate_obj, claim_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_size_adj_+3A_covariate_obj">covariate_obj</code></td>
<td>
<p>a <code><a href="#topic+covariates">covariates</a></code> object</p>
</td></tr>
<tr><td><code id="claim_size_adj_+3A_claim_size">claim_size</code></td>
<td>
<p>a list in the same output as <code><a href="#topic+claim_size">claim_size</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a nested named list:
</p>

<ul>
<li> <p><code>covariates_data</code> which is a named list of covariate relativities (<code><a href="#topic+covariates">covariates</a></code>), the simulated covariate levels (<code>data</code>) and the claim IDs.
</p>
</li>
<li> <p><code>claim_size_adj</code> which is a list of adjusted claim sizes such that the <code class="reqn">i</code>th component of the list gives the sizes for all claims that occurred in period <code class="reqn">i</code>.
</p>
</li></ul>


<hr>
<h2 id='claim_size_adj.fit'>Covariates Claim Size Adjustment</h2><span id='topic+claim_size_adj.fit'></span>

<h3>Description</h3>

<p>Adjusts claim sizes given the covariates related to each claim. The relative adjustment of each claim size is given by the severity relativities of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claim_size_adj.fit(covariates_data, claim_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claim_size_adj.fit_+3A_covariates_data">covariates_data</code></td>
<td>
<p>a <code>covariates_data</code> object</p>
</td></tr>
<tr><td><code id="claim_size_adj.fit_+3A_claim_size">claim_size</code></td>
<td>
<p>a list in the same output as <code><a href="#topic+claim_size">claim_size</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='claims'>Construction of a <code>claims</code> Object</h2><span id='topic+claims'></span>

<h3>Description</h3>

<p>Constructs a <code>claims</code> object which stores all the simulated quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>claims(
  frequency_vector,
  occurrence_list,
  claim_size_list,
  notification_list,
  settlement_list,
  no_payments_list,
  payment_size_list,
  payment_delay_list,
  payment_time_list,
  payment_inflated_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="claims_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="claims_+3A_occurrence_list">occurrence_list</code></td>
<td>
<p>list of claim occurrence times.</p>
</td></tr>
<tr><td><code id="claims_+3A_claim_size_list">claim_size_list</code></td>
<td>
<p>list of claim sizes.</p>
</td></tr>
<tr><td><code id="claims_+3A_notification_list">notification_list</code></td>
<td>
<p>list of notification delays.</p>
</td></tr>
<tr><td><code id="claims_+3A_settlement_list">settlement_list</code></td>
<td>
<p>list of settlement delays.</p>
</td></tr>
<tr><td><code id="claims_+3A_no_payments_list">no_payments_list</code></td>
<td>
<p>list of number of partial payments.</p>
</td></tr>
<tr><td><code id="claims_+3A_payment_size_list">payment_size_list</code></td>
<td>
<p>(compound) list of payment size pattern (without
inflation).</p>
</td></tr>
<tr><td><code id="claims_+3A_payment_delay_list">payment_delay_list</code></td>
<td>
<p>(compound) list of inter partial delays.</p>
</td></tr>
<tr><td><code id="claims_+3A_payment_time_list">payment_time_list</code></td>
<td>
<p>(compound) list of payment times on a <strong>continuous</strong>
time scale.</p>
</td></tr>
<tr><td><code id="claims_+3A_payment_inflated_list">payment_inflated_list</code></td>
<td>
<p>(compound) list of payment size pattern (after
inflation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>claims</code> object (mainly a reformat of the arguments as a
list object), with the 10 components as listed above.
</p>

<hr>
<h2 id='covariates'>Construction of a <code>covariates</code> Object</h2><span id='topic+covariates'></span>

<h3>Description</h3>

<p>Constructs a <code>covariates</code> object which stores all covariate inputs.
All covariates will be assumed discrete.
Continuous covariates will have been discretized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariates(factors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariates_+3A_factors">factors</code></td>
<td>
<p>named list of vectors, containing the name of the covariates
and associated factors in vector form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creating a <code>covariates</code> object will provide template relativities for the
frequency and severity relativities. It is encouraged to use the setter
functions <code><a href="#topic+set.covariates_relativity">set.covariates_relativity</a></code> to set these values to ensure that
all necessary inputs are provided.
</p>


<h3>Value</h3>

<p>Returns a <code>covariates</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>factors &lt;- list(
"Legal Representation" = c("Y", "N"),
"Injury Severity" = as.character(1:6),
"Age of Claimant" = c("0-15", "15-30", "30-50", "50-65", "over 65")
)

covariate_obj &lt;- covariates(factors)
</code></pre>

<hr>
<h2 id='covariates_data'>Construction of a <code>covariates_data</code> Object</h2><span id='topic+covariates_data'></span>

<h3>Description</h3>

<p>Constructs a <code>covariates_data</code> object which stores the dataset of known covariate levels of each factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariates_data(covariates, data, covariates_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariates_data_+3A_covariates">covariates</code></td>
<td>
<p>a <code><a href="#topic+covariates">covariates</a></code> object</p>
</td></tr>
<tr><td><code id="covariates_data_+3A_data">data</code></td>
<td>
<p>a dataset of covariate values, with columns equal to each of the covariate factors and rows related to individual claim observations.</p>
</td></tr>
<tr><td><code id="covariates_data_+3A_covariates_id">covariates_id</code></td>
<td>
<p>optional list of list of ids, in the same format as a <code><a href="#topic+claim_size">claim_size</a></code> output. Also see <code><a href="#topic+to_SynthETIC">to_SynthETIC</a></code>. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>covariates_data</code> object.
</p>

<hr>
<h2 id='covariates_relativity'>Calculates Relativities</h2><span id='topic+covariates_relativity'></span>

<h3>Description</h3>

<p>Calculates the relativities (<code>freq</code> or <code>sev</code>) of a set of covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariates_relativity(
  covariates_data,
  freq_sev = c("freq", "sev"),
  by_ids = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariates_relativity_+3A_covariates_data">covariates_data</code></td>
<td>
<p>a <code><a href="#topic+covariates_data">covariates_data</a></code> object</p>
</td></tr>
<tr><td><code id="covariates_relativity_+3A_freq_sev">freq_sev</code></td>
<td>
<p>one of <code>freq</code> or <code>sev</code> to calculate the frequency or severity relativity respectively.</p>
</td></tr>
<tr><td><code id="covariates_relativity_+3A_by_ids">by_ids</code></td>
<td>
<p>optional boolean to calculate reorder the result based off claim observations instead of observations in the covariates dataset. Defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='cv'>Coefficient of Variation</h2><span id='topic+cv'></span>

<h3>Description</h3>

<p>Returns the observed coefficient of variation (CoV) of a given sample
<code>x</code>. <br /> <br />
If <code>na.rm</code> is true then missing values are removed before
computation proceeds, as in the case of the <code>mean()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="cv_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficient of variation is defined as is defined as the
ratio of the standard deviation to the mean. It shows the extent of
variability in relation to the mean of the population. <br /> <br />
<code>cv()</code> estimates the CoV of a given sample by computing the ratio of
the sample standard deviation (see <code>stats::sd</code>) to the sample mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cv(1:10)
</code></pre>

<hr>
<h2 id='generate_claim_dataset'>Generate a Claims Dataset</h2><span id='topic+generate_claim_dataset'></span>

<h3>Description</h3>

<p>Generates a dataset of claims records that takes the same structure as
<code>test_claim_dataset</code> included in this package, with each row
representing a unique claim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_claim_dataset(
  frequency_vector,
  occurrence_list,
  claim_size_list,
  notification_list,
  settlement_list,
  no_payments_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_claim_dataset_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="generate_claim_dataset_+3A_occurrence_list">occurrence_list</code></td>
<td>
<p>list of claim occurrence times.</p>
</td></tr>
<tr><td><code id="generate_claim_dataset_+3A_claim_size_list">claim_size_list</code></td>
<td>
<p>list of claim sizes.</p>
</td></tr>
<tr><td><code id="generate_claim_dataset_+3A_notification_list">notification_list</code></td>
<td>
<p>list of notification delays.</p>
</td></tr>
<tr><td><code id="generate_claim_dataset_+3A_settlement_list">settlement_list</code></td>
<td>
<p>list of settlement delays.</p>
</td></tr>
<tr><td><code id="generate_claim_dataset_+3A_no_payments_list">no_payments_list</code></td>
<td>
<p>list of number of partial payments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe that takes the same structure as
<code><a href="#topic+test_claim_dataset">test_claim_dataset</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test_claim_dataset">test_claim_dataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># demo only, in practice might generate claim dataset before simulating
# the partial payments
# this code generates the built-in test_claim_dataset
attach(test_claims_object)
claim_dataset &lt;- generate_claim_dataset(
  frequency_vector, occurrence_list, claim_size_list, notification_list,
  settlement_list, no_payments_list
)
detach(test_claims_object)
</code></pre>

<hr>
<h2 id='generate_transaction_dataset'>Generate a Transactions Dataset</h2><span id='topic+generate_transaction_dataset'></span>

<h3>Description</h3>

<p>Generates a dataset of partial payment records that takes the same structure
as <code>test_transaction_dataset</code> included in this package, with each row
representing a unique payment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_transaction_dataset(claims, adjust = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_transaction_dataset_+3A_claims">claims</code></td>
<td>
<p>an <code>claims</code> object containing all the simulated quantities,
see <code><a href="#topic+claims">claims</a></code>.</p>
</td></tr>
<tr><td><code id="generate_transaction_dataset_+3A_adjust">adjust</code></td>
<td>
<p>if TRUE then the payment times will be forced to match with the
maximum development period under consideration; default FALSE (which will
produce out-of-bound payment times).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe that takes the same structure as
<code><a href="#topic+test_transaction_dataset">test_transaction_dataset</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test_transaction_dataset">test_transaction_dataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this generates the built-in test_transaction_dataset
transact_data &lt;- generate_transaction_dataset(test_claims_object)

</code></pre>

<hr>
<h2 id='get_Beta_parameters'>Estimating Beta Parameters</h2><span id='topic+get_Beta_parameters'></span>

<h3>Description</h3>

<p>Returns the Beta parameters given the mean and the CoV of the target Beta
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Beta_parameters(target_mean, target_cv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Beta_parameters_+3A_target_mean">target_mean</code></td>
<td>
<p>mean of the target Beta distribution (between 0 and 1).</p>
</td></tr>
<tr><td><code id="get_Beta_parameters_+3A_target_cv">target_cv</code></td>
<td>
<p>CoV of the target Beta distribution.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>get_Beta_parameters(target_mean = 0.5, target_cv = 0.20)
get_Beta_parameters(target_mean = 0.5,
                    target_cv = c(0.10, 0.20, 0.30))
</code></pre>

<hr>
<h2 id='get_Weibull_parameters'>Estimating Weibull Parameters</h2><span id='topic+get_Weibull_parameters'></span>

<h3>Description</h3>

<p>Returns the Weibull shape and scale parameters given the mean and the CoV
of the target Weibull distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Weibull_parameters(target_mean, target_cv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Weibull_parameters_+3A_target_mean">target_mean</code></td>
<td>
<p>mean of the target Weibull distribution.</p>
</td></tr>
<tr><td><code id="get_Weibull_parameters_+3A_target_cv">target_cv</code></td>
<td>
<p>CoV of the target Weibull distribution.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>get_Weibull_parameters(target_mean = 100000, target_cv = 0.60)
get_Weibull_parameters(target_mean = c(100000, 200000, 300000),
                       target_cv = 0.60)
</code></pre>

<hr>
<h2 id='plot_transaction_dataset'>Plot of Cumulative Claims Payments (Incurred Pattern)</h2><span id='topic+plot_transaction_dataset'></span>

<h3>Description</h3>

<p>Generates a plot of cumulative claims paid (as a percentage of total amount
incurred) as a function of development time for each occurrence period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_transaction_dataset(
  transactions,
  occurrence_time_col = "occurrence_time",
  payment_time_col = "payment_time",
  payment_size_col = "payment_inflated",
  by_year = FALSE,
  adjust = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_transaction_dataset_+3A_transactions">transactions</code></td>
<td>
<p>a dataset of partial payment records.</p>
</td></tr>
<tr><td><code id="plot_transaction_dataset_+3A_occurrence_time_col">occurrence_time_col</code></td>
<td>
<p>name of column that stores the time of occurrence
of the claims (on a <strong>continuous</strong> scale).</p>
</td></tr>
<tr><td><code id="plot_transaction_dataset_+3A_payment_time_col">payment_time_col</code></td>
<td>
<p>name of column that stores the time of partial
payments of the claims (on a <strong>continuous</strong> scale).</p>
</td></tr>
<tr><td><code id="plot_transaction_dataset_+3A_payment_size_col">payment_size_col</code></td>
<td>
<p>name of column that stores the size of partial
payments of the claims.</p>
</td></tr>
<tr><td><code id="plot_transaction_dataset_+3A_by_year">by_year</code></td>
<td>
<p>if <code>TRUE</code> returns a plot by occurrence year; otherwise returns
a plot by occurrence period (default).</p>
</td></tr>
<tr><td><code id="plot_transaction_dataset_+3A_adjust">adjust</code></td>
<td>
<p>if <code>TRUE</code> then the payment times will be forced to match with
the maximum development period under consideration, otherwise the plot will
see claims beyond the maximum development period; default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+generate_transaction_dataset">generate_transaction_dataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_transaction_dataset(test_transaction_dataset)

# Plot claim development without end-of-development-period correction
plot_transaction_dataset(test_transaction_dataset, adjust = FALSE)

# Plot claim development without inflation effects
plot_transaction_dataset(test_transaction_dataset, payment_size_col = "payment_size")
</code></pre>

<hr>
<h2 id='plot.claims'>Plot of Cumulative Claims Payments (Incurred Pattern)</h2><span id='topic+plot.claims'></span>

<h3>Description</h3>

<p>Generates a plot of cumulative claims paid (as a percentage of total amount
incurred) as a function of development time for each occurrence period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'claims'
plot(x, by_year = FALSE, inflated = TRUE, adjust = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.claims_+3A_x">x</code></td>
<td>
<p>an object of class <code>claims</code> containing all the simulated quantities.</p>
</td></tr>
<tr><td><code id="plot.claims_+3A_by_year">by_year</code></td>
<td>
<p>if <code>TRUE</code> returns a plot by occurrence year; otherwise returns
a plot by occurrence period (default).</p>
</td></tr>
<tr><td><code id="plot.claims_+3A_inflated">inflated</code></td>
<td>
<p>if <code>TRUE</code> shows a plot of payment pattern after inflation;
otherwise shows a plot of discounted payment pattern.</p>
</td></tr>
<tr><td><code id="plot.claims_+3A_adjust">adjust</code></td>
<td>
<p>if <code>TRUE</code> then the payment times will be forced to match with
the maximum development period under consideration, otherwise the plot will
see claims beyond the maximum development period; default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.claims_+3A_...">...</code></td>
<td>
<p>other graphical parameters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+claims">claims</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(test_claims_object)
plot(test_claims_object, adjust = FALSE)
</code></pre>

<hr>
<h2 id='relativity_template'>Template to input Covariate Relativities</h2><span id='topic+relativity_template'></span>

<h3>Description</h3>

<p>Constructs a template for the covariate relativities based on the
inputed covariates. Note that only non-zero relativities and one cross-factor
relativity is needed for each factor pair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relativity_template(factors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relativity_template_+3A_factors">factors</code></td>
<td>
<p>named list of vectors, containing the name of the covariates
and associated factors in vector form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that there are <code class="reqn">m</code> covariates labelled <code class="reqn">c_i</code>, <code class="reqn">i=1,...,m</code>,
and that covariate <code class="reqn">c_i</code> can assume one and only one of <code class="reqn">n_i</code> values,
<code class="reqn">x_{ik}</code>, <code class="reqn">k=1,...,n_i</code>. The total number of available covariate
values is <code class="reqn">n = \sum_{i=1}^m n_o</code>.
</p>
<p>Now set up an <code class="reqn">n \times n</code> matrix <code class="reqn">F</code>, consisting of sub-matrices
<code class="reqn">F_{ij}</code>, <code class="reqn">i,j = 1, ... ,m</code> of dimension <code class="reqn">n_i \times n_j</code>. The
diagonal blocks <code class="reqn">F_{ii}</code> will quantify first-order relativities on claims
attributes, and the off-diagonal blocks <code class="reqn">F_{ij}</code>, <code class="reqn">j \neq i</code> will quantify
second-order effects. Let <code class="reqn">f_{ij,kl}</code> denote the <code class="reqn">(k, l)</code> element of
<code class="reqn">F_{ij}</code>. This element operates as a multiplier of the claim attribute
when covariates <code class="reqn">c_i</code> and <code class="reqn">c_j</code> take values <code class="reqn">x_{ik}</code> and <code class="reqn">x_jl</code>
respectively. Since <code class="reqn">c_i</code> can assume only one of the values <code class="reqn">x_ik</code>,
<code class="reqn">f_{ii, kl} = 0</code> for <code class="reqn">k \neq l</code>, and so <code class="reqn">F_{ii}</code> is diagonal for
all <code class="reqn">i=1, ..., m</code>. Moreover, <code class="reqn">f_{ij,kl} = f_{ji,lk}</code>, so that
<code class="reqn">F</code> is symmetric and <code class="reqn">f_{ij,kl} &gt; 0</code>.
</p>


<h3>Value</h3>

<p>Returns a dataframe object, with five columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>factor_i</code> </td><td style="text-align: left;"> Factor i. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>factor_j</code> </td><td style="text-align: left;"> Factor j. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>level_ik</code> </td><td style="text-align: left;"> Level within Factor i. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>level_jl</code> </td><td style="text-align: left;"> Level within Factor j. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>relativity</code> </td><td style="text-align: left;"> Relativity between <code>level_ik</code> and <code>level_jl</code>, defaults to <code>NA</code>.
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>factors &lt;- list(
    "Legal Representation" = c("Y", "N"),
    "Injury Severity" = as.character(1:6),
    "Age of Claimant" = c("0-15", "15-30", "30-50", "50-65", "over 65")
)

relativity_freq &lt;- relativity_template(factors)
relativity_sev &lt;- relativity_template(factors)

# Default Values
relativity_freq$relativity &lt;- c(
    1, 1,
    0.95, 1, 1, 1, 1, 1,
    0.05, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1,
    1, 1, 1, 1, 1,
    0.53, 0.3, 0.1, 0.05, 0.01, 0.01,
    1, 1, 1, 1, 1,
    1, 1, 1, 1, 1,
    1, 1, 1, 1, 1,
    1, 1, 1, 1, 1,
    1, 1, 1, 1, 1,
    1, 1, 1, 1, 1,
    0.183, 0.192, 0.274, 0.18, 0.171
)

relativity_sev$relativity &lt;- c(
    2, 1,
    1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1,
    1, 1, 1, 1, 1,
    0.6, 1.2, 2.5, 5, 8, 0.4,
    1, 1, 1, 1, 1,
    1, 1, 1, 1, 1,
    1, 1, 1, 1, 1,
    1, 1, 1, 0.97, 0.95,
    1, 1, 1, 0.95, 0.9,
    1, 1, 1, 1, 1,
    1.25, 1.15, 1, 0.85, 0.7
)

head(relativity_freq)
head(relativity_sev)

test_covariates_obj &lt;- covariates(factors)
test_covariates_obj &lt;- set.covariates_relativity(
    covariates = test_covariates_obj,
    relativity = relativity_freq,
    freq_sev = "freq"
)
test_covariates_obj &lt;- set.covariates_relativity(
    covariates = test_covariates_obj,
    relativity = relativity_sev,
    freq_sev = "sev"
)

</code></pre>

<hr>
<h2 id='return_parameters'>Get Current Parameters</h2><span id='topic+return_parameters'></span>

<h3>Description</h3>

<p>Returns the current values of <code>ref_claim</code> and <code>time_unit</code> parameters, two
packagewise-global variables used by all simulation functions within this
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_parameters(print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="return_parameters_+3A_print">print</code></td>
<td>
<p>logical; if TRUE prints a message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns and (optionally) prints the current values of <code>ref_claim</code>
and <code>time_unit</code> parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_parameters">set_parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cur &lt;- return_parameters()
cur
set_parameters(ref_claim = 200000, time_unit = 1/12) # monthly reserving
return_parameters(print = FALSE)
</code></pre>

<hr>
<h2 id='set_parameters'>Set Packagewise Global Parameters for the Claims Simulator</h2><span id='topic+set_parameters'></span>

<h3>Description</h3>

<p>Sets <code>ref_claim</code> and <code>time_unit</code> parameters for all the simulation functions
within the <code>SynthETIC</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_parameters(ref_claim = 2e+05, time_unit = 1/4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_parameters_+3A_ref_claim">ref_claim</code></td>
<td>
<p>a reference value for the claim sizes (default 200000).</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_time_unit">time_unit</code></td>
<td>
<p>time unit to work with, given as a fraction of a year;
default calendar quarters (1/4).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Those variables will be available to multiple functions in this
package, but are kept local to the package environment (i.e. not accessible
from the global environment). To extract the current values of the variables,
use <code><a href="#topic+return_parameters">return_parameters</a></code>. <br /> <br />
We introduce the reference value <code>ref_claim</code> partly as a measure of the
monetary unit and/or overall claims experience. The default distributional
assumptions were set up with an Australian Auto Liability portfolio in mind.
<code>ref_claim</code> then allows users to easily simulate a synthetic portfolio with
similar claim pattern but in a different currency, for example. We also
remark that users can alternatively choose to interpret <code>ref_claim</code> as a
monetary unit. For example, one can set <code>ref_claim &lt;- 1000</code> and think of all
amounts in terms of $1,000. However, in this case the default simulation
functions will not work and users will need to supply their own set of
functions and set the values as multiples of <code>ref_claim</code> rather than
fractions as in the default setting. <br /> <br />
We also require the user to input a <code>time_unit</code> (which should be given as a
fraction of year), so that the default input parameters apply to contexts
where the time units are no longer in quarters. In the default setting we
have a <code>time_unit</code> of 1/4 i.e. we work with calendar quarters. <br /> <br />
The default input parameters will update automatically with the choice of
the two variables <code>ref_claim</code> and <code>time_unit</code>, which ensures that the
simulator produce sensible results in contexts other than the default
setting. We remark that both <code>ref_claim</code> and <code>time_unit</code> only affect the
default simulation functions, and users can also choose to set up their own
modelling assumptions for any of the modules to match their experiences even
better. In the latter case, it is the responsibility of the user to ensure
that their input parameters are compatible with their time units and claims
experience. For example, if the time units are quarters, then claim
occurrence rates must be quarterly.
</p>


<h3>See Also</h3>

<p>See the vignette for this package for a full list of functions
impacted by those two variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_parameters(ref_claim = 200000, time_unit = 1/12) # monthly reserving
</code></pre>

<hr>
<h2 id='set.covariates_relativity'>Sets the claims relativity for a <code>covariates</code> object.</h2><span id='topic+set.covariates_relativity'></span>

<h3>Description</h3>

<p>Sets the claims relativity for a <code>covariates</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.covariates_relativity(covariates, relativity, freq_sev = c("freq", "sev"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.covariates_relativity_+3A_covariates">covariates</code></td>
<td>
<p>an object of type <code>covariates</code>, see <code><a href="#topic+covariates">covariates</a></code></p>
</td></tr>
<tr><td><code id="set.covariates_relativity_+3A_relativity">relativity</code></td>
<td>
<p>see <code><a href="#topic+relativity_template">relativity_template</a></code></p>
</td></tr>
<tr><td><code id="set.covariates_relativity_+3A_freq_sev">freq_sev</code></td>
<td>
<p>one of <code>"freq"</code> or <code>"sev"</code> to adjust frequency or severity
relativities respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>covariates</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covariates">covariates</a></code>, <code><a href="#topic+relativity_template">relativity_template</a></code>
</p>

<hr>
<h2 id='simulate_cdf'>Inverse Tranform Sampling</h2><span id='topic+simulate_cdf'></span>

<h3>Description</h3>

<p>Generates sample numbers at random from any probability distribution
given its cumulative distribution function. Pre-defined distribution
functions such as <code>pnorm</code> are supported. <br /> <br />
See <a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling">here</a>
for the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_cdf(n, cdf, range = c(-1e+200, 1e+200), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_cdf_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="simulate_cdf_+3A_cdf">cdf</code></td>
<td>
<p>cumulative distribution function to be sampled from.</p>
</td></tr>
<tr><td><code id="simulate_cdf_+3A_range">range</code></td>
<td>
<p>support of the given <code>cdf</code>.</p>
</td></tr>
<tr><td><code id="simulate_cdf_+3A_...">...</code></td>
<td>
<p>other arguments/parameters to be passed onto <code>cdf</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>simulate_cdf(10, pnorm)
simulate_cdf(10, pbeta, shape1 = 2, shape2 = 2)
</code></pre>

<hr>
<h2 id='simulate_covariates'>Covariates Simulation</h2><span id='topic+simulate_covariates'></span>

<h3>Description</h3>

<p>Simulates covariates for each claim. The relative occurrence of each combination of covariates is given the frequency relativities of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_covariates(
  covariates,
  frequency_vector = 1,
  claim_size_list = list(1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_covariates_+3A_covariates">covariates</code></td>
<td>
<p>a <code><a href="#topic+covariates">covariates</a></code> object, which stores the frequency and severity relativities for given covariate levels.</p>
</td></tr>
<tr><td><code id="simulate_covariates_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector in the same output as <code><a href="#topic+claim_frequency">claim_frequency</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_covariates_+3A_claim_size_list">claim_size_list</code></td>
<td>
<p>optional if <code>frequency_vector</code> is not inputted. A list in the same output as <code><a href="#topic+claim_size">claim_size</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+covariates_data">covariates_data</a></code> object.
</p>

<hr>
<h2 id='SynthETIC-package'>SynthETIC: Synthetic Experience Tracking Insurance Claims</h2><span id='topic+SynthETIC'></span><span id='topic+SynthETIC-package'></span>

<h3>Description</h3>

<p>Creation of an individual claims simulator which generates various features of non-life insurance claims. An initial set of test parameters, designed to mirror the experience of an Auto Liability portfolio, were set up and applied by default to generate a realistic test data set of individual claims (see vignette). The simulated data set then allows practitioners to back-test the validity of various reserving models and to prove and/or disprove certain actuarial assumptions made in claims modelling. The distributional assumptions used to generate this data set can be easily modified by users to match their experiences. Reference: Avanzi B, Taylor G, Wang M, Wong B (2020) &quot;SynthETIC: an individual insurance claim simulator with feature control&quot; <a href="https://arxiv.org/abs/2008.05693">arXiv:2008.05693</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Melantha Wang <a href="mailto:wang.melantha@gmail.com">wang.melantha@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Benjamin Avanzi <a href="mailto:b.avanzi@unimelb.edu.au">b.avanzi@unimelb.edu.au</a>
</p>
</li>
<li><p> William Ho <a href="mailto:ho.w@unimelb.edu.au">ho.w@unimelb.edu.au</a>
</p>
</li>
<li><p> Greg Taylor <a href="mailto:greg_taylor60@hotmail.com">greg_taylor60@hotmail.com</a>
</p>
</li>
<li><p> Bernard Wong <a href="mailto:bernard.wong@unsw.edu.au">bernard.wong@unsw.edu.au</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/agi-lab/SynthETIC">https://github.com/agi-lab/SynthETIC</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/agi-lab/SynthETIC/issues">https://github.com/agi-lab/SynthETIC/issues</a>
</p>
</li></ul>


<hr>
<h2 id='test_claim_dataset'>Claims Dataset</h2><span id='topic+test_claim_dataset'></span>

<h3>Description</h3>

<p>A dataset of 3,624 rows containing individual claims features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_claim_dataset
</code></pre>


<h3>Format</h3>

<p>A data frame with 3,624 rows and 7 variables:
</p>

<dl>
<dt>claim_no</dt><dd><p>claim number, which uniquely characterises each claim.</p>
</dd>
<dt>occurrence_period</dt><dd><p>integer; period of ocurrence of the claim.</p>
</dd>
<dt>occurrence_time</dt><dd><p>double; time of occurrence of the claim.</p>
</dd>
<dt>claim_size</dt><dd><p>size of the claim (in constant dollar values).</p>
</dd>
<dt>notidel</dt><dd><p>notification delay of the claim, i.e. time from occurrence to notification.</p>
</dd>
<dt>setldel</dt><dd><p>settlement delay of the claim, i.e. time from notification to settlement.</p>
</dd>
<dt>no_payment</dt><dd><p>number of partial payments required for the claim.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># see a distribution of payment counts
table(test_claim_dataset$no_payment)
</code></pre>

<hr>
<h2 id='test_claim_dataset_cov'>Claims Dataset</h2><span id='topic+test_claim_dataset_cov'></span>

<h3>Description</h3>

<p>The <code>test_claim_dataset</code> where the default set of covariates have been applied to adjust claim sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_claim_dataset_cov
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 3624 rows and 7 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see a distribution of payment counts
table(test_claim_dataset_cov$no_payment)
</code></pre>

<hr>
<h2 id='test_claims_object'>Claims Data in List Format</h2><span id='topic+test_claims_object'></span>

<h3>Description</h3>

<p>A list containing a sample output from each of the simulation modules, in
sequential order of the running of the modules. This is the test data
generated when run with seed <code>20200131</code> at the top of the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_claims_object
</code></pre>


<h3>Format</h3>

<p>A <code>claims</code> object with 10 components:
</p>

<dl>
<dt>frequency_vector</dt><dd><p>vector; number of claims for each occurrence period, see also <code>claim_frequency()</code>.</p>
</dd>
<dt>occurrence_list</dt><dd><p>list; claim occurrence times for all claims that occurred in each of the period, see also <code>claim_occurrence()</code>.</p>
</dd>
<dt>claim_size_list</dt><dd><p>list; claim sizes for all claims that occurred in each of the period, see also <code>claim_size()</code>.</p>
</dd>
<dt>notification_list</dt><dd><p>list; notification delays for all claims that occurred in each of the period, see also <code>claim_notification()</code>.</p>
</dd>
<dt>settlement_list</dt><dd><p>list; settlement delays for all claims that occurred in each of the period, see also <code>claim_closure()</code>.</p>
</dd>
<dt>no_payments_list</dt><dd><p>list; number of partial payments for all claims that occurred in each of the period, see also <code>claim_payment_no()</code>.</p>
</dd>
<dt>payment_size_list</dt><dd><p>(compound) list; sizes of partial payments (without inflation) for all claims that occurred in each of the period, see also <code>claim_payment_size()</code>.</p>
</dd>
<dt>payment_delay_list</dt><dd><p>(compound) list; inter partial delays for all claims that occurred in each of the period, see also <code>claim_payment_delay()</code>.</p>
</dd>
<dt>payment_time_list</dt><dd><p>(compound) list; payment times (on a continuous time scale) for all claims that occurred in each of the period, see also <code>claim_payment_time()</code>.</p>
</dd>
<dt>payment_inflated_list</dt><dd><p>(compound) list; sizes of partial payments (with inflation) for all claims that occurred in each of the period, see also <code>claim_payment_inflation()</code>.</p>
</dd>
</dl>



<h3>See Also</h3>


<ol>
<li><p> Claim occurrence: <code><a href="#topic+claim_frequency">claim_frequency</a></code>, <code><a href="#topic+claim_occurrence">claim_occurrence</a></code>
</p>
</li>
<li><p> Claim size: <code><a href="#topic+claim_size">claim_size</a></code>
</p>
</li>
<li><p> Claim notification: <code><a href="#topic+claim_notification">claim_notification</a></code>
</p>
</li>
<li><p> Claim closure: <code><a href="#topic+claim_closure">claim_closure</a></code>
</p>
</li>
<li><p> Claim payment count: <code><a href="#topic+claim_payment_no">claim_payment_no</a></code>
</p>
</li>
<li><p> Claim payment size (without inflation): <code><a href="#topic+claim_payment_size">claim_payment_size</a></code>
</p>
</li>
<li><p> Claim payment time: <code><a href="#topic+claim_payment_delay">claim_payment_delay</a></code>, <code><a href="#topic+claim_payment_time">claim_payment_time</a></code>
</p>
</li>
<li><p> Claim inflation: <code><a href="#topic+claim_payment_inflation">claim_payment_inflation</a></code>
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>test_claims_object$frequency_vector
</code></pre>

<hr>
<h2 id='test_claims_object_cov'>Claims Data in List Format</h2><span id='topic+test_claims_object_cov'></span>

<h3>Description</h3>

<p>The <code>test_claims_object</code> where the default set of covariates have been applied to adjust claim sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_claims_object_cov
</code></pre>


<h3>Format</h3>

<p>An object of class <code>claims</code> of length 10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_claims_object$frequency_vector
</code></pre>

<hr>
<h2 id='test_covariates_dataset'>Covariates Data Object</h2><span id='topic+test_covariates_dataset'></span>

<h3>Description</h3>

<p>An object detailing the set of covariates for each claim in the default setting of <code>SynthETIC</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_covariates_dataset
</code></pre>


<h3>Format</h3>

<p>A <code>covariates_data</code> object with 3 components:
</p>

<dl>
<dt>data</dt><dd><p>data.frame; a dataset of covariate levels</p>
</dd>
<dt>covariates</dt><dd><p>covariates; a <code>covariates</code> object</p>
</dd>
<dt>ids</dt><dd><p>list; indices of the covariate-level dataset for each claim</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>test_covariates_dataset$data
</code></pre>

<hr>
<h2 id='test_covariates_obj'>Covariates Object</h2><span id='topic+test_covariates_obj'></span>

<h3>Description</h3>

<p>A list containing the frequency and severity relativities for three factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_covariates_obj
</code></pre>


<h3>Format</h3>

<p>A <code>covariates</code> object with 3 components:
</p>

<dl>
<dt>factors</dt><dd><p>list; levels within each factor.</p>
</dd>
<dt>relativity_freq</dt><dd><p>data.frame; first and second order frequency relativities between all the levels of each factor</p>
</dd>
<dt>relativity_sev</dt><dd><p>data.frame; first and second order severity relativities between all the levels of each factor</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>test_covariates_obj$factors
</code></pre>

<hr>
<h2 id='test_transaction_dataset'>Transactions Dataset</h2><span id='topic+test_transaction_dataset'></span>

<h3>Description</h3>

<p>A dataset of 18,983 records of partial payments associated with the 3,624
claims in <code>test_claim_dataset</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_transaction_dataset
</code></pre>


<h3>Format</h3>

<p>A data frame with 18,983 rows and 12 variables:
</p>

<dl>
<dt>claim_no</dt><dd><p>claim number, which uniquely characterises each claim.</p>
</dd>
<dt>pmt_no</dt><dd><p>payment number, identification number of partial payments in respect of a particular <code>claim_no</code>.</p>
</dd>
<dt>occurrence_period</dt><dd><p>integer; period of ocurrence of the claim.</p>
</dd>
<dt>occurrence_time</dt><dd><p>double; time of occurrence of the claim.</p>
</dd>
<dt>claim_size</dt><dd><p>size of the claim (in constant dollar values).</p>
</dd>
<dt>notidel</dt><dd><p>notification delay of the claim, i.e. time from occurrence to notification.</p>
</dd>
<dt>setldel</dt><dd><p>settlement delay of the claim, i.e. time from notification to settlement.</p>
</dd>
<dt>payment_time</dt><dd><p>double; time of payment (on a continuous time scale).</p>
</dd>
<dt>payment_period</dt><dd><p>integer; time of payment (in calendar period).</p>
</dd>
<dt>payment_size</dt><dd><p>size of the payment in constant dollar terms.</p>
</dd>
<dt>payment_inflated</dt><dd><p>actual size of the payment (i.e. with inflation).</p>
</dd>
<dt>payment_delay</dt><dd><p>inter partial delay associated with the payment.</p>
</dd>
</dl>


<hr>
<h2 id='test_transaction_dataset_cov'>Transactions Dataset</h2><span id='topic+test_transaction_dataset_cov'></span>

<h3>Description</h3>

<p>The <code>test_transaction_dataset</code> where the default set of covariates have been applied to adjust claim sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_transaction_dataset_cov
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 18983 rows and 12 columns.
</p>

<hr>
<h2 id='to_SynthETIC'>Conversion to SynthETIC Format</h2><span id='topic+to_SynthETIC'></span>

<h3>Description</h3>

<p>Converts a vector of simulated quantities (e.g. claim occurrence times, claim
sizes) to a list format consistent with what is used for <code>SynthETIC</code>
simulation; to be used when user wishes to replace one or more of the
<code>SynthETIC</code> modules with their own.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_SynthETIC(x, frequency_vector, level = c("clm", "pmt"), no_payments_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_SynthETIC_+3A_x">x</code></td>
<td>
<p>a vector of simulated quantities for all the claims.</p>
</td></tr>
<tr><td><code id="to_SynthETIC_+3A_frequency_vector">frequency_vector</code></td>
<td>
<p>a vector of claim frequencies for all the periods.</p>
</td></tr>
<tr><td><code id="to_SynthETIC_+3A_level">level</code></td>
<td>
<p>level of the data provided; one of <code>"clm"</code> (claim, which is the
default) or <code>"pmt"</code> (payment).</p>
</td></tr>
<tr><td><code id="to_SynthETIC_+3A_no_payments_list">no_payments_list</code></td>
<td>
<p>list of number of partial payments; only required
if <code>level = "pmt"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the simulated quantities in <code>x</code> is provided in
chronological order, e.g. if there are 30 claims in period 1 and <code>x</code> is
on a <code>"clm"</code> level, then the first 30 elements of <code>x</code> should give the
measures for those 30 claims. Likewise, if <code>x</code> is on a <code>"pmt"</code> level, and
the first claim in period 1 has 5 payments, then the first 5 elements of <code>x</code>
should give the measures for those 5 payments.
</p>


<h3>Value</h3>

<p>A list of quantities such that the <code class="reqn">i</code>th component of the
list gives the corresponding measure for all claims that occurred in period
<code class="reqn">i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freq &lt;- claim_frequency()
my_claims &lt;- rweibull(sum(freq), shape = 4, scale = 100000)
claim_sizes &lt;- to_SynthETIC(my_claims, freq)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
