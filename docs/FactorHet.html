<!DOCTYPE html><html lang="en"><head><title>Help for package FactorHet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FactorHet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AME'><p>Calculate marginal effects</p></a></li>
<li><a href='#cjoint_plot'><p>Plot a FactorHet object</p></a></li>
<li><a href='#create_data'><p>Create the (Sparse) Design Matrix for Analysis</p></a></li>
<li><a href='#create_penalty'><p>Create penalty matrix (list of F)</p></a></li>
<li><a href='#diff_AME'><p>Difference between AMEs in each group</p></a></li>
<li><a href='#FactorHet'><p>Estimate heterogeneous effects in factorial and conjoint experiments</p></a></li>
<li><a href='#FactorHet_control'><p>Control for FactorHet estimation</p></a></li>
<li><a href='#FactorHet_init'><p>Arguments for initializing FactorHet</p></a></li>
<li><a href='#FactorHet_mbo_control'><p>Control for model-based optimization</p></a></li>
<li><a href='#FactorHet_refit'><p>Refit model using estimated sparsity patterns</p></a></li>
<li><a href='#FactorHet-class'><p>Generic methods for FactorHet models</p></a></li>
<li><a href='#HTE'><p>Estimate heterogeneous treatment effects by individual or moderator</p></a></li>
<li><a href='#immigration'><p>Small dataset on immigration preferences</p></a></li>
<li><a href='#margeff_moderators'><p>Compute association between moderators and group membership</p></a></li>
<li><a href='#marginal_AME'><p>Deprecated Functions</p></a></li>
<li><a href='#posterior_by_moderators'><p>Visualize the posterior by observed moderators</p></a></li>
<li><a href='#predict.FactorHet'><p>Predict after using FactorHet</p></a></li>
<li><a href='#prepare_regression_data'><p>Prepare Data</p></a></li>
<li><a href='#rank_via_null'><p>Rank of Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Estimate Heterogeneous Effects in Factorial Experiments Using
Grouping and Sparsity</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates heterogeneous effects in factorial (and conjoint)
    models. The methodology employs a Bayesian finite mixture of
    regularized logistic regressions, where moderators can affect each
    observation's probability of group membership and a sparsity-inducing
    prior fuses together levels of each factor while respecting
    ANOVA-style sum-to-zero constraints. Goplerud, Imai, and Pashley
    (2024) &lt;<a href="https://doi.org/10.48550%2FARXIV.2201.01357">doi:10.48550/ARXIV.2201.01357</a>&gt; provide further details.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen (&ge; 0.3.3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), Matrix, ggplot2, ParamHelpers, mlr, mlrMBO,
smoof, lbfgs, methods, utils, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>FNN, RSpectra, mclust, ranger, tgp, testthat, covr, tictoc</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mgoplerud/FactorHet">https://github.com/mgoplerud/FactorHet</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mgoplerud/FactorHet/issues">https://github.com/mgoplerud/FactorHet/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 17:16:01 UTC; mg68977</td>
</tr>
<tr>
<td>Author:</td>
<td>Max Goplerud [aut, cre],
  Nicole E. Pashley [aut],
  Kosuke Imai [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Max Goplerud &lt;mgoplerud@austin.utexas.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-13 18:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='AME'>Calculate marginal effects</h2><span id='topic+AME'></span><span id='topic+manual_AME'></span><span id='topic+ACE'></span><span id='topic+AMIE'></span>

<h3>Description</h3>

<p>Calculate the average marginal (component) effect (AME or AMCE), the average
combination effect (ACE), or the average marginal interaction effect (AMIE)
with a FactorHet model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AME(
  object,
  baseline = NULL,
  vcov = TRUE,
  design = NULL,
  ignore_restrictions = FALSE,
  vcov.type = NULL,
  average_position = TRUE,
  verbose = TRUE,
  plot = TRUE
)

manual_AME(
  object,
  baseline,
  vcov = TRUE,
  design = NULL,
  extra_restriction = NULL,
  ignore_restrictions = FALSE,
  vcov.type = NULL,
  average_position = TRUE,
  verbose = TRUE,
  plot = TRUE
)

ACE(
  object,
  baseline,
  design = NULL,
  average_position = TRUE,
  ignore_restrictions = FALSE,
  extra_restriction = NULL,
  verbose = TRUE,
  plot = TRUE
)

AMIE(
  object,
  design = NULL,
  baseline = NULL,
  average_position = TRUE,
  ignore_restrictions = FALSE,
  verbose = FALSE,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AME_+3A_object">object</code></td>
<td>
<p>An object from <code><a href="#topic+FactorHet">FactorHet</a></code> or <code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>.</p>
</td></tr>
<tr><td><code id="AME_+3A_baseline">baseline</code></td>
<td>
<p>A named list consisting of each factor and a corresponding
baseline level. The default (<code>NULL</code>) computes the effect for all
factors using the first level as the baseline. <code>NA</code> uses no baseline
and approximates the &quot;marginal means&quot; from Leeper et al. (2020).</p>
</td></tr>
<tr><td><code id="AME_+3A_vcov">vcov</code></td>
<td>
<p>A logical value indicating whether the standard errors for the
AME should be computed. The default is <code>TRUE</code>. Standard errors are not
implemented for the AMIE.</p>
</td></tr>
<tr><td><code id="AME_+3A_design">design</code></td>
<td>
<p>A dataset used to estimate the marginal effects. The default,
<code>NULL</code>, uses the estimation data.</p>
</td></tr>
<tr><td><code id="AME_+3A_ignore_restrictions">ignore_restrictions</code></td>
<td>
<p>A logical value about whether to ignore
randomization restrictions when calculating the marginal effects. The
default is <code>FALSE</code>. &quot;Details&quot; provides more information.</p>
</td></tr>
<tr><td><code id="AME_+3A_vcov.type">vcov.type</code></td>
<td>
<p>A string indicating the type of standard errors to be
computed. The default is <code>NULL</code> and uses the default settings in
<code><a href="#topic+vcov.FactorHet">vcov.FactorHet</a></code>; options are specified by that function's
<code>se.method</code> argument.</p>
</td></tr>
<tr><td><code id="AME_+3A_average_position">average_position</code></td>
<td>
<p>A logical value indicating whether, for forced choice
designs, the &quot;left&quot; and &quot;right&quot; profiles should be averaged. The default is
<code>TRUE</code>. Goplerud et al. (2025) provide discussion of this point.</p>
</td></tr>
<tr><td><code id="AME_+3A_verbose">verbose</code></td>
<td>
<p>A logical value as to whether more information should be
provided on the progress of estimating the effects. The default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="AME_+3A_plot">plot</code></td>
<td>
<p>A logical value as to whether the function should print the plot
immediately or quietly provide an object containing the plot and data. The
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="AME_+3A_extra_restriction">extra_restriction</code></td>
<td>
<p>A list of additional restrictions to include when
computing the marginal effects. The default is <code>NULL</code>, i.e. no
additional restrictions. &quot;Details&quot; provides more information about the use
of this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Choice of Baseline</b>: For ACE and AMIE, a choice of baseline is
required. See Egami and Imai (2019) for details. For AME, a choice of
baseline corresponds to a &quot;standard&quot; AME (see Egami and Imai 2019). The
option <code>NULL</code> chooses the first level of each factor. It can be manually
specified using a named list. If a named list is provided, only AMEs for
those named factors are calculated. This can be helpful if there are many
factors. 
</p>
<p>If <code>NA</code> is provided as the baseline level, the AME is calculated without
a baseline; while this does not correspond to a &quot;proper&quot; AME, it is designed
to approximate the &quot;marginal means&quot; discussed in Leeper et al. (2020). Note
that in the presence of randomization restrictions, the quantity estimated
with a <code>NA</code> baseline may not be centered around 0.5. Ignoring the
randomization restrictions may be useful in this scenario. Supporting information
from Goplerud et al. (2025) provides more discussion of this point.
</p>
<p><b>Randomization Restrictions</b>: Randomization restrictions can be set in
one of two ways. By default, FactorHet checks whether for each pairwise
combinations of factors, some combination of levels do not occur at all (e.g.
&quot;doctor&quot; and &quot;high school&quot;) or whether some included interactions are
extremely rare (see <code>rare_threshold</code> in <code><a href="#topic+FactorHet_control">FactorHet_control</a></code>). Those
are assumed to be the randomization restrictions implied by the design.
Setting <code>rare_threshold = 0</code> forces the inclusion of all interaction
terms.
</p>
<p>If this procedure for automatically generating randomization restrictions is
inappropriate for a specific dataset, randomization restrictions can be set
manually as follows using the <code>manual_AME</code> function. First, set
<code>ignore_restrictions = TRUE</code>. This will ignore all &quot;data-driven&quot;
estimates of randomization restrictions. Second, the argument
<code>extra_restriction</code> should be a named list where the name of each
element corresponds to a factor (e.g. &quot;Job&quot;) and each element is a vector of
the levels that <em>cannot</em> be used. When using this approach, <code>AME</code>
should be used only for one factor at a time. An example is shown below.
</p>
<p><b>Plots</b>: Note that for the ggplot2 visualizations of the ACE and AMIE,
gray squares indicate combinations that are excluded due to randomization
restrictions. White indicates baseline levels.
</p>


<h3>Value</h3>

<p>Returns a named list with the underlying data (<code>"data"</code>) and the
plot (<code>"plot"</code>).
</p>


<h3>References</h3>

<p>Egami, Naoki and Kosuke Imai. 2019. &quot;Causal Interaction in
Factorial Experiments: Application to Conjoint Analysis.&quot; <em>Journal of the
American Statistical Association</em>. 114(526):529-540.
</p>
<p>Goplerud, Max, Kosuke Imai, and Nicole E. Pashley. 2025. &quot;Estimating
Heterogeneous Causal Effects of High-Dimensional Treatments: Application to
Conjoint Analysis.&quot; arxiv preprint: <a href="https://arxiv.org/abs/2201.01357">https://arxiv.org/abs/2201.01357</a>
</p>
<p>Leeper, Thomas J., Sara B. Hobolt, and James Tilley. 2020. &quot;Measuring Subgroup
Preferences in Conjoint Experiments.&quot; <em>Political Analysis</em>. 28(2):207-221.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immigration)
# Induce "fake" randomization restriction
immigration$joint_id &lt;- paste(immigration$CaseID, immigration$contest_no)
remove_profiles &lt;- subset(immigration, Plans == 'No plans' &amp; Ed == 'GradDeg')
immigration &lt;- subset(immigration, !(joint_id %in% remove_profiles$joint_id))
# Fit with one group and limited regularization for example only
fit &lt;- FactorHet(Chosen_Immigrant ~ Plans + Ed + Country,
  design = immigration, lambda = 1e-4,
  K = 1, group = ~ CaseID, task = ~ contest_no, choice_order = ~ choice_id)
# Estimate AME of "Ed" with randomization restriction
est_AME &lt;- AME(fit, baseline = list('Ed' = 'GradDeg'))

# Estimate AME ignoring randomization restriction
est_AME_norr &lt;- AME(fit, 
  baseline = list('Ed' = 'GradDeg'), ignore_restrictions = TRUE)
# Estimate AME by manually specifying randomization restrictions
# this uses the 'manual_AME' function
est_AME_rr_manual &lt;- manual_AME(fit,
  baseline = list('Ed' = 'GradDeg'), ignore_restrictions = TRUE,
  extra_restriction = list('Plans' = 'No plans'))
stopifnot(isTRUE(all.equal(est_AME$data, est_AME_rr_manual$data)))
# Estimate without baseline
est_MM &lt;- AME(fit, baseline = list('Ed' = NA))

# Estimate ACE and AMIE

est_ACE &lt;- ACE(fit, baseline = list('Ed' = 'GradDeg', 'Plans' = 'Has contract'))

est_AMIE &lt;- AMIE(fit, baseline = list('Ed' = 'GradDeg', 'Plans' = 'Has contract'))
</code></pre>

<hr>
<h2 id='cjoint_plot'>Plot a FactorHet object</h2><span id='topic+cjoint_plot'></span>

<h3>Description</h3>

<p>Plots the coefficients <code class="reqn">\beta_k</code> from a fitted FactorHet object for the
main effects only. Use <code><a href="#topic+AME">AME</a></code> to calculate average marginal effects. This
provides a fast method to examine the impact of a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjoint_plot(object, baseline = NA, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cjoint_plot_+3A_object">object</code></td>
<td>
<p>An object from <code><a href="#topic+FactorHet">FactorHet</a></code> or <code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>.</p>
</td></tr>
<tr><td><code id="cjoint_plot_+3A_baseline">baseline</code></td>
<td>
<p>A specification of baseline levels of each factor. The
default is <code>NA</code> and shows all coefficients. The documentation for
<code><a href="#topic+AME">AME</a></code> discusses how a named list could be provided to show the
difference between coefficients.</p>
</td></tr>
<tr><td><code id="cjoint_plot_+3A_plot">plot</code></td>
<td>
<p>A logical value as to whether the function should print the plot
immediately or quietly provide an object containing the plot and data. The
default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list with the underlying data (<code>"data"</code>) and the
plot (<code>"plot"</code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+AME">AME</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit with one group and limited regularization for example only
# Ignore conjoint structure for simplicity
fit &lt;- FactorHet(Chosen_Immigrant ~ Plans + Ed + Country,
  design = immigration, lambda = 1e-2,
  K = 1, group = ~ CaseID, task = ~ contest_no, choice_order = ~ choice_id)
# Plot the raw coefficients
cjoint_plot(fit)

</code></pre>

<hr>
<h2 id='create_data'>Create the (Sparse) Design Matrix for Analysis</h2><span id='topic+create_data'></span>

<h3>Description</h3>

<p>Create a sparse design matrix with weighted sum to zero constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_data(
  design,
  penalty_for_regression,
  warn_missing = TRUE,
  verif_row = TRUE,
  remove_cols = Inf
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_data_+3A_design">design</code></td>
<td>
<p>Data frame with levels of each factor assigned to observation i</p>
</td></tr>
<tr><td><code id="create_data_+3A_penalty_for_regression">penalty_for_regression</code></td>
<td>
<p>An object from &quot;create_penalty&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='create_penalty'>Create penalty matrix (list of F)</h2><span id='topic+create_penalty'></span>

<h3>Description</h3>

<p>Create penalty matrix (list of F)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_penalty(
  factor_levels,
  make_interactions,
  weight_dlist,
  ordered_factors,
  treatment_probs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_penalty_+3A_factor_levels">factor_levels</code></td>
<td>
<p>A list with the levels of each factor</p>
</td></tr>
<tr><td><code id="create_penalty_+3A_treatment_probs">treatment_probs</code></td>
<td>
<p>A list with the levels of each factor and the probability of treatment assignment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of penalty matrices (F) used for sparsification
</p>

<hr>
<h2 id='diff_AME'>Difference between AMEs in each group</h2><span id='topic+diff_AME'></span>

<h3>Description</h3>

<p>Computes the differences between AME between two groups with an
accompanying standard error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_AME(object, AME, baseline_group, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_AME_+3A_object">object</code></td>
<td>
<p>An object from <code><a href="#topic+FactorHet">FactorHet</a></code> or
<code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>.</p>
</td></tr>
<tr><td><code id="diff_AME_+3A_ame">AME</code></td>
<td>
<p>An object containing the average marginal effects estimated using
<code><a href="#topic+AME">AME</a></code>.</p>
</td></tr>
<tr><td><code id="diff_AME_+3A_baseline_group">baseline_group</code></td>
<td>
<p>An integer that denotes the baseline group. The
function will show the difference in AMEs from this group, i.e. Group
<code>k</code> - Group <code>baseline_group</code>.</p>
</td></tr>
<tr><td><code id="diff_AME_+3A_plot">plot</code></td>
<td>
<p>A logical value as to whether the function should print the plot
immediately or quietly provide an object containing the plot and data. The
default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list with the underlying data (<code>"data"</code>) and the
plot (<code>"plot"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Fit with two groups and fixed lambda for quick illustration
  
  data(immigration)
  set.seed(15)
  fit &lt;- FactorHet(formula = Chosen_Immigrant ~ Country + Ed,
    design = immigration, group = ~ CaseID, task = ~ contest_no,
    choice_order = ~ choice_id, lambda = 1e-2,
    control = FactorHet_control(init_method = 'random_member'),
    K = 2)
  fit_AME &lt;- AME(fit)
  diff_AME(fit, fit_AME, baseline_group = 2)
  
</code></pre>

<hr>
<h2 id='FactorHet'>Estimate heterogeneous effects in factorial and conjoint experiments</h2><span id='topic+FactorHet'></span><span id='topic+FactorHet_mbo'></span>

<h3>Description</h3>

<p>Fit a model to estimate heterogeneous effects in factorial or conjoint
experiments using a &quot;mixture of experts&quot; (i.e. a finite mixture of
regularized regressions with covariates affecting group assignment). Effects
are regularized using an overlapping group LASSO. <code>FactorHet_mbo</code> finds
an optimal lambda via Bayesian optimization whereas <code>FactorHet</code> requires
a lambda to be provided. <code>FactorHet_mbo</code> typically used in practice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FactorHet(
  formula,
  design,
  K,
  lambda,
  moderator = NULL,
  group = NULL,
  task = NULL,
  choice_order = NULL,
  weights = NULL,
  control = FactorHet_control(),
  initialize = FactorHet_init(),
  verbose = TRUE
)

FactorHet_mbo(
  formula,
  design,
  K,
  moderator = NULL,
  weights = NULL,
  group = NULL,
  task = NULL,
  choice_order = NULL,
  control = FactorHet_control(),
  initialize = FactorHet_init(),
  mbo_control = FactorHet_mbo_control()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FactorHet_+3A_formula">formula</code></td>
<td>
<p>Formula specifying model. The syntax is <code>y ~ X1 + X2</code>
where <code>y</code> is the outcome and <code>X1</code> and <code>X2</code> are factors.
Interactions can be specified using <code>*</code> syntax. All main factors must
be explicitly included.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_design">design</code></td>
<td>
<p>A data.frame containing the data to be analyzed.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_k">K</code></td>
<td>
<p>An integer specifying the number of groups; <code>K=1</code> specifies a
model with a single group.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_lambda">lambda</code></td>
<td>
<p>A positive numeric value denoting regularization strength; this
is scaled internally by the number of observations, see
<code><a href="#topic+FactorHet_control">FactorHet_control</a></code>. <code>FactorHet_mbo</code> calibrates through
model-based optimization. &quot;Details&quot; provides more discussion of this
approach.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_moderator">moderator</code></td>
<td>
<p>A formula of variables (moderators) that affect the prior
probability of group membership. This is ignored when <code>K=1</code> or
<code>moderator=NULL</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_group">group</code></td>
<td>
<p>A formula of a single variable, e.g. <code>~ person_id</code>, that is
used when there are repeated observations per individual.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_task">task</code></td>
<td>
<p>A formula of a single variable that indicates the task number
performed by each individual. This is not used when <code>group</code> is
unspecified.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_choice_order">choice_order</code></td>
<td>
<p>A formula of a single variable that indicates which
profile is on the &quot;left&quot; or &quot;right&quot; in a conjoint experiment.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_weights">weights</code></td>
<td>
<p>A formula of a single variable that indicates the weights for
each observation (e.g., survey weights). If <code>group</code> is specified, the
weights must be constant inside of each value of group.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_control">control</code></td>
<td>
<p>An object from <code><a href="#topic+FactorHet_control">FactorHet_control</a></code> that sets
various model estimation options.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_initialize">initialize</code></td>
<td>
<p>An object from <code><a href="#topic+FactorHet_init">FactorHet_init</a></code> that determines
how the model is initialized.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_verbose">verbose</code></td>
<td>
<p>A logical value that prints intermediate information about
model fitting. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_+3A_mbo_control">mbo_control</code></td>
<td>
<p>A list of control parameters for MBO; see
<code><a href="#topic+FactorHet_mbo_control">FactorHet_mbo_control</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Caution:</b> Many settings in <a href="#topic+FactorHet_control">FactorHet_control</a> can be modified
to allow for slight variations in how the model is estimated. Some of these
are faster but may introduce numerical differences across versions of
<code>R</code> and machines. The default settings aim to mitigate this. One of
the default settings (<code>FactorHet_control(step_SQUAREM=NULL)</code>)
considerably increases the speed of convergence and the quality of the
optimum located at the expense of sometimes introducing numerical
differences across machines. To address this, one could not use SQUAREM
(<code>do_SQUAREM=FALSE</code>) or set it to use some fixed step-size (e.g.,
<code>step_SQUAREM=-10</code>). If SQUAREM produces a large step, a message to
this effect will be issued.
</p>
<p><b>Factorial vs. Conjoint Experiment:</b> A factorial experiment, i.e.
without a forced-choice between profiles, can be modeled by ignoring the
<code>choice_order</code> argument and ensuring that each <code>group</code> and
<code>task</code> combination corresponds to exactly one observation in the
design.
</p>
<p><b>Estimation:</b> All models are estimated using an AECM algorithm
described in Goplerud et al. (2025). Calibration of the amount of
regularization (i.e. choosing <code class="reqn">\lambda</code>), should be done using
<code>FactorHet_mbo</code>. This uses a small number (default 15) of attempts to
calibrate the amount of regularization by minimizing a user-specific
criterion (defaulting to the BIC), and then fits a final model using the
<code class="reqn">\lambda</code> that is predicted to minimize the criterion.
</p>
<p>Options for the model based optimization (<code>mbo</code>) can be set using
<code><a href="#topic+FactorHet_mbo_control">FactorHet_mbo_control</a></code>. Options for model estimation can be
set using <code><a href="#topic+FactorHet_control">FactorHet_control</a></code>.
</p>
<p><b>Ridge Regression:</b> While more experimental, ridge regression can be
estimated by setting <code>lambda = 0</code> (in <code>FactorHet</code>) and then
setting <code>prior_var_beta</code> in <code><a href="#topic+FactorHet_control">FactorHet_control</a></code> or by
using <code>FactorHet_mbo</code> and setting <code>mbo_type = "ridge"</code>.
</p>
<p><b>Moderators:</b> Moderators can be provided via the <code>moderator</code>
argument. These are important when <code>K &gt; 1</code> for ensuring the stability
of the model. Repeated observations per individual can be specified by
<code>group</code> and/or <code>task</code> if relevant for a force-choice conjoint.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>FactorHet</code>. Typical use will involve
examining the patterns of estimated treatment effects.
<code><a href="#topic+cjoint_plot">cjoint_plot</a></code> shows the raw (logistic) coefficients.
</p>
<p>Marginal effects of treatments (e.g. average marginal effects) can be
computed using <code><a href="#topic+AME">AME</a></code>, <code><a href="#topic+ACE">ACE</a></code>, or <code><a href="#topic+AMIE">AMIE</a></code>.
</p>
<p>The impact of moderators on group membership can be examined using
<code><a href="#topic+margeff_moderators">margeff_moderators</a></code> or <code><a href="#topic+posterior_by_moderators">posterior_by_moderators</a></code>.
</p>
<p>The returned object is a list containing the following elements:
</p>

<dl>
<dt>parameters: </dt><dd><p>Estimated model parameters. These are usually obtained
via <code><a href="#topic+coef.FactorHet">coef.FactorHet</a></code>.</p>
</dd>
<dt>K: </dt><dd><p>The number of groups</p>
</dd>
<dt>posterior: </dt><dd><p>Posterior group probability for each observation. This
is list of two data.frames one with posterior probabilities
(<code>"posterior"</code>) and one (<code>"posterior_predictive"</code>) implied solely
by the moderators, i.e. <code class="reqn">\pi_{k}(X_i)</code> from Goplerud et al. (2025).</p>
</dd>
<dt>information_criterion: </dt><dd><p>Information on the BIC, degrees of freedom,
log-likelihood, and number of iterations.</p>
</dd>
<dt>internal_parameters: </dt><dd><p>A list of many internal parameters. This is
used for debugging or by other post-estimation functions.</p>
</dd>
<dt>vcov: </dt><dd><p>Named list containing the estimated variance-covariance
matrix. This is usually extracted with <code>vcov</code>.</p>
</dd>
<dt>lp_shortEM: </dt><dd><p>If <code>"short EM"</code> is applied (only applicable if 
<code>FactorHet</code>, not <code>FactorHet_mbo</code>, is used), it lists the
log-posterior at the end of each short run.</p>
</dd>
<dt>MBO: </dt><dd><p>If <code>FactorHet_mbo</code> is used, information about the
model-based optimization (MBO) is stored here. <code><a href="#topic+visualize_MBO">visualize_MBO</a></code> 
provides a quick graphical summary of the BIC at different <code class="reqn">\lambda</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Use a small subset of the immigration data from Hainmueller and Hopkins
data(immigration)

set.seed(1)
# Fit with two groups and tune regularization via MBO
fit_MBO &lt;- FactorHet_mbo(
  formula = Chosen_Immigrant ~ Country + Ed + Gender + Plans,
  design = immigration, group = ~ CaseID,
  task =  ~ contest_no, choice_order = ~ choice_id,
  # Only do one guess after initialization for speed
  mbo_control = FactorHet_mbo_control(iters = 1),
  K = 2)
# Plot the raw coefficients
cjoint_plot(fit_MBO)
# Check how MBO fared at calibrating regularization
visualize_MBO(fit_MBO)
# Visualize posterior distribution of group membership
posterior_FactorHet(fit_MBO)
# Get AMEs
AME(fit_MBO)

</code></pre>

<hr>
<h2 id='FactorHet_control'>Control for FactorHet estimation</h2><span id='topic+FactorHet_control'></span>

<h3>Description</h3>

<p>Provides a set of control arguments to <code><a href="#topic+FactorHet">FactorHet</a></code>. Arguments
around the initialization of the model (important when <code>K &gt; 1</code>) can be
set via <code><a href="#topic+FactorHet_init">FactorHet_init</a></code> and arguments for the model-based
optimization tuning of regularization strength <code class="reqn">\lambda</code> can be found in
<code><a href="#topic+FactorHet_mbo_control">FactorHet_mbo_control</a></code>. The parameters can be divided into ones
governing the model priors, model estimation, and miscellaneous settings. All
arguments have default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FactorHet_control(
  iterations = 1000,
  maxit_pi = NULL,
  optim_phi_controls = list(method = "lib_lbfgs"),
  prior_var_phi = 4,
  prior_var_beta = Inf,
  gamma = 1,
  repeat_beta = 1,
  adaptive_weight = "B&amp;R",
  init_method = "short_EM",
  return_data = FALSE,
  log_method = "log_ginv",
  tolerance.parameters = 1e-05,
  tolerance.logposterior = 1e-05,
  rare_threshold = 5,
  rare_verbose = 1,
  beta_method = "cpp",
  beta_cg_it = 25,
  lambda_scale = "N",
  weight_dlist = FALSE,
  do_SQUAREM = TRUE,
  step_SQUAREM = NULL,
  backtrack_SQUAREM = 10,
  df_method = "EM",
  forced_randomize = FALSE,
  single_intercept = NULL,
  tau_method = "nullspace",
  tau_stabilization = 5,
  tau_truncate = 1e+06,
  debug = FALSE,
  force_reset = FALSE,
  calc_df = TRUE,
  calc_se = TRUE,
  quiet_tictoc = TRUE,
  override_BR = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FactorHet_control_+3A_iterations">iterations</code></td>
<td>
<p>A numerical value setting the maximum number of iterations used in
the algorithm. The default is 1000.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_maxit_pi">maxit_pi</code></td>
<td>
<p>An argument setting the maximum number of iterations used in
each M-Step that updates the moderators. The default is <code>NULL</code> and
uses default settings in optimizer. For <code>"lib_lbfgs"</code>, this optimizes
until convergence is obtained.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_optim_phi_controls">optim_phi_controls</code></td>
<td>
<p>A list of options for optimizer used in updating
the moderator
parameters. A method must be provided at minimum, e.g., <code>list(method =
"lib_lbfgs")</code>. <code>"lib_lbfgs"</code> uses <code><a href="lbfgs.html#topic+lbfgs">lbfgs</a></code> from the
accompanying package. All other options use the base <code><a href="stats.html#topic+optim">optim</a></code>
function in <code>R</code>. The maximum number of iterations should be specified
via <code>maxit_pi</code>. All other options are specified through this argument.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_prior_var_phi">prior_var_phi</code></td>
<td>
<p>A numerical value that encodes the variance of
multivariate normal prior on moderator coefficients. <b>Note:</b> The
moderators are not standardized internally and thus should be on broadly
comparable scales to avoid differential amounts of regularization on
different moderators. The default value is 4.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_prior_var_beta">prior_var_beta</code></td>
<td>
<p>A numerical value of normal prior on each treatment
effect coefficient. The default is <code>Inf</code> when using sparse estimation.
A different value can be set when using &quot;ridge&quot; regression, i.e.
<code>lambda=0</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_gamma">gamma</code></td>
<td>
<p>A non-negative numerical value that determines whether
sparsity-inducing prior be &quot;spread&quot; across groups in proportion to the
average prior probability of membership. Default of 1; see Städler et al.
(2010) and Goplerud et al. (2025) for more discussion.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_repeat_beta">repeat_beta</code></td>
<td>
<p>An integer setting the number of times to repeat the E-M
cycle for updating <code class="reqn">\beta</code> before moving to update the moderator
parameters <code class="reqn">\phi</code>. The default is 1.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_adaptive_weight">adaptive_weight</code></td>
<td>
<p>An argument that determines the weights given to
different terms in the penalty function. The default (<code>"B&amp;R"</code>) uses
Bondell and Reich (2009), generalized appropriately if needed, see Goplerud
et al. (2025) for discussion. If a matrix is provided (e.g. from a prior
run of <code><a href="#topic+FactorHet">FactorHet</a></code>), this can be used to set up an &quot;adaptive
overlapping group LASSO&quot;. <code>"none"</code> imposes no weights. To use a matrix
and <em>not</em> use Bondell and Reich weights, additional set <code>override_BR =
TRUE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_init_method">init_method</code></td>
<td>
<p>An argument for initializing the algorithm. One set of
options are different character values: <code>"kmeans"</code> (k-means clustering
on the moderators), <code>"mclust"</code> (<code>"mclust"</code> on the moderators),
<code>"random_pi"</code> (random probabilities of group membership for each
person), <code>"random_member"</code> (random hard assignment),
<code>"random_beta"</code> (random coefficients). This can be set with a named
list with group membership probabilities. This should consist of a named
list with a single element <code>"group_E.prob"</code> that is a data.frame which
contains probabilities for each group/unit with the column names
<code>"group"</code> and then <code>"group_[0-9]+"</code> depending on <code>K</code>. In
general, when using <code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>, this argument is not used
and rather set via the relevant options in
<code><a href="#topic+FactorHet_mbo_control">FactorHet_mbo_control</a></code> as this will ensure the same
initialization for all runs of <code>FactorHet_mbo</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_return_data">return_data</code></td>
<td>
<p>A logical value for whether the formatted data should be
returned. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_log_method">log_method</code></td>
<td>
<p>An argument for specifying whether latent overlapping
groups should be used when interactions are included. The default is
<code>"log_ginv"</code>. Options beginning with <code>"log_"</code> employ latent
overlapping groups (see Yan and Bien 2017 and the supporting information of
Goplerud et al. 2025). The projection matrix can be either the generalized
inverse extending Post and Bondell (2013) (<code>"log_ginv"</code>), a random
matrix (<code>"log_random"</code>), or zero (<code>"log_0"</code>). <code>"standard"</code>
does not implement overlapping groups.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_tolerance.parameters">tolerance.parameters</code></td>
<td>
<p>A numerical value setting the one convergence
criterion: When no parameter changes by more than this
amount, terminate the algorithm. Default is 1e-5.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_tolerance.logposterior">tolerance.logposterior</code></td>
<td>
<p>A numerical value setting the one convergence
criterion: When the log-posterior changes by less than this amount,
terminate the algorithm. Default is 1e-5.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_rare_threshold">rare_threshold</code></td>
<td>
<p>A numerical value setting the threshold for which
interactions should be excluded. If an interaction of two factors has fewer
than <code>rare_threshold</code> observations, the corresponding interaction term
will not be included. This is a way to enforce randomization restrictions.
The default is <code>5</code> but setting it to 0 will ensure that all
interactions are included. The documentation of <code><a href="#topic+FactorHet">FactorHet</a></code>
provides more discussion.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_rare_verbose">rare_verbose</code></td>
<td>
<p>A logical value as to whether to print information about
the rare interactions. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_beta_method">beta_method</code></td>
<td>
<p>A character value for the method by which <code class="reqn">\beta</code> is
updated. The default is <code>"cpp"</code>. An alternative that uses conjugate
gradient (<code>"cg"</code>) is faster per-iteration but may introduce numerical
differences across platforms.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_beta_cg_it">beta_cg_it</code></td>
<td>
<p>A numerical value of the number of conjugate gradient steps
to use if <code>beta_method = "cg"</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_lambda_scale">lambda_scale</code></td>
<td>
<p>A function for internally rescaling lambda to be a
function of <code class="reqn">N</code>. Options are <code>"N"</code> (default; <code>lambda * N</code>),
<code>"unity"</code> (i.e. no rescaling), or <code>"root_N"</code> (<code>lambda *
sqrt(N)</code>).</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_weight_dlist">weight_dlist</code></td>
<td>
<p>A logical value for whether to weight additional
penalties following Hastie and Lim (2015). The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_do_squarem">do_SQUAREM</code></td>
<td>
<p>A logical value for whether to perform SQUAREM to
accelerate convergence. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_step_squarem">step_SQUAREM</code></td>
<td>
<p>An argument specifying the step size to use for SQUAREM.
The default is <code>NULL</code> which uses a data-driven step size. This
generally performs well, but may introduce numerical differences across
machines. See the documentation of <code><a href="#topic+FactorHet">FactorHet</a></code> for more
discussion.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_backtrack_squarem">backtrack_SQUAREM</code></td>
<td>
<p>An integer that sets the number of backtracking
steps to perform for SQUAREM. The default is 10.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_df_method">df_method</code></td>
<td>
<p>A character value specifying the method calculating degrees
of freedom. Default of <code>"EM"</code> follows Goplerud et al. (2025) and
calculates the degrees of freedom using the Polya-Gamma weights.
<code>"IRLS"</code> uses <code class="reqn">\zeta_{ik} (1 -
\zeta_{ik})</code> as weights, 
where <code class="reqn">\zeta_{ik} = Pr(y_i = 1 | X_i, z_i = k)</code>.
<code>"free_param"</code> counts the number of parameters after fusion and
accounting for the sum-to-zero constraints. Use <code>"all"</code> to estimate
all methods and compare.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_forced_randomize">forced_randomize</code></td>
<td>
<p>A logical value that indicates, in the forced-choice
setting, whether the &quot;left&quot; and &quot;right&quot; profiles should be randomized for
each task. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_single_intercept">single_intercept</code></td>
<td>
<p>A logical value or <code>NULL</code> that indicates whether
a single intercept should be used across groups. The default is <code>NULL</code>
which uses a single intercept if the study is a forced-choice conjoint
(i.e., <code>choice_order</code> is used) and a varying intercept by group
otherwise.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_tau_method">tau_method</code></td>
<td>
<p>A character value indicating the method for dealing with
binding restrictions, i.e. numerically infinite <code class="reqn">E[1/\tau^2]</code>. The two
options are <code>"nullspace"</code> (i.e. perform inference assuming this
restriction binds) or <code>"clip"</code> (set to a large value
<code>tau_truncate</code>). The default is <code>"nullspace"</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_tau_stabilization">tau_stabilization</code></td>
<td>
<p>An integer value of the number of steps to perform
with <code>tau_method="clip"</code> before using the provided setting. The
default is 5.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_tau_truncate">tau_truncate</code></td>
<td>
<p>A numerical value to either truncate <code class="reqn">E[1/\tau^2]</code>
(i.e. set maximum <code class="reqn">E[1/\tau^2]</code> in the E-Step for updating <code class="reqn">\beta</code>)
if <code>tau_method = "clip"</code> or a threshold by which to declare that two
levels are fused if 
<code>tau_method="nullspace"</code>. The default is 1e6.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_debug">debug</code></td>
<td>
<p>A logical value for whether the algorithm should be debugged.
The default is <code>FALSE</code>. In particular, it will verify that the
log-posterior increases at each (intermediate) step and throw an exception
otherwise.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_force_reset">force_reset</code></td>
<td>
<p>A logical argument about how the nullspace is computed. If
<code>tau_method="nullspace"</code>, it forces nullspace to be estimated directly
from all binding restrictions at each iteration versus the default method
that updates the existing basis when possible. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_calc_df">calc_df</code></td>
<td>
<p>A logical value for whether to calculate degrees of freedom of
final model. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_calc_se">calc_se</code></td>
<td>
<p>A logical value for whether standard errors of final model.
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_quiet_tictoc">quiet_tictoc</code></td>
<td>
<p>A logical value for whether to <em>not</em> print
information about the timing of the model. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_control_+3A_override_br">override_BR</code></td>
<td>
<p>A logical value for whether to ignore Bondell and Reich
style-weights. The default is <code>FALSE</code>. If <code>TRUE</code> is provided,
<code>sqrt(L) * (L + 1)</code> is used, where <code>L</code> is the number of factor
levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>FactorHet_control</code> returns a named list containing the elements
listed in &quot;Arguments&quot;.
</p>


<h3>References</h3>

<p>Bondell, Howard D., and Brian J. Reich. 2009. &quot;Simultaneous Factor Selection
and Collapsing Levels in ANOVA.&quot; Biometrics 65(1): 169-177.
</p>
<p>Goplerud, Max, Kosuke Imai, and Nicole E. Pashley. 2025. &quot;Estimating
Heterogeneous Causal Effects of High-Dimensional Treatments: Application to
Conjoint Analysis.&quot; arxiv preprint: <a href="https://arxiv.org/abs/2201.01357">https://arxiv.org/abs/2201.01357</a>
</p>
<p>Post, Justin B., and Howard D. Bondell. 2013. &quot;Factor Selection and
Structural Identification in the Interaction ANOVA Model.&quot; <em>Biometrics</em>
69(1):70-79.
</p>
<p>Lim, Michael, and Trevor Hastie. 2015. &quot;Learning Interactions via Hierarchical
Group-Lasso Regularization.&quot; <em>Journal of Computational and Graphical
Statistics</em> 24(3):627-654.
</p>
<p>Städler, Nicolas, Peter Bühlmann, and Sara Van De Geer. 2010.
&quot;l1-penalization for Mixture Regression Models.&quot; <em>Test</em> 19(2):209-256.
</p>
<p>Yan, Xiaohan and Jacob Bien. 2017. &quot;Hierarchical Sparse Modeling: A Choice of
Two Group Lasso Formulations.&quot; <em>Statistical Science</em> 32(4):531–560.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(FactorHet_control())

</code></pre>

<hr>
<h2 id='FactorHet_init'>Arguments for initializing FactorHet</h2><span id='topic+FactorHet_init'></span>

<h3>Description</h3>

<p>A set of arguments that govern the initialization of <code><a href="#topic+FactorHet">FactorHet</a></code>.
Use <code><a href="#topic+FactorHet_control">FactorHet_control</a></code> to set arguments around estimation.
<code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code> ignores many of these arguments as it uses a
single fixed initialization set by <code><a href="#topic+FactorHet_mbo_control">FactorHet_mbo_control</a></code>. All
arguments have default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FactorHet_init(
  short_EM = FALSE,
  short_EM_it = 40,
  short_EM_init = "random_member",
  short_EM_pi = NULL,
  force_rep = FALSE,
  verbose = FALSE,
  short_EM_beta_method = "cpp",
  short_EM_cg_it = 10,
  nrep = 5,
  debug_repeat = FALSE,
  plot_repeat = FALSE,
  return_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FactorHet_init_+3A_short_em">short_EM</code></td>
<td>
<p>A logical value indicating whether &quot;short EM&quot; should be used.
The default value is <code>FALSE</code>. <code>TRUE</code> indicates a &quot;short EM&quot;
should be followed. That is, run multiple short runs of EM with random
initializations and then proceed with the best for full initialization.
Biernacki et al. (2003) provides more discussion. If
<code><a href="#topic+FactorHet_control">FactorHet_control</a></code> has <code>init_method = "short_EM"</code>, this
will override this setting.</p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_short_em_it">short_EM_it</code></td>
<td>
<p>A numerical value of the number of iterations to use for
each &quot;short&quot; run of the EM algorithm. The default is 40.</p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_short_em_init">short_EM_init</code></td>
<td>
<p>An argument that sets the initialization procedure for
&quot;short EM&quot;. It must be some non-deterministic procedure that is valid in
<code><a href="#topic+FactorHet_control">FactorHet_control</a></code>. The default is <code>"random_member".</code></p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_short_em_pi">short_EM_pi</code></td>
<td>
<p>An argument for the maximum number of iterations for the
moderator updates to use for each &quot;short&quot; run of the EM algorithm. The
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_force_rep">force_rep</code></td>
<td>
<p>A logical value for whether to repeat the algorithm if
<code>K=1</code>. The default is <code>FALSE</code> and it should be used only for
debugging.</p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_verbose">verbose</code></td>
<td>
<p>A logical value to print more information about the progress
of each iteration. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_short_em_beta_method">short_EM_beta_method</code></td>
<td>
<p>An argument for the update method for <code class="reqn">\beta</code>
to use for each &quot;short&quot; run of the EM algorithm. The default is
<code>"cpp"</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_short_em_cg_it">short_EM_cg_it</code></td>
<td>
<p>An argument for the number of conjugate gradient
iterations to use if <code>short_EM_beta_method = "cg"</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_nrep">nrep</code></td>
<td>
<p>An integer value of the number of random iterations or runs of
&quot;short EM&quot; should be used. The default value is 5.</p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_debug_repeat">debug_repeat</code></td>
<td>
<p>A logical value for whether to debug the repeated runs.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_plot_repeat">plot_repeat</code></td>
<td>
<p>A logical value for whether to plot the trajectory of the
log-posterior for each run. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_init_+3A_return_all">return_all</code></td>
<td>
<p>A logical value for whether to return all repetitions of
the model versus the one with the highest log-posterior. The default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>FactorHet_init</code> returns a named list containing the elements
listed in &quot;Arguments&quot;.
</p>


<h3>References</h3>

<p>Biernacki, Christophe, Gilles Celeux, and Gérard Govaert. &quot;Choosing Starting
Values for the EM algorithm for Getting the Highest Likelihood in
Multivariate Gaussian Mixture Models.&quot; 2003. <em>Computational Statistics &amp;
Data Analysis</em>. 41(3-4):561-575.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(FactorHet_init())

</code></pre>

<hr>
<h2 id='FactorHet_mbo_control'>Control for model-based optimization</h2><span id='topic+FactorHet_mbo_control'></span>

<h3>Description</h3>

<p><code>FactorHet_mbo_control</code> is used to adjust the settings for the MBO
(model-based optimization). All arguments have default values. This relies
heavily on options from the <code><a href="mlrMBO.html#topic+mlrMBO_examples">mlrMBO</a></code>
package so please see this package for more detailed discussion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FactorHet_mbo_control(
  mbo_type = c("sparse", "ridge"),
  mbo_initialize = "mm_mclust_prob",
  mm_init_iterations = NULL,
  mbo_range = c(-5, 0),
  mbo_method = "regr.bgp",
  final_method = "best.predicted",
  iters = 11,
  mbo_noisy = TRUE,
  criterion = c("BIC", "AIC", "GCV", "BIC_group"),
  ic_method = c("EM", "IRLS", "free_param"),
  se_final = TRUE,
  mbo_design = -1.5,
  fast_estimation = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FactorHet_mbo_control_+3A_mbo_type">mbo_type</code></td>
<td>
<p>A character argument indicating the type of model to
estimate. The default is <code>"sparse"</code> which uses the structured sparse
penalty discussed in Goplerud et al. (2025) and discussed in
<code><a href="#topic+FactorHet">FactorHet</a></code>. <code>"ridge"</code> performs a ridge regression.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_mbo_initialize">mbo_initialize</code></td>
<td>
<p>An argument for the initialization method for each MBO
proposal. The default is <code>"mm_mclust_prob"</code>. &quot;Details&quot; provides a more
in-depth discussion.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_mm_init_iterations">mm_init_iterations</code></td>
<td>
<p>An integer value of the number of iterations to use
if Murphy/Murphy initialization is used. The default is <code>NULL</code> which
uses default values of 100 if probabilistic and 50 if deterministic.
&quot;Details&quot; provides a more in-depth discussion.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_mbo_range">mbo_range</code></td>
<td>
<p>A vector of numerical values that set the range of values to
consider on <code>log10(lambda)</code>, before standardization (e.g., scaling by
<code class="reqn">N</code>, see <code><a href="#topic+FactorHet_control">FactorHet_control</a></code>. The default is
<code>c(-5,0)</code>. &quot;Details&quot; provides more information.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_mbo_method">mbo_method</code></td>
<td>
<p>A function used to propose new values of the regularization
parameters. See information from <code><a href="mlr.html#topic+mlr">mlr</a></code> for more details.
The default is <code>"regr.bgp"</code> which requires the <code>tgp</code> package to
be installed.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_final_method">final_method</code></td>
<td>
<p>A character argument that determines how the final
regularization parameter should be selected. The default is
<code>"best_predicted"</code> that uses the regularization parameter that is
predicted to have the best value of the criterion. Other options are
described in detail in <code><a href="mlrMBO.html#topic+makeMBOControl">makeMBOControl</a></code> for
<code>final.method</code>. Alternative options include <code>"last.proposed"</code> and
<code>"best.true.y"</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_iters">iters</code></td>
<td>
<p>A non-negative integer value of the number of proposals to do
after initialization. The default is 11.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_mbo_noisy">mbo_noisy</code></td>
<td>
<p>A logical value for whether to treat the objective function
as &quot;noisy&quot; for purposes of model-based optimization. The default is
<code>TRUE</code>. The <code>"noisy_optimization"</code> vignette from <code>mlrMBO</code>
provides more details. The criterion function is not, in fact, noisy but
this option often performs better for a non-smooth function. It uses
<code>link[mlrMBO]{crit.eqi}</code> instead of <code>link[mlrMBO]{crit.ei}</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_criterion">criterion</code></td>
<td>
<p>A character value of the criterion to minimize. Options are
<code>"BIC"</code> (default), <code>"AIC"</code>, <code>"GCV"</code>, or <code>"BIC_group"</code>.
<code>"BIC_group"</code> counts the number of observations as the number of
individuals (e.g., in the case of repeated observations per person).</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_ic_method">ic_method</code></td>
<td>
<p>A character value for the method for calculating degrees of
freedom: <code>"EM"</code> (default), <code>"IRLS"</code>, and <code>"free_param"</code>. See
<code><a href="#topic+FactorHet_control">FactorHet_control</a></code> for more information.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_se_final">se_final</code></td>
<td>
<p>A logical value for whether standard errors be calculated for
the final model. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_mbo_design">mbo_design</code></td>
<td>
<p>An argument for how to design the initial proposals for
MBO. The default is -1.5; this and other options are described in
&quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_fast_estimation">fast_estimation</code></td>
<td>
<p>An argument as to whether a weaker convergence
criterion should be used for MBO. The default is <code>NULL</code> which uses the
<em>same</em> arguments for all models. &quot;Details&quot; provides more information.</p>
</td></tr>
<tr><td><code id="FactorHet_mbo_control_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument to provide more information on the initial
steps for MBO; the default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Initialization</b>: <code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code> relies on the same
initialization for each attempt. The default procedure
(<code>"mm_mclust_prob"</code>) is discussed in detail in the appendix of Goplerud
et al. (2025) and builds on Murphy and Murphy (2020). In brief, it
deterministically initializes group memberships using only the moderators
(e.g. using <code>"mclust"</code>). Using those memberships, it uses an EM
algorithm (with probabilistic assignment, if <code>"prob"</code> is specified, or
hard assignment otherwise) for a few steps with only the main effects to
update the proposed group memberships. If the warning appears that
&quot;Murphy/Murphy initialization did not fully converge&quot; , this mean that this
initial step did not fully converge. The number of iterations could be
increased using <code>mm_init_iterations</code> if desired, although benefits are
usually modest beyond the default settings. These memberships are then used
to initialize the model at each proposed regularization value.
</p>
<p>The options available are <code>"spectral"</code> and <code>"mclust"</code> that use
<code>"spectral"</code> or <code>"mclust"</code> on the moderators with no Murphy/Murphy
style tuning. Alternatively, <code>"mm_mclust"</code> and <code>"mm_spectral"</code>
combine the Murphy/Murphy tuning upon the corresponding initial deterministic
initialization (e.g. spectral or <code>"mclust"</code>). These use hard assignment
at each step and likely will converge more quickly although a hard initial
assignment may not be desirable. Adding the suffix <code>"_prob"</code> to the
<code>"mm_*"</code> options uses a standard (soft-assignment) EM algorithm during
the Murphy/Murphy tuning.
</p>
<p>If one wishes to use a custom initialization for MBO, then set
<code>mbo_initialize=NULL</code> and provide an initialization via
<code><a href="#topic+FactorHet_control">FactorHet_control</a></code>. It is strongly advised to use a
deterministic initialization if done manually, e.g. by providing a list of
initial assignment probabilities for each group.
</p>
<p><b>Design of MBO Proposals</b>: The MBO procedure works as follows; there are
some initial proposals that are evaluated in terms of the criterion. Given
those initial proposals, there are <code>iters</code> attempts to improve the
criterion through methods described in detail in
<code><a href="mlrMBO.html#topic+mlrMBO_examples">mlrMBO</a></code> (Bischl et al. 2018). A default
of 11 seems to work well, though one can examine <code><a href="#topic+visualize_MBO">visualize_MBO</a></code>
after estimation to see how the criterion varied across the proposals.
</p>
<p>By default, the regularization parameter is assumed to run from -5 to 0 on
the log10 scale, before standardizing by the size of the dataset. We found
this to be reasonable, but it can be adjusted using <code>mbo_range</code>.
</p>
<p>It is possible to calibrate the initial proposals to help the algorithm find
a minimum of the criterion more quickly. This is controlled by
<code>mbo_design</code> which accepts the following options. Note that a manual
grid search can be provided using the <code>data.frame</code> option below.
</p>
 
<dl>
<dt>Scalar: </dt><dd><p>By default, this is initialized with a scalar
(-1.5) that is the log10 of lambda, before standardization as discussed in
<code><a href="#topic+FactorHet_control">FactorHet_control</a></code>. For a scalar value, four proposals are generated
that start with the scalar value and adjust it based on the level of sparsity
of the initial estimated model. This attempts to avoid initializations that
are too dense and thus are very slow to estimate, as well as ones that are
too sparse.</p>
</dd> 
<dt>&quot;random&quot;: </dt><dd><p>If the string &quot;random&quot; is provided, this
follows the default settings in <code>mlrMBO</code> and generates random
proposals.</p>
</dd> 
<dt>data.frame: </dt><dd><p>A custom grid can be provided using a
data.frame that has two columns (<code>"l"</code> and <code>"y"</code>). <code>"l"</code>
provides the proposed values on the log10 lambda scale (before
standardization). If the corresponding BIC value is known, e.g. from a prior
run of the algorithm, the column <code>"y"</code> should contain this value. If it
is unknown, leave the value as <code>NA</code> and the value will be estimated.
Thus, if a manual grid search is desired, this can be done as follows. Create
a data.frame with the grid values <code>"l"</code> and all <code>"y"</code> as NA. Then,
set <code>iters = 0</code> to do no estimation <em>after</em> the grid search. </p>
</dd>
</dl>

<p><b>Estimation</b>: Typically, estimation proceeds using the same settings for
each MBO proposal and the final model estimated given the best regularization
value (see option <code>final_method</code> for details). However, if one wishes to
use a lower convergence criterion for the MBO proposals to speed estimation,
this can be done using the <code>fast_estimation</code> option. This proceeds by
giving a named list with two members <code>"final"</code> and <code>"fast"</code>. Each
of these should be a list with two elements <code>"tolerance.logposterior"</code>
and <code>"tolerance.parameters"</code> with the corresponding convergence
thresholds. <code>"final"</code> is used for the final model and <code>"fast"</code> is
used for evaluating all of the MBO proposals.
</p>


<h3>Value</h3>

<p><code>FactorHet_mbo_control</code> returns a named list containing the
elements listed in &quot;Arguments&quot;.
</p>


<h3>References</h3>

<p>Bischl, Bernd, Jakob Richter, Jakob Bossek, Daniel Horn, Janek Thomas and
Michel Lang. 2018. &quot;mlrMBO: A Modular Framework for Model-Based Optimization
of Expensive Black-Box Functions.&quot; arxiv preprint:
<a href="https://arxiv.org/abs/1703.03373">https://arxiv.org/abs/1703.03373</a>
</p>
<p>Goplerud, Max, Kosuke Imai, and Nicole E. Pashley. 2025. &quot;Estimating
Heterogeneous Causal Effects of High-Dimensional Treatments: Application to
Conjoint Analysis.&quot; arxiv preprint: <a href="https://arxiv.org/abs/2201.01357">https://arxiv.org/abs/2201.01357</a>
</p>
<p>Murphy, Keefe and Thomas Brendan Murphy. 2020. &quot;Gaussian Parsimonious
Clustering Models with Covariates and a Noise Component.&quot; <em>Advances in
Data Analysis and Classification</em> 14:293– 325.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(FactorHet_mbo_control())
</code></pre>

<hr>
<h2 id='FactorHet_refit'>Refit model using estimated sparsity patterns</h2><span id='topic+FactorHet_refit'></span>

<h3>Description</h3>

<p>Using a previously estimated model, this function takes the
estimated sparsity patterns (e.g., which levels are fused together) and the
estimates of the moderator parameters, <code class="reqn">\hat{\phi}</code>, and re-estimates the
regression parameters <code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FactorHet_refit(
  object,
  newdata,
  tolerance = 0.001,
  hard_assign = FALSE,
  iter_refit = 200
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FactorHet_refit_+3A_object">object</code></td>
<td>
<p>An object from <code><a href="#topic+FactorHet">FactorHet</a></code> or
<code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>.</p>
</td></tr>
<tr><td><code id="FactorHet_refit_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame containing the data to be estimated in the refit
model.</p>
</td></tr>
<tr><td><code id="FactorHet_refit_+3A_tolerance">tolerance</code></td>
<td>
<p>A numerical value that sets the threshold at which to
declare two levels as &quot;fused&quot;; the default is 1e-3. Two levels meet this
threshold if the maximum difference between the main effects and any
interactions is <code>tolerance</code>.</p>
</td></tr>
<tr><td><code id="FactorHet_refit_+3A_hard_assign">hard_assign</code></td>
<td>
<p>A logical value that sets whether observations should be
be assigned to the most probable cluster given <code class="reqn">\phi</code> from the original
model or whether they should they be weighted according to their estimated
group membership probabilities, <code class="reqn">\hat{\pi}(X_i)</code>. The default is
<code>FALSE</code> which uses the weighted method.</p>
</td></tr>
<tr><td><code id="FactorHet_refit_+3A_iter_refit">iter_refit</code></td>
<td>
<p>An integer value that sets the number of iterations used in
fitting the refit model. The default is 200. A warning will be produced if
it does not converge in this many iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main use of this function is to enable sample-splitting as
discussed in Goplerud et al. (2025) to improve coverage and remove bias
from the initial estimates. An example is provided below.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+FactorHet">FactorHet</a></code> that contains the output
described the linked documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immigration)
set.seed(1)
# Split the data into two parts for sample-splitting
train_data &lt;- subset(immigration, CaseID &lt; 900)
refit_data &lt;- subset(immigration, CaseID &gt;= 900)
# Fit using fixed lambda for demonstration
# only
fit &lt;- FactorHet(Chosen_Immigrant ~ Plans + Ed + Country,
  design = train_data, lambda = 1e-2,
  moderator = ~ party_ID + census_div,
  control = FactorHet_control(init = 'mclust'),
  K = 2, group = ~ CaseID, task = ~ contest_no, choice_order = ~ choice_id)
# Refit using the other half of data

refit &lt;- FactorHet_refit(fit, newdat = refit_data)
# AME (etc.) for treatment effects can be computed as normal
AME_refit &lt;- AME(refit)
# As can heterogeneous effects, although uncertainty in 
# phi is ignored
HTE_refit &lt;- HTE_by_individual(refit, AME_refit, design = immigration)

</code></pre>

<hr>
<h2 id='FactorHet-class'>Generic methods for FactorHet models</h2><span id='topic+FactorHet-class'></span><span id='topic+plot.FactorHet'></span><span id='topic+formula.FactorHet'></span><span id='topic+print.FactorHet'></span><span id='topic+summary.FactorHet'></span><span id='topic+coef.FactorHet'></span><span id='topic+logLik.FactorHet'></span><span id='topic+BIC.FactorHet'></span><span id='topic+AIC.FactorHet'></span><span id='topic+print.FactorHet_vis'></span><span id='topic+visualize_MBO'></span><span id='topic+posterior_FactorHet'></span><span id='topic+vcov.FactorHet'></span>

<h3>Description</h3>

<p>Brief descriptions of generic methods (e.g. print, summary) for FactorHet as
well as a way to visualize the progress of the model-based optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FactorHet'
plot(x, y = NULL, ...)

## S3 method for class 'FactorHet'
formula(x, ...)

## S3 method for class 'FactorHet'
print(x, fusion.tolerance = 0.001, ...)

## S3 method for class 'FactorHet'
summary(object, show_interactions = FALSE, digits = 3, ...)

## S3 method for class 'FactorHet'
coef(object, coef_type = "beta", ...)

## S3 method for class 'FactorHet'
logLik(object, type = "loglik", ...)

## S3 method for class 'FactorHet'
BIC(object, ...)

## S3 method for class 'FactorHet'
AIC(object, ...)

## S3 method for class 'FactorHet_vis'
print(x, ...)

visualize_MBO(object)

posterior_FactorHet(object)

## S3 method for class 'FactorHet'
vcov(object, phi = TRUE, se.method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FactorHet-class_+3A_x">x</code></td>
<td>
<p>Model from FactorHet</p>
</td></tr>
<tr><td><code id="FactorHet-class_+3A_y">y</code></td>
<td>
<p>Not used; required to maintain compatibility.</p>
</td></tr>
<tr><td><code id="FactorHet-class_+3A_...">...</code></td>
<td>
<p>Optional arguments; only used by <code>plot.FactorHet</code> with
<code><a href="#topic+cjoint_plot">cjoint_plot</a></code>.</p>
</td></tr>
<tr><td><code id="FactorHet-class_+3A_fusion.tolerance">fusion.tolerance</code></td>
<td>
<p>Threshold at which to declare levels fused</p>
</td></tr>
<tr><td><code id="FactorHet-class_+3A_object">object</code></td>
<td>
<p>Object fit using <code><a href="#topic+FactorHet">FactorHet</a></code> or <code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>.</p>
</td></tr>
<tr><td><code id="FactorHet-class_+3A_show_interactions">show_interactions</code></td>
<td>
<p>Used by <code>summary.FactorHet</code>; indicates whether the
interaction terms be shown. Default <code>FALSE</code>. See &quot;Details&quot; for more
discussion.</p>
</td></tr>
<tr><td><code id="FactorHet-class_+3A_digits">digits</code></td>
<td>
<p>Number of digits to include</p>
</td></tr>
<tr><td><code id="FactorHet-class_+3A_coef_type">coef_type</code></td>
<td>
<p>Type of coefficient (beta for treatment effects; phi for moderators)</p>
</td></tr>
<tr><td><code id="FactorHet-class_+3A_type">type</code></td>
<td>
<p>For &quot;logLik&quot;, should the log-likelihood (<code>"loglik"</code>),
log-posterior (<code>"log_posterior"</code>), or sequence of log-posterior values
at each iteration (<code>"log_posterior_seq"</code>) be returned?</p>
</td></tr>
<tr><td><code id="FactorHet-class_+3A_phi">phi</code></td>
<td>
<p>A logical value indicating whether the standard errors from the
moderator parameters, <code class="reqn">\phi</code>, should be returned as well. The default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="FactorHet-class_+3A_se.method">se.method</code></td>
<td>
<p>A string value for the type of standard errors to be
computed. The default, and primary option, is <code>NULL</code> which is
generally equivalent to <code>"louis"</code> (Louis 1982), as discussed in Goplerud et al.
(2025).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following methods with the arguments given above exist. All
methods work on models with using <code><a href="#topic+FactorHet">FactorHet</a></code> and
<code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>. 
</p>

<dl>
<dt>plot: </dt><dd><p>This is a shorthand for <code><a href="#topic+cjoint_plot">cjoint_plot</a></code> on a fitted
object.</p>
</dd>
<dt>formula: </dt><dd><p>This returns the underlying formula for the treatment effects and
moderators as a named list. This also returns the values used for <code>group</code>,
<code>task</code>, and <code>choice_order</code> if provided.</p>
</dd>
<dt>print: </dt><dd><p>This consists of two <code>print</code> methods.
For <code><a href="#topic+FactorHet">FactorHet</a></code>, it summarizes the
model and fusion of the factor levels. <code>fusion.tolerance</code> sets the
threshold at which levels are reported as fused. For outputs of
<code><a href="#topic+AME">AME</a></code> (and similar), this plots the corresponding plot. See
that documentation for more details.</p>
</dd>
<dt>summary: </dt><dd><p>This summarizes the main effects by group with standard
errors. It is typically more common to visualize this with
<code><a href="#topic+cjoint_plot">cjoint_plot</a></code> (and the accompanying data.frame) or <code><a href="#topic+AME">AME</a></code>.
<code>show_interactions = TRUE</code> shows the interactions in addition to the
main effects.</p>
</dd>
<dt>coef: </dt><dd><p>This returns the coefficient matrix on the original scale (i.e.
with the sum-to-zero constraints). <code>code_type = "phi"</code> returns the
moderator coefficients instead of the treatment effect coefficients.</p>
</dd>
<dt>AIC and BIC: </dt><dd><p>This returns the AIC or BIC. If multiple degrees of
freedom options specified, it returns a matrix.</p>
</dd>
<dt>logLik: </dt><dd><p>This returns the log-likelihood, log-posterior or sequence of
log-posterior values at each iteration of the algorithm. The argument
<code>"type"</code> provides more details.</p>
</dd>
<dt>visualize_MBO: </dt><dd><p>For a model fit with <code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>, 
this shows information about the MBO, i.e. proposed values and objectives.</p>
</dd>
<dt>posterior_FactorHet: </dt><dd><p>For a model with <code>K &gt; 1</code>, this visualizes 
the posterior for each observation and the posterior predictive implied by 
the moderators.</p>
</dd>
<dt>vcov.FactorHet</dt><dd><p>This extracts the estimated variance-covariance 
matrix of the parameters.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Returns the corresponding output of the generic method. &quot;Details&quot;
provides details on the output of each function.
</p>


<h3>References</h3>

<p>Louis, Thomas A. 1982. &quot;Finding the Observed Information Matrix when Using
the EM Algorithm.&quot; <em>Journal of the Royal Statistical Society. Series B
(Methodological)</em>. 44(2):226-233.
</p>
<p>Goplerud, Max, Kosuke Imai, and Nicole E. Pashley. 2025. &quot;Estimating
Heterogeneous Causal Effects of High-Dimensional Treatments: Application to
Conjoint Analysis.&quot; arxiv preprint: <a href="https://arxiv.org/abs/2201.01357">https://arxiv.org/abs/2201.01357</a>
</p>

<hr>
<h2 id='HTE'>Estimate heterogeneous treatment effects by individual or moderator</h2><span id='topic+HTE'></span><span id='topic+HTE_by_individual'></span><span id='topic+HTE_by_moderator'></span>

<h3>Description</h3>

<p>These functions estimate heterogeneous effects from
<code><a href="#topic+FactorHet">FactorHet</a></code> at the individual level or by the average value of
a moderator. They can be used to produce individual-level estimates that
can be compared against other methods for estimating heterogeneous effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTE_by_individual(object, AME, design = NULL)

HTE_by_moderator(
  object,
  AME,
  moderators = NULL,
  design = NULL,
  points_continuous = 10,
  overall_AME = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HTE_+3A_object">object</code></td>
<td>
<p>An object from <code><a href="#topic+FactorHet">FactorHet</a></code>,
<code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>.</p>
</td></tr>
<tr><td><code id="HTE_+3A_ame">AME</code></td>
<td>
<p>An estimate of the average marginal effects by group from
<code><a href="#topic+AME">AME</a></code>.</p>
</td></tr>
<tr><td><code id="HTE_+3A_design">design</code></td>
<td>
<p>An optional data.frame of moderator values on which to produce
the individual-level or average conditional average marginal effects.
<b>Note:</b> There should be one row per observation if this function is
used. The default is <code>NULL</code> which uses the estimation data.</p>
</td></tr>
<tr><td><code id="HTE_+3A_moderators">moderators</code></td>
<td>
<p>An argument that contains a list of moderators to evaluate.
The default is <code>NULL</code> and considers all moderators.</p>
</td></tr>
<tr><td><code id="HTE_+3A_points_continuous">points_continuous</code></td>
<td>
<p>A positive integer value that indicates the number
of equally spaced points to evaluate a continuous moderator over.</p>
</td></tr>
<tr><td><code id="HTE_+3A_overall_ame">overall_AME</code></td>
<td>
<p>A logical value that indicates whether to compute the AME
over the entire <code>design</code> without modification. The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="HTE_+3A_verbose">verbose</code></td>
<td>
<p>A logical value that indicates whether progress should be
reported. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions here allow for, first, estimation of conditional
average marginal effects for each individual given their pre-treatment
moderators (<code>HTE_by_individual</code>). This is a weighted average of the
AME for each group by the individual's group membership probabilities, i.e.
<code class="reqn">\hat{\pi}(X_i)</code> (Goplerud et al. 2025). These are also averaged
together to return an estimate to produce a population-level effect.
</p>
<p>Second, one can estimate conditional average marginal effects using
<code>HTE_by_moderator</code>. This takes a moderator such as party
identification and counterfactually sets each observation to some level
(e.g., &quot;Strong Democrat&quot;). It then reports the average of the
individual-level conditional effects across the sample population as the
&quot;conditional&quot; average marginal effect. If <code>overall_AME</code> is true, it
also returns the average of the individual heterogeneous effects given the
observed distribution of pre-treatment moderators. It and the
<code>population</code> element of the list produced by <code>HTE_by_individual</code>
coincide exactly.
</p>
<p>Both functions can be used with split-sample or refit, i.e.
<code><a href="#topic+FactorHet_refit">FactorHet_refit</a></code>, and the computed AME, although this will not
take into account uncertainty in the moderator estimation as they are
assumed fixed when refitting the model.
</p>
<p>To use these functions, first estimate the AMEs by group, i.e., using
<code><a href="#topic+AME">AME</a></code> and then pass this object and the original
<code><a href="#topic+FactorHet">FactorHet</a></code> model to the functions for computing heterogeneous
effects by moderator or individual.
</p>


<h3>Value</h3>

<p><code>HTE_by_individual</code> returns a list with two data.frames. The
first <code>individual</code> contains the estimated individual conditional
average marginal effects. The second <code>population</code> contains the average
of those individual effects. Standard errors (via the column <code>var</code>)
are also included.
</p>
<p><code>HTE_by_population</code> returns a list for each moderator that consists
itself of a list of each value of the moderator used. The value
<code>"out"</code> contains the conditional average marginal effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(immigration)
# Estimate model with arbitrary choice of lambda
fit &lt;- FactorHet(Chosen_Immigrant ~ Plans + Ed + Country,
  design = immigration, lambda = 1e-2,
  moderator = ~ party_ID,
  K = 2, group = ~ CaseID,
  control = FactorHet_control(init = 'mclust'),
  task = ~ contest_no, choice_order = ~ choice_id)
# Estimate AME 
est_AME &lt;- AME(fit)
# Get individual AME; note only seven distinct
# patterns will exist as partyID is the only (discrete)
# moderator
iAME &lt;- HTE_by_individual(
  object = fit,
  AME = est_AME)
# Get conditional AME by level of party ID
cAME_pID &lt;- HTE_by_moderator(
  object = fit,
  AME = est_AME, overall_AME = TRUE)

AME_1 &lt;- cAME_pID$`Overall AME`$out[[1]][,c('factor', 'level', 'est', 'var')]
AME_2 &lt;- iAME$population[,c('factor', 'level', 'est', 'var')]
rownames(AME_1) &lt;- rownames(AME_2) &lt;- NULL
stopifnot(isTRUE(all.equal(AME_1, AME_2)))

</code></pre>

<hr>
<h2 id='immigration'>Small dataset on immigration preferences</h2><span id='topic+immigration'></span>

<h3>Description</h3>

<p>An example dataset of 100 randomly chosen respondents from the replication
data in Hainmueller and Hopkins (2015). Only a small selection of the factors
and moderators in the original experiment are included in this example
dataset. The full data can be downloaded from the replication archive in
&quot;Source&quot; below. The original paper provides more details on all variables.
The replication data for Goplerud et al. (2025) provides code to process and
analyze the original data using <code><a href="#topic+FactorHet">FactorHet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>immigration
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 10 variables:
</p>

<dl>
<dt>CaseID</dt><dd><p>Unique identifier for respondent.</p>
</dd>
<dt>contest_no</dt><dd><p>Task number (1-5) for each respondent.</p>
</dd>
<dt>choice_id</dt><dd><p>Identifier for the profile shown, i.e., was it the &quot;left&quot;
or &quot;right&quot; profile.</p>
</dd>
<dt>Chosen_Immigrant</dt><dd><p>Immigrant profile chosen by respondent.</p>
</dd>
<dt>Country</dt><dd><p>Immigrant's country of origin.</p>
</dd>
<dt>Ed</dt><dd><p>Immigrant's education level.</p>
</dd>
<dt>Plans</dt><dd><p>Immigrant's employment plans after arrival.</p>
</dd>
<dt>Gender</dt><dd><p>Immigrant's gender.</p>
</dd>
<dt>party_ID</dt><dd><p><b>Respondent's</b> party identification.</p>
</dd>
<dt>census_div</dt><dd><p>Level of immigration in <b>respondent's</b> ZIP code.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.7910/DVN/25505">doi:10.7910/DVN/25505</a>
</p>


<h3>References</h3>

<p>Goplerud, Max, Kosuke Imai, and Nicole E. Pashley. 2025. &quot;Estimating
Heterogeneous Causal Effects of High-Dimensional Treatments: Application to
Conjoint Analysis.&quot; arxiv preprint: <a href="https://arxiv.org/abs/2201.01357">https://arxiv.org/abs/2201.01357</a>
</p>
<p>Hainmueller, Jens and Daniel J. Hopkins. 2015. &quot;The Hidden American
Immigration Consensus: A Conjoint Analysis of Attitudes Toward Immigrants.&quot;
<em>American Journal of Political Science</em> 59(3):529-548.
</p>

<hr>
<h2 id='margeff_moderators'>Compute association between moderators and group membership</h2><span id='topic+margeff_moderators'></span>

<h3>Description</h3>

<p>This function computes the impact of changing a
moderator on the group membership probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margeff_moderators(
  object,
  newdata = NULL,
  vcov = TRUE,
  se.method = NULL,
  quant_continuous = c(0.25, 0.75),
  abs_diff = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="margeff_moderators_+3A_object">object</code></td>
<td>
<p>An object from <code><a href="#topic+FactorHet">FactorHet</a></code> or
<code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>.</p>
</td></tr>
<tr><td><code id="margeff_moderators_+3A_newdata">newdata</code></td>
<td>
<p>An optional argument that provides the data over which to
average the distribution of the other moderators. The default is
<code>NULL</code> which uses the estimation data.</p>
</td></tr>
<tr><td><code id="margeff_moderators_+3A_vcov">vcov</code></td>
<td>
<p>A logical value indicating whether the standard errors should be
computed. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="margeff_moderators_+3A_se.method">se.method</code></td>
<td>
<p>An optional argument as to the type of standard errors used.
The default is <code>NULL</code> uses estimated standard errors.
<code><a href="#topic+vcov.FactorHet">vcov.FactorHet</a></code> provides more information.</p>
</td></tr>
<tr><td><code id="margeff_moderators_+3A_quant_continuous">quant_continuous</code></td>
<td>
<p>A numeric vector consisting of two values between 0
and 1. For continuous moderators, it sets two quantiles of the moderator's
distribution to show the difference between. The default <code>c(0.25,
0.75)</code> compares the effect of changing the moderator from its 25th
percentile to its 75th percentile.</p>
</td></tr>
<tr><td><code id="margeff_moderators_+3A_abs_diff">abs_diff</code></td>
<td>
<p>A logical value as to whether the difference or absolute
difference in the change in <code class="reqn">\pi_k(X_i)</code> should be shown. The default
is <code>FALSE</code> which returns the standard &quot;marginal effect&quot; of changing
the moderators with a standard error computed via the delta method. The
value <code>TRUE</code> draws 10,000 samples from the asymptotic distribution of
the moderators and computes the average the <b>absolute values</b> of the
marginal effects for each observation in <code>newdata</code> using those
samples. This is considerably slower than the default setting. The appendix
of Goplerud et al. (2025) illustrates one use of this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the change in <code class="reqn">\pi_k(X_i)</code> for the change
in one of the moderators in <code class="reqn">X_i</code>. The change is averaged across the
distribution of the other moderators found in <code>newdata</code> (or, by
default, the estimation data). It thus can be thought of as the &quot;marginal
effect&quot; of changing one moderator on the probability of group memberships,
holding all other moderators constant. It returns a data.frame of the
estimated effects as well as a plot to visualize the changes in
<code class="reqn">\pi_k(X_i)</code>. Goplerud et al. (2025) provides more discussion of this
method.
</p>


<h3>Value</h3>

<p>Returns a named list with the underlying data (<code>"data"</code>) and the
plot (<code>"plot"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate model with arbitrary choice of lambda
data(immigration)
set.seed(15)
# Estimate model with arbitrary choice of lambda
fit &lt;- FactorHet(Chosen_Immigrant ~ Plans + Ed + Country,
  design = immigration, lambda = 1e-2,
  moderator = ~ party_ID,
  K = 2, group = ~ CaseID,
  control = FactorHet_control(init = 'mclust'),
  task = ~ contest_no, choice_order = ~ choice_id)
margeff_moderators(fit)
</code></pre>

<hr>
<h2 id='marginal_AME'>Deprecated Functions</h2><span id='topic+marginal_AME'></span><span id='topic+marginal_ACE'></span><span id='topic+marginal_AMIE'></span><span id='topic+moderator_AME'></span>

<h3>Description</h3>

<p>The names of these functions have changed, e.g., <code>AME</code> to
<code>AME</code>, for clarity. Please adjust your code to use the current names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_AME(...)

marginal_ACE(...)

marginal_AMIE(...)

moderator_AME(...)
</code></pre>


<h3>Value</h3>

<p>Returns objects corresponding to those described in
<code><a href="#topic+AME">AME</a></code>, <code><a href="#topic+ACE">ACE</a></code>, <code><a href="#topic+AMIE">AMIE</a></code>, and
<code><a href="#topic+margeff_moderators">margeff_moderators</a></code>, respectively.
</p>


<h3>See Also</h3>

<p><a href="#topic+AME">AME</a> <a href="#topic+margeff_moderators">margeff_moderators</a>
</p>

<hr>
<h2 id='posterior_by_moderators'>Visualize the posterior by observed moderators</h2><span id='topic+posterior_by_moderators'></span>

<h3>Description</h3>

<p>Provides univariate summaries of the estimated posterior predictive
probabilities of group membership by the moderators. Can produce analyses
for continuous variables (weighted boxplot) or discrete variables (row/column
tables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_by_moderators(
  object,
  visualize = c("all", "discrete", "continuous"),
  type_discrete = c("bar", "row", "column", "all")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_by_moderators_+3A_object">object</code></td>
<td>
<p>A model fit using <code><a href="#topic+FactorHet">FactorHet</a></code> or <code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>.</p>
</td></tr>
<tr><td><code id="posterior_by_moderators_+3A_visualize">visualize</code></td>
<td>
<p>Specifies which types of moderators to show. Default (<code>"all"</code>)
shows all moderators. Other options include <code>"discrete"</code> and
<code>"continuous"</code>.</p>
</td></tr>
<tr><td><code id="posterior_by_moderators_+3A_type_discrete">type_discrete</code></td>
<td>
<p>Show the results by <code>"row"</code> or <code>"column"</code> or
<code>"all"</code> (i.e. both).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Discrete Moderators</b>: Discrete moderators are shown by either a
<code>"row"</code>, <code>"column"</code>, or <code>"bar"</code> plot. In the <code>"row"</code>
plot, the quantity reported is, for each level of the moderator, what
proportion of people fall into each group. For example, for moderator value
&quot;a&quot;, 25% of people are in group 1 and 75% of people are in group 2.
This is estimated using a weighted average, weighting by the estimated posterior
predictive probabilities of group membership and any survey weights.
</p>
<p>By contrast <code>"column"</code> and <code>"bar"</code> reports the distribution
by group. For example, for Group 1, 30% of people have moderator value &quot;f&quot;,
50% have moderator value &quot;g&quot;, and 20% have moderator value &quot;h&quot;.
<code>"bar"</code> reports this as a bar chart whereas <code>"column"</code> reports as a
tile plot.
</p>
<p>For all three types of plots, the data is provided in the returned output.
</p>
<p><b>Continuous Moderators</b>: Continuous moderators are shown by a
histogram of the value for each group, weighted by each observation's
posterior predictive probability of being in that group.
</p>


<h3>Value</h3>

<p>A list of each of the types of analyses is reported. Each element of
the list contains the ggplot object and the data (&quot;plot&quot; and &quot;data&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immigration)
set.seed(15)
# Estimate model with arbitrary choice of lambda
fit &lt;- FactorHet(Chosen_Immigrant ~ Plans + Ed + Country,
  design = immigration, lambda = 1e-2,
  moderator = ~ party_ID,
  K = 2, group = ~ CaseID,
  control = FactorHet_control(init = 'mclust'),
  task = ~ contest_no, choice_order = ~ choice_id)
posterior_by_moderators(fit)
</code></pre>

<hr>
<h2 id='predict.FactorHet'>Predict after using FactorHet</h2><span id='topic+predict.FactorHet'></span>

<h3>Description</h3>

<p>Predicted values for choosing particular profiles based on
<code><a href="#topic+FactorHet">FactorHet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FactorHet'
predict(
  object,
  newdata = NULL,
  type = "posterior",
  by_group = FALSE,
  return = "prediction",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.FactorHet_+3A_object">object</code></td>
<td>
<p>A model estimated using <code><a href="#topic+FactorHet">FactorHet</a></code> or
<code><a href="#topic+FactorHet_mbo">FactorHet_mbo</a></code>.</p>
</td></tr>
<tr><td><code id="predict.FactorHet_+3A_newdata">newdata</code></td>
<td>
<p>A dataset on which to generate predictions. The default,
<code>NULL</code>, uses the estimation data.</p>
</td></tr>
<tr><td><code id="predict.FactorHet_+3A_type">type</code></td>
<td>
<p>An argument that specifies how to deal with group-membership
probabilities when making predictions. The default is <code>"posterior"</code>
which use the posterior probabilities for each observation in the training
data for weighting the groups. If <code>"posterior_predictive"</code> is used,
the group membership probabilities implied by the moderators, i.e.
<code class="reqn">\hat{\pi}_k(X_i)</code>, will be used. If an observation in <code>newdata</code>
is not in the estimation data (i.e., its value of <code>group</code>) is not
found, then <code>"posterior_predictive"</code>, i.e. <code class="reqn">\hat{\pi}_k(X_i)</code>, is
used.</p>
</td></tr>
<tr><td><code id="predict.FactorHet_+3A_by_group">by_group</code></td>
<td>
<p>A logical value as to whether the predictions should be
returned for each group or whether a weighted averaged based on the group
membership probabilities (specified by <code>type</code>) should be reported. The
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.FactorHet_+3A_return">return</code></td>
<td>
<p>A character value that determines the type of prediction
return. The default is <code>"prediction"</code> that returns the predicted
probability. The option <code>"detailed"</code> returns a variety of additional
information. This is mostly called internally for other functions such as
<code><a href="#topic+AME">AME</a></code> or <code><a href="#topic+margeff_moderators">margeff_moderators</a></code>.</p>
</td></tr>
<tr><td><code id="predict.FactorHet_+3A_...">...</code></td>
<td>
<p>Miscellaneous options used internally and not documented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an estimate of the predicted probability of choosing a
profile for each observation. &quot;Arguments&quot; outlines different behavior if
certain options are chosen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immigration)
set.seed(1)
# Fit a model once for simplicity
fit &lt;- FactorHet(Chosen_Immigrant ~ Plans + Ed + Country,
 design = immigration, lambda = 1e-4,
 # Randomly initialize, do only one iteration for speed
 init = FactorHet_init(nrep = 1),
 control = FactorHet_control(init = 'random_member'),
 K = 2, group = ~ CaseID, task = ~ contest_no, 
 choice_order = ~ choice_id)
immigration$pred_FH &lt;- predict(fit)  
</code></pre>

<hr>
<h2 id='prepare_regression_data'>Prepare Data</h2><span id='topic+prepare_regression_data'></span>

<h3>Description</h3>

<p>Package data to use in FactorHet. Called internally by 'FactorHet_mbo';
rarely called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_regression_data(
  formula,
  design,
  moderator = NULL,
  group = NULL,
  task = NULL,
  choice_order = NULL,
  weights = NULL,
  single_intercept = NULL,
  forced_randomize = NULL,
  rare_threshold = NULL,
  weight_dlist = FALSE,
  rare_verbose = NULL
)
</code></pre>

<hr>
<h2 id='rank_via_null'>Rank of Matrix</h2><span id='topic+rank_via_null'></span>

<h3>Description</h3>

<p>Calculate rank of (sparse) matrix by a QR decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_via_null(X, outer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank_via_null_+3A_x">X</code></td>
<td>
<p>Sparse Matrix with size N by p.</p>
</td></tr>
<tr><td><code id="rank_via_null_+3A_outer">outer</code></td>
<td>
<p>Calculate rank of X^T X. Often much faster if N &gt;&gt; p.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
