<!DOCTYPE html><html lang="en"><head><title>Help for package geocausal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geocausal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#airstrikes'><p>airstrikes</p></a></li>
<li><a href='#airstrikes_base'><p>airstrikes_base</p></a></li>
<li><a href='#conv_owin_into_sf'><p>Convert windows into sf objects</p></a></li>
<li><a href='#get_base_dens'><p>Get the baseline density</p></a></li>
<li><a href='#get_cate'><p>Generate a Hajek estimator for heterogeneity analysis</p></a></li>
<li><a href='#get_cf_dens'><p>Get counterfactual densities</p></a></li>
<li><a href='#get_cf_sum_log_intens'><p>Calculate the log counterfactual densities</p></a></li>
<li><a href='#get_dist_focus'><p>Get distance maps</p></a></li>
<li><a href='#get_dist_line'><p>Get distance maps from lines and polygons</p></a></li>
<li><a href='#get_distexp'><p>Get the expectation of treatment events with arbitrary distances</p></a></li>
<li><a href='#get_elev'><p>Get elevation data</p></a></li>
<li><a href='#get_em_vec'><p>convert a list of im objects to a vector</p></a></li>
<li><a href='#get_est'><p>Get causal estimates comparing two scenarios</p></a></li>
<li><a href='#get_estimates'><p>Generate a Hajek estimator</p></a></li>
<li><a href='#get_hfr'><p>Create a hyperframe</p></a></li>
<li><a href='#get_hist'><p>Obtain histories of treatment or outcome events</p></a></li>
<li><a href='#get_obs_dens'><p>Generate observed densities</p></a></li>
<li><a href='#get_power_dens'><p>Get power densities</p></a></li>
<li><a href='#get_var_bound'><p>Calculate variance upper bounds</p></a></li>
<li><a href='#get_weighted_surf'><p>Generate average weighted surfaces</p></a></li>
<li><a href='#get_window'><p>Generate a window</p></a></li>
<li><a href='#imls_to_arr'><p>convert a list of im objects to a three-dimensional array</p></a></li>
<li><a href='#insurgencies'><p>insurgencies</p></a></li>
<li><a href='#iraq_window'><p>iraq_window</p></a></li>
<li><a href='#pixel_count_ppp'><p>Get number of events in a pixel</p></a></li>
<li><a href='#plot.cate'><p>Plot estimated CATE</p></a></li>
<li><a href='#plot.cflist'><p>Plot simulated counterfactual densities</p></a></li>
<li><a href='#plot.distlist'><p>Plot distance-based expectations</p></a></li>
<li><a href='#plot.est'><p>Plot estimates</p></a></li>
<li><a href='#plot.hyperframe'><p>Plot estimates</p></a></li>
<li><a href='#plot.im'><p>Plot im</p></a></li>
<li><a href='#plot.imlist'><p>Plot im objects (list)</p></a></li>
<li><a href='#plot.list'><p>Plot lists</p></a></li>
<li><a href='#plot.obs'><p>Plot observed densities</p></a></li>
<li><a href='#plot.powerlist'><p>Plot simulated power densities</p></a></li>
<li><a href='#plot.ppplist'><p>Plot point pattern (list)</p></a></li>
<li><a href='#plot.weights'><p>Plot weights</p></a></li>
<li><a href='#predict_obs_dens'><p>Perform out-of-sample prediction</p></a></li>
<li><a href='#print.cate'><p>Print results</p></a></li>
<li><a href='#print.est'><p>Print results</p></a></li>
<li><a href='#sim_cf_dens'><p>Simulate counterfactual densities</p></a></li>
<li><a href='#sim_power_dens'><p>Simulate power densities</p></a></li>
<li><a href='#smooth_ppp'><p>Smooth outcome events</p></a></li>
<li><a href='#summary.cate'><p>Summarize results</p></a></li>
<li><a href='#summary.est'><p>Summarize results</p></a></li>
<li><a href='#summary.obs'><p>Summarize results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Causal Inference with Spatio-Temporal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mitsuru Mukaigawara &lt;mitsuru_mukaigawara@g.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatio-temporal causal inference based on point process data. 
    You provide the raw data of locations and timings of treatment and 
    outcome events, specify counterfactual scenarios, and the package 
    estimates causal effects over specified spatial and temporal windows.
    See Papadogeorgou, et  al. (2022) &lt;<a href="https://doi.org/10.1111%2Frssb.12548">doi:10.1111/rssb.12548</a>&gt; and
    Mukaigawara, et al. (2024) &lt;<a href="https://doi.org/10.31219%2Fosf.io%2F5kc6f">doi:10.31219/osf.io/5kc6f</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mmukaigawara/geocausal">https://github.com/mmukaigawara/geocausal</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>elevatr, geosphere, gridExtra, ggthemes, knitr, readr,
gridGraphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, dplyr, furrr, ggplot2, ggpubr, latex2exp, mclust,
progressr, purrr, sf, spatstat.explore, spatstat.geom,
spatstat.model, spatstat.univar, terra, tidyr, tidyselect,
tidyterra</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-06 06:38:53 UTC; mitsurumukaigawara</td>
</tr>
<tr>
<td>Author:</td>
<td>Mitsuru Mukaigawara
    <a href="https://orcid.org/0000-0001-6530-2083"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Lingxiao Zhou [aut],
  Georgia Papadogeorgou
    <a href="https://orcid.org/0000-0002-1982-2245"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jason Lyall <a href="https://orcid.org/0000-0001-9117-7503"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Kosuke Imai <a href="https://orcid.org/0000-0002-2748-1022"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-07 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='airstrikes'>airstrikes</h2><span id='topic+airstrikes'></span>

<h3>Description</h3>

<p>A subset of airstrikes data in Iraq (March to June 2007)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airstrikes
</code></pre>


<h3>Format</h3>

<p>A tibble with 3938 rows and 4 variables:
</p>

<dl>
<dt>date</dt><dd><p>Date (YYYY-MM-DD)</p>
</dd>
<dt>longitude</dt><dd><p>Longitudes (decimal)</p>
</dd>
<dt>latitude</dt><dd><p>Latitudees (decimal)</p>
</dd>
<dt>type</dt><dd><p>Types of airstrikes (airstrikes or shows of force (SOF))</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>airstrikes
</code></pre>

<hr>
<h2 id='airstrikes_base'>airstrikes_base</h2><span id='topic+airstrikes_base'></span>

<h3>Description</h3>

<p>A subset of airstrikes data in Iraq (a subset of airstrikes in 2006) that can be used to construct baseline densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airstrikes_base
</code></pre>


<h3>Format</h3>

<p>A tibble with 808 rows and 3 variables:
</p>

<dl>
<dt>date</dt><dd><p>Date</p>
</dd>
<dt>longitude</dt><dd><p>Longitudes (decimal)</p>
</dd>
<dt>latitude</dt><dd><p>Latitudees (decimal)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>airstrikes_base
</code></pre>

<hr>
<h2 id='conv_owin_into_sf'>Convert windows into sf objects</h2><span id='topic+conv_owin_into_sf'></span>

<h3>Description</h3>

<p>'conv_owin_into_sf' takes an owin object and converts it to sf-related objects. 
This function is mostly an internal function of other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv_owin_into_sf(window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conv_owin_into_sf_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of polygon, dataframe, sfc_POLYGON, sf, and SpatialPolygonsDataFrame objects
</p>

<hr>
<h2 id='get_base_dens'>Get the baseline density</h2><span id='topic+get_base_dens'></span>

<h3>Description</h3>

<p>'get_base_dens()' takes a dataframe and
returns the baseline densities using Scott's rule of thumb (out-of-sample data)
or fitting an inhomogeneous Poisson model (in-sample data) by regressing
the in-sample data on time-invariant covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_base_dens(
  window,
  option,
  ndim = 256,
  out_data,
  out_coordinates = c("longitude", "latitude"),
  hfr,
  dep_var,
  indep_var,
  ratio
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_base_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_option">option</code></td>
<td>
<p>&quot;in&quot; (using in-sample data) or &quot;out&quot; (using out-of-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_ndim">ndim</code></td>
<td>
<p>the number of dimensions of grid cells (ndim^2). By default, ndim = 256.</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_out_data">out_data</code></td>
<td>
<p>dataframe (if using out-of-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_out_coordinates">out_coordinates</code></td>
<td>
<p>vector of column names of longitudes and latitudes (in this order) (if using in-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_hfr">hfr</code></td>
<td>
<p>hyperframe (if using in-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_dep_var">dep_var</code></td>
<td>
<p>the name of the dependent variable (if using in-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_indep_var">indep_var</code></td>
<td>
<p>the names of time-invariant independent varaibles (if using in-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_ratio">ratio</code></td>
<td>
<p>for random sampling of data (if using in-sample data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an im object of baseline density
</p>

<hr>
<h2 id='get_cate'>Generate a Hajek estimator for heterogeneity analysis</h2><span id='topic+get_cate'></span>

<h3>Description</h3>

<p>A function that returns a Hajek estimator of CATE for a spatial or spatio-temporal effect modifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cate(
  obs,
  cf1,
  cf2,
  treat,
  pixel_count_out,
  lag,
  trunc_level = 0.95,
  time_after = TRUE,
  entire_window = NULL,
  em = NULL,
  E_mat = NULL,
  nbase = 6,
  spline_type = "ns",
  intercept = TRUE,
  eval_values = NULL,
  eval_mat = NULL,
  test_beta = NULL,
  save_weights = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cate_+3A_obs">obs</code></td>
<td>
<p>observed density</p>
</td></tr>
<tr><td><code id="get_cate_+3A_cf1">cf1</code></td>
<td>
<p>counterfactual density 1</p>
</td></tr>
<tr><td><code id="get_cate_+3A_cf2">cf2</code></td>
<td>
<p>counterfactual density 2</p>
</td></tr>
<tr><td><code id="get_cate_+3A_treat">treat</code></td>
<td>
<p>column of a hyperframe that summarizes treatment data. In the form of 'hyperframe$column'.</p>
</td></tr>
<tr><td><code id="get_cate_+3A_pixel_count_out">pixel_count_out</code></td>
<td>
<p>column of a hyperframe that summarizes the number of outcome events in each pixel</p>
</td></tr>
<tr><td><code id="get_cate_+3A_lag">lag</code></td>
<td>
<p>integer that specifies lags to calculate causal estimates.</p>
</td></tr>
<tr><td><code id="get_cate_+3A_trunc_level">trunc_level</code></td>
<td>
<p>the level of truncation for the weights (0-1).</p>
</td></tr>
<tr><td><code id="get_cate_+3A_time_after">time_after</code></td>
<td>
<p>whether to include one unit time difference between treatment and outcome. By default = TRUE</p>
</td></tr>
<tr><td><code id="get_cate_+3A_entire_window">entire_window</code></td>
<td>
<p>owin object (the entire region of interest)</p>
</td></tr>
<tr><td><code id="get_cate_+3A_em">em</code></td>
<td>
<p>treat column of a hyperframe that summarizes the effect modifier data. In the form of 'hyperframe$column'. It can be NULL if E_mat is provided.</p>
</td></tr>
<tr><td><code id="get_cate_+3A_e_mat">E_mat</code></td>
<td>
<p>optional covariance matrix (excluding the intercept) for the effect modifier. If provided, then the regression model will be based on this matrix. If 'intercept = TRUE', then a column of 1 will be add to 'E_mat'.</p>
</td></tr>
<tr><td><code id="get_cate_+3A_nbase">nbase</code></td>
<td>
<p>number of bases for splines</p>
</td></tr>
<tr><td><code id="get_cate_+3A_spline_type">spline_type</code></td>
<td>
<p>type of splines. Either '&quot;ns&quot;' or '&quot;bs&quot;'.</p>
</td></tr>
<tr><td><code id="get_cate_+3A_intercept">intercept</code></td>
<td>
<p>whether to include intercept in the regression model. Default is TRUE.</p>
</td></tr>
<tr><td><code id="get_cate_+3A_eval_values">eval_values</code></td>
<td>
<p>a vector of values of the effect modifier for which CATE will be evaluated. Default is a 'seq(a,b,length.out=20)' where 'a' and 'b' are minimum and maximum values of the effect modifier.</p>
</td></tr>
<tr><td><code id="get_cate_+3A_eval_mat">eval_mat</code></td>
<td>
<p>evaluated spline basis (excluding the intercept) matrix at 'eval_values'.  If 'intercept = TRUE', then a column of 1 will be add to 'eval_mat'.</p>
</td></tr>
<tr><td><code id="get_cate_+3A_test_beta">test_beta</code></td>
<td>
<p>a vector of integers contain the indices of the coefficients that are included in the hypothesis test. By default, the null hypothesis is that all coefficient  (except the intercept is 0). See details below</p>
</td></tr>
<tr><td><code id="get_cate_+3A_save_weights">save_weights</code></td>
<td>
<p>whether to save weights. Default is 'TRUE'</p>
</td></tr>
<tr><td><code id="get_cate_+3A_...">...</code></td>
<td>
<p>arguments passed onto the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'E_mat' should be a matrix or array of dimensions <code class="reqn">n</code> by <code class="reqn">m</code> where <code class="reqn">n</code> is the product of image dimensions and number of time period,
and <code class="reqn">m</code> is 'nbase'-'intercept'. If you want to construct your own covariate matrix 'E_mat', you should use 'get_em_vec()' to convert
the effect modifer(usually a column of a hyperframe) to a vector, and then construct the splines basis based on the vector. The covariate matrix'E_mat' should not 
the column for intercept. The function 'get_cate()' will conduct a hypothesis testing on whether all the selected coefficients are 0. 'test_beta' is a vector of positive integers specifying the indices
of the chosen beta. The coefficients (except the intercept) are indexed by '1,2,...,nbase-intercept'. By default, it test whether all the coefficients(except the intercept) are 0, and this is testing the
the heterogeneity effect of the effect modifier.
</p>


<h3>Value</h3>

<p>list of the following:
'est_beta': estimated regression coefficient
'V_beta': estimated asymptotic covariance matrix of regression coefficient (normalized by total time periods)   
'chisq_stat': observed chi-square statistics for the hypothesis test
'p.value': observed chi-square statistics for the hypothesis test
'specification': information about the specification of the spline basis and the values on which the CATE is estimated
'est_eval': estimated CATE evaluted at chosen values
'V_eval': estimated asymptotic covariance matrix of the estimated CATE values (normalized by total time periods)
'mean_effect': Mean of the pseudo pixel effect
'total_effect': Mean of the pseudo effect for the window 'entire_window'. It is equal to mean effect times the total number of pixels inside the chosen window
</p>

<hr>
<h2 id='get_cf_dens'>Get counterfactual densities</h2><span id='topic+get_cf_dens'></span>

<h3>Description</h3>

<p>'get_cf_dens' takes the target (expected) number, baseline density,
and power density, and generates a hyperframe with counterfactual densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cf_dens(expected_number, base_dens, power_dens = NA, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cf_dens_+3A_expected_number">expected_number</code></td>
<td>
<p>the expected number of observations.</p>
</td></tr>
<tr><td><code id="get_cf_dens_+3A_base_dens">base_dens</code></td>
<td>
<p>baseline density (im object)</p>
</td></tr>
<tr><td><code id="get_cf_dens_+3A_power_dens">power_dens</code></td>
<td>
<p>power density (im object)</p>
</td></tr>
<tr><td><code id="get_cf_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways of generating counterfactual densities.
First, users can keep the locations of observations as they are and change the expected number of observations.
In this case, users do not have to set 'power_dens' and simply modify 'expected_number'.
Alternatively, users can shift the locations as well. In this case, 'power_dens' must be specified.
To obtain power densities, refer to [get_power_dens()].
</p>


<h3>Value</h3>

<p>an im object of a counterfactual density
</p>

<hr>
<h2 id='get_cf_sum_log_intens'>Calculate the log counterfactual densities</h2><span id='topic+get_cf_sum_log_intens'></span>

<h3>Description</h3>

<p>A function that takes a hyperframe and returns the log counterfactual densities
ie, the numerator of the equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cf_sum_log_intens(cf_dens, treatment_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cf_sum_log_intens_+3A_cf_dens">cf_dens</code></td>
<td>
<p>A counterfactual density (an im object)</p>
</td></tr>
<tr><td><code id="get_cf_sum_log_intens_+3A_treatment_data">treatment_data</code></td>
<td>
<p>In the form of hyperframe$column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of sums of log densities for each time period
</p>

<hr>
<h2 id='get_dist_focus'>Get distance maps</h2><span id='topic+get_dist_focus'></span>

<h3>Description</h3>

<p>'get_dist_focus()' generates a distance map from focus locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist_focus(window, lon, lat, resolution, mile = FALSE, preprocess = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dist_focus_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
<tr><td><code id="get_dist_focus_+3A_lon">lon</code></td>
<td>
<p>vector of longitudes</p>
</td></tr>
<tr><td><code id="get_dist_focus_+3A_lat">lat</code></td>
<td>
<p>vector of latitudes</p>
</td></tr>
<tr><td><code id="get_dist_focus_+3A_resolution">resolution</code></td>
<td>
<p>resolution of raster objects</p>
</td></tr>
<tr><td><code id="get_dist_focus_+3A_mile">mile</code></td>
<td>
<p>logical. 'mile' specifies whether to return the output in miles instead of kilometers (by default, FALSE).</p>
</td></tr>
<tr><td><code id="get_dist_focus_+3A_preprocess">preprocess</code></td>
<td>
<p>logical. 'preprocess' specifies whether to first pick the potentially closest point.
It is recommended to set 'preprocess = TRUE' if users need to obtain distances from many points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_dist_focus()' depends on 'geosphere::distVincentyEllipsoid()'.
Since it calculates accurate distances considering the ellipsoid, the process sometimes
becomes computationally demanding, namely when we need to obtain distances from many points.
In that case, users can set 'preprocess = TRUE'. With this option, 'get_dist_focus()' calculates
distances from points by first identifying the closest point using 'sf::st_nearest_feature()' with approximations.
This process is more efficient than computing distances from all the points
with 'geosphere::distVincentyEllipsoid()' and then obtaining the minimum of all the distances.
By default, 'get_dist_focus()' returns distances in kilometers unless users set 'mile =  TRUE'.
</p>


<h3>Value</h3>

<p>an im object
</p>

<hr>
<h2 id='get_dist_line'>Get distance maps from lines and polygons</h2><span id='topic+get_dist_line'></span>

<h3>Description</h3>

<p>'get_dist_line()' generates a distance map from lines and polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist_line(
  window,
  path_to_shapefile,
  line_data = NULL,
  mile = FALSE,
  resolution,
  preprocess = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dist_line_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
<tr><td><code id="get_dist_line_+3A_path_to_shapefile">path_to_shapefile</code></td>
<td>
<p>path to shapefile</p>
</td></tr>
<tr><td><code id="get_dist_line_+3A_line_data">line_data</code></td>
<td>
<p>sfc_MULTILINESTRING file (If available. If not, 'get_dist_line()' creates it from a shapefile.)</p>
</td></tr>
<tr><td><code id="get_dist_line_+3A_mile">mile</code></td>
<td>
<p>logical. 'mile' specifies whether to return the output in miles instead of kilometers (by default,  FALSE).</p>
</td></tr>
<tr><td><code id="get_dist_line_+3A_resolution">resolution</code></td>
<td>
<p>resolution of raster objects</p>
</td></tr>
<tr><td><code id="get_dist_line_+3A_preprocess">preprocess</code></td>
<td>
<p>logical. 'preprocess' specifies whether to first pick the potentially closest point.
It is recommended to set 'preprocess = TRUE' if users need to obtain distances from many points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an im object
</p>

<hr>
<h2 id='get_distexp'>Get the expectation of treatment events with arbitrary distances</h2><span id='topic+get_distexp'></span>

<h3>Description</h3>

<p>'get_distexp()' takes counterfactual densities and
and returns the expected number of treatment events based on distances
from a user-specified focus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distexp(
  cf_sim_results,
  entire_window,
  dist_map,
  dist_map_unit = "km",
  use_raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_distexp_+3A_cf_sim_results">cf_sim_results</code></td>
<td>
<p>output of 'sim_cf_dens()'</p>
</td></tr>
<tr><td><code id="get_distexp_+3A_entire_window">entire_window</code></td>
<td>
<p>owin object of the entire region</p>
</td></tr>
<tr><td><code id="get_distexp_+3A_dist_map">dist_map</code></td>
<td>
<p>im object whose cell values are the distance from a focus (e.g., city)</p>
</td></tr>
<tr><td><code id="get_distexp_+3A_dist_map_unit">dist_map_unit</code></td>
<td>
<p>either '&quot;km&quot;' or '&quot;mile&quot;'</p>
</td></tr>
<tr><td><code id="get_distexp_+3A_use_raw">use_raw</code></td>
<td>
<p>logical. 'use_raw' specifies whether to use the raw value of expectations or percentiles.
By default, 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of resulting dataframe ('result_data'), windows ('window_list'), data for distance quantiles,
and a window object for the entire window
</p>

<hr>
<h2 id='get_elev'>Get elevation data</h2><span id='topic+get_elev'></span>

<h3>Description</h3>

<p>'get_elevation()' takes a directory that hosts shapefile and returns an owin object of altitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elev(load_path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_elev_+3A_load_path">load_path</code></td>
<td>
<p>path to the shp file (note: a folder)</p>
</td></tr>
<tr><td><code id="get_elev_+3A_...">...</code></td>
<td>
<p>other parameters passed to 'elevatr::get_elev_raster()'. The resolution argument z must be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an im object (unit: meters)
</p>

<hr>
<h2 id='get_em_vec'>convert a list of im objects to a vector</h2><span id='topic+get_em_vec'></span>

<h3>Description</h3>

<p>'get_em_vec()' get the vector form of a column of a hyperframe that summarizes the effect modifier data in heterogeneity analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_em_vec(em, time_after = TRUE, lag, entire_window = NULL, ngrid = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_em_vec_+3A_em">em</code></td>
<td>
<p>column of a hyperframe that summarizes effect modifier data. In the form of 'hyperframe$column'.</p>
</td></tr>
<tr><td><code id="get_em_vec_+3A_time_after">time_after</code></td>
<td>
<p>whether to include one unit time difference between treatment and outcome. By default = TRUE</p>
</td></tr>
<tr><td><code id="get_em_vec_+3A_lag">lag</code></td>
<td>
<p>integer that specifies lags to calculate causal estimates</p>
</td></tr>
<tr><td><code id="get_em_vec_+3A_entire_window">entire_window</code></td>
<td>
<p>owin object (the entire region of interest). If given, then the values outside the region will be set to 'NA'.</p>
</td></tr>
<tr><td><code id="get_em_vec_+3A_ngrid">ngrid</code></td>
<td>
<p>a number or a vector of two numbers that specify the dimension of pixels. If NULL, the pixel dimension of the original
images will not be changed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function 'get_em_vec()' get the vector form of the effect modifier in the heterogeneity analysis. It is useful
if you want to construct the variance matrix 'E_mat' that is passed to the function 'get_cate()'
</p>

<hr>
<h2 id='get_est'>Get causal estimates comparing two scenarios</h2><span id='topic+get_est'></span>

<h3>Description</h3>

<p>'get_est()' generates causal estimates comparing two counterfactual scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_est(
  obs,
  cf1,
  cf2,
  treat,
  sm_out,
  mediation = FALSE,
  obs_med_log_sum_dens = NA,
  cf1_med_log_sum_dens = NA,
  cf2_med_log_sum_dens = NA,
  lag,
  time_after = TRUE,
  entire_window,
  use_dist,
  windows,
  dist_map,
  dist,
  trunc_level = NA,
  save_weights = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_est_+3A_obs">obs</code></td>
<td>
<p>observed density</p>
</td></tr>
<tr><td><code id="get_est_+3A_cf1">cf1</code></td>
<td>
<p>counterfactual density 1</p>
</td></tr>
<tr><td><code id="get_est_+3A_cf2">cf2</code></td>
<td>
<p>counterfactual density 2</p>
</td></tr>
<tr><td><code id="get_est_+3A_treat">treat</code></td>
<td>
<p>column of a hyperframe that summarizes treatment data. In the form of 'hyperframe$column'.</p>
</td></tr>
<tr><td><code id="get_est_+3A_sm_out">sm_out</code></td>
<td>
<p>column of a hyperframe that summarizes the smoothed outcome data</p>
</td></tr>
<tr><td><code id="get_est_+3A_mediation">mediation</code></td>
<td>
<p>whether to perform causal mediation analysis (don't use; still in development). By default, FALSE.</p>
</td></tr>
<tr><td><code id="get_est_+3A_obs_med_log_sum_dens">obs_med_log_sum_dens</code></td>
<td>
<p>sum of log densities of mediators for the observed (don't use; still in development)</p>
</td></tr>
<tr><td><code id="get_est_+3A_cf1_med_log_sum_dens">cf1_med_log_sum_dens</code></td>
<td>
<p>sum of log densities of mediators for counterfactual 1 (don't use; still in development)</p>
</td></tr>
<tr><td><code id="get_est_+3A_cf2_med_log_sum_dens">cf2_med_log_sum_dens</code></td>
<td>
<p>sum of log densities of mediators for counterfactual 2 (don't use; still in development)</p>
</td></tr>
<tr><td><code id="get_est_+3A_lag">lag</code></td>
<td>
<p>integer that specifies lags to calculate causal estimates</p>
</td></tr>
<tr><td><code id="get_est_+3A_time_after">time_after</code></td>
<td>
<p>whether to include one unit time difference between treatment and outcome. By default = TRUE</p>
</td></tr>
<tr><td><code id="get_est_+3A_entire_window">entire_window</code></td>
<td>
<p>owin object (the entire region of interest)</p>
</td></tr>
<tr><td><code id="get_est_+3A_use_dist">use_dist</code></td>
<td>
<p>whether to use distance-based maps. By default, TRUE</p>
</td></tr>
<tr><td><code id="get_est_+3A_windows">windows</code></td>
<td>
<p>a list of owin objects (if 'use_dist = FALSE')</p>
</td></tr>
<tr><td><code id="get_est_+3A_dist_map">dist_map</code></td>
<td>
<p>distance map (an im object, if 'use_dist = TRUE')</p>
</td></tr>
<tr><td><code id="get_est_+3A_dist">dist</code></td>
<td>
<p>distances (a numeric vector within the max distance of 'dist_map')</p>
</td></tr>
<tr><td><code id="get_est_+3A_trunc_level">trunc_level</code></td>
<td>
<p>the level of truncation for the weights (0-1)</p>
</td></tr>
<tr><td><code id="get_est_+3A_save_weights">save_weights</code></td>
<td>
<p>whether to save weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The level of truncation indicates the quantile of weights at which weights are truncated.
That is, if 'trunc_level = 0.95', then all weights are truncated at the 95 percentile of the weights.
</p>


<h3>Value</h3>

<p>list of the following:
'cf1_ave_surf': average weighted surface for scenario 1
'cf2_ave_surf': average weighted surface for scenario 2
'est_cf': estimated effects of each scenario
'est_causal': estimated causal contrasts
'var_cf': variance upper bounds for each scenario
'var_causal': variance upper bounds for causal contrasts
'windows': list of owin objects
</p>

<hr>
<h2 id='get_estimates'>Generate a Hajek estimator</h2><span id='topic+get_estimates'></span>

<h3>Description</h3>

<p>A function that returns a Hajek estimator of causal contrasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_estimates(
  weighted_surf_1,
  weighted_surf_2,
  use_dist = TRUE,
  windows,
  dist_map,
  dist,
  entire_window
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_estimates_+3A_weighted_surf_1">weighted_surf_1</code></td>
<td>
<p>a weighted surface for scenario 1</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_weighted_surf_2">weighted_surf_2</code></td>
<td>
<p>another weighted surface for scenario 2</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_use_dist">use_dist</code></td>
<td>
<p>whether to use distance-based maps. By default, TRUE</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_windows">windows</code></td>
<td>
<p>a list of owin objects (if 'use_dist = FALSE')</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_dist_map">dist_map</code></td>
<td>
<p>distance map (an im object, if 'use_dist = TRUE')</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_dist">dist</code></td>
<td>
<p>distances (a numeric vector within the max distance of 'dist_map')</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_entire_window">entire_window</code></td>
<td>
<p>an owin object of the entire map</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_estimates()' is an internal function to 'get_est()' function, 
performing the estimation analysis after 'get_weighted_surf()' function
</p>


<h3>Value</h3>

<p>list of Hajek estimators for each scenario ('est_haj'), 
causal contrasts (Hajek estimator) as a matrix ('est_tau_haj_matrix'), and 
causal contrast (scenario 2 - scenario 1) as a numeric vector ('est_tau_haj_cf2_vs_cf1'), 
along with weights, windows, and smoothed outcomes
</p>

<hr>
<h2 id='get_hfr'>Create a hyperframe</h2><span id='topic+get_hfr'></span>

<h3>Description</h3>

<p>'get_hfr()' takes a dataframe with time and location variables
and generates a hyperframe with point patterns.
'get_hfr()' is usually the first function that users employ in order to
perform spatiotemporal causal inference analytic methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hfr(
  data,
  col,
  window,
  time_col,
  time_range,
  coordinates = c("longitude", "latitude"),
  combine = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hfr_+3A_data">data</code></td>
<td>
<p>dataframe. The dataframe must have time and location variables.
Location variables should be standard coordinates (i.e., longitudes and latitudes).</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_col">col</code></td>
<td>
<p>the name of the column for subtypes of events of interest</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_window">window</code></td>
<td>
<p>owin object (for more information, refer to 'spatstat.geom::owin()').
Basically, an owin object specifies the geographical boundaries of areas of interest.</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_time_col">time_col</code></td>
<td>
<p>the name of the column for time variable. Note that the time variable must be integers.</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_time_range">time_range</code></td>
<td>
<p>numeric vector. 'time_range' specifies the range of the time variable
(i.e., min and max of the time variable).
The current version assumes that the unit of this time variable is dates.</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_coordinates">coordinates</code></td>
<td>
<p>character vector. 'coordinates' specifies the names of columns for locations.
By default, 'c(&quot;longitude&quot;, &quot;latitude&quot;)' in this order. Note that the coordinates must be in decimal degree formats.</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_combine">combine</code></td>
<td>
<p>logical. 'combine' tells whether to generate output for all subtypes of events combined.
By default, 'TRUE', which means that a column of ppp objects with all subtypes combined is generated in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A hyperframe is generated with rows representing time and columns representing the following:
* The first column: time variable
* The middle columns: ppp objects (see 'spatstat.geom::ppp()') generated for each subtype of events of interest
* The last column (if 'combine = TRUE'): ppp objects with all subtypes combined. This column is named as 'all_combined'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data
dat &lt;- data.frame(time = c(1, 1, 2, 2),
                  longitude = c(43.9, 44.5, 44.1, 44.0),
                  latitude = c(33.6, 32.7, 33.6, 33.5),
                  type = rep(c("treat", "out"), 2))

# Hyperframe
get_hfr(data = dat,
        col = "type",
        window = iraq_window,
        time_col = "time",
        time_range = c(1, 2),
        coordinates = c("longitude", "latitude"),
        combine = FALSE)
</code></pre>

<hr>
<h2 id='get_hist'>Obtain histories of treatment or outcome events</h2><span id='topic+get_hist'></span>

<h3>Description</h3>

<p>'get_hist()' takes a hyperframe and time and columns of interest, and generates histories of events of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hist(tt, Xt, Yt = NA, lag, window, x_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hist_+3A_tt">tt</code></td>
<td>
<p>values of the time variable of interest for which 'get_hist()' generates histories</p>
</td></tr>
<tr><td><code id="get_hist_+3A_xt">Xt</code></td>
<td>
<p>the name of a treatment column</p>
</td></tr>
<tr><td><code id="get_hist_+3A_yt">Yt</code></td>
<td>
<p>the name of an outcome column</p>
</td></tr>
<tr><td><code id="get_hist_+3A_lag">lag</code></td>
<td>
<p>numeric. 'lag' specifies the number of time periods over which
'get_hist()' aggregates treatment and outcome columns.</p>
</td></tr>
<tr><td><code id="get_hist_+3A_window">window</code></td>
<td>
<p>owin object.</p>
</td></tr>
<tr><td><code id="get_hist_+3A_x_only">x_only</code></td>
<td>
<p>logical. 'x_only' specifies whether to generate only treatment history (no outcome history). By default, 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of treatment and outcome histories
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat_out &lt;- insurgencies[1:100, ]
dat_out$time &lt;- as.numeric(dat_out$date - min(dat_out$date) + 1)

# Hyperframe
dat_hfr &lt;- get_hfr(data = dat_out,
                   col = "type",
                   window = iraq_window,
                   time_col = "time",
                   time_range = c(1, max(dat_out$time)),
                   coordinates = c("longitude", "latitude"),
                   combine = TRUE)

# Histories
lapply(1:nrow(dat_hfr), get_hist,
       Xt = dat_hfr$all_outcome,
       lag = 1, window = iraq_window)
</code></pre>

<hr>
<h2 id='get_obs_dens'>Generate observed densities</h2><span id='topic+get_obs_dens'></span>

<h3>Description</h3>

<p>'get_obs_dens()' takes a hyperframe and returns observed densities.
The output is used as propensity scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_obs_dens(hfr, dep_var, indep_var, ngrid = 100, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_obs_dens_+3A_hfr">hfr</code></td>
<td>
<p>hyperframe</p>
</td></tr>
<tr><td><code id="get_obs_dens_+3A_dep_var">dep_var</code></td>
<td>
<p>The name of the dependent variable.
Since we need to obtain the observed density of treatment events,
'dep_var' should be the name of the treatment variable.</p>
</td></tr>
<tr><td><code id="get_obs_dens_+3A_indep_var">indep_var</code></td>
<td>
<p>vector of names of independent variables (covariates)</p>
</td></tr>
<tr><td><code id="get_obs_dens_+3A_ngrid">ngrid</code></td>
<td>
<p>the number of grid cells that is used to generate observed densities.
By default = 100. Notice that as you increase 'ngrid', the process gets computationally demanding.</p>
</td></tr>
<tr><td><code id="get_obs_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_obs_dens()' assumes the poisson point process model and
calculates observed densities for each time period. It depends on 'spatstat.model::mppm()'.
Users should note that the coefficients in the output are not directly interpretable,
since they are the coefficients inside the exponential of the poisson model.
</p>


<h3>Value</h3>

<p>list of the following:
* 'indep_var': independent variables
* 'coef': coefficients
* 'intens_grid_cells': im object of observed densities for each time period
* 'estimated_counts': the number of events that is estimated by the poisson point process model for each time period
* 'sum_log_intens': the sum of log intensities for each time period
* 'actual_counts': the number of events (actual counts)
</p>

<hr>
<h2 id='get_power_dens'>Get power densities</h2><span id='topic+get_power_dens'></span>

<h3>Description</h3>

<p>'get_power_dens()' takes the target densities and their priorities
and returns a power density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_power_dens(target_dens, priorities, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_power_dens_+3A_target_dens">target_dens</code></td>
<td>
<p>list of target densities</p>
</td></tr>
<tr><td><code id="get_power_dens_+3A_priorities">priorities</code></td>
<td>
<p>vector of priorities for each of target densities</p>
</td></tr>
<tr><td><code id="get_power_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of an im object and a ggplot object of power densities
</p>

<hr>
<h2 id='get_var_bound'>Calculate variance upper bounds</h2><span id='topic+get_var_bound'></span>

<h3>Description</h3>

<p>A function that calculates variance upper bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_var_bound(estimates)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_var_bound_+3A_estimates">estimates</code></td>
<td>
<p>an object returned from 'get_est()' function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_var_bound()' is an internal function to 'get_estimates()' function, 
performing the estimation analysis after 'get_est()' function.
</p>


<h3>Value</h3>

<p>list of variance upper bounds for each scenario ('bound_haj') and causal contrasts ('bound_tau_haj'). 
Note that this function returns variance upper bounds for Hajek estimators
</p>

<hr>
<h2 id='get_weighted_surf'>Generate average weighted surfaces</h2><span id='topic+get_weighted_surf'></span>

<h3>Description</h3>

<p>A function that returns averaged weighted surfaces (both IPW and Hajek) along with weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_weighted_surf(
  obs_dens,
  cf_dens,
  mediation = FALSE,
  cate = FALSE,
  obs_med_log_sum_dens,
  cf_med_log_sum_dens,
  treatment_data,
  smoothed_outcome,
  lag,
  entire_window,
  time_after,
  truncation_level = truncation_level
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_weighted_surf_+3A_obs_dens">obs_dens</code></td>
<td>
<p>observed density</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_cf_dens">cf_dens</code></td>
<td>
<p>counterfactual density</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_mediation">mediation</code></td>
<td>
<p>whether to perform causal mediation analysis. By default, FALSE.</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_cate">cate</code></td>
<td>
<p>whether to perform the heterogeneity analysis. By default, FALSE.</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_obs_med_log_sum_dens">obs_med_log_sum_dens</code></td>
<td>
<p>sum of log densities of mediators for the observed (if 'mediation = TRUE')</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_cf_med_log_sum_dens">cf_med_log_sum_dens</code></td>
<td>
<p>sum of log densities of mediators for counterfactual (if 'mediation = TRUE')</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_treatment_data">treatment_data</code></td>
<td>
<p>column of a hyperframe that summarizes treatment data. In the form of 'hyperframe$column'.</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_smoothed_outcome">smoothed_outcome</code></td>
<td>
<p>column of a hyperframe that summarizes the smoothed outcome data</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_lag">lag</code></td>
<td>
<p>integer that specifies lags to calculate causal estimates</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_entire_window">entire_window</code></td>
<td>
<p>owin object (the entire region of interest)</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_time_after">time_after</code></td>
<td>
<p>whether to include one unit time difference between treatment and outcome</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_truncation_level">truncation_level</code></td>
<td>
<p>the level at which the weights are truncated (see 'get_estimates()')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_weighted_surf()' is an internal function to 'get_estimates()' function.
If 'time_after' is TRUE, then this function uses treatment data and weights from lag to nrow(data)-1, and
outcome data from lag+1 to nrow(data).
</p>


<h3>Value</h3>

<p>list of an average weighted surface ('avarage_surf', an 'im' object),
a Hajek average weighted surface ('average_weighted_surf_haj', an 'im' object),
weights, and smoothed outcomes
</p>

<hr>
<h2 id='get_window'>Generate a window</h2><span id='topic+get_window'></span>

<h3>Description</h3>

<p>'get_window()' takes a directory that hosts a shapefile
and returns an owin object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_window(load_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_window_+3A_load_path">load_path</code></td>
<td>
<p>path to the shp file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>owin object
</p>

<hr>
<h2 id='imls_to_arr'>convert a list of im objects to a three-dimensional array</h2><span id='topic+imls_to_arr'></span>

<h3>Description</h3>

<p>'imls_to_arr()' convert a list of im object to a 3D array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imls_to_arr(imls, start = 1, end = NULL, entire_window = NULL, ngrid = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imls_to_arr_+3A_imls">imls</code></td>
<td>
<p>a list of im objects (imlist)</p>
</td></tr>
<tr><td><code id="imls_to_arr_+3A_start">start</code></td>
<td>
<p>the index of the first im to be converted. Default is 1.</p>
</td></tr>
<tr><td><code id="imls_to_arr_+3A_end">end</code></td>
<td>
<p>the index of the last im to be converted. If not provided, then it will be set to the length of the list.</p>
</td></tr>
<tr><td><code id="imls_to_arr_+3A_entire_window">entire_window</code></td>
<td>
<p>a owin object. If given, then the values outside the region will be set to 'NA'</p>
</td></tr>
<tr><td><code id="imls_to_arr_+3A_ngrid">ngrid</code></td>
<td>
<p>an optional arugument that takes one integer or  vector of two integers specifying the dimensions of the 'im' objects. If provided, the dimensions of the objects will be adjusted to 'ngrid' before the conversion to the array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'imls_to_arr()' is a internal function for 'imls_to_vec()'. By default, it returns a three-dimensional array of dimension <code class="reqn">n</code> by <code class="reqn">m</code> by<code class="reqn">l</code> where <code class="reqn">n</code> and <code class="reqn">m</code>
are the dimensions of the im objects, and <code class="reqn">l</code> is the length of the list. All the im objects in the list need to have the same dimensions.
</p>

<hr>
<h2 id='insurgencies'>insurgencies</h2><span id='topic+insurgencies'></span>

<h3>Description</h3>

<p>A subset of insurgencies data in Iraq (March to June 2007)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insurgencies
</code></pre>


<h3>Format</h3>

<p>A tibble with 68573 rows and 4 variables:
</p>

<dl>
<dt>date</dt><dd><p>Date (YYYY-MM-DD)</p>
</dd>
<dt>longitude</dt><dd><p>Longitudes (decimal)</p>
</dd>
<dt>latitude</dt><dd><p>Latitudees (decimal)</p>
</dd>
<dt>type</dt><dd><p>Types of insurgencies (improvised explosive devices (IED), small arms fire (SAF), or other)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>insurgencies
</code></pre>

<hr>
<h2 id='iraq_window'>iraq_window</h2><span id='topic+iraq_window'></span>

<h3>Description</h3>

<p>An owin object of Iraq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iraq_window
</code></pre>


<h3>Format</h3>

<p>A polygonal object:
</p>

<dl>
<dt>type</dt><dd><p>Polygonal</p>
</dd>
<dt>xrange</dt><dd><p>Range (longitude)</p>
</dd>
<dt>yrange</dt><dd><p>Range (latitude)</p>
</dd>
<dt>bdry</dt><dd><p>Boundaries</p>
</dd>
<dt>units</dt><dd><p>Units</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>iraq_window
</code></pre>

<hr>
<h2 id='pixel_count_ppp'>Get number of events in a pixel</h2><span id='topic+pixel_count_ppp'></span>

<h3>Description</h3>

<p>'pixel_count_ppp()' takes a column of hyperframes (ppp objects) and gets the number of events in each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixel_count_ppp(
  data,
  ngrid = c(128, 128),
  W = NULL,
  weights = NULL,
  DivideByPixelArea = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pixel_count_ppp_+3A_data">data</code></td>
<td>
<p>the name of a hyperframe and column of interest.</p>
</td></tr>
<tr><td><code id="pixel_count_ppp_+3A_ngrid">ngrid</code></td>
<td>
<p>a number or a vector of two numbers specifying the pixel array dimensions. A single integer, or an integer vector of length 2 giving dimensions in the y and x directions.Default is 'c(128,128)'.</p>
</td></tr>
<tr><td><code id="pixel_count_ppp_+3A_w">W</code></td>
<td>
<p>Optional window mask (object of class '&quot;owin&quot;') determining the pixel raster.
'data' should be in the form of '&quot;hyperframe$column&quot;'.</p>
</td></tr>
<tr><td><code id="pixel_count_ppp_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights associated with the points.</p>
</td></tr>
<tr><td><code id="pixel_count_ppp_+3A_dividebypixelarea">DivideByPixelArea</code></td>
<td>
<p>Logical value determining whether the resulting pixel values should be devided by the pixel area. Default value is 'False'.</p>
</td></tr>
<tr><td><code id="pixel_count_ppp_+3A_...">...</code></td>
<td>
<p>parameters passed on to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>im objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Time variable
dat_out &lt;- insurgencies[1:100, ]
dat_out$time &lt;- as.numeric(dat_out$date - min(dat_out$date) + 1)

# Hyperframe
dat_hfr &lt;- get_hfr(data = dat_out,
                   col = "type",
                   window = iraq_window,
                   time_col = "time",
                   time_range = c(1, max(dat_out$time)),
                   coordinates = c("longitude", "latitude"),
                   combine = TRUE)

# Get the number of events for each pixel
pixel_count_ppp(data = dat_hfr$all_combined)
</code></pre>

<hr>
<h2 id='plot.cate'>Plot estimated CATE</h2><span id='topic+plot.cate'></span>

<h3>Description</h3>

<p>Plot estimated CATE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cate'
plot(
  x,
  ...,
  result = "cate",
  type = "l",
  scale = 1,
  xrange = NULL,
  main = "",
  xlab = "",
  ylim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cate_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.cate_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.cate_+3A_result">result</code></td>
<td>
<p>specify which values will be used for plot. Default is &quot;cate&quot;
- If 'result' is &quot;cate&quot;, then estimated cate values will be used
- If 'result' is &quot;beta&quot;, then the estimated regression coefficients will be used</p>
</td></tr>
<tr><td><code id="plot.cate_+3A_type">type</code></td>
<td>
<p>The type of plot to draw. This argument will be ignored if 'result' = &quot;beta&quot;. Default is &quot;l&quot;.
- If 'type' is &quot;p&quot;, points with error bars will be drawn.
- If 'type' is &quot;l&quot;, lines with shaded region will be drawn.
- If 'type' is a vector of strings, each element specifies the type for the corresponding 'eval_values' value.</p>
</td></tr>
<tr><td><code id="plot.cate_+3A_scale">scale</code></td>
<td>
<p>a positive number specifying the scale by which the estimates will be scaled. If provided, the estimates will be scaled by this value. Default is NULL, which means no scaling is applied.</p>
</td></tr>
<tr><td><code id="plot.cate_+3A_xrange">xrange</code></td>
<td>
<p>an optional vector of two values the range of x shown.</p>
</td></tr>
<tr><td><code id="plot.cate_+3A_main">main</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id="plot.cate_+3A_xlab">xlab</code></td>
<td>
<p>label of x-axis</p>
</td></tr>
<tr><td><code id="plot.cate_+3A_ylim">ylim</code></td>
<td>
<p>an optional vector of two values specifying the limits of y</p>
</td></tr>
</table>

<hr>
<h2 id='plot.cflist'>Plot simulated counterfactual densities</h2><span id='topic+plot.cflist'></span>

<h3>Description</h3>

<p>A function that takes the simulated counterfactual densities and their priorities
and returns a counterfactual density image over a range of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cflist'
plot(
  x,
  ...,
  color = c("white", "#F8DAC5FF", "#F4825AFF", "#D2204CFF", "#771F59FF"),
  grayscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cflist_+3A_x">x</code></td>
<td>
<p>input (should be the output of the 'sim_power_dens()' function)</p>
</td></tr>
<tr><td><code id="plot.cflist_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.cflist_+3A_color">color</code></td>
<td>
<p>the color scale. By default, &quot;white&quot;, &quot;#F8DAC5FF&quot;, &quot;#F4825AFF&quot;, &quot;#D2204CFF&quot;, and &quot;#771F59FF&quot;.</p>
</td></tr>
<tr><td><code id="plot.cflist_+3A_grayscale">grayscale</code></td>
<td>
<p>logical. 'grayscale' specifies whether to convert plot to grayscale (by default, FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='plot.distlist'>Plot distance-based expectations</h2><span id='topic+plot.distlist'></span>

<h3>Description</h3>

<p>Plot distance-based expectations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'distlist'
plot(
  x,
  ...,
  dist_map_unit = "km",
  grayscale = FALSE,
  win_plot = FALSE,
  use_raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.distlist_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.distlist_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.distlist_+3A_dist_map_unit">dist_map_unit</code></td>
<td>
<p>either '&quot;km&quot;' or '&quot;mile&quot;'</p>
</td></tr>
<tr><td><code id="plot.distlist_+3A_grayscale">grayscale</code></td>
<td>
<p>grayscale or not. By default, FALSE.</p>
</td></tr>
<tr><td><code id="plot.distlist_+3A_win_plot">win_plot</code></td>
<td>
<p>whether to plot windows as well. By default, FALSE</p>
</td></tr>
<tr><td><code id="plot.distlist_+3A_use_raw">use_raw</code></td>
<td>
<p>logical. 'use_raw' specifies whether to use the raw value of expectations or percentiles.
By default, 'FALSE'.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.est'>Plot estimates</h2><span id='topic+plot.est'></span>

<h3>Description</h3>

<p>Plot estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'est'
plot(x, ..., surface = FALSE, lim = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.est_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.est_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.est_+3A_surface">surface</code></td>
<td>
<p>whether to produce the surface plot. By default, FALSE</p>
</td></tr>
<tr><td><code id="plot.est_+3A_lim">lim</code></td>
<td>
<p>limits of the scale. By default, NA. To set limits manually, provide a vector of max and min</p>
</td></tr>
</table>

<hr>
<h2 id='plot.hyperframe'>Plot estimates</h2><span id='topic+plot.hyperframe'></span>

<h3>Description</h3>

<p>Plot estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperframe'
plot(
  x,
  ...,
  col,
  time_col = "time",
  range,
  lim = NA,
  main = "Image object",
  scalename = NA,
  color = c("white", "#F8DAC5FF", "#F4825AFF", "#D2204CFF", "#771F59FF"),
  combined = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.hyperframe_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_col">col</code></td>
<td>
<p>the name/s of a column of interest.</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_time_col">time_col</code></td>
<td>
<p>The name of the column of time variable. By default, '&quot;time&quot;'. Note that the time variable must be integers.</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_range">range</code></td>
<td>
<p>vector that specifies the range of tiem variable (e.g., 'c(&quot;2007-01-01&quot;, &quot;2007-01-31&quot;)')</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_lim">lim</code></td>
<td>
<p>limits of the scale. By default, NA. To set limits manually, provide a vector or max and min</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_main">main</code></td>
<td>
<p>title
To specify multiple columns, users should list column names as a character vector.</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_scalename">scalename</code></td>
<td>
<p>the name of the scale (for images only)</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_color">color</code></td>
<td>
<p>the color scale. By default, &quot;white&quot;, &quot;#F8DAC5FF&quot;, &quot;#F4825AFF&quot;, &quot;#D2204CFF&quot;, and &quot;#771F59FF&quot;.</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_combined">combined</code></td>
<td>
<p>logical. 'combined' specifies whether to combine all the point processes to one plot.
This argument applies only to the case when users specify one column with multiple time periods.
By default = TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='plot.im'>Plot im</h2><span id='topic+plot.im'></span>

<h3>Description</h3>

<p>Plot im
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
plot(
  x,
  ...,
  main = "Image object",
  scalename = "Density",
  grayscale = "FALSE",
  transf = NULL,
  color = c("white", "#F8DAC5FF", "#F4825AFF", "#D2204CFF", "#771F59FF"),
  lim = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.im_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.im_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.im_+3A_main">main</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id="plot.im_+3A_scalename">scalename</code></td>
<td>
<p>the name of the scale (for images only)</p>
</td></tr>
<tr><td><code id="plot.im_+3A_grayscale">grayscale</code></td>
<td>
<p>whether to use grayscale. By default, FALSE.</p>
</td></tr>
<tr><td><code id="plot.im_+3A_transf">transf</code></td>
<td>
<p>a function to transform the pixel values (by default, NULL)</p>
</td></tr>
<tr><td><code id="plot.im_+3A_color">color</code></td>
<td>
<p>the color scale. By default, &quot;white&quot;, &quot;#F8DAC5FF&quot;, &quot;#F4825AFF&quot;, &quot;#D2204CFF&quot;, and &quot;#771F59FF&quot;.</p>
</td></tr>
<tr><td><code id="plot.im_+3A_lim">lim</code></td>
<td>
<p>limits of the scale. By default, NA. To set limits manually, provide a vector or max and min</p>
</td></tr>
</table>

<hr>
<h2 id='plot.imlist'>Plot im objects (list)</h2><span id='topic+plot.imlist'></span>

<h3>Description</h3>

<p>Plot im objects (list)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imlist'
plot(
  x,
  ...,
  main = "image",
  lim = NA,
  transf = NULL,
  frame = 1,
  scalename = "Density",
  color = c("white", "#F8DAC5FF", "#F4825AFF", "#D2204CFF", "#771F59FF"),
  grayscale = FALSE,
  ncol = NA,
  nrow = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.imlist_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_main">main</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_lim">lim</code></td>
<td>
<p>limits of the scale. By default, NA. To set limits manually, provide a vector or max and min</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_transf">transf</code></td>
<td>
<p>a function to transform the pixel values (by default, NULL)</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_frame">frame</code></td>
<td>
<p>the element number of the list object (by default, 1)</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_scalename">scalename</code></td>
<td>
<p>the name of the scale</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_color">color</code></td>
<td>
<p>the color scale. By default, &quot;white&quot;, &quot;#F8DAC5FF&quot;, &quot;#F4825AFF&quot;, &quot;#D2204CFF&quot;, and &quot;#771F59FF&quot;.</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_grayscale">grayscale</code></td>
<td>
<p>grayscale or not. By default, FALSE.</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns (if plotitng multiple images at once)</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_nrow">nrow</code></td>
<td>
<p>the number of rows (if plotting multiple images at once)</p>
</td></tr>
</table>

<hr>
<h2 id='plot.list'>Plot lists</h2><span id='topic+plot.list'></span>

<h3>Description</h3>

<p>Plot lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
plot(
  x,
  ...,
  main = "list",
  lim = NA,
  transf = NULL,
  frame = 1,
  combined = TRUE,
  scalename = "Density",
  color = c("white", "#F8DAC5FF", "#F4825AFF", "#D2204CFF", "#771F59FF"),
  grayscale = FALSE,
  ncol = NA,
  nrow = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.list_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.list_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.list_+3A_main">main</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id="plot.list_+3A_lim">lim</code></td>
<td>
<p>limits of the scale. By default, NA. To set limits manually, provide a vector or max and min</p>
</td></tr>
<tr><td><code id="plot.list_+3A_transf">transf</code></td>
<td>
<p>a function to transform the pixel values (by default, NULL)
This argument applies only to the case when users specify one column with multiple time periods.
By default = TRUE</p>
</td></tr>
<tr><td><code id="plot.list_+3A_frame">frame</code></td>
<td>
<p>the element number of the list object (by default, 1)</p>
</td></tr>
<tr><td><code id="plot.list_+3A_combined">combined</code></td>
<td>
<p>logical. 'combined' specifies whether to combine all the point processes to one plot.</p>
</td></tr>
<tr><td><code id="plot.list_+3A_scalename">scalename</code></td>
<td>
<p>the name of the scale</p>
</td></tr>
<tr><td><code id="plot.list_+3A_color">color</code></td>
<td>
<p>the color scale. By default, &quot;white&quot;, &quot;#F8DAC5FF&quot;, &quot;#F4825AFF&quot;, &quot;#D2204CFF&quot;, and &quot;#771F59FF&quot;.</p>
</td></tr>
<tr><td><code id="plot.list_+3A_grayscale">grayscale</code></td>
<td>
<p>grayscale or not. By default, FALSE.</p>
</td></tr>
<tr><td><code id="plot.list_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns (if plotitng multiple images at once)</p>
</td></tr>
<tr><td><code id="plot.list_+3A_nrow">nrow</code></td>
<td>
<p>the number of rows (if plotting multiple images at once)</p>
</td></tr>
</table>

<hr>
<h2 id='plot.obs'>Plot observed densities</h2><span id='topic+plot.obs'></span>

<h3>Description</h3>

<p>Plot observed densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'obs'
plot(x, ..., dens_2 = NA, dens_3 = NA, time_unit = NA, combined = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.obs_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.obs_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.obs_+3A_dens_2">dens_2</code></td>
<td>
<p>density 2 (if any). By default, 'NA'.</p>
</td></tr>
<tr><td><code id="plot.obs_+3A_dens_3">dens_3</code></td>
<td>
<p>density 3 (if any). By default, 'NA'.</p>
</td></tr>
<tr><td><code id="plot.obs_+3A_time_unit">time_unit</code></td>
<td>
<p>x-axis label of the output</p>
</td></tr>
<tr><td><code id="plot.obs_+3A_combined">combined</code></td>
<td>
<p>whether to combine the two plots. By default, TRUE. If TRUE,
then the plot function produces one ggplot object. If FALSE, three objects (two ggplot and one dataframe) will be produced.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.powerlist'>Plot simulated power densities</h2><span id='topic+plot.powerlist'></span>

<h3>Description</h3>

<p>A function that takes the simulated power densities and their priorities
and returns a power density image over a range of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powerlist'
plot(
  x,
  ...,
  color = c("white", "#F8DAC5FF", "#F4825AFF", "#D2204CFF", "#771F59FF"),
  grayscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.powerlist_+3A_x">x</code></td>
<td>
<p>input (should be the output of the 'sim_power_dens()' function)</p>
</td></tr>
<tr><td><code id="plot.powerlist_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.powerlist_+3A_color">color</code></td>
<td>
<p>the color scale. By default, &quot;white&quot;, &quot;#F8DAC5FF&quot;, &quot;#F4825AFF&quot;, &quot;#D2204CFF&quot;, and &quot;#771F59FF&quot;.</p>
</td></tr>
<tr><td><code id="plot.powerlist_+3A_grayscale">grayscale</code></td>
<td>
<p>logical. 'grayscale' specifies whether to convert plot to grayscale (by default, FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of densities, plot, and priorities
</p>

<hr>
<h2 id='plot.ppplist'>Plot point pattern (list)</h2><span id='topic+plot.ppplist'></span>

<h3>Description</h3>

<p>Plot point pattern (list)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppplist'
plot(x, ..., frame = 1, main = "ppp", combined = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ppplist_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.ppplist_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.ppplist_+3A_frame">frame</code></td>
<td>
<p>the element number of the list object (by default, 1)</p>
</td></tr>
<tr><td><code id="plot.ppplist_+3A_main">main</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id="plot.ppplist_+3A_combined">combined</code></td>
<td>
<p>logical. 'combined' specifies whether to combine all the point processes to one plot.
This argument applies only to the case when users specify one column with multiple time periods.
By default = TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='plot.weights'>Plot weights</h2><span id='topic+plot.weights'></span>

<h3>Description</h3>

<p>Plot weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weights'
plot(x, ..., type_weights = "standardized", binwidth = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.weights_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.weights_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.weights_+3A_type_weights">type_weights</code></td>
<td>
<p>the type of weights to plot.
- If 'plot_weights' is 'standardized', histogram of standardized weights will be generated.
- If 'plot_weights' is 'unstandardized', histogram of unstandardized weights will be generated.
Default is 'standardized'.</p>
</td></tr>
<tr><td><code id="plot.weights_+3A_binwidth">binwidth</code></td>
<td>
<p>bin width of the histogram. Default is NULL</p>
</td></tr>
</table>

<hr>
<h2 id='predict_obs_dens'>Perform out-of-sample prediction</h2><span id='topic+predict_obs_dens'></span>

<h3>Description</h3>

<p>'predict_obs_dens()' performs out-of-sample prediction
(separating data into training and test sets).
It assumes that training and test sets have the same window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_obs_dens(hfr, ratio, dep_var, indep_var, ngrid = 100, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_obs_dens_+3A_hfr">hfr</code></td>
<td>
<p>hyperframe</p>
</td></tr>
<tr><td><code id="predict_obs_dens_+3A_ratio">ratio</code></td>
<td>
<p>numeric. ratio between training and test sets</p>
</td></tr>
<tr><td><code id="predict_obs_dens_+3A_dep_var">dep_var</code></td>
<td>
<p>dependent variables</p>
</td></tr>
<tr><td><code id="predict_obs_dens_+3A_indep_var">indep_var</code></td>
<td>
<p>independent variables</p>
</td></tr>
<tr><td><code id="predict_obs_dens_+3A_ngrid">ngrid</code></td>
<td>
<p>the number of grids. By default, '100'.</p>
</td></tr>
<tr><td><code id="predict_obs_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of the following:
* 'indep_var': independent variables
* 'coef': coefficients
* 'intens_grid_cells': im object of observed densities for each time period
* 'estimated_counts': the number of events that is estimated by the poisson point process model for each time period
* 'sum_log_intens': the sum of log intensities for each time period
* 'training_row_max': the max row ID of the training set
</p>

<hr>
<h2 id='print.cate'>Print results</h2><span id='topic+print.cate'></span>

<h3>Description</h3>

<p>'print' functions take the output and print the summary of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cate_+3A_x">x</code></td>
<td>
<p>an output object</p>
</td></tr>
<tr><td><code id="print.cate_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, observed densities (class: obs), estimates (class: est) and heterogeneity estimates (class: cate) are supported by this function.
</p>

<hr>
<h2 id='print.est'>Print results</h2><span id='topic+print.est'></span>

<h3>Description</h3>

<p>'print' functions take the output and print the summary of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'est'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.est_+3A_x">x</code></td>
<td>
<p>an output object</p>
</td></tr>
<tr><td><code id="print.est_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, observed densities (class: obs) and estimates (class: est) are supported by this function.
</p>

<hr>
<h2 id='sim_cf_dens'>Simulate counterfactual densities</h2><span id='topic+sim_cf_dens'></span>

<h3>Description</h3>

<p>'sim_cf_dens()' takes a list of power densities
and returns simulated counterfactual densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_cf_dens(expected_number, base_dens, power_sim_results, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_cf_dens_+3A_expected_number">expected_number</code></td>
<td>
<p>the expected number of observations</p>
</td></tr>
<tr><td><code id="sim_cf_dens_+3A_base_dens">base_dens</code></td>
<td>
<p>the baseline density (im object)</p>
</td></tr>
<tr><td><code id="sim_cf_dens_+3A_power_sim_results">power_sim_results</code></td>
<td>
<p>the results obtained by 'simulate_power_density()'</p>
</td></tr>
<tr><td><code id="sim_cf_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of counterfactual densities, power as numerics, and expected number as a numeric
</p>

<hr>
<h2 id='sim_power_dens'>Simulate power densities</h2><span id='topic+sim_power_dens'></span>

<h3>Description</h3>

<p>A function that takes the target densities and their priorities
and returns a power density image over a range of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_power_dens(target_dens, dens_manip, priorities, priorities_manip, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_power_dens_+3A_target_dens">target_dens</code></td>
<td>
<p>list of target densities. This should always be a list, even if there is only one target density.</p>
</td></tr>
<tr><td><code id="sim_power_dens_+3A_dens_manip">dens_manip</code></td>
<td>
<p>a target density for which we manipulate the value of priorities</p>
</td></tr>
<tr><td><code id="sim_power_dens_+3A_priorities">priorities</code></td>
<td>
<p>numeric. 'priorities' specifies the priority for the target density that we do not manipulate.</p>
</td></tr>
<tr><td><code id="sim_power_dens_+3A_priorities_manip">priorities_manip</code></td>
<td>
<p>vector of priorities for the density that we manipulate.</p>
</td></tr>
<tr><td><code id="sim_power_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of densities and priorities
</p>

<hr>
<h2 id='smooth_ppp'>Smooth outcome events</h2><span id='topic+smooth_ppp'></span>

<h3>Description</h3>

<p>'smooth_ppp()' takes a column of hyperframes (ppp objects) and smoothes them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_ppp(data, method, sampling = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_ppp_+3A_data">data</code></td>
<td>
<p>the name of a hyperframe and column of interest.
'data' should be in the form of '&quot;hyperframe$column&quot;'.</p>
</td></tr>
<tr><td><code id="smooth_ppp_+3A_method">method</code></td>
<td>
<p>methods for smoothing ppp objects.
Either '&quot;mclust&quot;' or '&quot;abramson&quot;'. See details.</p>
</td></tr>
<tr><td><code id="smooth_ppp_+3A_sampling">sampling</code></td>
<td>
<p>numeric between 0 and 1. 'sampling' determines the proportion of data
to use for initialization. By default, NA (meaning that it uses all data without sampling).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To smooth ppp objects, users can choose either the Gaussian mixture model ('method = &quot;mclust&quot;')
or Abramson's adaptive smoothing ('method = &quot;abramson&quot;').
The Gaussian mixture model is essentially the method that performs model-based clustering of all the observed points.
In this package, we employ the EII model (equal volume, round shape (spherical covariance)).
This means that we model observed points by several Gaussian densities with the same, round shape.
This is why this model is called fixed-bandwidth smoothing. This is a simple model to smooth observed points,
yet given that analyzing spatiotemporal data is often computationally demanding, it is often the best place to start (and end).
Sometimes this process can also take time, which is why an option for 'init' is included in this function.
</p>
<p>Another, more precise, method for smoothing outcomes is adaptive smoothing ('method = &quot;abram&quot;').
This method allows users to vary bandwidths based on 'Abramson (1982)'.
Essentially, this model assumes that the bandwidth is inversely proportional to the square root of the target densities.
Since the bandwidth is adaptive, the estimation is usually more precise than the Gaussian mixture model.
However, the caveat is that this method is often extremely computationally demanding.
</p>


<h3>Value</h3>

<p>im objects
</p>

<hr>
<h2 id='summary.cate'>Summarize results</h2><span id='topic+summary.cate'></span>

<h3>Description</h3>

<p>'summary' functions take the output and summarize it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cate'
summary(object, ..., significance_level = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cate_+3A_object">object</code></td>
<td>
<p>an output object</p>
</td></tr>
<tr><td><code id="summary.cate_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="summary.cate_+3A_significance_level">significance_level</code></td>
<td>
<p>Numeric scalar between 0 and 1, inclusive, representing the significance level for the chi-square test. The test is used to determine whether at least one of the coefficients (except the intercept) is not equal to 0. Default is 0.05</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, observed densities (class: obs), estimates (class: est) and heterogeneity estimates (class: cate) are supported by this function.
</p>

<hr>
<h2 id='summary.est'>Summarize results</h2><span id='topic+summary.est'></span>

<h3>Description</h3>

<p>'summary' functions take the output and summarize it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'est'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.est_+3A_object">object</code></td>
<td>
<p>an output object</p>
</td></tr>
<tr><td><code id="summary.est_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, observed densities (class: obs) and estimates (class: est) are supported by this function.
</p>

<hr>
<h2 id='summary.obs'>Summarize results</h2><span id='topic+summary.obs'></span>

<h3>Description</h3>

<p>'summary' functions take the output and summarize it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'obs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.obs_+3A_object">object</code></td>
<td>
<p>an output object</p>
</td></tr>
<tr><td><code id="summary.obs_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, observed densities (class: obs) and estimates (class: est) are supported by this function.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
