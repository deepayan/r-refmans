<!DOCTYPE html><html><head><title>Help for package geocausal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geocausal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#airstrikes'><p>airstrikes</p></a></li>
<li><a href='#airstrikes_base'><p>airstrikes_base</p></a></li>
<li><a href='#conv_owin_into_sf'><p>Convert windows into sf objects</p></a></li>
<li><a href='#get_base_dens'><p>Get the baseline density</p></a></li>
<li><a href='#get_cf_dens'><p>Get counterfactual densities</p></a></li>
<li><a href='#get_cf_sum_log_intens'><p>Calculate the log counterfactual densities</p></a></li>
<li><a href='#get_dist_focus'><p>Get distance maps</p></a></li>
<li><a href='#get_dist_line'><p>Get distance maps from lines and polygons</p></a></li>
<li><a href='#get_distexp'><p>Get the expectation of treatment events with arbitrary distances</p></a></li>
<li><a href='#get_elev'><p>Get elevation data</p></a></li>
<li><a href='#get_est'><p>Get causal estimates comparing two scenarios</p></a></li>
<li><a href='#get_estimates'><p>Generate a Hajek estimator</p></a></li>
<li><a href='#get_hfr'><p>Create a hyperframe</p></a></li>
<li><a href='#get_hist'><p>Obtain histories of treatment or outcome events</p></a></li>
<li><a href='#get_obs_dens'><p>Generate observed densities</p></a></li>
<li><a href='#get_power_dens'><p>Get power densities</p></a></li>
<li><a href='#get_var_bound'><p>Calculate variance upper bounds</p></a></li>
<li><a href='#get_weighted_surf'><p>Generate average weighted surfaces</p></a></li>
<li><a href='#get_window'><p>Generate a window</p></a></li>
<li><a href='#insurgencies'><p>insurgencies</p></a></li>
<li><a href='#iraq_window'><p>iraq_window</p></a></li>
<li><a href='#plot.est'><p>Plot estimates</p></a></li>
<li><a href='#plot.hyperframe'><p>Plot estimates</p></a></li>
<li><a href='#plot.im'><p>Plot im</p></a></li>
<li><a href='#plot.obs'><p>Plot observed densities</p></a></li>
<li><a href='#predict_obs_dens'><p>Perform out-of-sample prediction</p></a></li>
<li><a href='#sim_cf_dens'><p>Simulate counterfactual densities</p></a></li>
<li><a href='#sim_power_dens'><p>Simulate power densities</p></a></li>
<li><a href='#smooth_ppp'><p>Smooth outcome events</p></a></li>
<li><a href='#summary.est'><p>Summarize results</p></a></li>
<li><a href='#summary.obs'><p>Summarize results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Causal Inference with Spatio-Temporal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mitsuru Mukaigawara &lt;mitsuru_mukaigawara@g.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatio-temporal causal inference based on point process data. 
    You provide the raw data of locations and timings of treatment and 
    outcome events, specify counterfactual scenarios, and the package 
    estimates causal effects over specified spatial and temporal windows.
    See Papadogeorgou, et  al. (2022) &lt;<a href="https://doi.org/10.1111%2Frssb.12548">doi:10.1111/rssb.12548</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mmukaigawara/geocausal">https://github.com/mmukaigawara/geocausal</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>elevatr, geosphere, gridExtra, ggthemes, knitr, readr</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, dplyr, furrr, ggplot2, ggpubr, latex2exp, mclust,
progressr, purrr, sf, spatstat.explore, spatstat.geom,
spatstat.model, terra, tidyr, tidyselect, tidyterra</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-25 18:35:46 UTC; mitsurumukaigawara</td>
</tr>
<tr>
<td>Author:</td>
<td>Mitsuru Mukaigawara
    <a href="https://orcid.org/0000-0001-6530-2083"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Georgia Papadogeorgou
    <a href="https://orcid.org/0000-0002-1982-2245"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jason Lyall <a href="https://orcid.org/0000-0001-9117-7503"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Kosuke Imai <a href="https://orcid.org/0000-0002-2748-1022"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-25 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='airstrikes'>airstrikes</h2><span id='topic+airstrikes'></span>

<h3>Description</h3>

<p>A subset of airstrikes data in Iraq (March to June 2007)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airstrikes
</code></pre>


<h3>Format</h3>

<p>A tibble with 3938 rows and 4 variables:
</p>

<dl>
<dt>date</dt><dd><p>Date (YYYY-MM-DD)</p>
</dd>
<dt>longitude</dt><dd><p>Longitudes (decimal)</p>
</dd>
<dt>latitude</dt><dd><p>Latitudees (decimal)</p>
</dd>
<dt>type</dt><dd><p>Types of airstrikes (airstrikes or shows of force (SOF))</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>airstrikes
</code></pre>

<hr>
<h2 id='airstrikes_base'>airstrikes_base</h2><span id='topic+airstrikes_base'></span>

<h3>Description</h3>

<p>A subset of airstrikes data in Iraq (a subset of airstrikes in 2006) that can be used to construct baseline densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airstrikes_base
</code></pre>


<h3>Format</h3>

<p>A tibble with 808 rows and 3 variables:
</p>

<dl>
<dt>date</dt><dd><p>Date</p>
</dd>
<dt>longitude</dt><dd><p>Longitudes (decimal)</p>
</dd>
<dt>latitude</dt><dd><p>Latitudees (decimal)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>airstrikes_base
</code></pre>

<hr>
<h2 id='conv_owin_into_sf'>Convert windows into sf objects</h2><span id='topic+conv_owin_into_sf'></span>

<h3>Description</h3>

<p>'conv_owin_into_sf' takes an owin object and converts it to sf-related objects. 
This function is mostly an internal function of other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv_owin_into_sf(window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_owin_into_sf_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of polygon, dataframe, sfc_POLYGON, sf, and SpatialPolygonsDataFrame objects
</p>

<hr>
<h2 id='get_base_dens'>Get the baseline density</h2><span id='topic+get_base_dens'></span>

<h3>Description</h3>

<p>'get_base_dens()' takes a dataframe and
returns the baseline densities using Scott's rule of thumb (out-of-sample data)
or fitting an inhomogeneous Poisson model (in-sample data) by regressing
the in-sample data on time-invariant covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_base_dens(
  window,
  option,
  ndim = 256,
  out_data,
  out_coordinates = c("longitude", "latitude"),
  hfr,
  dep_var,
  indep_var,
  ratio
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_base_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_option">option</code></td>
<td>
<p>&quot;in&quot; (using in-sample data) or &quot;out&quot; (using out-of-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_ndim">ndim</code></td>
<td>
<p>the number of dimensions of grid cells (ndim^2). By default, ndim = 256.</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_out_data">out_data</code></td>
<td>
<p>dataframe (if using out-of-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_out_coordinates">out_coordinates</code></td>
<td>
<p>vector of column names of longitudes and latitudes (in this order) (if using in-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_hfr">hfr</code></td>
<td>
<p>hyperframe (if using in-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_dep_var">dep_var</code></td>
<td>
<p>the name of the dependent variable (if using in-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_indep_var">indep_var</code></td>
<td>
<p>the names of time-invariant independent varaibles (if using in-sample data)</p>
</td></tr>
<tr><td><code id="get_base_dens_+3A_ratio">ratio</code></td>
<td>
<p>for random sampling of data (if using in-sample data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an im object of baseline density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_base_dens(option = "out",
              out_data = airstrikes_base,
              out_coordinates = c("longitude", "latitude"),
              window = iraq_window,
              ndim = 256)
</code></pre>

<hr>
<h2 id='get_cf_dens'>Get counterfactual densities</h2><span id='topic+get_cf_dens'></span>

<h3>Description</h3>

<p>'get_cf_dens' takes the target (expected) number, baseline density,
and power density, and generates a hyperframe with counterfactual densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cf_dens(expected_number, base_dens, power_dens = NA, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cf_dens_+3A_expected_number">expected_number</code></td>
<td>
<p>the expected number of observations.</p>
</td></tr>
<tr><td><code id="get_cf_dens_+3A_base_dens">base_dens</code></td>
<td>
<p>baseline density (im object)</p>
</td></tr>
<tr><td><code id="get_cf_dens_+3A_power_dens">power_dens</code></td>
<td>
<p>power density (im object)</p>
</td></tr>
<tr><td><code id="get_cf_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways of generating counterfactual densities.
First, users can keep the locations of observations as they are and change the expected number of observations.
In this case, users do not have to set 'power_dens' and simply modify 'expected_number'.
Alternatively, users can shift the locations as well. In this case, 'power_dens' must be specified.
To obtain power densities, refer to [get_power_dens()].
</p>


<h3>Value</h3>

<p>an im object of a counterfactual density
</p>

<hr>
<h2 id='get_cf_sum_log_intens'>Calculate the log counterfactual densities</h2><span id='topic+get_cf_sum_log_intens'></span>

<h3>Description</h3>

<p>A function that takes a hyperframe and returns the log counterfactual densities
ie, the numerator of the equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cf_sum_log_intens(cf_dens, treatment_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cf_sum_log_intens_+3A_cf_dens">cf_dens</code></td>
<td>
<p>A counterfactual density (an im object)</p>
</td></tr>
<tr><td><code id="get_cf_sum_log_intens_+3A_treatment_data">treatment_data</code></td>
<td>
<p>In the form of hyperframe$column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of sums of log densities for each time period
</p>

<hr>
<h2 id='get_dist_focus'>Get distance maps</h2><span id='topic+get_dist_focus'></span>

<h3>Description</h3>

<p>'get_dist_focus()' generates a distance map from focus locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist_focus(window, lon, lat, resolution, mile = FALSE, preprocess = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dist_focus_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
<tr><td><code id="get_dist_focus_+3A_lon">lon</code></td>
<td>
<p>vector of longitudes</p>
</td></tr>
<tr><td><code id="get_dist_focus_+3A_lat">lat</code></td>
<td>
<p>vector of latitudes</p>
</td></tr>
<tr><td><code id="get_dist_focus_+3A_resolution">resolution</code></td>
<td>
<p>resolution of raster objects</p>
</td></tr>
<tr><td><code id="get_dist_focus_+3A_mile">mile</code></td>
<td>
<p>logical. 'mile' specifies whether to return the output in miles instead of kilometers (by default, FALSE).</p>
</td></tr>
<tr><td><code id="get_dist_focus_+3A_preprocess">preprocess</code></td>
<td>
<p>logical. 'preprocess' specifies whether to first pick the potentially closest point. 
It is recommended to set 'preprocess = TRUE' if users need to obtain distances from many points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_dist_focus()' depends on 'geosphere::distVincentyEllipsoid()'. 
Since it calculates accurate distances considering the ellipsoid, the process sometimes 
becomes computationally demanding, namely when we need to obtain distances from many points. 
In that case, users can set 'preprocess = TRUE'. With this option, 'get_dist_focus()' calculates 
distances from points by first identifying the closest point using 'sf::st_nearest_feature()' with approximations.
This process is more efficient than computing distances from all the points 
with 'geosphere::distVincentyEllipsoid()' and then obtaining the minimum of all the distances. 
By default, 'get_dist_focus()' returns distances in kilometers unless users set 'mile =  TRUE'.
</p>


<h3>Value</h3>

<p>an im object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_dist_focus(window = iraq_window,
               lon = c(44.366), #Baghdad
               lat = c(33.315),
               resolution = 0.5,
               mile = FALSE,
               preprocess = FALSE)
</code></pre>

<hr>
<h2 id='get_dist_line'>Get distance maps from lines and polygons</h2><span id='topic+get_dist_line'></span>

<h3>Description</h3>

<p>'get_dist_line()' generates a distance map from lines and polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist_line(
  window,
  path_to_shapefile,
  line_data = NULL,
  mile = FALSE,
  resolution,
  preprocess = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dist_line_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
<tr><td><code id="get_dist_line_+3A_path_to_shapefile">path_to_shapefile</code></td>
<td>
<p>path to shapefile</p>
</td></tr>
<tr><td><code id="get_dist_line_+3A_line_data">line_data</code></td>
<td>
<p>sfc_MULTILINESTRING file (If available. If not, 'get_dist_line()' creates it from a shapefile.)</p>
</td></tr>
<tr><td><code id="get_dist_line_+3A_mile">mile</code></td>
<td>
<p>logical. 'mile' specifies whether to return the output in miles instead of kilometers (by default,  FALSE).</p>
</td></tr>
<tr><td><code id="get_dist_line_+3A_resolution">resolution</code></td>
<td>
<p>resolution of raster objects</p>
</td></tr>
<tr><td><code id="get_dist_line_+3A_preprocess">preprocess</code></td>
<td>
<p>logical. 'preprocess' specifies whether to first pick the potentially closest point.
It is recommended to set 'preprocess = TRUE' if users need to obtain distances from many points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an im object
</p>

<hr>
<h2 id='get_distexp'>Get the expectation of treatment events with arbitrary distances</h2><span id='topic+get_distexp'></span>

<h3>Description</h3>

<p>'get_distexp()' takes counterfactual densities and
and returns the expected number of treatment events based on distances
from a user-specified focus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distexp(
  cf_sim_results,
  entire_window,
  dist_map,
  dist_map_unit = "km",
  grayscale = FALSE,
  use_raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_distexp_+3A_cf_sim_results">cf_sim_results</code></td>
<td>
<p>output of 'sim_cf_dens()'</p>
</td></tr>
<tr><td><code id="get_distexp_+3A_entire_window">entire_window</code></td>
<td>
<p>owin object of the entire region</p>
</td></tr>
<tr><td><code id="get_distexp_+3A_dist_map">dist_map</code></td>
<td>
<p>im object whose cell values are the distance from a focus (e.g., city)</p>
</td></tr>
<tr><td><code id="get_distexp_+3A_dist_map_unit">dist_map_unit</code></td>
<td>
<p>either '&quot;km&quot;' or '&quot;mile&quot;'</p>
</td></tr>
<tr><td><code id="get_distexp_+3A_grayscale">grayscale</code></td>
<td>
<p>logical. 'grayscale' specifies whether to convert plot to grayscale (by default, FALSE).</p>
</td></tr>
<tr><td><code id="get_distexp_+3A_use_raw">use_raw</code></td>
<td>
<p>logical. 'use_raw' specifies whether to use the raw value of expectations or percentiles.
By default, 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of ggplot objects that summarizes how expectations change over distances from a focus ('expectation_plot')
and summarizes distances and areas ('window_plot'). Note that the second object can not necessarily be well drawn
depending on how windows are defined.
</p>

<hr>
<h2 id='get_elev'>Get elevation data</h2><span id='topic+get_elev'></span>

<h3>Description</h3>

<p>'get_elevation()' takes a directory that hosts shapefile and returns an owin object of altitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elev(load_path, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_elev_+3A_load_path">load_path</code></td>
<td>
<p>path to the shp file (note: a folder)</p>
</td></tr>
<tr><td><code id="get_elev_+3A_...">...</code></td>
<td>
<p>other parameters passed to 'elevatr::get_elev_raster()'. The resolution argument z must be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an im object (unit: meters)
</p>

<hr>
<h2 id='get_est'>Get causal estimates comparing two scenarios</h2><span id='topic+get_est'></span>

<h3>Description</h3>

<p>'get_est()' generates causal estimates comparing two counterfactual scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_est(
  obs,
  cf1,
  cf2,
  treat,
  sm_out,
  mediation = FALSE,
  obs_med_log_sum_dens = NA,
  cf1_med_log_sum_dens = NA,
  cf2_med_log_sum_dens = NA,
  lag,
  time_after = TRUE,
  entire_window,
  use_dist,
  windows,
  dist_map,
  dist,
  trunc_level = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_est_+3A_obs">obs</code></td>
<td>
<p>observed density</p>
</td></tr>
<tr><td><code id="get_est_+3A_cf1">cf1</code></td>
<td>
<p>counterfactual density 1</p>
</td></tr>
<tr><td><code id="get_est_+3A_cf2">cf2</code></td>
<td>
<p>counterfactual density 2</p>
</td></tr>
<tr><td><code id="get_est_+3A_treat">treat</code></td>
<td>
<p>column of a hyperframe that summarizes treatment data. In the form of 'hyperframe$column'.</p>
</td></tr>
<tr><td><code id="get_est_+3A_sm_out">sm_out</code></td>
<td>
<p>column of a hyperframe that summarizes the smoothed outcome data</p>
</td></tr>
<tr><td><code id="get_est_+3A_mediation">mediation</code></td>
<td>
<p>whether to perform causal mediation analysis (don't use; still in development). By default, FALSE.</p>
</td></tr>
<tr><td><code id="get_est_+3A_obs_med_log_sum_dens">obs_med_log_sum_dens</code></td>
<td>
<p>sum of log densities of mediators for the observed (don't use; still in development)</p>
</td></tr>
<tr><td><code id="get_est_+3A_cf1_med_log_sum_dens">cf1_med_log_sum_dens</code></td>
<td>
<p>sum of log densities of mediators for counterfactual 1 (don't use; still in development)</p>
</td></tr>
<tr><td><code id="get_est_+3A_cf2_med_log_sum_dens">cf2_med_log_sum_dens</code></td>
<td>
<p>sum of log densities of mediators for counterfactual 2 (don't use; still in development)</p>
</td></tr>
<tr><td><code id="get_est_+3A_lag">lag</code></td>
<td>
<p>integer that specifies lags to calculate causal estimates</p>
</td></tr>
<tr><td><code id="get_est_+3A_time_after">time_after</code></td>
<td>
<p>whether to include one unit time difference between treatment and outcome. By default = TRUE</p>
</td></tr>
<tr><td><code id="get_est_+3A_entire_window">entire_window</code></td>
<td>
<p>owin object (the entire region of interest)</p>
</td></tr>
<tr><td><code id="get_est_+3A_use_dist">use_dist</code></td>
<td>
<p>whether to use distance-based maps. By default, TRUE</p>
</td></tr>
<tr><td><code id="get_est_+3A_windows">windows</code></td>
<td>
<p>a list of owin objects (if 'use_dist = FALSE')</p>
</td></tr>
<tr><td><code id="get_est_+3A_dist_map">dist_map</code></td>
<td>
<p>distance map (an im object, if 'use_dist = TRUE')</p>
</td></tr>
<tr><td><code id="get_est_+3A_dist">dist</code></td>
<td>
<p>distances (a numeric vector within the max distance of 'dist_map')</p>
</td></tr>
<tr><td><code id="get_est_+3A_trunc_level">trunc_level</code></td>
<td>
<p>the level of truncation for the weights (0-1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The level of truncation indicates the quantile of weights at which weights are truncated.
That is, if 'trunc_level = 0.95', then all weights are truncated at the 95 percentile of the weights.
</p>


<h3>Value</h3>

<p>list of the following:
'cf1_ave_surf': average weighted surface for scenario 1
'cf2_ave_surf': average weighted surface for scenario 2
'est_cf': estimated effects of each scenario
'est_causal': estimated causal contrasts
'var_cf': variance upper bounds for each scenario
'var_causal': variance upper bounds for causal contrasts
'windows': list of owin objects
</p>

<hr>
<h2 id='get_estimates'>Generate a Hajek estimator</h2><span id='topic+get_estimates'></span>

<h3>Description</h3>

<p>A function that returns a Hajek estimator of causal contrasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_estimates(
  weighted_surf_1,
  weighted_surf_2,
  use_dist = TRUE,
  windows,
  dist_map,
  dist,
  entire_window
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_estimates_+3A_weighted_surf_1">weighted_surf_1</code></td>
<td>
<p>a weighted surface for scenario 1</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_weighted_surf_2">weighted_surf_2</code></td>
<td>
<p>another weighted surface for scenario 2</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_use_dist">use_dist</code></td>
<td>
<p>whether to use distance-based maps. By default, TRUE</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_windows">windows</code></td>
<td>
<p>a list of owin objects (if 'use_dist = FALSE')</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_dist_map">dist_map</code></td>
<td>
<p>distance map (an im object, if 'use_dist = TRUE')</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_dist">dist</code></td>
<td>
<p>distances (a numeric vector within the max distance of 'dist_map')</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_entire_window">entire_window</code></td>
<td>
<p>an owin object of the entire map</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_estimates()' is an internal function to 'get_est()' function, 
performing the estimation analysis after 'get_weighted_surf()' function
</p>


<h3>Value</h3>

<p>list of Hajek estimators for each scenario ('est_haj'), 
causal contrasts (Hajek estimator) as a matrix ('est_tau_haj_matrix'), and 
causal contrast (scenario 2 - scenario 1) as a numeric vector ('est_tau_haj_cf2_vs_cf1'), 
along with weights, windows, and smoothed outcomes
</p>

<hr>
<h2 id='get_hfr'>Create a hyperframe</h2><span id='topic+get_hfr'></span>

<h3>Description</h3>

<p>'get_hfr()' takes a dataframe with time and location variables
and generates a hyperframe with point patterns.
'get_hfr()' is usually the first function that users employ in order to
perform spatiotemporal causal inference analytic methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hfr(
  data,
  col,
  window,
  time_col,
  time_range,
  coordinates = c("longitude", "latitude"),
  combine = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hfr_+3A_data">data</code></td>
<td>
<p>dataframe. The dataframe must have time and location variables.
Location variables should be standard coordinates (i.e., longitudes and latitudes).</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_col">col</code></td>
<td>
<p>the name of the column for subtypes of events of interest</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_window">window</code></td>
<td>
<p>owin object (for more information, refer to 'spatstat.geom::owin()').
Basically, an owin object specifies the geographical boundaries of areas of interest.</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_time_col">time_col</code></td>
<td>
<p>the name of the column for time variable. Note that the time variable must be integers.</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_time_range">time_range</code></td>
<td>
<p>numeric vector. 'time_range' specifies the range of the time variable
(i.e., min and max of the time variable).
The current version assumes that the unit of this time variable is dates.</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_coordinates">coordinates</code></td>
<td>
<p>character vector. 'coordinates' specifies the names of columns for locations.
By default, 'c(&quot;longitude&quot;, &quot;latitude&quot;)' in this order. Note that the coordinates must be in decimal degree formats.</p>
</td></tr>
<tr><td><code id="get_hfr_+3A_combine">combine</code></td>
<td>
<p>logical. 'combine' tells whether to generate output for all subtypes of events combined.
By default, 'TRUE', which means that a column of ppp objects with all subtypes combined is generated in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A hyperframe is generated with rows representing time and columns representing the following:
* The first column: time variable
* The middle columns: ppp objects (see 'spatstat.geom::ppp()') generated for each subtype of events of interest
* The last column (if 'combine = TRUE'): ppp objects with all subtypes combined. This column is named as 'all_combined'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data
dat &lt;- data.frame(time = c(1, 1, 2, 2),
                  longitude = c(43.9, 44.5, 44.1, 44.0),
                  latitude = c(33.6, 32.7, 33.6, 33.5),
                  type = rep(c("treat", "out"), 2))

# Hyperframe
get_hfr(data = dat,
        col = "type",
        window = iraq_window,
        time_col = "time",
        time_range = c(1, 2),
        coordinates = c("longitude", "latitude"),
        combine = FALSE)
</code></pre>

<hr>
<h2 id='get_hist'>Obtain histories of treatment or outcome events</h2><span id='topic+get_hist'></span>

<h3>Description</h3>

<p>'get_hist()' takes a hyperframe and time and columns of interest, and generates histories of events of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hist(tt, Xt, Yt = NA, lag, window, x_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hist_+3A_tt">tt</code></td>
<td>
<p>values of the time variable of interest for which 'get_hist()' generates histories</p>
</td></tr>
<tr><td><code id="get_hist_+3A_xt">Xt</code></td>
<td>
<p>the name of a treatment column</p>
</td></tr>
<tr><td><code id="get_hist_+3A_yt">Yt</code></td>
<td>
<p>the name of an outcome column</p>
</td></tr>
<tr><td><code id="get_hist_+3A_lag">lag</code></td>
<td>
<p>numeric. 'lag' specifies the number of time periods over which
'get_hist()' aggregates treatment and outcome columns.</p>
</td></tr>
<tr><td><code id="get_hist_+3A_window">window</code></td>
<td>
<p>owin object.</p>
</td></tr>
<tr><td><code id="get_hist_+3A_x_only">x_only</code></td>
<td>
<p>logical. 'x_only' specifies whether to generate only treatment history (no outcome history). By default, 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of treatment and outcome histories
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat_out &lt;- insurgencies[1:100, ]
dat_out$time &lt;- as.numeric(dat_out$date - min(dat_out$date) + 1)

# Hyperframe
dat_hfr &lt;- get_hfr(data = dat_out,
                   col = "type",
                   window = iraq_window,
                   time_col = "time",
                   time_range = c(1, max(dat_out$time)),
                   coordinates = c("longitude", "latitude"),
                   combine = TRUE)

# Histories
lapply(1:nrow(dat_hfr), get_hist,
       Xt = dat_hfr$all_outcome,
       lag = 1, window = iraq_window)
</code></pre>

<hr>
<h2 id='get_obs_dens'>Generate observed densities</h2><span id='topic+get_obs_dens'></span>

<h3>Description</h3>

<p>'get_obs_dens()' takes a hyperframe and returns observed densities.
The output is used as propensity scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_obs_dens(hfr, dep_var, indep_var, ngrid = 100, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_obs_dens_+3A_hfr">hfr</code></td>
<td>
<p>hyperframe</p>
</td></tr>
<tr><td><code id="get_obs_dens_+3A_dep_var">dep_var</code></td>
<td>
<p>The name of the dependent variable.
Since we need to obtain the observed density of treatment events,
'dep_var' should be the name of the treatment variable.</p>
</td></tr>
<tr><td><code id="get_obs_dens_+3A_indep_var">indep_var</code></td>
<td>
<p>vector of names of independent variables (covariates)</p>
</td></tr>
<tr><td><code id="get_obs_dens_+3A_ngrid">ngrid</code></td>
<td>
<p>the number of grid cells that is used to generate observed densities.
By default = 100. Notice that as you increase 'ngrid', the process gets computationally demanding.</p>
</td></tr>
<tr><td><code id="get_obs_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_obs_dens()' assumes the poisson point process model and
calculates observed densities for each time period. It depends on 'spatstat.model::mppm()'.
Users should note that the coefficients in the output are not directly interpretable,
since they are the coefficients inside the exponential of the poisson model.
</p>


<h3>Value</h3>

<p>list of the following:
* 'indep_var': independent variables
* 'coef': coefficients
* 'intens_grid_cells': im object of observed densities for each time period
* 'estimated_counts': the number of events that is estimated by the poisson point process model for each time period
* 'sum_log_intens': the sum of log intensities for each time period
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data
dat_out &lt;- insurgencies[1:100, ]
dat_out$time &lt;- as.numeric(dat_out$date - min(dat_out$date) + 1)

# Hyperframe
dat_hfr &lt;- get_hfr(data = dat_out,
                   col = "type",
                   window = iraq_window,
                   time_col = "time",
                   time_range = c(1, max(dat_out$time)),
                   coordinates = c("longitude", "latitude"),
                   combine = TRUE)

# Covariates
dist_baghdad &lt;- get_dist_focus(window = iraq_window,
                               lon = c(44.366), #Baghdad
                               lat = c(33.315),
                               resolution = 0.1,
                               mile = FALSE,
                               preprocess = FALSE)

dat_hfr$dist_bagh &lt;- dist_baghdad

# Observed density
get_obs_dens(dat_hfr,
             dep_var = "all_combined",
             indep_var = c("dist_bagh"),
             ngrid = 100,
             window = iraq_window)
</code></pre>

<hr>
<h2 id='get_power_dens'>Get power densities</h2><span id='topic+get_power_dens'></span>

<h3>Description</h3>

<p>'get_power_dens()' takes the target densities and their priorities
and returns a power density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_power_dens(target_dens, priorities, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_power_dens_+3A_target_dens">target_dens</code></td>
<td>
<p>list of target densities</p>
</td></tr>
<tr><td><code id="get_power_dens_+3A_priorities">priorities</code></td>
<td>
<p>vector of priorities for each of target densities</p>
</td></tr>
<tr><td><code id="get_power_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of an im object and a ggplot object of power densities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Density 1: Distance from Mosul
dist_from_mosul &lt;- get_dist_focus(window = iraq_window,
                                  lon = c(43.158),
                                  lat = c(36.349),
                                  resolution = 0.5,
                                  mile = FALSE,
                                  preprocess = FALSE)

# Density 2: Distance from Baghdad
dist_from_baghd &lt;- get_dist_focus(window = iraq_window,
                                  lon = c(44.366),
                                  lat = c(33.315),
                                  resolution = 0.5,
                                  mile = FALSE,
                                  preprocess = FALSE)

# Power density
get_power_dens(target_dens = list(dist_from_mosul, dist_from_baghd),
               priorities = c(3, 2),
               window = iraq_window)
</code></pre>

<hr>
<h2 id='get_var_bound'>Calculate variance upper bounds</h2><span id='topic+get_var_bound'></span>

<h3>Description</h3>

<p>A function that calculates variance upper bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_var_bound(estimates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_var_bound_+3A_estimates">estimates</code></td>
<td>
<p>an object returned from 'get_est()' function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_var_bound()' is an internal function to 'get_estimates()' function, 
performing the estimation analysis after 'get_est()' function
</p>


<h3>Value</h3>

<p>list of variance upper bounds for each scenario ('bound_haj') and causal contrasts ('bound_tau_haj'). 
Note that this function returns variance upper bounds for Hajek estimators
</p>

<hr>
<h2 id='get_weighted_surf'>Generate average weighted surfaces</h2><span id='topic+get_weighted_surf'></span>

<h3>Description</h3>

<p>A function that returns averaged weighted surfaces (both IPW and Hajek) along with weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_weighted_surf(
  obs_dens,
  cf_dens,
  mediation = FALSE,
  obs_med_log_sum_dens,
  cf_med_log_sum_dens,
  treatment_data,
  smoothed_outcome,
  lag,
  entire_window,
  time_after,
  truncation_level = truncation_level
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_weighted_surf_+3A_obs_dens">obs_dens</code></td>
<td>
<p>observed density</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_cf_dens">cf_dens</code></td>
<td>
<p>counterfactual density</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_mediation">mediation</code></td>
<td>
<p>whether to perform causal mediation analysis. By default, FALSE.</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_obs_med_log_sum_dens">obs_med_log_sum_dens</code></td>
<td>
<p>sum of log densities of mediators for the observed (if 'mediation = TRUE')</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_cf_med_log_sum_dens">cf_med_log_sum_dens</code></td>
<td>
<p>sum of log densities of mediators for counterfactual (if 'mediation = TRUE')</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_treatment_data">treatment_data</code></td>
<td>
<p>column of a hyperframe that summarizes treatment data. In the form of 'hyperframe$column'.</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_smoothed_outcome">smoothed_outcome</code></td>
<td>
<p>column of a hyperframe that summarizes the smoothed outcome data</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_lag">lag</code></td>
<td>
<p>integer that specifies lags to calculate causal estimates</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_entire_window">entire_window</code></td>
<td>
<p>owin object (the entire region of interest)</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_time_after">time_after</code></td>
<td>
<p>whether to include one unit time difference between treatment and outcome</p>
</td></tr>
<tr><td><code id="get_weighted_surf_+3A_truncation_level">truncation_level</code></td>
<td>
<p>the level at which the weights are truncated (see 'get_estimates()')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_weighted_surf()' is an internal function to 'get_estimates()' function.
If 'time_after' is TRUE, then this function uses treatment data and weights from lag to nrow(data)-1, and
outcome data from lag+1 to nrow(data).
</p>


<h3>Value</h3>

<p>list of an average weighted surface ('avarage_surf', an 'im' object),
a Hajek average weighted surface ('average_weighted_surf_haj', an 'im' object),
weights, and smoothed outcomes
</p>

<hr>
<h2 id='get_window'>Generate a window</h2><span id='topic+get_window'></span>

<h3>Description</h3>

<p>'get_window()' takes a directory that hosts a shapefile
and returns an owin object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_window(load_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_window_+3A_load_path">load_path</code></td>
<td>
<p>path to the shp file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>owin object
</p>

<hr>
<h2 id='insurgencies'>insurgencies</h2><span id='topic+insurgencies'></span>

<h3>Description</h3>

<p>A subset of insurgencies data in Iraq (March to June 2007)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insurgencies
</code></pre>


<h3>Format</h3>

<p>A tibble with 68573 rows and 4 variables:
</p>

<dl>
<dt>date</dt><dd><p>Date (YYYY-MM-DD)</p>
</dd>
<dt>longitude</dt><dd><p>Longitudes (decimal)</p>
</dd>
<dt>latitude</dt><dd><p>Latitudees (decimal)</p>
</dd>
<dt>type</dt><dd><p>Types of insurgencies (improvised explosive devices (IED), small arms fire (SAF), or other)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>insurgencies
</code></pre>

<hr>
<h2 id='iraq_window'>iraq_window</h2><span id='topic+iraq_window'></span>

<h3>Description</h3>

<p>An owin object of Iraq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iraq_window
</code></pre>


<h3>Format</h3>

<p>A polygonal object:
</p>

<dl>
<dt>type</dt><dd><p>Polygonal</p>
</dd>
<dt>xrange</dt><dd><p>Range (longitude)</p>
</dd>
<dt>yrange</dt><dd><p>Range (latitude)</p>
</dd>
<dt>bdry</dt><dd><p>Boundaries</p>
</dd>
<dt>units</dt><dd><p>Units</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>iraq_window
</code></pre>

<hr>
<h2 id='plot.est'>Plot estimates</h2><span id='topic+plot.est'></span>

<h3>Description</h3>

<p>Plot estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'est'
plot(x, ..., lim = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.est_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.est_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.est_+3A_lim">lim</code></td>
<td>
<p>limits of the scale. By default, NA. To set limits manually, provide a vector or max and min</p>
</td></tr>
</table>

<hr>
<h2 id='plot.hyperframe'>Plot estimates</h2><span id='topic+plot.hyperframe'></span>

<h3>Description</h3>

<p>Plot estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyperframe'
plot(
  x,
  ...,
  col,
  time_col = "time",
  range,
  lim = NA,
  scalename = NA,
  color = c("white", "#F8DAC5FF", "#F4825AFF", "#D2204CFF", "#771F59FF"),
  combined = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hyperframe_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_col">col</code></td>
<td>
<p>the name/s of a column of interest.
To specify multiple columns, users should list column names as a character vector.</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_time_col">time_col</code></td>
<td>
<p>The name of the column of time variable. By default, '&quot;time&quot;'. Note that the time variable must be integers.</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_range">range</code></td>
<td>
<p>vector that specifies the range of tiem variable (e.g., 'c(&quot;2007-01-01&quot;, &quot;2007-01-31&quot;)')</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_lim">lim</code></td>
<td>
<p>limits of the scale. By default, NA. To set limits manually, provide a vector or max and min</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_scalename">scalename</code></td>
<td>
<p>the name of the scale (for images only)</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_color">color</code></td>
<td>
<p>the color scale. By default, &quot;white&quot;, &quot;#F8DAC5FF&quot;, &quot;#F4825AFF&quot;, &quot;#D2204CFF&quot;, and &quot;#771F59FF&quot;.</p>
</td></tr>
<tr><td><code id="plot.hyperframe_+3A_combined">combined</code></td>
<td>
<p>logical. 'combined' specifies whether to combine all the point processes to one plot.
This argument applies only to the case when users specify one column with multiple time periods.
By default = TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='plot.im'>Plot im</h2><span id='topic+plot.im'></span>

<h3>Description</h3>

<p>Plot im
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
plot(
  x,
  ...,
  main = "Image object",
  scalename = "Density",
  grayscale = "FALSE",
  color = c("white", "#F8DAC5FF", "#F4825AFF", "#D2204CFF", "#771F59FF"),
  lim = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.im_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.im_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.im_+3A_main">main</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id="plot.im_+3A_scalename">scalename</code></td>
<td>
<p>the name of the scale (for images only)</p>
</td></tr>
<tr><td><code id="plot.im_+3A_grayscale">grayscale</code></td>
<td>
<p>whether to use grayscale. By default, FALSE.</p>
</td></tr>
<tr><td><code id="plot.im_+3A_color">color</code></td>
<td>
<p>the color scale. By default, &quot;white&quot;, &quot;#F8DAC5FF&quot;, &quot;#F4825AFF&quot;, &quot;#D2204CFF&quot;, and &quot;#771F59FF&quot;.</p>
</td></tr>
<tr><td><code id="plot.im_+3A_lim">lim</code></td>
<td>
<p>limits of the scale. By default, NA. To set limits manually, provide a vector or max and min</p>
</td></tr>
</table>

<hr>
<h2 id='plot.obs'>Plot observed densities</h2><span id='topic+plot.obs'></span>

<h3>Description</h3>

<p>Plot observed densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'obs'
plot(x, ..., dens_2 = NA, dens_3 = NA, actual_data = NA, time_unit = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.obs_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="plot.obs_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
<tr><td><code id="plot.obs_+3A_dens_2">dens_2</code></td>
<td>
<p>density 2 (if any). By default, 'NA'.</p>
</td></tr>
<tr><td><code id="plot.obs_+3A_dens_3">dens_3</code></td>
<td>
<p>density 3 (if any). By default, 'NA'.</p>
</td></tr>
<tr><td><code id="plot.obs_+3A_actual_data">actual_data</code></td>
<td>
<p>actual data in the form of 'hyperframe$column'.</p>
</td></tr>
<tr><td><code id="plot.obs_+3A_time_unit">time_unit</code></td>
<td>
<p>x-axis label of the output</p>
</td></tr>
</table>

<hr>
<h2 id='predict_obs_dens'>Perform out-of-sample prediction</h2><span id='topic+predict_obs_dens'></span>

<h3>Description</h3>

<p>'predict_obs_dens()' performs out-of-sample prediction
(separating data into training and test sets).
It assumes that training and test sets have the same window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_obs_dens(hfr, ratio, dep_var, indep_var, ngrid = 100, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_obs_dens_+3A_hfr">hfr</code></td>
<td>
<p>hyperframe</p>
</td></tr>
<tr><td><code id="predict_obs_dens_+3A_ratio">ratio</code></td>
<td>
<p>numeric. ratio between training and test sets</p>
</td></tr>
<tr><td><code id="predict_obs_dens_+3A_dep_var">dep_var</code></td>
<td>
<p>dependent variables</p>
</td></tr>
<tr><td><code id="predict_obs_dens_+3A_indep_var">indep_var</code></td>
<td>
<p>independent variables</p>
</td></tr>
<tr><td><code id="predict_obs_dens_+3A_ngrid">ngrid</code></td>
<td>
<p>the number of grids. By default, '100'.</p>
</td></tr>
<tr><td><code id="predict_obs_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of the following:
* 'indep_var': independent variables
* 'coef': coefficients
* 'intens_grid_cells': im object of observed densities for each time period
* 'estimated_counts': the number of events that is estimated by the poisson point process model for each time period
* 'sum_log_intens': the sum of log intensities for each time period
* 'training_row_max': the max row ID of the training set
</p>

<hr>
<h2 id='sim_cf_dens'>Simulate counterfactual densities</h2><span id='topic+sim_cf_dens'></span>

<h3>Description</h3>

<p>'sim_cf_dens()' takes a list of power densities
and returns simulated counterfactual densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_cf_dens(
  expected_number,
  base_dens,
  power_sim_results,
  window,
  grayscale = FALSE,
  color = c("white", "#F8DAC5FF", "#F4825AFF", "#D2204CFF", "#771F59FF")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_cf_dens_+3A_expected_number">expected_number</code></td>
<td>
<p>the expected number of observations</p>
</td></tr>
<tr><td><code id="sim_cf_dens_+3A_base_dens">base_dens</code></td>
<td>
<p>the baseline density (im object)</p>
</td></tr>
<tr><td><code id="sim_cf_dens_+3A_power_sim_results">power_sim_results</code></td>
<td>
<p>the results obtained by 'simulate_power_density()'</p>
</td></tr>
<tr><td><code id="sim_cf_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
<tr><td><code id="sim_cf_dens_+3A_grayscale">grayscale</code></td>
<td>
<p>logical. 'grayscale' specifies whether to convert plot to grayscale (by default, FALSE).</p>
</td></tr>
<tr><td><code id="sim_cf_dens_+3A_color">color</code></td>
<td>
<p>the color scale. By default, &quot;white&quot;, &quot;#F8DAC5FF&quot;, &quot;#F4825AFF&quot;, &quot;#D2204CFF&quot;, and &quot;#771F59FF&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of counterfactual densities, a ggplot, and priorities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Baseline density
baseline &lt;- get_base_dens(option = "out",
                          out_data = airstrikes_base,
                          out_coordinates = c("longitude", "latitude"),
                          window = iraq_window,
                          ndim = 64)

# Density 1: Distance from Mosul
dist_from_mosul &lt;- get_dist_focus(window = iraq_window,
                                  lon = c(43.158),
                                  lat = c(36.349),
                                  resolution = 0.5,
                                  mile = FALSE,
                                  preprocess = FALSE)

# Density 2: Distance from Baghdad
dist_from_baghd &lt;- get_dist_focus(window = iraq_window,
                                  lon = c(44.366),
                                  lat = c(33.315),
                                  resolution = 0.5,
                                  mile = FALSE,
                                  preprocess = FALSE)

# Simulation of power density
sim_power_mosul &lt;- sim_power_dens(target_dens = list(dist_from_baghd),
                                  dens_manip = dist_from_mosul,
                                  priorities = 1,
                                  priorities_manip = c(1, 2, 5, 10, 15, 50),
                                  window = iraq_window,
                                  grayscale = FALSE)

# Simulation of counterfactual density
sim_cf_dens(expected_number = 3,
            base_dens = baseline,
            power_sim_results = sim_power_mosul,
            window = iraq_window,
            grayscale = FALSE)
</code></pre>

<hr>
<h2 id='sim_power_dens'>Simulate power densities</h2><span id='topic+sim_power_dens'></span>

<h3>Description</h3>

<p>A function that takes the target densities and their priorities
and returns a power density image over a range of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_power_dens(
  target_dens,
  dens_manip,
  priorities,
  priorities_manip,
  window,
  color = c("white", "#F8DAC5FF", "#F4825AFF", "#D2204CFF", "#771F59FF"),
  grayscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_power_dens_+3A_target_dens">target_dens</code></td>
<td>
<p>list of target densities. This should always be a list, even if there is only one target density.</p>
</td></tr>
<tr><td><code id="sim_power_dens_+3A_dens_manip">dens_manip</code></td>
<td>
<p>a target density for which we manipulate the value of priorities</p>
</td></tr>
<tr><td><code id="sim_power_dens_+3A_priorities">priorities</code></td>
<td>
<p>numeric. 'priorities' specifies the priority for the target density that we do not manipulate.</p>
</td></tr>
<tr><td><code id="sim_power_dens_+3A_priorities_manip">priorities_manip</code></td>
<td>
<p>vector of priorities for the density that we manipulate.</p>
</td></tr>
<tr><td><code id="sim_power_dens_+3A_window">window</code></td>
<td>
<p>owin object</p>
</td></tr>
<tr><td><code id="sim_power_dens_+3A_color">color</code></td>
<td>
<p>the color scale. By default, &quot;white&quot;, &quot;#F8DAC5FF&quot;, &quot;#F4825AFF&quot;, &quot;#D2204CFF&quot;, and &quot;#771F59FF&quot;.</p>
</td></tr>
<tr><td><code id="sim_power_dens_+3A_grayscale">grayscale</code></td>
<td>
<p>logical. 'grayscale' specifies whether to convert plot to grayscale (by default, FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of densities, plot, and priorities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Density 1: Distance from Mosul
dist_from_mosul &lt;- get_dist_focus(window = iraq_window,
                                  lon = c(43.158),
                                  lat = c(36.349),
                                  resolution = 0.5,
                                  mile = FALSE,
                                  preprocess = FALSE)

# Density 2: Distance from Baghdad
dist_from_baghd &lt;- get_dist_focus(window = iraq_window,
                                  lon = c(44.366),
                                  lat = c(33.315),
                                  resolution = 0.5,
                                  mile = FALSE,
                                  preprocess = FALSE)

# Simulation
sim_power_dens(target_dens = list(dist_from_baghd),
               dens_manip = dist_from_mosul,
               priorities = 1,
               priorities_manip = c(1, 2, 5, 10, 15, 50),
               window = iraq_window,
               grayscale = FALSE)
</code></pre>

<hr>
<h2 id='smooth_ppp'>Smooth outcome events</h2><span id='topic+smooth_ppp'></span>

<h3>Description</h3>

<p>'smooth_ppp()' takes a column of hyperframes (ppp objects) and smoothes them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_ppp(data, method, sampling = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_ppp_+3A_data">data</code></td>
<td>
<p>the name of a hyperframe and column of interest.
'data' should be in the form of '&quot;hyperframe$column&quot;'.</p>
</td></tr>
<tr><td><code id="smooth_ppp_+3A_method">method</code></td>
<td>
<p>methods for smoothing ppp objects.
Either '&quot;mclust&quot;' or '&quot;abramson&quot;'. See details.</p>
</td></tr>
<tr><td><code id="smooth_ppp_+3A_sampling">sampling</code></td>
<td>
<p>numeric between 0 and 1. 'sampling' determines the proportion of data
to use for initialization. By default, NA (meaning that it uses all data without sampling).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To smooth ppp objects, users can choose either the Gaussian mixture model ('method = &quot;mclust&quot;')
or Abramson's adaptive smoothing ('method = &quot;abramson&quot;').
The Gaussian mixture model is essentially the method that performs model-based clustering of all the observed points.
In this package, we employ the EII model (equal volume, round shape (spherical covariance)).
This means that we model observed points by several Gaussian densities with the same, round shape.
This is why this model is called fixed-bandwidth smoothing. This is a simple model to smooth observed points,
yet given that analyzing spatiotemporal data is often computationally demanding, it is often the best place to start (and end).
Sometimes this process can also take time, which is why an option for 'init' is included in this function.
</p>
<p>Another, more precise, method for smoothing outcomes is adaptive smoothing ('method = &quot;abram&quot;').
This method allows users to vary bandwidths based on 'Abramson (1982)'.
Essentially, this model assumes that the bandwidth is inversely proportional to the square root of the target densities.
Since the bandwidth is adaptive, the estimation is usually more precise than the Gaussian mixture model.
However, the caveat is that this method is often extremely computationally demanding.
</p>


<h3>Value</h3>

<p>im objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Time variable
dat_out &lt;- insurgencies[1:100, ]
dat_out$time &lt;- as.numeric(dat_out$date - min(dat_out$date) + 1)

# Hyperframe
dat_hfr &lt;- get_hfr(data = dat_out,
                   col = "type",
                   window = iraq_window,
                   time_col = "time",
                   time_range = c(1, max(dat_out$time)),
                   coordinates = c("longitude", "latitude"),
                   combine = TRUE)

# Smoothing outcome
smooth_ppp(data = dat_hfr$all_combined,
           method = "mclust",
           sampling = 0.05)
</code></pre>

<hr>
<h2 id='summary.est'>Summarize results</h2><span id='topic+summary.est'></span>

<h3>Description</h3>

<p>'summary' functions take the output and summarize it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'est'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.est_+3A_object">object</code></td>
<td>
<p>an output object</p>
</td></tr>
<tr><td><code id="summary.est_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, observed densities (class: obs) and estimates (class: est) are supported by this function.
</p>

<hr>
<h2 id='summary.obs'>Summarize results</h2><span id='topic+summary.obs'></span>

<h3>Description</h3>

<p>'summary' functions take the output and summarize it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'obs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.obs_+3A_object">object</code></td>
<td>
<p>an output object</p>
</td></tr>
<tr><td><code id="summary.obs_+3A_...">...</code></td>
<td>
<p>arguments passed on to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, observed densities (class: obs) and estimates (class: est) are supported by this function.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
