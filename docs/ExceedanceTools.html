<!DOCTYPE html><html><head><title>Help for package ExceedanceTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ExceedanceTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#colorado'><p>Colorado precipitation data</p></a></li>
<li><a href='#confreg'><p>Construct confidence regions for exceedance (excursion) sets.</p></a></li>
<li><a href='#create.pgrid'><p>Create grid of locations.</p></a></li>
<li><a href='#create.pgrid2'><p>Create grid of locations.</p></a></li>
<li><a href='#exceedance.ci'><p>Return confidence region</p></a></li>
<li><a href='#ExceedanceTools'><p>ExceedanceTools.</p></a></li>
<li><a href='#plot.pgrid'><p>Plots <code>pgrid</code> object.</p></a></li>
<li><a href='#sdata'><p>Synthetic data</p></a></li>
<li><a href='#statistic.cv'><p>Return critical value of distribution.</p></a></li>
<li><a href='#statistic.sim'><p>Simulates statistics related to exceedance region.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Confidence/Credible Regions for Exceedance Sets and Contour
Lines</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua French</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua French &lt;joshua.french@ucdenver.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for constructing confidence or credible regions
    for exceedance sets and contour lines.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.12.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>splancs, SpatialTools, matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spBayes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 15:54:21 UTC; frencjos</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='colorado'>Colorado precipitation data</h2><span id='topic+colorado'></span>

<h3>Description</h3>

<p>Data related to Colorado precipitation in
May 1997. Taken from
<a href="https://www.image.ucar.edu/Data/US.monthly.met/">https://www.image.ucar.edu/Data/US.monthly.met/</a>.
Data is contained in a list with components
<code>odata</code> (containing a transformed precipitation
variable) and <code>ocoords</code> containing the longitude
and latitude of the associated sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(colorado)
</code></pre>


<h3>Format</h3>

<p>A list.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Source</h3>

<p>National Center for Atmospheric Research
</p>

<hr>
<h2 id='confreg'>Construct confidence regions for exceedance (excursion) sets.</h2><span id='topic+confreg'></span>

<h3>Description</h3>

<p><code>confreg</code> constructs confidence regions for the exceedance (excursions) sets of geostatistical processes.  These will actually be credible regions if <code>obj</code> contains samples from the joint posterior predictive distribution in a Bayesian setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confreg(
  obj,
  level,
  statistic = NULL,
  conf.level = 0.95,
  direction = "&gt;",
  type = "o",
  method = "test",
  greedy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confreg_+3A_obj">obj</code></td>
<td>
<p>An object of the appropriate type (<code>matrix</code>, <code>krigeConditionalSample</code>, or <code>jointPredictiveSample</code>.  See Details.</p>
</td></tr>
<tr><td><code id="confreg_+3A_level">level</code></td>
<td>
<p>The threshold level for the exceedance region.</p>
</td></tr>
<tr><td><code id="confreg_+3A_statistic">statistic</code></td>
<td>
<p>The statistic used in constructing the confidence region.  Should be a vector containing a value for each location</p>
</td></tr>
<tr><td><code id="confreg_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level of the confidence region.  Default is 0.95.</p>
</td></tr>
<tr><td><code id="confreg_+3A_direction">direction</code></td>
<td>
<p>The direction of the exceedance region.  <code>"&gt;"</code> indicates the exceedance region is values above a threshold, while <code>"&lt;"</code> indicates values below a threshold.</p>
</td></tr>
<tr><td><code id="confreg_+3A_type">type</code></td>
<td>
<p><code>"o"</code> indicates on outer confidence region while <code>"i"</code> indicates in inner confidence region.</p>
</td></tr>
<tr><td><code id="confreg_+3A_method">method</code></td>
<td>
<p><code>"test"</code> indicates a testing-based method, while <code>"direct"</code> indicates a direct method using joint probabilities.</p>
</td></tr>
<tr><td><code id="confreg_+3A_greedy">greedy</code></td>
<td>
<p>Only applicable for the direct construction method.  Default is <code>FALSE</code>.  If <code>TRUE</code>, then grid cells are added to the confidence region using a greedy algorithm based on joint probability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>obj</code> can be an object of class <code>matrix</code>,  <code>krigeConditionalSample</code>, or <code>jointPredictiveSample</code>.  If <code>obj</code> is a <code>matrix</code>, then it should have <code>m</code> rows and <code>nsim</code> columns.  In that case, each row of <code>obj</code> corresponds to a sample from the conditional distribution of the response conditional on the observed data.  Each row represents a different location.  Generally, these locations are assumed to be on a grid spanning the spatial domain of interest.  A <code>krigeConditionalSample</code> object can be obtained using the <code>krige.sk</code>, <code>krige.ok</code>, 
or <code>krige.uk</code> functions in the <code>SpatialTools</code> package.  In these functions, the <code>nsim</code> argument must be greater than 0, and indicates the number of samples used to construct the confidence region.  A <code>jointPredictiveSample</code> object can be obtained using the <code>spLMPredictJoint</code> function in the <code>SpatialTools</code> package.  Since this is in the context of Bayesian statistics, the function actually produces credible region.  
</p>
<p>If <code>statistic</code> is supplied for the direct construction procedure, then the locations are ordered by marginal probability and then the statistic.  <code>statistic</code> should be a vector of length <code>m</code>, where <code>m</code> is the number of prediction locations at which samples were drawn for in <code>obj</code>.
</p>
<p>If type == <code>"o"</code>, then an outer credible region is constructed.  The outer credible region should entirely contain the true exceedanace region with the specified posterior probability.  If type == <code>"i"</code>, then an inner credible region is constructed.  The inner confidence region should be entirely contained within the true exceedanace region with specified posterior probability.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>confreg</code> with the following components: 
</p>
<table>
<tr><td><code>confidence</code></td>
<td>
<p>The sites included in the confidence region.</p>
</td></tr>
<tr><td><code>complement</code></td>
<td>
<p>The complement of the confidence region.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Joshua P. French and Stephan R. Sain (2013).
Spatio-temporal exceedance locations and confidence
regions.  Annals of Applied Statistics.  7(3):1421-1449.
</p>
<p>French, J. P. (2014), Confidence regions for the level
curves of spatial data, Environmetrics, 25, pages
498–512, DOI: 10.1002/env.2295
</p>
<p>French, J. P., and Hoeting, J. A. (2016) Credible regions
for exceedance sets of geostatistical data.
Environmetrics, 27: 4–14. doi: 10.1002/env.2371.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set parameters
n &lt;- 100
mygrid = create.pgrid(0, 1, 0, 1, nx = 5, ny = 4)
n.samples &lt;- 10
burnin.start &lt;- 1
sigmasq &lt;- 1
tausq &lt;- 0.0
phi &lt;- 1
cov.model &lt;- "exponential"
n.report &lt;- 5

# Generate coordinates
coords &lt;- matrix(runif(2 * n), ncol = 2) 
pcoords &lt;- mygrid$pgrid
# Construct design matrices
X &lt;- as.matrix(cbind(1, coords))
Xp &lt;- cbind(1, pcoords)

# Specify priors
starting &lt;- list("phi" = phi, "sigma.sq"= sigmasq, "tau.sq" = tausq)
tuning &lt;- list("phi"=0.1, "sigma.sq"=0.1, "tau.sq"=0.1)
priors.1 &lt;- list("beta.Norm"=list(c(1, 2, 1), diag(100, 3)), "phi.Unif"=c(0.00001, 10), 
 "sigma.sq.IG"=c(1, 1))

# Generate data
library(SpatialTools)
B &lt;- rnorm(3, c(1, 2, 1), sd = 10)
phi &lt;- runif(1, 0, 10)
sigmasq &lt;- 1/rgamma(1, 1, 1)
V &lt;- simple.cov.sp(D = dist1(coords), cov.model, c(sigmasq, 1/phi), error.var = tausq, 
 smoothness = nu, finescale.var = 0)
y &lt;- X %*% B + rmvnorm(1, rep(0, n), V) + rnorm(n, 0, sqrt(tausq))

# Create spLM object
library(spBayes)
m1 &lt;- spBayes::spLM(y ~ X - 1, coords = coords, starting = starting, tuning = tuning, 
 priors = priors.1, cov.model = cov.model, n.samples = n.samples, verbose = FALSE,
 n.report = n.report)

# Sample from joint posterior predictive distribution
y1 &lt;- spLMPredictJoint(m1, pred.coords = pcoords, pred.covars = Xp, 
 start = burnin.start, verbose = FALSE, method = "chol")
 u = quantile(y, .5)
myfun = function(x)
{
    (mean(x) - u)/sd(x)
}

myfun2 = function(x)
{
 mean(x &gt; u)
}

stat1 = apply(y1, 1, myfun)
stat2 = apply(y1, 1, myfun2)

myconf = confreg(y1, level = u, statistic = NULL, direction = "&gt;", type = "o", method = "direct")
myconf2 = confreg(y1, level = u, statistic = stat1, direction = "&gt;", type = "o")
myconf3 = confreg(y1, level = u, statistic = stat2, direction = "&gt;", type = "o")
</code></pre>

<hr>
<h2 id='create.pgrid'>Create grid of locations.</h2><span id='topic+create.pgrid'></span>

<h3>Description</h3>

<p><code>create.pgrid</code> creates a grid of locations from the boundaries of domain and other information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.pgrid(
  xmin,
  xmax,
  ymin,
  ymax,
  nx,
  ny,
  midpoints = FALSE,
  poly.coords = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.pgrid_+3A_xmin">xmin</code></td>
<td>
<p>The minimum value of the boundary of the x coordinates of the spatial domain.</p>
</td></tr>
<tr><td><code id="create.pgrid_+3A_xmax">xmax</code></td>
<td>
<p>The maximum value of the boundary of the x coordinates of the spatial domain.</p>
</td></tr>
<tr><td><code id="create.pgrid_+3A_ymin">ymin</code></td>
<td>
<p>The minimum value of the boundary of the y coordinates of the spatial domain.</p>
</td></tr>
<tr><td><code id="create.pgrid_+3A_ymax">ymax</code></td>
<td>
<p>The maximum value of the boundary of the y coordinates of the spatial domain.</p>
</td></tr>
<tr><td><code id="create.pgrid_+3A_nx">nx</code></td>
<td>
<p>The number of gridpoints/cells/pixels in the x direction.</p>
</td></tr>
<tr><td><code id="create.pgrid_+3A_ny">ny</code></td>
<td>
<p>The number of gridpoints/cells/pixels in the y direction.</p>
</td></tr>
<tr><td><code id="create.pgrid_+3A_midpoints">midpoints</code></td>
<td>
<p>A logical value (<code>TRUE</code> or <code>FALSE</code>) indicating whether the boundary values are for the midpoint of a pixel (<code>midpoints = TRUE</code>) or for the boundary of the spatial domain in general (<code>midpoints = FALSE</code>), in which case the midpoints are calculated internally). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="create.pgrid_+3A_poly.coords">poly.coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix with the coordinates specifying the polygon vertices of the true spatial domain of interest within the rectangular boundaries provided by <code>xmin</code>, <code>xmax</code>, <code>ymin</code>, and <code>ymax</code>. If this is provided, the <code>pgrid</code> returned will be within the convex hull of <code>poly.coords</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key argument in the function midpoints. If this is <code>TRUE</code>, it is assumed that the boundaries of the spatial domain correspond to the midpoints of the cell/pixel in the grid. Otherwise, it is assumed that the boundaries correspond to the actual borders of the region of interest. If <code>poly.coords</code> is supplied, the grid returned is the grid of midpoints contained in the convex hull of <code>poly.coords</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>pgrid</code> with the following components: 
</p>
<table>
<tr><td><code>pgrid</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of locations (the midpoints of the pixelized grid).</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The number of rows in pgrid.</p>
</td></tr>
<tr><td><code>p.in.grid</code></td>
<td>
<p>A vector of 0s and 1s indicating whether the midpoint of each pixel is in the convex hull of <code>poly.coords</code>. If <code>poly.coords</code> is not provided, this is a vector of 1s.</p>
</td></tr>
<tr><td><code>ubx</code></td>
<td>
<p>The pixel boundaries in the x direction.</p>
</td></tr>
<tr><td><code>uby</code></td>
<td>
<p>The pixel boundaries in the y direction.</p>
</td></tr>
<tr><td><code>upx</code></td>
<td>
<p>The pixel midpoints in the x direction.</p>
</td></tr>
<tr><td><code>upy</code></td>
<td>
<p>The pixel midpoints in the y direction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pgrida &lt;- create.pgrid(0, 1, 0, 1, nx = 50, ny = 50, midpoints = FALSE)
pgridb &lt;- create.pgrid(.01, .99, .01, .99, nx = 50, ny = 50, midpoints = TRUE)
</code></pre>

<hr>
<h2 id='create.pgrid2'>Create grid of locations.</h2><span id='topic+create.pgrid2'></span>

<h3>Description</h3>

<p><code>create.pgrid2</code> creates a grid of locations fusing vectors of x and y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.pgrid2(xgrid, ygrid, midpoints = FALSE, poly.coords = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.pgrid2_+3A_xgrid">xgrid</code></td>
<td>
<p>A vector of locations in the x direction.</p>
</td></tr>
<tr><td><code id="create.pgrid2_+3A_ygrid">ygrid</code></td>
<td>
<p>A vector of location in the y direction.</p>
</td></tr>
<tr><td><code id="create.pgrid2_+3A_midpoints">midpoints</code></td>
<td>
<p>A logical value (<code>TRUE</code> or <code>FALSE</code>) indicating whether the boundary values are for the midpoint of a pixel (<code>midpoints = TRUE</code>) or for the boundary of the spatial domain in general (<code>midpoints = FALSE</code>, in which case the midpoints are calculated internally). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="create.pgrid2_+3A_poly.coords">poly.coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix with the coordinates specifying the polygon vertices of the true spatial domain of interest within the rectangular boundaries provided by <code>xmin</code>, <code>xmax</code>, <code>ymin</code>, and <code>ymax</code>. If this is provided, the <code>pgrid</code> returned will be within the convex hull of <code>poly.coords</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key argument in the function midpoints. If this is <code>TRUE</code>, it is assumed that the boundaries of the spatial domain correspond to the midpoints of the cell/pixel in the grid. Otherwise, it is assumed that the boundaries correspond to the actual borders of the region of interest. If <code>poly.coords</code> is supplied, the grid returned is the grid of midpoints contained in the convex hull of <code>poly.coords</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class pgrid with the following components: 
</p>
<table>
<tr><td><code>pgrid</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of locations (the midpoints of the pixelized grid).</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The number of rows in pgrid.</p>
</td></tr>
<tr><td><code>p.in.grid</code></td>
<td>
<p>A vector of 0s and 1s indicating whether the midpoint of each pixel is in the convex hull of <code>poly.coords</code>. If <code>poly.coords</code> is not provided, this is a vector of 1s.</p>
</td></tr>
<tr><td><code>ubx</code></td>
<td>
<p>The pixel boundaries in the x-direction.</p>
</td></tr>
<tr><td><code>uby</code></td>
<td>
<p>The pixel boundaries in the y-direction.</p>
</td></tr>
<tr><td><code>upx</code></td>
<td>
<p>The pixel midpoints in the x-direction.</p>
</td></tr>
<tr><td><code>upy</code></td>
<td>
<p>The pixel midpoints in the y-direction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq1 = seq(0, 1, len = 101)
pgrida &lt;- create.pgrid2(seq1, seq1, midpoint = FALSE)
seq2 = seq(.005, .995, len = 100)
pgridb &lt;- create.pgrid2(seq2, seq2, midpoint = TRUE)
# pgrids produced match
range(pgrida$pgrid - pgridb$pgrid)
</code></pre>

<hr>
<h2 id='exceedance.ci'>Return confidence region</h2><span id='topic+exceedance.ci'></span>

<h3>Description</h3>

<p><code>exceedance.ci</code> returns a confidence set for an exceedance region or contour line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exceedance.ci(statistic.sim.obj, conf.level = 0.95, type = "null")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exceedance.ci_+3A_statistic.sim.obj">statistic.sim.obj</code></td>
<td>
<p>An object returned from the <code>statistic.sim</code> function.</p>
</td></tr>
<tr><td><code id="exceedance.ci_+3A_conf.level">conf.level</code></td>
<td>
<p>The desired confidence level of the confidence region.</p>
</td></tr>
<tr><td><code id="exceedance.ci_+3A_type">type</code></td>
<td>
<p>Whether the function should return the null region or rejection region of exceedance confidence region  Options are <code>"null"</code> or <code>"rejection"</code>.  Default is <code>"null"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector with the set of pixels comprising the null or rejection region related to <code>statistic.sim.obj</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SpatialTools)

# Example for exceedance regions

set.seed(10)
# Load data
data(sdata)
# Create prediction grid
pgrid &lt;- create.pgrid(0, 1, 0, 1, nx = 26, ny = 26)
pcoords &lt;- pgrid$pgrid
# Create design matrices
coords = cbind(sdata$x1, sdata$x2)
X &lt;- cbind(1, coords)
Xp &lt;- cbind(1, pcoords)

# Generate covariance matrices V, Vp, Vop using appropriate parameters for 
# observed data and responses to be predicted
spcov &lt;- cov.sp(coords = coords, sp.type = "exponential", 
 sp.par = c(1, 1.5), error.var = 1/3, finescale.var = 0, pcoords = pcoords)

# Predict responses at pgrid locations
krige.obj &lt;- krige.uk(y = as.vector(sdata$y), V = spcov$V, Vp = spcov$Vp, 
 Vop = spcov$Vop, X = X, Xp = Xp, nsim = 100, 
 Ve.diag = rep(1/3, length(sdata$y)) , method = "chol")
                
# Simulate distribution of test statistic for different alternatives
statistic.sim.obj.less &lt;- statistic.sim(krige.obj = krige.obj, level = 5, 
 alternative = "less")
statistic.sim.obj.greater &lt;- statistic.sim(krige.obj = krige.obj, level = 5,
 alternative = "greater")
# Construct null and rejection sets for two scenarios
n90 &lt;- exceedance.ci(statistic.sim.obj.less, conf.level = .90, type = "null")
r90 &lt;- exceedance.ci(statistic.sim.obj.greater,conf.level = .90, type = "rejection")       
# Plot results
plot(pgrid, n90, col="blue", add = FALSE, xlab = "x", ylab = "y")
plot(pgrid, r90, col="orange", add = TRUE)
legend("bottomleft", 
 legend = c("contains true exceedance region with 90 percent confidence", 
   "is contained in true exceedance region with 90 percent confidence"),
   col = c("blue", "orange"), lwd = 10)  
</code></pre>

<hr>
<h2 id='ExceedanceTools'>ExceedanceTools.</h2><span id='topic+ExceedanceTools'></span><span id='topic+ExceedanceTools-package'></span>

<h3>Description</h3>

<p>A package to create confidence or credible regions for
the exceedance regions/excursion sets of spatial data.
</p>

<hr>
<h2 id='plot.pgrid'>Plots <code>pgrid</code> object.</h2><span id='topic+plot.pgrid'></span>

<h3>Description</h3>

<p><code>plot.pgrid</code> plots a grid of pixels based on a <code>pgrid</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pgrid'
plot(x, set, col = "gray", add = FALSE, type = "confidence", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pgrid_+3A_x">x</code></td>
<td>
<p>An <code>pgrid</code> object returned from the <code>pgrid</code> function.</p>
</td></tr>
<tr><td><code id="plot.pgrid_+3A_set">set</code></td>
<td>
<p>A vector which contains the indices of the pixels/cells that should be plotted.  OR a <code>confreg</code> object from the <code>confreg</code> function.  See Details.</p>
</td></tr>
<tr><td><code id="plot.pgrid_+3A_col">col</code></td>
<td>
<p>The color of the plotted pixels.</p>
</td></tr>
<tr><td><code id="plot.pgrid_+3A_add">add</code></td>
<td>
<p>A logical value indicating whether the pixels should be added to an existing plot (<code>add = TRUE</code>) or should the pixels be plotted on a new plot (<code>add = FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.pgrid_+3A_type">type</code></td>
<td>
<p>The type of set of plot if <code>set</code> of of class <code>confreg</code>.  The default is <code>"confidence"</code>, while the other option is <code>complement</code>, based on the components of the <code>confreg</code> object.</p>
</td></tr>
<tr><td><code id="plot.pgrid_+3A_...">...</code></td>
<td>
<p>Additional arguments that will be passed to the <code>image</code> function (assuming <code>add=FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a vector of pixel indices is supplied to <code>set</code>, then those pixels will be colored <code>col</code> by this function and the <code>type</code> argument has no effect.  On the other hand, if the <code>set</code> argument is of class <code>confreg</code>, then the function digs in to display either the <code>confidence</code> or <code>complement</code> set in the <code>confreg</code> object.  In that case, <code>type</code> is used to decide which set to display.
</p>


<h3>Value</h3>

<p>This function does not return anything; it only creates a new plot or modifies an existing plot.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SpatialTools)

# Example for exceedance regions

set.seed(10)
# Load data
data(sdata)
# Create prediction grid
pgrid &lt;- create.pgrid(0, 1, 0, 1, nx = 26, ny = 26)
pcoords &lt;- pgrid$pgrid
# Create design matrices
coords = cbind(sdata$x1, sdata$x2)
X &lt;- cbind(1, coords)
Xp &lt;- cbind(1, pcoords)

# Generate covariance matrices V, Vp, Vop using appropriate parameters for 
# observed data and responses to be predicted
spcov &lt;- cov.sp(coords = coords, sp.type = "exponential", 
 sp.par = c(1, 1.5), error.var = 1/3, finescale.var = 0, pcoords = pcoords)

# Predict responses at pgrid locations
krige.obj &lt;- krige.uk(y = as.vector(sdata$y), V = spcov$V, Vp = spcov$Vp, 
 Vop = spcov$Vop, X = X, Xp = Xp, nsim = 100, 
 Ve.diag = rep(1/3, length(sdata$y)) , method = "chol")
                
# Simulate distribution of test statistic for different alternatives
statistic.sim.obj.less &lt;- statistic.sim(krige.obj = krige.obj, level = 5, 
 alternative = "less")
statistic.sim.obj.greater &lt;- statistic.sim(krige.obj = krige.obj, 
 level = 5, alternative = "greater")
# Construct null and rejection sets for two scenarios
n90 &lt;- exceedance.ci(statistic.sim.obj.less, conf.level = .90, 
 type = "null")
r90 &lt;- exceedance.ci(statistic.sim.obj.greater,conf.level = .90, 
 type = "rejection")       
# Plot results
plot(pgrid, n90, col="blue", add = FALSE, xlab = "x", ylab = "y")
plot(pgrid, r90, col="orange", add = TRUE)
legend("bottomleft", 
 legend = c("contains true exceedance region with 90 percent confidence", 
 "is contained in true exceedance region with 90 percent confidence"),
 col = c("blue", "orange"), lwd = 10)  
</code></pre>

<hr>
<h2 id='sdata'>Synthetic data</h2><span id='topic+sdata'></span>

<h3>Description</h3>

<p>A synthetic data set for use in examples. A 100x3 data frame with vectors <code>x1</code> and <code>x2</code> (specifying spatial location) and <code>y</code>, the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sdata)
</code></pre>


<h3>Format</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>

<hr>
<h2 id='statistic.cv'>Return critical value of distribution.</h2><span id='topic+statistic.cv'></span>

<h3>Description</h3>

<p><code>statistic.cv</code> returns the critical value of the distribution of the test statistics from <code>statistic.sim</code> based on the specified confidence level. However, it is not recommended for general usage.  It is recommedned that the <code>exceedance.ci</code> function be used to automatically create confidence regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statistic.cv(statistic.sim.obj, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statistic.cv_+3A_statistic.sim.obj">statistic.sim.obj</code></td>
<td>
<p>An object returned from the <code>statistic.sim</code> function.</p>
</td></tr>
<tr><td><code id="statistic.cv_+3A_conf.level">conf.level</code></td>
<td>
<p>The desired confidence level of the confidence interval we want to construct.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the desired critical value.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SpatialTools)

# Example for exceedance regions

set.seed(10)
# Load data
data(sdata)
# Create prediction grid
pgrid &lt;- create.pgrid(0, 1, 0, 1, nx = 26, ny = 26)
pcoords &lt;- pgrid$pgrid
# Create design matrices
coords = cbind(sdata$x1, sdata$x2)
X &lt;- cbind(1, coords)
Xp &lt;- cbind(1, pcoords)

# Generate covariance matrices V, Vp, Vop using appropriate parameters for 
# observed data and responses to be predicted
spcov &lt;- cov.sp(coords = coords, sp.type = "exponential", sp.par = c(1, 1.5),
 error.var = 1/3, finescale.var = 0, pcoords = pcoords)

# Predict responses at pgrid locations
krige.obj &lt;- krige.uk(y = as.vector(sdata$y), V = spcov$V, Vp = spcov$Vp, 
 Vop = spcov$Vop, X = X, Xp = Xp, nsim = 100, 
 Ve.diag = rep(1/3, length(sdata$y)) , method = "chol")
                
# Simulate distribution of test statistic for different alternatives
statistic.sim.obj.less &lt;- statistic.sim(krige.obj = krige.obj, level = 5, 
 alternative = "less")
statistic.sim.obj.greater &lt;- statistic.sim(krige.obj = krige.obj, level = 5,
 alternative = "greater")
# Calculate quantiles of distribution of statistic
q90.less &lt;- statistic.cv(statistic.sim.obj.less, conf.level = .90)
q90.greater &lt;- statistic.cv(statistic.sim.obj.greater, conf.level = .90)
</code></pre>

<hr>
<h2 id='statistic.sim'>Simulates statistics related to exceedance region.</h2><span id='topic+statistic.sim'></span>

<h3>Description</h3>

<p><code>statistic.sim</code> simulates statistics related to the construction of confidence regions for exceedance sets and contour lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statistic.sim(krige.obj, level, alternative = "less", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statistic.sim_+3A_krige.obj">krige.obj</code></td>
<td>
<p>An object from the function <code>krige.uk</code> in the <code>SpatialTools</code> package.</p>
</td></tr>
<tr><td><code id="statistic.sim_+3A_level">level</code></td>
<td>
<p>The threshold/exceedance level under consideration.</p>
</td></tr>
<tr><td><code id="statistic.sim_+3A_alternative">alternative</code></td>
<td>
<p>Indicates the type of exceedance region or level curve under consideration.  For exceedances above a threshold, use (<code>alternative = "less"</code>).  For exceedances below a threshold, use (<code>alternative = "greater"</code>).  For contour lines, use (<code>alternative = "two.sided"</code>). Defaults to &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="statistic.sim_+3A_...">...</code></td>
<td>
<p>Additional arguments when <code>alternative = "two.sided"</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>alternative = "two.sided"</code>, the <code>...</code> argument must include <code>user.cov</code> (a user-specified covariance function), <code>pgrid</code> (the grid of locations to be predicted, produced by <code>create.pgrid</code> or <code>create.pgrid2</code>), <code>X</code> (the matrix of covariates for the observed data), and any other arguments needed by <code>user.cov</code>. Note that <code>user.cov</code> should take <code>cLcoords</code> as its first argument (a matrix containing the coordinates of contour lines under consideration). Additional arguments to <code>user.cov</code> are passed internally using the <code>...</code> argument. The <code>user.cov</code> function should return a list with values <code>V</code> (the covariance matrix of the observed data), <code>Vop</code> (the cross-covariance matrix between the observed data and the responses with coordinates in cL), <code>Vp</code> (the covariance matrix of the responses with coordinates in <code>cL</code>), and <code>Xp</code> (the matrix of covariates for the coordinates contained in <code>cL</code>). See the Examples section.
</p>


<h3>Value</h3>

<p>Returns a list with components: 
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>A vector with the observed values of the test statistic.</p>
</td></tr>
<tr><td><code>statistic.sim</code></td>
<td>
<p>A vector with the observed values of the test statistic.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>The alternative hypothesis provided to <code>statistic.sim</code>.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The threshold level under consideration.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SpatialTools)

# Example for exceedance regions

set.seed(10)
# Load data
data(sdata)
# Create prediction grid
pgrid &lt;- create.pgrid(0, 1, 0, 1, nx = 26, ny = 26)
pcoords &lt;- pgrid$pgrid
# Create design matrices
coords = cbind(sdata$x1, sdata$x2)
X &lt;- cbind(1, coords)
Xp &lt;- cbind(1, pcoords)

# Generate covariance matrices V, Vp, Vop using appropriate parameters for
# observed data and responses to be predicted
spcov &lt;- cov.sp(coords = coords, sp.type = "exponential", sp.par = c(1, 1.5),
 error.var = 1/3, finescale.var = 0, pcoords = pcoords)

# Predict responses at pgrid locations
krige.obj &lt;- krige.uk(y = as.vector(sdata$y), V = spcov$V, Vp = spcov$Vp, 
 Vop = spcov$Vop, X = X, Xp = Xp, nsim = 50, 
 Ve.diag = rep(1/3, length(sdata$y)) , method = "chol")
                
# Simulate distribution of test statistic for different alternatives
statistic.sim.obj.less &lt;- statistic.sim(krige.obj = krige.obj, level = 5,
 alternative = "less")
statistic.sim.obj.greater &lt;- statistic.sim(krige.obj = krige.obj, level = 5,
 alternative = "greater")
# Construct null and rejection sets for two scenarios
n90 &lt;- exceedance.ci(statistic.sim.obj.less, conf.level = .90, type = "null")
r90 &lt;- exceedance.ci(statistic.sim.obj.greater,conf.level = .90, 
 type = "rejection")       
# Plot results
plot(pgrid, n90, col="blue", add = FALSE, xlab = "x", ylab = "y")
plot(pgrid, r90, col="orange", add = TRUE)
legend("bottomleft", 
 legend = c("contains true exceedance region with 90 percent confidence", 
 "is contained in true exceedance region with 90 percent confidence"),
 col = c("blue", "orange"), lwd = 10)  

# Example for level curves
data(colorado)
ocoords &lt;- colorado$ocoords
odata &lt;- colorado$odata    

# Set up example
nsim &lt;- 50
u &lt;- log(16)
np &lt;- 26
conf.level &lt;- 0.90   
x.min &lt;- min(ocoords[,1])
x.max &lt;- max(ocoords[,1])
y.min &lt;- min(ocoords[,2])
y.max &lt;- max(ocoords[,2])   

#pixelize the domain
pgrid &lt;- create.pgrid(x.min, x.max, y.min, y.max, nx = np, ny = np)
pcoords &lt;- pgrid$pgrid; upx &lt;- pgrid$upx; upy &lt;- pgrid$upy
names(pcoords) &lt;- c("lon", "lat")    

# Set up covariates matrices
X &lt;- cbind(1, ocoords)
Xp &lt;- cbind(1, pcoords)           

# Estimate covariance parameters
cov.est &lt;- maxlik.cov.sp(X, odata, sp.type = "exponential", range.par = 1.12,
 error.ratio = 0.01, reml = TRUE, coords = ocoords)

# Create covariance matrices
myCov &lt;- cov.sp(coords = ocoords, sp.type = "exponential", 
 sp.par = cov.est$sp.par, error.var = cov.est$error.var, pcoords = pcoords)

# Krige and do conditional simulation 
krige.obj &lt;- krige.uk(y = odata, V = myCov$V, Vp = myCov$Vp, Vop = myCov$Vop, 
 X = X, Xp = Xp, nsim = nsim, Ve.diag = rep(cov.est$error.var, 
 length(odata)))

# Create user covariance function for simulating statistic for confidence 
# regions
user.cov &lt;- function(cLcoords,...)
{
   arglist &lt;- list(...)
   coords &lt;- arglist$coords
   sp.type &lt;- arglist$sp.type
   sp.par &lt;- arglist$sp.par
   V &lt;- arglist$V
   out &lt;- list(V = arglist$V,
               Vp = sp.par[1] * exp(-dist1(cLcoords)/sp.par[2]),
               Vop = sp.par[1] * exp(-dist2(coords, cLcoords)/sp.par[2]))
   out$Xp &lt;- cbind(1, cLcoords)
   return(out)
}

# Simulation statistic for confidence regions
statistic.sim.obj &lt;- statistic.sim(krige.obj = krige.obj, level = u, 
 alternative = "two.sided", user.cov = user.cov, y = odata, pgrid = pgrid, 
 X = X, coords = ocoords, pcoords = pcoords, V = myCov$V, 
 sp.type = "exponential", sp.par = cov.est$sp.par)

# Create 90% confidence region
n90 &lt;- exceedance.ci(statistic.sim.obj, conf.level = conf.level, 
 type = "null")
# Get estimated contour lines
cL &lt;- contourLines(pgrid$upx, pgrid$upy, matrix(krige.obj$pred, nrow = np), 
 level = u)

# Plot results
plot(ocoords, xlab = "longitude", ylab = "latitude", type = "n", 
 cex.lab = 1.5, cex.axis = 1.5)
plot(pgrid, n90, col = "grey", add = TRUE)
plot.contourLines(cL, col="black", lwd=2, lty = 2, add = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
