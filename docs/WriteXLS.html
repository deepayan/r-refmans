<!DOCTYPE html><html><head><title>Help for package WriteXLS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WriteXLS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#testPerl'><p>Test Perl installation and required modules for WriteXLS()</p></a></li>
<li><a href='#WriteXLS'><p>Cross-platform Perl based R function to create Excel 2003 (XLS)</p>
or Excel 2007 (XLSX) files</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>6.6.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Cross-Platform Perl Based R Function to Create Excel 2003 (XLS)
and Excel 2007 (XLSX) Files</td>
</tr>
<tr>
<td>Description:</td>
<td>Cross-platform Perl based R function to create Excel 2003 (XLS) and Excel 2007 (XLSX)
             files from one or more data frames. Each data frame will be
             written to a separate named worksheet in the Excel spreadsheet.
             The worksheet name will be the name of the data frame it contains
             or can be specified by the user. </td>
</tr>
<tr>
<td>Author:</td>
<td>Marc Schwartz &lt;marc_schwartz@me.com&gt; and various authors for Perl modules listed in each .pm file.</td>
</tr>
<tr>
<td>Copyright:</td>
<td>The copyright holders of the Perl files are listed in each
.pm file under the Perl directory.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc Schwartz &lt;marc_schwartz@me.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Perl</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/marcschwartz/WriteXLS">https://github.com/marcschwartz/WriteXLS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/marcschwartz/WriteXLS/issues">https://github.com/marcschwartz/WriteXLS/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-13 16:30:37 UTC; marcschwartz</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-13 17:23:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='testPerl'>Test Perl installation and required modules for WriteXLS()</h2><span id='topic+testPerl'></span>

<h3>Description</h3>

<p>Test Perl installation and required modules for WriteXLS()</p>


<h3>Usage</h3>

<pre><code class='language-R'>  testPerl(perl = "perl", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testPerl_+3A_perl">perl</code></td>
<td>
<p>Name of the perl executable to be called.</p>
</td></tr>
<tr><td><code id="testPerl_+3A_verbose">verbose</code></td>
<td>
<p>Output test result messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will test your current system to be sure that Perl is installed
and if so, whether or not all of the Perl modules required for <code>WriteXLS()</code>
are present.
</p>
<p>Success and/or error messages as appropriate will be output. 
</p>


<h3>Value</h3>

<p>A boolean value (TRUE or FALSE). TRUE if Perl and ALL required modules are found
</p>


<h3>Note</h3>

<p>Please be sure to read the included INSTALL file (in the main package installation 
directory) for additional details on meeting the requirements for Perl and the 
additional Perl modules that are necessary for <code>WriteXLS</code> to work properly. The file
includes platform specific recommendations for common scenarios. The path to the package
installation directory can be located using <code>system.file(package = "WriteXLS")</code>.
</p>
<p>A working installed version of Perl must be present in the current 
system searchpath or the exact path of the perl executable
must be provided via the <code>perl</code> argument.
Perl modules required for this function that may not be part of a default
Perl installation are included with this package. These modules include:
</p>
<p>Archive::Zip, OLE::Storage_Lite, Parse::RecDescent,
Spreadsheet::WriteExcel, Excel::Writer::XLSX and Text::CSV_PP
</p>
<p>File::Basename and Getopt::Long are &quot;Core&quot; Perl modules and should be part of a
standard Perl installation, however, they are both included in WriteXLS as a fall back.
</p>


<h3>Author(s)</h3>

<p>Marc Schwartz <a href="mailto:marc_schwartz@me.com">marc_schwartz@me.com</a>
</p>
<p>Many thanks to Prof. Brian Ripley for his assistance in the testing of this package. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WriteXLS">WriteXLS</a></code>
</p>

<hr>
<h2 id='WriteXLS'>Cross-platform Perl based R function to create Excel 2003 (XLS)
or Excel 2007 (XLSX) files</h2><span id='topic+WriteXLS'></span>

<h3>Description</h3>

<p>Writes one or more R data frames to an Excel 2003 or Excel
2007 file</p>


<h3>Usage</h3>

<pre><code class='language-R'>  WriteXLS(x, ExcelFileName = "R.xls", SheetNames = NULL,
           perl = "perl", verbose = FALSE,
           Encoding = c("UTF-8", "latin1", "cp1252"), AllText = FALSE,
           row.names = FALSE, col.names = TRUE,
           AdjWidth = FALSE, AutoFilter = FALSE, BoldHeaderRow = FALSE,
           ReadOnly = FALSE,
           na = "",
           FreezeRow = 0, FreezeCol = 0,
           envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WriteXLS_+3A_x">x</code></td>
<td>
<p>A character vector or factor containing the names of one or more R
data frames; A character vector or factor containing the name of
a single list which contains one or more
R data frames; a single list object of one or more data frames; a single data
frame object.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_excelfilename">ExcelFileName</code></td>
<td>
<p>The name of the Excel file to be created.
If the file extension is <em>.XLS</em>, an Excel 2003 file will be
created. If the file extension is <em>.XLSX</em>, an Excel 2007
file will be created.
Must be a valid Excel filename. May include an existing path.
<code>normalizePath</code> is used to support tilde expansion, etc.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_sheetnames">SheetNames</code></td>
<td>
<p>A character vector containing the names of each worksheet
to be created. If <code>NULL</code> (the default), the
names of the dataframes will be used instead. Worksheet names may
be up to 31 characters in length and must be unique. If
specified, <code>length(SheetNames)</code> must be the same as
<code>length(x)</code>. NOTE: The order of the names here must match
the order of the data frames as listed in <code>x</code>.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_perl">perl</code></td>
<td>
<p>Name of the perl executable to be called.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_verbose">verbose</code></td>
<td>
<p>Output step-by-step status messages during the creation
of the Excel file. Default is FALSE.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_encoding">Encoding</code></td>
<td>
<p>Define the character encoding to be used for the
exported data frames. Defaults to <code>UTF-8</code>.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_alltext">AllText</code></td>
<td>
<p>If <code>TRUE</code>, all cell contents of the Excel file will
be written as text. Default is FALSE. See Details.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_row.names">row.names</code></td>
<td>
<p>If <code>TRUE</code>, the row names of the data frames are
included in the Excel file worksheets.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_col.names">col.names</code></td>
<td>
<p>If <code>TRUE</code>, the column names of the data frames are
included in the Excel file worksheets.</p>
</td></tr>  
<tr><td><code id="WriteXLS_+3A_adjwidth">AdjWidth</code></td>
<td>
<p>If <code>TRUE</code>, will adjust the worksheet column
widths based upon the longest entry in each column. This is
approximate.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_autofilter">AutoFilter</code></td>
<td>
<p>If <code>TRUE</code>, will add autofiltering to each
column in each worksheet. Note that not all spreadsheet applications
support this feature.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_boldheaderrow">BoldHeaderRow</code></td>
<td>
<p>If <code>TRUE</code>, will apply a bold font to the
header row for each worksheet.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_readonly">ReadOnly</code></td>
<td>
<p>If <code>TRUE</code>, each worksheet will be set to Read Only
(Protected mode) to prevent inadvertent changes to the contents when
the file is opened in Excel or a compatible application. See Details.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_na">na</code></td>
<td>
<p>The string to use for missing values in the data. Defaults
to &quot;&quot;</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_freezerow">FreezeRow</code></td>
<td>
<p>Rows including this row and above this row will be
frozen and not scroll. The default value of <code>0</code> will scroll
the entire sheet. Note that not all spreadsheet applications
support this feature.</p>
</td></tr>
<tr><td><code id="WriteXLS_+3A_freezecol">FreezeCol</code></td>
<td>
<p>Columns including this column and to the left of this
column will be frozen and not scroll. The default value of
<code>0</code> will scroll the entire sheet. Note that not all
spreadsheet applications support this feature.</p>
</td></tr> 
<tr><td><code id="WriteXLS_+3A_envir">envir</code></td>
<td>
<p>The environment in which to look for the data frames
named in <code>x</code>. This defaults to the environment in which
<code>WriteXLS</code> was called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes: a character vector or factor containing the names of one or
more R data frames; A character vector or factor containing the name
of a single list which contains one or more R data frames; a single
list object containing one or more data frames; a
single data frame object and exports them to an Excel 2003 or 2007
spreadsheet file. Each data frame will be written to a separate
worksheet in the same Excel file.
</p>
<p>The order of the worksheets created in the Excel file will match the
order of the entries in <code>x</code>.
</p>
<p>The actual creation of the Excel file is performed by Perl scripts
called WriteXLS.pl (for XLS files) and WriteXLSX.pl (for XLSX files),
which are included with this package.
</p>
<p>Note that the named Excel file, if it already exists, will be
overwritten and no warning is given. In addition, if the file exists
and is open by another application (eg. Excel, OO.org, LibreOffice, etc.) you will
likely get an error message regarding the inability to open the file
and/or that the file is already in use by another application or
user. Errors can also occur if the file has been marked as
read-only or if your access rights do not allow you to overwrite the
file or write to the folder you have indicated in the path to the file.
</p>
<p>There is an intermediate step, where the R data frames are first written
to CSV files using <code>writeLines</code> with argument <code>useBytes = TRUE</code> before being written
to the Excel file by the relevant Perl script. <code>tempdir</code> is used to determine the 
current R session temporary directory and a new sub-directory called &ldquo;WriteXLS&rdquo;
will be created there. The CSV files will be written to that directory and
both the files and the directory will be deleted prior to the function
terminating normally using <code>on.exit</code>. It is possible that these 
will remain in place if this function terminates abnormally or is aborted
prior to completion.
</p>
<p>Since <code>as.character</code> is used to coerce data frame column content to character
vectors prior to export, data types supported by <code>as.character</code> will be exported to their 
character representation correctly. For other data types, it is recommended
that you first coerce them to character columns, formatted as you require,
and then use <code>WriteXLS</code> to create the Excel file.
</p>
<p>All of the CSV files will be created prior to the creation of the Excel file
as the Perl script will loop over them as part of the process. Thus, 
sufficient free disk space must be available for these files and the Excel
file at the same time. Note, importantly, that in the course of creating XLSX files,
which are ZIP compressed XML files, Perl will require free disk space that is some
multiple of the size of the resultant XLSX file, in the course of creating the
XML files before compression into the XLSX file. Thus, additional free disk space,
in addition to the CSV files noted above, will also be required temporarily.
</p>
<p>A text file called &quot;SheetNames.txt&quot; will be created in the same
temporary directory as the CSV files. This file will contain the sheet
names, one per line and will be used by the Perl script to name the
worksheets in the Excel file.
</p>
<p>Each worksheet will be named using either the names in
<code>SheetNames</code>, the names of the data frames in <code>x</code> or the
names of the list elements if <code>x</code> is a list (up to the first 31
characters, which is an Excel limitation). If any the data frame names
specified in <code>x</code> are longer than 31 characters, they will be
truncated to 31 characters. <code>SheetNames</code> if specified, will be
checked to make sure that all of the entries are less than or equal to
31 characters. If not, an error message will be displayed.
</p>
<p>Note that the order of the names in <code>SheetNames</code> MUST match the
order of the data frames named in <code>x</code>.
</p>
<p>Note that the worksheets must have unique names. Thus, if
<code>SheetNames</code> is <code>NULL</code>, the data frame names will be checked
to be sure that they are unique up through the first 31 characters. If
<code>SheetNames</code> is specified, the entries will be checked to be sure
that they are unique. If not, an error message will be displayed.
</p>
<p>Note that the following characters are not allowed for Excel worksheet
names: []:*?/\ 
</p>
<p>The data frame column names will be exported &quot;as is&quot; and will be the first 
row in the corresponding worksheet, if <code>col.names = TRUE</code>.
</p>
<p>UTF-8 encoded content in the data frame should be properly exported by
default. If you are operating in a 'latin1' based locale (also known
as iso-8859-1) or a Windows CP-1252 locale, set <code>Encoding</code>
to 'latin1' or 'cp1252', respectively.
</p>
<p>As of version 5.0.0, Unicode character based content is better supported if
running on a Windows based operating system. This is achieved by generating
the intermediate CSV files using <code>writeLines(..., useBytes = TRUE)</code>,
which should avoid the re-encoding of the content of the CSV files into the
operating locale of the relevant computer. Set <code>Encoding</code> to 'UTF-8' in
this case to preserve the Unicode content in the Excel file. Since
<code>Encoding</code> applies to all data frames and columns therein being
exported to the same Excel file, if mixed character encodings are present,
this may cause errors in the character representations in the Excel file.
If you note errors from Perl regarding characters not mapping to Unicode,
or illegal characters in UTF-8, try setting <code>Encoding</code> to 'latin1'.
If mixed encodings are present, you may want to explore the use of <code>iconv</code>
to standardize the data to a single encoding.
</p>
<p>If one or more of the data frame columns have been assigned a
<em>comment</em> attribute using the <code>comment</code> function, these will
be used to create a worksheet cell comment in this first row of
the worksheet for each column with this attribute. These can serve to
provide descriptive information for each column. This will work for
both the Excel 2003 and 2007 file formats.
</p>
<p>Values containing leading and/or trailing zeroes in data frame content will
be treated, by default, as text, such that these zeroes will be preserved in the Excel
worksheet content, rather than being coerced to numeric values and being stripped, which is
the default Excel behavior. These values will be left-justified in the cells, rather than
being right-justified, and there may be a mix of justification in a single column, based
upon the data present. 
</p>
<p>If <code>AllText = TRUE</code>, all data frame contents, including numeric values, will be
written to the Excel file as text, and will be left-justified. There may be content in
the source data frame(s), that contain leading and/or trailing zeros or other pre-formatted
content which would otherwise be modified by Excel, and which is the default Excel behavior.
Thus, this option is provided to fully override the default behavior in Excel. Note that if
you open the Excel file after creation, you may note little colored triangles in the upper
left hand corner of the relevant cells, indicating that a number is stored as text. This is
expected and if you manually edit the cell content, it may revert to a number, losing any desired
formatting.
</p>
<p>If <code>verbose = TRUE</code>, messages will be output during key steps in the process of creating
the Excel file and intermediate steps. In the case of the Perl scripts parsing the intermediate CSV files,
CSV file line numbers will be output to hopefully assist in the debugging of possible content problems that may
compromise the integrity of the resultant Excel file. Note that the line numbers are 0 based, rather than 1 based,
and will include an additional line for the column names if <code>col.names = TRUE</code>. An additional line is
also included to be able to handle any <em>comment</em> attributes, and you will observe a repeat of either line 0,
if <code>col.names = FALSE</code> or line 1, if <code>col.names = TRUE</code>, as a result. The actual source data frame
content will begin on the subsequent line.
</p>
<p>If <code>ReadOnly = TRUE</code>, each worksheet will be set to Protected (read only) mode to prevent the inadvertent
editing of the contents when the file is opened in Excel or a compatible application. This is not the same as
the file being password protected and encrypted, which is not supported. The contents of the worksheets will be
readable and copyable, but not editable. Each worksheet will show a lock icon on the worksheet tab. Protected mode
can be disabled by the user by right-clicking on each worksheet tab and selecting 'Unprotect Sheet' in the menu.
</p>
<p>Note that as of version 6.0.0, more robust handling of embedded newline ('\n') and carriage return ('\r')
characters, double quotes, and two character sequences of a backslash character ('\') followed by another character,
within a data frame value has been implemented.
</p>
<p>If there any issues parsing the lines in the CSV file, such that the number of fields in the current line is different
than the prior line, perhaps due to atypical character content, an error will be issued. If this occurs, you may wish
to set <code>verbose = TRUE</code> in order to obtain additional debugging information to help identify where in the CSV
file the error may be located. You may need to pre-process the data in the source data frame (e.g. using <code>gsub</code>)
in order to resolve this issue. While this handling is now more robust, the user is strongly encouraged to verify the
content of the resultant Excel file to ensure that the integrity of the exported data frame(s) is maintained and that
all source data have been written correctly to the worksheet(s). The user is strongly encouraged to be aware of any
data frame content that includes escaped character sequences or other atypical content, and to consider pre-processing
these as may be apropos, prior to using this function.
</p>
<p>Note that arguments <code>AdjWidth</code>, <code>AutoFilter</code>, <code>BoldHeaderRow</code>, <code>ReadOnly</code>, <code>FreezeRow</code>,
<code>FreezeCol</code>, <code>Encoding</code>, <code>row.names</code>, <code>col.names</code> and <code>AllText</code> will apply to ALL
worksheets exported.
</p>


<h3>Value</h3>

<p>TRUE if the Excel file was successfully created.
FALSE if any errors occurred.
</p>


<h3>Note</h3>

<p>Please be sure to read the included INSTALL file (in the main package installation 
directory) for additional details on meeting the requirements for Perl and the 
additional Perl modules that are necessary for this function to work properly. The file
includes platform specific recommendations for common scenarios. The path to the package
installation directory can be located using <code>system.file(package = "WriteXLS")</code>.
</p>
<p>A working installed version of Perl must be present in the current 
system searchpath or the exact path of the perl executable
must be provided via the <code>perl</code> argument.
Perl modules required for this function that may not be part of a default
Perl installation are included with this package. These modules include:
</p>
<p>Archive::Zip, OLE::Storage_Lite, Parse::RecDescent,
Spreadsheet::WriteExcel, Excel::Writer::XLSX and Text::CSV_PP
</p>
<p>File::Basename and Getopt::Long are &quot;Core&quot; Perl modules and should be part of a
standard Perl installation, however, they are both included in WriteXLS as a fall back.
</p>
<p>To test your Perl installation and verify that all required Perl modules are available,
use the <code>testPerl</code> function provided in this package.
</p>


<h3>Author(s)</h3>

<p>Marc Schwartz <a href="mailto:marc_schwartz@me.com">marc_schwartz@me.com</a>
</p>
<p>Many thanks to Prof. Brian Ripley for his assistance in the testing of this package. 
</p>


<h3>References</h3>

<p>Spreadsheet::WriteExcel Perl Module <a href="https://metacpan.org/release/Spreadsheet-WriteExcel">https://metacpan.org/release/Spreadsheet-WriteExcel</a>
</p>
<p>Excel::Writer::XLSX Perl Module <a href="https://metacpan.org/release/Excel-Writer-XLSX">https://metacpan.org/release/Excel-Writer-XLSX</a>
</p>
<p>Excel 2007 Specifications and Limitations <a href="https://support.microsoft.com/en-us/office/excel-specifications-and-limits-1672b34d-7043-467e-8e27-269d656771c3">https://support.microsoft.com/en-us/office/excel-specifications-and-limits-1672b34d-7043-467e-8e27-269d656771c3</a>
</p>
<p>For Perl Unicode Issues
<a href="https://ahinea.com/en/tech/perl-unicode-struggle.html">https://ahinea.com/en/tech/perl-unicode-struggle.html</a> and/or
<a href="https://www.perl.com/pub/2012/04/perlunicook-standard-preamble.html/">https://www.perl.com/pub/2012/04/perlunicook-standard-preamble.html/</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+writeLines">writeLines</a></code>, <code><a href="#topic+testPerl">testPerl</a></code>, <code><a href="base.html#topic+comment">comment</a></code> and <code><a href="base.html#topic+iconv">iconv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Only run the examples if Perl and all modules are present
  if (testPerl(verbose = FALSE))
  {
    ## Examples using built-in data frames
    ## Create XLSX (Excel 2007) files 
    WriteXLS("iris", "iris.xlsx")

    WriteXLS(c("iris", "infert", "esoph"), "Example.xlsx")

    iris.split &lt;- split(iris, iris$Species)
    WriteXLS("iris.split", "irissplit.xlsx")

    ## Example using comment()
    ## Commented cells with have a small red triangle in the
    ## upper right hand corner of the cell. Click on the cell
    ## or place the cursor over the cell to see the pop-up
    ## containing the comment text.
    ## Adjust the column widths
    ## Bold the header row
    comment(iris$Sepal.Length) &lt;- "Length of the sepals (cm)"
    comment(iris$Sepal.Width) &lt;- "Width of the sepals (cm)"
    comment(iris$Petal.Length) &lt;- "Length of the petals (cm)"
    comment(iris$Petal.Width) &lt;- "Width of the petals (cm)"
    comment(iris$Species) &lt;- "Species of the flowers"
    WriteXLS("iris", "iriscomments.xlsx",
             AdjWidth = TRUE, BoldHeaderRow = TRUE)

    ## Add row names
    WriteXLS("iris", "irisrownames.xlsx",
             AdjWidth = TRUE, BoldHeaderRow = TRUE, row.names = TRUE)

    ## Use latin1 Encoding
    WriteXLS("iris", "irisLatin1.xlsx", Encoding = "latin1")

    ## Write a 0 row data frame
    ## Worksheet will contain header row only
    DF0 &lt;- data.frame("A" = numeric(), "B" = numeric(), "C" = numeric())
    WriteXLS("DF0", "DF0.xlsx", AdjWidth = TRUE, BoldHeaderRow = TRUE)

    ## 'x' is a single data frame object
    WriteXLS(iris, "irisDF.xlsx")

    ## 'x' is a list object containing data frames
    WriteXLS(iris.split, "irisList.xlsx")

    ## Behavior with leading and/or trailing zeroes
    DFL0 &lt;- data.frame(A = c("01234", "12345", "012300", "1050", "10230"), 
                       B = c("000-00", "123-45", "000-10-1230", ".1.2.3.40", "0123.45.6"), 
                       C = c("0123.4", "001234.5", "0.1234", "1234.0", "1234.00"))
    WriteXLS(DFL0, "DFL0.xlsx", AdjWidth = TRUE, BoldHeaderRow = TRUE)
    WriteXLS(DFL0, "DFL0AT.xlsx", AdjWidth = TRUE, BoldHeaderRow = TRUE, AllText = TRUE)

    ## Embedded newline, carriage return and a two character backslash sequence
    DF.NL &lt;- data.frame(RL = "This is normal text",
                        LF = "This sample text \n has a LF",
                        CR = "This sample text \r has a CR",
                        CRLF = "This sample text \r\n has a CRLF",
                        BSChar = "This sample text \\I has a character preceded by a backslash")
    WriteXLS(DF.NL, "DFNL.xlsx", AdjWidth = TRUE, BoldHeaderRow = TRUE)

    ## Embedded comma, single and double quotes
    DF.Embed &lt;- data.frame(A = "This is sample text, with a comma",
                           B = "This is \"sample text\" with a double quote",
                           C = "This is \'sample text\' with a single quote")
    WriteXLS(DF.Embed, "DFEmbed.xlsx")
    
    
    ## Clean up and delete XLSX files
    rm(iris.split)
    rm(DF0)
    rm(DFL0)
    rm(DF.NL)
    rm(DF.Embed)
    unlink("iris.xlsx")
    unlink("Example.xlsx")
    unlink("irissplit.xlsx")
    unlink("iriscomments.xlsx")
    unlink("irisrownames.xlsx")
    unlink("irisLatin1.xlsx")
    unlink("DF0.xlsx")
    unlink("irisDF.xlsx")
    unlink("irisList.xlsx")
    unlink("DFL0.xlsx")
    unlink("DFL0AT.xlsx")
    unlink("DFNL.xlsx")
    unlink("DFEmbed.xlsx")
  }
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
