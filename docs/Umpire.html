<!DOCTYPE html><html><head><title>Help for package Umpire</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Umpire}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addControl-method'><p>Method &quot;addControl&quot;</p></a></li>
<li><a href='#alterMean-method'><p>Methods &quot;alterMean&quot; and &quot;alterSD&quot;</p></a></li>
<li><a href='#BlockHyperParameters-class'><p>The &quot;BlockHyperParameters&quot; Class</p></a></li>
<li><a href='#blur-method'><p>Method &quot;blur&quot;</p></a></li>
<li><a href='#CancerEngine-class'><p>The &quot;CancerEngine&quot; Class</p></a></li>
<li><a href='#CancerModel-class'><p>The &quot;CancerModel&quot; Class</p></a></li>
<li><a href='#ClinicalNoiseModel'>
<p>A Noise Model for Clinical Data</p></a></li>
<li><a href='#Engine-class'><p>The &quot;Engine&quot; Class</p></a></li>
<li><a href='#EngineWithActivity-class'><p>The &quot;EngineWithActivity&quot; Class</p></a></li>
<li><a href='#IndependentLogNormal-class'><p>The &quot;IndependentLogNormal&quot; Class</p></a></li>
<li><a href='#IndependentNormal-class'><p>The &quot;IndependentNormal&quot; Class</p></a></li>
<li><a href='#makeDataTypes'>
<p>Discretize a Continuous Data Set to Mixed Types</p></a></li>
<li><a href='#MixedTypeEngine-class'><p>The &quot;MixedTypeEngine&quot; Class</p></a></li>
<li><a href='#MVN-class'><p>The &quot;MVN&quot; Class</p></a></li>
<li><a href='#nComponents-method'><p>Method &quot;nComponents&quot;</p></a></li>
<li><a href='#NoiseModel-class'><p>The &quot;NoiseModel&quot; Class</p></a></li>
<li><a href='#NormalVsCancer'><p>Simulating Cancer Versus Normal Datasets</p></a></li>
<li><a href='#rand-method'><p>Method &quot;rand&quot;</p></a></li>
<li><a href='#SurvivalModel-class'><p>The &quot;SurvivalModel&quot; Class</p></a></li>
<li><a href='#transforms'><p>Transform functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-11-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulating Realistic Gene Expression and Clinical Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin R. Coombes, Jiexin Zhang, Caitlin E. Coombes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin R. Coombes &lt;krc@silicovore.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Ultimate Microrray Prediction, Reality and Inference
  Engine (UMPIRE) is a package to facilitate the simulation of realistic
  microarray data sets with links to associated outcomes. See Zhang and
  Coombes (2012) &lt;<a href="https://doi.org/10.1186%2F1471-2105-13-S13-S1">doi:10.1186/1471-2105-13-S13-S1</a>&gt;. Version 2.0 adds the
  ability to simulate realistic mixed-typed clinical data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, mc2d, BimodalIndex</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mclust, survival, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-10 20:47:24 UTC; KRC</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-10 21:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='addControl-method'>Method &quot;addControl&quot;</h2><span id='topic+addControl'></span><span id='topic+addControl-method'></span><span id='topic+addControl+2CANY-method'></span><span id='topic+addControl+2CCancerModel-method'></span><span id='topic+addControl+2CCancerEngine-method'></span>

<h3>Description</h3>

<p><code>addControl</code> is a generic function used to add a control group to
a simulated patient cohort. Implementations exists for a
<code>CancerModel</code> and for a <code>CancerEngine</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
addControl(object, fraction = 0.5, ...)
## S4 method for signature 'CancerModel'
addControl(object, fraction = 0.5, ...)
## S4 method for signature 'CancerEngine'
addControl(object, fraction = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addControl-method_+3A_object">object</code></td>
<td>
<p>an object to which adding a contrl group is desired</p>
</td></tr>
<tr><td><code id="addControl-method_+3A_fraction">fraction</code></td>
<td>
<p>a real number between zero oand one; the fraction of
the final cohort that shoudl consist of controls</p>
</td></tr>
<tr><td><code id="addControl-method_+3A_...">...</code></td>
<td>
<p>additional arguments; not yet used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new object of the same class as its first argument.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
</p>

<hr>
<h2 id='alterMean-method'>Methods &quot;alterMean&quot; and &quot;alterSD&quot;</h2><span id='topic+alterMean'></span><span id='topic+alterMean-method'></span><span id='topic+alterMean+2CANY-method'></span><span id='topic+alterSD'></span><span id='topic+alterSD-method'></span><span id='topic+alterSD+2CANY-method'></span>

<h3>Description</h3>

<p><code>alterMean</code> and <code>alterSD</code> are generic functions used to alter
means or standard deviations, respectively, based on the input object.
Each generic functions invokes different
<code><a href="utils.html#topic+methods">methods</a></code> which depend on the <code><a href="base.html#topic+class">class</a></code> of the
first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
alterMean(object, TRANSFORM, ...)
## S4 method for signature 'ANY'
alterSD(object, TRANSFORM, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alterMean-method_+3A_object">object</code></td>
<td>
<p>an object for which altering mean or standard deviation
is desired</p>
</td></tr>
<tr><td><code id="alterMean-method_+3A_transform">TRANSFORM</code></td>
<td>
<p>function that returns its transformed input</p>
</td></tr>
<tr><td><code id="alterMean-method_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the specific transformation
performed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The form of the value returned by <code>alterMean</code> or <code>alterSD</code>
depends on the class of its argument. See the documentation of the
particular methods for details of what is produced by that method. 
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jiexin Zhang <a href="mailto:jiexinzhang@mdanderson.org">jiexinzhang@mdanderson.org</a>,
</p>

<hr>
<h2 id='BlockHyperParameters-class'>The &quot;BlockHyperParameters&quot; Class</h2><span id='topic+BlockHyperParameters-class'></span><span id='topic+BlockHyperParameters'></span><span id='topic+makeBlockStructure'></span>

<h3>Description</h3>

<p>Provides tools to create a CancerEngine with block correlation structure.
Also makes it possible to simulate paired clinical and gene expression data
with this block structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlockHyperParameters(nExtraBlocks = 100,
                     meanBlockSize = 100,
                     sigmaBlockSize = 30,
                     minBlockSize = 5,
                     mu0 = 6,
                     sigma0 = 1.5,
                     rate = 28.11,
                     shape = 44.25,
                     p.cor = 0.6,
                     wt.cor = 5)
makeBlockStructure(cm, hyperp, xform = normalOffset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BlockHyperParameters-class_+3A_cm">cm</code></td>
<td>
<p>object of class <code>CancerModel</code></p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_hyperp">hyperp</code></td>
<td>
<p>object of class <code>BlockHypeParameters</code></p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_nextrablocks">nExtraBlocks</code></td>
<td>
<p>integer scalar specifying number of blocks not
involved in the &quot;hit&quot; structure defined by the <code>CancerModel</code></p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_meanblocksize">meanBlockSize</code></td>
<td>
<p>numeric scalar specifying mean number of genes in a
correlated block</p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_sigmablocksize">sigmaBlockSize</code></td>
<td>
<p>numeric scalar specifying standard deviation of the
number of genes in a correlated block</p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_minblocksize">minBlockSize</code></td>
<td>
<p>integer scalar specifying minimal number of genes in a
correlated block</p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_mu0">mu0</code></td>
<td>
<p>numeric scalar specifying expected mean expression level of a
gene on the log scale</p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_sigma0">sigma0</code></td>
<td>
<p>numeric scalar specifying standard deviation of the mean
expression level of a gene on the log scale</p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_rate">rate</code></td>
<td>
<p>numeric scalar specifying one of the gamma parameters</p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_shape">shape</code></td>
<td>
<p>numeric scalar specifying one of the gamma parameters</p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_p.cor">p.cor</code></td>
<td>
<p>numeric scalar specifying expected correlation within each
block</p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_wt.cor">wt.cor</code></td>
<td>
<p>numeric scalar specifying weight given to the expected block
correlation</p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_xform">xform</code></td>
<td>
<p>A function that will be passed to the <code>alterMean</code>
method</p>
</td></tr>
<tr><td><code id="BlockHyperParameters-class_+3A_...">...</code></td>
<td>
<p>extra arguments that wil be passed back to the
<code>xform</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Our standard model for gene expression in a homogeneous sample assumes
that the overall correlation matrix is block diagonal.  Correlation
between genes in different blocks is assumed to be zero.  Correlation
for genes in the same block is assumed to be a constant, but different
correlation constants can be used in different blocks.  The actual
correlations are assumed to arise from a beta distribution of the form
Beta(pw, (1-p)w), where p=<code>p.cor</code> and w=<code>wt.cor</code> are two of the
hyperparameters.
</p>
<p>The number of blocks is determined jointly by the <code><a href="#topic+CancerModel">CancerModel</a></code>,
<code>cm</code>, and the hyperparameter <code>nExtraBlocks</code>.  The size of a
block is assumed to arise from a normal distribution with mean given
by <code>meanBlockSize</code> and standard deviaion given by
<code>sigmaBlockSize</code>.  To avoid accidentally assigning non-postive
block sizes, this distribution is truncated below by
<code>minBlockSize</code>.
</p>
<p>The expression of each gene is assumed to come from a log-normal
distribution with parameters describing the per-gene mean (<code class="reqn">\mu_g</code>)
and standard deviation (<code class="reqn">\sigma_g</code>) n the log scale.  These
parameters, in turn, are assumed to come from hyperdistributions.
Specifically, we assume that <code class="reqn">\mu_g</code> comes from a normal distribution
with  mean <code>mu0</code> and standard deviation <code>sigma0</code>.  We also
assume that <code class="reqn">\sigma_g</code> comes from an inverse gamma distribution with
parameters <code>rate</code> and <code>shape</code>.
</p>
<p>The <code>BlockHyperParameters</code> class simply bundles the parameters for
this model into a single structure. The default values are consistent
with data we have seen from several Affymetrix microarray studies.
</p>
<p>The <code>makeBlockStructure</code> function takes a <code>CancerModel</code> and
a <code>BlockHyperParameters</code> object as arguments and produces a
<code><a href="#topic+CancerEngine">CancerEngine</a></code> object. The <code><a href="#topic+rand">rand</a></code> method for
this class can be used to generate matched clinical data (with the
structure defined by the <code>CancerModel</code> object) and gene
expression data with the specified block correlation structure.
</p>


<h3>Value</h3>

<p>The <code>BlockHyperParameters</code> generator returns an object of class
<code>BlockHyperParameters</code>.
</p>
<p>The function <code>makeBlockStructure</code> returns an object of the
<code><a href="#topic+CancerEngine">CancerEngine</a></code> class.  
</p>


<h3>Objects from the Class</h3>

<p>Although objects of the class can be created by a direct call to
<a href="methods.html#topic+new">new</a>, the preferred method is to use the
<code>BlockHyperParameters</code> generator function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nExtraBlocks</code>:</dt><dd><p>An integer; the number of blocks not involved in
the &quot;hit&quot; structure defined by the <code>CancerModel</code>.</p>
</dd>
<dt><code>meanBlockSize</code>:</dt><dd><p>A real number; the mean number of genes in a
correlated block.</p>
</dd> 
<dt><code>sigmaBlockSize</code>:</dt><dd><p>A real number; standard deviation of the number of
genes in a correlated block.</p>
</dd>
<dt><code>minBlockSize</code>:</dt><dd><p>An integer; the minimal number of genes in a
correlated block.</p>
</dd>
<dt><code>mu0</code>:</dt><dd><p>A real number; the expected mean expression level of a gene
on the log scale.</p>
</dd>
<dt><code>sigma0</code>:</dt><dd><p>A real number; the standard deviation of the mean
expression level of a gene on the log scale.</p>
</dd>
<dt><code>rate</code>:</dt><dd><p>Gamma parameter; see details.</p>
</dd>
<dt><code>shape</code>:</dt><dd><p>Gamma parameter; see details.</p>
</dd>
<dt><code>p.cor</code>:</dt><dd><p>A real number; the expected correlation within each block.</p>
</dd>
<dt><code>wt.cor</code>:</dt><dd><p>A real number; the weight given to the
expected block correlation.</p>
</dd> 
</dl>



<h3>Methods</h3>

<p>There are no special methods defind for this class.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CancerModel-class">CancerModel</a></code>,
<code><a href="#topic+CancerEngine-class">CancerEngine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("BlockHyperParameters")
sm &lt;- SurvivalModel(baseHazard = 1/3, units = 52, unitName = "weeks")
cm &lt;- CancerModel("myModel", nPossible = 10, nPattern = 5,
                  survivalModel = sm)
hyper &lt;- BlockHyperParameters()
engine &lt;- makeBlockStructure(cm, hyper)
outcome &lt;- rand(engine, 100)
summary(outcome$clinical)
dim(outcome$data)
</code></pre>

<hr>
<h2 id='blur-method'>Method &quot;blur&quot;</h2><span id='topic+blur'></span><span id='topic+blur-method'></span><span id='topic+blur+2CANY-method'></span>

<h3>Description</h3>

<p><code>blur</code> is a generic function used to add noise to a signal as defined
by various objects. The generic function invokes different <code><a href="utils.html#topic+methods">methods</a></code>
which depend on the <code><a href="base.html#topic+class">class</a></code> of the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
blur(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blur-method_+3A_object">object</code></td>
<td>
<p>an object from which adding noise to its signal is desired</p>
</td></tr>
<tr><td><code id="blur-method_+3A_x">x</code></td>
<td>
<p>matrix containing signal to be affected</p>
</td></tr>
<tr><td><code id="blur-method_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the noise addition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The form of the value returned by <code>blur</code> depends on the
class of its argument. See the documentation of the particular methods
for details of what is produced by that method.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
</p>

<hr>
<h2 id='CancerEngine-class'>The &quot;CancerEngine&quot; Class</h2><span id='topic+CancerEngine-class'></span><span id='topic+CancerEngine'></span><span id='topic+ClinicalEngine'></span><span id='topic+rand+2CCancerEngine-method'></span><span id='topic+nrow+2CCancerEngine-method'></span><span id='topic+nComponents+2CCancerEngine-method'></span><span id='topic+summary+2CCancerEngine-method'></span>

<h3>Description</h3>

<p>A CancerEngine combines a CancerModel (which defines the combinatorics
of hits that produce cancer subtypes) with a pair of gene expression
Engines that can be used to simulate microarray data depending on the
presence or absence of different hits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CancerEngine(cm, base, altered)
## S4 method for signature 'CancerEngine'
summary(object, ...)
## S4 method for signature 'CancerEngine'
nrow(x)
## S4 method for signature 'CancerEngine'
nComponents(object, ...)
## S4 method for signature 'CancerEngine'
rand(object, n, ...)
ClinicalEngine(nFeatures, nClusters, isWeighted,
               bHyp = NULL, survivalModel = NULL,
               SURV = function(n) rnorm(n, 0, 0.3),
               OUT = function(n) rnorm(n, 0, 0.3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CancerEngine-class_+3A_cm">cm</code></td>
<td>
<p>object of class <code>CancerModel</code></p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_base">base</code></td>
<td>
<p>character string giving the name of an <code><a href="#topic+Engine">Engine</a></code>
or <code><a href="#topic+EngineWithActivity">EngineWithActivity</a></code>, or an object of class <code>Engine</code>.
Represents the expected gene expression in the absence of any hits.</p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_altered">altered</code></td>
<td>
<p>character string giving the name of an <code><a href="#topic+Engine">Engine</a></code>
or <code><a href="#topic+EngineWithActivity">EngineWithActivity</a></code>, or an object of class <code>Engine</code>.
Represents the expected gene expression in the presence of hits.</p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_object">object</code></td>
<td>
<p>object of class <code>CancerEngine</code></p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_x">x</code></td>
<td>
<p>object of class <code>CancerEngine</code></p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_n">n</code></td>
<td>
<p>numeric scalar representing number of samples to be simulated</p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic routines</p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_nfeatures">nFeatures</code></td>
<td>
<p>an integer; the number of simulated clinical features</p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_nclusters">nClusters</code></td>
<td>
<p>an integer; the number of simulated clusters or subtypes</p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_isweighted">isWeighted</code></td>
<td>
<p>a logical value; used to determine whether the prevalence
of subtypes is equal (unweighted) or unequal (weighted).</p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_bhyp">bHyp</code></td>
<td>
<p>an object of the class <code>BlockHyperParameters</code>. If NULL,
then it is constructed using the default clinical parameters. See the
Values section below.</p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_survivalmodel">survivalModel</code></td>
<td>
<p>an object of the <code><a href="#topic+SurvivalModel">SurvivalModel</a></code> class.
If NULL, then it is constructed using the default parameters.</p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_surv">SURV</code></td>
<td>
<p>a function; the same as used in a <code><a href="#topic+CancerModel">CancerModel</a></code>.</p>
</td></tr>
<tr><td><code id="CancerEngine-class_+3A_out">OUT</code></td>
<td>
<p>a function; the same as used in a <code><a href="#topic+CancerModel">CancerModel</a></code>.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Although objects of the class can be created by a direct call to
<a href="methods.html#topic+new">new</a>, the preferred method is to use the
<code>CancerEngine</code> or <code>ClinicalEngine</code> generator functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cm</code>:</dt><dd><p>A <code><a href="#topic+CancerModel">CancerModel</a></code> object.</p>
</dd>
<dt><code>base</code>:</dt><dd><p>Object of class &quot;character&quot; giving the name of
an <code><a href="#topic+Engine">Engine</a></code> or <code><a href="#topic+EngineWithActivity">EngineWithActivity</a></code>.
Represents the expected gene expression in the absence of any hits.</p>
</dd>
<dt><code>altered</code>:</dt><dd><p>Object of class &quot;character&quot; giving the name of
an <code><a href="#topic+Engine">Engine</a></code> or <code><a href="#topic+EngineWithActivity">EngineWithActivity</a></code>.
Represents the expected gene expression in the presence of hits.</p>
</dd>
<dt><code>localenv</code>:</dt><dd><p>Object of class <code>"environment"</code>; used
in the internal implementation. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>rand</dt><dd><p><code>signature(object = "CancerEngine")</code>: returns a list
containing two named components, <code>clinical</code> and <code>data</code>, The
clinical element is a data frame generated from the underlying
<code>CancerModel</code>, and the data element is a matrix generated by the
gene expression engines, altered by the appropriate &quot;hits&quot; present in
each simulated individual.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "CancerEngine")</code>: print
summaries of the underlying cancer models and gene expression engines
in the cancer engine. </p>
</dd>  </dl>



<h3>Values</h3>

<p>Both the <code>CancerEngine</code> and <code>ClinicalEngine</code>
constructors return objects of the <code>CancerEngine</code> class. The only
practical differences are the default parameters set by the constructors.
The primary change is in the <code><a href="#topic+CancerModel">CancerModel</a></code> slot. The
<code>CancerEngine</code> expects you to construct your own <code>CancerModel</code>
explicitly before producing a <code>CancerEngine</code>.
</p>
<p>By contrast, the <code>ClinicalEngine</code> expects to use many fewer
features, so gives a simpler interface and uses its parameters to construct the
<code>CancerModel</code> for you. The &quot;HIT&quot; function will use 2 hits per subtype
when there are fewer than 15 features, 3 hits between 15 and 45 features,
and the older default of 5 hits when there are more than 45 features. The
total number of possible hits is set equal to the number of features (N) when
there are fewer than 12 features, approximately N/3 up to 50 features,
approximately N/5 up to 100, and is then locked at 20. If <code>isWeighted</code>
is <code>TRUE</code>, subtype prevalences are chosen from a Dirichlet
distribution. Otherwise, each subtype is equally likely.
</p>
<p>The <code>nrow</code> and <code>nComponents</code> methods both return
non-negative integer values describing the number of rows (features)
and the number of components of the underlying gene expression or
clinical data Engines. The <code>rand</code> method returns a matrix with
<code>n</code> columns of smiulated data.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Caitlin E. Coombes <a href="mailto:caitlin.coombes@osumc.edu">caitlin.coombes@osumc.edu</a>
</p>


<h3>References</h3>

<p>Zhang J, Coombes KR.<br />
<em>Sources of variation in false discovery rate estimation include
sample size, correlation, and inherent differences between groups.</em><br />
BMC Bioinformatics. 2012; 13 Suppl 13:S1. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CancerModel-class">CancerModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CancerEngine")
set.seed(391629)
## Set up survival outcome; baseline is exponential
sm &lt;- SurvivalModel(baseHazard=1/5, accrual=5, followUp=1)
## Build a CancerModel with 6 subtypes
nBlocks &lt;- 20    # number of possible hits
cm &lt;- CancerModel(name="cansim",
                  nPossible=nBlocks,
                  nPattern=6,
                  OUT = function(n) rnorm(n, 0, 1), 
                  SURV= function(n) rnorm(n, 0, 1),
                  survivalModel=sm)
## Include 100 blocks/pathways that are not hit by cancer
nTotalBlocks &lt;- nBlocks + 100
## Assign values to hyperparameters
## block size
blockSize &lt;- round(rnorm(nTotalBlocks, 100, 30))
## log normal mean hypers
mu0    &lt;- 6
sigma0 &lt;- 1.5
## log normal sigma hypers
rate   &lt;- 28.11
shape  &lt;- 44.25
## block corr
p &lt;- 0.6
w &lt;- 5
## Set up the baseline Engine
rho &lt;- rbeta(nTotalBlocks, p*w, (1-p)*w)
base &lt;- lapply(1:nTotalBlocks,
               function(i) {
                 bs &lt;- blockSize[i]
                 co &lt;- matrix(rho[i], nrow=bs, ncol=bs)
                 diag(co) &lt;- 1
                 mu &lt;- rnorm(bs, mu0, sigma0)
                 sigma &lt;- matrix(1/rgamma(bs, rate=rate, shape=shape), nrow=1)
                 covo &lt;- co *(t(sigma) %*% sigma)
                 MVN(mu, covo)
               })
eng &lt;- Engine(base)
## Alter the means if there is a hit
altered &lt;- alterMean(eng, normalOffset, delta=0, sigma=1)
## Build the CancerEngine using character strings
object &lt;- CancerEngine(cm, "eng", "altered")
## Or build it using the actual Engine components
ob &lt;- CancerEngine(cm, eng, altered)
summary(object)
summary(ob)
## Simulate the data
dset &lt;- rand(object, 20)
summary(dset$clinical)
summary(dset$data[, 1:3])
</code></pre>

<hr>
<h2 id='CancerModel-class'>The &quot;CancerModel&quot; Class</h2><span id='topic+CancerModel-class'></span><span id='topic+CancerModel'></span><span id='topic+ncol+2CCancerModel-method'></span><span id='topic+nrow+2CCancerModel-method'></span><span id='topic+rand+2CCancerModel-method'></span><span id='topic+summary+2CCancerModel-method'></span><span id='topic+nPatterns'></span><span id='topic+nPossibleHits'></span><span id='topic+nHitsPerPattern'></span><span id='topic+survivalCoefficients'></span><span id='topic+outcomeCoefficients'></span>

<h3>Description</h3>

<p>A <code>CancerModel</code> object contains a number of pieces of information
representing an abstract, heterogeneous collection of cancer patients.
It can be used to simulate patient outcome data linked to hit classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CancerModel(name,
            nPossible,
            nPattern,
            HIT = function(n) 5,
            SURV = function(n) rnorm(n, 0, 0.3),
            OUT = function(n) rnorm(n, 0, 0.3),
            survivalModel=NULL,
            prevalence=NULL)
nPatterns(object)
nPossibleHits(object)
nHitsPerPattern(object)
outcomeCoefficients(object)
survivalCoefficients(object)
## S4 method for signature 'CancerModel'
ncol(x)
## S4 method for signature 'CancerModel'
nrow(x)
## S4 method for signature 'CancerModel'
rand(object, n, balance = FALSE, ...)
## S4 method for signature 'CancerModel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CancerModel-class_+3A_name">name</code></td>
<td>
<p>character string specifying name given to this model</p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_object">object</code>, <code id="CancerModel-class_+3A_x">x</code></td>
<td>
<p>object of class <code>CancerModel</code></p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_npossible">nPossible</code></td>
<td>
<p>integer scalar specifying number of potential hits relevant
to the kind of cancer being modeled</p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_npattern">nPattern</code></td>
<td>
<p>integer scalar specifying number of different cancer subtypes</p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_hit">HIT</code></td>
<td>
<p>function that generates non-negative integers from a discrete
distribution. Used to determine the number of hits actually present in each
cancer subtype.</p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_surv">SURV</code></td>
<td>
<p>function that generates real numbers from a continuous
distributions. Used in simulations to select the coefficients associated
with each hit in Cox proportional hazards models.</p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_out">OUT</code></td>
<td>
<p>function that generates real numbers from a continuous
distributions. Used in simulations to select the coefficients associated
with each hit in logistic models of a binary outcome.</p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_survivalmodel">survivalModel</code></td>
<td>
<p>object of class <code>SurvivalModel</code> used to simulate
survival times for each simulated patient</p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_prevalence">prevalence</code></td>
<td>
<p>optional numeric vector of relative prevalences of cancer
subtypes</p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_n">n</code></td>
<td>
<p>numeric scalar specifying quantity of random numbers</p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_balance">balance</code></td>
<td>
<p>logical scalar specifying how patients should be simulated</p>
</td></tr>
<tr><td><code id="CancerModel-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rand</code> method is the most important method for objects of this
class.  It returns a data frame with four columns: the
<code>CancerSubType</code> (as an integer that indexes into the
<code>hitPattern</code> slot of the object), a binary <code>Outcome</code> that
takes on values <code>"Bad"</code> or <code>"Good"</code>, an <code>LFU</code> column
with censored survival times, and a logical <code>Event</code> column that
describes whether the simulated survival event has occurred.
</p>
<p>The <code>rand</code> method for the <code>CancerModel</code> class adds an extra
logical parameter, <code>balance</code>, to the signature specified by the
default method.  If <code>balance = FALSE</code> (the default), then
patients are simulated based on the <code>prevalence</code> defined as part
of the model.   If <code>balance = TRUE</code>, then patients are simulated
with equal numbers in each hit pattern class, ordered by the hit
pattern class.
</p>


<h3>Value</h3>

<p>The <code>CancerModel</code> function is used to contruct and return an object of
the <code>CancerModel</code> class.
</p>
<p>The <code>ncol</code> and <code>nrow</code> functions return integers with the size of
the matrix of hit patterns.
</p>
<p>The <code>rand</code> method returns data frame with four columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>CancerSubType</code> </td><td style="text-align: left;"> integer index into object's 'hitPattern' slot </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Outcome</code> </td><td style="text-align: left;"> outcomes with values "Bad" or "Good" </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>LFU</code>     </td><td style="text-align: left;"> censored survival times </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Event</code>   </td><td style="text-align: left;"> has simulated survival event has occurred? </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Objects from the Class</h3>

<p>Although objects of the class can be created by a direct call to
<a href="methods.html#topic+new">new</a>, the preferred method is to use the
<code>CancerModel</code> generator function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>hitPattern</code>:</dt><dd><p>Object of class <code>"matrix"</code></p>
</dd>
<dt><code>survivalBeta</code>:</dt><dd><p>Object of class <code>"numeric"</code>
containing the coeffieicents associated with each hit in a
Cox proportional hazards model of survival.</p>
</dd>
<dt><code>outcomeBeta</code>:</dt><dd><p>Object of class <code>"numeric"</code>
containing the coefficients associated with each hit in a logistic
model to predict a binary outcome.</p>
</dd>
<dt><code>prevalence</code>:</dt><dd><p>Object of class <code>"numeric"</code>
containing the prevalence of each cancer subtype. </p>
</dd>
<dt><code>survivalModel</code>:</dt><dd><p>Object of class <code>"survivalModel"</code>
containing parameters used to simualte survival times. </p>
</dd>
<dt><code>call</code>:</dt><dd><p>object of class <code>"call"</code> recording the
function call used to initialize the object.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>ncol</dt><dd><p><code>signature(x = "CancerModel")</code>: ... </p>
</dd>
<dt>nrow</dt><dd><p><code>signature(x = "CancerModel")</code>: ... </p>
</dd>
<dt>rand</dt><dd><p><code>signature(object = "CancerModel")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "CancerModel")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
</p>


<h3>References</h3>

<p>Zhang J, Coombes KR.<br />
<em>Sources of variation in false discovery rate estimation include
sample size, correlation, and inherent differences between groups.</em><br />
BMC Bioinformatics. 2012; 13 Suppl 13:S1. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SurvivalModel-class">SurvivalModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CancerModel")
set.seed(391629)
# set up survival outcome; baseline is exponential
sm &lt;- SurvivalModel(baseHazard=1/5, accrual=5, followUp=1)
# now build a CancerModel with 6 subtypes
cm &lt;- CancerModel(name="cansim",
                  nPossible=20,
                  nPattern=6,
                  OUT = function(n) rnorm(n, 0, 1), 
                  SURV= function(n) rnorm(n, 0, 1),
                  survivalModel=sm)
# simulate 100 patients
clinical &lt;- rand(cm, 100)
summary(clinical)
</code></pre>

<hr>
<h2 id='ClinicalNoiseModel'>
A Noise Model for Clinical Data
</h2><span id='topic+ClinicalNoiseModel'></span>

<h3>Description</h3>

<p>A <code>ClinicalNoiseModel</code> represents the additional human and measurement 
noise that is layered on top of any biological variabilty when measuring 
clinical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClinicalNoiseModel(nFeatures, shape = 1.02, scale = 0.05/shape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClinicalNoiseModel_+3A_nfeatures">nFeatures</code></td>
<td>
<p>An integer; the number of additive scale parameters
to sample from the gamma distribution.
</p>
</td></tr>
<tr><td><code id="ClinicalNoiseModel_+3A_shape">shape</code></td>
<td>

<p>The <code>shape</code> gamma hyperparameter describing the standard 
deviation of additive noise.
</p>
</td></tr>
<tr><td><code id="ClinicalNoiseModel_+3A_scale">scale</code></td>
<td>

<p>The <code>scale</code> gamma hyperparameter describing the standard 
deviation of additive noise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We model both additive and multiplicative noise, so that the observed
expression of clinical variable <var>c</var> in sample <var>i</var> is given by:
<code class="reqn">Y_ci = S_ci + E_ci</code>, where <var>Y_ci</var> = observed expression,
<var>S_ci</var> = true biological signal.
In the ClinicalNoiseModel (as opposed to the <code><a href="#topic+NoiseModel">NoiseModel</a></code>), 
we model the additive noise as <code class="reqn">E_ci ~ N(0,tau)</code>, 
without multiplicative noise or an additive bias/offset in the clinical model. 
The standard deviation hyperparameters of the additive noise <var>tau</var> 
is modeled by the gamma distribution <code class="reqn">tau ~ Gamma(shape, scale)</code>
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+NoiseModel">NoiseModel</a></code>.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Caitlin E. Coombes <a href="mailto:caitlin.coombes@osumc.edu">caitlin.coombes@osumc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NoiseModel-class">NoiseModel-class</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("NoiseModel")

## generate a ClinicalEngine with 20 features and 4 clusters
ce &lt;- ClinicalEngine(20, 4, TRUE)
## generate 300 simulated patients
set.seed(194718)
dset &lt;- rand(ce, 300)

cnm &lt;- ClinicalNoiseModel(nrow(ce@localenv$eng), shape=2, scale=0.1)
cnm

noisy &lt;- blur(cnm, dset$data)
hist(noisy)
</code></pre>

<hr>
<h2 id='Engine-class'>The &quot;Engine&quot; Class</h2><span id='topic+Engine-class'></span><span id='topic+Engine'></span><span id='topic+alterMean+2CEngine-method'></span><span id='topic+alterSD+2CEngine-method'></span><span id='topic+nrow+2CEngine-method'></span><span id='topic+rand+2CEngine-method'></span><span id='topic+summary+2CEngine-method'></span><span id='topic+nComponents+2CEngine-method'></span>

<h3>Description</h3>

<p>The <code>Engine</code> class is a tool (i.e., an algorithm) used to simulate
vectors of gene expression from some underlying distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Engine(components)
## S4 method for signature 'Engine'
nComponents(object, ...)
## S4 method for signature 'Engine'
alterMean(object, TRANSFORM, ...)
## S4 method for signature 'Engine'
alterSD(object, TRANSFORM, ...)
## S4 method for signature 'Engine'
nrow(x)
## S4 method for signature 'Engine'
rand(object, n, ...)
## S4 method for signature 'Engine'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Engine-class_+3A_components">components</code></td>
<td>
<p>object of class <code>list</code>, each element of which
contains the parameters for the underlying distribution that the
gene expression follows. A component can be viewed as a special case
of an engine that only has one component.</p>
</td></tr>
<tr><td><code id="Engine-class_+3A_object">object</code>, <code id="Engine-class_+3A_x">x</code></td>
<td>
<p>object of class <code>Engine</code></p>
</td></tr>
<tr><td><code id="Engine-class_+3A_transform">TRANSFORM</code></td>
<td>
<p>function takes as its input a vector of mean expression
or standard deviation and returns a transformed vector that can be used
to alter the appropriate slot of the object.</p>
</td></tr>
<tr><td><code id="Engine-class_+3A_n">n</code></td>
<td>
<p>numeric scalar representing number of samples to be simulated</p>
</td></tr>
<tr><td><code id="Engine-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases, an engine object is an instantiation of a more general
family or class that we call an ABSTRACT ENGINE. Every abstract engine
is an ordered list of components, which can also be thought of as an
engine with parameters. We instantiate an engine by binding all the
free parameters of an abstract engine to actual values. Note that
partial binding (of a subset of the free parameters) produces another
abstract engine.
</p>
<p>For all practical purposes, a COMPONENT should be viewed as an
irreducible abstract engine. Every component must have an IDENTIFIER
that is unique within the context of its enclosing abstract engine.
The identifer may be implicitly taken to be the position of the
component in the ordered list.
</p>
<p>We interpret an <code>Engine</code> as the gene expression generator for a
homogenous population; effects of cancer on gene expression are modeled
at a higher level.
</p>


<h3>Value</h3>

<p>The <code>Engine</code> generator returns an object of class <code>Engine</code>.
</p>
<p>The <code>alterMean</code> method returns an object of class <code>Engine</code> with
altered mean.
</p>
<p>The <code>alterSD</code> method returns an object of class <code>Engine</code> with
altered standard deviation.
</p>
<p>The <code>nrow</code> method returns the number of genes (i.e, the length of the
vector) the <code>Engine</code> object will generate.
</p>
<p>The <code>rand</code> method returns <code class="reqn">nrow(Engine)*n</code> matrix representing the
expressions of <code>nrow(Engine)</code> genes and <code>n</code> samples.
</p>
<p>The <code>summary</code> method prints out the number of components included
in the <code>Engine</code> object.
</p>
<p>The <code>nComponents</code> method returns the number of components in the
<code>Engine</code> object.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Engine",
    components=components)</code>, or use the <code>Engine</code> generator function.
Every engine is an ordered list of components, which generates a contiguous
subvector of the total vector of gene expression.
</p>


<h3>Methods</h3>


<dl>
<dt>alterMean(object, TRANSFORM, ...)</dt><dd><p>Takes an object of class
<code>Engine</code>, loops over the components in the <code>Engine</code>, alters
the mean as defined by <code>TRANSFORM</code> function, and returns a modified
object of class <code>Engine</code>.</p>
</dd>
<dt>alterSD(object, TRANSFORM, ...)</dt><dd><p>Takes an object of class
<code>Engine</code>, loops over the components in the <code>Engine</code>, alters
the standard deviation as defined by <code>TRANSFORM</code> function, and
returns a modified object of class <code>Engine</code>.</p>
</dd>
<dt>nrow(x)</dt><dd><p>Counts the total number of genes (i.e, the
length of the vector the <code>Engine</code> will generate).</p>
</dd>
<dt>rand(object, n, ...)</dt><dd><p>Generates <code class="reqn">nrow(Engine)*n</code> matrix
representing gene expressions of <code>n</code> samples following the
underlying distribution captured in the object of <code>Engine</code>.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Prints out the number of components included
in the object of <code>Engine</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jiexin Zhang <a href="mailto:jiexinzhang@mdanderson.org">jiexinzhang@mdanderson.org</a>,
</p>


<h3>References</h3>

<p>Zhang J, Coombes KR.<br />
<em>Sources of variation in false discovery rate estimation include
sample size, correlation, and inherent differences between groups.</em><br />
BMC Bioinformatics. 2012; 13 Suppl 13:S1. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EngineWithActivity-class">EngineWithActivity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Engine")
nComp &lt;- 10
nGenes &lt;- 100
comp &lt;- list()
for (i in 1:nComp) {
  comp[[i]] &lt;- IndependentNormal(rnorm(nGenes/nComp, 6, 1.5),
                                 1/rgamma(nGenes/nComp, 44, 28))
}
myEngine &lt;- Engine(comp)
nrow(myEngine)
nComponents(myEngine)
summary(myEngine)
myData &lt;- rand(myEngine, 5)
dim(myData)
summary(myData)
OFFSET &lt;- 2
myEngine.alterMean &lt;- alterMean(myEngine, function(x){x+OFFSET})
myData.alterMean &lt;- rand(myEngine.alterMean, 5)
summary(myData.alterMean)
SCALE &lt;- 2
myEngine.alterSD &lt;- alterSD(myEngine, function(x){x*SCALE})
myData.alterSD &lt;- rand(myEngine.alterSD, 5)
summary(myData.alterSD)
</code></pre>

<hr>
<h2 id='EngineWithActivity-class'>The &quot;EngineWithActivity&quot; Class</h2><span id='topic+EngineWithActivity-class'></span><span id='topic+EngineWithActivity'></span><span id='topic+rand+2CEngineWithActivity-method'></span><span id='topic+summary+2CEngineWithActivity-method'></span>

<h3>Description</h3>

<p>The <code>EngineWithActivity</code> is used to set some components in the object
of class <code>Engine</code> to be transcriptionally inactive and transform the
expression data to appropriate logarithmic scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EngineWithActivity(active, components, base=2)
## S4 method for signature 'EngineWithActivity'
rand(object, n, ...)
## S4 method for signature 'EngineWithActivity'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EngineWithActivity-class_+3A_active">active</code></td>
<td>
<p>logical vector with length equal to number of components
specifying whether each component should be transcriptionally active, or
a numeric scalar specifying the probability for a component to be active</p>
</td></tr>
<tr><td><code id="EngineWithActivity-class_+3A_components">components</code></td>
<td>
<p>list where each element contains the parameters for the
underlying distribution that the gene expression follows</p>
</td></tr>
<tr><td><code id="EngineWithActivity-class_+3A_base">base</code></td>
<td>
<p>numeric scalar specifying the logarithmic scale to which the
data should be transformed</p>
</td></tr>
<tr><td><code id="EngineWithActivity-class_+3A_object">object</code></td>
<td>
<p>object of class <code>EngineWithActivity</code></p>
</td></tr>
<tr><td><code id="EngineWithActivity-class_+3A_n">n</code></td>
<td>
<p>number of samples to be simulated</p>
</td></tr>
<tr><td><code id="EngineWithActivity-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An ENGINE WITH ACTIVITY allows for the possibility that some
components (or genes) in an expression engine (or tissue) might be
transcriptionally inactive.  Thus, the true biological signal
S_gi should really be viewed as a mixture:
</p>
<p><code class="reqn">S_gi = z_g * delta_0 + (1 - z_g) * T_gi</code>
</p>
<p>where delta_0 = a point mass at zero;   
T_gi = a random variable supported on the positive real line;   
z_g ~ Binom(pi) defines the activity state (1 = on, 0 = off)
</p>
<p>The <code>rand</code> method for an EngineWithActivity is a little bit
tricky, since we do two things at once. First, we use the
<code>base</code> slot to exponentiate the random variables generated by
the underlying Engine on the log scale. We treat <code>base = 0</code> as
a special case, which means that we should continue to work on
the scale of the Engine. Second, we mask any inactive component
by replacing the generated values with <code>0</code>.
</p>
<p>Note that this is terribly inefficient if we only have a single
homogeneous population, since we generate a certain amount of
data only to throw it away.  The power comes when we allow
cancer disregulation to turn a block on or off, when the
underlying data reappears.
</p>


<h3>Value</h3>

<p>The <code>EngineWithActivity</code> generator returns an object of class
<code>EngineWithActivity</code>.
</p>
<p>The <code>rand</code> method returns <code class="reqn">nrow(EngineWithActivity)*n</code> gene
expression matrix with the inactive components being masked by <code>0</code>.
</p>
<p>The <code>summary</code> method prints out the total number of components and
the number of active components in the object of <code>EngineWithActivity</code>.
</p>


<h3>Objects from the Class</h3>

<p>Although objects of the class can be created by a direct call to
<a href="methods.html#topic+new">new</a>, the preferred method is to use the
<code>EngineWithActivity</code> generator function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>active</code>:</dt><dd><p>logical vector specifying whether each component
should be transcriptionally active or not</p>
</dd>
<dt><code>base</code>:</dt><dd><p>numeric scalar specifying the logarithmic scale</p>
</dd>
<dt><code>components</code>:</dt><dd><p>list specifying the parameters of the
underlying distribution</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+Engine-class">Engine</a></code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>rand(object, n, ...)</dt><dd><p>Generates nrow(EngineWithActivity)*n matrix
representing gene expressions of <code>n</code> samples, and the
transcriptionally inactive components are masked by <code>0</code>.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Prints out the total number of
components and the number of active components in the object
of <code>EngineWithActivity</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jiexin Zhang <a href="mailto:jiexinzhang@mdanderson.org">jiexinzhang@mdanderson.org</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("EngineWithActivity")
nComponents &lt;- 10
nGenes &lt;- 100
active &lt;- 0.7
comp &lt;- list()
for (i in 1:nComponents) {
  comp[[i]] &lt;- IndependentNormal(rnorm(nGenes/nComponents, 6, 1.5),
                                 1/rgamma(nGenes/nComponents, 44, 28))
}
myEngine &lt;- EngineWithActivity(active, comp, 2)
summary(myEngine)
myData &lt;- rand(myEngine, 5)
dim(myData)
</code></pre>

<hr>
<h2 id='IndependentLogNormal-class'>The &quot;IndependentLogNormal&quot; Class</h2><span id='topic+IndependentLogNormal-class'></span><span id='topic+IndependentLogNormal'></span><span id='topic+alterMean+2CIndependentLogNormal-method'></span><span id='topic+alterSD+2CIndependentLogNormal-method'></span><span id='topic+nrow+2CIndependentLogNormal-method'></span><span id='topic+rand+2CIndependentLogNormal-method'></span><span id='topic+summary+2CIndependentLogNormal-method'></span>

<h3>Description</h3>

<p>The <code>IndependentLogNormal</code> class is a tool used to generate gene
expressions that follow log normal distribution, because the true expression
value follows log normal in our model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndependentLogNormal(logmu,logsigma)
## S4 method for signature 'IndependentLogNormal'
alterMean(object, TRANSFORM, ...)
## S4 method for signature 'IndependentLogNormal'
alterSD(object, TRANSFORM, ...)
## S4 method for signature 'IndependentLogNormal'
nrow(x)
## S4 method for signature 'IndependentLogNormal'
rand(object, n, ...)
## S4 method for signature 'IndependentLogNormal'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IndependentLogNormal-class_+3A_logmu">logmu</code></td>
<td>
<p>numeric vector specifying the mean expression values on the
logarithmic scale.</p>
</td></tr>
<tr><td><code id="IndependentLogNormal-class_+3A_logsigma">logsigma</code></td>
<td>
<p>numeric vector specifying the standard deviation of the
gene expression values on the logarithmic scale</p>
</td></tr>
<tr><td><code id="IndependentLogNormal-class_+3A_object">object</code>, <code id="IndependentLogNormal-class_+3A_x">x</code></td>
<td>
<p>object of class <code>IndependentLogNormal</code></p>
</td></tr>
<tr><td><code id="IndependentLogNormal-class_+3A_transform">TRANSFORM</code></td>
<td>
<p>function that takes a vector of mean expression or
standard deviation and returns a transformed vector that can be used
to alter the appropriate slot of the object.</p>
</td></tr>
<tr><td><code id="IndependentLogNormal-class_+3A_n">n</code></td>
<td>
<p>numeric scalar specifying number of samples to be simulated</p>
</td></tr>
<tr><td><code id="IndependentLogNormal-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Although objects of the class can be created by a direct call to
<a href="methods.html#topic+new">new</a>, the preferred method is to use the
<code>IndependentLogNormal</code> generator function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>logmu</code>:</dt><dd><p>numeric vector containing the mean expression
values on the logarithmic scale</p>
</dd>
<dt><code>logsigma</code>:</dt><dd><p>numeric vector containing the standard deviation
of the gene expression values on the logarithmic scale</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>nrow(x)</dt><dd><p>Returns the number of genes (i.e, the length of the
<code>logmu</code> vector).</p>
</dd>
<dt>rand(object, n, ...)</dt><dd><p>Generates nrow(IndependentLogNormal)*n matrix
representing gene expressions of n samples following log normal
distribution captured in the object of <code>IndependentLogNormal</code>.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Prints out the number of independent log
normal random variables in the object of <code>IndependentLogNormal</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jiexin Zhang <a href="mailto:jiexinzhang@mdanderson.org">jiexinzhang@mdanderson.org</a>,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Engine-class">Engine</a></code>,
<code><a href="#topic+IndependentNormal-class">IndependentNormal</a></code>,
<code><a href="#topic+MVN-class">MVN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("IndependentLogNormal")
nGenes &lt;- 20
logmu &lt;- rnorm(nGenes, 6, 1)
logsigma &lt;- 1/rgamma(nGenes, rate=14, shape=6)
ln &lt;- IndependentLogNormal(logmu, logsigma)
nrow(ln)
summary(ln)
if (any(logmu - ln@logmu)) {
  print('means do not match')
} else {
  print('means verified')
}
if (any(logsigma - ln@logsigma)) {
  print('standard deviations do not match')
} else {
  print('sd verified')
}
x &lt;- rand(ln, 1000)
print(dim(x))
 
print(paste("'ln' should be valid:", validObject(ln)))
ln@logsigma &lt;- 1:3 # now we break it
print(paste("'ln' should not be valid:", validObject(ln, test=TRUE)))
tmp.sd &lt;- sqrt(apply(log(x), 1, var))
plot(tmp.sd, logsigma)
tmp.mu &lt;- apply(log(x), 1, mean)
plot(tmp.mu, logmu)
rm(nGenes, logmu, logsigma, ln, x, tmp.mu, tmp.sd)
</code></pre>

<hr>
<h2 id='IndependentNormal-class'>The &quot;IndependentNormal&quot; Class</h2><span id='topic+IndependentNormal-class'></span><span id='topic+IndependentNormal'></span><span id='topic+alterMean+2CIndependentNormal-method'></span><span id='topic+alterSD+2CIndependentNormal-method'></span><span id='topic+nrow+2CIndependentNormal-method'></span><span id='topic+rand+2CIndependentNormal-method'></span><span id='topic+summary+2CIndependentNormal-method'></span>

<h3>Description</h3>

<p>The <code>IndependentNormal</code> class is a tool used to generate gene
expressions that follow independent normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndependentNormal(mu,sigma)
## S4 method for signature 'IndependentNormal'
alterMean(object, TRANSFORM, ...)
## S4 method for signature 'IndependentNormal'
alterSD(object, TRANSFORM, ...)
## S4 method for signature 'IndependentNormal'
nrow(x)
## S4 method for signature 'IndependentNormal'
rand(object, n, ...)
## S4 method for signature 'IndependentNormal'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IndependentNormal-class_+3A_mu">mu</code></td>
<td>
<p>numeric vector specifying the mean expression values</p>
</td></tr>
<tr><td><code id="IndependentNormal-class_+3A_sigma">sigma</code></td>
<td>
<p>numeric vector specifying the standard deviation of the
gene expression values</p>
</td></tr>
<tr><td><code id="IndependentNormal-class_+3A_object">object</code>, <code id="IndependentNormal-class_+3A_x">x</code></td>
<td>
<p>object of class <code>IndependentNormal</code></p>
</td></tr>
<tr><td><code id="IndependentNormal-class_+3A_transform">TRANSFORM</code></td>
<td>
<p>function that takes a vector of mean expression or
standard deviation and returns a transformed vector that can be used
to alter the appropriate slot of the object.</p>
</td></tr>
<tr><td><code id="IndependentNormal-class_+3A_n">n</code></td>
<td>
<p>numeric scalar specifying number of samples to be simulated</p>
</td></tr>
<tr><td><code id="IndependentNormal-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that we typically work on expression value with its logarithm to
some appropriate base. That is, the independent normal should
be used on the logarithmic scale in order to construct the engine.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the <code>IndependentNormal</code> generator
function. The object of class <code>IndependentNormal</code> contains the mean
and standard deviation for the normal distribution
</p>


<h3>Slots</h3>


<dl>
<dt><code>mu</code>:</dt><dd><p>see corresponding argument above</p>
</dd>
<dt><code>sigma</code>:</dt><dd><p>see corresponding argument above</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>alterMean(object, TRANSFORM, ...)</dt><dd><p>Takes an object of class
<code>IndependentNormal</code>, loops over the <code>mu</code> slot, alters
the mean as defined by <code>TRANSFORM</code> function, and returns an
object of class <code>IndependentNormal</code> with altered <code>mu</code>.</p>
</dd>
<dt>alterSD(object, TRANSFORM, ...)</dt><dd><p>Takes an object of class
<code>IndependentNormal</code>, loops over the <code>sigma</code> slot, alters
the standard deviation as defined by <code>TRANSFORM</code> function, and
returns an object of class <code>IndependentNormal</code> with altered
<code>sigma</code>.</p>
</dd>
<dt>nrow(x)</dt><dd><p>Returns the number of genes (i.e, the length of the
<code>mu</code> vector).</p>
</dd>
<dt>rand(object, n, ...)</dt><dd><p>Generates <code class="reqn">nrow(IndependentNormal)*n</code>
matrix representing gene expressions of <code>n</code> samples following the
normal distribution captured in the object of <code>IndependentNormal</code>.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Prints out the number of independent normal
random variables in the object of <code>IndependentNormal</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jiexin Zhang <a href="mailto:jiexinzhang@mdanderson.org">jiexinzhang@mdanderson.org</a>,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Engine-class">Engine</a></code>,
<code><a href="#topic+IndependentLogNormal-class">IndependentLogNormal</a></code>,
<code><a href="#topic+MVN-class">MVN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("IndependentNormal")
nGenes &lt;- 20
mu &lt;- rnorm(nGenes, 6, 1)
sigma &lt;- 1/rgamma(nGenes, rate=14, shape=6)
ind &lt;- IndependentNormal(mu, sigma)
nrow(ind)
summary(ind)
if (any(mu - ind@mu)) {
  print('means do not match')
} else {
  print('means verified')
}
if (any(sigma - ind@sigma)) {
  print('standard deviations do not match')
} else {
  print('sd verified')
}
x &lt;- rand(ind, 3)
print(dim(x))
print(summary(x))
print(paste("'ind' should be valid:", validObject(ind)))
ind@sigma &lt;- 1:3 # now we break it
print(paste("'ind' should not be valid:", validObject(ind, test=TRUE)))
rm(nGenes, mu, sigma, ind, x)
</code></pre>

<hr>
<h2 id='makeDataTypes'>
Discretize a Continuous Data Set to Mixed Types
</h2><span id='topic+makeDataTypes'></span><span id='topic+getDataTypes'></span><span id='topic+getDaisyTypes'></span>

<h3>Description</h3>

<p>The makeDataTypes function allows the user to discretize a continuous data set
generated from an engine of any type into binary, nominal, ordinal, or mixed-type data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDataTypes(dataset, pCont, pBin, pCat, pNominal = 0.5,
             range = c(3, 9), exact = FALSE, inputRowsAreFeatures = TRUE)
getDataTypes(object)
getDaisyTypes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDataTypes_+3A_dataset">dataset</code></td>
<td>
<p>A matrix or dataframe of continuous data.</p>
</td></tr>
<tr><td><code id="makeDataTypes_+3A_pcont">pCont</code></td>
<td>

<p>Non-negative, numeric probability equal to or between 0 and 1
describing desired percent frequency of continuous features.
</p>
</td></tr>
<tr><td><code id="makeDataTypes_+3A_pbin">pBin</code></td>
<td>

<p>Non-negative, numeric probability equal to or between 0 and 1
describing desired percent frequency of binary features.
</p>
</td></tr>
<tr><td><code id="makeDataTypes_+3A_pcat">pCat</code></td>
<td>

<p>Non-negative, numeric probability equal to or between 0 and 1
describing desired percent frequency of categorical features.
</p>
</td></tr>
<tr><td><code id="makeDataTypes_+3A_pnominal">pNominal</code></td>
<td>

<p>Non-negative, numeric probability equal to or between 0 and 1
describing desired percent frequency of categorical features to
be simulated as nominal.
</p>
</td></tr>
<tr><td><code id="makeDataTypes_+3A_range">range</code></td>
<td>

<p>A set of integers whose minimum and maximum determine the range of
the number of levels to be associated with simulated  categorical
factors.
</p>
</td></tr>
<tr><td><code id="makeDataTypes_+3A_exact">exact</code></td>
<td>

<p>A logical value; should the parameters <code>pCont</code>, <code>pBin</code>
and <code>pCat</code> be treated  as exact fractions to achieve or as
probabilities.
</p>
</td></tr>
<tr><td><code id="makeDataTypes_+3A_inputrowsarefeatures">inputRowsAreFeatures</code></td>
<td>

<p>Logical value indicating if features are to be simulated as rows 
(TRUE) or columns (FALSE).
</p>
</td></tr>
<tr><td><code id="makeDataTypes_+3A_object">object</code></td>
<td>
<p>An object of the <code>MixedTypeEngine</code> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>makeDataTypes</code> function is a critical step in the
construction of a <code><a href="#topic+MixedTypeEngine">MixedTypeEngine</a></code>, which is an object
that is used to simulate clinical mixed-type data instead of gene
expression data. The standard process, as illustrated in the example,
involves (1) creating a <code><a href="#topic+ClinicalEngine">ClinicalEngine</a></code>, (2) generating a
random data set from that engine, (3) adding noise, (4) setting the
data types, and finally (5) creating the <code>MixedTypeEngine</code>.
</p>
<p>The main types of data (continuous, binary, or categorical) are
randomly assigned using the probability parameters <code>pCont</code>,
<code>pBin</code>, and <code>pCat</code>. To choose the splitting point for the
binary features, we compute the bimodality index (Wang et al.). If that
is significant, we split the data halfway between the two
modes. Otherwise, we choose a random split point between 5% and
35%. Categorical data is also randomly assigned to ordinal or nominal
based on the <code>pNominal</code> parameter. The number of levels is
uniformly selected in the specified <code>range</code>, and the fraction of
data points assigned to each level is selected from a Dirichlet
distribution with alpha = c(20, 20, ..., 20).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>binned</code></td>
<td>
<p>An object of class data.frame of simulated, mixed-type data.</p>
</td></tr>
<tr><td><code>cutpoints</code></td>
<td>

<p>An object of class &quot;list&quot;. For each feature, data type, labels (if data are 
binary or categorical), and break points (if data are binary or categorical) 
are stored. Cutpoints can be passed to a <code><a href="#topic+MixedTypeEngine">MixedTypeEngine</a></code> 
for storage and downstream use.
</p>
</td></tr>
</table>
<p>The <code>getDataTypes</code> function returns a character vector listing
the type of data for each feature in a <code>MixedTypeEngine</code>. the
<code>getDaisyTypes</code> function converts this vector to a list suitable
for input to the <code><a href="cluster.html#topic+daisy">daisy</a></code> function in the <code>cluster</code>
package.
</p>


<h3>Note</h3>

<p>If <code>pCont</code>, <code>pBin</code>, and <code>pCat</code> do not sum to 1, they will be rescaled.
</p>
<p>By default, categorical variables are simulated as a mixture of nominal
and ordinal data. The remaining categorical features described by
<code>pNominal</code> are simulated as ordinal.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Caitlin E. Coombes <a href="mailto:caitlin.coombes@osumc.edu">caitlin.coombes@osumc.edu</a>
</p>


<h3>References</h3>

<p>Wang J, Wen S, Symmans WF, Pusztai L, Coombes KR. <br /><em>The bimodality index: A criterion for discovering and ranking bimodal signatures from cancer gene expression profiling data.</em><br /> Cancer Inform 2009; 7:199-216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixedTypeEngine">MixedTypeEngine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a ClinicalEngine with 4 clusters
ce &lt;- ClinicalEngine(20, 4, TRUE)

## Generate continuous data
set.seed(194718)
dset &lt;- rand(ce, 300)

## Add noise before binning mixed type data
cnm &lt;- ClinicalNoiseModel(nrow(ce@localenv$eng)) # default
noisy &lt;- blur(cnm, dset$data)

## Set the data mixture
dt &lt;- makeDataTypes(dset$data, 1/3, 1/3, 1/3, 0.3)
cp &lt;- dt$cutpoints
type &lt;- sapply(cp, function(X) { X$Type })
table(type)
summary(dt$binned)

## Use the pieces from above to create an MTE.
mte &lt;- MixedTypeEngine(ce,
           noise = cnm,
           cutpoints = dt$cutpoints)
## and generate some data with the same data types and cutpoints
R &lt;- rand(mte, 20)
summary(R)
</code></pre>

<hr>
<h2 id='MixedTypeEngine-class'>The &quot;MixedTypeEngine&quot; Class</h2><span id='topic+MixedTypeEngine-class'></span><span id='topic+MixedTypeEngine'></span><span id='topic+rand+2CMixedTypeEngine-method'></span><span id='topic+summary+2CMixedTypeEngine-method'></span>

<h3>Description</h3>

<p>A MixedTypeEngine combines a ClinicalEngine (which defines the combinatorics
of hits and block hyperparameters that determine cluster identities and behavior),
a stored <code><a href="#topic+ClinicalNoiseModel">ClinicalNoiseModel</a></code>, and cutpoints for generating mixed type
data generated by <code><a href="#topic+makeDataTypes">makeDataTypes</a></code> into an object that can be used to
re-generate downstream datasets with shared parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixedTypeEngine(ce, noise, cutpoints)
## S4 method for signature 'MixedTypeEngine'
rand(object, n, keepall = FALSE, ...)
## S4 method for signature 'MixedTypeEngine'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixedTypeEngine-class_+3A_ce">ce</code></td>
<td>
<p>Object of class <code>ClinicalEngine</code> (or a list; see Details).</p>
</td></tr>
<tr><td><code id="MixedTypeEngine-class_+3A_noise">noise</code></td>
<td>
<p>Object of class <code>NoiseModel</code>, preferably constructed
using the function <code>ClinicalNoiseModel</code>. Alternatively, a list;
see Details.</p>
</td></tr>
<tr><td><code id="MixedTypeEngine-class_+3A_cutpoints">cutpoints</code></td>
<td>
<p>a list with the properties of the <code>cutpoints</code>
element produced by the function <code>makeDataTypes</code>. Alternatively,
a list; see Details. </p>
</td></tr>
<tr><td><code id="MixedTypeEngine-class_+3A_object">object</code></td>
<td>
<p>object of class <code>MixedTypeEngine</code></p>
</td></tr>
<tr><td><code id="MixedTypeEngine-class_+3A_n">n</code></td>
<td>
<p>a non-negative integer</p>
</td></tr>
<tr><td><code id="MixedTypeEngine-class_+3A_keepall">keepall</code></td>
<td>
<p>a logical value</p>
</td></tr>
<tr><td><code id="MixedTypeEngine-class_+3A_...">...</code></td>
<td>
<p>additional arguments for generic functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MixedTypeEngine is a device for a parameter set used to generate 
a simulated set of clinical data which can be used to store these parameters
and to generate related datasets downstream. Building a MixedTypeEngine
requires many parameters. You can supply these parameters in mutliple
steps:
</p>

<ol>
<li><p> Construct a <code>ClinicalEngine</code>.
</p>
</li>
<li><p> Contruct a <code>ClinicalNoiseModel</code>.
</p>
</li>
<li><p> Use <code>rand</code>rand to generate a &quot;raw&quot; data set from the
<code>ClinicalEngine</code>.
</p>
</li>
<li><p> Use <code>blur</code> to add noise to the raw data.
</p>
</li>
<li><p> Feed the noisy data into <code>makeDataTypes</code> to generate a
mixed-type dataset, with cut points.
</p>
</li>
<li><p> Pass the <code>ClinicalEngine</code>, <code>ClinicalNoiseModel</code>, and
cutpoints into the <code>MixedTypeEngine</code> constructor.
</p>
</li></ol>

<p>The alternative method is to pass the parameters for Steps 1, 2, and 5
directly into the <code>MixedTypeEngine</code> directly, as lists, and it will
carry out steps 3-5 automatically. Note, however, that instead of
passing a <code>dataset</code> to be used by the <code>makeDataTypes</code> function,
you instead set the value of <code>N</code> to the desired number of patients
used during construction. Also, if you use the explicit steps, you
can save the intermediate data sets that are generated. If you simply
pass all of the parameters to the constructor, those intermediate data
sets are discarded, and you must generate a new data set using
<code>rand</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by a direct call to
<a href="methods.html#topic+new">new</a>, though using the constructor
<code>MixedTypeEngine</code> is preferred.
</p>


<h3>Methods</h3>


<dl>
<dt>rand(object, n, keepall, ...)</dt><dd><p>Generates <code class="reqn">nrow(Engine)*n</code> matrix
representing clinical features of <code>n</code> patients following the
underlying distribution, noise, and data discretization pattern
captured in the object of <code>MixedTypeEngine</code>. If <code>keepall
      == TRUE</code>, it reurns a list containing a data frame named
<code>clinical</code> and three data matrices called <code>raw</code>,
<code>noisy</code>, and <code>binned</code>. If <code>keepall == FALSE</code>, then
noly the <code>clinical</code> and <code>binned</code> components are returned.</p>
</dd>
</dl>

<dl>
<dt>summary(object, ...)</dt><dd><p>Prints a summary of the object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Caitlin E. Coombes <a href="mailto:caitlin.coombes@osumc.edu">caitlin.coombes@osumc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Engine-class">Engine</a></code>
<code><a href="#topic+CancerModel-class">CancerModel</a></code>
<code><a href="#topic+CancerEngine-class">CancerEngine</a></code>
<code><a href="#topic+ClinicalNoiseModel">ClinicalNoiseModel</a></code>
<code><a href="#topic+makeDataTypes">makeDataTypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a Clinical Engine of continuous data 
## with clusters generated from variation on the base CancerEngine
ce &lt;- ClinicalEngine(20, 4, TRUE)
summary(ce)

## Generate an initial data set
set.seed(194718)
dset &lt;- rand(ce, 300)
class(dset)
names(dset)
summary(dset$clinical)
dim(dset$data)

## Add noise before binning mixed type data
cnm &lt;- ClinicalNoiseModel(nrow(ce@localenv$eng)) # default
noisy &lt;- blur(cnm, dset$data)

## Set the data mixture
dt &lt;- makeDataTypes(dset$data, 1/3, 1/3, 1/3, 0.3)
## Store the cutpoints
cp &lt;- dt$cutpoints

## Use the pieces from above to create an MTE.
mte &lt;- MixedTypeEngine(ce,
           noise = cnm,
           cutpoints = dt$cutpoints)

## Use the MTE rand method to generate
## multiple data sets with the same parameters
R &lt;- rand(mte, 20)
summary(R)

S &lt;- rand(mte, 20)
summary(S)
</code></pre>

<hr>
<h2 id='MVN-class'>The &quot;MVN&quot; Class</h2><span id='topic+MVN-class'></span><span id='topic+MVN'></span><span id='topic+alterMean+2CMVN-method'></span><span id='topic+alterSD+2CMVN-method'></span><span id='topic+nrow+2CMVN-method'></span><span id='topic+rand+2CMVN-method'></span><span id='topic+summary+2CMVN-method'></span><span id='topic+covar'></span><span id='topic+correl'></span>

<h3>Description</h3>

<p>The <code>MVN</code> class is a tool used to generate gene expressions that
follow multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MVN(mu, Sigma, tol = 1e-06)
covar(object)
correl(object)
## S4 method for signature 'MVN'
alterMean(object, TRANSFORM, ...)
## S4 method for signature 'MVN'
alterSD(object, TRANSFORM, ...)
## S4 method for signature 'MVN'
nrow(x)
## S4 method for signature 'MVN'
rand(object, n, ...)
## S4 method for signature 'MVN'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVN-class_+3A_mu">mu</code></td>
<td>
<p>numeric vector representing <var>k</var>-dimensional means</p>
</td></tr>
<tr><td><code id="MVN-class_+3A_sigma">Sigma</code></td>
<td>
<p>numeric <var>k</var>-by-<var>k</var> covariance matrix containing the
measurement of the linear coupling between every pair of random vectors</p>
</td></tr>
<tr><td><code id="MVN-class_+3A_tol">tol</code></td>
<td>
<p>numeric scalar roundoff error that will be tolerated when
assessing the singularity of the covariance matrix</p>
</td></tr>
<tr><td><code id="MVN-class_+3A_object">object</code>, <code id="MVN-class_+3A_x">x</code></td>
<td>
<p>object of class <code>MVN</code></p>
</td></tr>
<tr><td><code id="MVN-class_+3A_transform">TRANSFORM</code></td>
<td>
<p>function that takes a vector of mean expression or
standard deviation and returns a transformed vector that can be used
to alter the appropriate slot of the object.</p>
</td></tr>
<tr><td><code id="MVN-class_+3A_n">n</code></td>
<td>
<p>numeric scalar representing number of samples to be simulated</p>
</td></tr>
<tr><td><code id="MVN-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of <code>MVN</code> class is designed for efficiency when
generating new samples, since we expect to do this several times.
Basically, this class separates the <code>mvrnorm</code> function from the
<span class="pkg">MASS</span> package into several steps. The computationally expensive step
(when the dimension is large) is the eigenvector decomposition of the
covariance matrix. This step is performed at construction and the
pieces are stored in the object. The <code>rand</code> method for <code>MVN</code>
objects contains the second half of the <code>mvrnorm</code> function.
</p>
<p>Note that we typically work on expression values after taking the
logarithm to some appropriate base. That is, the multivariate normal
should be used on the logarithmic scale in order to contruct an engine.
</p>
<p>The <code>alterMean</code> method for an <code>MVN</code> simply replaces the appropriate slot by
the transformed vector. The <code>alterSD</code> method for an <code>MVN</code> is trickier,
because of the way the data is stored. In order to have some hope of getting
this correct, we work in the space of the covariance matrix, <var>Sigma</var>.
If we let <var>R</var> denote the correlation matrix and let <var>Delta</var> be the
diagonal matrix whose entries are the individual standard deviations, then
<code class="reqn">Sigma = Delta \%*\% R \%*\% Delta</code>.
So, we can change the standard deviations by replacing <var>Delta</var> in this
product. We then construct a new <code>MVN</code> object with the old mean vector
and the new covariance matrix.
</p>
<p>The <code>covar</code> and <code>correl</code> functions, respectively, calculate
the covariance matrix and correlation matrix that underly the
covariance matrix for the objects of class <code>MVN</code>. We have four
assertions as shown below, which are tested in the examples section:
</p>

<ol>
<li> <p><code>covar</code> should return the same matrix that was used
in the function call to construct the <code>MVN</code> object.
</p>
</li>
<li><p> After applying an <code>alterMean</code> method, the
covariance matrix is unchanged.
</p>
</li>
<li><p> The diagonal of the correlation matrix consists of all ones.
</p>
</li>
<li><p> After applying an <code>alterMean</code> or an <code>alterSD</code> method, the
correlation matrix is unchanged.
</p>
</li></ol>



<h3>Objects from the Class</h3>

<p>Although objects of the class can be created by a direct call to
<a href="methods.html#topic+new">new</a>, the preferred method is to use the
<code>MVN</code> generator function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mu</code>:</dt><dd><p>numeric vector containing the k-dimensional means</p>
</dd>
<dt><code>lambda</code>:</dt><dd><p>numeric vector containing the square roots of
the eigenvalues of the covariance matrix</p>
</dd>
<dt><code>half</code>:</dt><dd><p>numeric matrix with <code class="reqn">k*k</code> dimensions whose
columns contain the eigenvectors of the covariance matrix</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>alterMean(object, TRANSFORM, ...)</dt><dd><p>Takes an object of class
<code>MVN</code>, loops over the <code>mu</code> slot, alters the mean as defined
by TRANSFORM function, and returns an object of class <code>MVN</code> with
altered <code>mu</code>.</p>
</dd>
<dt>alterSD(object, TRANSFORM, ...)</dt><dd><p>Takes an object of class
<code>MVN</code>, works on the diagonal matrix of the covariance matrix, alters
the standard deviation as defined by TRANSFORM function, and reconstructs
an object of class <code>MVN</code> with the old <code>mu</code> and
reconstructed covariance matrix.</p>
</dd>
<dt>nrow(x)</dt><dd><p>Returns the number of genes (i.e, the length of the
<code>mu</code> vector).</p>
</dd>
<dt>rand(object, n, ...)</dt><dd><p>Generates <code class="reqn">nrow(MVN)*n</code> matrix
representing gene expressions of <code>n</code> samples following the
multivariate normal distribution captured in the object of <code>MVN</code>.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Prints out the number of
multivariate normal random variables in the object of <code>MVN</code>.</p>
</dd>
<dt>covar(object)</dt><dd><p>Returns the covariance matrix of the object of
class <code>MVN</code>.</p>
</dd>
<dt>correl(object)</dt><dd><p>Returns the correlation matrix of the object of
class <code>MVN</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jiexin Zhang <a href="mailto:jiexinzhang@mdanderson.org">jiexinzhang@mdanderson.org</a>,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Engine-class">Engine</a></code>,
<code><a href="#topic+IndependentNormal-class">IndependentNormal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MVN")
  ## Not run: 
tolerance &lt;- 1e-10
## Create a random orthogonal 2x2 matrix
a &lt;- runif(1)
b &lt;- sqrt(1-a^2)
X &lt;- matrix(c(a, b, -b, a), 2, 2)
## Now choose random positive squared-eigenvalues
Lambda2 &lt;- diag(rev(sort(rexp(2))), 2)
## Construct a covariance matrix
Y &lt;- t(X) 
## Use the MVN constructor
marvin &lt;- MVN(c(0,0), Y)
## Check the four assertions
print(paste('Tolerance for assertion checking:', tolerance))
print(paste('Covar  assertion 1:',
            all(abs(covar(marvin) - Y) &lt; tolerance)))
mar2 &lt;- alterMean(marvin, normalOffset, delta=3)
print(paste('Covar  assertion 2:',
            all(abs(covar(marvin) - covar(mar2)) &lt; tolerance)))
print(paste('Correl assertion 1:',
            all(abs(diag(correl(marvin)) - 1) &lt; tolerance)))
mar3 &lt;- alterSD(marvin, function(x) 2*x)
print(paste('Correl assertion 1:',
            all(abs(correl(marvin) - correl(mar2)) &lt; tolerance)))
rm(a, b, X, Lambda2, Y, marvin, mar2, mar3)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='nComponents-method'>Method &quot;nComponents&quot;</h2><span id='topic+nComponents'></span><span id='topic+nComponents-method'></span><span id='topic+nComponents+2CANY-method'></span>

<h3>Description</h3>

<p><code>nComponents</code> is a generic function, analogous to 'nrow' or
'ncol', that reports the number of components of an &ldquo;engine&ldquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
nComponents(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nComponents-method_+3A_object">object</code></td>
<td>
<p>an object from which the number of components is desired</p>
</td></tr>
<tr><td><code id="nComponents-method_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the number of components produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a nonnegative integer (scalar).
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Caitlin E. Coombes <a href="mailto:caitlin.coombes@osumc.edu">caitlin.coombes@osumc.edu</a>
</p>

<hr>
<h2 id='NoiseModel-class'>The &quot;NoiseModel&quot; Class</h2><span id='topic+NoiseModel-class'></span><span id='topic+NoiseModel'></span><span id='topic+blur+2CNoiseModel-method'></span><span id='topic+summary+2CNoiseModel-method'></span>

<h3>Description</h3>

<p>A <code>NoiseModel</code> represents the additional machine noise that is layered
on top of any biological variabilty when measuring the gene expression in a
set of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NoiseModel(nu, tau, phi)
## S4 method for signature 'NoiseModel'
blur(object, x, ...)
## S4 method for signature 'NoiseModel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NoiseModel-class_+3A_nu">nu</code></td>
<td>
<p>The mean value for the additive noise</p>
</td></tr>
<tr><td><code id="NoiseModel-class_+3A_tau">tau</code></td>
<td>
<p>The standard deviation for the additive noise</p>
</td></tr>
<tr><td><code id="NoiseModel-class_+3A_phi">phi</code></td>
<td>
<p>The standard deviation for the multiplicative noise. Note that
the mean of the multiplicative noise is set to <code>0</code>.</p>
</td></tr>
<tr><td><code id="NoiseModel-class_+3A_object">object</code></td>
<td>
<p>object of class <code>NoiseModel</code></p>
</td></tr>
<tr><td><code id="NoiseModel-class_+3A_x">x</code></td>
<td>
<p>The data matrix containing true signal from the gene expression</p>
</td></tr>
<tr><td><code id="NoiseModel-class_+3A_...">...</code></td>
<td>
<p>extra arguments affecting the blur method applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We model both additive and multiplicative noise, so that the observed
expression of gene <var>g</var> in sample <var>i</var> is given by:
<code class="reqn">Y_gi = S_gi exp(H_gi) + E_gi</code>, where <var>Y_gi</var> = observed expression,
<var>S_gi</var> = true biological signal,
H_gi ~ N(0, phi) defines the multiplicative noise, and
E_gi ~ N(nu,tau) defines the additive noise.
Note that we allow a systematic offset/bias in the additive noise model.
</p>


<h3>Methods</h3>


<dl>
<dt>blur(object, x, ...)</dt><dd><p>Adds and multiplies random noise to the
data matrix <code>x</code> containing the true signal from the gene expression.</p>
</dd>
</dl>


<dl>
<dt>summary(object, ...)</dt><dd><p>Prints a summary of the object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jiexin Zhang <a href="mailto:jiexinzhang@mdanderson.org">jiexinzhang@mdanderson.org</a>,
</p>


<h3>References</h3>

<p>Zhang J, Coombes KR.<br />
<em>Sources of variation in false discovery rate estimation include
sample size, correlation, and inherent differences between groups.</em><br />
BMC Bioinformatics. 2012; 13 Suppl 13:S1. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("NoiseModel")
nComp &lt;- 10
nGenes &lt;- 100
comp &lt;- list()
for (i in 1:nComp){
  comp[[i]] &lt;- IndependentLogNormal(rnorm(nGenes/nComp, 6, 1.5),
                                    1/rgamma(nGenes/nComp, 44, 28))
}
myEngine &lt;- Engine(comp)
myData &lt;- rand(myEngine, 5)
summary(myData)

nu &lt;- 10
tau &lt;- 20
phi &lt;- 0.1
nm &lt;- NoiseModel(nu, tau, phi)
realData &lt;- blur(nm, myData)
summary(realData)
</code></pre>

<hr>
<h2 id='NormalVsCancer'>Simulating Cancer Versus Normal Datasets</h2><span id='topic+NormalVsCancerModel'></span><span id='topic+NormalVsCancerEngine'></span>

<h3>Description</h3>

<p>These functions are useful for simulating data that compares a
homogeneous &quot;cancer&quot; group to a homogeneous &quot;normal&quot; group of
samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalVsCancerModel(nBlocks, survivalModel=NULL, name="NormalVsCancer")
NormalVsCancerEngine(nBlocks, hyperp) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalVsCancer_+3A_nblocks">nBlocks</code></td>
<td>
<p>scalar integer representing number of correlated blocks
that are differentially expressed between cancer and normal</p>
</td></tr>
<tr><td><code id="NormalVsCancer_+3A_survivalmodel">survivalModel</code></td>
<td>
<p>a <code>SurvivalModel</code> object</p>
</td></tr>
<tr><td><code id="NormalVsCancer_+3A_name">name</code></td>
<td>
<p>character string specifying name of the object being created</p>
</td></tr>
<tr><td><code id="NormalVsCancer_+3A_hyperp">hyperp</code></td>
<td>
<p>object of class <code>BlockHyperParameters</code> that describes
the block correlation structure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simplest simulation model assumes that we are comparing two
homogeneous groups.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jiexin Zhang <a href="mailto:jiexinzhang@mdanderson.org">jiexinzhang@mdanderson.org</a>,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BlockHyperParameters-class">BlockHyperParameters</a></code>,
<code><a href="#topic+CancerEngine-class">CancerEngine</a></code>,
<code><a href="#topic+CancerModel-class">CancerModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nvc &lt;- NormalVsCancerModel(10)
summary(nvc)
rand(nvc, 10)
rand(nvc, 10, balance=TRUE)
engine &lt;- NormalVsCancerEngine(10)
dset &lt;- rand(engine, 10, balance=TRUE)
</code></pre>

<hr>
<h2 id='rand-method'>Method &quot;rand&quot;</h2><span id='topic+rand'></span><span id='topic+rand-method'></span><span id='topic+rand+2CANY-method'></span>

<h3>Description</h3>

<p><code>rand</code> is a generic function used to produce random vectors from the
distribution defined by various objects. The generic function invokes particular
<code><a href="utils.html#topic+methods">methods</a></code> which depend on the <code><a href="base.html#topic+class">class</a></code> of the first
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
rand(object, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand-method_+3A_object">object</code></td>
<td>
<p>an object from which random numbers from a distribution is
desired</p>
</td></tr>
<tr><td><code id="rand-method_+3A_n">n</code></td>
<td>
<p>numeric scalar specifying quantity of random numbers</p>
</td></tr>
<tr><td><code id="rand-method_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the random numbers produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The form of the value returned by <code>rand</code> depends on the
class of its argument. See the documentation of the particular methods
for details of what is produced by that method.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
</p>

<hr>
<h2 id='SurvivalModel-class'>The &quot;SurvivalModel&quot; Class</h2><span id='topic+SurvivalModel-class'></span><span id='topic+SurvivalModel'></span><span id='topic+rand+2CSurvivalModel-method'></span>

<h3>Description</h3>

<p>A <code>SurvivalModel</code> class represents the information for simulating
survival times for each patient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurvivalModel(baseHazard = 1/5,
              accrual = 5,
              followUp = 1,
              units = 12,
              unitName = "months")
## S4 method for signature 'SurvivalModel'
rand(object, n, beta = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SurvivalModel-class_+3A_basehazard">baseHazard</code></td>
<td>
<p>numeric scalar describing the underlying hazard rate at
baseline levels of covariates</p>
</td></tr>
<tr><td><code id="SurvivalModel-class_+3A_accrual">accrual</code></td>
<td>
<p>numeric scalar representing number of patient accrual years</p>
</td></tr>
<tr><td><code id="SurvivalModel-class_+3A_followup">followUp</code></td>
<td>
<p>numeric scalar representing length of follow up, in years</p>
</td></tr>
<tr><td><code id="SurvivalModel-class_+3A_units">units</code></td>
<td>
<p>numeric scalar representing number of units per year where
units are specified by <code>unitName</code></p>
</td></tr>
<tr><td><code id="SurvivalModel-class_+3A_unitname">unitName</code></td>
<td>
<p>character string representing the <code>unit</code> argument type</p>
</td></tr>
<tr><td><code id="SurvivalModel-class_+3A_object">object</code></td>
<td>
<p>object of class <code>SurvivalModel</code></p>
</td></tr>
<tr><td><code id="SurvivalModel-class_+3A_n">n</code></td>
<td>
<p>numeric scalar specifying quantity of random numbers</p>
</td></tr>
<tr><td><code id="SurvivalModel-class_+3A_beta">beta</code></td>
<td>
<p>numeric vector specifying beta parameters for patients</p>
</td></tr>
<tr><td><code id="SurvivalModel-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic routines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>SurvivalModel</code> generator returns an object of class
<code>SurvivalModel</code>.
</p>
<p>The <code>rand</code> method returns a data.frame with components:
</p>
<table>
<tr><td><code>LFU</code></td>
<td>
<p>time to event</p>
</td></tr>
<tr><td><code>Event</code></td>
<td>
<p>whether the data is censored</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Although objects of the class can be created by a direct call to
<a href="methods.html#topic+new">new</a>, the preferred method is to use the
<code>SurvivalModel</code> generator function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>baseHazard</code>:</dt><dd><p>see corresponding argument above</p>
</dd>
<dt><code>accrual</code>:</dt><dd><p>see corresponding argument above</p>
</dd>
<dt><code>followUp</code>:</dt><dd><p>see corresponding argument above</p>
</dd>
<dt><code>units</code>:</dt><dd><p>see corresponding argument above</p>
</dd>
<dt><code>unitName</code>:</dt><dd><p>see corresponding argument above</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>rand(object, n, beta, ...)</dt><dd><p>Simulate survival data for <code>n</code>
patients given <code>beta</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jiexin Zhang <a href="mailto:jiexinzhang@mdanderson.org">jiexinzhang@mdanderson.org</a>,
</p>


<h3>References</h3>

<p>Zhang J, Coombes KR.<br />
<em>Sources of variation in false discovery rate estimation include
sample size, correlation, and inherent differences between groups.</em><br />
BMC Bioinformatics. 2012; 13 Suppl 13:S1. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CancerModel-class">CancerModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SurvivalModel")
sm &lt;- SurvivalModel()
## Generate data from base model
outcome &lt;- rand(sm, 100)
summary(outcome)
## Generate data from five classes with different beta parameters
beta &lt;- rep(rnorm(5, 0, 2), each = 20)
outcome &lt;- rand(sm, 100, beta = beta)
summary(outcome)
</code></pre>

<hr>
<h2 id='transforms'>Transform functions</h2><span id='topic+normalOffset'></span><span id='topic+invGammaMultiple'></span>

<h3>Description</h3>

<p><code>normalOffset</code> is a function that can be used as the
<code>TRANSFORM</code> argument in an <code>alterMean</code> operation, which adds
an offset to each value in the mean where the offset is chosen from a
normal distribution.
</p>
<p><code>invGammaMultiple</code> is a function that can be used as the
<code>TRANSFORM</code> argument in an <code>alterSD</code> operation, which multiplies
each standard deviation by a positive value chosen from an inverse gamma
distribution with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalOffset(x, delta, sigma)
invGammaMultiple(x, shape, rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transforms_+3A_x">x</code></td>
<td>
<p>numeric vector of mean expression or standard deviation
defined in the object</p>
</td></tr>
<tr><td><code id="transforms_+3A_delta">delta</code>, <code id="transforms_+3A_sigma">sigma</code></td>
<td>
<p>numeric vector used as <code>mean</code> and/or <code>sd</code>
parameters specifying the normal distribution</p>
</td></tr>
<tr><td><code id="transforms_+3A_shape">shape</code>, <code id="transforms_+3A_rate">rate</code></td>
<td>
<p>numeric vector used as <code>shape</code> and/or <code>rate</code>
parameters specifying the gamma distribution. Must be positive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>normalOffset</code> returns a new vector, TO each element of which is added
aN offset chosen from a normal distribution with parameters <code>mean</code>
and <code>sd</code>.
</p>
<p><code>invGammaMultiple</code> returns a new vector, each element of which is
multiplied by a positive value chosen from an inverse gamma distribution
with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jiexin Zhang <a href="mailto:jiexinzhang@mdanderson.org">jiexinzhang@mdanderson.org</a>,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alterMean">alterMean</a></code>,
<code><a href="#topic+alterSD">alterSD</a></code>,
<code><a href="base.html#topic+RNGkind">RNGkind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nComp &lt;- 10
nGenes &lt;- 100
comp &lt;- list()
for (i in 1:nComp) {
  comp[[i]] &lt;- IndependentNormal(rnorm(nGenes/nComp, 6, 1.5),
                                 1/rgamma(nGenes/nComp, 44, 28))
}
myEngine &lt;- Engine(comp)
nrow(myEngine)
nComponents(myEngine)
summary(myEngine)
myData &lt;- rand(myEngine, 5)
dim(myData)
summary(myData)
MEAN &lt;- 2
SD &lt;- 2
myEngine.alterMean &lt;- alterMean(myEngine,
                                function(x) normalOffset(x, MEAN, SD))
myData.alterMean &lt;- rand(myEngine.alterMean, 5)
summary(myData.alterMean)
RATE &lt;- 1
SHAPE &lt;- 2
myEngine.alterSD &lt;- alterSD(myEngine,
                            function(x) invGammaMultiple(x, SHAPE, RATE))
myData.alterSD &lt;- rand(myEngine.alterSD, 5)
summary(myData.alterSD)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
