<!DOCTYPE html><html><head><title>Help for package tramME</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tramME}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.tramME'><p>Comparison of nested tramME models.</p></a></li>
<li><a href='#BoxCoxME'><p>Non-normal (Box-Cox-type) Linear Mixed-effects Additive Regression Model</p></a></li>
<li><a href='#coef.LmME'><p>Extract the coefficients of an <code>LmME</code> model</p></a></li>
<li><a href='#coef.SurvregME'><p>Extract the coefficients of the fixed effects terms of an SurvregME model.</p></a></li>
<li><a href='#coef.tramME'><p>Extract the coefficients of a <code>tramME</code> model</p></a></li>
<li><a href='#coef+26lt+3B-.tramME'><p>Set coefficients of a tramME model.</p></a></li>
<li><a href='#ColrME'><p>Mixed-effects Additive Continuous Outcome Logistic Regression Model</p></a></li>
<li><a href='#confband.tramME'><p>Confidence intervals and bands from a <code>tramME</code> model</p></a></li>
<li><a href='#confint.LmME'><p>Confidence intervals for LmME model parameters</p></a></li>
<li><a href='#confint.tramME'><p>Confidence intervals for tramME model parameters</p></a></li>
<li><a href='#CoxphME'><p>Mixed-effects Additive Parametric Cox Regression Model</p></a></li>
<li><a href='#edf_smooth.tramME'><p>EDFs of smooth shift terms</p></a></li>
<li><a href='#LehmannME'><p>Mixed-effects Additive Lehmann-alternative Linear Regression Model</p></a></li>
<li><a href='#LmME'><p>Mixed-effects Additive Normal Linear Regression Model</p></a></li>
<li><a href='#logLik.tramME'><p>Get the log-likelihood of the tramME model</p></a></li>
<li><a href='#model.frame.tramME'><p>Extract model frame from a tramME model</p></a></li>
<li><a href='#model.matrix.tramME'><p>Model matrices for <code>tramME</code> models</p></a></li>
<li><a href='#optim_control'><p>Set up and control optimization parameters</p></a></li>
<li><a href='#plot_ci'><p>Plot confidence bands from <code>tramME</code> models</p></a></li>
<li><a href='#plot.smooth.tramME'><p>Plot smooth terms of a tramME model.</p></a></li>
<li><a href='#plot.tramME'><p>Plotting method for tramME objects</p></a></li>
<li><a href='#PolrME'><p>Mixed-effects Additive Transformation Models for Ordered Categorical</p>
Responses</a></li>
<li><a href='#predict.tramME'><p>Predict method for tramME objects</p></a></li>
<li><a href='#predict.tramTMB'><p>Post-estimation calculations in a tramTMB model</p></a></li>
<li><a href='#print.anova.tramME'><p>Printing <code>anova.tramME</code> table</p></a></li>
<li><a href='#print.summary.tramME'><p>Print method for tramME model summary</p></a></li>
<li><a href='#print.tramME'><p>Print tramME model</p></a></li>
<li><a href='#print.VarCorr.tramME'><p>Print method for the variance-correlation parameters of a tramME object</p></a></li>
<li><a href='#ranef.LmME'><p>Extract the conditional modes of random effects of an LmME model</p></a></li>
<li><a href='#ranef.tramME'><p>Point estimates and conditional variances of random effects.</p></a></li>
<li><a href='#residuals.LmME'><p>Residuals of a LmME model</p></a></li>
<li><a href='#residuals.tramME'><p>Residuals of a tramME model</p></a></li>
<li><a href='#Resp'><p>Response objects</p></a></li>
<li><a href='#sigma.LmME'><p>Extract the SD of the error term of an LmME model.</p></a></li>
<li><a href='#simulate.tramME'><p>Simulate from a <code>tramME</code> model</p></a></li>
<li><a href='#smooth_terms.LmME'><p>Evaluate smooth terms of a <code>LmME</code> model.</p></a></li>
<li><a href='#smooth_terms.tramME'><p>Extract and evaluate the smooth terms of a tramME model</p></a></li>
<li><a href='#summary.tramME'><p>Summary method for tramME model</p></a></li>
<li><a href='#SurvregME'><p>Mixed-effects Additive Parametric Survival Models</p></a></li>
<li><a href='#tramME'><p>Mixed-effects Additive transformation models</p></a></li>
<li><a href='#tramTMB'><p>Create a tramTMB object</p></a></li>
<li><a href='#VarCorr.LmME'><p>Variances and correlation matrices of random effects of an LmME object</p></a></li>
<li><a href='#VarCorr.tramME'><p>Variances and correlation matrices of random effects</p></a></li>
<li><a href='#varcov'><p>Generic method for <code>varcov</code></p></a></li>
<li><a href='#varcov.LmME'><p>Extract the variance-covariance matrix of the random effects of an LmME model</p></a></li>
<li><a href='#varcov.tramME'><p>Extract the variance-covariance matrix of the random effects</p></a></li>
<li><a href='#varcov+26lt+3B-'><p>Generic method for <code>"varcov&lt;-"</code></p></a></li>
<li><a href='#varcov+26lt+3B-.tramME'><p>Set the values of the random effects covariance matrices of a tramME model.</p></a></li>
<li><a href='#variable.names.tramME'><p>Return variable names.</p></a></li>
<li><a href='#vcov.LmME'><p>Get the variance-covariance matrix of the parameters of an LmME model</p></a></li>
<li><a href='#vcov.tramME'><p>Calculate the variance-covariance matrix of the parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Transformation Models with Mixed Effects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Likelihood-based estimation of mixed-effects transformation models
    using the Template Model Builder ('TMB', Kristensen et al., 2016)
    &lt;<a href="https://doi.org/10.18637%2Fjss.v070.i05">doi:10.18637/jss.v070.i05</a>&gt;. The technical details of transformation models
    are given in Hothorn et al. (2018) &lt;<a href="https://doi.org/10.1111%2Fsjos.12291">doi:10.1111/sjos.12291</a>&gt;. Likelihood
    contributions of exact, randomly censored (left, right, interval) and
    truncated observations are supported. The random effects are assumed to be
    normally distributed on the scale of the transformation function, the
    marginal likelihood is evaluated using the Laplace approximation, and the
    gradients are calculated with automatic differentiation (Tamasi &amp; Hothorn,
    2021) &lt;<a href="https://doi.org/10.32614%2FRJ-2021-075">doi:10.32614/RJ-2021-075</a>&gt;. Penalized smooth shift terms can be
    defined using 'mgcv'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), tram (&ge; 0.3.2), mlt (&ge; 1.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>alabama, Matrix, methods, mgcv (&ge; 1.8.34), nlme, TMB (&ge;
1.7.15), stats, variables (&ge; 1.0.2), basefun (&ge; 1.0.6),
numDeriv, MASS, coneproj, mvtnorm, reformulas</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lme4 (&ge; 1.1.19), multcomp, parallel, survival, knitr, coxme,
ordinal, ordinalCont, gamm4, gamlss.dist, glmmTMB, xtable</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB, RcppEigen</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://ctm.R-forge.R-project.org">http://ctm.R-forge.R-project.org</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-01 19:26:33 UTC; balint</td>
</tr>
<tr>
<td>Author:</td>
<td>Balint Tamasi <a href="https://orcid.org/0000-0002-2629-7362"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Torsten Hothorn <a href="https://orcid.org/0000-0001-8301-0471"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Balint Tamasi &lt;balint.tamasi+tramME@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-02 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.tramME'>Comparison of nested tramME models.</h2><span id='topic+anova.tramME'></span>

<h3>Description</h3>

<p>Calculates information criteria and LR ratio test for nested tramME models.
The calculation of the degrees of freedom is problematic, because the
parameter space is restricted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
anova(object, object2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="anova.tramME_+3A_object2">object2</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="anova.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments, for compatibility with the generic. (Ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently only supports the comparison of two models. Additional arguments
will be ignored.
</p>
<p>The nestedness of the models is not checked.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the calculated statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
mod1 &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
mod2 &lt;- LmME(Reaction ~ Days + (Days || Subject), data = sleepstudy)
anova(mod1, mod2)
</code></pre>

<hr>
<h2 id='BoxCoxME'>Non-normal (Box-Cox-type) Linear Mixed-effects Additive Regression Model</h2><span id='topic+BoxCoxME'></span>

<h3>Description</h3>

<p>Estimates a mixed-effects additive transformation model with flexible smooth
parameterization for the baseline transformation and the inverse link set to
the CDF of the standard Gaussian distribution (see Hothorn et al., 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoxCoxME(
  formula,
  data,
  subset,
  weights,
  offset,
  na.action = na.omit,
  silent = TRUE,
  resid = FALSE,
  do_update = FALSE,
  estinit = TRUE,
  initpar = NULL,
  fixed = NULL,
  nofit = FALSE,
  control = optim_control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoxCoxME_+3A_formula">formula</code></td>
<td>
<p>A formula describing the model. Smooth additive terms are
defined the way as in <code>mgcv</code>, and random effects consistently with
the notation used in <code>lme4</code>.</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>.
</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_weights">weights</code></td>
<td>
<p>an optional vector of case weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector. If present,
the weighted log-likelihood is maximised.
</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an _a priori_ known component to
be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the
number of cases.
</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set to <code>na.omit</code>.
</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_silent">silent</code></td>
<td>
<p>Logical. Make <span class="pkg">TMB</span> functionality silent.</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_resid">resid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the score residuals are also calculated.
This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_do_update">do_update</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model is set up so that the weights and the
offsets are updateable. This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_estinit">estinit</code></td>
<td>
<p>Logical. Estimate a vector of initial values for the fixed effects parameters
from a (fixed effects only) mlt model</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_initpar">initpar</code></td>
<td>
<p>Named list of initial parameter values, if <code>NULL</code>, it is ignored</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_fixed">fixed</code></td>
<td>
<p>a named vector of fixed regression coefficients; the names
need to correspond to column names of the design matrix</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_nofit">nofit</code></td>
<td>
<p>logical, if TRUE, creates the model object, but does not run the optimization</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_control">control</code></td>
<td>
<p>list with controls for optimization</p>
</td></tr>
<tr><td><code id="BoxCoxME_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="tram.html#topic+tram">tram</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model extends <code><a href="tram.html#topic+BoxCox">tram::BoxCox</a></code> with random effects and
(optionally penalized) additive terms. For details on mixed-effect
transformation models, see Tamasi and Hothorn (2021).
</p>
<p>The elements of the linear predictor are parameterized with negative
parameters (i.e. <code>negative = TRUE</code> in <code><a href="tram.html#topic+tram">tram</a></code>).
</p>


<h3>Value</h3>

<p>A <code>BoxCoxME</code> model object.
</p>


<h3>References</h3>

<p>Hothorn, Torsten, Lisa Möst, and Peter Bühlmann. &quot;Most Likely
Transformations.&quot;  Scandinavian Journal of Statistics 45, no. 1 (March
2018): 110–34.  &lt;doi:10.1111/sjos.12291&gt;
</p>
<p>Tamasi, Balint, and Torsten Hothorn. &quot;tramME: Mixed-Effects Transformation
Models Using Template Model Builder.&quot; The R Journal 13, no. 2 (2021):
398–418. &lt;doi:10.32614/RJ-2021-075&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
m &lt;- BoxCoxME(Reaction ~ s(Days) + (Days | Subject), data = sleepstudy)
summary(m)
</code></pre>

<hr>
<h2 id='coef.LmME'>Extract the coefficients of an <code>LmME</code> model</h2><span id='topic+coef.LmME'></span>

<h3>Description</h3>

<p>Extracts the fixed effects coefficents (default behavior), the baseline
parameters or all (baseline, fixed and random) coefficients of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LmME'
coef(object, as.lm = FALSE, fixed = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.LmME_+3A_object">object</code></td>
<td>
<p>An <code>LmME</code> object.</p>
</td></tr>
<tr><td><code id="coef.LmME_+3A_as.lm">as.lm</code></td>
<td>
<p>If <code>TRUE</code>, return the transformed coefficients as in a
<code>lmerMod</code> object.</p>
</td></tr>
<tr><td><code id="coef.LmME_+3A_fixed">fixed</code></td>
<td>
<p>If <code>TRUE</code>, also include the fixed parameters.</p>
</td></tr>
<tr><td><code id="coef.LmME_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="#topic+coef.tramME">coef.tramME</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also the documentation of <code><a href="#topic+coef.tramME">coef.tramME</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of the transformed coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
coef(fit, as.lm = TRUE)
</code></pre>

<hr>
<h2 id='coef.SurvregME'>Extract the coefficients of the fixed effects terms of an SurvregME model.</h2><span id='topic+coef.SurvregME'></span>

<h3>Description</h3>

<p>Extract the coefficients of the fixed effects terms of an SurvregME model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SurvregME'
coef(object, as.survreg = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.SurvregME_+3A_object">object</code></td>
<td>
<p>An <code>SurvregME</code> object.</p>
</td></tr>
<tr><td><code id="coef.SurvregME_+3A_as.survreg">as.survreg</code></td>
<td>
<p>If <code>TRUE</code>, return the transformed coefficients as in a
<code>survival::survreg</code> object.</p>
</td></tr>
<tr><td><code id="coef.SurvregME_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="#topic+coef.tramME">coef.tramME</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the transformed coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("survival")
fit &lt;- SurvregME(Surv(time, status) ~ rx + (1 | litter), data = rats)
coef(fit, as.survreg = TRUE)
</code></pre>

<hr>
<h2 id='coef.tramME'>Extract the coefficients of a <code>tramME</code> model</h2><span id='topic+coef.tramME'></span>

<h3>Description</h3>

<p>Extracts the fixed effects coefficents (default behavior), the baseline
parameters or all (baseline, fixed and random) coefficients of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
coef(object, with_baseline = FALSE, fixed = TRUE, complete = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="coef.tramME_+3A_with_baseline">with_baseline</code></td>
<td>
<p>If <code>TRUE</code>, also include the baseline parameters
and the fixed effects parameters from the smooth terms. (Kept for
compatibility with <code>tram</code>)</p>
</td></tr>
<tr><td><code id="coef.tramME_+3A_fixed">fixed</code></td>
<td>
<p>If <code>TRUE</code>, also include the fixed parameters.</p>
</td></tr>
<tr><td><code id="coef.tramME_+3A_complete">complete</code></td>
<td>
<p>If <code>TRUE</code>, return all parameters that can be seen as
coefficients (baseline, fixed, random) in the <code>tramME</code> model.  With
<code>complete = TRUE</code>, <code>with_baseline = FALSE</code> and <code>fixed =
FALSE</code> are ignored. (The behavior of this argument might change in the
future).</p>
</td></tr>
<tr><td><code id="coef.tramME_+3A_...">...</code></td>
<td>
<p>Optional parameters (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of parameter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("survival")
mod &lt;- SurvregME(Surv(time, status) ~ rx + (1 | litter/rx), data = rats,
                 dist = "exponential", nofit = TRUE)
coef(mod, with_baseline = TRUE)
coef(mod, with_baseline = TRUE, fixed = FALSE)

data("sleepstudy", package = "lme4")
mod2 &lt;- BoxCoxME(Reaction ~ s(Days) + (Days || Subject), data = sleepstudy,
                 nofit = TRUE)
coef(mod2, complete = TRUE)
</code></pre>

<hr>
<h2 id='coef+26lt+3B-.tramME'>Set coefficients of a tramME model.</h2><span id='topic+coef+3C-.tramME'></span>

<h3>Description</h3>

<p>Sets the whole vector of fixed-effects coefficients of a tramME model.
The parameters of the baseline transformation function should respect the
restrictions of the parameter space. This is checked before setting the new
parameter values provided that the parameters for the variance components has
already been set.
If the model contains fixed coefficient parameters, the input should also respect
that.
When called on a fitted tram object, the function sets it to unfitted and removes
all parts that come from the estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'tramME'
coef(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B26lt+2B3B-.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-.tramME_+3A_value">value</code></td>
<td>
<p>Numeric vector of new coefficient values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tramME</code> object with the new coefficient values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
mod &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy, nofit = TRUE)
coef(mod) &lt;- c(-1, 0.5, 1)
</code></pre>

<hr>
<h2 id='ColrME'>Mixed-effects Additive Continuous Outcome Logistic Regression Model</h2><span id='topic+ColrME'></span>

<h3>Description</h3>

<p>Estimates a mixed-effects additive transformation model with flexible smooth
parameterization for the baseline transformation and the inverse link set to
the CDF of the standard logistic distribution (see Hothorn et al., 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ColrME(
  formula,
  data,
  subset,
  weights,
  offset,
  na.action = na.omit,
  silent = TRUE,
  resid = FALSE,
  do_update = FALSE,
  estinit = TRUE,
  initpar = NULL,
  fixed = NULL,
  nofit = FALSE,
  control = optim_control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ColrME_+3A_formula">formula</code></td>
<td>
<p>A formula describing the model. Smooth additive terms are
defined the way as in <code>mgcv</code>, and random effects consistently with
the notation used in <code>lme4</code>.</p>
</td></tr>
<tr><td><code id="ColrME_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>.
</p>
</td></tr>
<tr><td><code id="ColrME_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td></tr>
<tr><td><code id="ColrME_+3A_weights">weights</code></td>
<td>
<p>an optional vector of case weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector. If present,
the weighted log-likelihood is maximised.
</p>
</td></tr>
<tr><td><code id="ColrME_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an _a priori_ known component to
be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the
number of cases.
</p>
</td></tr>
<tr><td><code id="ColrME_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set to <code>na.omit</code>.
</p>
</td></tr>
<tr><td><code id="ColrME_+3A_silent">silent</code></td>
<td>
<p>Logical. Make <span class="pkg">TMB</span> functionality silent.</p>
</td></tr>
<tr><td><code id="ColrME_+3A_resid">resid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the score residuals are also calculated.
This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="ColrME_+3A_do_update">do_update</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model is set up so that the weights and the
offsets are updateable. This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="ColrME_+3A_estinit">estinit</code></td>
<td>
<p>Logical. Estimate a vector of initial values for the fixed effects parameters
from a (fixed effects only) mlt model</p>
</td></tr>
<tr><td><code id="ColrME_+3A_initpar">initpar</code></td>
<td>
<p>Named list of initial parameter values, if <code>NULL</code>, it is ignored</p>
</td></tr>
<tr><td><code id="ColrME_+3A_fixed">fixed</code></td>
<td>
<p>a named vector of fixed regression coefficients; the names
need to correspond to column names of the design matrix</p>
</td></tr>
<tr><td><code id="ColrME_+3A_nofit">nofit</code></td>
<td>
<p>logical, if TRUE, creates the model object, but does not run the optimization</p>
</td></tr>
<tr><td><code id="ColrME_+3A_control">control</code></td>
<td>
<p>list with controls for optimization</p>
</td></tr>
<tr><td><code id="ColrME_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="tram.html#topic+tram">tram</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model extends <code><a href="tram.html#topic+Colr">tram::Colr</a></code> with random effects and
(optionally penalized) additive terms. For details on mixed-effect
transformation models, see Tamasi and Hothorn (2021).
</p>
<p>The elements of the linear predictor are parameterized with positive
parameters (i.e. <code>negative = FALSE</code> in <code><a href="tram.html#topic+tram">tram</a></code>).
</p>


<h3>Value</h3>

<p>A <code>ColrME</code> model object.
</p>


<h3>References</h3>

<p>Hothorn, Torsten, Lisa Möst, and Peter Bühlmann. &quot;Most Likely
Transformations.&quot;  Scandinavian Journal of Statistics 45, no. 1 (March
2018): 110–34.  &lt;doi:10.1111/sjos.12291&gt;
</p>
<p>Tamasi, Balint, and Torsten Hothorn. &quot;tramME: Mixed-Effects Transformation
Models Using Template Model Builder.&quot; The R Journal 13, no. 2 (2021):
398–418. &lt;doi:10.32614/RJ-2021-075&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("neck_pain", package = "ordinalCont")
m &lt;- ColrME(vas ~ time * laser + (1 | id), data = neck_pain,
            bounds = c(0, 1), support = c(0, 1), order = 6)
summary(m)
</code></pre>

<hr>
<h2 id='confband.tramME'>Confidence intervals and bands from a <code>tramME</code> model</h2><span id='topic+confband.tramME'></span>

<h3>Description</h3>

<p>Pointwise confidence intervals or multiplicity-adjusted confidence bands for
transformation, distribution, survivor or cumulative hazard functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
confband(
  object,
  newdata,
  level = 0.95,
  type = c("trafo", "distribution", "survivor", "cumhazard"),
  adjust = FALSE,
  K = 40,
  cheat = K,
  q = NULL,
  baseline_only = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confband.tramME_+3A_object">object</code></td>
<td>
<p>The <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="confband.tramME_+3A_newdata">newdata</code></td>
<td>
<p>A data frame of covariate values.</p>
</td></tr>
<tr><td><code id="confband.tramME_+3A_level">level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
<tr><td><code id="confband.tramME_+3A_type">type</code></td>
<td>
<p>The scale on which the condfidence bands are calculated.</p>
</td></tr>
<tr><td><code id="confband.tramME_+3A_adjust">adjust</code></td>
<td>
<p>If <code>TRUE</code>, multiplicity-adjusted confidence bands are
calculated. (see Details)</p>
</td></tr>
<tr><td><code id="confband.tramME_+3A_k">K</code></td>
<td>
<p>The number of grid points at which the outcome distribution is
evaluated.</p>
</td></tr>
<tr><td><code id="confband.tramME_+3A_cheat">cheat</code></td>
<td>
<p>In the case of multiplicity adjustment (<code>adjust = TRUE</code>),
an option to decrease the number of grid points (<code>cheat &lt; K</code>), for
faster calculations and increased numerical stability. (see Details)</p>
</td></tr>
<tr><td><code id="confband.tramME_+3A_q">q</code></td>
<td>
<p>The quantiles at which the model is evaluated.</p>
</td></tr>
<tr><td><code id="confband.tramME_+3A_baseline_only">baseline_only</code></td>
<td>
<p>If <code>TRUE</code>, only evaluate the baseline
transformation function and ignore the shift terms.</p>
</td></tr>
<tr><td><code id="confband.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="multcomp.html#topic+confint.glht">confint.glht</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similarly to <code><a href="mlt.html#topic+confband">confband</a></code>, this method evaluates the
conditional distribution of the outcome on a selected scale given a number
of grid-points and claculates the corresponding confidence intervals or
bands (adjusting for multiplicity).
</p>
<p>The point estimates retured by this function could also be calculated with
<code><a href="#topic+predict.tramME">predict.tramME</a></code> (when <code>newdata</code> does not contain
response values and <code>K</code> is set to the number of grid points).
While <code><a href="#topic+predict.tramME">predict.tramME</a></code> is designed to calculate a
potentially large number of point estimates on a wider range of available
scales, <code>confband</code> calculates the asymptotic intervals from the joint
covariance matrix of the fixed and random effects. For technical reasons,
a smaller set of <code>type</code> options are available, and the calculations
are slower than with <code><a href="#topic+predict.tramME">predict.tramME</a></code>. The handling of random
effects is currently stricter than in <code>predict.tramME</code>: No
<code>ranef</code> option is available, and grouping factors for random effects
supplied in <code>newdata</code> must have the same levels as the dataset used
to fit the model.
</p>
<p>The multiplicity adjustment is done using
<code><a href="multcomp.html#topic+confint.glht">confint.glht</a></code>. The <code>cheat</code> argument reduces
the dimensionality of the multivariate root-finding problem (see
<code><a href="mvtnorm.html#topic+qmvt">qmvt</a></code>) for speed and (occasionally) numerical
stability. The critical value for the confidence bands are obtained for
<code>cheat &lt; K</code> grid points, but the confidence bands are calculated for
<code>K</code> grid points. As a result, the nominal level of the returned
confidence band is not maintained, but the deviation is expected to be
small if <code>cheat</code> is reasonably large. It is the user's responsibility
to set this value, and by default <code>cheat = K</code>.
</p>


<h3>Value</h3>

<p>A matrix (in the case when <code>newdata</code> has a single row) or a
list of matrices for each row of <code>newdata</code>.
</p>


<h3>Warning</h3>

<p>This method implements new functionality. Its user interface may
be subject to change.
</p>

<hr>
<h2 id='confint.LmME'>Confidence intervals for LmME model parameters</h2><span id='topic+confint.LmME'></span>

<h3>Description</h3>

<p>Confidence intervals for model parameters on their original scale,
optionally consistent with the linear mixed-model specification.
When <code>as.lm = TRUE</code>, only Wald CIs are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LmME'
confint(
  object,
  parm = NULL,
  level = 0.95,
  as.lm = FALSE,
  pargroup = c("all", "fixef", "ranef"),
  type = c("Wald", "wald", "profile"),
  estimate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.LmME_+3A_object">object</code></td>
<td>
<p>An <code>LmME</code> object.</p>
</td></tr>
<tr><td><code id="confint.LmME_+3A_parm">parm</code></td>
<td>
<p>Names of the parameters to extract.</p>
</td></tr>
<tr><td><code id="confint.LmME_+3A_level">level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
<tr><td><code id="confint.LmME_+3A_as.lm">as.lm</code></td>
<td>
<p>Logical. If <code>TRUE</code>, return results consistent with the normal linear
mixed model parameterization.</p>
</td></tr>
<tr><td><code id="confint.LmME_+3A_pargroup">pargroup</code></td>
<td>
<p>The name of the parameter group to extract. With <code>as.lm = FALSE</code>,
the available options are described in <code>confint.tramME</code>. When <code>as.lm = TRUE</code>,
the following options are available:
</p>

<ul>
<li><p> all: Fixed effects and variance components parameters.
</p>
</li>
<li><p> fixef: Fixed effects parameters (including FE parameters of the smooth terms).
</p>
</li>
<li><p> ranef: Variance components parameters (including the smoothing parameters of
the random effects).
</p>
</li></ul>
</td></tr>
<tr><td><code id="confint.LmME_+3A_type">type</code></td>
<td>
<p>Type of the CI: either Wald or profile.</p>
</td></tr>
<tr><td><code id="confint.LmME_+3A_estimate">estimate</code></td>
<td>
<p>Logical, add the point estimates in a thrid column.</p>
</td></tr>
<tr><td><code id="confint.LmME_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code>confint.tramME</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with lower and upper bounds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
confint(fit) ## transformation model parameterization
confint(fit, as.lm = TRUE) ## LMM parameterization
confint(fit, as.lm = TRUE, pargroup = "fixef", estimate = TRUE)
confint(fit, as.lm = TRUE, parm = "(Sigma)") ## error SD
</code></pre>

<hr>
<h2 id='confint.tramME'>Confidence intervals for tramME model parameters</h2><span id='topic+confint.tramME'></span>

<h3>Description</h3>

<p>Confidence intervals for model parameters on their original scale.
Either Wald CI or profile CI by root finding. Multicore computations
are supported in the case of profile confidence intervals, but snow
support is yet to be implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
confint(
  object,
  parm = NULL,
  level = 0.95,
  pargroup = c("all", "fixef", "shift", "baseline", "ranef", "smooth"),
  type = c("Wald", "wald", "profile"),
  estimate = FALSE,
  pmatch = FALSE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("profile.ncpus", 1L),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="confint.tramME_+3A_parm">parm</code></td>
<td>
<p>The indices or names of the parameters of interest.</p>
</td></tr>
<tr><td><code id="confint.tramME_+3A_level">level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
<tr><td><code id="confint.tramME_+3A_pargroup">pargroup</code></td>
<td>
<p>The name of the parameter group to return:
</p>

<ul>
<li><p> all: All parameters.
</p>
</li>
<li><p> fixef: Fixed effects parameters.
</p>
</li>
<li><p> shift: Shift parameters.
</p>
</li>
<li><p> baseline: Parameters of the baseline transformation function.
</p>
</li>
<li><p> ranef: Variance components parameters.
</p>
</li>
<li><p> smooth: Paramaters that belong to the smooth shift terms
(both FE and smoothing parameters).
</p>
</li></ul>
</td></tr>
<tr><td><code id="confint.tramME_+3A_type">type</code></td>
<td>
<p>Type of the CI: either Wald or profile.</p>
</td></tr>
<tr><td><code id="confint.tramME_+3A_estimate">estimate</code></td>
<td>
<p>Logical, add the point estimates in a thrid column.</p>
</td></tr>
<tr><td><code id="confint.tramME_+3A_pmatch">pmatch</code></td>
<td>
<p>Logical. If <code>TRUE</code>, partial name matching is allowed.</p>
</td></tr>
<tr><td><code id="confint.tramME_+3A_parallel">parallel</code></td>
<td>
<p>Method for parallel computation.</p>
</td></tr>
<tr><td><code id="confint.tramME_+3A_ncpus">ncpus</code></td>
<td>
<p>Number of cores to use for parallel computation.</p>
</td></tr>
<tr><td><code id="confint.tramME_+3A_...">...</code></td>
<td>
<p>Optional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with lower and upper bounds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- BoxCoxME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
confint(fit)
confint(fit, pargroup = "shift", estimate = TRUE)
exp(confint(fit, 1:2, pargroup = "ranef")) ## CIs for the SDs of the REs
</code></pre>

<hr>
<h2 id='CoxphME'>Mixed-effects Additive Parametric Cox Regression Model</h2><span id='topic+CoxphME'></span>

<h3>Description</h3>

<p>Estimates a mixed-effects additive transformation model with flexible smooth
parameterization for the baseline transformation (log-cumulative baseline
hazard) and the inverse link set to the CDF of the standard minimum extreme
value distribution (see Hothorn et al., 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoxphME(
  formula,
  data,
  subset,
  weights,
  offset,
  na.action = na.omit,
  silent = TRUE,
  resid = FALSE,
  do_update = FALSE,
  estinit = TRUE,
  initpar = NULL,
  fixed = NULL,
  nofit = FALSE,
  control = optim_control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoxphME_+3A_formula">formula</code></td>
<td>
<p>A formula describing the model. Smooth additive terms are
defined the way as in <code>mgcv</code>, and random effects consistently with
the notation used in <code>lme4</code>.</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>.
</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_weights">weights</code></td>
<td>
<p>an optional vector of case weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector. If present,
the weighted log-likelihood is maximised.
</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an _a priori_ known component to
be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the
number of cases.
</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set to <code>na.omit</code>.
</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_silent">silent</code></td>
<td>
<p>Logical. Make <span class="pkg">TMB</span> functionality silent.</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_resid">resid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the score residuals are also calculated.
This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_do_update">do_update</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model is set up so that the weights and the
offsets are updateable. This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_estinit">estinit</code></td>
<td>
<p>Logical. Estimate a vector of initial values for the fixed effects parameters
from a (fixed effects only) mlt model</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_initpar">initpar</code></td>
<td>
<p>Named list of initial parameter values, if <code>NULL</code>, it is ignored</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_fixed">fixed</code></td>
<td>
<p>a named vector of fixed regression coefficients; the names
need to correspond to column names of the design matrix</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_nofit">nofit</code></td>
<td>
<p>logical, if TRUE, creates the model object, but does not run the optimization</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_control">control</code></td>
<td>
<p>list with controls for optimization</p>
</td></tr>
<tr><td><code id="CoxphME_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="tram.html#topic+tram">tram</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model extends <code><a href="tram.html#topic+Coxph">tram::Coxph</a></code> with random effects and
(optionally penalized) additive terms. For details on mixed-effect
transformation models, see Tamasi and Hothorn (2021).
</p>
<p>The elements of the linear predictor are parameterized with positive
parameters (i.e. <code>negative = FALSE</code> in <code><a href="tram.html#topic+tram">tram</a></code>).
</p>


<h3>Value</h3>

<p>A <code>CoxphME</code> model object.
</p>


<h3>References</h3>

<p>Hothorn, Torsten, Lisa Möst, and Peter Bühlmann. &quot;Most Likely
Transformations.&quot;  Scandinavian Journal of Statistics 45, no. 1 (March
2018): 110–34.  &lt;doi:10.1111/sjos.12291&gt;
</p>
<p>Tamasi, Balint, and Torsten Hothorn. &quot;tramME: Mixed-Effects Transformation
Models Using Template Model Builder.&quot; The R Journal 13, no. 2 (2021):
398–418. &lt;doi:10.32614/RJ-2021-075&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("survival")
rats$litter &lt;- factor(rats$litter)
m &lt;- CoxphME(Surv(time, status) ~ rx + (1 | litter), data = rats,
             log_first = TRUE)
summary(m)
</code></pre>

<hr>
<h2 id='edf_smooth.tramME'>EDFs of smooth shift terms</h2><span id='topic+edf_smooth.tramME'></span><span id='topic+edf_smooth'></span>

<h3>Description</h3>

<p>Returns an estimate of effective degrees of freedom associated with each
smooth term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
edf_smooth(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edf_smooth.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="edf_smooth.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to the Hessian calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EDFs are calculated by summing up the elements of
</p>
<p style="text-align: center;"><code class="reqn">diag(V_{\vartheta}I)</code>
</p>
<p> term-by-term.
<code class="reqn">V_{\vartheta}</code> is the joint covariance matrix of fixed and random
parameters (the inverse of the joint precision, i.e., Hessian of the
negative log-likelihood), and <code class="reqn">I</code> is the joint precision of the
unpenalized negative log-likelihood function. See Wood et al. (2016) or
Wood (2017, Chapter 6) for references.
</p>


<h3>Value</h3>

<p>A named vector with the edf values.
</p>


<h3>References</h3>

<p>Wood, Simon N., Natalya Pya, and Benjamin Saefken (2016).  &quot;Smoothing
Parameter and Model Selection for General Smooth Models.&quot;  Journal of the
American Statistical Association 111, &lt;doi:10.1080/01621459.2016.1180986&gt;
</p>
<p>Wood, Simon N. (2017). Generalized Additive Models: An Introduction with R.
Second edition. Chapman &amp; Hall/CRC Texts in Statistical Science.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mcycle", package = "MASS")
fit &lt;- LmME(accel ~ s(times), data = mcycle)
edf_smooth(fit)
</code></pre>

<hr>
<h2 id='LehmannME'>Mixed-effects Additive Lehmann-alternative Linear Regression Model</h2><span id='topic+LehmannME'></span>

<h3>Description</h3>

<p>Estimates a mixed-effects additive transformation model with flexible smooth
parameterization for the baseline transformation and the inverse link set to
the CDF of the standard maximum extreme value distribution (see Hothorn et
al., 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LehmannME(
  formula,
  data,
  subset,
  weights,
  offset,
  na.action = na.omit,
  silent = TRUE,
  resid = FALSE,
  do_update = FALSE,
  estinit = TRUE,
  initpar = NULL,
  fixed = NULL,
  nofit = FALSE,
  control = optim_control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LehmannME_+3A_formula">formula</code></td>
<td>
<p>A formula describing the model. Smooth additive terms are
defined the way as in <code>mgcv</code>, and random effects consistently with
the notation used in <code>lme4</code>.</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>.
</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_weights">weights</code></td>
<td>
<p>an optional vector of case weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector. If present,
the weighted log-likelihood is maximised.
</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an _a priori_ known component to
be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the
number of cases.
</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set to <code>na.omit</code>.
</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_silent">silent</code></td>
<td>
<p>Logical. Make <span class="pkg">TMB</span> functionality silent.</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_resid">resid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the score residuals are also calculated.
This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_do_update">do_update</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model is set up so that the weights and the
offsets are updateable. This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_estinit">estinit</code></td>
<td>
<p>Logical. Estimate a vector of initial values for the fixed effects parameters
from a (fixed effects only) mlt model</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_initpar">initpar</code></td>
<td>
<p>Named list of initial parameter values, if <code>NULL</code>, it is ignored</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_fixed">fixed</code></td>
<td>
<p>a named vector of fixed regression coefficients; the names
need to correspond to column names of the design matrix</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_nofit">nofit</code></td>
<td>
<p>logical, if TRUE, creates the model object, but does not run the optimization</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_control">control</code></td>
<td>
<p>list with controls for optimization</p>
</td></tr>
<tr><td><code id="LehmannME_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="tram.html#topic+tram">tram</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model extends <code><a href="tram.html#topic+Lehmann">tram::Lehmann</a></code> with random
effects and (optionally penalized) additive terms. For details on
mixed-effect transformation models, see Tamasi and Hothorn (2021).
</p>
<p>The elements of the linear predictor are parameterized with negative
parameters (i.e. <code>negative = TRUE</code> in <code><a href="tram.html#topic+tram">tram</a></code>).
</p>


<h3>Value</h3>

<p>A <code>LehmannME</code> model object.
</p>


<h3>References</h3>

<p>Hothorn, Torsten, Lisa Möst, and Peter Bühlmann. &quot;Most Likely
Transformations.&quot;  Scandinavian Journal of Statistics 45, no. 1 (March
2018): 110–34.  &lt;doi:10.1111/sjos.12291&gt;
</p>
<p>Tamasi, Balint, and Torsten Hothorn. &quot;tramME: Mixed-Effects Transformation
Models Using Template Model Builder.&quot; The R Journal 13, no. 2 (2021):
398–418. &lt;doi:10.32614/RJ-2021-075&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
m &lt;- LehmannME(Reaction ~ s(Days) + (Days | Subject), data = sleepstudy)
summary(m)
</code></pre>

<hr>
<h2 id='LmME'>Mixed-effects Additive Normal Linear Regression Model</h2><span id='topic+LmME'></span>

<h3>Description</h3>

<p>Estimates the normal linear model parameterized as a linear transformation
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LmME(
  formula,
  data,
  subset,
  weights,
  offset,
  na.action = na.omit,
  silent = TRUE,
  resid = FALSE,
  do_update = FALSE,
  estinit = TRUE,
  initpar = NULL,
  fixed = NULL,
  nofit = FALSE,
  control = optim_control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LmME_+3A_formula">formula</code></td>
<td>
<p>A formula describing the model. Smooth additive terms are
defined the way as in <code>mgcv</code>, and random effects consistently with
the notation used in <code>lme4</code>.</p>
</td></tr>
<tr><td><code id="LmME_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>.
</p>
</td></tr>
<tr><td><code id="LmME_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td></tr>
<tr><td><code id="LmME_+3A_weights">weights</code></td>
<td>
<p>an optional vector of case weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector. If present,
the weighted log-likelihood is maximised.
</p>
</td></tr>
<tr><td><code id="LmME_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an _a priori_ known component to
be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the
number of cases.
</p>
</td></tr>
<tr><td><code id="LmME_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set to <code>na.omit</code>.
</p>
</td></tr>
<tr><td><code id="LmME_+3A_silent">silent</code></td>
<td>
<p>Logical. Make <span class="pkg">TMB</span> functionality silent.</p>
</td></tr>
<tr><td><code id="LmME_+3A_resid">resid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the score residuals are also calculated.
This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="LmME_+3A_do_update">do_update</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model is set up so that the weights and the
offsets are updateable. This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="LmME_+3A_estinit">estinit</code></td>
<td>
<p>Logical. Estimate a vector of initial values for the fixed effects parameters
from a (fixed effects only) mlt model</p>
</td></tr>
<tr><td><code id="LmME_+3A_initpar">initpar</code></td>
<td>
<p>Named list of initial parameter values, if <code>NULL</code>, it is ignored</p>
</td></tr>
<tr><td><code id="LmME_+3A_fixed">fixed</code></td>
<td>
<p>a named vector of fixed regression coefficients; the names
need to correspond to column names of the design matrix</p>
</td></tr>
<tr><td><code id="LmME_+3A_nofit">nofit</code></td>
<td>
<p>logical, if TRUE, creates the model object, but does not run the optimization</p>
</td></tr>
<tr><td><code id="LmME_+3A_control">control</code></td>
<td>
<p>list with controls for optimization</p>
</td></tr>
<tr><td><code id="LmME_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="tram.html#topic+tram">tram</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The additive mixed-effects normal linear model is a special case of the
mixed-effects additive transformation model family, with the
transformation function restricted to be linear and the inverse link set
to the standard Gaussian CDF (see Hothorn et al., 2018). This function
estimates this model with the transformation model parameterization, and
offers features that are typically not available in other mixed-effects
additive implementations, such as stratum-specific variances, and censored
and/or truncated observations.
</p>
<p>The model extends <code><a href="tram.html#topic+Lm">tram::Lm</a></code> with random effects and
(optionally penalized) additive terms. For details on mixed-effect
transformation models, see Tamasi and Hothorn (2021).
</p>
<p>The elements of the linear predictor are parameterized with negative
parameters (i.e. <code>negative = TRUE</code> in <code><a href="tram.html#topic+tram">tram</a></code>).
</p>
<p>The results can be transformed back to the usual linear mixed/additive model
parametrization with specific methods provided by <code>tramME</code>. The
differences between the two parametrizations are discussed in Tamasi and
Hothorn (2021).
</p>


<h3>Value</h3>

<p>A <code>LmME</code> model object.
</p>


<h3>References</h3>

<p>Hothorn, Torsten, Lisa Möst, and Peter Bühlmann. &quot;Most Likely
Transformations.&quot;  Scandinavian Journal of Statistics 45, no. 1 (March
2018): 110–34.  &lt;doi:10.1111/sjos.12291&gt;
</p>
<p>Tamasi, Balint, and Torsten Hothorn. &quot;tramME: Mixed-Effects Transformation
Models Using Template Model Builder.&quot; The R Journal 13, no. 2 (2021):
398–418. &lt;doi:10.32614/RJ-2021-075&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("survival")
data("sleepstudy", package = "lme4")
## Create a version of the response with 200 ms detection limit and 50 ms
## step sizes
ub &lt;- ceiling(sleepstudy$Reaction / 50) * 50
lb &lt;- floor(sleepstudy$Reaction / 50) * 50
lb[ub == 200] &lt;- 0
sleepstudy$Reaction_ic &lt;- Surv(lb, ub, type = "interval2")
m &lt;- LmME(Reaction_ic ~ Days + (Days | Subject), data = sleepstudy)
summary(m)
coef(m, as.lm = TRUE)
</code></pre>

<hr>
<h2 id='logLik.tramME'>Get the log-likelihood of the tramME model</h2><span id='topic+logLik.tramME'></span>

<h3>Description</h3>

<p>Evaluates the log-likelihood function. New parameter values and data can
optionally be supplied. In the latter case, the function returns the
out-of-sample log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
logLik(
  object,
  param = NULL,
  newdata = NULL,
  type = c("integrated", "fix_smooth", "penalized"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="logLik.tramME_+3A_param">param</code></td>
<td>
<p>An optional named list of parameter values (beta and theta).
See details.  Optionally, gamma elements can also be added, which leads to
'fixing' those random effects terms at the supplied values.</p>
</td></tr>
<tr><td><code id="logLik.tramME_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame to calculate the out-of-sample
log-likelihood.</p>
</td></tr>
<tr><td><code id="logLik.tramME_+3A_type">type</code></td>
<td>
<p>The type of the likelihood to be calculated:
</p>

<ul>
<li><p> integrated (default when <code>newdata = NULL</code>): The marginal
log-likelihood, calculated by integrating out the random effects.
</p>
</li>
<li><p> fix_smooth (default when <code>newdata</code> is supplied): Treating the
penalized parameters of the smooth terms as fixed at their
posterior mode predictions and only integrating out the 'true'
random effects. (Consistent with the functionality of
<code><a href="#topic+ranef.tramME">ranef.tramME</a></code> and
<code><a href="#topic+residuals.tramME">residuals.tramME</a></code> when
<code>fix_smooth = TRUE</code>.)
</p>
</li>
<li><p> penalized: Treat all parameters as fixed, return the penalized
log-likelihood (conditional log-likelihood + penalty for smooth
terms and random effects). This is equivalent to fixing all random
effect values.
</p>
</li></ul>

<p>See details.</p>
</td></tr>
<tr><td><code id="logLik.tramME_+3A_...">...</code></td>
<td>
<p>Optional argument (for consistency with generic).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>param</code> is set to the estimated (or previously set)
parameters. If the parameter vectors in the model are incomplete (contain
<code>NA</code> elemets), the returned log-likelihood will also be <code>NA</code>,
unless the user provides new values.
</p>
<p>Setting <code>type = "fix_smooth"</code> fixes the random effects terms that
correspond to penalized smooths at their estimated values, so that they
are not refitted when <code>newdata</code> is supplied. This is consistent with
treating these parameter regularized fixed terms, i.e. as 'new-style'
random effects described by Hodges (2014, Chapter 13).
</p>
<p>The <code>"fix_smooth"</code> and <code>"penalized"</code> options for <code>type</code> are
just for convenience.  The same functionality can be achieved by setting
<code>param$gamma</code> to the desired values.  <code>"penalized"</code> respects the
values of <code>param$gamma</code> if both are supplied, while
<code>"fix_smooth"</code> overwrites them with the fitted values if there are
ambiguities.
</p>


<h3>Value</h3>

<p>A numeric value of the log-likelihood.
</p>


<h3>Type of the log-likelihood</h3>

<p>By default, <code>logLik</code> calculates the _integrated_ (or marginal)
log-likelihood by integrating over the random effects. By fixing the
random effects, the value of the log-likelihood changes, because TMB won't
integrate over these random effects.  This will result in the _penalized_
log-likelihood (conditional log-likelihood + penalty for smooth terms and
random effects, see example).
</p>
<p>By setting <code>type = "penalized"</code>, the function will 'fix' all random
effects and penalized parameters of the smooth terms at their predicted
levels, and calcualte the penalized log-likelihood. In this sense, setting
<code>type = "fix_smooth"</code> will result in a hybrid log-likelihood value,
where the 'true' random effects (c.f.  Hodges 2014, Ch. 13) are integrated
out, while it includes the penalty values for the penalized parameters of
the smooths terms.
</p>
<p>In general, it is not clear which type of log-likelihood we should calculate
when we want to evaluate models based on their out-of-sample
log-likelihood values.  The context and the model setup are key in these
cases. Please make sure you know what you want to calculate to avoid
misunderstandings.
</p>


<h3>References</h3>

<p>Hodges, James S. (2014). Richly Parameterized Linear Models: Additive, Time
Series, and Spatial Models Using Random Effects. Chapman &amp; Hall/CRC Texts
in Statistical Science Series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sleepstudy", package = "lme4")
fit &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
logLik(fit)

data("mcycle", package = "MASS")
fit &lt;- LmME(accel ~ s(times), data = mcycle)
logLik(fit) &lt; logLik(fit, type = "penalized")

</code></pre>

<hr>
<h2 id='model.frame.tramME'>Extract model frame from a tramME model</h2><span id='topic+model.frame.tramME'></span>

<h3>Description</h3>

<p>Extract model frame from a tramME model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
model.frame(
  formula,
  data = NULL,
  group_as_factor = FALSE,
  ignore_response = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.tramME_+3A_formula">formula</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="model.frame.tramME_+3A_data">data</code></td>
<td>
<p>a data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame),
containing the variables in <code>formula</code>.  Neither a matrix nor an
array will be accepted.</p>
</td></tr>
<tr><td><code id="model.frame.tramME_+3A_group_as_factor">group_as_factor</code></td>
<td>
<p>Logical; If <code>TRUE</code>, automatically convert the
grouping variables of the random effects to factors. (not used, might not be needed) ## FIXME</p>
</td></tr>
<tr><td><code id="model.frame.tramME_+3A_ignore_response">ignore_response</code></td>
<td>
<p>Logical; If <code>TRUE</code>, the response is not added to the
result. In this case the function won't look for it in <code>data</code>.</p>
</td></tr>
<tr><td><code id="model.frame.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments, passed to <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code><a href="mlt.html#topic+mlt">mlt</a></code>, the basis functions expect the response variables
in the data to be evaluated, i.e. instead of <code>x</code> and <code>y</code> columns
we should have a <code>`Surv(x, y)`</code> column when the response is a
<code><a href="survival.html#topic+Surv">Surv</a></code> object. <code>model.frame.tramME</code> builds the
model frame accordingly, assigning to the resulting object the class
<code>tramME_data</code> to indicate this structure to other functions that use
its results. If the input <code>data</code> is a <code>tramME_data</code> is also expects
this structure.
</p>


<h3>Value</h3>

<p>A <code>tramME_data</code> object, which is also a <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
mod &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy, nofit = TRUE)
model.frame(mod)
</code></pre>

<hr>
<h2 id='model.matrix.tramME'>Model matrices for <code>tramME</code> models</h2><span id='topic+model.matrix.tramME'></span>

<h3>Description</h3>

<p>Model matrix for fixed effects, random effects, and baseline transformations
(with interacting terms if present).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
model.matrix(
  object,
  data = model.frame(object),
  type = c("Y", "X", "Zt"),
  drop_unused_groups = FALSE,
  keep_sign = TRUE,
  simplify = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="model.matrix.tramME_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the variable values.</p>
</td></tr>
<tr><td><code id="model.matrix.tramME_+3A_type">type</code></td>
<td>
<p>&quot;X&quot;: Fixed effects model matrix. &quot;Zt&quot;: Random effects model matrix
(transposed). &quot;Y&quot;: Model matrices for the baseline transfromations.</p>
</td></tr>
<tr><td><code id="model.matrix.tramME_+3A_drop_unused_groups">drop_unused_groups</code></td>
<td>
<p>Logical; remove unused levels of the random effects.
(see <code>drop.unused.levels</code> argument of <code><a href="reformulas.html#topic+mkReTrms">mkReTrms</a></code>)</p>
</td></tr>
<tr><td><code id="model.matrix.tramME_+3A_keep_sign">keep_sign</code></td>
<td>
<p>Logical; the terms will have the same sign as in the
<code>tramME</code> model if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="model.matrix.tramME_+3A_simplify">simplify</code></td>
<td>
<p>Logical; Remove empty <code>Y</code> matrices.</p>
</td></tr>
<tr><td><code id="model.matrix.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates model matrices for fixed effects (<code>type = "X"</code>) and random
effects (<code>type = "Zt"</code>) and baseline transfromation (<code>type = "Y"</code>),
by evaluating the respective basis functions given a new dataset.
</p>
<p>The response values may be exact, censored (left, right, interval) and
truncated (left, right, interval), and the function returns several,
potentially empty, model matrices:
</p>

<ul>
<li><p> Ye: Exact observations.
</p>
</li>
<li><p> Yeprime: The model matrix corresponding to the first derivative
of the baseline transformation, evaluated at exact observations.
</p>
</li>
<li><p> Yl: Left-censored observations.
</p>
</li>
<li><p> Yr: Rigt-censored observations.
</p>
</li>
<li><p> Yil and Yir: Interval-censored observations evaluated at the
left and right bounds of the interval.
</p>
</li>
<li><p> Ytl: Left-truncated observations.
</p>
</li>
<li><p> Ytr: Rigt-truncated observations.
</p>
</li>
<li><p> Ytil and Ytir: Interval-truncated observations evaluated at the
left and right bounds of the interval.
</p>
</li></ul>

<p>for the baseline transfromations (unless <code>simplify = TRUE</code>).
</p>


<h3>Value</h3>

<p>List of requested model matrices.
</p>


<h3>Note</h3>

<p>The model matrix of the random effects is a sparse matrix and it is transposed
to be directly used with <code>Matrix::crossprod</code> which is faster than transposing
and multiplying (&quot;Zt&quot; instead of &quot;Z&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("survival")
rats$litter &lt;- factor(rats$litter)
m &lt;- CoxphME(Surv(time, status) ~ rx + (1 | litter), data = rats,
             log_first = TRUE, nofit = TRUE)
mm &lt;- model.matrix(m)
nd &lt;- model.frame(m)[rep(1, 100), ]
nd[[1]] &lt;- seq(1, 120, length.out = 100)
mm2 &lt;- model.matrix(m, data = nd, simplify = TRUE)
mm3 &lt;- model.matrix(m, data = nd, simplify = TRUE, drop_unused_groups = TRUE)
## compare mm2$Zt &amp; mm3$Zt
</code></pre>

<hr>
<h2 id='optim_control'>Set up and control optimization parameters</h2><span id='topic+optim_control'></span>

<h3>Description</h3>

<p>Set up and control optimization parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_control(
  method = c("nlminb", "BFGS", "CG", "L-BFGS-B"),
  scale = TRUE,
  trace = FALSE,
  ntry = 5,
  ok_warnings = "NA/NaN function evaluation",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim_control_+3A_method">method</code></td>
<td>
<p>Optimization procedure.</p>
</td></tr>
<tr><td><code id="optim_control_+3A_scale">scale</code></td>
<td>
<p>Logical; if <code>TRUE</code> rescale the fixed effects design matrix to improve
convergence.</p>
</td></tr>
<tr><td><code id="optim_control_+3A_trace">trace</code></td>
<td>
<p>Logical; print trace of the optimization.</p>
</td></tr>
<tr><td><code id="optim_control_+3A_ntry">ntry</code></td>
<td>
<p>Number of restarts with new random initialization if optimization
fails to converge.</p>
</td></tr>
<tr><td><code id="optim_control_+3A_ok_warnings">ok_warnings</code></td>
<td>
<p>Control for what warnings will be reported during
optimization. If <code>TRUE</code>, no warnings will be reported, if
<code>FALSE</code> all warnings are displayed. In case of a character vector,
the matching warnings are treated as unimportant, and not reported. See also Notes.</p>
</td></tr>
<tr><td><code id="optim_control_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="alabama.html#topic+auglag">auglag</a></code>,
<code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+optim">optim</a></code> as a list of control
parameters.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Irrespective of the value of the <code>ok_warnings</code> argument, all
warnings are collected in the <code>opt$warnings</code> element of the
<code>tramME</code> object.
</p>

<hr>
<h2 id='plot_ci'>Plot confidence bands from <code>tramME</code> models</h2><span id='topic+plot_ci'></span><span id='topic+plot.confband.tramME'></span>

<h3>Description</h3>

<p>Plotting method for <code>confband.tramME</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'confband.tramME'
plot(
  x,
  col,
  lty,
  fill,
  add = FALSE,
  single_plot = FALSE,
  trafo_x = identity,
  trafo_y = identity,
  align_xlim = FALSE,
  align_ylim = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ci_+3A_x">x</code></td>
<td>
<p>The object containing the confidence intervals.</p>
</td></tr>
<tr><td><code id="plot_ci_+3A_col">col</code></td>
<td>
<p>Color of the point estimates.</p>
</td></tr>
<tr><td><code id="plot_ci_+3A_lty">lty</code></td>
<td>
<p>Line type of the point estimates.</p>
</td></tr>
<tr><td><code id="plot_ci_+3A_fill">fill</code></td>
<td>
<p>Fill color for the intervals.</p>
</td></tr>
<tr><td><code id="plot_ci_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, no new plot is created, the interval is added to
the current plot.</p>
</td></tr>
<tr><td><code id="plot_ci_+3A_single_plot">single_plot</code></td>
<td>
<p>If <code>TRUE</code>, a single new plot is created, and all
intervals are plotted on it.</p>
</td></tr>
<tr><td><code id="plot_ci_+3A_trafo_x">trafo_x</code></td>
<td>
<p>Transform x-axis before plotting.</p>
</td></tr>
<tr><td><code id="plot_ci_+3A_trafo_y">trafo_y</code></td>
<td>
<p>Transform y-axis before plotting.</p>
</td></tr>
<tr><td><code id="plot_ci_+3A_align_xlim">align_xlim</code></td>
<td>
<p>If <code>TRUE</code>, align the x-axis limits across all
subplots.</p>
</td></tr>
<tr><td><code id="plot_ci_+3A_align_ylim">align_ylim</code></td>
<td>
<p>If <code>TRUE</code>, align the y-axis limits across all
subplots.</p>
</td></tr>
<tr><td><code id="plot_ci_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
and <code><a href="graphics.html#topic+plot.xy">plot.xy</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.smooth.tramME'>Plot smooth terms of a tramME model.</h2><span id='topic+plot.smooth.tramME'></span>

<h3>Description</h3>

<p>Plot smooth terms of a tramME model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smooth.tramME'
plot(
  x,
  which = seq_along(x),
  col = 1,
  fill = grey(0.5, 0.25),
  trafo = I,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smooth.tramME_+3A_x">x</code></td>
<td>
<p>A <code>smooth.tramME</code> object.</p>
</td></tr>
<tr><td><code id="plot.smooth.tramME_+3A_which">which</code></td>
<td>
<p>Select terms to be printed by their indices</p>
</td></tr>
<tr><td><code id="plot.smooth.tramME_+3A_col">col</code></td>
<td>
<p>Line color for the point estimates.</p>
</td></tr>
<tr><td><code id="plot.smooth.tramME_+3A_fill">fill</code></td>
<td>
<p>Fill color for the confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.smooth.tramME_+3A_trafo">trafo</code></td>
<td>
<p>Monotonic transformation to be applied on the smooth terms</p>
</td></tr>
<tr><td><code id="plot.smooth.tramME_+3A_add">add</code></td>
<td>
<p>Add the plot to an existing figure.</p>
</td></tr>
<tr><td><code id="plot.smooth.tramME_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to the plotting functions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("mcycle", package = "MASS")
fit &lt;- LmME(accel ~ s(times), data = mcycle)
plot(smooth_terms(fit, as.lm = TRUE))
</code></pre>

<hr>
<h2 id='plot.tramME'>Plotting method for tramME objects</h2><span id='topic+plot.tramME'></span>

<h3>Description</h3>

<p>Plot the conditional distribution evaluated at a grid of possible response
values and a set of covariate and random effects values on a specified scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
plot(
  x,
  newdata = model.frame(x),
  ranef = NULL,
  fix_smooth = TRUE,
  type = c("trafo", "distribution", "logdistribution", "survivor", "logsurvivor",
    "density", "logdensity", "hazard", "loghazard", "cumhazard", "logcumhazard", "odds",
    "logodds", "quantile"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tramME_+3A_x">x</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="plot.tramME_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame of observations</p>
</td></tr>
<tr><td><code id="plot.tramME_+3A_ranef">ranef</code></td>
<td>
<p>Random effects (either in named list format or a numeric vector)
or the word &quot;zero&quot;. See Details.</p>
</td></tr>
<tr><td><code id="plot.tramME_+3A_fix_smooth">fix_smooth</code></td>
<td>
<p>If <code>FALSE</code>, the random effects coefficients of the smooth
terms are refitted to <code>newdata</code>. It's probably not what you want to do.</p>
</td></tr>
<tr><td><code id="plot.tramME_+3A_type">type</code></td>
<td>
<p>The scale on which the predictions are evaluated:
</p>

<ul>
<li><p> trafo: The prediction evaluated on the scale of the
transformation function.
</p>
</li>
<li><p> (log)distribution: The prediction evaluated on the scale of the
conditional (log-)CDF.
</p>
</li>
<li><p> (log)survivor: The prediction evaluated on the scale of the
(conditional) (log-)survivor function.
</p>
</li>
<li><p> (log)density: The prediction evaluated on the scale of
the conditional (log-)PDF.
</p>
</li>
<li><p> (log)hazard: The prediction evaluated on the (log-)hazard scale.
</p>
</li>
<li><p> (log)cumhazard: The prediction evaluated on the (log-)cumulative
hazard scale.
</p>
</li>
<li><p> (log)odds: The prediction evaluated on the (log-)odds scale.
</p>
</li>
<li><p> quantile: Return the quantiles of the conditional outcome distribution
corresponding to <code>newdata</code>. For more information, see Details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.tramME_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code><a href="mlt.html#topic+plot.mlt">plot.mlt</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>ranef</code> is equal to &quot;zero&quot;, a vector of zeros with the right size is
substituted. For more details, see <code><a href="#topic+predict.tramME">predict.tramME</a></code>.
</p>
<p>For more information on how to control the grid on which the functions are evaluated,
see the documentation of <code><a href="mlt.html#topic+predict.mlt">predict.mlt</a></code>.
</p>


<h3>Value</h3>

<p>A numeric matrix of the predicted values invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- BoxCoxME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
plot(fit, K = 100, type = "density")
</code></pre>

<hr>
<h2 id='PolrME'>Mixed-effects Additive Transformation Models for Ordered Categorical
Responses</h2><span id='topic+PolrME'></span>

<h3>Description</h3>

<p>Estimates mixed-effects additive transformation models for ordered
categorical responses with various link functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PolrME(
  formula,
  data,
  subset,
  weights,
  offset,
  na.action = na.omit,
  method = c("logistic", "probit", "loglog", "cloglog"),
  silent = TRUE,
  resid = FALSE,
  do_update = FALSE,
  estinit = TRUE,
  initpar = NULL,
  fixed = NULL,
  nofit = FALSE,
  control = optim_control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PolrME_+3A_formula">formula</code></td>
<td>
<p>A formula describing the model. Smooth additive terms are
defined the way as in <code>mgcv</code>, and random effects consistently with
the notation used in <code>lme4</code>.</p>
</td></tr>
<tr><td><code id="PolrME_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>.
</p>
</td></tr>
<tr><td><code id="PolrME_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td></tr>
<tr><td><code id="PolrME_+3A_weights">weights</code></td>
<td>
<p>an optional vector of case weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector. If present,
the weighted log-likelihood is maximised.
</p>
</td></tr>
<tr><td><code id="PolrME_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an _a priori_ known component to
be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the
number of cases.
</p>
</td></tr>
<tr><td><code id="PolrME_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set to <code>na.omit</code>.
</p>
</td></tr>
<tr><td><code id="PolrME_+3A_method">method</code></td>
<td>
<p>a character describing the link function.
</p>
</td></tr>
<tr><td><code id="PolrME_+3A_silent">silent</code></td>
<td>
<p>Logical. Make <span class="pkg">TMB</span> functionality silent.</p>
</td></tr>
<tr><td><code id="PolrME_+3A_resid">resid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the score residuals are also calculated.
This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="PolrME_+3A_do_update">do_update</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model is set up so that the weights and the
offsets are updateable. This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="PolrME_+3A_estinit">estinit</code></td>
<td>
<p>Logical. Estimate a vector of initial values for the fixed effects parameters
from a (fixed effects only) mlt model</p>
</td></tr>
<tr><td><code id="PolrME_+3A_initpar">initpar</code></td>
<td>
<p>Named list of initial parameter values, if <code>NULL</code>, it is ignored</p>
</td></tr>
<tr><td><code id="PolrME_+3A_fixed">fixed</code></td>
<td>
<p>a named vector of fixed regression coefficients; the names
need to correspond to column names of the design matrix</p>
</td></tr>
<tr><td><code id="PolrME_+3A_nofit">nofit</code></td>
<td>
<p>logical, if TRUE, creates the model object, but does not run the optimization</p>
</td></tr>
<tr><td><code id="PolrME_+3A_control">control</code></td>
<td>
<p>list with controls for optimization</p>
</td></tr>
<tr><td><code id="PolrME_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="tram.html#topic+tram">tram</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformation function is parameterized as a step function on a scale
defined by the link function (see Hothorn et al., 2018).
</p>
<p>The model extends <code><a href="tram.html#topic+Polr">tram::Polr</a></code> with random effects and
(optionally penalized) additive terms. For details on mixed-effect
transformation models, see Tamasi and Hothorn (2021).
</p>
<p>The elements of the linear predictor are parameterized with negative
parameters (i.e. <code>negative = TRUE</code> in <code><a href="tram.html#topic+tram">tram</a></code>).
</p>


<h3>Value</h3>

<p>A <code>PolrME</code> model object.
</p>


<h3>References</h3>

<p>Hothorn, Torsten, Lisa Möst, and Peter Bühlmann. &quot;Most Likely
Transformations.&quot;  Scandinavian Journal of Statistics 45, no. 1 (March
2018): 110–34.  &lt;doi:10.1111/sjos.12291&gt;
</p>
<p>Tamasi, Balint, and Torsten Hothorn. &quot;tramME: Mixed-Effects Transformation
Models Using Template Model Builder.&quot; The R Journal 13, no. 2 (2021):
398–418. &lt;doi:10.32614/RJ-2021-075&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("soup", package = "ordinal")
m &lt;- PolrME(SURENESS | SOUPFREQ ~ PROD + (1 | RESP/PROD),
            data = soup, method = "probit")
summary(m)
</code></pre>

<hr>
<h2 id='predict.tramME'>Predict method for tramME objects</h2><span id='topic+predict.tramME'></span>

<h3>Description</h3>

<p>Evaluates the _conditional_ distribution implied by a tramME model, given by a
set of covariates and random effects on a selected scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
predict(
  object,
  newdata = model.frame(object),
  ranef = NULL,
  fix_smooth = TRUE,
  type = c("lp", "trafo", "distribution", "logdistribution", "survivor", "logsurvivor",
    "density", "logdensity", "hazard", "loghazard", "cumhazard", "logcumhazard", "odds",
    "logodds", "quantile"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="predict.tramME_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame of observations</p>
</td></tr>
<tr><td><code id="predict.tramME_+3A_ranef">ranef</code></td>
<td>
<p>Random effects it can be a <code>ranef.tramME</code> object, a named list,
an unnamed list, <code>NULL</code> or the word &quot;zero&quot;. See Details.</p>
</td></tr>
<tr><td><code id="predict.tramME_+3A_fix_smooth">fix_smooth</code></td>
<td>
<p>If <code>FALSE</code>, the random effects coefficients of the smooth
terms are refitted to <code>newdata</code>. It's probably not what you want to do.</p>
</td></tr>
<tr><td><code id="predict.tramME_+3A_type">type</code></td>
<td>
<p>The scale on which the predictions are evaluated:
</p>

<ul>
<li><p> lp: Linear predictor (Xb + Zg). For more information, see Details.
</p>
</li>
<li><p> trafo: The prediction evaluated on the scale of the
transformation function.
</p>
</li>
<li><p> (log)distribution: The prediction evaluated on the scale of the
conditional (log-)CDF.
</p>
</li>
<li><p> (log)survivor: The prediction evaluated on the scale of the
(conditional) (log-)survivor function.
</p>
</li>
<li><p> (log)density: The prediction evaluated on the scale of
the conditional (log-)PDF.
</p>
</li>
<li><p> (log)hazard: The prediction evaluated on the (log-)hazard scale.
</p>
</li>
<li><p> (log)cumhazard: The prediction evaluated on the (log-)cumulative
hazard scale.
</p>
</li>
<li><p> (log)odds: The prediction evaluated on the (log-)odds scale.
</p>
</li>
<li><p> quantile: Return the quantiles of the conditional outcome distribution
corresponding to <code>newdata</code>. For more information, see Details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.tramME_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code><a href="mlt.html#topic+predict.mlt">predict.mlt</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>newdata</code> contains values of the response variable, prediction is only
done for those values. In this case, if random effects vector (<code>ranef</code>) is not
supplied by the user, the function predicts the random effects from the model
using <code>newdata</code>.
</p>
<p>When no response values are supplied in <code>newdata</code>, the prediction is done
on a grid of values for each line of the dataset (see <code><a href="mlt.html#topic+predict.mlt">predict.mlt</a></code>
for information on how to control the setup of this grid).
In this case, the user has to specify the vector of random effects to avoid ambiguities.
</p>
<p>The linear predictor (<code>type = "lp"</code>) equals to the shift terms plus the random
effects terms _without the baseline transfromation function_.
</p>
<p>The linear predictor (<code>type = "lp"</code>) and the conditional quantile function
(<code>type = "quantile"</code>) are special in that they do not return results evaluated
on a grid, even when the response variable in <code>newdata</code> is missing. The probabilities
for the evaluation of the quantile function can be supplied with the <code>prob</code> argument
of <code><a href="mlt.html#topic+predict.mlt">predict.mlt</a></code>.
</p>
<p>In the case of <code>type = "quantile"</code>, when the some of the requested conditonal
quantiles fall outside of the support of the response distribution
(specified when the model was set up), the inversion of the CDF cannot be done exactly
and <code>tramME</code> returns censored values.
</p>
<p><code>ranef</code> can be different objects based on what we want to calculate and
what the other inputs are. If <code>ranef</code> is a <code>ranef.tramME</code>, we assume
that it contains the full set of random effects, but not the penalized coefficients
of the smooth terms. In this case <code>fix_smooth</code> must be <code>TRUE</code>. If
<code>ranef</code> is a named vector, we are fixing the supplied random effects (and
penalized coefficients) and predict the rest from <code>newdata</code> (<code>fix_smooth</code>
may also be used in this case). In this case, the random effects are identified
with the same naming convention as in <code>object$param$gamma</code>.
</p>
<p>If <code>ranef</code> is an unnamed vector, the function expects the
full set of necessary random effects (with or without penalized coefficients, depending
on <code>fix_smooth</code>). If <code>ranef = NULL</code> (the default), all random effects and
optionally penalized parameters (although this is not recommended) are predicted from
<code>newdata</code>. Finally, if <code>ranef</code> is equal to &quot;zero&quot;, a vector of zeros with the
right size is used.
</p>


<h3>Value</h3>

<p>A numeric vector/matrix of the predicted values (depending on the inputs)
or a <code>response</code> object, when the some of the requested conditonal quantiles
fall outside of the support of the response distribution specified when the model
was set up (only can occur with <code>type = "quantile"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- BoxCoxME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
predict(fit, type = "trafo") ## evaluate on the transformation function scale
nd &lt;- sleepstudy
nd$Reaction &lt;- NULL
pr &lt;- predict(fit, newdata = nd, ranef = ranef(fit), type = "distribution",
              K = 100)
</code></pre>

<hr>
<h2 id='predict.tramTMB'>Post-estimation calculations in a tramTMB model</h2><span id='topic+predict.tramTMB'></span>

<h3>Description</h3>

<p>Post-estimation calculations in a tramTMB model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramTMB'
predict(
  object,
  newdata,
  parameters = .get_par(object, full = TRUE),
  scale = c("lp", "trafo"),
  cov = FALSE,
  as.lm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.tramTMB_+3A_object">object</code></td>
<td>
<p>A <code>tramTMB</code> object</p>
</td></tr>
<tr><td><code id="predict.tramTMB_+3A_newdata">newdata</code></td>
<td>
<p>A named list with elements Y, X and Z (not all necessary)</p>
</td></tr>
<tr><td><code id="predict.tramTMB_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter values</p>
</td></tr>
<tr><td><code id="predict.tramTMB_+3A_scale">scale</code></td>
<td>
<p>The scale on which the post-estimation calculations are done</p>
</td></tr>
<tr><td><code id="predict.tramTMB_+3A_cov">cov</code></td>
<td>
<p>Logical; If <code>TRUE</code>, calculate the full covariance matrix
of the calculated values</p>
</td></tr>
<tr><td><code id="predict.tramTMB_+3A_as.lm">as.lm</code></td>
<td>
<p>Logical; reparameterize as a LMM</p>
</td></tr>
<tr><td><code id="predict.tramTMB_+3A_...">...</code></td>
<td>
<p>Optional arguments (ignored).</p>
</td></tr>
</table>

<hr>
<h2 id='print.anova.tramME'>Printing <code>anova.tramME</code> table</h2><span id='topic+print.anova.tramME'></span>

<h3>Description</h3>

<p>Printing <code>anova.tramME</code> table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anova.tramME'
print(
  x,
  digits = max(getOption("digits") - 2L, 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.anova.tramME_+3A_x">x</code></td>
<td>
<p>A <code>anova.tramME</code> object.</p>
</td></tr>
<tr><td><code id="print.anova.tramME_+3A_digits">digits</code></td>
<td>
<p>minimum number of significant digits to be used for
most numbers.</p>
</td></tr>
<tr><td><code id="print.anova.tramME_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical; if <code>TRUE</code>, P-values are additionally
encoded visually as &lsquo;significance stars&rsquo; in order to help scanning
of long coefficient tables.  It defaults to the
<code>show.signif.stars</code> slot of <code><a href="base.html#topic+options">options</a></code>.</p>
</td></tr>
<tr><td><code id="print.anova.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly retrurns the <code>anova.tramME</code> object.
</p>

<hr>
<h2 id='print.summary.tramME'>Print method for tramME model summary</h2><span id='topic+print.summary.tramME'></span>

<h3>Description</h3>

<p>Print method for tramME model summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.tramME'
print(
  x,
  fancy = !isTRUE(getOption("knitr.in.progress")) &amp;&amp; interactive(),
  digits = max(getOption("digits") - 2L, 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.tramME_+3A_x">x</code></td>
<td>
<p>A <code>summary.tramME</code> object.</p>
</td></tr>
<tr><td><code id="print.summary.tramME_+3A_fancy">fancy</code></td>
<td>
<p>Logical, if <code>TRUE</code>, use color in outputs.</p>
</td></tr>
<tr><td><code id="print.summary.tramME_+3A_digits">digits</code></td>
<td>
<p>minimum number of significant digits to be used for
most numbers.</p>
</td></tr>
<tr><td><code id="print.summary.tramME_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical; if <code>TRUE</code>, P-values are additionally
encoded visually as &lsquo;significance stars&rsquo; in order to help scanning
of long coefficient tables.  It defaults to the
<code>show.signif.stars</code> slot of <code><a href="base.html#topic+options">options</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input summary.tramME object, invisibly.
</p>

<hr>
<h2 id='print.tramME'>Print tramME model</h2><span id='topic+print.tramME'></span>

<h3>Description</h3>

<p>Print tramME model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
print(x, digits = max(getOption("digits") - 2L, 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tramME_+3A_x">x</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="print.tramME_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits</p>
</td></tr>
<tr><td><code id="print.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments (for consistency with the generic)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>tramME</code> object invisibly
</p>

<hr>
<h2 id='print.VarCorr.tramME'>Print method for the variance-correlation parameters of a tramME object</h2><span id='topic+print.VarCorr.tramME'></span>

<h3>Description</h3>

<p>Print method for the variance-correlation parameters of a tramME object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VarCorr.tramME'
print(x, sd = TRUE, digits = max(getOption("digits") - 2L, 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.VarCorr.tramME_+3A_x">x</code></td>
<td>
<p>A <code>VarCorr.tramME</code> object.</p>
</td></tr>
<tr><td><code id="print.VarCorr.tramME_+3A_sd">sd</code></td>
<td>
<p>Logical. Print standard deviations instead of variances.</p>
</td></tr>
<tr><td><code id="print.VarCorr.tramME_+3A_digits">digits</code></td>
<td>
<p>Number of digits</p>
</td></tr>
<tr><td><code id="print.VarCorr.tramME_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the input VarCorr.tramME object.
</p>

<hr>
<h2 id='ranef.LmME'>Extract the conditional modes of random effects of an LmME model</h2><span id='topic+ranef.LmME'></span>

<h3>Description</h3>

<p>The <code>condVar</code> option is not implemented for <code>ranef.LmME</code>.
Setting <code>raw=TURE</code> will return the raw random effects estimates from
the transformation model parameterization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LmME'
ranef(object, as.lm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.LmME_+3A_object">object</code></td>
<td>
<p>A fitted LmME object.</p>
</td></tr>
<tr><td><code id="ranef.LmME_+3A_as.lm">as.lm</code></td>
<td>
<p>If <code>TRUE</code>, return the transformed conditional modes as in a
normal linear mixed effects model.</p>
</td></tr>
<tr><td><code id="ranef.LmME_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code>ranef.tramME</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or a <code>ranef.tramME</code> object depending on the inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
ranef(fit, raw = TRUE) ## transformation model parameterization!
ranef(fit, as.lm = TRUE)
</code></pre>

<hr>
<h2 id='ranef.tramME'>Point estimates and conditional variances of random effects.</h2><span id='topic+ranef.tramME'></span><span id='topic+ranef'></span>

<h3>Description</h3>

<p>Extract the conditional modes and conditional variances of random effects in
a formatted or unformatted way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
ranef(
  object,
  param = NULL,
  newdata = NULL,
  fix_smooth = !is.null(newdata),
  condVar = FALSE,
  raw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="ranef.tramME_+3A_param">param</code></td>
<td>
<p>An optional named list of parameter values (beta and theta).
See details.  Optionally, gamma elements can also be added, which leads to
'fixing' those random effects terms at the supplied values.</p>
</td></tr>
<tr><td><code id="ranef.tramME_+3A_newdata">newdata</code></td>
<td>
<p>An optional <code>data.frame</code> of new observations for which the
new random effects values are predicted.</p>
</td></tr>
<tr><td><code id="ranef.tramME_+3A_fix_smooth">fix_smooth</code></td>
<td>
<p>Logical; it is set to <code>TRUE</code> by default, if
<code>newdata</code> is supplied.  The random effects parameters corresponding
the smooth terms are fixed and not fitted (posterior mode) to
<code>newdata</code> instead they are treated just like fixed effects
parameters. See details.</p>
</td></tr>
<tr><td><code id="ranef.tramME_+3A_condvar">condVar</code></td>
<td>
<p>If <code>TRUE</code>, include the conditional variances as attributes.
Only works with <code>raw = FALSE</code>.</p>
</td></tr>
<tr><td><code id="ranef.tramME_+3A_raw">raw</code></td>
<td>
<p>Return the unformatted RE estimates as fitted by the model.</p>
</td></tr>
<tr><td><code id="ranef.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments (for consistency with generic)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>raw = TRUE</code> returns the whole vector of random effects (i.e. with
parameters of smooth shift terms), while <code>raw = FALSE</code> only returns
the formatted list of actual random effects (i.e. for grouped
observations) values. For the conceptual differences between the two types
of random effects, see Hodges (2014, Chapter 13).
</p>
<p>The conditional variances of the fixed random effects are set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>Depending on the value of <code>raw</code>, either a numeric vector or a
<code>ranef.tramME</code> object which contains the conditional mode and variance
estimates by grouping factors.
</p>


<h3>Warning</h3>

<p>The function has several optional arguments that allow great flexibilty
beyond its most basic usage. The user should be careful with setting
these, because some combinations might not return sensical results.  Only
limited sanity checks are performed.
</p>


<h3>References</h3>

<p>Hodges, James S. (2014). Richly Parameterized Linear Models: Additive, Time
Series, and Spatial Models Using Random Effects. Chapman &amp; Hall/CRC Texts
in Statistical Science Series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sleepstudy", package = "lme4")
fit &lt;- BoxCoxME(Reaction ~ Days + (Days | Subject), data = sleepstudy, order = 5)
ranef(fit, raw = TRUE)
ranef(fit)

</code></pre>

<hr>
<h2 id='residuals.LmME'>Residuals of a LmME model</h2><span id='topic+residuals.LmME'></span>

<h3>Description</h3>

<p>Calculates the score residuals of an intercept term fixed at 0.
In the case of an LmME model, this is equal to the residual of an LMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LmME'
residuals(object, as.lm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.LmME_+3A_object">object</code></td>
<td>
<p>An <code>LmME</code> object.</p>
</td></tr>
<tr><td><code id="residuals.LmME_+3A_as.lm">as.lm</code></td>
<td>
<p>If <code>TRUE</code>, return the residuals as in a normal linear
mixed effects model.</p>
</td></tr>
<tr><td><code id="residuals.LmME_+3A_...">...</code></td>
<td>
<p>Optional arguments (for consistency with generic)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
resid(fit)
</code></pre>

<hr>
<h2 id='residuals.tramME'>Residuals of a tramME model</h2><span id='topic+residuals.tramME'></span>

<h3>Description</h3>

<p>Calculates the score residuals of an intercept term fixed at 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
residuals(
  object,
  param = NULL,
  newdata = NULL,
  fix_smooth = !is.null(newdata),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="residuals.tramME_+3A_param">param</code></td>
<td>
<p>An optional named list of parameter values (beta and theta).
See details.  Optionally, gamma elements can also be added, which leads to
'fixing' those random effects terms at the supplied values.</p>
</td></tr>
<tr><td><code id="residuals.tramME_+3A_newdata">newdata</code></td>
<td>
<p>An optional <code>data.frame</code> of observations for which we
want to calculate the residuals.</p>
</td></tr>
<tr><td><code id="residuals.tramME_+3A_fix_smooth">fix_smooth</code></td>
<td>
<p>Logical; it is set to <code>TRUE</code> by default, if
<code>newdata</code> is supplied.  The random effects parameters corresponding
the smooth terms are fixed and not fitted (posterior mode) to
<code>newdata</code> instead they are treated just like fixed effects
parameters. See details.</p>
</td></tr>
<tr><td><code id="residuals.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments (for consistency with generic)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library("survival")
fit &lt;- SurvregME(Surv(time, status) ~ rx + (1 | litter), data = rats)
resid(fit)

</code></pre>

<hr>
<h2 id='Resp'>Response objects</h2><span id='topic+Resp'></span><span id='topic+R.Resp'></span><span id='topic+print.Resp'></span><span id='topic++5B.Resp'></span><span id='topic+is.na.Resp'></span><span id='topic+length.Resp'></span><span id='topic+format.Resp'></span>

<h3>Description</h3>

<p>Response objects to represent censored and truncated observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Resp(
  cleft,
  cright,
  tleft,
  tright,
  bounds = c(-Inf, Inf),
  open_lwr_bnd = TRUE,
  tol = sqrt(.Machine$double.eps)
)

## S3 method for class 'Resp'
R(object, ...)

## S3 method for class 'Resp'
print(x, ...)

## S3 method for class 'Resp'
x[i, j, drop = FALSE]

## S3 method for class 'Resp'
is.na(x)

## S3 method for class 'Resp'
length(x)

## S3 method for class 'Resp'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Resp_+3A_cleft">cleft</code></td>
<td>
<p>A vector of left borders of censoring intervals</p>
</td></tr>
<tr><td><code id="Resp_+3A_cright">cright</code></td>
<td>
<p>A vector of right borders of censoring intervals</p>
</td></tr>
<tr><td><code id="Resp_+3A_tleft">tleft</code></td>
<td>
<p>A vector of left truncation values</p>
</td></tr>
<tr><td><code id="Resp_+3A_tright">tright</code></td>
<td>
<p>A vector of right truncation values</p>
</td></tr>
<tr><td><code id="Resp_+3A_bounds">bounds</code></td>
<td>
<p>An optional numeric vector of two elements (<code>c(a, b)</code>)
that denotes the lower and upper boundaries of the outcome.</p>
</td></tr>
<tr><td><code id="Resp_+3A_open_lwr_bnd">open_lwr_bnd</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the lower boundary of the
outcome is open, and we want to enforce this.</p>
</td></tr>
<tr><td><code id="Resp_+3A_tol">tol</code></td>
<td>
<p>Tolerance level.</p>
</td></tr>
<tr><td><code id="Resp_+3A_object">object</code></td>
<td>
<p>A <code>Resp</code> object</p>
</td></tr>
<tr><td><code id="Resp_+3A_...">...</code></td>
<td>
<p>Optional arguments</p>
</td></tr>
<tr><td><code id="Resp_+3A_x">x</code></td>
<td>
<p>A <code>Resp</code> object</p>
</td></tr>
<tr><td><code id="Resp_+3A_i">i</code></td>
<td>
<p>Row index (typically the only index)</p>
</td></tr>
<tr><td><code id="Resp_+3A_j">j</code></td>
<td>
<p>Column index (typically missing)</p>
</td></tr>
<tr><td><code id="Resp_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> the result is coerced to the lowest possible dimension</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Resp</code> extends the functionality of <code><a href="survival.html#topic+Surv">Surv</a></code> class
by allowing cases that cannot be defined with it. An example is an
interval-censored outcome with left truncatation (see Examples).
</p>
<p>Censored and exactly observed data can be defined similarly to <code>type =
  "interval2"</code> objects in <code><a href="survival.html#topic+Surv">Surv</a></code>. <code>NA</code> values for
left or right censoring borders mean left- or right-censored observations,
respectively. If both borders are <code>NA</code>, the observation is considered
<code>NA</code> by <code>is.na()</code>.  Truncation times (<code>tleft</code> and
<code>tright</code> arguments) can be omitted or take <code>NA</code> values, which
means no truncation. If only the censoring intervals are provided, i.e.,
no trunction is present, the function returns a <code>Surv</code> object.
</p>
<p><code>Resp</code> also provides a limited interface between <code>tramME</code> and the
<code>response</code> class (technically, inherits from it) of <code>mlt</code> (see
<code><a href="mlt.html#topic+R">R</a></code>), which uses an internal representation that is not
compatible with <code>tramME</code>.
</p>
<p>The optional argument <code>open_lwr_bnd</code> can be used to enforce lower
boundaries of the outcome. Left boundaries in the <code>Resp</code> object
(<code>cleft</code> and <code>tleft</code>) that are equal to the first element of
<code>bounds</code> will be increased with one <code>tol</code> value to avoid
downstream numerical problems in <code>mlt</code>. This adjustment is recorded
and reversed when we print the object.
</p>


<h3>Value</h3>

<p>A <code>Resp</code> object or a <code>Surv</code> object
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>R(Resp)</code>: Converting <code>Resp</code> objects to <code>response</code> (from
<code>mlt</code>) objects (see <code><a href="mlt.html#topic+R">R</a></code>)
</p>
</li>
<li> <p><code>print(Resp)</code>: Print method for the <code>Resp</code> class
</p>
</li>
<li> <p><code>[</code>: Subsetting <code>Resp</code> objects
</p>
</li>
<li> <p><code>is.na(Resp)</code>: Missing values
</p>
</li>
<li> <p><code>length(Resp)</code>: Length of a <code>Resp</code> object
</p>
</li>
<li> <p><code>format(Resp)</code>: <code>format</code> method for a <code>Resp</code> object
</p>
</li></ul>


<h3>Warning</h3>

<p>This function is experimental and currently limited to continuous outcome
types. It may be subject to change.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(x1 = 1:10, x2 = c(2:10, NA), x3 = c(NA, 0:8))
dat$r &lt;- with(dat, Resp(x1, x2, x3))

dat$r
dat[1:3, ]$r
dat$r[1:3]

is.na(dat$r)

model.frame(r ~ 1, data = dat, na.action = na.omit)

</code></pre>

<hr>
<h2 id='sigma.LmME'>Extract the SD of the error term of an LmME model.</h2><span id='topic+sigma.LmME'></span>

<h3>Description</h3>

<p>Extract the SD of the error term of an LmME model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LmME'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.LmME_+3A_object">object</code></td>
<td>
<p>An <code>LmME</code> object.</p>
</td></tr>
<tr><td><code id="sigma.LmME_+3A_...">...</code></td>
<td>
<p>Optional argument (for consistency with generic).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of the transformed sigma parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
sigma(fit)
</code></pre>

<hr>
<h2 id='simulate.tramME'>Simulate from a <code>tramME</code> model</h2><span id='topic+simulate.tramME'></span>

<h3>Description</h3>

<p>Simulate from a <code>tramME</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  newdata = model.frame(object),
  type = c("ranef", "response", "joint"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="simulate.tramME_+3A_nsim">nsim</code></td>
<td>
<p>number of samples to generate</p>
</td></tr>
<tr><td><code id="simulate.tramME_+3A_seed">seed</code></td>
<td>
<p>optional seed for the random number generator</p>
</td></tr>
<tr><td><code id="simulate.tramME_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame of observations</p>
</td></tr>
<tr><td><code id="simulate.tramME_+3A_type">type</code></td>
<td>
<p>Defaults to <code>"ranef"</code>. Currently the only avalable option.</p>
</td></tr>
<tr><td><code id="simulate.tramME_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code><a href="mlt.html#topic+simulate.mlt">simulate.mlt</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length <code>nsim</code> list of draws.
</p>


<h3>Warning</h3>

<p>This method is under active development and may be subject to change. It is
currently limited to simulating random effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- BoxCoxME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
sim &lt;- simulate(fit, nsim = 10, seed = 123)
</code></pre>

<hr>
<h2 id='smooth_terms.LmME'>Evaluate smooth terms of a <code>LmME</code> model.</h2><span id='topic+smooth_terms.LmME'></span>

<h3>Description</h3>

<p>Evaluate smooth terms of a <code>LmME</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LmME'
smooth_terms(object, as.lm = FALSE, k = 100, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_terms.LmME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="smooth_terms.LmME_+3A_as.lm">as.lm</code></td>
<td>
<p>Logical; if <code>TRUE</code> return the rescaled values according to a LMM
parametrization.</p>
</td></tr>
<tr><td><code id="smooth_terms.LmME_+3A_k">k</code></td>
<td>
<p>Integer, the number of points to be used to evaluate the smooth terms.
Ignored when <code>newdata</code> is supplied.</p>
</td></tr>
<tr><td><code id="smooth_terms.LmME_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> with new values for the smooth terms.
If <code>NULL</code>, the new data is set up based on the <code>model.frame</code> and
<code>k</code>. Smooths for which the supplied information in this input is incomplete
will be ignored.</p>
</td></tr>
<tr><td><code id="smooth_terms.LmME_+3A_...">...</code></td>
<td>
<p>Optional arguments. <code>as.lm</code> is passed through this when it is necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results from evaluating the smooth terms of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mcycle", package = "MASS")
fit &lt;- LmME(accel ~ s(times), data = mcycle)
plot(smooth_terms(fit, as.lm = TRUE))
</code></pre>

<hr>
<h2 id='smooth_terms.tramME'>Extract and evaluate the smooth terms of a tramME model</h2><span id='topic+smooth_terms.tramME'></span><span id='topic+smooth_terms'></span>

<h3>Description</h3>

<p>Extract and evaluate the smooth terms of a tramME model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
smooth_terms(object, k = 100, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_terms.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="smooth_terms.tramME_+3A_k">k</code></td>
<td>
<p>Integer, the number of points to be used to evaluate the smooth terms.
Ignored when <code>newdata</code> is supplied.</p>
</td></tr>
<tr><td><code id="smooth_terms.tramME_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> with new values for the smooth terms.
If <code>NULL</code>, the new data is set up based on the <code>model.frame</code> and
<code>k</code>. Smooths for which the supplied information in this input is incomplete
will be ignored.</p>
</td></tr>
<tr><td><code id="smooth_terms.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments. <code>as.lm</code> is passed through this when it is necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results from evaluating the smooth terms of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mcycle", package = "MASS")
fit &lt;- LmME(accel ~ s(times), data = mcycle)
plot(smooth_terms(fit))
</code></pre>

<hr>
<h2 id='summary.tramME'>Summary method for tramME model</h2><span id='topic+summary.tramME'></span>

<h3>Description</h3>

<p>Summary method for tramME model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object</p>
</td></tr>
<tr><td><code id="summary.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments (for consistency with the generic)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary.tramME object.
</p>

<hr>
<h2 id='SurvregME'>Mixed-effects Additive Parametric Survival Models</h2><span id='topic+SurvregME'></span>

<h3>Description</h3>

<p>Estimates various mixed-effects additive parametric models (not exclusively)
for survival analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurvregME(
  formula,
  data,
  subset,
  weights,
  offset,
  na.action = na.omit,
  dist = c("weibull", "logistic", "gaussian", "exponential", "rayleigh", "loggaussian",
    "lognormal", "loglogistic"),
  scale = 0,
  silent = TRUE,
  resid = FALSE,
  do_update = FALSE,
  estinit = TRUE,
  initpar = NULL,
  fixed = NULL,
  nofit = FALSE,
  control = optim_control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SurvregME_+3A_formula">formula</code></td>
<td>
<p>A formula describing the model. Smooth additive terms are
defined the way as in <code>mgcv</code>, and random effects consistently with
the notation used in <code>lme4</code>.</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>.
</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_weights">weights</code></td>
<td>
<p>an optional vector of case weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector. If present,
the weighted log-likelihood is maximised.
</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an _a priori_ known component to
be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the
number of cases.
</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set to <code>na.omit</code>.
</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_dist">dist</code></td>
<td>
<p>character defining the conditional distribution of the
(not necessarily positive) response, current choices include 
Weibull, logistic, normal, exponential, Rayleigh, log-normal (same as
log-gaussian), or log-logistic.
</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_scale">scale</code></td>
<td>
<p>a fixed value for the scale parameter(s).
</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_silent">silent</code></td>
<td>
<p>Logical. Make <span class="pkg">TMB</span> functionality silent.</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_resid">resid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the score residuals are also calculated.
This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_do_update">do_update</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model is set up so that the weights and the
offsets are updateable. This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_estinit">estinit</code></td>
<td>
<p>Logical. Estimate a vector of initial values for the fixed effects parameters
from a (fixed effects only) mlt model</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_initpar">initpar</code></td>
<td>
<p>Named list of initial parameter values, if <code>NULL</code>, it is ignored</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_fixed">fixed</code></td>
<td>
<p>a named vector of fixed regression coefficients; the names
need to correspond to column names of the design matrix</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_nofit">nofit</code></td>
<td>
<p>logical, if TRUE, creates the model object, but does not run the optimization</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_control">control</code></td>
<td>
<p>list with controls for optimization</p>
</td></tr>
<tr><td><code id="SurvregME_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="tram.html#topic+tram">tram</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameterization is slightly different from
<code><a href="survival.html#topic+survreg">survival::survreg</a></code>, see Hothorn et al.
(2018).  The results can be transformed back to the <code>survreg</code>
parameterization with specific methods provided by <code>tramME</code>.
</p>
<p>The model extends <code><a href="tram.html#topic+Survreg">tram::Survreg</a></code> with random
effects and (optionally penalized) additive terms. For details on
mixed-effect transformation models, see Tamasi and Hothorn (2021).
</p>
<p>The elements of the linear predictor are parameterized with negative
parameters (i.e. <code>negative = TRUE</code> in <code><a href="tram.html#topic+tram">tram</a></code>).
</p>


<h3>Value</h3>

<p>A <code>SurvregME</code> model object.
</p>


<h3>References</h3>

<p>Hothorn, Torsten, Lisa Möst, and Peter Bühlmann. &quot;Most Likely
Transformations.&quot;  Scandinavian Journal of Statistics 45, no. 1 (March
2018): 110–34.  &lt;doi:10.1111/sjos.12291&gt;
</p>
<p>Tamasi, Balint, and Torsten Hothorn. &quot;tramME: Mixed-Effects Transformation
Models Using Template Model Builder.&quot; The R Journal 13, no. 2 (2021):
398–418. &lt;doi:10.32614/RJ-2021-075&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("survival")
rats$litter &lt;- factor(rats$litter)
m &lt;- SurvregME(Surv(time, status) ~ rx + (1 | litter), data = rats,
               dist = "weibull")
summary(m)
coef(m, as.survreg = TRUE)
</code></pre>

<hr>
<h2 id='tramME'>Mixed-effects Additive transformation models</h2><span id='topic+tramME'></span>

<h3>Description</h3>

<p>A general function to define and fit <code>tramME</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tramME(
  formula,
  data,
  subset,
  weights,
  offset,
  na.action,
  tram = NULL,
  call = NULL,
  ctm = NULL,
  smooth = NULL,
  negative = NULL,
  silent = TRUE,
  resid = FALSE,
  do_update = FALSE,
  estinit = TRUE,
  initpar = NULL,
  fixed = NULL,
  nofit = FALSE,
  control = optim_control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tramME_+3A_formula">formula</code></td>
<td>
<p>A formula describing the model. Smooth additive terms are
defined the way as in <code>mgcv</code>, and random effects consistently with
the notation used in <code>lme4</code>.</p>
</td></tr>
<tr><td><code id="tramME_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>.
</p>
</td></tr>
<tr><td><code id="tramME_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td></tr>
<tr><td><code id="tramME_+3A_weights">weights</code></td>
<td>
<p>an optional vector of case weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector. If present,
the weighted log-likelihood is maximised.
</p>
</td></tr>
<tr><td><code id="tramME_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an _a priori_ known component to
be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the
number of cases.
</p>
</td></tr>
<tr><td><code id="tramME_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set to <code>na.omit</code>.
</p>
</td></tr>
<tr><td><code id="tramME_+3A_tram">tram</code></td>
<td>
<p>Parameter vector for the <code>tram</code> model type.</p>
</td></tr>
<tr><td><code id="tramME_+3A_call">call</code></td>
<td>
<p>The original function call (to be passed from the wrapper).</p>
</td></tr>
<tr><td><code id="tramME_+3A_ctm">ctm</code></td>
<td>
<p>A model object of the <code>ctm</code> class that descibes the
fixed-effects part of the <code>tramME</code> model.</p>
</td></tr>
<tr><td><code id="tramME_+3A_smooth">smooth</code></td>
<td>
<p>A <code>tramME_smooth</code> object that describes the smooth
additive elements of the <code>tramME</code> model.</p>
</td></tr>
<tr><td><code id="tramME_+3A_negative">negative</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the model is parameterized with
negative coefficinets for the elements of the linear predictor.</p>
</td></tr>
<tr><td><code id="tramME_+3A_silent">silent</code></td>
<td>
<p>Logical. Make <span class="pkg">TMB</span> functionality silent.</p>
</td></tr>
<tr><td><code id="tramME_+3A_resid">resid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the score residuals are also calculated.
This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="tramME_+3A_do_update">do_update</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model is set up so that the weights and the
offsets are updateable. This comes with some performance cost.</p>
</td></tr>
<tr><td><code id="tramME_+3A_estinit">estinit</code></td>
<td>
<p>Logical. Estimate a vector of initial values for the fixed effects parameters
from a (fixed effects only) mlt model</p>
</td></tr>
<tr><td><code id="tramME_+3A_initpar">initpar</code></td>
<td>
<p>Named list of initial parameter values, if <code>NULL</code>, it is ignored</p>
</td></tr>
<tr><td><code id="tramME_+3A_fixed">fixed</code></td>
<td>
<p>a named vector of fixed regression coefficients; the names
need to correspond to column names of the design matrix</p>
</td></tr>
<tr><td><code id="tramME_+3A_nofit">nofit</code></td>
<td>
<p>logical, if TRUE, creates the model object, but does not run the optimization</p>
</td></tr>
<tr><td><code id="tramME_+3A_control">control</code></td>
<td>
<p>list with controls for optimization</p>
</td></tr>
<tr><td><code id="tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="tram.html#topic+tram">tram</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specific model functions (<code><a href="#topic+LmME">LmME</a></code>,
<code><a href="#topic+BoxCoxME">BoxCoxME</a></code>, <code><a href="#topic+ColrME">ColrME</a></code>, etc.) are
wrappers around this function.
</p>
<p>For a general description of the transformation model family, see Hothorn et
al. (2018), for details on the mixed-effects extension, see Tamasi and
Hothorn (2021).
</p>


<h3>Warning</h3>

<p>Typically, the <code>tramME</code> function shouldn't be called directly; it is
only exported to allow the advanced users to define their <code>tramME</code>
models in a more flexible way from their basic building blocks.
</p>


<h3>References</h3>

<p>Hothorn, Torsten, Lisa Möst, and Peter Bühlmann. &quot;Most Likely
Transformations.&quot;  Scandinavian Journal of Statistics 45, no. 1 (March
2018): 110–34.  &lt;doi:10.1111/sjos.12291&gt;
</p>
<p>Tamasi, Balint, and Torsten Hothorn. &quot;tramME: Mixed-Effects Transformation
Models Using Template Model Builder.&quot; The R Journal 13, no. 2 (2021):
398–418. &lt;doi:10.32614/RJ-2021-075&gt;
</p>

<hr>
<h2 id='tramTMB'>Create a tramTMB object</h2><span id='topic+tramTMB'></span>

<h3>Description</h3>

<p>Create a tramTMB object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tramTMB(
  data,
  parameters,
  constraint,
  negative,
  map = list(),
  resid = FALSE,
  do_update = FALSE,
  check_const = TRUE,
  no_int = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tramTMB_+3A_data">data</code></td>
<td>
<p>List of data objects (vectors, matrices, arrays, factors, sparse matrices) required by the user template (order does not matter and un-used components are allowed).</p>
</td></tr>
<tr><td><code id="tramTMB_+3A_parameters">parameters</code></td>
<td>
<p>List of all parameter objects required by the user template (both random and fixed effects).</p>
</td></tr>
<tr><td><code id="tramTMB_+3A_constraint">constraint</code></td>
<td>
<p>list describing the constarints on the parameters</p>
</td></tr>
<tr><td><code id="tramTMB_+3A_negative">negative</code></td>
<td>
<p>logical, whether the model is parameterized with negative values</p>
</td></tr>
<tr><td><code id="tramTMB_+3A_map">map</code></td>
<td>
<p>same as map argument of <code>TMB::MakeADFun</code></p>
</td></tr>
<tr><td><code id="tramTMB_+3A_resid">resid</code></td>
<td>
<p>logical, indicating whether the score residuals are calculated
from the resulting object</p>
</td></tr>
<tr><td><code id="tramTMB_+3A_do_update">do_update</code></td>
<td>
<p>logical, indicating whether the model should be set up with
updateable offsets and weights</p>
</td></tr>
<tr><td><code id="tramTMB_+3A_check_const">check_const</code></td>
<td>
<p>Logical; if <code>TRUE</code> check the parameter constraints before
evaluating the returned functions.</p>
</td></tr>
<tr><td><code id="tramTMB_+3A_no_int">no_int</code></td>
<td>
<p>Logical; if <code>FALSE</code> skip the numerical integration step.</p>
</td></tr>
<tr><td><code id="tramTMB_+3A_...">...</code></td>
<td>
<p>optional parameters passed to <code>TMB::MakeADFun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tramTMB object.
</p>


<h3>Note</h3>

<p>The post-estimation parameters are supplied as a part of <code>data</code>
</p>

<hr>
<h2 id='VarCorr.LmME'>Variances and correlation matrices of random effects of an LmME object</h2><span id='topic+VarCorr.LmME'></span>

<h3>Description</h3>

<p>The returned parameters are the transformed versions of the original parameters that
correspond to the normal linear mixed model parameterization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LmME'
VarCorr(x, sigma = 1, as.lm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarCorr.LmME_+3A_x">x</code></td>
<td>
<p>An <code>LmME</code> object.</p>
</td></tr>
<tr><td><code id="VarCorr.LmME_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the error term in the LMM parameterization (should
not be set manually, only for consistency with the generic method)</p>
</td></tr>
<tr><td><code id="VarCorr.LmME_+3A_as.lm">as.lm</code></td>
<td>
<p>If <code>TRUE</code>, return the variances and correlations that correspond to
a normal linear mixed model (i.e. <code>lmerMod</code>).</p>
</td></tr>
<tr><td><code id="VarCorr.LmME_+3A_...">...</code></td>
<td>
<p>Optional arguments (for consistency with generic)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function only returns the correlation matrices that belong to actual random effects
(defined for groups in the data) and ignores the random effects parameters of the smooth
shift terms. To extract these, the user should use <code>varcov</code> with <code>full = TRUE</code>.
</p>


<h3>Value</h3>

<p>A list of vectors with variances and correlation matrices corresponding to the
various grouping variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
VarCorr(fit) ## tranformation model parameterization
VarCorr(fit, as.lm = TRUE) ## LMM parameterization
</code></pre>

<hr>
<h2 id='VarCorr.tramME'>Variances and correlation matrices of random effects</h2><span id='topic+VarCorr.tramME'></span><span id='topic+VarCorr'></span>

<h3>Description</h3>

<p>This function calculates the variances and correlations from
<code>varcov.tramME</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
VarCorr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarCorr.tramME_+3A_x">x</code></td>
<td>
<p>A <code>tramME</code> object</p>
</td></tr>
<tr><td><code id="VarCorr.tramME_+3A_...">...</code></td>
<td>
<p>optional arguments (for consistency with the generic method)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function only returns the correlation matrices that belong to actual
random effects (defined for groups in the data) and ignores the random
effects parameters of the smooth shift terms. To extract these, the user
should use <code>varcov</code> with <code>full = TRUE</code>.
</p>
<p>Note that, by default, <code><a href="#topic+print.VarCorr.tramME">print.VarCorr.tramME</a></code> prints the
standard deviations of the random effects, similarly to <code>lme4</code>.
</p>


<h3>Value</h3>

<p>A list of vectors with variances and correlation matrices corresponding to the
various grouping variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- BoxCoxME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
VarCorr(fit)
</code></pre>

<hr>
<h2 id='varcov'>Generic method for <code>varcov</code></h2><span id='topic+varcov'></span>

<h3>Description</h3>

<p>Generic method for <code>varcov</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcov_+3A_object">object</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="varcov_+3A_...">...</code></td>
<td>
<p>Optional inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance-covariance matrix.
</p>

<hr>
<h2 id='varcov.LmME'>Extract the variance-covariance matrix of the random effects of an LmME model</h2><span id='topic+varcov.LmME'></span>

<h3>Description</h3>

<p>Extract the variance-covariance matrix of the random effects of an LmME model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LmME'
varcov(object, as.lm = FALSE, as.theta = FALSE, full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcov.LmME_+3A_object">object</code></td>
<td>
<p>A <code>LmME</code> object.</p>
</td></tr>
<tr><td><code id="varcov.LmME_+3A_as.lm">as.lm</code></td>
<td>
<p>If <code>TRUE</code>, the returned values correspond to the LMM
parameterization.</p>
</td></tr>
<tr><td><code id="varcov.LmME_+3A_as.theta">as.theta</code></td>
<td>
<p>Logical value, if <code>TRUE</code>, the values are returned
in their reparameterized form.</p>
</td></tr>
<tr><td><code id="varcov.LmME_+3A_full">full</code></td>
<td>
<p>Logical value; if <code>TRUE</code>, return all random effects elements,
if <code>FALSE</code>, do not return the random effects parameters of the smooth
terms.</p>
</td></tr>
<tr><td><code id="varcov.LmME_+3A_...">...</code></td>
<td>
<p>Optional arguments (unused).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the covariance matrices or a vector of theta values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
varcov(fit, as.lm = TRUE)
varcov(fit, as.theta = TRUE, as.lm = TRUE)
</code></pre>

<hr>
<h2 id='varcov.tramME'>Extract the variance-covariance matrix of the random effects</h2><span id='topic+varcov.tramME'></span>

<h3>Description</h3>

<p>Returns the covariance matrix of the random effects as saved in the <code>tramME</code>
object.
The returned values correspond to the transformation model parametrization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
varcov(object, as.theta = FALSE, full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcov.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="varcov.tramME_+3A_as.theta">as.theta</code></td>
<td>
<p>Logical value, if <code>TRUE</code>, the values are returned
in their reparameterized form.</p>
</td></tr>
<tr><td><code id="varcov.tramME_+3A_full">full</code></td>
<td>
<p>Logical value; if <code>TRUE</code>, return all random effects elements,
if <code>FALSE</code>, do not return the random effects parameters of the smooth
terms.</p>
</td></tr>
<tr><td><code id="varcov.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments (unused).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the covariance matrices or a vector of theta values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
varcov(fit)
varcov(fit, as.theta = TRUE)
</code></pre>

<hr>
<h2 id='varcov+26lt+3B-'>Generic method for <code>"varcov&lt;-"</code></h2><span id='topic+varcov+3C-'></span>

<h3>Description</h3>

<p>Generic method for <code>"varcov&lt;-"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcov(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcov+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="varcov+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>Optional inputs.</p>
</td></tr>
<tr><td><code id="varcov+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>The new value of the covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with the same class as <code>object</code>, with updated
variance-covariance matrix of random effects.
</p>

<hr>
<h2 id='varcov+26lt+3B-.tramME'>Set the values of the random effects covariance matrices of a tramME model.</h2><span id='topic+varcov+3C-.tramME'></span>

<h3>Description</h3>

<p>Sets the list containing the covariance matrices of a tramME model. The matrices have
to be positive definite. Just as in <code>"coef&lt;-"</code>, when the function is called
on a fitted object, the function will remove the infromation about the optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'tramME'
varcov(object, as.theta = FALSE, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcov+2B26lt+2B3B-.tramME_+3A_object">object</code></td>
<td>
<p>A <code>tramME</code> object.</p>
</td></tr>
<tr><td><code id="varcov+2B26lt+2B3B-.tramME_+3A_as.theta">as.theta</code></td>
<td>
<p>Logical value, if <code>TRUE</code>, indicating that the new values are supplied
in their reparameterized form.</p>
</td></tr>
<tr><td><code id="varcov+2B26lt+2B3B-.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments (ignored).</p>
</td></tr>
<tr><td><code id="varcov+2B26lt+2B3B-.tramME_+3A_value">value</code></td>
<td>
<p>A list of positive definite covariance matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The supplied list has to be named with the same names as implied by the model.
Hence, it might be a good idea to call <code>varcov</code> first, and
modify this list to make sure that the input has the right structure.
</p>
<p>The new values can also be supplied in a form that corresponds to the reparametrization
used by the <code>tramTMB</code> model (see the option <code>as.theta = TRUE</code>).
</p>
<p>All random effects variance parameters must be supplied. When there are penalized smooth
terms in the model variance parameters corresponding to these should also be part of the
input list.
</p>


<h3>Value</h3>

<p>A new <code>tramME</code> object with the new coefficient values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
mod &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy, nofit = TRUE)
vc &lt;- varcov(mod)
vc[[1]] &lt;- matrix(c(1, 0, 0, 2), ncol = 2)
varcov(mod) &lt;- vc
</code></pre>

<hr>
<h2 id='variable.names.tramME'>Return variable names.</h2><span id='topic+variable.names.tramME'></span>

<h3>Description</h3>

<p>Returns the variable names corresponding to different variable groups in a tramME
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
variable.names(
  object,
  which = c("all", "response", "grouping", "shifting", "interacting", "smooth", "ranef"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable.names.tramME_+3A_object">object</code></td>
<td>
<p>a tramME object (fitted or unfitted)</p>
</td></tr>
<tr><td><code id="variable.names.tramME_+3A_which">which</code></td>
<td>

<ol>
<li><p> all: all variables,
</p>
</li>
<li><p> response: response variable,
</p>
</li>
<li><p> grouping: grouping factors for random effects,
</p>
</li>
<li><p> shifting: shifting variables,
</p>
</li>
<li><p> interacting: interacting variables,
</p>
</li>
<li><p> smooth: variables in smooth terms,
</p>
</li>
<li><p> ranef: all random effects variables (covariates with random slopes and grouping
factors).
</p>
</li></ol>
</td></tr>
<tr><td><code id="variable.names.tramME_+3A_...">...</code></td>
<td>
<p>optional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned names are the names as they are used by tramME. For example,
when the response is a <code>Surv</code> object, <code>variable.names</code> returns
the name of that object, and not the names of the variables used to create it.
</p>


<h3>Value</h3>

<p>A vector of variable names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
mod &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy, nofit = TRUE)
variable.names(mod)
variable.names(mod, "response")
</code></pre>

<hr>
<h2 id='vcov.LmME'>Get the variance-covariance matrix of the parameters of an LmME model</h2><span id='topic+vcov.LmME'></span>

<h3>Description</h3>

<p>Get the variance-covariance matrix of the parameters of an LmME model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LmME'
vcov(
  object,
  as.lm = FALSE,
  parm = NULL,
  pargroup = c("all", "fixef", "ranef"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.LmME_+3A_object">object</code></td>
<td>
<p>A fitted <code>LmME</code> object.</p>
</td></tr>
<tr><td><code id="vcov.LmME_+3A_as.lm">as.lm</code></td>
<td>
<p>If <code>TRUE</code>, return the covariance matrix of the same
parameterization as used by <code><a href="lme4.html#topic+lmer">lmer</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.LmME_+3A_parm">parm</code></td>
<td>
<p>Names of the parameters to extract.</p>
</td></tr>
<tr><td><code id="vcov.LmME_+3A_pargroup">pargroup</code></td>
<td>
<p>The name of the parameter group to extract. With <code>as.lm = FALSE</code>,
the available options are described in <code>confint.tramME</code>. When <code>as.lm = TRUE</code>,
the following options are available:
</p>

<ul>
<li><p> all: Fixed effects and variance components parameters.
</p>
</li>
<li><p> fixef: Fixed effects parameters (including FE parameters of the smooth terms).
</p>
</li>
<li><p> ranef: Variance components parameters (including the smoothing parameters of
the random effects).
</p>
</li></ul>
</td></tr>
<tr><td><code id="vcov.LmME_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code>confint.tramME</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- LmME(Reaction ~ Days + (Days | Subject), data = sleepstudy)
vcov(fit) ## transformation model parameterization
vcov(fit, as.lm = TRUE) ## LMM parameterization
vcov(fit, as.lm = TRUE, pargroup = "fixef") ## cov of fixed effects
</code></pre>

<hr>
<h2 id='vcov.tramME'>Calculate the variance-covariance matrix of the parameters</h2><span id='topic+vcov.tramME'></span>

<h3>Description</h3>

<p>Extracts the covariance matrix of the selected parameters. The returned values
are on the same scale as the estimated parameter values, i.e. the standard
deviations of the random effect terms are on log scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tramME'
vcov(
  object,
  parm = NULL,
  pargroup = c("all", "fixef", "shift", "baseline", "ranef", "smooth"),
  pmatch = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.tramME_+3A_object">object</code></td>
<td>
<p>A fitted tramME object.</p>
</td></tr>
<tr><td><code id="vcov.tramME_+3A_parm">parm</code></td>
<td>
<p>The names of the parameters of interest. See in details.</p>
</td></tr>
<tr><td><code id="vcov.tramME_+3A_pargroup">pargroup</code></td>
<td>
<p>The name of the parameter group to return:
</p>

<ul>
<li><p> all: All parameters.
</p>
</li>
<li><p> fixef: Fixed effects parameters.
</p>
</li>
<li><p> shift: Shift parameters.
</p>
</li>
<li><p> baseline: Parameters of the baseline transformation function.
</p>
</li>
<li><p> ranef: Variance components parameters.
</p>
</li>
<li><p> smooth: Paramaters that belong to the smooth shift terms
(both FE and smoothing parameters).
</p>
</li></ul>
</td></tr>
<tr><td><code id="vcov.tramME_+3A_pmatch">pmatch</code></td>
<td>
<p>Logical. If <code>TRUE</code>, partial name matching is allowed.</p>
</td></tr>
<tr><td><code id="vcov.tramME_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code>vcov.tramTMB</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Access to variances and covariances of penalized parameters is currently
provided by the <code>parm</code> argument. Parameter names must be consistent
with names in <code>object$param</code>.
</p>


<h3>Value</h3>

<p>A numeric covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sleepstudy", package = "lme4")
fit &lt;- BoxCoxME(Reaction ~ Days + (Days | Subject), data = sleepstudy, order = 10)
vcov(fit)
vcov(fit, pargroup = "ranef")
vcov(fit, pargroup = "baseline")
vcov(fit, parm = "Reaction") ## same as previous
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
