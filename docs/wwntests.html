<!DOCTYPE html><html><head><title>Help for package wwntests</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wwntests}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autocorrelation_coeff_h'><p>'autocorrelation_coeff_h' Computes the approximate functional autocorrelation coefficient at a given lag.</p></a></li>
<li><a href='#autocorrelation_coeff_plot'><p>Plot Confidence Bounds of Estimated Functional Autocorrelation Coefficients</p></a></li>
<li><a href='#autocov_approx_h'><p>Compute the approximate autocovariance at specified lag</p></a></li>
<li><a href='#B_h_bound'><p>Compute weak white noise confidence bound for autocorrelation coefficient.</p></a></li>
<li><a href='#B_iid_bound'><p>Compute strong white noise confidence bound for autocorrelation coefficient.</p></a></li>
<li><a href='#bartlett_kernel'><p>Bartlett Kernel Function</p></a></li>
<li><a href='#block_bootsrap'><p>'block_bootstrap' Performs a block bootstrap on the functional data f_data with block size b.</p></a></li>
<li><a href='#brown_motion'><p>'brown_motion' Creates at J x N matrix, containing N independent Brownian motion sample paths in</p>
each of the columns.</a></li>
<li><a href='#center'><p>Center functional data</p></a></li>
<li><a href='#covariance_diag_store'><p>List storage of diagonal covariances.</p></a></li>
<li><a href='#covariance_i_j'><p>Compute the approximate covariance tensor for lag windows defined by i,j</p></a></li>
<li><a href='#covariance_i_j_vec'><p>Compute the approximate covariance tensor for lag windows defined by i,j</p></a></li>
<li><a href='#daniell_kernel'><p>Daniell Kernel Function</p></a></li>
<li><a href='#diagonal_autocov_approx_0'><p>Compute the diagonal covariance</p></a></li>
<li><a href='#diagonal_covariance_i'><p>Compute the approximate diagonal covariance matrix for lag windows defined by i</p></a></li>
<li><a href='#far_1_S'><p>'far_1_S' Simulates an FAR(1,S)-fGARCH(1,1) process with N independent observations, each</p>
observed discretely at J points on the interval [0,1].</a></li>
<li><a href='#fgarch_1_1'><p>'fgarch_1_1' Simulates an fGARCH(1,1) process with N independent observations, each observed</p></a></li>
<li><a href='#fport_test'><p>Compute Functional Hypothesis Tests</p></a></li>
<li><a href='#GOF_far'><p>Goodness-of-fit test for FAR(1)</p></a></li>
<li><a href='#iid_covariance'><p>Compute part of the covariance under a strong white noise assumption</p></a></li>
<li><a href='#iid_covariance_vec'><p>Compute part of the covariance under a strong white noise assumption</p></a></li>
<li><a href='#independence_test'><p>Independence Test</p></a></li>
<li><a href='#multi_lag_test'><p>Multi-Lag Hypothesis Test</p></a></li>
<li><a href='#parzen_kernel'><p>Parzen Kernel Function</p></a></li>
<li><a href='#Q_WS_hyp_test'><p>Compute size alpha single-lag hypothesis test under weak or strong white noise assumption</p></a></li>
<li><a href='#scalar_covariance_i_j'><p>Compute the approximate covariance at a point for lag windows defined by i,j</p></a></li>
<li><a href='#scalar_covariance_i_j_vec'><p>Compute the approximate covariance at a point for lag windows defined by i,j</p></a></li>
<li><a href='#single_lag_test'><p>Single-Lag Hypothesis Test</p></a></li>
<li><a href='#spectral_test'><p>Spectral Density Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hypothesis Tests for Functional Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mihyun Kim &lt;mihyun.kim@mail.wvu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of white noise hypothesis tests for functional time series and related visualizations. 
  These include tests based on the norms of autocovariance operators that are built under both strong and weak 
  white noise assumptions. Additionally, tests based on the spectral density operator and on principal component
  dimensional reduction are included, which are built under strong white noise assumptions. 
  Also, this package provides goodness-of-fit tests for functional autoregressive of order 1 models.
  These methods are described in Kokoszka et al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2017.08.004">doi:10.1016/j.jmva.2017.08.004</a>&gt;, Characiejus and Rice (2019) 
  &lt;<a href="https://doi.org/10.1016%2Fj.ecosta.2019.01.003">doi:10.1016/j.ecosta.2019.01.003</a>&gt;, Gabrys and Kokoszka (2007) &lt;<a href="https://doi.org/10.1198%2F016214507000001111">doi:10.1198/016214507000001111</a>&gt;, 
  and Kim et al. (2023) &lt;<a href="https://doi.org/10.1214%2F23-SS143">doi:10.1214/23-SS143</a>&gt;
  respectively.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sde, stats, ftsa, rainbow, MASS, graphics, fda</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, CompQuadForm, tensorA</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/veritasmih/wwntests/issues">https://github.com/veritasmih/wwntests/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-01 04:18:27 UTC; miyhun</td>
</tr>
<tr>
<td>Author:</td>
<td>Mihyun Kim [aut, cre],
  Daniel Petoukhov [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-01 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='autocorrelation_coeff_h'>'autocorrelation_coeff_h' Computes the approximate functional autocorrelation coefficient at a given lag.</h2><span id='topic+autocorrelation_coeff_h'></span>

<h3>Description</h3>

<p>'autocorrelation_coeff_h' Computes the approximate functional autocorrelation coefficient at a given lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorrelation_coeff_h(f_data, lag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorrelation_coeff_h_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="autocorrelation_coeff_h_+3A_lag">lag</code></td>
<td>
<p>the lag to use to compute the single lag test statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value; the approximate functional autocorrelation coefficient at lag h.
</p>

<hr>
<h2 id='autocorrelation_coeff_plot'>Plot Confidence Bounds of Estimated Functional Autocorrelation Coefficients</h2><span id='topic+autocorrelation_coeff_plot'></span>

<h3>Description</h3>

<p>'autocorrelation_coeff_plot' Computes the 1-alpha upper confidence bounds for the functional
autocorrelation coefficients at lags h = 1:K under both weak white noise (WWN) and strong white
noise (SWN) assumptions. It plots the coefficients as well as the bounds for all lags h = 1:K.
Note, the SWN bound is constant, while the WWN is dependent on the lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorrelation_coeff_plot(
  f_data,
  K = 20,
  alpha = 0.05,
  M = NULL,
  wwn_bound = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorrelation_coeff_plot_+3A_f_data">f_data</code></td>
<td>
<p>The functional data matrix with observed functions in the columns.</p>
</td></tr>
<tr><td><code id="autocorrelation_coeff_plot_+3A_k">K</code></td>
<td>
<p>A positive Integer value. The maximum lag for which to compute the single-lag test (tests
will be computed for lags h in 1:K).</p>
</td></tr>
<tr><td><code id="autocorrelation_coeff_plot_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 specifying the significance level to be used in the single-lag
test. The default value is 0.05.</p>
</td></tr>
<tr><td><code id="autocorrelation_coeff_plot_+3A_m">M</code></td>
<td>
<p>A positive Integer value. Determines the number of Monte-Carlo simulations employed in the
Welch-Satterthwaite approximation of the limiting distribution of the test statistics, for each test.</p>
</td></tr>
<tr><td><code id="autocorrelation_coeff_plot_+3A_wwn_bound">wwn_bound</code></td>
<td>
<p>A Boolean value allowing the user to turn off the weak white noise bound. TRUE by default.
Speeds up computation when FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes and plots autocorrelation coefficients at lag h, for h in 1:K. It also
computes an estimated asymptotic 1 - alpha confidence bound, under the assumption that the series
forms a weak white noise. Additionally, it computes a similar (constant) bound under the assumption the
series form a strong white noise. Please see the vignette or the references for a more complete treatment.
</p>


<h3>Value</h3>

<p>Plot of the estimated autocorrelation coefficients for lags h in 1:K with the weak
white noise 1-alpha upper  confidence bound for each lag, as well as the constant strong white
noise 1-alpha confidence bound.
</p>


<h3>References</h3>

<p>[1] Kokoszka P., &amp; Rice G., &amp; Shang H.L. (2017). Inference for the autocovariance of a functional time series
under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brown_motion(75, 40)
autocorrelation_coeff_plot(b)
autocorrelation_coeff_plot(b, M = 200)

</code></pre>

<hr>
<h2 id='autocov_approx_h'>Compute the approximate autocovariance at specified lag</h2><span id='topic+autocov_approx_h'></span>

<h3>Description</h3>

<p>'autocov_approx_h' computes the approximate autocovariance for a given lag h of the functional
data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocov_approx_h(f_data, lag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocov_approx_h_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="autocov_approx_h_+3A_lag">lag</code></td>
<td>
<p>the lag to use to compute the single lag test statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-dimensional array encoding the autocovariance matrix for a given lag h.
</p>

<hr>
<h2 id='B_h_bound'>Compute weak white noise confidence bound for autocorrelation coefficient.</h2><span id='topic+B_h_bound'></span>

<h3>Description</h3>

<p>'B_h_bound' Computes an approximate asymptotic upper 1-alpha confidence bound for the functional
autocorrelation coefficient at lag h under a weak white noise assumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_h_bound(f_data, lag, alpha = 0.05, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_h_bound_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="B_h_bound_+3A_lag">lag</code></td>
<td>
<p>the lag to use to compute the single lag test statistic</p>
</td></tr>
<tr><td><code id="B_h_bound_+3A_alpha">alpha</code></td>
<td>
<p>the significance level to be used in the hypothesis test</p>
</td></tr>
<tr><td><code id="B_h_bound_+3A_m">M</code></td>
<td>
<p>Number of samples to take when applying a Monte-Carlo approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value; the 1-alpha confidence bound for the functional autocorrelation
coefficient at lag h under a weak white noise assumption.
</p>

<hr>
<h2 id='B_iid_bound'>Compute strong white noise confidence bound for autocorrelation coefficient.</h2><span id='topic+B_iid_bound'></span>

<h3>Description</h3>

<p>'B_iid_bound' Computes an approximate asymptotic upper 1-alpha confidence bound for the functional
autocorrelation coefficient at lag h under the assumption that f_data forms a strong white noise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_iid_bound(f_data, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_iid_bound_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="B_iid_bound_+3A_alpha">alpha</code></td>
<td>
<p>the significance level to be used in the hypothesis test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value; the 1-alpha confidence bound for the functional autocorrelation coefficient
at lag h under a strong white noise assumption.
</p>

<hr>
<h2 id='bartlett_kernel'>Bartlett Kernel Function</h2><span id='topic+bartlett_kernel'></span>

<h3>Description</h3>

<p>'bartlett_kernel' Computes the Bartlett kernel function at a given point value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bartlett_kernel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bartlett_kernel_+3A_x">x</code></td>
<td>
<p>the point value at which the kernel function is evaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value; the value of the Bartlett kernel function at the point value x.
</p>

<hr>
<h2 id='block_bootsrap'>'block_bootstrap' Performs a block bootstrap on the functional data f_data with block size b.</h2><span id='topic+block_bootsrap'></span>

<h3>Description</h3>

<p>'block_bootstrap' Performs a block bootstrap on the functional data f_data with block size b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_bootsrap(f_data, b, B = 300, moving = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_bootsrap_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="block_bootsrap_+3A_b">b</code></td>
<td>
<p>the block size (of each block in each bootstrap sample)</p>
</td></tr>
<tr><td><code id="block_bootsrap_+3A_b">B</code></td>
<td>
<p>the number of bootstraps samples</p>
</td></tr>
<tr><td><code id="block_bootsrap_+3A_moving">moving</code></td>
<td>
<p>boolean value specifying whether the block bootstrap should be moving or not. A moving black
bootstrap samples individual functional observations and adds on the consequent block, rather than sampling
blocks of the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of B elements, each element being a block bootstrap sample in the same format
as the original functional data f_data.
</p>

<hr>
<h2 id='brown_motion'>'brown_motion' Creates at J x N matrix, containing N independent Brownian motion sample paths in
each of the columns.</h2><span id='topic+brown_motion'></span>

<h3>Description</h3>

<p>'brown_motion' Creates at J x N matrix, containing N independent Brownian motion sample paths in
each of the columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brown_motion(N, J)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brown_motion_+3A_n">N</code></td>
<td>
<p>the number of independent Brownian motion sample paths to compute.</p>
</td></tr>
<tr><td><code id="brown_motion_+3A_j">J</code></td>
<td>
<p>the number of steps observed for each sample path (the resolution of the data).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A J x N matrix containing Brownian motion functional data in the columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brown_motion(250, 50)

</code></pre>

<hr>
<h2 id='center'>Center functional data</h2><span id='topic+center'></span>

<h3>Description</h3>

<p>'center' Centers the given functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center(f_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same form as f_data containing the centered functional data.
</p>

<hr>
<h2 id='covariance_diag_store'>List storage of diagonal covariances.</h2><span id='topic+covariance_diag_store'></span>

<h3>Description</h3>

<p>'covariance_diag_store' Creates a list storage of approximate diagonal covariances computed
by the function diagonal_covariance_i
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariance_diag_store(f_data, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariance_diag_store_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="covariance_diag_store_+3A_k">K</code></td>
<td>
<p>the range of lags 1:K to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing K 2-dimensional arrays containing the diagonal covariance matrices of the
functional data, for lags h in the range 1:K.
</p>

<hr>
<h2 id='covariance_i_j'>Compute the approximate covariance tensor for lag windows defined by i,j</h2><span id='topic+covariance_i_j'></span>

<h3>Description</h3>

<p>'covariance_i_j' computes the approximate covariance tensor of the functional data for lag
windows defined by i,j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariance_i_j(f_data, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariance_i_j_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="covariance_i_j_+3A_i">i</code>, <code id="covariance_i_j_+3A_j">j</code></td>
<td>
<p>the indices i,j in 1:T that we are computing the covariance for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 4-dimensional array, encoding the covariance tensor of the functional data for lag
windows defined by i,j.
</p>

<hr>
<h2 id='covariance_i_j_vec'>Compute the approximate covariance tensor for lag windows defined by i,j</h2><span id='topic+covariance_i_j_vec'></span>

<h3>Description</h3>

<p>'covariance_i_j_vec' computes the approximate covariance tensor of the functional data for lag
windows defined by i,j; a vectorized version of covariance_i_j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariance_i_j_vec(f_data, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariance_i_j_vec_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="covariance_i_j_vec_+3A_i">i</code>, <code id="covariance_i_j_vec_+3A_j">j</code></td>
<td>
<p>the indices i,j in 1:T that we are computing the covariance for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 4-dimensional array, encoding the covariance tensor of the functional data for lag
windows defined by i,j.
</p>

<hr>
<h2 id='daniell_kernel'>Daniell Kernel Function</h2><span id='topic+daniell_kernel'></span>

<h3>Description</h3>

<p>'daniell_kernel' Computes the Daniell kernel function at a given point value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daniell_kernel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daniell_kernel_+3A_x">x</code></td>
<td>
<p>the point value at which the kernel function is evaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value; the value of the Daniell kernel function at the point value x.
</p>

<hr>
<h2 id='diagonal_autocov_approx_0'>Compute the diagonal covariance</h2><span id='topic+diagonal_autocov_approx_0'></span>

<h3>Description</h3>

<p>'diagonal_autocov_approx_0' Computes the diagonal covariance of the given functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagonal_autocov_approx_0(f_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagonal_autocov_approx_0_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value; integral approximation of the diagonal covariance of the functional data.
</p>

<hr>
<h2 id='diagonal_covariance_i'>Compute the approximate diagonal covariance matrix for lag windows defined by i</h2><span id='topic+diagonal_covariance_i'></span>

<h3>Description</h3>

<p>'diagonal_covariance_i' computes the approximate diagonal covariance matrix of the functional
data for lag windows defined by i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagonal_covariance_i(f_data, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagonal_covariance_i_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="diagonal_covariance_i_+3A_i">i</code></td>
<td>
<p>the index in 1:T that we are computing the covariance for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-dimensional array, encoding the covariance matrix of the functional data for lag
windows defined by i.
</p>

<hr>
<h2 id='far_1_S'>'far_1_S' Simulates an FAR(1,S)-fGARCH(1,1) process with N independent observations, each
observed discretely at J points on the interval [0,1].</h2><span id='topic+far_1_S'></span>

<h3>Description</h3>

<p>'far_1_S' Simulates an FAR(1,S)-fGARCH(1,1) process with N independent observations, each
observed discretely at J points on the interval [0,1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>far_1_S(N, J, S, type = "IID", burn_in = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="far_1_S_+3A_n">N</code></td>
<td>
<p>the number of fGARCH(1,1) curves to sample.</p>
</td></tr>
<tr><td><code id="far_1_S_+3A_j">J</code></td>
<td>
<p>the number of points at which each curve is sampled (the resolution of the data).</p>
</td></tr>
<tr><td><code id="far_1_S_+3A_s">S</code></td>
<td>
<p>the autoregressive operator of the model, between 0 and 1, indicating the level of
conditional heteroscedasticity.</p>
</td></tr>
<tr><td><code id="far_1_S_+3A_type">type</code></td>
<td>
<p>the assumed model of the error term. The default argument is 'IID', under which
the errors are assumed to be independent and identically distributed. The alternative argument
is 'fGARCH', which will assume that the errors follow an fGARCH(1,1) process.</p>
</td></tr>
<tr><td><code id="far_1_S_+3A_burn_in">burn_in</code></td>
<td>
<p>the number of initial samples to burn (discard).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A J x N matrix containing FAR(1,S) functional data in the columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- far_1_S(100, 50, 0.75)

</code></pre>

<hr>
<h2 id='fgarch_1_1'>'fgarch_1_1' Simulates an fGARCH(1,1) process with N independent observations, each observed</h2><span id='topic+fgarch_1_1'></span>

<h3>Description</h3>

<p>'fgarch_1_1' Simulates an fGARCH(1,1) process with N independent observations, each observed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgarch_1_1(N, J, delta = 0.01, burn_in = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgarch_1_1_+3A_n">N</code></td>
<td>
<p>the number of fGARCH(1,1) curves to sample.</p>
</td></tr>
<tr><td><code id="fgarch_1_1_+3A_j">J</code></td>
<td>
<p>the number of points at which each curve is sampled (the resolution of the data).</p>
</td></tr>
<tr><td><code id="fgarch_1_1_+3A_delta">delta</code></td>
<td>
<p>a parameter used in the variance recursion of the model.</p>
</td></tr>
<tr><td><code id="fgarch_1_1_+3A_burn_in">burn_in</code></td>
<td>
<p>the number of initial samples to burn (discard).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two J x N matrices, the former containing the sample of fGARCH(1,1)
curves and the latter containing the respective variance values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- fgarch_1_1(100, 50)

</code></pre>

<hr>
<h2 id='fport_test'>Compute Functional Hypothesis Tests</h2><span id='topic+fport_test'></span>

<h3>Description</h3>

<p>'fport_test' computes a variety of white noise tests for functional data. All white noise tests in this
package are accessible through this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fport_test(
  f_data,
  test = "multi-lag",
  lag = NULL,
  iid = FALSE,
  M = NULL,
  kernel = "Bartlett",
  bandwidth = "adaptive",
  components = 3,
  bootstrap = FALSE,
  block_size = "adaptive",
  moving = FALSE,
  straps = 300,
  alpha = 0.05,
  complete_test = FALSE,
  suppress_raw_output = FALSE,
  suppress_print_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fport_test_+3A_f_data">f_data</code></td>
<td>
<p>The functional data matrix with observed functions in the columns.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_test">test</code></td>
<td>
<p>A String specifying the hypothesis test. Currently available tests are referred to by their
string handles: &quot;single-lag&quot;, &quot;multi-lag&quot;, &quot;spectral&quot;, &quot;independence&quot;, and &quot;imhof&quot;. Please see the Details
section of the documentation, or the vignette, for a short overview of the available tests. For a more
complete treatment of these hypothesis tests, please consult the references.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_lag">lag</code></td>
<td>
<p>A positive integer value. Only used for the &quot;single-lag&quot;, &quot;multi-lag&quot;, &quot;independence&quot;, and &quot;imhof&quot; tests.
This parameter specifies the single lag, or maximum lag, to be used by the specified test.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_iid">iid</code></td>
<td>
<p>Only used for the &quot;single-lag&quot; and &quot;multi-lag&quot; tests. A Boolean value, FALSE by default. If given TRUE,
the hypothesis test will use a strong-white noise assumption (instead of a weak-white noise assumption).</p>
</td></tr>
<tr><td><code id="fport_test_+3A_m">M</code></td>
<td>
<p>Only used for the &quot;single-lag&quot; and &quot;multi-lag&quot; tests. A positive Integer. Determines the number of
Monte-Carlo simulations employed in the Welch-Satterthwaite approximation of the limiting distribution of the
test statistic.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_kernel">kernel</code></td>
<td>
<p>Only used for the &quot;spectral&quot; test. A String, 'Bartlett' by default. Specifies the kernel to be
used in the &quot;spectral&quot; test. Currently supported kernels are the 'Bartlett' and 'Parzen' kernels.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Only used for the &quot;spectral&quot; test. Either a String or a positive Integer value, 'adaptive' by
default. Determines the bandwidth (or lag-window) to be used for the test. Given the string handle 'adaptive',
the bandwidth is computed via a bandwidth selection method which aims to minimize the integrated normed
error of the spectral density operator. If the given string handle is 'static', the bandwidth is computed
to be n^(1/(2q + 1)), where n is the sample size and q is the kernel order. If a positive integer is
given, that will be the bandwidth that is used.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_components">components</code></td>
<td>
<p>Only used for the &quot;independence&quot; test. A positive Integer value. Determines the number of
functional principal components to use (ranked by their importance).</p>
</td></tr>
<tr><td><code id="fport_test_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Only used for the &quot;single-lag&quot; test. A Boolean value, FALSE by default. If given TRUE, the
hypothesis test is evaluated by approximating the limiting distribution of the test statistic via a block
bootstrapping process.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_block_size">block_size</code></td>
<td>
<p>Only used for the &quot;single-lag&quot; test in the case when 'bootstrap' = TRUE. A positive Integer
value, with the default value being computed via the adaptive bandwidth selection method in the &quot;spectral&quot; test.
Determines the block size (of each block in each bootstrap sample) if the test is being bootstrapped.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_moving">moving</code></td>
<td>
<p>Only used for the &quot;single-lag&quot; test in the case when 'bootstrap' = TRUE. A Boolean value, FALSE
by default If given TRUE, the performed block bootstrap will be moving rather than stationary.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_straps">straps</code></td>
<td>
<p>Only used for the &quot;single-lag&quot; test in the case when 'bootstrap' = TRUE. A positive Integer with
a default value of 300. Determines the number of bootstrap samples to take if the test is being bootstrapped.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value between 0 and 1 specifying the significance level to be used in the specified
hypothesis test. The default value is 0.05. Note, the significance value is only ever used to compute the
1-alpha quantile of the limiting distribution of the specified test's test statistic.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_complete_test">complete_test</code></td>
<td>
<p>A Boolean value, FALSE by default. If TRUE, the function requires no other parameters
other than f_data, and will return a table with a single column containing p-values from an array of tests
contained in the rows.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_suppress_raw_output">suppress_raw_output</code></td>
<td>
<p>A Boolean value, FALSE by default. If given TRUE, the function will not return a
list containing the p-value, quantile and statistic, and instead only prints output to the console.</p>
</td></tr>
<tr><td><code id="fport_test_+3A_suppress_print_output">suppress_print_output</code></td>
<td>
<p>A Boolean value, FALSE by default. If TRUE, the function will not print any
output to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;single-lag&quot; portmanteau test is based on the sample autocovariance function computed from the
functional data. This test assesses the significance of lagged autocovariance operators at a single, user-specified
lag h. More specifically, it tests the null hypothesis that the lag-h autocovariance operator is equal to 0.
This test is designed for stationary functional time-series, and is valid under conditional heteroscedasticity
conditions. The required parameter for this test is 'lag', which determines the lag at which the test is evaluated. If this
parameter is left blank, it will take a default of 1. The optional parameters for this test are 'iid', 'M', 'bootstrap',
'block_size', 'straps', 'moving',and 'alpha'.
</p>
<p>The &quot;multi-lag&quot; portmanteau test is also based on the sample autocovariance function computed from the functional
data. This test assesses the cumulative significance of lagged autocovariance operators, up to a user-selected
maximum lag K. More specifically, it tests the null hypothesis that the first K lag-h autocovariance operators
(h going from 1 to K) is equal to 0. This test is designed for stationary functional time-series, and is valid
under conditional heteroscedasticity conditions.
The required parameter for this test is 'lag', which determines the maximum lag at which the test is evaluated.
If this parameter is left blank, it will take a default of 20.
The optional parameters for this test are 'iid', 'M', 'bootstrap', 'block_size', 'straps', 'moving',
and 'alpha'.
</p>
<p>The &quot;spectral&quot; portmanteau test is based on the spectral density operator. It essentially measures the proximity of a
functional time series to a white noise - the constant spectral density operator of an uncorrelated series.
Unlike the &quot;single-lag&quot; and &quot;multi-lag&quot; tests, this test is not for general white noise series, and may not hold
under functional conditionally heteroscedastic assumptions.
The optional parameters for this test are 'kernel', 'bandwidth', and 'alpha'.
</p>
<p>The &quot;independence&quot; portmanteau test is a test of independence and identical distribution based on a dimensionality
reduction by projecting the data onto the most important functional principal components. It is based on the
resulting lagged cross-variances. This test is not for general white noise series, and may not hold under
functional conditionally heteroscedastic assumptions.
The required parameters for this test are 'lag' and 'components'. The 'lag' parameter determines the maximum lag at
which the test is evaluated. The 'components' parameter determines the number of the most important principal
components to use (importance is determined by the proportion of the variance that is explained by the
individual principal component.)
</p>
<p>The &quot;imhof&quot; portmanteau test is an analogue of the &quot;single-lag&quot; test. While the &quot;single-lag&quot; test computes the
limiting distribution of the test statistic via a Welch-Satterthwaite approximation, the &quot;imhof&quot; test directly
computes the coefficients of the quadratic form in Normal variables which the test statistic converges too as
the sample size goes to infinity. We warn the user that this test is extremely computationally expensive, and
is only recommended for small datasets as a means of cross-verification against the single-lag test.
The required parameter for this test is 'lag', which determines the lag at which the test is evaluated.
The &quot;imhof&quot; test requires the &quot;tensorA&quot; and &quot;CompQuadForm&quot; packages. Note also that the imhof test does not
return a statistic, and thus returns a list with only 2 elements if suppress_raw_output = FALSE.
</p>


<h3>Value</h3>

<p>If suppress_raw_output = FALSE, a list containing the test statistic, the 1-alpha quantile of the
limiting distribution, and the p-value computed from the specified hypothesis test. Also prints output
containing a short description of the test, the p-value, and additional information about the test if
suppress_print_output = FALSE. If 'complete-test' = TRUE, will return a 1-column table instead containing
the p-values for a variety of tests, which are given short descriptions in the index of the table.
</p>


<h3>References</h3>

<p>[1] Kokoszka P., &amp; Rice G., &amp; Shang H.L. (2017). Inference for the autocovariance of a functional time series
under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.
</p>
<p>[2] Characiejus V., &amp; Rice G. (2019). A general white noise test based on kernel lag-window estimates of the
spectral density operator. Econometrics and Statistics, submitted.
</p>
<p>[3] Gabrys R., &amp; Kokoszka P. (2007). Portmanteau Test of Independence for Functional Observations.
Journal of the American Statistical Association, 102:480, 1338-1348, DOI: 10.1198/016214507000001111.
</p>
<p>[4] Zhang X. (2016). White noise testing and model diagnostic checking for functional time series.
Journal of Econometrics, 194, 76-95.
</p>
<p>[5] Chen W.W. &amp; Deo R.S. (2004). Power transformations to induce normality and their applications.
Journal of the Royal Statistical Society: Series B (Statistical Methodology), 66, 117–130.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brown_motion(250, 50)
fport_test(b, test = 'single-lag', lag = 10)
fport_test(b, test = 'multi-lag', lag = 10, alpha = 0.01)
fport_test(b, test = 'single-lag', lag = 1, M = 250)
fport_test(b, test = 'spectral', kernel = 'Bartlett', bandwidth = 'static', alpha = 0.05)
fport_test(b, test = 'spectral', alpha = 0.1, kernel = 'Parzen', bandwidth = 'adaptive')
fport_test(b, test = 'independence', components = 3, lag = 3)

</code></pre>

<hr>
<h2 id='GOF_far'>Goodness-of-fit test for FAR(1)</h2><span id='topic+GOF_far'></span>

<h3>Description</h3>

<p>The &quot;GOF_far&quot; test fits a FAR(1) model and then assesses the cumulative significance of lagged
autocovariance operators from the model residuals, up to a user-selected maximum lag K.
More specifically, it tests the null hypothesis that the first K lag-h autocovariance
operators (h going from 1 to K) from the model residuals is equal to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GOF_far(
  f_data,
  lag = 5,
  M = 10000,
  alpha = 0.05,
  suppress_raw_output = FALSE,
  suppress_print_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GOF_far_+3A_f_data">f_data</code></td>
<td>
<p>The functional data matrix with observed functions in the columns.</p>
</td></tr>
<tr><td><code id="GOF_far_+3A_lag">lag</code></td>
<td>
<p>Positive integer value. A user-selected maximum lag. 10 by default.</p>
</td></tr>
<tr><td><code id="GOF_far_+3A_m">M</code></td>
<td>
<p>Positive integer value. Number of Monte-Carlo simulation for Welch-Satterthwaite approximation.10000 by default.</p>
</td></tr>
<tr><td><code id="GOF_far_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value between 0 and 1 specifying the significance level to be used in the specified
hypothesis test. The default value is 0.05. Note, the significance value is only ever used to compute the
1-alpha quantile of the limiting distribution of the specified test's test statistic.</p>
</td></tr>
<tr><td><code id="GOF_far_+3A_suppress_raw_output">suppress_raw_output</code></td>
<td>
<p>Boolean value, FALSE by default. If TRUE, the function will not return the list
containing the p-value, quantile, and statistic.</p>
</td></tr>
<tr><td><code id="GOF_far_+3A_suppress_print_output">suppress_print_output</code></td>
<td>
<p>Boolean value, FALSE by default. If TRUE, the function will not print any
output to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'GOF_far' computes the goodness-of-fit test for FAR(1) over a range of user-specified lags.
</p>


<h3>Value</h3>

<p>If suppress_raw_output = FALSE, a list containing the test statistic, the 1-alpha quantile of the
limiting distribution, and the p-value computed from the specified hypothesis test. Also prints output
containing a short description of the test, the p-value, and additional information about the test if
suppress_print_output = FALSE.
</p>


<h3>References</h3>

<p>[1] Kim, M., Kokoszka, P., &amp; Rice, G. (2023). White noise testing for functional time series. Statistic Surveys, 17, 119-168.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- far_1_S(100, 50, 0.75)
GOF_far(f, lag=5)

</code></pre>

<hr>
<h2 id='iid_covariance'>Compute part of the covariance under a strong white noise assumption</h2><span id='topic+iid_covariance'></span>

<h3>Description</h3>

<p>'iid_covariance' A helper function used to compute one of the two independent sum terms in the
computation of the approximate covariance of the functional data under a strong white noise assumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iid_covariance(f_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iid_covariance_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-dimensional matrix containing one of the two independent sums in the computation of the
covariance.
</p>

<hr>
<h2 id='iid_covariance_vec'>Compute part of the covariance under a strong white noise assumption</h2><span id='topic+iid_covariance_vec'></span>

<h3>Description</h3>

<p>'iid_covariance_vec' A helper function used to compute one of the two independent sum terms in the
computation of the approximate covariance of the functional data under a strong white noise assumption;
a vectorized version of iid_covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iid_covariance_vec(f_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iid_covariance_vec_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-dimensional matrix containing one of the two independent sums in the computation of the
covariance.
</p>

<hr>
<h2 id='independence_test'>Independence Test</h2><span id='topic+independence_test'></span>

<h3>Description</h3>

<p>'independence_test' Computes the independence test with a user-specified number of principal components
and range of lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>independence_test(
  f_data,
  components,
  lag,
  alpha = 0.05,
  suppress_raw_output = FALSE,
  suppress_print_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="independence_test_+3A_f_data">f_data</code></td>
<td>
<p>The functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="independence_test_+3A_components">components</code></td>
<td>
<p>A positive Integer specifying the number of principal components to project the data on;
ranked in order of importance (importance is determined by the proportion of the variance that is explained
by the individual principal component.)</p>
</td></tr>
<tr><td><code id="independence_test_+3A_lag">lag</code></td>
<td>
<p>A positive Integer value, specifying the maximum lag to include - this can be seen as the bandwidth
or lag-window.</p>
</td></tr>
<tr><td><code id="independence_test_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value between 0 and 1 specifying the significance level to be used in the specified
hypothesis test. The default value is 0.05. Note, the significance value is only ever used to compute the
1-alpha quantile of the limiting distribution of the specified test's test statistic.</p>
</td></tr>
<tr><td><code id="independence_test_+3A_suppress_raw_output">suppress_raw_output</code></td>
<td>
<p>Boolean value, FALSE by default. If TRUE, the function will not return the list
containing the p-value, quantile, and statistic.</p>
</td></tr>
<tr><td><code id="independence_test_+3A_suppress_print_output">suppress_print_output</code></td>
<td>
<p>Boolean value, FALSE by default. If TRUE, the function will not print any
output to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;independence&quot; portmanteau test is a test of independence and identical distribution based on a
dimensionality reduction by projecting the data onto the most important functional principal components.
It is based on the resulting lagged cross-variances. This test is not for general white noise series, and
may not hold under functional conditionally heteroscedastic assumptions. Please consult the vignette for a
deeper exposition, and consult the reference for a complete treatment.
</p>


<h3>Value</h3>

<p>If suppress_raw_output = FALSE, a list containing the test statistic, the 1-alpha quantile of the
limiting distribution, and the p-value computed from the specified hypothesis test. Also prints output
containing a short description of the test, the p-value, and additional information about the test if
suppress_print_output = FALSE.
</p>


<h3>References</h3>

<p>[1] Gabrys R., &amp; Kokoszka P. (2007). Portmanteau Test of Independence for Functional Observations.
Journal of the American Statistical Association, 102:480, 1338-1348, DOI: 10.1198/016214507000001111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brown_motion(250, 100)
independence_test(b, components = 3, lag = 5)

</code></pre>

<hr>
<h2 id='multi_lag_test'>Multi-Lag Hypothesis Test</h2><span id='topic+multi_lag_test'></span>

<h3>Description</h3>

<p>'multi_lag_test' Computes the multi-lag hypothesis test over a range of user-specified lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_lag_test(
  f_data,
  lag = 20,
  M = NULL,
  iid = FALSE,
  alpha = 0.05,
  suppress_raw_output = FALSE,
  suppress_print_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_lag_test_+3A_f_data">f_data</code></td>
<td>
<p>The functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="multi_lag_test_+3A_lag">lag</code></td>
<td>
<p>Positive integer value. The lag to use to compute the multi-lag test statistic</p>
</td></tr>
<tr><td><code id="multi_lag_test_+3A_m">M</code></td>
<td>
<p>Positive integer value. Number of Monte-Carlo simulation for Welch-Satterthwaite approximation.</p>
</td></tr>
<tr><td><code id="multi_lag_test_+3A_iid">iid</code></td>
<td>
<p>A Boolean value, FALSE by default. If given TRUE, the hypothesis test will use a strong-white
noise assumption (instead of a weak-white noise assumption).</p>
</td></tr>
<tr><td><code id="multi_lag_test_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value between 0 and 1 specifying the significance level to be used in the specified
hypothesis test. The default value is 0.05. Note, the significance value is only ever used to compute the
1-alpha quantile of the limiting distribution of the specified test's test statistic.</p>
</td></tr>
<tr><td><code id="multi_lag_test_+3A_suppress_raw_output">suppress_raw_output</code></td>
<td>
<p>Boolean value, FALSE by default. If TRUE, the function will not return the list
containing the p-value, quantile, and statistic.</p>
</td></tr>
<tr><td><code id="multi_lag_test_+3A_suppress_print_output">suppress_print_output</code></td>
<td>
<p>Boolean value, FALSE by default. If TRUE, the function will not print any
output to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;multi-lag&quot; portmanteau test is also based on the sample autocovariance function computed from the
functional data. This test assesses the cumulative significance of lagged autocovariance operators, up to a
user-selected maximum lag K. More specifically, it tests the null hypothesis that the first K lag-h autocovariance
operators (h going from 1 to K) is equal to 0. This test is designed for stationary functional time-series, and
is valid under conditional heteroscedasticity conditions.
</p>


<h3>Value</h3>

<p>If suppress_raw_output = FALSE, a list containing the test statistic, the 1-alpha quantile of the
limiting distribution, and the p-value computed from the specified hypothesis test. Also prints output
containing a short description of the test, the p-value, and additional information about the test if
suppress_print_output = FALSE.
</p>


<h3>References</h3>

<p>[1] Kokoszka P., &amp; Rice G., &amp; Shang H.L. (2017). Inference for the autocovariance of a functional time series
under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brown_motion(150, 50)
multi_lag_test(b, lag = 5)
multi_lag_test(b, lag = 10, M = 50)

</code></pre>

<hr>
<h2 id='parzen_kernel'>Parzen Kernel Function</h2><span id='topic+parzen_kernel'></span>

<h3>Description</h3>

<p>'parzen_kernel' Computes the Parzen kernel function at a given point value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parzen_kernel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parzen_kernel_+3A_x">x</code></td>
<td>
<p>the point value at which the kernel function is evaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value; the value of the Parzen kernel function at the point value x.
</p>

<hr>
<h2 id='Q_WS_hyp_test'>Compute size alpha single-lag hypothesis test under weak or strong white noise assumption</h2><span id='topic+Q_WS_hyp_test'></span>

<h3>Description</h3>

<p>'Q_WS_hyp_test' computes the size alpha test of a single lag hypothesis under a weak white noise
or strong white noise assumption using a Welch-Satterthwaite Approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q_WS_hyp_test(
  f_data,
  lag,
  alpha = 0.05,
  iid = FALSE,
  M = NULL,
  bootstrap = FALSE,
  block_size = "adaptive",
  straps = 300,
  moving = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q_WS_hyp_test_+3A_f_data">f_data</code></td>
<td>
<p>The functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="Q_WS_hyp_test_+3A_lag">lag</code></td>
<td>
<p>Positive integer value. The lag to use to compute the single lag test statistic.</p>
</td></tr>
<tr><td><code id="Q_WS_hyp_test_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value between 0 and 1 specifying the significance level to be used in the specified
hypothesis test. The default value is 0.05. Note, the significance value is only ever used to compute the
1-alpha quantile of the limiting distribution of the specified test's test statistic.</p>
</td></tr>
<tr><td><code id="Q_WS_hyp_test_+3A_iid">iid</code></td>
<td>
<p>A Boolean value, FALSE by default. If given TRUE, the hypothesis test will use a strong-white
noise assumption (instead of a weak-white noise assumption).</p>
</td></tr>
<tr><td><code id="Q_WS_hyp_test_+3A_m">M</code></td>
<td>
<p>Positive integer value. Number of Monte-Carlo simulations for the Welch-Satterthwaite approximation.</p>
</td></tr>
<tr><td><code id="Q_WS_hyp_test_+3A_bootstrap">bootstrap</code></td>
<td>
<p>A Boolean value, FALSE by default. If given TRUE, the hypothesis test is done by
approximating the limiting distribution of the test statistic via a block bootstrap process.</p>
</td></tr>
<tr><td><code id="Q_WS_hyp_test_+3A_block_size">block_size</code></td>
<td>
<p>A positive Integer value, with the default value being computed via the adaptive
bandwidth selection method in the &quot;spectral&quot; test. Determines the block size (of each block in each
bootstrap sample) if the test is being bootstrapped.</p>
</td></tr>
<tr><td><code id="Q_WS_hyp_test_+3A_straps">straps</code></td>
<td>
<p>A positive Integer, with a default value of 300. Determines the number of bootstrap samples
to take if the test is being bootstrapped. Only used if 'bootstrap' == TRUE.</p>
</td></tr>
<tr><td><code id="Q_WS_hyp_test_+3A_moving">moving</code></td>
<td>
<p>A Boolean value, FALSE by default. If given TRUE, the performed block bootstrap will be moving
rather than stationary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the p-value, the quantile, and a boolean value indicating whether or not the
hypothesis is rejected.
</p>

<hr>
<h2 id='scalar_covariance_i_j'>Compute the approximate covariance at a point for lag windows defined by i,j</h2><span id='topic+scalar_covariance_i_j'></span>

<h3>Description</h3>

<p>'scalar_covariance_i_j' computes the approximate covariance at a point of the functional data
for lag windows defined by i,j; a scalarized version of covariance_i_j that takes point estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalar_covariance_i_j(f_data, i, j, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalar_covariance_i_j_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="scalar_covariance_i_j_+3A_i">i</code>, <code id="scalar_covariance_i_j_+3A_j">j</code></td>
<td>
<p>the indices i,j in 1:T that we are computing the covariance for</p>
</td></tr>
<tr><td><code id="scalar_covariance_i_j_+3A_times">times</code></td>
<td>
<p>A vector with 4 columns containing indices specifying which subset of f_data to consider</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value; the covariance of the functional data at a point for lag
windows defined by i,j.
</p>

<hr>
<h2 id='scalar_covariance_i_j_vec'>Compute the approximate covariance at a point for lag windows defined by i,j</h2><span id='topic+scalar_covariance_i_j_vec'></span>

<h3>Description</h3>

<p>'scalar_covariance_i_j_vec' computes the approximate covariance at a point of the functional data
for lag windows defined by i,j; a vectorized version of scalar_covariance_i_j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalar_covariance_i_j_vec(f_data, i, j, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalar_covariance_i_j_vec_+3A_f_data">f_data</code></td>
<td>
<p>the functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="scalar_covariance_i_j_vec_+3A_i">i</code>, <code id="scalar_covariance_i_j_vec_+3A_j">j</code></td>
<td>
<p>the indices i,j in 1:T that we are computing the covariance for</p>
</td></tr>
<tr><td><code id="scalar_covariance_i_j_vec_+3A_times">times</code></td>
<td>
<p>A vector with 4 columns containing indices specifying which subset of f_data to consider</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value; the covariance of the functional data at a point for lag
windows defined by i,j.
</p>

<hr>
<h2 id='single_lag_test'>Single-Lag Hypothesis Test</h2><span id='topic+single_lag_test'></span>

<h3>Description</h3>

<p>'single_lag_test' computes the single-lag hypothesis test at a single user-specified lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_lag_test(
  f_data,
  lag = 1,
  alpha = 0.05,
  iid = FALSE,
  M = NULL,
  bootstrap = FALSE,
  block_size = "adaptive",
  straps = 300,
  moving = FALSE,
  suppress_raw_output = FALSE,
  suppress_print_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_lag_test_+3A_f_data">f_data</code></td>
<td>
<p>The functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="single_lag_test_+3A_lag">lag</code></td>
<td>
<p>Positive integer value. The lag to use to compute the single lag test statistic.</p>
</td></tr>
<tr><td><code id="single_lag_test_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value between 0 and 1 specifying the significance level to be used in the specified
hypothesis test. The default value is 0.05. Note, the significance value is only ever used to compute the
1-alpha quantile of the limiting distribution of the specified test's test statistic.</p>
</td></tr>
<tr><td><code id="single_lag_test_+3A_iid">iid</code></td>
<td>
<p>A Boolean value, FALSE by default. If given TRUE, the hypothesis test will use a strong-white
noise assumption (instead of a weak-white noise assumption).</p>
</td></tr>
<tr><td><code id="single_lag_test_+3A_m">M</code></td>
<td>
<p>Positive integer value. Number of Monte-Carlo simulations for the Welch-Satterthwaite approximation.</p>
</td></tr>
<tr><td><code id="single_lag_test_+3A_bootstrap">bootstrap</code></td>
<td>
<p>A Boolean value, FALSE by default. If given TRUE, the hypothesis test is done by
approximating the limiting distribution of the test statistic via a block bootstrap process.</p>
</td></tr>
<tr><td><code id="single_lag_test_+3A_block_size">block_size</code></td>
<td>
<p>A positive Integer value, with the default value being computed via the adaptive
bandwidth selection method in the &quot;spectral&quot; test. Determines the block size (of each block in each
bootstrap sample) if the test is being bootstrapped.</p>
</td></tr>
<tr><td><code id="single_lag_test_+3A_straps">straps</code></td>
<td>
<p>A positive Integer, with a default value of 300. Determines the number of bootstrap samples
to take if the test is being bootstrapped. Only used if 'bootstrap' == TRUE.</p>
</td></tr>
<tr><td><code id="single_lag_test_+3A_moving">moving</code></td>
<td>
<p>A Boolean value, FALSE by default. If given TRUE, the performed block bootstrap will be moving
rather than stationary.</p>
</td></tr>
<tr><td><code id="single_lag_test_+3A_suppress_raw_output">suppress_raw_output</code></td>
<td>
<p>Boolean value, FALSE by default. If TRUE, the function will not return the list
containing the p-value, quantile, and statistic.</p>
</td></tr>
<tr><td><code id="single_lag_test_+3A_suppress_print_output">suppress_print_output</code></td>
<td>
<p>Boolean value, FALSE by default. If TRUE, the function will not print any
output to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;single-lag&quot; portmanteau test is based on the sample autocovariance function computed from the
functional data. This test assesses the significance of lagged autocovariance operators at a single,
user-specified lag h. More specifically, it tests the null hypothesis that the lag-h autocovariance
operator is equal to 0. This test is designed for stationary functional time-series, and is valid under
conditional heteroscedasticity conditions.
</p>


<h3>Value</h3>

<p>If suppress_raw_output = FALSE, a list containing the test statistic, the 1-alpha quantile of the
limiting distribution, and the p-value computed from the specified hypothesis test. Also prints output
containing a short description of the test, the p-value, and additional information about the test if
suppress_print_output = FALSE.
</p>


<h3>References</h3>

<p>[1] Kokoszka P., &amp; Rice G., &amp; Shang H.L. (2017). Inference for the autocovariance of a functional time series
under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- far_1_S(150, 50, S = 0.75)
single_lag_test(f, lag = 1)
single_lag_test(f, lag = 2, M=100)

</code></pre>

<hr>
<h2 id='spectral_test'>Spectral Density Test</h2><span id='topic+spectral_test'></span>

<h3>Description</h3>

<p>The &quot;spectral&quot; portmanteau test is based on the spectral density operator. It essentially measures
the proximity of a functional time series to a white noise - the constant spectral density operator of an
uncorrelated series. Unlike the &quot;single-lag&quot; and &quot;multi-lag&quot; tests, this test is not for general white noise
series, and may not hold under functional conditionally heteroscedastic assumptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_test(
  f_data,
  kernel = "Bartlett",
  bandwidth = "adaptive",
  alpha = 0.05,
  suppress_raw_output = FALSE,
  suppress_print_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_test_+3A_f_data">f_data</code></td>
<td>
<p>The functional data matrix with observed functions in the columns</p>
</td></tr>
<tr><td><code id="spectral_test_+3A_kernel">kernel</code></td>
<td>
<p>A String specifying the kernel function to use. The currently supported kernels are the
'Bartlett' and  'Parzen' kernels. The default kernel is 'Bartlett'.</p>
</td></tr>
<tr><td><code id="spectral_test_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A String or positive Integer value which specifies the bandwidth to use. Currently admitted
string handles are 'static' which computes the bandwidth p via p = n^(1/(2q+1)) where n is the sample size
and q is the kernel order, or 'adaptive' which uses a bandwidth selection method that is based on the
functional data.</p>
</td></tr>
<tr><td><code id="spectral_test_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value between 0 and 1 specifying the significance level to be used for the test.
The significance level is 0.05 by default. Note, the significance value is only ever used to compute the
1-alpha quantile of the limiting distribution of the specified test's test statistic.</p>
</td></tr>
<tr><td><code id="spectral_test_+3A_suppress_raw_output">suppress_raw_output</code></td>
<td>
<p>Boolean value, FALSE by default. If TRUE, the function will not return the list
containing the p-value, quantile, and statistic.</p>
</td></tr>
<tr><td><code id="spectral_test_+3A_suppress_print_output">suppress_print_output</code></td>
<td>
<p>Boolean value, FALSE by default. If TRUE, the function will not print any
output to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'spectral_test' Computes the spectral hypothesis test under a user-specified kernel function and
bandwidth; automatic bandwidth selection methods are provided.
</p>


<h3>Value</h3>

<p>If suppress_raw_output = FALSE, a list containing the test statistic, the 1-alpha quantile of the
limiting distribution, and the p-value computed from the specified hypothesis test. Also prints output
containing a short description of the test, the p-value, and additional information about the test if
suppress_print_output = FALSE.
</p>


<h3>References</h3>

<p>[1] Characiejus V., &amp; Rice G. (2019). A general white noise test based on kernel lag-window estimates of the
spectral density operator. Econometrics and Statistics, submitted.
</p>
<p>[2] Chen W.W. &amp; Deo R.S. (2004). Power transformations to induce normality and their applications.
Journal of the Royal Statistical Society: Series B (Statistical Methodology), 66, 117–130.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- brown_motion(100, 50)
spectral_test(b)
spectral_test(b, kernel = 'Parzen', bandwidth = 'adaptive')
spectral_test(b, kernel = 'Bartlett', bandwidth = 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
