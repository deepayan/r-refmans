<!DOCTYPE html><html><head><title>Help for package SparseM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SparseM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#character or NULL-class'><p>Class &quot;character or NULL&quot;</p></a></li>
<li><a href='#lsq'><p>Least Squares Problems in Surveying</p></a></li>
<li><a href='#matrix.coo-class'><p>Class &quot;matrix.coo&quot;</p></a></li>
<li><a href='#matrix.csc-class'><p>Class &quot;matrix.csc&quot;</p></a></li>
<li><a href='#matrix.csc.hb-class'><p>Class &quot;matrix.csc.hb&quot;</p></a></li>
<li><a href='#matrix.csr-class'><p>Class &quot;matrix.csr&quot;</p></a></li>
<li><a href='#matrix.csr.chol-class'><p>Class &quot;matrix.csr.chol&quot;</p></a></li>
<li><a href='#matrix.ssc-class'><p>Class &quot;matrix.ssc&quot;</p></a></li>
<li><a href='#matrix.ssc.hb-class'><p>Class &quot;matrix.ssc.hb&quot;</p></a></li>
<li><a href='#matrix.ssr-class'><p>Class &quot;matrix.ssr&quot;</p></a></li>
<li><a href='#mslm-class'><p>Class &quot;mslm&quot;</p></a></li>
<li><a href='#numeric or NULL-class'><p>Class &quot;numeric or NULL&quot;</p></a></li>
<li><a href='#slm'><p>Fit a linear regression model using sparse matrix algebra</p></a></li>
<li><a href='#slm-class'><p>Class &quot;slm&quot;</p></a></li>
<li><a href='#slm.fit'><p>Internal slm fitting functions</p></a></li>
<li><a href='#slm.methods'><p>Methods for slm objects</p></a></li>
<li><a href='#SparseM.hb'><p>Harwell-Boeing Format Sparse Matrices</p></a></li>
<li><a href='#SparseM.image'><p>Image Plot for Sparse Matrices</p></a></li>
<li><a href='#SparseM.ontology'><p>Sparse Matrix Class</p></a></li>
<li><a href='#SparseM.ops'><p>Basic Linear Algebra for Sparse Matrices</p></a></li>
<li><a href='#SparseM.solve'><p>Linear Equation Solving for Sparse Matrices</p></a></li>
<li><a href='#summary.mslm-class'><p>Class &quot;summary.mslm&quot;</p></a></li>
<li><a href='#summary.slm-class'><p>Class &quot;summary.slm&quot;</p></a></li>
<li><a href='#triogramX'><p>A Design Matrix for a Triogram Problem</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.81</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roger Koenker &lt;rkoenker@uiuc.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger Koenker [cre, aut],
  Pin Tian Ng [ctb] (Contributions to Sparse QR code),
  Yousef Saad [ctb] (author of sparskit2),
  Ben Shaby [ctb] (author of chol2csr)</td>
</tr>
<tr>
<td>Description:</td>
<td>Some basic linear algebra functionality for sparse matrices is
  provided:  including Cholesky decomposition and backsolving as well as 
  standard R subsetting and Kronecker products.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Linear Algebra</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.econ.uiuc.edu/~roger/research/sparse/sparse.html">http://www.econ.uiuc.edu/~roger/research/sparse/sparse.html</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-18 11:10:52 UTC; roger</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-18 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='character+20or+20NULL-class'>Class &quot;character or NULL&quot;</h2><span id='topic+character+20or+20NULL-class'></span>

<h3>Description</h3>

<p>A virtual class needed by the &quot;matrix.csc.hb&quot; class</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;character or NULL&quot; in the signature.
</p>

<hr>
<h2 id='lsq'>Least Squares Problems in Surveying</h2><span id='topic+lsq'></span>

<h3>Description</h3>

<p>One of the four matrices from the least-squares solution of 
problems in surveying that were used by Michael Saunders and Chris Paige 
in the testing of LSQR</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lsq)</code></pre>


<h3>Format</h3>

<p>A list of class <code>matrix.csc.hb</code> or <code>matrix.ssc.hb</code> depending
on how the coefficient matrix is stored with the following components:
</p>

<ul>
<li><p>ra ra component of the csc or ssc format of the coefficient matrix, X.
   </p>
</li>
<li><p>ja ja component of the csc or ssc format of the coefficient matrix, X.
   </p>
</li>
<li><p>ia ia component of the csc or ssc format of the coefficient matrix, X.
   </p>
</li>
<li><p>rhs.ra ra component of the right-hand-side, y, if stored in csc or
ssc format; right-hand-side stored in dense vector or matrix otherwise.
</p>
</li>
<li><p>rhs.ja ja component of the right-hand-side, y, if stored in csc or 
ssc format; a null vector otherwise.
</p>
</li>
<li><p>rhs.ia ia component of the right-hand-side, y, if stored in csc or
ssc format; a null vector otherwise.
</p>
</li>
<li><p>xexactvector of the exact solutions, b, if they exist; a null vector o
therwise.  </p>
</li>
<li><p>guessvector of the initial guess of the solutions if they exist;
a null vector otherwise.
</p>
</li>
<li><p>dimdimenson of the coefficient matrix, X.
</p>
</li>
<li><p>rhs.dimdimenson of the right-hand-side, y.
</p>
</li>
<li><p>rhs.modestorage mode of the right-hand-side; can be full storage or
same format as the coefficient matrix.
</p>
</li></ul>



<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>
<p>Matrix Market, <a href="https://math.nist.gov/MatrixMarket/data/Harwell-Boeing/lsq/lsq.html">https://math.nist.gov/MatrixMarket/data/Harwell-Boeing/lsq/lsq.html</a>
</p>


<h3>See Also</h3>

<p><code>read.matrix.hb</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lsq)
class(lsq) # -&gt; [1] "matrix.csc.hb"
model.matrix(lsq)-&gt;X
class(X) # -&gt; "matrix.csr"
dim(X) # -&gt; [1] 1850  712
y &lt;- model.response(lsq) # extract the rhs
length(y) # [1] 1850 
</code></pre>

<hr>
<h2 id='matrix.coo-class'>Class &quot;matrix.coo&quot;</h2><span id='topic+matrix.coo-class'></span>

<h3>Description</h3>

<p>A new class for sparse matrices stored in coordinate format</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.coo", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, a real array of nnz elements containing the non-zero
elements of A.</p>
</dd> 
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the column
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the row
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimension of the matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.matrix.csr</dt><dd><p><code>signature(x = "matrix.coo")</code>: ... </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "matrix.coo")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "matrix.coo")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+matrix.csr-class">matrix.csr-class</a></code></p>

<hr>
<h2 id='matrix.csc-class'>Class &quot;matrix.csc&quot;</h2><span id='topic+matrix.csc-class'></span>

<h3>Description</h3>

<p>A new class for sparse matrices stored in compressed sparse column format</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.csc", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, a real array of nnz elements containing the non-zero
elements of A, stored in column order. Thus, if i&lt;j, all elements
of column i precede elements from column j. The order of elements
within the column is immaterial.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the row
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of n+1 elements containing pointers to
the beginning of each column in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;. Thus
&lsquo;ia[i]&rsquo; indicates the position in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;
where the ith column begins. The last, (n+1)st, element of &lsquo;ia&rsquo;
indicates where the n+1 column would start, if it existed.
</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimension of the matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.matrix.csr</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>as.matrix.ssc</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>as.matrix.ssr</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>chol</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+matrix.csr-class">matrix.csr-class</a></code></p>

<hr>
<h2 id='matrix.csc.hb-class'>Class &quot;matrix.csc.hb&quot;</h2><span id='topic+matrix.csc.hb-class'></span>

<h3>Description</h3>

<p>A new class consists of the coefficient matrix and
the right-hand-side of a linear system of equations,
initial guess of the solution and the exact solutions if they exist stored
in external files using the Harwell-Boeing format.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.csc.hb", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, ra component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, ja component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>numeric</code>, ia component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>
<dt><code>rhs.ra</code>:</dt><dd><p>Object of class <code>numeric</code>, ra component of the right-hand-side, y, if stored in csc or
ssc format; right-hand-side stored in dense vector or matrix otherwise.</p>
</dd>
<dt><code>guess</code>:</dt><dd><p>Object of class <code>numeric</code> or <code>NULL</code> vector of the initial guess of the solutions if they exist;
a null vector otherwise.</p>
</dd>
<dt><code>xexact</code>:</dt><dd><p>Object of class <code>numeric or NULL</code> vector of the exact solutions, b, if they exist; a null vector otherwise.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimenson of the coefficient matrix, X.</p>
</dd>
<dt><code>rhs.dim</code>:</dt><dd><p>Object of class <code>integer</code>, dimenson of the right-hand-side, y.</p>
</dd>
<dt><code>rhs.mode</code>:</dt><dd><p>Object of class <code>character or NULL</code> storage mode of the right-hand-side; can be full storage or
same format as the coefficient matrix.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>model.matrix</dt><dd><p><code>signature(object = "matrix.csc.hb")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+model.matrix">model.matrix</a></code>, <code><a href="#topic+model.response">model.response</a></code>, 
<code><a href="#topic+read.matrix.hb">read.matrix.hb</a></code>,  <code><a href="#topic+matrix.ssc.hb-class">matrix.ssc.hb-class</a></code></p>

<hr>
<h2 id='matrix.csr-class'>Class &quot;matrix.csr&quot;</h2><span id='topic+matrix.csr-class'></span><span id='topic+matrix.diag.csr-class'></span>

<h3>Description</h3>

<p>A new class for sparse matrices stored in compressed sparse row format</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.csr", ...)</code>.
and coerced from various other formats.  Coercion of integer scalars 
and vectors into identity matrices and diagonal matrices respectively
is accomplished by <code>as(x,"matrix.diag.csr")</code> which generates an
object that has all the rights and responsibilties of the matrix.csr class.
The default matrix.csr object is a scalar (1 by 1) matrix  with element 0.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, a real array of nnz elements containing the non-zero
elements of A, stored in row order. Thus, if i&lt;j, all elements
of row i precede elements from row j. The order of elements
within the rows is immaterial.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the column
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of n+1 elements containing pointers to
the beginning of each row in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;. Thus
&lsquo;ia[i]&rsquo; indicates the position in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;
where the ith row begins. The last, (n+1)st, element of &lsquo;ia&rsquo;
indicates where the n+1 row would start, if it existed.
</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimension of the matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>%*%</dt><dd><p><code>signature(x = "matrix.csr", y = "matrix.csr")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "matrix.csr", y = "matrix")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "matrix.csr", y = "numeric")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "matrix", y = "matrix.csr")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "numeric", y = "matrix.csr")</code>: ... </p>
</dd>
<dt>as.matrix.csc</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>as.matrix.ssc</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>as.matrix.ssr</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>as.matrix.coo</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>chol</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>diag&lt;-</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>image</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "matrix.csr")</code>: ... </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>diff</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+matrix.csc-class">matrix.csc-class</a></code></p>

<hr>
<h2 id='matrix.csr.chol-class'>Class &quot;matrix.csr.chol&quot;</h2><span id='topic+matrix.csr.chol-class'></span>

<h3>Description</h3>

<p>A class of objects returned from Ng and Peyton's (1993) block
sparse Cholesky algorithm</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.csr.chol", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nrow</code>:</dt><dd><p>Object of class <code>integer</code>, number of rows in the linear system of equations </p>
</dd>
<dt><code>nnzlindx</code>:</dt><dd><p>Object of class <code>numeric</code>, number of non-zero elements in lindx</p>
</dd>
<dt><code>nsuper</code>:</dt><dd><p>Object of class <code>integer</code>, number of supernodes</p>
</dd>
<dt><code>lindx</code>:</dt><dd><p>Object of class <code>integer</code>, vector of integer
containing, in column major order, the row subscripts of the non-zero entries 
in the Cholesky factor in a compressed storage format</p>
</dd>
<dt><code>xlindx</code>:</dt><dd><p>Object of class <code>integer</code>, vector of integer of pointers for lindx</p>
</dd>
<dt><code>nnzl</code>:</dt><dd><p>Object of class <code>numeric</code>, number of non-zero
entries, including the diagonal entries, of the Cholesky factor stored in lnz</p>
</dd>
<dt><code>lnz</code>:</dt><dd><p>Object of class <code>numeric</code>, contains the entries of the Cholesky factor </p>
</dd>
<dt><code>log.det</code>:</dt><dd><p>Object of class <code>numeric</code>, log determinant of the Cholesky factor</p>
</dd>
<dt><code>xlnz</code>:</dt><dd><p>Object of class <code>integer</code>, column pointer for the Cholesky factor stored in lnz</p>
</dd>
<dt><code>invp</code>:</dt><dd><p>Object of class <code>integer</code>, vector of integer of inverse permutation vector</p>
</dd>
<dt><code>perm</code>:</dt><dd><p>Object of class <code>integer</code>, vector of integer of permutation vector </p>
</dd>
<dt><code>xsuper</code>:</dt><dd><p>Object of class <code>integer</code>, array containing the supernode partioning</p>
</dd>
<dt><code>det</code>:</dt><dd><p>Object of class <code>numeric</code>, determinant of the Cholesky factor</p>
</dd>
<dt><code>ierr</code>:</dt><dd><p>Object of class <code>integer</code>, error flag </p>
</dd>
<dt><code>time</code>:</dt><dd><p>Object of class <code>numeric</code> execution time </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>backsolve</dt><dd><p><code>signature(r = "matrix.csr.chol")</code>: ... </p>
</dd>
<dt>as.matrix.csr</dt><dd><p><code>signature(x = "matrix.csr.chol", upper.tri=TRUE)</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+chol">chol</a></code>, <code><a href="#topic+backsolve">backsolve</a></code></p>

<hr>
<h2 id='matrix.ssc-class'>Class &quot;matrix.ssc&quot;</h2><span id='topic+matrix.ssc-class'></span>

<h3>Description</h3>

<p>A new class for sparse matrices stored in symmetric sparse column format</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.ssc", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, a real array of nnz elements containing the non-zero
elements of the lower triangular part of A, stored in column order. Thus, if i&lt;j, all elements
of column i precede elements from column j. The order of elements
within the column is immaterial.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the row
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of n+1 elements containing pointers to
the beginning of each column in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;. Thus
&lsquo;ia[i]&rsquo; indicates the position in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;
where the ith column begins. The last, (n+1)st, element of &lsquo;ia&rsquo;
indicates where the n+1 column would start, if it existed.
</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimension of the matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.matrix.csc</dt><dd><p><code>signature(x = "matrix.ssc")</code>: ... </p>
</dd>
<dt>as.matrix.csr</dt><dd><p><code>signature(x = "matrix.ssc")</code>: ... </p>
</dd>
<dt>as.matrix.ssr</dt><dd><p><code>signature(x = "matrix.ssc")</code>: ... </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "matrix.ssc")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "matrix.ssc")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+matrix.csr-class">matrix.csr-class</a></code></p>

<hr>
<h2 id='matrix.ssc.hb-class'>Class &quot;matrix.ssc.hb&quot;</h2><span id='topic+matrix.ssc.hb-class'></span>

<h3>Description</h3>

<p>A new class consists of the coefficient matrix and
the right-hand-side of a linear system of equations,
initial guess of the solution and the exact solutions if they exist stored
in external files using the Harwell-Boeing format.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.ssc.hb", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, ra component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, ja component of the csc or s
sc format of the coefficient matrix, X.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, ia component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>
<dt><code>rhs.ra</code>:</dt><dd><p>Object of class <code>numeric</code>, ra component of the right-hand-side, y, if stored in csc or
ssc format; right-hand-side stored in dense vector or matrix otherwise.</p>
</dd>
<dt><code>guess</code>:</dt><dd><p>Object of class <code>numeric or NULL</code> vector of the initial guess of the solutions if they exist;
a null vector otherwise.</p>
</dd>
<dt><code>xexact</code>:</dt><dd><p>Object of class <code>numeric or NULL</code> vector of the exact solutions, b, if they exist; a null vector otherwise.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimenson of the coefficient matrix, X.</p>
</dd>
<dt><code>rhs.dim</code>:</dt><dd><p>Object of class <code>integer</code>, dimenson of the right-hand-side, y.</p>
</dd>
<dt><code>rhs.mode</code>:</dt><dd><p>Object of class <code>character or NULL</code> storage mode of the right-hand-side; can be full storage or
same format as the coefficient matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"matrix.csc.hb"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>model.matrix</dt><dd><p><code>signature(object = "matrix.ssc.hb")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+model.matrix">model.matrix</a></code>, <code><a href="#topic+model.response">model.response</a></code>, 
<code><a href="#topic+read.matrix.hb">read.matrix.hb</a></code>, <code><a href="#topic+matrix.csc.hb-class">matrix.csc.hb-class</a></code></p>

<hr>
<h2 id='matrix.ssr-class'>Class &quot;matrix.ssr&quot;</h2><span id='topic+matrix.ssr-class'></span>

<h3>Description</h3>

<p>A new class for sparse matrices stored in symmetric sparse row format</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.ssr", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, a real array of nnz elements containing the non-zero
elements of the lower triangular part of A, stored in row order. Thus, if i&lt;j, all elements
of row i precede elements from row j. The order of elements
within the rows is immaterial.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the column
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of n+1 elements containing pointers to
the beginning of each row in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;. Thus
&lsquo;ia[i]&rsquo; indicates the position in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;
where the ith row begins. The last, (n+1)st, element of &lsquo;ia&rsquo;
indicates where the n+1 row would start, if it existed.
</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimension of the matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.matrix.csc</dt><dd><p><code>signature(x = "matrix.ssr")</code>: ... </p>
</dd>
<dt>as.matrix.csr</dt><dd><p><code>signature(x = "matrix.ssr")</code>: ... </p>
</dd>
<dt>as.matrix.ssr</dt><dd><p><code>signature(x = "matrix.ssr")</code>: ... </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "matrix.ssr")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "matrix.ssr")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+matrix.csr-class">matrix.csr-class</a></code></p>

<hr>
<h2 id='mslm-class'>Class &quot;mslm&quot;</h2><span id='topic+mslm-class'></span>

<h3>Description</h3>

<p>A sparse extension of <code>lm</code></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("mslm", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coefficients</code>:</dt><dd><p>Object of class <code>numeric</code> estimated coefficients</p>
</dd>
<dt><code>chol</code>:</dt><dd><p>Object of class <code>matrix.csr.chol</code> generated by 
the function <code>chol</code></p>
</dd>
<dt><code>residuals</code>:</dt><dd><p>Object of class <code>"numeric"</code> residuals</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Object of class <code>"numeric"</code> fitted values</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"lm"</code>, directly.
Class <code>"slm"</code>, directly.
Class <code>"oldClass"</code>, by class &quot;lm&quot;.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "mslm")</code>: ... </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "mslm")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "mslm")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "mslm")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+slm">slm</a></code></p>

<hr>
<h2 id='numeric+20or+20NULL-class'>Class &quot;numeric or NULL&quot;</h2><span id='topic+numeric+20or+20NULL-class'></span>

<h3>Description</h3>

<p>A virtual class needed by the &quot;matrix.csc.hb&quot; class</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;numeric or NULL&quot; in the signature.
</p>

<hr>
<h2 id='slm'>Fit a linear regression model using sparse matrix algebra</h2><span id='topic+slm'></span>

<h3>Description</h3>

<p>This is a function to illustrate the use of sparse linear algebra
to solve a linear least squares problem using Cholesky decomposition.
The syntax and output attempt to emulate <code>lm()</code> but may
fail to do so fully satisfactorily.  Ideally, this would eventually
become a method for <code>lm</code>.  The main obstacle to this step is
that it would be necessary to have a model.matrix function that
returned an object in sparse csr form.  For the present, the objects
represented in the formula must be in dense form.  If the user wishes
to specify fitting with a design matrix that is already in sparse form,
then the lower level function <code>slm.fit()</code> should be used. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slm(formula, data, weights, na.action, method = "csr", contrasts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slm_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response on the left of a <code>~</code> operator,
and the terms, separated by <code>+</code> operators, on the right.  As in
<code>lm()</code>, the response variable in the formula can be matrix valued.
</p>
</td></tr>
<tr><td><code id="slm_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables
named in the formula, or in the subset and the weights argument.
If this is missing, then the variables in the formula should be on the
search list.  This may also be a single number to handle some special
cases &ndash; see below for details.
</p>
</td></tr>
<tr><td><code id="slm_+3A_weights">weights</code></td>
<td>

<p>vector of observation weights; if supplied, the algorithm fits
to minimize the sum of the weights multiplied into the
absolute residuals. The length of weights must be the same as
the number of observations.  The weights must be nonnegative
and it is strongly recommended that they be strictly positive,
since zero weights are ambiguous.
</p>
</td></tr>
<tr><td><code id="slm_+3A_na.action">na.action</code></td>
<td>

<p>a function to filter missing data.
This is applied to the model.frame after any subset argument has been used.
The default (with <code>na.fail</code>) is to create an error if any missing 
values are found.  A possible alternative is <code>na.omit</code>, which
deletes observations that contain one or more missing values.
</p>
</td></tr>
<tr><td><code id="slm_+3A_method">method</code></td>
<td>
<p>there is only one method based on Cholesky factorization</p>
</td></tr>
<tr><td><code id="slm_+3A_contrasts">contrasts</code></td>
<td>

<p>a list giving contrasts for some or all of the factors
default = <code>NULL</code> appearing in the model formula.
The elements of the list should have the same name as the variable
and should be either a contrast matrix (specifically, any full-rank
matrix with as many rows as there are levels in the factor),
or else a function to compute such a matrix given the number of levels.
</p>
</td></tr>
<tr><td><code id="slm_+3A_...">...</code></td>
<td>

<p>additional arguments for the fitting routines
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>slm</code> consisting of:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>estimated coefficients</p>
</td></tr>
<tr><td><code>chol</code></td>
<td>
<p>cholesky object from fitting</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>terms</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>call</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p> Roger Koenker </p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>, <br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>


<h3>See Also</h3>

<p><code>slm.methods</code> for methods <code>summary</code>, <code>print</code>, <code>fitted</code>,
<code>residuals</code> and <code>coef</code> associated with class <code>slm</code>,
and <code>slm.fit</code> for lower level fitting functions.  The latter functions
are of special interest if you would like to pass a sparse form of the
design matrix directly to the fitting process.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lsq)
X &lt;- model.matrix(lsq) #extract the design matrix
y &lt;- model.response(lsq) # extract the rhs
X1 &lt;- as.matrix(X)
slm.time &lt;- system.time(slm(y~X1-1) -&gt; slm.o) # pretty fast
lm.time &lt;- system.time(lm(y~X1-1) -&gt; lm.o) # very slow
cat("slm time =",slm.time,"\n")
cat("slm Results: Reported Coefficients Truncated to 5  ","\n")
sum.slm &lt;- summary(slm.o)
sum.slm$coef &lt;- sum.slm$coef[1:5,]
sum.slm
cat("lm time =",lm.time,"\n")
cat("lm Results: Reported Coefficients Truncated to 5  ","\n")
sum.lm &lt;- summary(lm.o)
sum.lm$coef &lt;- sum.lm$coef[1:5,]
sum.lm
</code></pre>

<hr>
<h2 id='slm-class'>Class &quot;slm&quot;</h2><span id='topic+slm-class'></span>

<h3>Description</h3>

<p>A sparse extension of <code>lm</code></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("slm", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coefficients</code>:</dt><dd><p>Object of class <code>numeric</code> estimated coefficients</p>
</dd>
<dt><code>chol</code>:</dt><dd><p>Object of class <code>matrix.csr.chol</code> generated by
function <code>chol</code></p>
</dd>
<dt><code>residuals</code>:</dt><dd><p>Object of class <code>"numeric"</code> residuals</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Object of class <code>"numeric"</code> fitted values</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"lm"</code>, directly.
Class <code>"oldClass"</code>, by class &quot;lm&quot;.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "slm")</code>: ... </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "slm")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "slm")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "slm")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+slm">slm</a></code></p>

<hr>
<h2 id='slm.fit'>Internal slm fitting functions</h2><span id='topic+slm.fit'></span><span id='topic+slm.fit'></span><span id='topic+slm.wfit'></span><span id='topic+slm.fit.csr'></span>

<h3>Description</h3>

<p>Fitting functions for sparse linear model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slm.fit(x,y,method, ...)
slm.wfit(x,y,weights,...)
slm.fit.csr(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slm.fit_+3A_x">x</code></td>
<td>
<p> design matrix.  </p>
</td></tr>
<tr><td><code id="slm.fit_+3A_y">y</code></td>
<td>
<p> vector of response observations.  </p>
</td></tr>
<tr><td><code id="slm.fit_+3A_method">method</code></td>
<td>
<p> only <code>csr</code> is supported currently </p>
</td></tr>
<tr><td><code id="slm.fit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process. If specified, weighted least squares is used with
weights &lsquo;weights&rsquo; (that is, minimizing </p>
<p style="text-align: center;"><code class="reqn">\sum w_i*e_i^2</code>
</p>

<p>The length of weights must be the same as
the number of observations.  The weights must be nonnegative
and it is strongly recommended that they be strictly positive,
since zero weights are ambiguous.</p>
</td></tr>
<tr><td><code id="slm.fit_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slm.fit</code> and <code>slm.wfit</code> call <code>slm.fit.csr</code> 
to do Cholesky decomposition
and then backsolve to obtain the least squares estimated coefficients.
These functions can be called directly if the user is willing to
specify the design matrix in <code>matrix.csr</code> form.  This is often
advantageous in large problems to reduce memory requirements.
</p>


<h3>Value</h3>

<p>A list of class <code>slm</code> consisting of:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>estimated coefficients</p>
</td></tr>
<tr><td><code>chol</code></td>
<td>
<p>cholesky object from fitting</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>terms</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>call</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p> Roger Koenker </p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a></p>


<h3>See Also</h3>

  <p><code><a href="#topic+slm">slm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lsq)
X &lt;- model.matrix(lsq) #extract the design matrix
y &lt;- model.response(lsq) # extract the rhs
class(X) # -&gt; "matrix.csr"
class(y) # -&gt; NULL
slm.fit(X,y)-&gt;slm.fit.o # this is much more efficient in memory usage than slm()
slm(y~as.matrix(X)-1) -&gt; slm.o # this requires X to be transformed into dense mode
cat("Difference between `slm.fit' and `slm' estimated coefficients =",
	sum(abs(slm.fit.o$coef-slm.o$coef)),"\n")
</code></pre>

<hr>
<h2 id='slm.methods'>Methods for slm objects</h2><span id='topic+slm.methods'></span><span id='topic+summary.slm'></span><span id='topic+summary.mslm'></span><span id='topic+print.summary.slm'></span><span id='topic+print.slm'></span><span id='topic+fitted.slm'></span><span id='topic+residuals.slm'></span><span id='topic+coef.slm'></span><span id='topic+extractAIC.slm'></span><span id='topic+deviance.slm'></span>

<h3>Description</h3>

<p>Summarize, print, and extract objects from  <code><a href="#topic+slm">slm</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
summary(object, correlation, ...)
## S3 method for class 'mslm'
summary(object, ...)
## S3 method for class 'slm'
print(x, digits, ...)
## S3 method for class 'summary.slm'
print(x, digits, symbolic.cor, signif.stars, ...)
## S3 method for class 'slm'
fitted(object, ...)
## S3 method for class 'slm'
residuals(object, ...)
## S3 method for class 'slm'
coef(object, ...)
## S3 method for class 'slm'
extractAIC(fit, scale = 0, k = 2, ...)
## S3 method for class 'slm'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slm.methods_+3A_object">object</code>, <code id="slm.methods_+3A_x">x</code>, <code id="slm.methods_+3A_fit">fit</code></td>
<td>
<p> object of class <code>slm</code>.  </p>
</td></tr>
<tr><td><code id="slm.methods_+3A_digits">digits</code></td>
<td>
<p>minimum number of significant digits to be used for most numbers.</p>
</td></tr>
<tr><td><code id="slm.methods_+3A_scale">scale</code></td>
<td>
<p>optional numeric specifying the scale parameter of the model,
see 'scale' in 'step'.  Currently only used in the '&quot;lm&quot;'
method, where 'scale' specifies the estimate of the error
variance, and 'scale = 0' indicates that it is to be
estimated by maximum likelihood.</p>
</td></tr> 
<tr><td><code id="slm.methods_+3A_k">k</code></td>
<td>
<p> numeric specifying the &quot;weight&quot; of the equivalent degrees of
freedom ('edf') part in the AIC formula.</p>
</td></tr>
<tr><td><code id="slm.methods_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation of coefficients
will be printed. The default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="slm.methods_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical; if <code>TRUE</code>, P-values are additionally encoded
visually as &ldquo;significance stars&rdquo; in order to help scanning
of long coefficient tables.  It defaults to the
&lsquo;show.signif.stars&rsquo; slot of &lsquo;options&rsquo;. </p>
</td></tr>
<tr><td><code id="slm.methods_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of the
estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="slm.methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print.slm</code> and <code>print.summary.slm</code> return invisibly.
<code>fitted.slm</code>, <code>residuals.slm</code>, and <code>coef.slm</code> 
return the corresponding components of the <code>slm</code> object.
<code>extractAIC.slm</code> and <code>deviance.slm</code> return the AIC
and deviance values of the fitted object.
</p>


<h3>Author(s)</h3>

<p> Roger Koenker </p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>


<h3>See Also</h3>

  
<p><code>slm</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lsq)
X &lt;- model.matrix(lsq) #extract the design matrix
y &lt;- model.response(lsq) # extract the rhs
X1 &lt;- as.matrix(X)
slm.time &lt;- system.time(slm(y~X1-1) -&gt; slm.o) # pretty fast
cat("slm time =",slm.time,"\n")
cat("slm Results: Reported Coefficients Truncated to 5  ","\n")
sum.slm &lt;- summary(slm.o)
sum.slm$coef &lt;- sum.slm$coef[1:5,]
sum.slm
fitted(slm.o)[1:10]
residuals(slm.o)[1:10]
coef(slm.o)[1:10]
</code></pre>

<hr>
<h2 id='SparseM.hb'>Harwell-Boeing Format Sparse Matrices</h2><span id='topic+SparseM.hb'></span><span id='topic+read.matrix.hb'></span><span id='topic+model.matrix+2CANY-method'></span><span id='topic+model.matrix+2Cmatrix.csc.hb-method'></span><span id='topic+model.matrix+2Cmatrix.ssc.hb-method'></span><span id='topic+model.matrix.matrix.ssc.hb'></span><span id='topic+model.response+2CANY-method'></span><span id='topic+model.response+2Cmatrix.csc.hb-method'></span><span id='topic+model.response+2Cmatrix.ssc.hb-method'></span><span id='topic+model.guess+2Cmatrix.csc.hb-method'></span><span id='topic+model.guess+2Cmatrix.ssc.hb-method'></span><span id='topic+model.xexact+2Cmatrix.csc.hb-method'></span><span id='topic+model.xexact+2Cmatrix.ssc.hb-method'></span><span id='topic+model.response'></span><span id='topic+model.guess'></span><span id='topic+model.xexact'></span><span id='topic+model.matrix'></span>

<h3>Description</h3>

<p>Read, and extract components of data in Harwell-Boeing sparse matrix format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.matrix.hb(file)
model.matrix(object, ...)
model.response(data,type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM.hb_+3A_file">file</code></td>
<td>
<p>file name to read from or </p>
</td></tr>
<tr><td><code id="SparseM.hb_+3A_data">data</code>, <code id="SparseM.hb_+3A_object">object</code></td>
<td>
<p>an object of either 'matrix.csc.hb' or 'matrix.ssc.hb' class</p>
</td></tr>
<tr><td><code id="SparseM.hb_+3A_type">type</code></td>
<td>
<p>One of &lsquo;&quot;any&quot;&rsquo;, &lsquo;&quot;numeric&quot;&rsquo;, &lsquo;&quot;double&quot;&rsquo;. Using the either of
latter two coerces the result to have storage mode &lsquo;&quot;double&quot;&rsquo;</p>
</td></tr>
<tr><td><code id="SparseM.hb_+3A_...">...</code></td>
<td>
<p>additional arguments to model.matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sparse coefficient matrices in the Harwell-Boeing format are stored in 
80-column records. Each file begins with a multiple line header block 
followed by two, three or four data blocks. The header block contains 
summary information on the storage formats and storage requirements. 
The data blocks contain information of the sparse coefficient matrix and 
data for the right-hand-side of the linear system of equations, 
initial guess of the solution and the exact solutions if they exist.
The function <code>model.matrix</code> extracts the X matrix component.
The function <code>model.response</code> extracts the y vector (or matrix).
The function <code>model.guess</code> extracts the guess vector. 
The function <code>model.xexact</code> extracts the xexact vector. 
This function is written in R replacing a prior implementation based
on iohb.c which had memory fault difficulties.  The function write.matrix.hb
has been purged; users wishing to write matrices in Harwell-Boeing format
are advised to convert SparseM matrices to Matrix classes and use writeHB
from the Matrix package.  Contributions of code to facilitate this conversion
would be appreciated!
</p>


<h3>Value</h3>

<p>The function <code>read.matrix.hb</code> returns a list of class 
<code>matrix.csc.hb</code> or <code>matrix.ssc.hb</code> depending
on how the coefficient matrix is stored in the <code>file</code>.
</p>
<table>
<tr><td><code>ra</code></td>
<td>
<p>ra component of the csc or ssc format of the coefficient matrix, X.</p>
</td></tr>
<tr><td><code>ja</code></td>
<td>
<p>ja component of the csc or ssc format of the coefficient matrix, X.</p>
</td></tr>
<tr><td><code>ia</code></td>
<td>
<p>ia component of the csc or ssc format of the coefficient matrix, X.</p>
</td></tr>
<tr><td><code>rhs.ra</code></td>
<td>
<p>ra component of the right-hand-side, y, if stored in csc or 
ssc format; right-hand-side stored in dense vector or matrix otherwise.</p>
</td></tr>
<tr><td><code>rhs.ja</code></td>
<td>
<p>ja component of the right-hand-side, y, if stored in csc or 
ssc format; a null vector otherwise.</p>
</td></tr>
<tr><td><code>rhs.ia</code></td>
<td>
<p>ia component of the right-hand-side, y, if stored in csc or 
ssc format; a null vector otherwise.</p>
</td></tr>
<tr><td><code>xexact</code></td>
<td>
<p>vector of the exact solutions, b, if they exist; a null vector otherwise.</p>
</td></tr>
<tr><td><code>guess</code></td>
<td>
<p>vector of the initial guess of the solutions if they exist; 
a null vector otherwise.</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>dimenson of the coefficient matrix, X.</p>
</td></tr>
<tr><td><code>rhs.dim</code></td>
<td>
<p>dimenson of the right-hand-side, y.</p>
</td></tr>
<tr><td><code>rhs.mode</code></td>
<td>
<p>storage mode of the right-hand-side; can be full storage or
same format as the coefficient matrix, for the moment the only allowed
mode is &quot;F&quot; for full, or dense mode.</p>
</td></tr>
</table>
<p>The function <code>model.matrix</code> returns the X matrix of class <code>matrix.csr</code>.
The function <code>model.response</code> returns the y vector (or matrix).
The function <code>model.guess</code> returns the guess  vector (or matrix).
The function <code>model.xexact</code> returns the xexact vector (or matrix).
</p>


<h3>Author(s)</h3>

<p>Pin Ng</p>


<h3>References</h3>

 
<p>Duff, I.S., Grimes, R.G. and Lewis, J.G. (1992) 
User's Guide for Harwell-Boeing Sparse Matrix Collection at 
<a href="https://math.nist.gov/MatrixMarket/collections/hb.html">https://math.nist.gov/MatrixMarket/collections/hb.html</a></p>


<h3>See Also</h3>

<p><code>slm</code> for sparse version of <code>lm</code> <br />
<code>SparseM.ops</code> for operators on class <code>matrix.csr</code> <br />
<code>SparseM.solve</code> for linear equation solving for class <code>matrix.csr</code> <br />
<code>SparseM.image</code> for image plotting of class <code>matrix.csr</code> <br />
<code>SparseM.ontology</code> for coercion of class <code>matrix.csr</code> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
Xy &lt;- read.matrix.hb(system.file("extdata","lsq.rra",package = "SparseM"))
class(Xy) # -&gt; [1] "matrix.csc.hb"
X &lt;- model.matrix(Xy)-&gt;X
class(X) # -&gt; "matrix.csr"
dim(X) # -&gt; [1] 1850  712
y &lt;- model.response(Xy) # extract the rhs
length(y) # [1] 1850
Xy &lt;- read.matrix.hb(system.file("extdata","rua_32_ax.rua",package = "SparseM"))
X &lt;- model.matrix(Xy)
y &lt;- model.response(Xy) # extract the rhs
g &lt;- model.guess(Xy) # extract the guess 
a &lt;- model.xexact(Xy) # extract the xexact 
fit &lt;- solve(t(X) %*% X, t(X) %*% y) # compare solution with xexact solution 
</code></pre>

<hr>
<h2 id='SparseM.image'>Image Plot for Sparse Matrices</h2><span id='topic+image'></span><span id='topic+SparseM.image'></span><span id='topic+image+2Cmatrix.csr-method'></span>

<h3>Description</h3>

<p>Display the pattern of non-zero entries of
a matrix of class <code>matrix.csr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix.csr'
image(x, col=c("white","gray"),
      xlab="column", ylab="row", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM.image_+3A_x">x</code></td>
<td>
<p>a matrix of class <code>matrix.csr</code>.</p>
</td></tr>
<tr><td><code id="SparseM.image_+3A_col">col</code></td>
<td>
<p>a list of colors such as that generated by <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>.
Defaults to c(&quot;white&quot;,&quot;gray&quot;)</p>
</td></tr>
<tr><td><code id="SparseM.image_+3A_xlab">xlab</code>, <code id="SparseM.image_+3A_ylab">ylab</code></td>
<td>
<p>each a character string giving the labels for the x and y axis.</p>
</td></tr>
<tr><td><code id="SparseM.image_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pattern of the non-zero entries of a sparse matrix
is displayed.  By default nonzero entries of the matrix appear
as gray blocks and zero entries as white background.</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).
SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>


<h3>See Also</h3>

<p><code>SparseM.ops</code>,
<code>SparseM.solve</code>,
<code>SparseM.ontology</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rnorm(20*5)
A &lt;- matrix(a,20,5)
A[row(A)&gt;col(A)+4|row(A)&lt;col(A)+3] &lt;- 0
b &lt;- rnorm(20*5)
B &lt;- matrix(b,20,5)
B[row(A)&gt;col(A)+2|row(A)&lt;col(A)+2] &lt;- 0
image(as.matrix.csr(A)%*%as.matrix.csr(t(B)))
</code></pre>

<hr>
<h2 id='SparseM.ontology'>Sparse Matrix Class</h2><span id='topic+SparseM.ontology'></span><span id='topic+matrix.csr'></span><span id='topic+matrix.csc'></span><span id='topic+initialize+2CANY-method'></span><span id='topic+initialize+2Cmatrix.csr-method'></span><span id='topic+initialize+2Cmatrix.coo-method'></span><span id='topic+coerce+2Cvector+2Cmatrix.diag.csr-method'></span><span id='topic+coerce+2Cmatrix+2Cmatrix.csr-method'></span><span id='topic+coerce+2Cmatrix.csr+2Cmatrix.diag.csr-method'></span><span id='topic+coerce+2Cvector+2Cmatrix.csr-method'></span><span id='topic+coerce+2Cnumeric+2Cmatrix.diag.csr-method'></span><span id='topic+as.matrix+2CANY-method'></span><span id='topic+as.matrix+2Cmatrix.csr-method'></span><span id='topic+as.matrix+2Ccsr-method'></span><span id='topic+is.matrix+2Ccsr-methods'></span><span id='topic+as.matrix+2Ccsc-methods'></span><span id='topic+is.matrix+2Ccsc-methods'></span><span id='topic+as.matrix+2Cssr-methods'></span><span id='topic+is.matrix+2Cssr-methods'></span><span id='topic+as.matrix+2Cssc-methods'></span><span id='topic+is.matrix+2Cssc-methods'></span><span id='topic+as.matrix+2Ccoo-methods'></span><span id='topic+is.matrix+2Ccoo-methods'></span><span id='topic+as.matrix.csr+2CANY-method'></span><span id='topic+as.matrix.csr+2Cmatrix.csc-method'></span><span id='topic+as.matrix.csr+2Cmatrix.ssr-method'></span><span id='topic+as.matrix.csr+2Cmatrix.ssc-method'></span><span id='topic+as.matrix.csr+2Cmatrix.coo-method'></span><span id='topic+as.matrix.csr+2Cmatrix.csr.chol-method'></span><span id='topic+as.matrix.csc+2CANY-method'></span><span id='topic+as.matrix.csc+2Cmatrix.csr-method'></span><span id='topic+as.matrix.csc+2Cmatrix.csc-method'></span><span id='topic+as.matrix.csc+2Cmatrix.ssr-method'></span><span id='topic+as.matrix.csc+2Cmatrix.ssc-method'></span><span id='topic+as.matrix.csc+2Cmatrix.coo-method'></span><span id='topic+as.matrix.ssr+2CANY-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.csc-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.ssr-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.ssc-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.coo-method'></span><span id='topic+as.matrix.ssc+2CANY-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.csr-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.csc-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.ssr-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.ssc-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.coo-method'></span><span id='topic+as.matrix.coo+2CANY-method'></span><span id='topic+as.matrix.coo+2Cmatrix.csr-method'></span><span id='topic+as.matrix.coo+2Cmatrix.csc-method'></span><span id='topic+as.matrix.coo+2Cmatrix.ssr-method'></span><span id='topic+as.matrix.coo+2Cmatrix.ssc-method'></span><span id='topic+as.matrix.coo+2Cmatrix.coo-method'></span><span id='topic+as.matrix+2Cmatrix.csc-method'></span><span id='topic+as.matrix+2Cmatrix.ssc-method'></span><span id='topic+as.matrix+2Cmatrix.ssr-method'></span><span id='topic+as.matrix+2Cmatrix.coo-method'></span><span id='topic+matrix.ssc'></span><span id='topic+as.matrix.ssc+2Cmatrix.csc-method'></span><span id='topic+as.matrix.ssc.matrix.csr-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.ssr-method'></span><span id='topic+matrix.ssr'></span><span id='topic+as.matrix.ssr+2Cmatrix.csc-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.csr-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.ssc-method'></span><span id='topic+is.matrix.csr'></span><span id='topic+is.matrix.csc'></span><span id='topic+is.matrix.ssr'></span><span id='topic+is.matrix.ssc'></span><span id='topic+is.matrix.coo'></span><span id='topic+is.matrix.csr'></span><span id='topic+as.matrix.csr'></span><span id='topic+as.matrix.csc'></span><span id='topic+as.matrix.ssr'></span><span id='topic+as.matrix.ssc'></span><span id='topic+as.matrix.coo'></span>

<h3>Description</h3>

<p>This group of functions evaluates and coerces changes in class structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix.csr'
as(x, nrow = 1, ncol = 1, eps = .Machine$double.eps, ...)
## S3 method for class 'matrix.csc'
as(x, nrow = 1, ncol = 1, eps = .Machine$double.eps, ...)
## S3 method for class 'matrix.ssr'
as(x, nrow = 1, ncol = 1, eps = .Machine$double.eps, ...)
## S3 method for class 'matrix.ssc'
as(x, nrow = 1, ncol = 1, eps = .Machine$double.eps, ...)
## S3 method for class 'matrix.csr'
is(x, ...)
## S3 method for class 'matrix.csc'
is(x, ...)
## S3 method for class 'matrix.ssr'
is(x, ...)
## S3 method for class 'matrix.ssc'
is(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM.ontology_+3A_x">x</code></td>
<td>
<p>is a matrix, or vector object,  of either dense or sparse form</p>
</td></tr>
<tr><td><code id="SparseM.ontology_+3A_nrow">nrow</code></td>
<td>
<p>number of rows of matrix </p>
</td></tr>
<tr><td><code id="SparseM.ontology_+3A_ncol">ncol</code></td>
<td>
<p>number of columns of matrix </p>
</td></tr>
<tr><td><code id="SparseM.ontology_+3A_eps">eps</code></td>
<td>
<p>A tolerance parameter:  elements of x such that abs(x) &lt; eps set to zero.
This argument is only relevant when coercing matrices from dense to sparse form. Defaults to
<code>eps = .Machine$double.eps</code> </p>
</td></tr>
<tr><td><code id="SparseM.ontology_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>matrix.csc</code> acts like <code>matrix</code> to coerce a vector object to
a sparse matrix object of class <code>matrix.csr</code>.  
This aspect of the code is in the process of conversion from S3 to S4 classes.
For the most part the S3 syntax prevails.  An exception is the code to
coerce vectors to diagonal matrix form which uses <code>as(v,"matrix.diag.csr"</code>.
The generic functions <code>as.matrix.xxx</code> coerce a matrix <code>x</code> into 
a matrix of storage class <code>matrix.xxx</code>. The argument matrix <code>x</code>
may be of conventional dense form, or of any of the four supported 
classes:  <code>matrix.csr, matrix.csc, matrix.ssr, matrix.ssc</code>.  
The generic functions <code>is.matrix.xxx</code> evaluate whether the  
argument is of class <code>matrix.xxx</code>.  The function
<code>as.matrix</code> transforms a matrix of any sparse class into conventional
dense form.  The primary storage class for sparse matrices is the
compressed sparse row <code>matrix.csr</code> class.
An <em>n</em> by <em>m</em> matrix <em>A</em> with real elements <code class="reqn">a_{ij}</code>, 
stored in <code>matrix.csr</code> format consists of three arrays:
</p>

<ul>
<li> <p><code>ra</code>: a real array of <em>nnz</em> elements containing the non-zero
elements of <em>A</em>, stored in row order. Thus, if <em>i&lt;j</em>, all elements of row <em>i</em>
precede elements from row <em>j</em>. The order of elements within the rows is immaterial.
</p>
</li>
<li> <p><code>ja</code>: an integer array of <em>nnz</em> elements containing the column
indices of the elements stored in <code>ra</code>.
</p>
</li>
<li> <p><code>ia</code>: an integer array of <em>n+1</em> elements containing pointers to
the beginning of each row in the arrays <code>ra</code> and <code>ja</code>. Thus
<code>ia[i]</code> indicates the position in the arrays <code>ra</code> and
<code>ja</code> where the <em>i</em>th row begins. The last, <em>(n+1)</em>st, element of
<code>ia</code> indicates where the <em>n+1</em> row would start, if it existed.
</p>
</li></ul>

<p>The compressed sparse column class  <code>matrix.csc</code> is defined in
an analogous way, as are  the <code>matrix.ssr</code>, symmetric sparse row, and
<code>matrix.ssc</code>, symmetric sparse column classes.
</p>


<h3>Note</h3>

<p><code>as.matrix.ssr</code> and <code>as.matrix.ssc</code> should ONLY be used with 
symmetric matrices.
</p>
<p><code>as.matrix.csr(x)</code>, when <code>x</code> is an object of class <code>matrix.csr.chol</code>
(that is, an object returned by a call to <code>chol(a)</code> when <code>a</code> 
is an object of class <code>matrix.csr</code> or <code>matric.csc</code>),
by default returns an upper triangular matrix, which
is <em>not</em> consistent with the result of <code>chol</code> in the <span class="pkg">base</span>
package.  To get an lower triangular <code>matric.csr</code> matrix, use either
<code>as.matrix.csr(x, upper.tri = FALSE)</code> or
<code>t(as.matrix.csr(x))</code>.
</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>


<h3>See Also</h3>

<p><code>SparseM.hb</code> for handling Harwell-Boeing sparse matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 10
p &lt;- 5
a &lt;- rnorm(n1*p)
a[abs(a)&lt;0.5] &lt;- 0
A &lt;- matrix(a,n1,p)
B &lt;- t(A)%*%A
A.csr &lt;- as.matrix.csr(A)
A.csc &lt;- as.matrix.csc(A)
B.ssr &lt;- as.matrix.ssr(B)
B.ssc &lt;- as.matrix.ssc(B)
is.matrix.csr(A.csr) # -&gt; TRUE
is.matrix.csc(A.csc) # -&gt; TRUE
is.matrix.ssr(B.ssr) # -&gt; TRUE
is.matrix.ssc(B.ssc) # -&gt; TRUE
as.matrix(A.csr)
as.matrix(A.csc)
as.matrix(B.ssr)
as.matrix(B.ssc)
as.matrix.csr(rep(0,9),3,3) #sparse matrix of all zeros
as(4,"matrix.diag.csr") #identity matrix of dimension 4
</code></pre>

<hr>
<h2 id='SparseM.ops'>Basic Linear Algebra for Sparse Matrices</h2><span id='topic+Ops.matrix.csr'></span><span id='topic+Ops.matrix.diag.csr'></span><span id='topic++25+2A+25-methods'></span><span id='topic++25+2A+25+2CANY+2CANY-method'></span><span id='topic++25+2A+25+2Cmatrix.csr+2Cmatrix.csr-method'></span><span id='topic++25+2A+25+2Cmatrix.csr+2Cmatrix-method'></span><span id='topic++25+2A+25+2Cmatrix.csr+2Cnumeric-method'></span><span id='topic++25+2A+25+2Cmatrix+2Cmatrix.csr-method'></span><span id='topic++25+2A+25+2Cnumeric+2Cmatrix.csr-method'></span><span id='topic+kronecker-methods'></span><span id='topic+kronecker+2Cmatrix.csr+2Cmatrix.csr-method'></span><span id='topic+kronecker+2Cmatrix.csr+2Cmatrix-method'></span><span id='topic+kronecker+2Cmatrix.csr+2Cnumeric-method'></span><span id='topic+kronecker+2Cmatrix+2Cmatrix.csr-method'></span><span id='topic+kronecker+2Cnumeric+2Cmatrix.csr-method'></span><span id='topic++2B+2Cmatrix.csr-method'></span><span id='topic+-+2Cmatrix.csr-method'></span><span id='topic++2A+2Cmatrix.csr-method'></span><span id='topic++2F+2Cmatrix.csr-method'></span><span id='topic++5E+2Cmatrix.csr-method'></span><span id='topic++25+25+2Cmatrix.csr-method'></span><span id='topic++25+2F+25+2Cmatrix.csr-method'></span><span id='topic++3E+2Cmatrix.csr-method'></span><span id='topic++3E+3D+2Cmatrix.csr-method'></span><span id='topic++3C+2Cmatrix.csr-method'></span><span id='topic++3C+3D+2Cmatrix.csr-method'></span><span id='topic++3D+3D+2Cmatrix.csr-method'></span><span id='topic++21+3D+2Cmatrix.csr-method'></span><span id='topic++26+2Cmatrix.csr-method'></span><span id='topic++7C+2Cmatrix.csr-method'></span><span id='topic+norm'></span><span id='topic+norm+2CANY-method'></span><span id='topic+norm+2Cmatrix.csr-method'></span><span id='topic+norm+2Cmatrix.csr+2Ccharacter-method'></span><span id='topic+norm+2Cmatrix.csr+2Cmissing-method'></span><span id='topic+det+2CANY-method'></span><span id='topic+det+2Cmatrix-method'></span><span id='topic+det+2Cmatrix.csr-method'></span><span id='topic+det+2Cmatrix.csr.chol-method'></span><span id='topic+determinant+2Cmatrix.csr.chol+2Cmissing-method'></span><span id='topic+determinant+2Cmatrix.csr.chol+2Clogical-method'></span><span id='topic+determinant+2Cmatrix.csr+2Cmissing-method'></span><span id='topic+determinant+2Cmatrix.csr+2Clogical-method'></span><span id='topic+t+2CANY-method'></span><span id='topic+t+2Cmatrix.csr-method'></span><span id='topic+t+2Cmatrix.csc-method'></span><span id='topic+t+2Cmatrix.coo-method'></span><span id='topic+diag+2CANY-method'></span><span id='topic+diag+2Cmatrix.csr-method'></span><span id='topic+diag+3C-+2CANY-method'></span><span id='topic+diag+3C-+2Cmatrix.csr-method'></span><span id='topic+diag+3C-+2Cmatrix.diag.csr-method'></span><span id='topic+diff+2Cmatrix.csr-method'></span><span id='topic+diff+3C-+2CANY-method'></span><span id='topic+diff+3C-+2Cmatrix.csr-method'></span><span id='topic+diag.assign+2Cmatrix.csr-method'></span><span id='topic+ncol+2Cmatrix.csr-method'></span><span id='topic+nrow+2Cmatrix.csr-method'></span><span id='topic+dim+2CANY-method'></span><span id='topic+dim+2Cmatrix.csr-method'></span><span id='topic+dim+2Cmatrix.csc-method'></span><span id='topic+dim+2Cmatrix.ssr-method'></span><span id='topic+dim+2Cmatrix.ssc-method'></span><span id='topic+dim+2Cmatrix.coo-method'></span><span id='topic+rbind.matrix.csr'></span><span id='topic+cbind.matrix.csr'></span><span id='topic++5B.matrix.csr'></span><span id='topic++5B.matrix.diag.csr'></span><span id='topic++5B+3C-.matrix.csr'></span><span id='topic++5B+3C-.matrix.diag.csr'></span><span id='topic++5B.matrix.coo'></span><span id='topic++5B+3C-.matrix.coo'></span>

<h3>Description</h3>

<p>Basic linear algebra operations for sparse matrices
of class <code>matrix.csr</code>.</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM.ops_+3A_x">x</code></td>
<td>
<p>matrix of class <code>matrix.csr</code>.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_y">y</code></td>
<td>
<p>matrix of class <code>matrix.csr</code> or a dense matrix or vector.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_value">value</code></td>
<td>
<p>replacement values.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_i">i</code>, <code id="SparseM.ops_+3A_j">j</code></td>
<td>
<p>vectors of elements to extract or replace.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_nrow">nrow</code></td>
<td>
<p>optional number of rows for the result.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_lag">lag</code></td>
<td>
<p>an integer indicating which lag to use.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_differences">differences</code></td>
<td>
<p>an integer indicating the order of the difference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linear algebra operations for matrices of class
<code>matrix.csr</code> are designed to behave exactly as for
regular matrices.  In particular, matrix multiplication, kronecker
product, addition,
subtraction and various logical operations should work as with the conventional
dense form of matrix storage, as does indexing, rbind, cbind, and diagonal
assignment and extraction.  The method diag may be used to extract the
diagonal of a <code>matrix.csr</code> object, to create a sparse diagonal see
<code>SparseM.ontology</code>.
</p>
<p>The function <code><a href="base.html#topic+determinant">determinant</a></code> computes the (log) determinant,
of the argument, returning a <code>"det"</code> object as the base function.
This is <em>preferred</em> over using the function <code>det()</code>
which is a simple wrapper for <code>determinant()</code>.
Using <code>det()</code> in the following way is somewhat deprecated:
<br />
<code>det()</code> computes the determinant of the argument
matrix.  If the matrix is of class <code>matrix.csr</code> then it must
be symmetric, or an error will be returned.  If the matrix is of
class <code>matrix.csr.chol</code> then the determinant of the Cholesky
factor is returned, ie the product of the diagonal elements.


</p>
<p>The function <code>norm</code> is used to check for symmetry by
computing the maximum of the elements of the difference between
the matrix and its transpose.  Optionally, this sup norm can
be replaced by the Hilbert-Schmidt norm, or the l1 norm.
</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).
SparseM: A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>


<h3>See Also</h3>

<p><code>slm</code> for sparse linear model fitting.
<code>SparseM.ontology</code> for coercion and other class relations involving the
sparse matrix classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 10
n2 &lt;- 10
p &lt;- 6
y &lt;- rnorm(n1)
a &lt;- rnorm(n1*p)
a[abs(a) &lt; 0.5] &lt;- 0
A &lt;- matrix(a,n1,p)
A.csr &lt;- as.matrix.csr(A)
b &lt;- rnorm(n2*p)
b[abs(b)&lt;1.0] &lt;- 0
B &lt;- matrix(b,n2,p)
B.csr &lt;- as.matrix.csr(B)

# matrix transposition and multiplication
A.csr%*%t(B.csr)

# kronecker product - via kronecker() methods:
A.csr %x% matrix(1:4,2,2)
</code></pre>

<hr>
<h2 id='SparseM.solve'>Linear Equation Solving for Sparse Matrices</h2><span id='topic+SparseM.solve'></span><span id='topic+chol+2CANY-method'></span><span id='topic+chol+2Cmatrix.csr-method'></span><span id='topic+chol+2Cmatrix.csc-method'></span><span id='topic+chol+2Cmatrix-method'></span><span id='topic+chol'></span><span id='topic+backsolve-methods'></span><span id='topic+backsolve+2CANY-method'></span><span id='topic+backsolve'></span><span id='topic+forwardsolve'></span><span id='topic+solve'></span><span id='topic+backsolve+2Cmatrix.csr.chol-method'></span><span id='topic+forwardsolve+2Cmatrix.csr.chol-method'></span><span id='topic+solve+2CANY-method'></span><span id='topic+solve+2Cmatrix.csr-method'></span>

<h3>Description</h3>

<p><code>chol</code> performs a Cholesky
decomposition of a symmetric positive definite sparse matrix <code>x</code>
of class <code>matrix.csr</code>. <br />
<code>backsolve</code> performs a triangular back-fitting to compute
the solutions of a system of linear equations in one step. <br />
<code>backsolve</code> and <code>forwardsolve</code> can also split the functionality of
<code>backsolve</code> into two steps. <br />
<code>solve</code> combines <code>chol</code> and <code>backsolve</code> and will
compute the inverse of a matrix if the right-hand-side is missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chol(x, ...)
## S4 method for signature 'matrix.csr.chol'
backsolve(r, x, k = NULL, upper.tri = NULL,
          transpose = NULL, twice = TRUE, ...)
forwardsolve(l, x, k = ncol(l), upper.tri = FALSE, transpose = FALSE)
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM.solve_+3A_a">a</code></td>
<td>
<p>symmetric positive definite matrix of class <code>matrix.csr</code>.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_r">r</code></td>
<td>
<p>object of class <code>matrix.csr.chol</code> returned by the function <code>chol</code>.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_l">l</code></td>
<td>
<p>object of class <code>matrix.csr.chol</code> returned by the function <code>chol</code>.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_x">x</code>, <code id="SparseM.solve_+3A_b">b</code></td>
<td>
<p>vector(regular matrix) of right-hand-side(s) of a system of linear equations.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_k">k</code></td>
<td>
<p>inherited from the generic; not used here.</p>
</td></tr>

<tr><td><code id="SparseM.solve_+3A_upper.tri">upper.tri</code></td>
<td>
<p>inherited from the generic; not used here.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_transpose">transpose</code></td>
<td>
<p>inherited from the generic; not used here.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_twice">twice</code></td>
<td>
<p>Logical flag:  If true backsolve solves twice, see below.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chol</code> performs a Cholesky decomposition of
a symmetric positive definite sparse matrix <code>a</code> of class
<code>matrix.csr</code> using the block sparse Cholesky algorithm of Ng and
Peyton (1993).  The structure of the resulting <code>matrix.csr.chol</code>
object is relatively complicated.  If necessary it can be coerced back
to a <code>matrix.csr</code> object as usual with <code>as.matrix.csr</code>.
<code>backsolve</code> does triangular back-fitting to compute
the solutions of a system of linear equations.  For systems of linear equations
that only vary on the right-hand-side, the result from <code>chol</code>
can be reused.  Contrary to the behavior of <code>backsolve</code> in base R,
the default behavior of  <code>backsolve(C,b)</code> when C is a <code>matrix.csr.chol</code> object
is to produce a solution to the system <code class="reqn">Ax = b</code> where <code>C &lt;- chol(A)</code>, see
the example section.  When the flag <code>twice</code> is <code>FALSE</code> then backsolve
solves the system <code class="reqn">Cx = b</code>, up to a permutation  &ndash; see the comments below.
The command <code>solve</code> combines <code>chol</code> and <code>backsolve</code>, and will
compute the inverse of a matrix if the right-hand-side is missing.
The determinant of the Cholesky factor is returned providing a
means to efficiently compute the determinant of sparse positive
definite symmetric matrices.
</p>
<p>There are several integer storage parameters that are set by default in the call
to the Cholesky factorization, these can be overridden in any of the above
functions and will be passed by the usual &quot;dots&quot; mechanism.  The necessity
to do this is usually apparent from error messages like:  Error  
in local(X...) increase tmpmax.   For example, one can use,
<code>solve(A,b, tmpmax = 100*nrow(A))</code>.  The current default for tmpmax
is <code>50*nrow(A)</code>. Some experimentation may be needed to
select appropriate values, since they are highly problem dependent.  See
the code of chol() for further details on the current defaults.
</p>


<h3>Note</h3>

<p>Because the sparse Cholesky algorithm re-orders the positive
definite sparse matrix <code>A</code>, the value of
<code>x &lt;- backsolve(C, b)</code> does <em>not</em> equal the solution to the
triangular system <code class="reqn">Cx = b</code>, but is instead the solution to the
system <code class="reqn">CPx = Pb</code> for some permutation matrix <code class="reqn">P</code>
(and analogously for <code>x &lt;- forwardsolve(C, b)</code>).  However, a
little algebra easily shows that
<code>backsolve(C, forwardsolve(C, b), twice = FALSE)</code> <em>is</em> the solution
to the equation <code class="reqn">Ax=b</code>.  Finally, if <code>C &lt;- chol(A)</code>  for some
sparse covariance matrix <code>A</code>, and z is a conformable standard normal vector,
then the product  <code>y &lt;- as.matrix.csr(C) %*% z</code> is normal with covariance
matrix <code>A</code> irrespective of the permutation of the Cholesky factor.
</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>
<p>Ng, E. G. and B. W. Peyton (1993), &quot;Block sparse Cholesky algorithms
on advanced uniprocessor computers&quot;, <em>SIAM J. Sci. Comput.</em>, <b>14</b>,
pp. 1034-1056.
</p>


<h3>See Also</h3>

<p><code>slm</code> for sparse version of <code>lm</code> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lsq)
class(lsq) # -&gt; [1] "matrix.csc.hb"
model.matrix(lsq)-&gt;design.o
class(design.o) # -&gt; "matrix.csr"
dim(design.o) # -&gt; [1] 1850  712
y &lt;- model.response(lsq) # extract the rhs
length(y) # [1] 1850

t(design.o) %*% design.o -&gt; XpX
t(design.o) %*% y -&gt; Xpy
chol(XpX) -&gt; chol.o

b1 &lt;- backsolve(chol.o,Xpy) # least squares solutions in two steps
b2 &lt;- solve(XpX,Xpy)        # least squares estimates in one step
b3 &lt;- backsolve(chol.o, forwardsolve(chol.o, Xpy),
                twice = FALSE) # in three steps
## checking that these three are indeed equal :
stopifnot(all.equal(b1, b2), all.equal(b2, b3))
</code></pre>

<hr>
<h2 id='summary.mslm-class'>Class &quot;summary.mslm&quot; </h2><span id='topic+summary.mslm-class'></span>

<h3>Description</h3>

<p>Sparse version of <code>summary.lm</code></p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "summary.mslm")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='summary.slm-class'>Class &quot;summary.slm&quot; </h2><span id='topic+summary.slm-class'></span>

<h3>Description</h3>

<p>Sparse version of <code>summary.lm</code></p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "summary.slm")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='triogramX'>A Design Matrix for a Triogram Problem</h2><span id='topic+triogramX'></span><span id='topic+X'></span>

<h3>Description</h3>

<p>This is a design matrix arising from a bivariate smoothing
problem using penalized triogram fitting.  It is used in the SparseM vignette
to illustrate the use of the sparse matrix image function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(triogramX)</code></pre>


<h3>Format</h3>

<p>A 375 by 100 matrix stored in compressed sparse row format</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
