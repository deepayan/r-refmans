<!DOCTYPE html><html><head><title>Help for package SparseM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SparseM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#character+20or+20NULL-class'><p>Class &quot;character or NULL&quot;</p></a></li>
<li><a href='#lsq'><p>Least Squares Problems in Surveying</p></a></li>
<li><a href='#matrix.coo-class'><p>Class &quot;matrix.coo&quot; &ndash; Sparse Matrices in [Coo]rdinate Format</p></a></li>
<li><a href='#matrix.csc-class'><p>Class &quot;matrix.csc&quot; - Sparse Matrices in [C]ompressed [S]parse [C]olumn Format</p></a></li>
<li><a href='#matrix.csc.hb-class'><p>Class &quot;matrix.csc.hb&quot; - Column Compressed Sparse Matrices stored in Harwell-Boeing Format</p></a></li>
<li><a href='#matrix.csr-class'><p>Class &quot;matrix.csr&quot; - Sparse Matrices in Compressed Sparse Row Format</p></a></li>
<li><a href='#matrix.csr.chol-class'><p>Class &quot;matrix.csr.chol&quot; (Block Sparse Cholesky Decomposition)</p></a></li>
<li><a href='#matrix.ssc-class'><p>Class &quot;matrix.ssc&quot; - Sparse Matrices in [S]ymmetric [S]parse [C]olumn Format</p></a></li>
<li><a href='#matrix.ssc.hb-class'><p>Class &quot;matrix.ssc.hb&quot;</p></a></li>
<li><a href='#matrix.ssr-class'><p>Class &quot;matrix.ssr&quot; - Sparse Matrices in [S]ymmetric [S]parse [R]ow Format</p></a></li>
<li><a href='#mslm-class'><p>Class &quot;mslm&quot;</p></a></li>
<li><a href='#numeric+20or+20NULL-class'><p>Class &quot;numeric or NULL&quot;</p></a></li>
<li><a href='#slm'><p>Fit a linear regression model using sparse matrix algebra</p></a></li>
<li><a href='#slm-class'><p>Class &quot;slm&quot;</p></a></li>
<li><a href='#slm.fit'><p>Internal slm fitting functions</p></a></li>
<li><a href='#slm.methods'><p>Methods for slm objects</p></a></li>
<li><a href='#SparseM.hb'><p>Harwell-Boeing Format Sparse Matrices</p></a></li>
<li><a href='#SparseM.image'><p>Image Plot for Sparse Matrices</p></a></li>
<li><a href='#SparseM.ontology'><p>Sparse Matrix Class Ontology</p></a></li>
<li><a href='#SparseM.ops'><p>Basic Linear Algebra for Sparse Matrices</p></a></li>
<li><a href='#SparseM.solve'><p>Linear Equation Solving via Cholesky Decomposition for Sparse Matrices</p></a></li>
<li><a href='#summary.mslm-class'><p>Class &quot;summary.mslm&quot;</p></a></li>
<li><a href='#summary.slm-class'><p>Class &quot;summary.slm&quot;</p></a></li>
<li><a href='#triogramX'><p>A Design Matrix for a Triogram Problem</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.84</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roger Koenker &lt;rkoenker@uiuc.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Some basic linear algebra functionality for sparse matrices is
  provided:  including Cholesky decomposition and backsolving as well as
  standard R subsetting and Kronecker products.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Linear Algebra</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.econ.uiuc.edu/~roger/research/sparse/sparse.html">http://www.econ.uiuc.edu/~roger/research/sparse/sparse.html</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-15 19:23:09 UTC; maechler</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger Koenker [cre, aut],
  Pin Tian Ng [ctb] (Contributions to Sparse QR code),
  Yousef Saad [ctb] (author of sparskit2),
  Ben Shaby [ctb] (author of chol2csr),
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (chol() tweaks; S4)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-25 12:00:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='character+20or+20NULL-class'>Class &quot;character or NULL&quot;</h2><span id='topic+character+20or+20NULL-class'></span>

<h3>Description</h3>

<p>A virtual class needed by the &quot;matrix.csc.hb&quot; class</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;character or NULL&quot; in the signature.
</p>

<hr>
<h2 id='lsq'>Least Squares Problems in Surveying</h2><span id='topic+lsq'></span>

<h3>Description</h3>

<p>One of the four matrices from the least-squares solution of 
problems in surveying that were used by Michael Saunders and Chris Paige 
in the testing of LSQR</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lsq)</code></pre>


<h3>Format</h3>

<p>A list of class <code>matrix.csc.hb</code> or <code>matrix.ssc.hb</code> depending
on how the coefficient matrix is stored with the following components:
</p>
  
<dl>
<dt>ra </dt><dd><p>ra component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>   
<dt>ja </dt><dd><p>ja component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>   
<dt>ia </dt><dd><p>ia component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>   
<dt>rhs.ra </dt><dd><p>ra component of the right-hand-side, y, if stored in csc 
or ssc format; right-hand-side stored in dense vector or matrix otherwise.</p>
</dd>
<dt>rhs.ja </dt><dd><p>ja component of the right-hand-side, y, if stored in csc or 
ssc format; a null vector otherwise.</p>
</dd>
<dt>rhs.ia </dt><dd><p>ia component of the right-hand-side, y, if stored in csc or
ssc format; a null vector otherwise.</p>
</dd>
<dt>xexact</dt><dd><p>vector of the exact solutions, b, if they exist; a null vector o therwise.</p>
</dd>  
<dt>guess</dt><dd><p>vector of the initial guess of the solutions if they exist;
a null vector otherwise.</p>
</dd>
<dt>dim</dt><dd><p>dimenson of the coefficient matrix, X.</p>
</dd>
<dt>rhs.dim</dt><dd><p>dimenson of the right-hand-side, y.</p>
</dd>
<dt>rhs.mode</dt><dd><p>storage mode of the right-hand-side; can be full storage or
same format as the coefficient matrix.</p>
</dd>
</dl>



<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>
<p>Matrix Market, <a href="https://math.nist.gov/MatrixMarket/data/Harwell-Boeing/lsq/lsq.html">https://math.nist.gov/MatrixMarket/data/Harwell-Boeing/lsq/lsq.html</a>
</p>


<h3>See Also</h3>

<p><code>read.matrix.hb</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lsq)
class(lsq) # -&gt; [1] "matrix.csc.hb"
model.matrix(lsq)-&gt;X
class(X) # -&gt; "matrix.csr"
dim(X) # -&gt; [1] 1850  712
y &lt;- model.response(lsq) # extract the rhs
length(y) # [1] 1850 
</code></pre>

<hr>
<h2 id='matrix.coo-class'>Class &quot;matrix.coo&quot; &ndash; Sparse Matrices in [Coo]rdinate Format</h2><span id='topic+matrix.coo-class'></span>

<h3>Description</h3>

<p>Class for sparse matrices stored in coordinate aka
&ldquo;triplet&rdquo; format, storing for each non-zero entry <code>x[i,j]</code>
the triplet <code>(i,j, x[i,j])</code>, in slots <code>(ia, ja, ra)</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.coo", ...)</code>,
but typically rather by <code><a href="#topic+as.matrix.coo">as.matrix.coo</a>()</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, a real array of nnz elements containing the non-zero
elements of A.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the column
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the row
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimension of the matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.matrix.coo</dt><dd><p><code>signature(x = "matrix.coo")</code>: ... </p>
</dd>
<dt>as.matrix.csr</dt><dd><p><code>signature(x = "matrix.coo")</code>: ... </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "matrix.coo")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "matrix.coo")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+matrix.csr-class">matrix.csr-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> try(  new("matrix.coo") ) # fails currently {FIXME!}     # the 1x1 matrix [0]

 ## correponds to base  matrix()
 mcoo &lt;- new("matrix.coo", ra=NA_real_, ia = 1L, ja = 1L, dimension = c(1L, 1L))
 mcoo # currently *does* print but wrongly:  as.matrix.csr(&lt;matrix.coo&gt;) fails to keep NA !!
 co2 &lt;- new("matrix.coo", ra = c(-Inf, -2, 3, Inf),
            ia = c(1L,1:3), ja = 2L*(1:4), dimension = c(7L, 12L))
 co2 # works fine (as has no NA)

 ## Sparse Diagonal (from "numeric"):
 as(1:5, "matrix.diag.csr") # a sparse version of  diag(1:5)
</code></pre>

<hr>
<h2 id='matrix.csc-class'>Class &quot;matrix.csc&quot; - Sparse Matrices in [C]ompressed [S]parse [C]olumn Format</h2><span id='topic+matrix.csc-class'></span>

<h3>Description</h3>

<p>A class for sparse matrices stored in compressed sparse column ('csc')
format.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.csc", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, a real array of nnz elements containing the non-zero
elements of A, stored in column order. Thus, if i&lt;j, all elements
of column i precede elements from column j. The order of elements
within the column is immaterial.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the row
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of n+1 elements containing pointers to
the beginning of each column in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;. Thus
&lsquo;ia[i]&rsquo; indicates the position in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;
where the ith column begins. The last, (n+1)st, element of &lsquo;ia&rsquo;
indicates where the n+1 column would start, if it existed.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimension of the matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.matrix.csr</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>as.matrix.ssc</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>as.matrix.ssr</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>chol</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "matrix.csc")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+matrix.csr-class">matrix.csr-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  cscM &lt;- as.matrix.csc(as(diag(4:1), "matrix.csr"))
  cscM
  str(cscM)
  stopifnot(identical(dim(cscM), c(4L, 4L)))
</code></pre>

<hr>
<h2 id='matrix.csc.hb-class'>Class &quot;matrix.csc.hb&quot; - Column Compressed Sparse Matrices stored in Harwell-Boeing Format</h2><span id='topic+matrix.csc.hb-class'></span><span id='topic+show+2Cmatrix.csc.hb-method'></span><span id='topic+show+2Cmatrix.ssc.hb-method'></span>

<h3>Description</h3>

<p>A class consisting of the coefficient matrix and the right-hand-side of a
linear system of equations, initial guess of the solution and the exact
solutions if they exist stored in external files using the
Harwell-Boeing format.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.csc.hb", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, ra component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, ja component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>numeric</code>, ia component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>
<dt><code>rhs.ra</code>:</dt><dd><p>Object of class <code>numeric</code>, ra component of the right-hand-side, y, if stored in csc or
ssc format; right-hand-side stored in dense vector or matrix otherwise.</p>
</dd>
<dt><code>guess</code>:</dt><dd><p>Object of class <code>numeric</code> or <code>NULL</code> vector of the initial guess of the solutions if they exist;
a null vector otherwise.</p>
</dd>
<dt><code>xexact</code>:</dt><dd><p>Object of class <code>numeric or NULL</code> vector of the exact solutions, b, if they exist; a null vector otherwise.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimenson of the coefficient matrix, X.</p>
</dd>
<dt><code>rhs.dim</code>:</dt><dd><p>Object of class <code>integer</code>, dimenson of the right-hand-side, y.</p>
</dd>
<dt><code>rhs.mode</code>:</dt><dd><p>Object of class <code>character or NULL</code> storage mode of the right-hand-side; can be full storage or
same format as the coefficient matrix.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>model.matrix</dt><dd><p><code>signature(object = "matrix.csc.hb")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "matrix.csc.hb")</code>:
<code><a href="methods.html#topic+show">show</a>()</code> the object, notably also when auto-printing.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+model.matrix">model.matrix</a></code>, <code><a href="#topic+model.response">model.response</a></code>, 
<code><a href="#topic+read.matrix.hb">read.matrix.hb</a></code>,  <code><a href="#topic+matrix.ssc.hb-class">matrix.ssc.hb-class</a></code></p>

<hr>
<h2 id='matrix.csr-class'>Class &quot;matrix.csr&quot; - Sparse Matrices in Compressed Sparse Row Format</h2><span id='topic+matrix.csr-class'></span><span id='topic+matrix.diag.csr-class'></span><span id='topic+show+2CmatrixSpM-method'></span><span id='topic+show+2Cmatrix.csr.chol-method'></span>

<h3>Description</h3>

<p>A class for sparse matrices stored in compressed sparse row ('csr') format.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.csr", ...)</code>
and coerced from various other formats.  Coercion of integer scalars
and vectors into identity matrices and diagonal matrices respectively
is accomplished by <code>as(x,"matrix.diag.csr")</code> which generates an
object that has all the rights and responsibilties of the <code>"matrix.csr"</code> class.
</p>
<p>The default <code>"matrix.csr"</code> object, i.e., <code>new("matrix.csr")</code>, is
a scalar (1 by 1) matrix  with element 0.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, a real array of nnz elements containing the non-zero
elements of A, stored in row order. Thus, if <code class="reqn">i &lt; j</code>, all elements
of row i precede elements from row j. The order of elements
within the rows is immaterial.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the column
indices of the elements stored in <code>ra</code>.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>A class <code>integer</code> array of n+1 elements containing pointers to
the beginning of each row in the arrays <code>ra</code> and <code>ja</code>. Thus
&lsquo;ia[i]&rsquo; indicates the position in the arrays <code>ra</code> and <code>ja</code>
where the ith row begins. The last, (n+1)st, element of <code>ia</code>
indicates where the n+1 row would start, if it existed.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>An <code>integer</code>, dimension of the matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>%*%</dt><dd><p><code>signature(x = "matrix.csr", y = "matrix.csr")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "matrix.csr", y = "matrix")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "matrix.csr", y = "numeric")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "matrix", y = "matrix.csr")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "numeric", y = "matrix.csr")</code>: ... </p>
</dd>
<dt>as.matrix.csc</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>as.matrix.ssc</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>as.matrix.ssr</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>as.matrix.coo</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>chol</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>diag&lt;-</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>image</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "matrix.csr")</code>: ... </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>
<dt>diff</dt><dd><p><code>signature(x = "matrix.csr")</code>: ... </p>
</dd>

<dt>diag&lt;-</dt><dd><p><code>signature(x = "matrix.diag.csr")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+matrix.csc-class">matrix.csc-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  new("matrix.csr")      # the 1x1 matrix [0]
  new("matrix.diag.csr") # the 'same'

  as(1:5, "matrix.diag.csr") # a sparse version of  diag(1:5)
</code></pre>

<hr>
<h2 id='matrix.csr.chol-class'>Class &quot;matrix.csr.chol&quot; (Block Sparse Cholesky Decomposition)</h2><span id='topic+matrix.csr.chol-class'></span>

<h3>Description</h3>

<p>A class of objects returned from Ng and Peyton's (1993) block
sparse Cholesky algorithm.
</p>


<h3>Details</h3>

<p>Note that the <code>perm</code> and notably <code>invp</code> maybe important to back
permute rows and columns of the decompositions, see the Examples, and our
<code><a href="#topic+SparseM.solve">chol</a></code> help page.
</p>


<h3>Objects from the Class</h3>

<p>Objects may be created by calls of the form <code>new("matrix.csr.chol",
    ...)</code>, but typically result from
<code><a href="#topic+SparseM.solve">chol</a>(&lt;matrix.csr&gt;)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nrow</code>:</dt><dd><p>an <code>integer</code>, the number of rows of the
original matrix, or in the linear system of equations.</p>
</dd>
<dt><code>nnzlindx</code>:</dt><dd><p>Object of class <code>numeric</code>, number of non-zero elements in <code>lindx</code></p>
</dd>
<dt><code>nsuper</code>:</dt><dd><p>an <code>integer</code>, the number of supernodes of the decomposition</p>
</dd>
<dt><code>lindx</code>:</dt><dd><p>Object of class <code>integer</code>, vector of integer
containing, in column major order, the row subscripts of the non-zero entries
in the Cholesky factor in a compressed storage format</p>
</dd>
<dt><code>xlindx</code>:</dt><dd><p>Object of class <code>integer</code>, vector of integer of pointers for <code>lindx</code></p>
</dd>
<dt><code>nnzl</code>:</dt><dd><p>of class <code>"numeric"</code>, an integer, the number of non-zero
entries, including the diagonal entries, of the Cholesky factor stored in <code>lnz</code></p>
</dd>
<dt><code>lnz</code>:</dt><dd><p>a <code>numeric</code> vector of the entries of the Cholesky factor</p>
</dd>
<dt><code>xlnz</code>:</dt><dd><p>an <code>integer</code> vector, the column pointers for the Cholesky factor stored in <code>lnz</code></p>
</dd>
<dt><code>invp</code>:</dt><dd><p>inverse permutation vector, <code>integer</code></p>
</dd>
<dt><code>perm</code>:</dt><dd><p>permutation vector, <code>integer</code></p>
</dd>
<dt><code>xsuper</code>:</dt><dd><p>Object of class <code>integer</code>, array containing the supernode partioning</p>
</dd>
<dt><code>det</code>:</dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, the determinant of the Cholesky factor</p>
</dd>
<dt><code>log.det</code>:</dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, the log determinant of the Cholesky factor</p>
</dd>
<dt><code>ierr</code>:</dt><dd><p>an <code>integer</code>, the error flag (from Fortran's &lsquo;<span class="file">src/chol.f</span>&rsquo;)</p>
</dd>
<dt><code>time</code>:</dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, unused (always <code>0.</code>) currently.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.matrix.csr</dt><dd><p><code>signature(x = "matrix.csr.chol",
	upper.tri=TRUE)</code>: to get the sparse (<code>"matrix.csr"</code>) upper
triangular matrix corresponding to the Cholesky decomposition.</p>
</dd>
<dt>backsolve</dt><dd><p><code>signature(r = "matrix.csr.chol")</code>: for computing
<code class="reqn">R^{-1} b</code> when the Cholesky decomposition is <code class="reqn">A = R'R</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Base <span class="rlang"><b>R</b></span>'s <code><a href="#topic+chol">chol</a></code> and <span class="pkg">SparseM</span>'s
<code><a href="#topic+SparseM.solve">chol</a></code>, notably for examples;
<code><a href="base.html#topic+backsolve">backsolve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x5g &lt;- new("matrix.csr",
          ra = c(300, 130, 5, 130, 330,
                 125, 10, 5, 125, 200, 70,
                 10, 70, 121.5, 1e30),
          ja = c(1:3, 1:4, 1:4, 2:5),
          ia = c(1L, 4L, 8L, 12L, 15L, 16L),
          dimension = c(5L, 5L))
(m5g &lt;- as.matrix(x5g)) # yes, is symmetric, and positive definite:
eigen(m5g, only.values=TRUE)$values  # all positive (but close to singular)
ch5g &lt;- chol(x5g)
str(ch5g) # --&gt; the slots of the "matrix.csr.chol" class
mch5g &lt;- as.matrix.csr(ch5g)
print.table(as.matrix(mch5g), zero.print=".") # indeed upper triagonal w/ positive diagonal

## x5 has even more extreme entry at [5,5]:
x5 &lt;- x5g; x5[5,5] &lt;- 2.9e32
m5 &lt;- as.matrix(x5)
(c5 &lt;- chol(m5))# still fine, w/ [5,5] entry = 1.7e16 and other diag.entries in (9.56, 17.32)
ch5 &lt;- chol(x5) # --&gt; warning  "Replaced 3 tiny diagonal entries by 'Large'"
                # gave error for a while
(mmc5 &lt;- as.matrix(as.matrix.csr(ch5)))
        # yes, these replacements were extreme, and the result is "strange'
## Solve the problem (here) specifying non-default  singularity-tuning par 'tiny':
ch5. &lt;- chol(x5, tiny = 1e-33)
(mmc5. &lt;- as.matrix(as.matrix.csr(ch5.))) # looks much better.
## Indeed: R'R  back-permuted *is* the original matrix x5, here m5:
(RtR &lt;- crossprod(mmc5.)[ch5.@invp, ch5.@invp])
          all.equal(m5, RtR, tolerance = 2^-52)
stopifnot(all.equal(m5, RtR, tolerance = 1e-14)) # on F38 Linux, only need tol = 1.25e-16
</code></pre>

<hr>
<h2 id='matrix.ssc-class'>Class &quot;matrix.ssc&quot; - Sparse Matrices in [S]ymmetric [S]parse [C]olumn Format</h2><span id='topic+matrix.ssc-class'></span>

<h3>Description</h3>

<p>A class for sparse matrices stored in symmetric sparse column ('ssc')
format.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.ssc", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, a real array of nnz elements containing the non-zero
elements of the lower triangular part of A, stored in column order. Thus, if i&lt;j, all elements
of column i precede elements from column j. The order of elements
within the column is immaterial.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the row
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of n+1 elements containing pointers to
the beginning of each column in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;. Thus
&lsquo;ia[i]&rsquo; indicates the position in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;
where the ith column begins. The last, (n+1)st, element of &lsquo;ia&rsquo;
indicates where the n+1 column would start, if it existed.
</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimension of the matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.matrix.csc</dt><dd><p><code>signature(x = "matrix.ssc")</code>: ... </p>
</dd>
<dt>as.matrix.csr</dt><dd><p><code>signature(x = "matrix.ssc")</code>: ... </p>
</dd>
<dt>as.matrix.ssr</dt><dd><p><code>signature(x = "matrix.ssc")</code>: ... </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "matrix.ssc")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "matrix.ssc")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+matrix.csr-class">matrix.csr-class</a></code></p>

<hr>
<h2 id='matrix.ssc.hb-class'>Class &quot;matrix.ssc.hb&quot;</h2><span id='topic+matrix.ssc.hb-class'></span>

<h3>Description</h3>

<p>A new class consists of the coefficient matrix and
the right-hand-side of a linear system of equations,
initial guess of the solution and the exact solutions if they exist stored
in external files using the Harwell-Boeing format.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.ssc.hb", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, ra component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, ja component of the csc or s
sc format of the coefficient matrix, X.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, ia component of the csc or ssc format of the coefficient matrix, X.</p>
</dd>
<dt><code>rhs.ra</code>:</dt><dd><p>Object of class <code>numeric</code>, ra component of the right-hand-side, y, if stored in csc or
ssc format; right-hand-side stored in dense vector or matrix otherwise.</p>
</dd>
<dt><code>guess</code>:</dt><dd><p>Object of class <code>numeric or NULL</code> vector of the initial guess of the solutions if they exist;
a null vector otherwise.</p>
</dd>
<dt><code>xexact</code>:</dt><dd><p>Object of class <code>numeric or NULL</code> vector of the exact solutions, b, if they exist; a null vector otherwise.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimenson of the coefficient matrix, X.</p>
</dd>
<dt><code>rhs.dim</code>:</dt><dd><p>Object of class <code>integer</code>, dimenson of the right-hand-side, y.</p>
</dd>
<dt><code>rhs.mode</code>:</dt><dd><p>Object of class <code>character or NULL</code> storage mode of the right-hand-side; can be full storage or
same format as the coefficient matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"matrix.csc.hb"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>model.matrix</dt><dd><p><code>signature(object = "matrix.ssc.hb")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+model.matrix">model.matrix</a></code>, <code><a href="#topic+model.response">model.response</a></code>, 
<code><a href="#topic+read.matrix.hb">read.matrix.hb</a></code>, <code><a href="#topic+matrix.csc.hb-class">matrix.csc.hb-class</a></code></p>

<hr>
<h2 id='matrix.ssr-class'>Class &quot;matrix.ssr&quot; - Sparse Matrices in [S]ymmetric [S]parse [R]ow Format</h2><span id='topic+matrix.ssr-class'></span>

<h3>Description</h3>

<p>A class for sparse matrices stored in symmetric sparse row ('ssr') format.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("matrix.ssr", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ra</code>:</dt><dd><p>Object of class <code>numeric</code>, a real array of nnz elements containing the non-zero
elements of the lower triangular part of A, stored in row order. Thus, if i&lt;j, all elements
of row i precede elements from row j. The order of elements
within the rows is immaterial.</p>
</dd>
<dt><code>ja</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of nnz elements containing the column
indices of the elements stored in &lsquo;ra&rsquo;.</p>
</dd>
<dt><code>ia</code>:</dt><dd><p>Object of class <code>integer</code>, an integer array of n+1 elements containing pointers to
the beginning of each row in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;. Thus
&lsquo;ia[i]&rsquo; indicates the position in the arrays &lsquo;ra&rsquo; and &lsquo;ja&rsquo;
where the ith row begins. The last, (n+1)st, element of &lsquo;ia&rsquo;
indicates where the n+1 row would start, if it existed.
</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>integer</code>, dimension of the matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.matrix.csc</dt><dd><p><code>signature(x = "matrix.ssr")</code>: ... </p>
</dd>
<dt>as.matrix.csr</dt><dd><p><code>signature(x = "matrix.ssr")</code>: ... </p>
</dd>
<dt>as.matrix.ssr</dt><dd><p><code>signature(x = "matrix.ssr")</code>: ... </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "matrix.ssr")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "matrix.ssr")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+matrix.csr-class">matrix.csr-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ssr &lt;- as.matrix.ssr(diag(c(2,3,5,7)))
  ssr
</code></pre>

<hr>
<h2 id='mslm-class'>Class &quot;mslm&quot;</h2><span id='topic+mslm-class'></span>

<h3>Description</h3>

<p>A sparse extension of <code>lm</code></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("mslm", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coefficients</code>:</dt><dd><p>Object of class <code>numeric</code> estimated coefficients</p>
</dd>
<dt><code>chol</code>:</dt><dd><p>Object of class <code>matrix.csr.chol</code> generated by 
the function <code>chol</code></p>
</dd>
<dt><code>residuals</code>:</dt><dd><p>Object of class <code>"numeric"</code> residuals</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Object of class <code>"numeric"</code> fitted values</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"lm"</code>, directly.
Class <code>"slm"</code>, directly.
Class <code>"oldClass"</code>, by class &quot;lm&quot;.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "mslm")</code>: ... </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "mslm")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "mslm")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "mslm")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+slm">slm</a></code></p>

<hr>
<h2 id='numeric+20or+20NULL-class'>Class &quot;numeric or NULL&quot;</h2><span id='topic+numeric+20or+20NULL-class'></span>

<h3>Description</h3>

<p>A virtual class needed by the &quot;matrix.csc.hb&quot; class</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;numeric or NULL&quot; in the signature.
</p>

<hr>
<h2 id='slm'>Fit a linear regression model using sparse matrix algebra</h2><span id='topic+slm'></span>

<h3>Description</h3>

<p>This is a function to illustrate the use of sparse linear algebra
to solve a linear least squares problem using Cholesky decomposition.
The syntax and output attempt to emulate <code>lm()</code> but may
fail to do so fully satisfactorily.  Ideally, this would eventually
become a method for <code>lm</code>.  The main obstacle to this step is
that it would be necessary to have a model.matrix function that
returned an object in sparse csr form.  For the present, the objects
represented in the formula must be in dense form.  If the user wishes
to specify fitting with a design matrix that is already in sparse form,
then the lower level function <code>slm.fit()</code> should be used. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slm(formula, data, weights, na.action, method = "csr", contrasts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slm_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response on the left of a <code>~</code> operator,
and the terms, separated by <code>+</code> operators, on the right.  As in
<code>lm()</code>, the response variable in the formula can be matrix valued.
</p>
</td></tr>
<tr><td><code id="slm_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables
named in the formula, or in the subset and the weights argument.
If this is missing, then the variables in the formula should be on the
search list.  This may also be a single number to handle some special
cases &ndash; see below for details.
</p>
</td></tr>
<tr><td><code id="slm_+3A_weights">weights</code></td>
<td>

<p>vector of observation weights; if supplied, the algorithm fits
to minimize the sum of the weights multiplied into the
absolute residuals. The length of weights must be the same as
the number of observations.  The weights must be nonnegative
and it is strongly recommended that they be strictly positive,
since zero weights are ambiguous.
</p>
</td></tr>
<tr><td><code id="slm_+3A_na.action">na.action</code></td>
<td>

<p>a function to filter missing data.
This is applied to the model.frame after any subset argument has been used.
The default (with <code>na.fail</code>) is to create an error if any missing 
values are found.  A possible alternative is <code>na.omit</code>, which
deletes observations that contain one or more missing values.
</p>
</td></tr>
<tr><td><code id="slm_+3A_method">method</code></td>
<td>
<p>there is only one method based on Cholesky factorization</p>
</td></tr>
<tr><td><code id="slm_+3A_contrasts">contrasts</code></td>
<td>

<p>a list giving contrasts for some or all of the factors
default = <code>NULL</code> appearing in the model formula.
The elements of the list should have the same name as the variable
and should be either a contrast matrix (specifically, any full-rank
matrix with as many rows as there are levels in the factor),
or else a function to compute such a matrix given the number of levels.
</p>
</td></tr>
<tr><td><code id="slm_+3A_...">...</code></td>
<td>

<p>additional arguments for the fitting routines
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>slm</code> consisting of:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>estimated coefficients</p>
</td></tr>
<tr><td><code>chol</code></td>
<td>
<p>cholesky object from fitting</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>terms</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>call</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p> Roger Koenker </p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>, <br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>


<h3>See Also</h3>

<p><code>slm.methods</code> for methods <code>summary</code>, <code>print</code>, <code>fitted</code>,
<code>residuals</code> and <code>coef</code> associated with class <code>slm</code>,
and <code>slm.fit</code> for lower level fitting functions.  The latter functions
are of special interest if you would like to pass a sparse form of the
design matrix directly to the fitting process.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lsq)
X &lt;- model.matrix(lsq) #extract the design matrix
y &lt;- model.response(lsq) # extract the rhs
X1 &lt;- as.matrix(X)
slm.time &lt;- system.time(slm(y~X1-1) -&gt; slm.o) # pretty fast
lm.time &lt;- system.time(lm(y~X1-1) -&gt; lm.o) # very slow
cat("slm time =",slm.time,"\n")
cat("slm Results: Reported Coefficients Truncated to 5  ","\n")
sum.slm &lt;- summary(slm.o)
sum.slm$coef &lt;- sum.slm$coef[1:5,]
sum.slm
cat("lm time =",lm.time,"\n")
cat("lm Results: Reported Coefficients Truncated to 5  ","\n")
sum.lm &lt;- summary(lm.o)
sum.lm$coef &lt;- sum.lm$coef[1:5,]
sum.lm
</code></pre>

<hr>
<h2 id='slm-class'>Class &quot;slm&quot;</h2><span id='topic+slm-class'></span>

<h3>Description</h3>

<p>A sparse extension of <code>lm</code></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("slm", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coefficients</code>:</dt><dd><p>Object of class <code>numeric</code> estimated coefficients</p>
</dd>
<dt><code>chol</code>:</dt><dd><p>Object of class <code>matrix.csr.chol</code> generated by
function <code>chol</code></p>
</dd>
<dt><code>residuals</code>:</dt><dd><p>Object of class <code>"numeric"</code> residuals</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Object of class <code>"numeric"</code> fitted values</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"lm"</code>, directly.
Class <code>"oldClass"</code>, by class &quot;lm&quot;.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "slm")</code>: ... </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "slm")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "slm")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "slm")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+slm">slm</a></code></p>

<hr>
<h2 id='slm.fit'>Internal slm fitting functions</h2><span id='topic+slm.fit'></span><span id='topic+slm.fit'></span><span id='topic+slm.wfit'></span><span id='topic+slm.fit.csr'></span>

<h3>Description</h3>

<p>Fitting functions for sparse linear model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slm.fit(x,y,method, ...)
slm.wfit(x,y,weights,...)
slm.fit.csr(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slm.fit_+3A_x">x</code></td>
<td>
<p> design matrix.  </p>
</td></tr>
<tr><td><code id="slm.fit_+3A_y">y</code></td>
<td>
<p> vector of response observations.  </p>
</td></tr>
<tr><td><code id="slm.fit_+3A_method">method</code></td>
<td>
<p> only <code>csr</code> is supported currently </p>
</td></tr>
<tr><td><code id="slm.fit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process. If specified, weighted least squares is used with
weights &lsquo;weights&rsquo; (that is, minimizing </p>
<p style="text-align: center;"><code class="reqn">\sum w_i*e_i^2</code>
</p>

<p>The length of weights must be the same as
the number of observations.  The weights must be nonnegative
and it is strongly recommended that they be strictly positive,
since zero weights are ambiguous.</p>
</td></tr>
<tr><td><code id="slm.fit_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slm.fit</code> and <code>slm.wfit</code> call <code>slm.fit.csr</code> 
to do Cholesky decomposition
and then backsolve to obtain the least squares estimated coefficients.
These functions can be called directly if the user is willing to
specify the design matrix in <code>matrix.csr</code> form.  This is often
advantageous in large problems to reduce memory requirements.
</p>


<h3>Value</h3>

<p>A list of class <code>slm</code> consisting of:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>estimated coefficients</p>
</td></tr>
<tr><td><code>chol</code></td>
<td>
<p>cholesky object from fitting</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>terms</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>call</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p> Roger Koenker </p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a></p>


<h3>See Also</h3>

  <p><code><a href="#topic+slm">slm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lsq)
X &lt;- model.matrix(lsq) #extract the design matrix
y &lt;- model.response(lsq) # extract the rhs
class(X) # -&gt; "matrix.csr"
class(y) # -&gt; NULL
slm.fit(X,y)-&gt;slm.fit.o # this is much more efficient in memory usage than slm()
slm(y~as.matrix(X)-1) -&gt; slm.o # this requires X to be transformed into dense mode
cat("Difference between `slm.fit' and `slm' estimated coefficients =",
	sum(abs(slm.fit.o$coef-slm.o$coef)),"\n")
</code></pre>

<hr>
<h2 id='slm.methods'>Methods for slm objects</h2><span id='topic+slm.methods'></span><span id='topic+summary.slm'></span><span id='topic+summary.mslm'></span><span id='topic+print.summary.slm'></span><span id='topic+print.slm'></span><span id='topic+fitted.slm'></span><span id='topic+residuals.slm'></span><span id='topic+coef.slm'></span><span id='topic+extractAIC.slm'></span><span id='topic+deviance.slm'></span>

<h3>Description</h3>

<p>Summarize, print, and extract objects from  <code><a href="#topic+slm">slm</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
summary(object, correlation, ...)
## S3 method for class 'mslm'
summary(object, ...)
## S3 method for class 'slm'
print(x, digits, ...)
## S3 method for class 'summary.slm'
print(x, digits, symbolic.cor, signif.stars, ...)
## S3 method for class 'slm'
fitted(object, ...)
## S3 method for class 'slm'
residuals(object, ...)
## S3 method for class 'slm'
coef(object, ...)
## S3 method for class 'slm'
extractAIC(fit, scale = 0, k = 2, ...)
## S3 method for class 'slm'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slm.methods_+3A_object">object</code>, <code id="slm.methods_+3A_x">x</code>, <code id="slm.methods_+3A_fit">fit</code></td>
<td>
<p> object of class <code>slm</code>.  </p>
</td></tr>
<tr><td><code id="slm.methods_+3A_digits">digits</code></td>
<td>
<p>minimum number of significant digits to be used for most numbers.</p>
</td></tr>
<tr><td><code id="slm.methods_+3A_scale">scale</code></td>
<td>
<p>optional numeric specifying the scale parameter of the model,
see 'scale' in 'step'.  Currently only used in the '&quot;lm&quot;'
method, where 'scale' specifies the estimate of the error
variance, and 'scale = 0' indicates that it is to be
estimated by maximum likelihood.</p>
</td></tr> 
<tr><td><code id="slm.methods_+3A_k">k</code></td>
<td>
<p> numeric specifying the &quot;weight&quot; of the equivalent degrees of
freedom ('edf') part in the AIC formula.</p>
</td></tr>
<tr><td><code id="slm.methods_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation of coefficients
will be printed. The default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="slm.methods_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical; if <code>TRUE</code>, P-values are additionally encoded
visually as &ldquo;significance stars&rdquo; in order to help scanning
of long coefficient tables.  It defaults to the
&lsquo;show.signif.stars&rsquo; slot of &lsquo;options&rsquo;. </p>
</td></tr>
<tr><td><code id="slm.methods_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of the
estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="slm.methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print.slm</code> and <code>print.summary.slm</code> return invisibly.
<code>fitted.slm</code>, <code>residuals.slm</code>, and <code>coef.slm</code> 
return the corresponding components of the <code>slm</code> object.
<code>extractAIC.slm</code> and <code>deviance.slm</code> return the AIC
and deviance values of the fitted object.
</p>


<h3>Author(s)</h3>

<p> Roger Koenker </p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>


<h3>See Also</h3>

  
<p><code>slm</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lsq)
X &lt;- model.matrix(lsq) #extract the design matrix
y &lt;- model.response(lsq) # extract the rhs
X1 &lt;- as.matrix(X)
slm.time &lt;- system.time(slm(y~X1-1) -&gt; slm.o) # pretty fast
cat("slm time =",slm.time,"\n")
cat("slm Results: Reported Coefficients Truncated to 5  ","\n")
sum.slm &lt;- summary(slm.o)
sum.slm$coef &lt;- sum.slm$coef[1:5,]
sum.slm
fitted(slm.o)[1:10]
residuals(slm.o)[1:10]
coef(slm.o)[1:10]
</code></pre>

<hr>
<h2 id='SparseM.hb'>Harwell-Boeing Format Sparse Matrices</h2><span id='topic+SparseM.hb'></span><span id='topic+read.matrix.hb'></span><span id='topic+model.matrix+2CANY-method'></span><span id='topic+model.matrix+2Cmatrix.csc.hb-method'></span><span id='topic+model.matrix+2Cmatrix.ssc.hb-method'></span><span id='topic+model.matrix.matrix.ssc.hb'></span><span id='topic+model.response+2CANY-method'></span><span id='topic+model.response+2Cmatrix.csc.hb-method'></span><span id='topic+model.response+2Cmatrix.ssc.hb-method'></span><span id='topic+model.guess+2Cmatrix.csc.hb-method'></span><span id='topic+model.guess+2Cmatrix.ssc.hb-method'></span><span id='topic+model.xexact+2Cmatrix.csc.hb-method'></span><span id='topic+model.xexact+2Cmatrix.ssc.hb-method'></span><span id='topic+model.response'></span><span id='topic+model.guess'></span><span id='topic+model.xexact'></span><span id='topic+model.matrix'></span>

<h3>Description</h3>

<p>Read, and extract components of data in Harwell-Boeing sparse matrix format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.matrix.hb(file)
model.matrix(object, ...)
model.response(data,type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM.hb_+3A_file">file</code></td>
<td>
<p>file name to read from or </p>
</td></tr>
<tr><td><code id="SparseM.hb_+3A_data">data</code>, <code id="SparseM.hb_+3A_object">object</code></td>
<td>
<p>an object of either 'matrix.csc.hb' or 'matrix.ssc.hb' class</p>
</td></tr>
<tr><td><code id="SparseM.hb_+3A_type">type</code></td>
<td>
<p>One of &lsquo;&quot;any&quot;&rsquo;, &lsquo;&quot;numeric&quot;&rsquo;, &lsquo;&quot;double&quot;&rsquo;. Using the either of
latter two coerces the result to have storage mode &lsquo;&quot;double&quot;&rsquo;</p>
</td></tr>
<tr><td><code id="SparseM.hb_+3A_...">...</code></td>
<td>
<p>additional arguments to model.matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sparse coefficient matrices in the Harwell-Boeing format are stored in 
80-column records. Each file begins with a multiple line header block 
followed by two, three or four data blocks. The header block contains 
summary information on the storage formats and storage requirements. 
The data blocks contain information of the sparse coefficient matrix and 
data for the right-hand-side of the linear system of equations, 
initial guess of the solution and the exact solutions if they exist.
The function <code>model.matrix</code> extracts the X matrix component.
The function <code>model.response</code> extracts the y vector (or matrix).
The function <code>model.guess</code> extracts the guess vector. 
The function <code>model.xexact</code> extracts the xexact vector. 
This function is written in R replacing a prior implementation based
on iohb.c which had memory fault difficulties.  The function write.matrix.hb
has been purged; users wishing to write matrices in Harwell-Boeing format
are advised to convert SparseM matrices to Matrix classes and use writeHB
from the Matrix package.  Contributions of code to facilitate this conversion
would be appreciated!
</p>


<h3>Value</h3>

<p>The function <code>read.matrix.hb</code> returns a list of class 
<code>matrix.csc.hb</code> or <code>matrix.ssc.hb</code> depending
on how the coefficient matrix is stored in the <code>file</code>.
</p>
<table>
<tr><td><code>ra</code></td>
<td>
<p>ra component of the csc or ssc format of the coefficient matrix, X.</p>
</td></tr>
<tr><td><code>ja</code></td>
<td>
<p>ja component of the csc or ssc format of the coefficient matrix, X.</p>
</td></tr>
<tr><td><code>ia</code></td>
<td>
<p>ia component of the csc or ssc format of the coefficient matrix, X.</p>
</td></tr>
<tr><td><code>rhs.ra</code></td>
<td>
<p>ra component of the right-hand-side, y, if stored in csc or 
ssc format; right-hand-side stored in dense vector or matrix otherwise.</p>
</td></tr>
<tr><td><code>rhs.ja</code></td>
<td>
<p>ja component of the right-hand-side, y, if stored in csc or 
ssc format; a null vector otherwise.</p>
</td></tr>
<tr><td><code>rhs.ia</code></td>
<td>
<p>ia component of the right-hand-side, y, if stored in csc or 
ssc format; a null vector otherwise.</p>
</td></tr>
<tr><td><code>xexact</code></td>
<td>
<p>vector of the exact solutions, b, if they exist; a null vector otherwise.</p>
</td></tr>
<tr><td><code>guess</code></td>
<td>
<p>vector of the initial guess of the solutions if they exist; 
a null vector otherwise.</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>dimenson of the coefficient matrix, X.</p>
</td></tr>
<tr><td><code>rhs.dim</code></td>
<td>
<p>dimenson of the right-hand-side, y.</p>
</td></tr>
<tr><td><code>rhs.mode</code></td>
<td>
<p>storage mode of the right-hand-side; can be full storage or
same format as the coefficient matrix, for the moment the only allowed
mode is &quot;F&quot; for full, or dense mode.</p>
</td></tr>
</table>
<p>The function <code>model.matrix</code> returns the X matrix of class <code>matrix.csr</code>.
The function <code>model.response</code> returns the y vector (or matrix).
The function <code>model.guess</code> returns the guess  vector (or matrix).
The function <code>model.xexact</code> returns the xexact vector (or matrix).
</p>


<h3>Author(s)</h3>

<p>Pin Ng</p>


<h3>References</h3>

 
<p>Duff, I.S., Grimes, R.G. and Lewis, J.G. (1992) 
User's Guide for Harwell-Boeing Sparse Matrix Collection at 
<a href="https://math.nist.gov/MatrixMarket/collections/hb.html">https://math.nist.gov/MatrixMarket/collections/hb.html</a></p>


<h3>See Also</h3>

<p><code>slm</code> for sparse version of <code>lm</code> <br />
<code>SparseM.ops</code> for operators on class <code>matrix.csr</code> <br />
<code>SparseM.solve</code> for linear equation solving for class <code>matrix.csr</code> <br />
<code>SparseM.image</code> for image plotting of class <code>matrix.csr</code> <br />
<code>SparseM.ontology</code> for coercion of class <code>matrix.csr</code> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
Xy &lt;- read.matrix.hb(system.file("extdata","lsq.rra",package = "SparseM"))
class(Xy) # -&gt; [1] "matrix.csc.hb"
X &lt;- model.matrix(Xy)-&gt;X
class(X) # -&gt; "matrix.csr"
dim(X) # -&gt; [1] 1850  712
y &lt;- model.response(Xy) # extract the rhs
length(y) # [1] 1850
Xy &lt;- read.matrix.hb(system.file("extdata","rua_32_ax.rua",package = "SparseM"))
X &lt;- model.matrix(Xy)
y &lt;- model.response(Xy) # extract the rhs
g &lt;- model.guess(Xy) # extract the guess 
a &lt;- model.xexact(Xy) # extract the xexact 
fit &lt;- solve(t(X) %*% X, t(X) %*% y) # compare solution with xexact solution 
</code></pre>

<hr>
<h2 id='SparseM.image'>Image Plot for Sparse Matrices</h2><span id='topic+image'></span><span id='topic+SparseM.image'></span><span id='topic+image+2Cmatrix.csr-method'></span>

<h3>Description</h3>

<p>Display the pattern of non-zero entries of
a matrix of class <code>matrix.csr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix.csr'
image(x, col=c("white","gray"),
      xlab="column", ylab="row", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM.image_+3A_x">x</code></td>
<td>
<p>a matrix of class <code>matrix.csr</code>.</p>
</td></tr>
<tr><td><code id="SparseM.image_+3A_col">col</code></td>
<td>
<p>a list of colors such as that generated by <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>.
Defaults to c(&quot;white&quot;,&quot;gray&quot;)</p>
</td></tr>
<tr><td><code id="SparseM.image_+3A_xlab">xlab</code>, <code id="SparseM.image_+3A_ylab">ylab</code></td>
<td>
<p>each a character string giving the labels for the x and y axis.</p>
</td></tr>
<tr><td><code id="SparseM.image_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pattern of the non-zero entries of a sparse matrix
is displayed.  By default nonzero entries of the matrix appear
as gray blocks and zero entries as white background.</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).
SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>


<h3>See Also</h3>

<p><code>SparseM.ops</code>,
<code>SparseM.solve</code>,
<code>SparseM.ontology</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rnorm(20*5)
A &lt;- matrix(a,20,5)
A[row(A)&gt;col(A)+4|row(A)&lt;col(A)+3] &lt;- 0
b &lt;- rnorm(20*5)
B &lt;- matrix(b,20,5)
B[row(A)&gt;col(A)+2|row(A)&lt;col(A)+2] &lt;- 0
image(as.matrix.csr(A)%*%as.matrix.csr(t(B)))
</code></pre>

<hr>
<h2 id='SparseM.ontology'>Sparse Matrix Class Ontology</h2><span id='topic+SparseM.ontology'></span><span id='topic+initialize+2CANY-method'></span><span id='topic+initialize+2Cmatrix.csr-method'></span><span id='topic+initialize+2Cmatrix.coo-method'></span><span id='topic+coerce+2Cvector+2Cmatrix.diag.csr-method'></span><span id='topic+coerce+2Cmatrix+2Cmatrix.csr-method'></span><span id='topic+coerce+2Cmatrix.csr+2Cmatrix.diag.csr-method'></span><span id='topic+coerce+2Cvector+2Cmatrix.csr-method'></span><span id='topic+coerce+2Cnumeric+2Cmatrix.diag.csr-method'></span><span id='topic+as.matrix'></span><span id='topic+as.matrix+2CANY-method'></span><span id='topic+as.matrix+2Cmatrix.csr-method'></span><span id='topic+as.matrix+2Cmatrix.csc-method'></span><span id='topic+as.matrix+2Cmatrix.ssc-method'></span><span id='topic+as.matrix+2Cmatrix.ssr-method'></span><span id='topic+as.matrix+2Cmatrix.coo-method'></span><span id='topic+as.matrix.coo'></span><span id='topic+as.matrix.coo+2CANY-method'></span><span id='topic+as.matrix.coo+2Cmatrix.csr-method'></span><span id='topic+as.matrix.csr'></span><span id='topic+as.matrix.csr+2CANY-method'></span><span id='topic+as.matrix.csr+2Cmatrix.csc-method'></span><span id='topic+as.matrix.csr+2Cmatrix.ssr-method'></span><span id='topic+as.matrix.csr+2Cmatrix.ssc-method'></span><span id='topic+as.matrix.csr+2Cmatrix.coo-method'></span><span id='topic+as.matrix.csr+2Cmatrix.csr.chol-method'></span><span id='topic+as.matrix.csc'></span><span id='topic+as.matrix.csc+2CANY-method'></span><span id='topic+as.matrix.csc+2Cmatrix.csr-method'></span><span id='topic+as.matrix.csc+2Cmatrix.csc-method'></span><span id='topic+as.matrix.csc+2Cmatrix.ssr-method'></span><span id='topic+as.matrix.csc+2Cmatrix.ssc-method'></span><span id='topic+as.matrix.csc+2Cmatrix.coo-method'></span><span id='topic+as.matrix.ssr'></span><span id='topic+as.matrix.ssr+2CANY-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.coo-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.csc-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.csr-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.ssc-method'></span><span id='topic+as.matrix.ssr+2Cmatrix.ssr-method'></span><span id='topic+as.matrix.ssc'></span><span id='topic+as.matrix.ssc+2CANY-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.coo-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.csc-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.csr-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.ssc-method'></span><span id='topic+as.matrix.ssc+2Cmatrix.ssr-method'></span><span id='topic+is.matrix.coo'></span><span id='topic+is.matrix.csc'></span><span id='topic+is.matrix.csr'></span><span id='topic+is.matrix.ssc'></span><span id='topic+is.matrix.ssr'></span><span id='topic+matrix.csr'></span>

<h3>Description</h3>

<p>This group of functions evaluates and coerces changes in class structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.matrix.csr(x, nrow, ncol, eps = .Machine$double.eps, ...)
## S4 method for signature 'matrix.csr.chol'
as.matrix.csr(x, nrow, ncol, eps, upper.tri=TRUE, ...)
## S4 method for signature 'matrix.csr'
as.matrix.csc(x, nrow = 1, ncol = 1, eps = .Machine$double.eps)
## S4 method for signature 'matrix.coo'
as.matrix.ssr(x, nrow = 1, ncol = 1, eps = .Machine$double.eps)
## S4 method for signature 'matrix.csc'
as.matrix.ssc(x, nrow = 1, ncol = 1, eps = .Machine$double.eps)
## S4 method for signature 'matrix.csr'
as.matrix.coo(x, nrow = 1, ncol = 1, eps = .Machine$double.eps)

is.matrix.csr(x)
is.matrix.csc(x)
is.matrix.ssr(x)
is.matrix.ssc(x)
is.matrix.coo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM.ontology_+3A_x">x</code></td>
<td>
<p>is a matrix, or vector object,  of either dense or sparse form</p>
</td></tr>
<tr><td><code id="SparseM.ontology_+3A_nrow">nrow</code></td>
<td>
<p>number of rows of matrix </p>
</td></tr>
<tr><td><code id="SparseM.ontology_+3A_ncol">ncol</code></td>
<td>
<p>number of columns of matrix </p>
</td></tr>
<tr><td><code id="SparseM.ontology_+3A_eps">eps</code></td>
<td>
<p>A tolerance parameter:  elements of x such that abs(x) &lt; eps set to zero.
This argument is only relevant when coercing matrices from dense to sparse form. Defaults to
<code>eps = .Machine$double.eps</code> </p>
</td></tr>
<tr><td><code id="SparseM.ontology_+3A_upper.tri">upper.tri</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, to choose upper or lower triangular matrix result.</p>
</td></tr>
<tr><td><code id="SparseM.ontology_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>matrix.csc</code> acts like <code>matrix</code> to coerce a vector object to
a sparse matrix object of class <code>matrix.csr</code>.
This aspect of the code is in the process of conversion from S3 to S4 classes.
For the most part the S3 syntax prevails.  An exception is the code to
coerce vectors to diagonal matrix form which uses <code>as(v,"matrix.diag.csr"</code>.
The generic functions <code>as.matrix.xxx</code> coerce a matrix <code>x</code> into
a matrix of storage class <code>matrix.xxx</code>. The argument matrix <code>x</code>
may be of conventional dense form, or of any of the four supported
classes:  <code>matrix.csr, matrix.csc, matrix.ssr, matrix.ssc</code>.
The generic functions <code>is.matrix.xxx</code> evaluate whether the
argument is of class <code>matrix.xxx</code>.  The function
<code>as.matrix</code> transforms a matrix of any sparse class into conventional
dense form.  The primary storage class for sparse matrices is the
compressed sparse row <code>matrix.csr</code> class.
An <em>n</em> by <em>m</em> matrix <em>A</em> with real elements <code class="reqn">a_{ij}</code>,
stored in <code>matrix.csr</code> format consists of three arrays:
</p>

<ul>
<li> <p><code>ra</code>: a real array of <em>nnz</em> elements containing the non-zero
elements of <em>A</em>, stored in row order. Thus, if <em>i&lt;j</em>, all elements of row <em>i</em>
precede elements from row <em>j</em>. The order of elements within the rows is immaterial.
</p>
</li>
<li> <p><code>ja</code>: an integer array of <em>nnz</em> elements containing the column
indices of the elements stored in <code>ra</code>.
</p>
</li>
<li> <p><code>ia</code>: an integer array of <em>n+1</em> elements containing pointers to
the beginning of each row in the arrays <code>ra</code> and <code>ja</code>. Thus
<code>ia[i]</code> indicates the position in the arrays <code>ra</code> and
<code>ja</code> where the <em>i</em>th row begins. The last, <em>(n+1)</em>st, element of
<code>ia</code> indicates where the <em>n+1</em> row would start, if it existed.
</p>
</li></ul>

<p>The compressed sparse column class  <code>matrix.csc</code> is defined in
an analogous way, as are  the <code>matrix.ssr</code>, symmetric sparse row, and
<code>matrix.ssc</code>, symmetric sparse column classes.
</p>


<h3>Note</h3>

<p><code>as.matrix.ssr</code> and <code>as.matrix.ssc</code> should ONLY be used with
symmetric matrices.
</p>
<p><code>as.matrix.csr(x)</code>, when <code>x</code> is an object of class <code>matrix.csr.chol</code>
(that is, an object returned by a call to <code>chol(a)</code> when <code>a</code>
is an object of class <code>matrix.csr</code> or <code>matric.csc</code>),
by default returns an upper triangular matrix, which
is <em>not</em> consistent with the result of <code>chol</code> in the <span class="pkg">base</span>
package.  To get an lower triangular <code>matric.csr</code> matrix, use either
<code>as.matrix.csr(x, upper.tri = FALSE)</code> or
<code>t(as.matrix.csr(x))</code>.
</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002)
<em>SparseM: A Sparse Matrix Package for <span class="rlang"><b>R</b></span></em>.
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>


<h3>See Also</h3>

<p><code>SparseM.hb</code> for handling Harwell-Boeing sparse matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t(m5 &lt;- as.matrix.csr(c(-1:1,0,0)))
t(M4 &lt;- as.matrix.csc(c(0:2,0), 4))
 (S3 &lt;- as.matrix.ssr(diag(x = 0:2))) # *symmetric*
stopifnot(identical(dim(m5), c(5L, 1L)),
          identical(dim(M4), c(4L, 1L)),
          identical(dim(S3), c(3L, 3L)))

n1 &lt;- 10
p &lt;- 5
a &lt;- round(rnorm(n1*p), 2)
a[abs(a) &lt; 0.7] &lt;- 0
A &lt;- matrix(a,n1,p)
B &lt;- t(A) %*% A      
A.csr &lt;- as.matrix.csr(A)
A.csc &lt;- as.matrix.csc(A)
B.ssr &lt;- as.matrix.ssr(B)
B.ssc &lt;- as.matrix.ssc(B)
stopifnot(exprs = {
  is.matrix.csr(A.csr) # -&gt; TRUE
  is.matrix.csc(A.csc) # -&gt; TRUE
  is.matrix.ssr(B.ssr) # -&gt; TRUE
  is.matrix.ssc(B.ssc) # -&gt; TRUE
})
as.matrix(A.csr)
as.matrix(A.csc)
as.matrix(B.ssr)
as.matrix(B.ssc)
as.matrix.csr(0, 2,3)    # sparse matrix of all zeros
## Diagonal (sparse) : 
as(4,   "matrix.diag.csr") # identity matrix of dimension 4
as(2:0, "matrix.diag.csr") # diagonal 3x3 matrix
</code></pre>

<hr>
<h2 id='SparseM.ops'>Basic Linear Algebra for Sparse Matrices</h2><span id='topic+Ops.matrix.csr'></span><span id='topic+Ops.matrix.diag.csr'></span><span id='topic++25+2A+25-methods'></span><span id='topic++25+2A+25+2CANY+2CANY-method'></span><span id='topic++25+2A+25+2Cmatrix.csr+2Cmatrix.csr-method'></span><span id='topic++25+2A+25+2Cmatrix.csr+2Cmatrix-method'></span><span id='topic++25+2A+25+2Cmatrix.csr+2Cnumeric-method'></span><span id='topic++25+2A+25+2Cmatrix+2Cmatrix.csr-method'></span><span id='topic++25+2A+25+2Cnumeric+2Cmatrix.csr-method'></span><span id='topic+kronecker-methods'></span><span id='topic+kronecker+2Cmatrix.csr+2Cmatrix.csr-method'></span><span id='topic+kronecker+2Cmatrix.csr+2Cmatrix-method'></span><span id='topic+kronecker+2Cmatrix.csr+2Cnumeric-method'></span><span id='topic+kronecker+2Cmatrix+2Cmatrix.csr-method'></span><span id='topic+kronecker+2Cnumeric+2Cmatrix.csr-method'></span><span id='topic++2B+2Cmatrix.csr-method'></span><span id='topic+-+2Cmatrix.csr-method'></span><span id='topic++2A+2Cmatrix.csr-method'></span><span id='topic++2F+2Cmatrix.csr-method'></span><span id='topic++5E+2Cmatrix.csr-method'></span><span id='topic++25+25+2Cmatrix.csr-method'></span><span id='topic++25+2F+25+2Cmatrix.csr-method'></span><span id='topic++3E+2Cmatrix.csr-method'></span><span id='topic++3E+3D+2Cmatrix.csr-method'></span><span id='topic++3C+2Cmatrix.csr-method'></span><span id='topic++3C+3D+2Cmatrix.csr-method'></span><span id='topic++3D+3D+2Cmatrix.csr-method'></span><span id='topic++21+3D+2Cmatrix.csr-method'></span><span id='topic++26+2Cmatrix.csr-method'></span><span id='topic++7C+2Cmatrix.csr-method'></span><span id='topic+norm'></span><span id='topic+norm+2CANY-method'></span><span id='topic+norm+2Cmatrix.csr+2Ccharacter-method'></span><span id='topic+norm+2Cmatrix.csr+2Cmissing-method'></span><span id='topic+det'></span><span id='topic+determinant'></span><span id='topic+determinant+2Cmatrix.csr.chol+2Cmissing-method'></span><span id='topic+determinant+2Cmatrix.csr.chol+2Clogical-method'></span><span id='topic+determinant+2Cmatrix.csr+2Cmissing-method'></span><span id='topic+determinant+2Cmatrix.csr+2Clogical-method'></span><span id='topic+t+2CANY-method'></span><span id='topic+t+2Cmatrix.csr-method'></span><span id='topic+t+2Cmatrix.csc-method'></span><span id='topic+t+2Cmatrix.coo-method'></span><span id='topic+diag+2CANY-method'></span><span id='topic+diag+2Cmatrix.csr-method'></span><span id='topic+diag+3C-+2CANY-method'></span><span id='topic+diag+3C-+2Cmatrix.csr-method'></span><span id='topic+diag+3C-+2Cmatrix.diag.csr-method'></span><span id='topic+diff+2Cmatrix.csr-method'></span><span id='topic+diff+3C-+2CANY-method'></span><span id='topic+diff+3C-+2Cmatrix.csr-method'></span><span id='topic+diag.assign+2Cmatrix.csr-method'></span><span id='topic+ncol+2Cmatrix.csr-method'></span><span id='topic+nrow+2Cmatrix.csr-method'></span><span id='topic+dim+2CANY-method'></span><span id='topic+dim+2Cmatrix.csr-method'></span><span id='topic+dim+2Cmatrix.csc-method'></span><span id='topic+dim+2Cmatrix.ssr-method'></span><span id='topic+dim+2Cmatrix.ssc-method'></span><span id='topic+dim+2Cmatrix.coo-method'></span><span id='topic+rbind.matrix.csr'></span><span id='topic+cbind.matrix.csr'></span><span id='topic++5B.matrix.csr'></span><span id='topic++5B.matrix.diag.csr'></span><span id='topic++5B+3C-.matrix.csr'></span><span id='topic++5B+3C-.matrix.diag.csr'></span><span id='topic++5B.matrix.coo'></span><span id='topic++5B+3C-.matrix.coo'></span>

<h3>Description</h3>

<p>Basic linear algebra operations for sparse matrices,
mostly of class <code>matrix.csr</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM.ops_+3A_x">x</code></td>
<td>
<p>matrix of class <code>matrix.csr</code>.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_y">y</code></td>
<td>
<p>matrix of class <code>matrix.csr</code> or a dense matrix or vector.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_value">value</code></td>
<td>
<p>replacement values.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_i">i</code>, <code id="SparseM.ops_+3A_j">j</code></td>
<td>
<p>vectors of elements to extract or replace.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_nrow">nrow</code></td>
<td>
<p>optional number of rows for the result.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_lag">lag</code></td>
<td>
<p>an integer indicating which lag to use.</p>
</td></tr>
<tr><td><code id="SparseM.ops_+3A_differences">differences</code></td>
<td>
<p>an integer indicating the order of the difference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linear algebra operations for matrices of class
<code>matrix.csr</code> are designed to behave exactly as for
regular matrices.  In particular, matrix multiplication, kronecker
product, addition,
subtraction and various logical operations should work as with the conventional
dense form of matrix storage, as does indexing, rbind, cbind, and diagonal
assignment and extraction.  The method diag may be used to extract the
diagonal of a <code>matrix.csr</code> object, to create a sparse diagonal see
<code>SparseM.ontology</code>.
</p>
<p>The function <code><a href="base.html#topic+determinant">determinant</a></code> computes the (log) determinant,
of the argument, returning a <code>"det"</code> object as the base function.
This is typically <em>preferred</em> over using the function <code>det()</code>
which is a simple wrapper for <code>determinant()</code>, in a way it will work
for our sparse matrices, as well.
<code>determinant()</code> computes the determinant of the argument
matrix.  If the matrix is of class <code>matrix.csr</code> then it must
be symmetric, or an error will be returned.  If the matrix is of
class <code>matrix.csr.chol</code> then the (pre-computed) determinant of the Cholesky
factor is returned, i.e., the product of the diagonal elements.
</p>
<p>The function <code>norm</code>, i.e. <code>norm(x, type)</code>, by default computes
the &ldquo;sup&rdquo; (or <code>"M"</code>aximum norm, i.e., the maximum of the matrix
elements.  Optionally, this <code>type = "sup"</code> (equivalently, <code>type = "M"</code>) norm can
be replaced by the Hilbert-Schmidt, <code>type = "HS"</code> or equivalently, <code>type = "F"</code>
norm, or the <code>type = "l1"</code>, norm.
Note that for historical reasons, the default <code>type</code> differs from <span class="rlang"><b>R</b></span>'s
own <code><a href="base.html#topic+norm">norm</a>()</code>, see the examples using <code>B</code>, below.
The <code>"sup" === "M"</code> and <code>"HS" === "F"</code> equivalences have been
introduced in <span class="pkg">SparseM</span> version 1.84.
</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).
SparseM: A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slm">slm</a></code> for sparse linear model fitting.
<code><a href="#topic+SparseM.ontology">SparseM.ontology</a></code> for coercion and other class relations
involving our sparse matrix classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 10
n2 &lt;- 10
p &lt;- 6
y &lt;- rnorm(n1)
a &lt;- round(rnorm(n1*p), 2)
a[abs(a) &lt; 0.5] &lt;- 0
A &lt;- matrix(a, n1,p)
A.csr &lt;- as.matrix.csr(A)

B &lt;- matrix(c(1.5, 0,  0,  0, -1.4,    0,    0,   0,   0, -1.4,
              2,   0, -1,  0,  0,      2.1, -1.9, 1.4, 0,  0,
              0,-2.3,  0,  0, -1.9,    0,    0,   0,   0, -1.4,
              0,   0,  0,  0,  0,     -3,    0,   1.3, 0,  1.1,
              0,   0,  0,  0,  2,      0,    0,   0,  -1,  0,
              0,   0, -1.6,0,  0,      0,    0,   0,  -1.7,0),
            10L, 6L)
rcond(B) # 0.21 .. i.e., quite well conditioned
B.csr &lt;- as.matrix.csr(B)
B.csr

## norm() : different 'type' for base R and  SparseM:
(nR &lt;- vapply(c("1", "I", "F", "M", "2"), norm, 0, x = B))
##        1        I        F        M        2
## 8.400000 5.300000 7.372923 3.000000 4.464801
(nSpM &lt;- vapply(c("sup","M",  "HS","F",  "l1"), norm, 0, x = B.csr))
##      sup         M        HS         F        l1
## 3.000000  3.000000  7.372923  7.372923 30.000000
stopifnot(all.equal(unname(nSpM[c("M", "F")]),
                    unname(nR  [c("M", "F" )]), tolerance = 1e-14))

# matrix transposition and multiplication
BtB &lt;- crossprod(B) # == t(B) %*% B  {more efficiently}

A.csr %*% t(B.csr)
BtBs &lt;- t(B.csr) %*% B.csr
BtBs
stopifnot(all.equal(    BtB,  as.matrix(BtBs),  tolerance = 1e-14),
          all.equal(det(BtB), print(det(BtBs)), tolerance = 1e-14))

# matrix  o  vector
stopifnot(all.equal(y %*%  A , y   %*% A.csr) ,
          all.equal(A %*% 1:6, A.csr %*% 1:6)
)

# kronecker product - via kronecker() methods:
A.csr %x% matrix(1:4,2,2)
</code></pre>

<hr>
<h2 id='SparseM.solve'>Linear Equation Solving via Cholesky Decomposition for Sparse Matrices</h2><span id='topic+SparseM.solve'></span><span id='topic+chol+2CANY-method'></span><span id='topic+chol+2Cmatrix.csr-method'></span><span id='topic+chol+2Cmatrix.csc-method'></span><span id='topic+chol+2Cmatrix-method'></span><span id='topic+chol'></span><span id='topic+backsolve-methods'></span><span id='topic+backsolve+2CANY-method'></span><span id='topic+backsolve+2Cmatrix.csr.chol-method'></span><span id='topic+forwardsolve'></span><span id='topic+forwardsolve+2Cmatrix.csr.chol-method'></span><span id='topic+solve'></span><span id='topic+solve+2CANY-method'></span><span id='topic+solve+2Cmatrix.csr-method'></span>

<h3>Description</h3>

 
<dl>
<dt><code>chol()</code></dt><dd><p>performs a Cholesky decomposition of a symmetric
positive definite sparse matrix <code>x</code> of class <code>matrix.csr</code>.</p>
</dd>
<dt><code>backsolve()</code></dt><dd><p>performs a triangular back-fitting to compute
the solutions of a system of linear equations in one step.</p>
</dd>
<dt><code>backsolve()</code> and <code>forwardsolve()</code></dt><dd><p>can also split the functionality of
<code>backsolve</code> into two steps.</p>
</dd>
<dt><code>solve()</code></dt><dd><p>combines <code>chol()</code> and <code>backsolve()</code> to
compute the inverse of a matrix if the right-hand-side is missing.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>chol(x, ...)
## S4 method for signature 'matrix.csr'
chol(x, pivot = FALSE,
    nsubmax, nnzlmax, tmpmax,
    eps = .Machine$double.eps, tiny = 1e-30, Large = 1e128, warnOnly = FALSE,
    cacheKb = 1024L, level = 8L, ...)

## S4 method for signature 'matrix.csr.chol'
backsolve(r, x, k, upper.tri, transpose,
          twice = TRUE, drop = TRUE, ...)
## S4 method for signature 'matrix.csr.chol'
forwardsolve(l, x, k, upper.tri, transpose)
## S4 method for signature 'matrix.csr'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM.solve_+3A_a">a</code></td>
<td>
<p>symmetric positive definite matrix of class <code>"matrix.csr"</code>.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_r">r</code>, <code id="SparseM.solve_+3A_l">l</code></td>
<td>
<p>object of class <code>"matrix.csr.chol"</code> as returned by the
<code>chol()</code> method.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_x">x</code></td>
<td>

<dl>
<dt>For <code>chol()</code>:</dt><dd><p>One of the sparse matrix classes,
<code>"matrix.csr"</code> or <code>"matrix.csc"</code>;</p>
</dd>
<dt>For <code>{back,forward,}solve()</code>:</dt><dd><p>vector or regular matrix of
right-hand-side(s) of a system of linear equations.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_b">b</code></td>
<td>
<p>vector or matrix right-hand-side(s) to solve for.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_k">k</code></td>
<td>
<p>inherited from the generic; not used here.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_pivot">pivot</code></td>
<td>
<p>inherited from the generic; not used here.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_nsubmax">nsubmax</code>, <code id="SparseM.solve_+3A_nnzlmax">nnzlmax</code>, <code id="SparseM.solve_+3A_tmpmax">tmpmax</code></td>
<td>
<p>positive integer numbers with smart
defaults; do <em>not</em> set unless you know what you are doing!</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_eps">eps</code></td>
<td>
<p>positive tolerance for checking symmetry; change with caution.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_tiny">tiny</code></td>
<td>
<p>positive tolerance for checking diagonal entries to be
&ldquo;essentially zero&rdquo; and hence to be replaced by <code>Large</code>, during
Cholesky decomposition.  Chaning this value may help in close to
singular cases, see &lsquo;Examples&rsquo;.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_large">Large</code></td>
<td>
<p>large positive number, &ldquo;essentially infinite&rdquo;, to
replace tiny diagonal entries during Cholesky.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_warnonly">warnOnly</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>; when set to true, a result is
returned with a <code><a href="base.html#topic+warning">warning</a></code> instead of an error (via
<code><a href="base.html#topic+stop">stop</a>()</code>); notably in close to singular cases.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_cachekb">cacheKb</code></td>
<td>
<p>a positive integer, specifying an approximate size of the machine's
cache memory in kilo (1024) bytes (&lsquo;Kb&rsquo;); used to be hard wired to 64.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_level">level</code></td>
<td>
<p>level of loop unrolling while performing numerical
factorization; an integer in <code>c(1, 2, 4, 8)</code>; used to be hard wired to 8.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_upper.tri">upper.tri</code>, <code id="SparseM.solve_+3A_transpose">transpose</code></td>
<td>
<p>inherited from the generic; not used here.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_twice">twice</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> flag:  If true, <code>backsolve()</code>
solves twice, see below.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_drop">drop</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> flag:  If true, <code>backsolve()</code>
returns <code><a href="base.html#topic+drop">drop</a>(.)</code>, i.e., a vector instead of a column-1 matrix.</p>
</td></tr>
<tr><td><code id="SparseM.solve_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chol</code> performs a Cholesky decomposition of
a symmetric positive definite sparse matrix <code>a</code> of class
<code>matrix.csr</code> using the block sparse Cholesky algorithm of Ng and
Peyton (1993).  The structure of the resulting <code>matrix.csr.chol</code>
object is relatively complicated.  If necessary it can be coerced back
to a <code>matrix.csr</code> object as usual with <code>as.matrix.csr</code>.
<code>backsolve</code> does triangular back-fitting to compute
the solutions of a system of linear equations.  For systems of linear equations
that only vary on the right-hand-side, the result from <code>chol</code>
can be reused.  Contrary to the behavior of <code>backsolve</code> in base R,
the default behavior of  <code>backsolve(C,b)</code> when C is a <code>matrix.csr.chol</code> object
is to produce a solution to the system <code class="reqn">Ax = b</code> where <code>C &lt;- chol(A)</code>, see
the example section.  When the flag <code>twice</code> is <code>FALSE</code> then backsolve
solves the system <code class="reqn">Cx = b</code>, up to a permutation  &ndash; see the comments below.
The command <code>solve</code> combines <code>chol</code> and <code>backsolve</code>, and will
compute the inverse of a matrix if the right-hand-side is missing.
The determinant of the Cholesky factor is returned providing a
means to efficiently compute the determinant of sparse positive
definite symmetric matrices.
</p>
<p>There are several integer storage parameters that are set by default in the call
to the Cholesky factorization, these can be overridden in any of the above
functions and will be passed by the usual &quot;dots&quot; mechanism.  The necessity
to do this is usually apparent from error messages like:  Error
in local(X...) increase tmpmax.   For example, one can use,
<code>solve(A,b, tmpmax = 100*nrow(A))</code>.  The current default for tmpmax
is <code>50*nrow(A)</code>. Some experimentation may be needed to
select appropriate values, since they are highly problem dependent.  See
the code of chol() for further details on the current defaults.
</p>


<h3>Note</h3>

<p>There is no explicit checking for positive definiteness of the matrix
so users are advised to ensure that this condition is satisfied.
Messages such as &quot;insufficient space&quot; may indicate that one is trying
to factor a singular matrix.
Because the sparse Cholesky algorithm re-orders the positive
definite sparse matrix <code>A</code>, the value of
<code>x &lt;- backsolve(C, b)</code> does <em>not</em> equal the solution to the
triangular system <code class="reqn">Cx = b</code>, but is instead the solution to the
system <code class="reqn">CPx = Pb</code> for some permutation matrix <code class="reqn">P</code>
(and analogously for <code>x &lt;- forwardsolve(C, b)</code>).  However, a
little algebra easily shows that
<code>backsolve(C, forwardsolve(C, b), twice = FALSE)</code> <em>is</em> the solution
to the equation <code class="reqn">Ax=b</code>.  Finally, if <code>C &lt;- chol(A)</code>  for some
sparse covariance matrix <code>A</code>, and z is a conformable standard normal vector,
then the product  <code>y &lt;- as.matrix.csr(C) %*% z</code> is normal with covariance
matrix <code>A</code> irrespective of the permutation of the Cholesky factor.
</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002)
SparseM: A Sparse Matrix Package for <span class="rlang"><b>R</b></span>. <a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>
<p>Ng, E. G. and B. W. Peyton (1993)
Block sparse Cholesky algorithms on advanced uniprocessor computers.
<em>SIAM J. Scientific Computing</em> <b>14</b>, 1034&ndash;1056.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slm">slm</a>()</code> for a sparse version of <span class="pkg">stats</span> package's <code><a href="stats.html#topic+lm">lm</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lsq)
class(lsq) # -&gt; [1] "matrix.csc.hb"
model.matrix(lsq)-&gt;design.o
class(design.o) # -&gt; "matrix.csr"
dim(design.o) # -&gt; [1] 1850  712
y &lt;- model.response(lsq) # extract the rhs
length(y) # [1] 1850

X &lt;- as.matrix(design.o)
c(object.size(X) / object.size(design.o)) ## X is 92.7 times larger

t(design.o) %*% design.o -&gt; XpX
t(design.o) %*% y -&gt; Xpy
chol(XpX) -&gt; chol.o

determinant(chol.o)

b1 &lt;- backsolve(chol.o,Xpy) # least squares solutions in two steps
b2 &lt;- solve(XpX,Xpy)        # least squares estimates in one step
b3 &lt;- backsolve(chol.o, forwardsolve(chol.o, Xpy),
                twice = FALSE) # in three steps
## checking that these three are indeed equal :
stopifnot(all.equal(b1, b2), all.equal(b2, b3))
</code></pre>

<hr>
<h2 id='summary.mslm-class'>Class &quot;summary.mslm&quot; </h2><span id='topic+summary.mslm-class'></span>

<h3>Description</h3>

<p>Sparse version of <code>summary.lm</code></p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "summary.mslm")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='summary.slm-class'>Class &quot;summary.slm&quot; </h2><span id='topic+summary.slm-class'></span>

<h3>Description</h3>

<p>Sparse version of <code>summary.lm</code></p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(x = "summary.slm")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='triogramX'>A Design Matrix for a Triogram Problem</h2><span id='topic+triogramX'></span><span id='topic+X'></span>

<h3>Description</h3>

<p>This is a design matrix arising from a bivariate smoothing
problem using penalized triogram fitting.  It is used in the SparseM vignette
to illustrate the use of the sparse matrix image function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(triogramX)</code></pre>


<h3>Format</h3>

<p>A 375 by 100 matrix stored in compressed sparse row format</p>


<h3>References</h3>

<p>Koenker, R and Ng, P. (2002).  SparseM:  A Sparse Matrix Package for <span class="rlang"><b>R</b></span>,<br />
<a href="http://www.econ.uiuc.edu/~roger/research/home.html">http://www.econ.uiuc.edu/~roger/research/home.html</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
