<!DOCTYPE html><html lang="en"><head><title>Help for package ForIT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ForIT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ForIT'><p>ForIT: A package that implements as R functions the INFC-2005 equations estimating single tree volume and phytomass .</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#ForIT_DataBase'><p>'ForIT'-package Database - Ver.2</p></a></li>
<li><a href='#ForIT_test_data'><p>'ForIT'-package TEST-data - Ver.2</p></a></li>
<li><a href='#INFC_CVgrid'><p>'ForIT'-package Auxiliary pre-computed data - Ver.2</p></a></li>
<li><a href='#INFCdomain'><p>The range of applicability of <code>INFCvpe()</code> function</p></a></li>
<li><a href='#INFCtabulate'><p>Reproduce the tables that Tabacchi et al. published in 2011</p></a></li>
<li><a href='#INFCvpe'><p>Estimate bole volume or tree phytomass for individual stems, with associated accuracy info</p></a></li>
<li><a href='#INFCvpeSUM'><p>Estimate tree bole volume or phytomass for stems groups, with associated accuracy info</p></a></li>
<li><a href='#PlottingINFCaccuracy'><p>Plotting the accuracy and reliability region (or 'domain') of the volume and</p>
phytomass estimation functions</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Functions to Estimate Tree Volume and Phytomass in the Italian
Forest Inventory 2005</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tabacchi et al. (2011) published a very detailed study producing a uniform system of functions to estimate tree volume and
    phytomass components (stem, branches, stool). The estimates of the 2005 Italian forest inventory (<a href="https://www.inventarioforestale.org/it/">https://www.inventarioforestale.org/it/</a>) 
    are based on these functions. The study documents the domain of applicability of each function and the equations to quantify estimates
    accuracies for individual estimates as well as for aggregated estimates. This package makes the functions available in the R environment. 
    Version 2 exposes two distinct functions for individual and summary estimates. To facilitate access to the functions, tree species 
    identification is now based on EPPO species codes (<a href="https://data.eppo.int/">https://data.eppo.int/</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, dplyr, purrr, tibble, tidyr, RColorBrewer, metR,
rlang, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix, testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/NuoroForestrySchool/ForIT.git">https://gitlab.com/NuoroForestrySchool/ForIT.git</a>, DOI:
10.5281/zenodo.5790157</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-26 18:57:50 UTC; nicolapuletti</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicola Puletti <a href="https://orcid.org/0000-0002-2142-959X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mirko Grotti [aut],
  Roberto Scotti <a href="https://orcid.org/0000-0001-7394-4473"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicola Puletti &lt;nicola.puletti@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-26 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ForIT'>ForIT: A package that implements as R functions the INFC-2005 equations estimating single tree volume and phytomass .</h2><span id='topic+ForIT'></span><span id='topic+ForIT-package'></span>

<h3>Description</h3>

<p>The ForIT package provides two main functions, estimating respectively individual and summary
values, and some accessory functions, facilitating package use and documenting its content
</p>


<h3>References</h3>

<p>Tabacchi G., Di Cosmo L., Gasparini P., Morelli S., 2011a. <em>Stima
del volume e della fitomassa delle principali specie forestali italiane.
Equazioni di previsione, tavole del volume e tavole della fitomassa arborea
epigea. Stima del volume e della fitomassa delle principali specie
forestali italiane. Equazioni di previsione, tavole del volume e tavole
della fitomassa arborea epigea</em>. 412 pp.
</p>
<p>Tabacchi G., Di Cosmo L., Gasparini P., 2011b. <em>Aboveground tree
volume and phytomass prediction equations for forest species in Italy</em>.
European Journal of Forest Research 130: 6 911-934
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='ForIT_DataBase'>'ForIT'-package Database - Ver.2</h2><span id='topic+ForIT_DataBase'></span><span id='topic+INFCspecies'></span><span id='topic+INFCcatalog'></span><span id='topic+Quantities'></span><span id='topic+INFCparam'></span><span id='topic+INFCf_domains'></span>

<h3>Description</h3>

<p>The package exposes 5 tightly interconnected tibbles:
</p>
<p><code>INFCspecies</code>, <code>INFCcatalog</code>, <code>Quantities</code>, <code>INFCparam</code>, <code>INFCf_domains</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INFCspecies

INFCcatalog

Quantities

INFCparam

INFCf_domains
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 44 rows and 3 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 26 rows and 4 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 5 rows and 2 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 130 rows and 5 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 617 rows and 4 columns.
</p>


<h3>Details</h3>

<p><img src="../help/figures/ForITDBschema.png" width="50%" alt="Figure: ForIT-DBschema" />

</p>
<p><strong>Tables columns</strong>
</p>
<p><code>INFCspecies</code>
</p>

<ul>
<li> <p><code>EPPOcode [PK]</code>: species code, adopting <a href="https://gd.eppo.int/search">EPPO</a> database
</p>
</li>
<li> <p><code>pag</code>: section page number in the original reference (Tabacchi et al., 2011a)
</p>
</li>
<li> <p><code>PrefName</code>: EPPO preferred name for the species
</p>
</li></ul>

<p><code>INFCcatalog</code>
</p>

<ul>
<li> <p><code>pag [PK]</code>: section page number in the original reference (Tabacchi et al., 2011a)
</p>
</li>
<li> <p><code>n_oss</code>: number of sample trees for the section
</p>
</li>
<li> <p><code>n_par</code>: number of parameters in the equations for the section
</p>
</li>
<li> <p><code>section</code>: section name (species or species group)
</p>
</li></ul>

<p><code>Quantities</code>
</p>

<ul>
<li> <p><code>quantity [PK]</code>: code of the estimated quantity
</p>
</li>
<li> <p><code>quantity_definition</code>: estimated quantity definition and measurement units
</p>
</li></ul>

<p><code>INFCparam</code>
</p>

<ul>
<li> <p><code>pag [PK]</code>: section page number in the original reference (Tabacchi et al., 2011a)
</p>
</li>
<li> <p><code>quantity [PK]</code>: code of the estimated quantity (see Quantities)
</p>
</li>
<li> <p><code>wrv</code>: weighted residual variance
</p>
</li>
<li> <p><code>bm</code>: functions coefficients (a list of arrays)
</p>
</li>
<li> <p><code>vcm</code>: variance-covariance matrices (a list of 'dspMatrix')
</p>
</li></ul>

<p><code>INFCf_domains</code>
</p>

<ul>
<li> <p><code>pag [PK]</code>: section page number in the original reference (Tabacchi et al., 2011a)
</p>
</li>
<li> <p><code>htot.m [PK]</code>: tree height class [m] (class width 1 m)
</p>
</li>
<li> <p><code>dbh.min</code>: minimum tree diameter class [cm] (class width 1 cm)
</p>
</li>
<li> <p><code>dbh.max</code>: maximum tree diameter class [cm] (class width 1 cm)
</p>
</li></ul>

<p>Columns <code>bm</code> and <code>vcm</code> are lists, the dimensions of the arrays and
matrices they store vary depending on <code>n_par</code>.<br />
Matrices in <code>vcm</code> are symmetric, stored as &quot;dspMatrix&quot; class objects.<br />
Database schema is defined, verified and illustrated using package <code>dm</code>
</p>
<div class="sourceCode"><pre>library(dm)
ForIT_DB &lt;- dm(INFCcatalog,
               INFCspecies,
               Quantities,
               INFCparam,
               INFCf_domains) %&gt;%
  dm_add_pk(INFCcatalog, pag, check = TRUE) %&gt;%

  dm_add_pk(INFCspecies, EPPOcode, check = TRUE) %&gt;%
  dm_add_fk(INFCspecies, pag, INFCcatalog, check = TRUE) %&gt;%

  dm_add_pk(Quantities, quantity, check = TRUE) %&gt;%

  dm_add_pk(INFCparam, c(pag, quantity), check = TRUE) %&gt;%
  dm_add_fk(INFCparam, pag, INFCcatalog, check = TRUE) %&gt;%
  dm_add_fk(INFCparam, quantity, Quantities, check = TRUE) %&gt;%

  dm_add_pk(INFCf_domains, c(pag, htot.m), check = TRUE) %&gt;%
  dm_add_fk(INFCf_domains, pag, INFCcatalog, check = TRUE)

dm_examine_constraints(ForIT_DB)

dm_draw(ForIT_DB, rankdir = "BT", view_type = "all", column_types = T)
</pre></div>

<hr>
<h2 id='ForIT_test_data'>'ForIT'-package TEST-data - Ver.2</h2><span id='topic+ForIT_test_data'></span>

<h3>Description</h3>

<p>A tiny test dataset including example data displayed in Tabacchi et al. (2011),
the basic reference for ForIT package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ForIT_test_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 16 rows and 5 variables:
</p>


<h3>Details</h3>

<p>The dataset is produced by the following code.
</p>
<div class="sourceCode"><pre>ForIT_test_data &lt;- dplyr::tribble(
  ~UC, ~IdF, ~specie, ~d130, ~h_dendro,
  # UC: Plot Id (Unità Campionaria)
  # IdF: Stem ID (Identificativo Fusto)
  # specie: EPPO species code (see https://gd.eppo.int/)
  #  - ACRCA: Acer campestre
  #  - ABIAL: Abies alba
  #  - FAUSY: Fagus sylvatica
  # d130: trunk diameter at breast height [cm]
  # h_dendro: tree height [m]
 # Example data in Tabacchi et al. (2011) pag. 25
  "U1","01","ACRCA",10,7,
  "U1","02","ACRCA",15,9,
  "U1","03","ACRCA",20,12,
  "U1","04","ACRCA",30,20,
  "U1","05","ACRCA",32,21,
  "U1","06","ACRCA",24,18,
  "U1","07","ACRCA",36,21,
  "U1","08","ACRCA",40,22,
  "U1","09","ACRCA",8,8,
  "U1","10","ACRCA",18,12,

 # Example continuation, pag. 27
  "U2","01","ABIAL",38,21,
  "U2","02","ABIAL",52,28,
  "U2","03","FAUSY",25,16,
  "U2","04","FAUSY",30,18,
  "U2","05","FAUSY",12,10,

 # Extra lines, to test for 'out of domain'
  "U0","01","ACRCA",22,14,   # pag. 24
  "U0","02","ACRCA",30,10
 )
</pre></div>

<hr>
<h2 id='INFC_CVgrid'>'ForIT'-package Auxiliary pre-computed data - Ver.2</h2><span id='topic+INFC_CVgrid'></span>

<h3>Description</h3>

<p>A large dataset used by 'INFCaccuracyPlot0()' to speed the production of a
fine resolution CV surface for the plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INFC_CVgrid
</code></pre>


<h3>Format</h3>

<p>A data frame with 167560 rows and 7 variables:
</p>

<dl>
<dt>pag</dt><dd><p>see 'INFCcatalog' primary key</p>
</dd>
<dt>quantity</dt><dd><p>see 'Quantities'</p>
</dd>
<dt>dbh</dt><dd><p>trunk diameter at breast height (dbh), in cm</p>
</dd>
<dt>h_tot</dt><dd><p>tree height, in m</p>
</dd>
<dt>cv_ie</dt><dd><p>coefficient of variation for an individual estimate</p>
</dd>
<dt>cv_ea</dt><dd><p>coefficient of variation for the estimate of an average</p>
</dd>
<dt>est</dt><dd><p>estimated value for the selected 'quantity'.
See 'INFCvpe()' for more details</p>
</dd>
<dt>n_par</dt><dd><p>number of parameters that the function requires</p>
</dd>
<dt>inD</dt><dd><p>is the (dbh, htot) point within the function domain?</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset is produced by the following code.
</p>
<div class="sourceCode"><pre> Populate_INFC_CVgrid &lt;- function() {
 INFCcatalog %&gt;%
   select(pag) %&gt;%
   inner_join(INFCspecies %&gt;%
                select(pag, EPPOcode),
              by = "pag") %&gt;%
   group_by(pag) %&gt;%
   summarise(EPPOcode = first(EPPOcode),
             .groups = "drop") %&gt;%
   inner_join(Quantities %&gt;% select(quantity), by = character()) %&gt;%
   mutate(grid.k = pmap(list(pag, EPPOcode, quantity), compute_grid0)) %&gt;%
   select(-EPPOcode) %&gt;%
   unnest(cols = c(grid.k)) %&gt;%
   return()
 }
</pre></div>

<hr>
<h2 id='INFCdomain'>The range of applicability of <code>INFCvpe()</code> function</h2><span id='topic+INFCdomain'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> containing the &quot;range of applicability&quot; (or &quot;domain&quot;)
of <code>INFCvpe()</code> function
</p>


<h3>Format</h3>

<p>A data frame with 18563 observations on the following 2 variables.
</p>

<dl>
<dt><code>key</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>in.range</code></dt><dd><p>a factor with levels  <code>y</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Tabacchi G., Di Cosmo L., Gasparini P., Morelli S., 2011a.
<em>Stima del volume e della fitomassa delle principali specie forestali
italiane. Equazioni di previsione, tavole del volume e tavole della
fitomassa arborea epigea. Stima del volume e della fitomassa delle
principali specie forestali italiane. Equazioni di previsione, tavole del
volume e tavole della fitomassa arborea epigea</em>. 412 pp. [ITA, ita]
</p>

<hr>
<h2 id='INFCtabulate'>Reproduce the tables that Tabacchi et al. published in 2011</h2><span id='topic+INFCtabulate'></span>

<h3>Description</h3>

<p>The tables published in the work on which this package is based, convey a very
relevant part of the information produced: printed numbers serve as reference to
verify that coded functions return expected results and, more specifically, empty
spaces in the printed tables signal function applicability domain. In other words,
measurement data used to estimate function coefficients values, cover only the
portion of the <code>(dbh, htot)</code> plane where numbers are printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INFCtabulate(
  EPPOcode,
  quantity = "vol",
  dbh.by = 5,
  htot.by = 3,
  digits = 1,
  print_tab = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="INFCtabulate_+3A_eppocode">EPPOcode</code></td>
<td>
<p>tree species code defined by the
EPPO database <a href="https://gd.eppo.int/search">https://gd.eppo.int/search</a>.
Lookup 'INFCspecies' dataframe to retrieve recognized codes.</p>
</td></tr>
<tr><td><code id="INFCtabulate_+3A_quantity">quantity</code></td>
<td>
<p>for each species (or species group) different
quantities can be estimated. Quantity's definitions and Ids are exposed by
the 'Quantities' dataframe. Default value is &quot;vol&quot;, estimation of timber volume.</p>
</td></tr>
<tr><td><code id="INFCtabulate_+3A_dbh.by">dbh.by</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="INFCtabulate_+3A_htot.by">htot.by</code></td>
<td>
<p>increment value between rows
(respectively columns) expressed in 'cm' (respectively 'm') for <code>dbh</code>
(respectively total height, <code>htot</code>). Default 5 cm (respectively 1 m).</p>
</td></tr>
<tr><td><code id="INFCtabulate_+3A_digits">digits</code></td>
<td>
<p>number of decimal digits to expose in the table.
Default one decimal digit.</p>
</td></tr>
<tr><td><code id="INFCtabulate_+3A_print_tab">print_tab</code></td>
<td>
<p>defaults to TRUE in order to produce a text output. If set
to FALSE no printing will occur (see 'return')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function principal output is the printout of the volume or phytomass tables.
If print_tab = FALSE, the function will only return a tibble with a list column
containing the tabulation of the required estimation equation/s.
Using default values, tables will be identical (or anyway similar) to the
corresponding published tables, with white (NA) cells delimiting the domain of
applicability of the equation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  INFCtabulate(c("ABIAL", "ACRCA"),
                quantity = "vol",
                dbh.by = 5,
                htot.by = 3,
                digits = 1)
  # EPPO code:  ABIAL  - pag =  33  - quantity =  vol
  #     htot.m
  # dbh.cm    7    10    13    16     19     22     25     28     31
  # 9  23.2  32.4    NA    NA     NA     NA     NA     NA     NA
  # 14   NA  77.9 100.2    NA     NA     NA     NA     NA     NA
  # 19   NA 142.3 183.3 224.3     NA     NA     NA     NA     NA
  # 24   NA    NA 291.1 356.4  421.8  487.2     NA     NA     NA
  # 29   NA    NA    NA 518.9  614.3  709.8  805.2     NA     NA
  # 34   NA    NA    NA 711.6  842.8  974.0 1105.2 1236.4     NA
  # 39   NA    NA    NA    NA 1107.2 1279.8 1452.5 1625.1 1797.7
  # 44   NA    NA    NA    NA     NA 1627.2 1847.0 2066.7 2286.5
  # 49   NA    NA    NA    NA     NA 2016.3 2288.8 2561.4 2833.9
  # 54   NA    NA    NA    NA     NA     NA 2778.0 3109.0 3439.9
  # 59   NA    NA    NA    NA     NA     NA 3314.4 3709.5 4104.6
  # 64   NA    NA    NA    NA     NA     NA     NA 4363.1 4828.0
  
  
  # ---
  #   EPPO code:  ACRCA  - pag =  231  - quantity =  vol
  # htot.m
  # dbh.cm  7.5  10.5  13.5  16.5   19.5   22.5
  # 9.5  26.8  36.8    NA    NA     NA     NA
  # 14.5   NA  83.6 106.9    NA     NA     NA
  # 19.5   NA 149.7 192.0 234.3  276.6     NA
  # 24.5   NA    NA 302.2 369.0  435.7     NA
  # 29.5   NA    NA    NA 534.2  631.0  727.8
  # 34.5   NA    NA    NA 729.9  862.4  994.8
  # 39.5   NA    NA    NA    NA 1129.9 1303.5
  # ---
  
## End(Not run)

</code></pre>

<hr>
<h2 id='INFCvpe'>Estimate bole volume or tree phytomass for individual stems, with associated accuracy info</h2><span id='topic+INFCvpe'></span>

<h3>Description</h3>

<p>Using the functions developed for INFC 2005 (the 2005 Italian national forest inventory),
stem volume or tree compartment phytomass are estimated for each
<code>(EPPOcode, dbh.cm, htot.m)</code> input tuple.
Accompaining the main value, accuracy estimates are returned, as attributes.
The functions are documented in Tabacchi et al. (2011a)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INFCvpe(EPPOcode, dbh.cm, htot.m, quantity = "vol")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="INFCvpe_+3A_eppocode">EPPOcode</code></td>
<td>
<p>Character vector of tree species code, as defined in EPPO database,
(See <code>INFCspecies()</code> and  <a href="https://gd.eppo.int">https://gd.eppo.int</a> )</p>
</td></tr>
<tr><td><code id="INFCvpe_+3A_dbh.cm">dbh.cm</code></td>
<td>
<p>Numeric vector of stem/s breast height diameter (in cm)</p>
</td></tr>
<tr><td><code id="INFCvpe_+3A_htot.m">htot.m</code></td>
<td>
<p>Numeric vector of tree total height/s (in m). Length equal to dbh.cm vector or one.
In this case same value will be replicated for all dbh.cm entries</p>
</td></tr>
<tr><td><code id="INFCvpe_+3A_quantity">quantity</code></td>
<td>
<p>(default = <code>vol</code>) Character vector specifying required quantity,
one of <code>c("vol", "dw1" : "dw4")</code>. Use <code>qantities()</code> to retrieve
codes definitions. Length equal to dbh.cm vector or one.
In this case same value will be replicated for all dbh.cm entries</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output value will have following added attributes with estimates accuracy evaluations
for each stem:</p>

<ol>
<li> <p><code>pag</code> - page number, referred to original source
</p>
</li>
<li> <p><code>wrv</code> - weighted residual variance
</p>
</li>
<li> <p><code>Var_ea</code> - variance for an estimated average<br />
or variance for 'confidence interval' estimation,
see <code>prediction.lm(.., interval = "confidence")</code>
</p>
</li>
<li> <p><code>Var_ie</code> - variance for an individual estimate<br />
or 'prediction variance', (see <code>prediction.lm(.., interval = "prediction")</code> and
Freese, 1964 - in:Tabacchi, 2011
</p>
</li>
<li> <p><code>InDomain</code> - logical indicating whether the (dbh, htot) point lies
out of the domain explored by the experimental data (see 'INFCtabulate()')
</p>
</li></ol>



<h3>Value</h3>

<p>The functions returns a Numeric vector of the same length
of the <code>dbh.cm</code> argument, with accuracy info as attributes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+INFCvpe_summarise">INFCvpe_summarise()</a></code> and functions related to <code><a href="#topic+INFCvpe_sum">INFCvpe_sum()</a></code> to produce
estimates of aggregates with better accuracy evaluation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># COMPARE WITH Tabacchi (2011a) page 25 ----
(v &lt;- INFCvpe("ACRCA", dbh.cm = 22, htot.m = 14))
# [1] 252.9581
# attr(,"pag")
# [1] 231
# attr(,"wrv")
# [1] 2.271e-05
# attr(,"Var_ea")
# [1] 33.17182
# attr(,"Var_ie")
# [1] 1075.883
# attr(,"InDomain")
# [1] TRUE

# Standard Error of the Estimate
see &lt;- sqrt(attr(v, "Var_ie"))
# Degrees of freedom
df &lt;- INFCcatalog$n_oss[INFCcatalog$pag == attr(v, "pag")] -
      INFCcatalog$n_par[INFCcatalog$pag == attr(v, "pag")]
# confidence level
p &lt;- 95/100
# Confidence Interval Half Width
cihw &lt;- qt(1-(1-p)/2, df) * see
cat(" *** Volume confidence interval (p = ", p*100, "%) is [", round(v, 1),
    " +/- ", round(cihw, 1), "] dm^3\n", sep = "")

# ESTIMATION OF PHYTOMASS ----
Quantities[5,] %&gt;% as.data.frame()
#   quantity         quantity_definition
# 1      dw4 phytomass of the whole tree [kg]
tree_phy &lt;- INFCvpe(c("ACRCA", "ALUCO"),
                    dbh.cm = c(22, 15),
                    htot.m = c(14, 16),
                    quantity = "dw4")
tree_phy
# [1] 185.1291  87.7970
# attr(,"pag")
# [1] 231 245
# attr(,"wrv")
# [1] 3.142e-05 2.104e-05
# attr(,"Var_ea")
# [1] 45.89002  9.12407
# attr(,"Var_ie")
# [1] 1488.5135  281.8072
# attr(,"InDomain")
# [1] TRUE TRUE

# PROCESSING A TALLY DATA-FRAME ----
tst_vol &lt;- ForIT_test_data %&gt;%
  dplyr::mutate(vol = INFCvpe(specie, d130, h_dendro),
                OutOfDomain = !attr(vol, "InDomain"))
tst_vol %&gt;%
  dplyr::filter(OutOfDomain)
tst_vol %&gt;%
  dplyr::filter(UC == "U1")

# SUMS AND direct ACCUARACY AGGREGATION (instead of via ?INFCvpeSUM) ----
df &lt;- function(pag) return(
  INFCcatalog %&gt;%
    dplyr::right_join(tibble::tibble(pag = !!pag), by = "pag") %&gt;%
    dplyr::transmute(df = n_oss - n_par) %&gt;%
    purrr::pluck(1)
)
p &lt;- 95/100
tst_vol %&gt;%
  dplyr::mutate(cihw = qt(1-(1-p)/2,
                          df(attr(vol, "pag"))) *
                  sqrt(attr(vol, "Var_ie"))
  ) %&gt;%
  dplyr::filter(!OutOfDomain) %&gt;%
  dplyr::group_by(specie) %&gt;%
  dplyr::summarise(.groups = "drop",
                   est = sum(vol),
                   cihw = sqrt(sum(cihw^2)),
  ) %&gt;%
  dplyr::left_join(INFCspecies %&gt;% dplyr::select(EPPOcode, pag),
                   by = c("specie" = "EPPOcode")) %&gt;%
  dplyr::left_join(INFCcatalog %&gt;% dplyr::select(pag, section),
                   by = "pag") %&gt;% 
  dplyr::select(-c(specie, pag)) %&gt;% 
  dplyr::rename(specie = section) %&gt;% 
  dplyr::mutate(dplyr::across(c("est", "cihw"), ~round(.x, 1))) %&gt;% 
  dplyr::arrange(specie) %&gt;%
  dplyr::select(specie, est, cihw) -&gt; tab
tab[c(2,1,3),] %&gt;% 
  t()
rm(tst_vol, tab, df)

</code></pre>

<hr>
<h2 id='INFCvpeSUM'>Estimate tree bole volume or phytomass for stems groups, with associated accuracy info</h2><span id='topic+INFCvpeSUM'></span><span id='topic+INFCvpe_summarise'></span><span id='topic+INFCvpe_sum'></span><span id='topic+INFCvpe_ConfInt'></span><span id='topic+INFCvpe_OutOfDomain'></span>

<h3>Description</h3>

<p>Cumulative estimation of the volume or phytomass of groups of trees is just
the summation of the values computed with <code>INFCvpe()</code>, but the computation of
accuracy estimates is improved using these summation functions.<br />
Two approaches are available.
</p>

<ul>
<li><p> Via <code>INFCvpe_summarise()</code> that processes and returns a data frame
</p>
</li>
<li><p> or by following aggregation functions within a standard <code>summarise()</code>:
</p>

<ul>
<li> <p><code>INFCvpe_sum()</code>
</p>
</li>
<li> <p><code>INFCvpe_ConfInt()</code>
</p>
</li>
<li> <p><code>INFCvpe_OutOfDomain()</code>
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>INFCvpe_summarise(
  in.data,
  EPPOcode_C,
  dbh_C,
  h_tot_C,
  quantity = "vol",
  p = 0.95
)

INFCvpe_sum(EPPOcode, dbh, h_tot, quantity = "vol")

INFCvpe_ConfInt(EPPOcode, dbh, h_tot, quantity = "vol", p = 0.95)

INFCvpe_OutOfDomain(EPPOcode, dbh, h_tot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="INFCvpeSUM_+3A_in.data">in.data</code></td>
<td>
<p>A dataframe (or tibble) containing tally data to be matched with
&quot;EPPOcode_C&quot;, &quot;dbh_C&quot; and &quot;htot_C&quot; arguments</p>
</td></tr>
<tr><td><code id="INFCvpeSUM_+3A_eppocode_c">EPPOcode_C</code></td>
<td>
<p>A string, the name of the column in <code>in.data</code> with the
species EPPO codes</p>
</td></tr>
<tr><td><code id="INFCvpeSUM_+3A_dbh_c">dbh_C</code></td>
<td>
<p>A string, the name of the column in <code>in.data</code> with the
breast height diameter values</p>
</td></tr>
<tr><td><code id="INFCvpeSUM_+3A_h_tot_c">h_tot_C</code></td>
<td>
<p>A string, the name of the column in <code>in.data</code> with the
tree total height values</p>
</td></tr>
<tr><td><code id="INFCvpeSUM_+3A_quantity">quantity</code></td>
<td>
<p>(default = <code>"vol"</code>) A character vector specifying required
quantity/ies: <code>c("vol", "dw1" : "dw4")</code>.
Use <code>qantities()</code> to decode definitions.
</p>

<ul>
<li><p> for <code>INFCvpe_summarise()</code>, if <code>length(unique(quantity)) &gt; 1</code>,
rows in in.data will be replicated for each value.
</p>
</li>
<li><p> for <code>INFCvpe_SUM functions</code>, length(quantity) must be 1
</p>
</li></ul>
</td></tr>
<tr><td><code id="INFCvpeSUM_+3A_p">p</code></td>
<td>
<p>(default <code>p = 95%</code>) probability used to compute <code>cihw</code>
(with length = 1 or length = length(dbh))
</p>
<p>OPZIONE 2  <code>INFCvpe_SUM functions</code>:</p>
</td></tr>
<tr><td><code id="INFCvpeSUM_+3A_eppocode">EPPOcode</code></td>
<td>
<p>A character vector with the species EPPO codes
(with length = 1 or length = length(dbh))</p>
</td></tr>
<tr><td><code id="INFCvpeSUM_+3A_dbh">dbh</code></td>
<td>
<p>A numeric vector with the brest height diameter values</p>
</td></tr>
<tr><td><code id="INFCvpeSUM_+3A_h_tot">h_tot</code></td>
<td>
<p>A numeric vector with the tree total height values
(with length = 1 or length = length(dbh))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions developed following Tabacchi et al. (2011), pages 23-26.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>INFCvpe_summarise()</code> returns a dataframe (tibble) with
the grouping columns defined with <code>group_by()</code>, and the following columns:
</p>

<ul>
<li> <p><code>quantity</code>: as additional grouping column,
</p>
</li>
<li> <p><code>n</code> : number of trees in the group,
</p>
</li>
<li> <p><code>n_out</code> : the number of <code>(dbh, htot)</code> pairs that are 'out of the domain',
</p>
</li>
<li> <p><code>est</code> : the estimated value,
</p>
</li>
<li> <p><code>cihw</code> : confidence interval half width
</p>
</li>
<li> <p><code>p</code>: probability used computing <code>cihw</code>
</p>
</li></ul>

</li>
<li> <p><code>INFCvpe_SUM</code> - the functions of this family return a numeric vector,
aggregating rows within the same group,
</p>

<ul>
<li> <p><code>INFCvpe_sum()</code> returns the sum of the estimated quantities,
</p>
</li>
<li> <p><code>INFCvpe_ConfInt()</code> returns 'confidence interval half width',
</p>
</li>
<li> <p><code>INFCvpe_OutOfDomain()</code> returns the number of 'out of domain'
<code>(dhb, h_tot)</code> pairs included in the summation
</p>
</li></ul>

</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+INFCvpe">INFCvpe()</a></code> to compute individual estimates, with detailed accuracy evaluation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Sezione &lt;- function(EPPOcodes){
  # retrive 'Sezione' name, decoding EPPO codes
  INFCspecies %&gt;% 
    dplyr::filter(EPPOcode %in% EPPOcodes) %&gt;%
    dplyr::left_join(INFCcatalog,by = "pag")%&gt;% 
    dplyr::select(section) %&gt;% 
    purrr::pluck(1)
}

tst &lt;- ForIT_test_data %&gt;%
  dplyr::filter(UC != "U0") 
# select Tabachi et al. example data

tst %&gt;%
  dplyr::group_by(specie) %&gt;%
  INFCvpe_summarise("specie", "d130", "h_dendro") %&gt;%
  dplyr::ungroup() %&gt;%
  dplyr::mutate(specie = Sezione(specie),
                dplyr::across(c("est", "cihw"), ~round(.x, 1))
  ) %&gt;%
  dplyr::select(specie, est, cihw) %&gt;%
  dplyr::arrange(specie) %&gt;%
  dplyr::slice(2, 1, 3) %&gt;% 
  t() %&gt;% 
  provideDimnames(base = list(dimnames(.)[[1]], ""), unique=FALSE)
# Compare ForIT (ver 2) output
## specie "Aceri"  "Abete bianco" "Faggio"
## est    "4623.0" "4044.2"       "1079.4"
## cihw   "567.5"  "661.2"        "275.4" 
# with 'Tabella 2' in Tabacchi et al. (2011, pag. 27)
## specie "aceri"  "abete bianco" "faggio"
## est    "4623.0" "4044.2"       "1079.4"
## cihw   "567.4"  "662.4"        "279.2"

# Using 'INFCvpe_summarise()'

## Overall totals
tst %&gt;%
  INFCvpe_summarise("specie", "d130", "h_dendro", quantity = c("vol", "dw4"))

## Group by dbh class ('cld')
tst %&gt;%
  dplyr::mutate(cld = ceiling(d130/5)*5) %&gt;%
  dplyr::group_by(UC, specie, cld) %&gt;%
  INFCvpe_summarise("specie", "d130", "h_dendro")

## Group by sampling unit ('UC')
tst %&gt;%
  dplyr::group_by(UC) %&gt;%
  INFCvpe_summarise("specie", "d130", "h_dendro", quantity = "dw4")

# Using 'INFCvpeSUM' aggregation functions

## Esitmate 'dw4' phytomass, by sampling unit ('UC')
tst %&gt;%
  dplyr::group_by(UC) %&gt;%
  dplyr::summarise(
    n_stems = dplyr::n(),
    OoD = INFCvpe_OutOfDomain(specie, d130, h_dendro),
    dw4 = INFCvpe_sum(specie, d130, h_dendro, quantity = "dw4"),
    dw4_ConfInt = INFCvpe_ConfInt(specie, d130, h_dendro, quantity = "dw4")
  )

## Esitmate volume, by sampling unit ('UC')
tst %&gt;%
  dplyr::group_by(UC) %&gt;%
  dplyr::summarise(
    n_stems = dplyr::n(),
    OoD = INFCvpe_OutOfDomain(specie, d130, h_dendro),
    vol = INFCvpe_sum(specie, d130, h_dendro),
    vol_ConfInt = INFCvpe_ConfInt(specie, d130, h_dendro)
  )

rm(tst, Sezione)

## End(Not run)
</code></pre>

<hr>
<h2 id='PlottingINFCaccuracy'>Plotting the accuracy and reliability region (or 'domain') of the volume and
phytomass estimation functions</h2><span id='topic+PlottingINFCaccuracy'></span><span id='topic+INFCaccuracyPlot'></span><span id='topic+INFCaccuracyPlot0'></span><span id='topic+compute_grid0'></span>

<h3>Description</h3>

<p>Volume and phytomass functions are tabulated in Tabacchi et al. (2011a).
The tabulation covers a limited region of the <code>dbh</code> by <code>h_tot</code> rectangle.
This region is the &quot;domain&quot; of the reliable estimates, based on the
distribution of the sample trees used to calibrate the functions.
The coefficient of variation (CV = standard_deviation / estimate) is computed
and plotted (as 'filled contours') for the whole rectangular area,
the limits of the region of reliable estimates (the &quot;domain&quot;), is
superimposed as a light colored line. Function output is a <code>ggplot</code> object that can be used
by its self or as a background on top of which the user can plot his/her data to
verify eventual accuracy or reliability problems.<br />
Two functions are available.
</p>

<ul>
<li> <p><code>INFCaccuracyPlot()</code> - allows the plots to be fully customized but, beware,
all values required for the 'fill' will be computed and,
at finer resolution, the process can be slow.
</p>
</li>
<li> <p><code>INFCaccuracyPlot0()</code> - produces, much faster, the plots at the finest
resolution, using pre-calculated values stored in
a specific auxiliary dataframe (see <code><a href="#topic+INFC_CVgrid">INFC_CVgrid</a></code>),
necessarily leaving less customization freedom.
</p>
</li></ul>

<p>(** <code>compute_grid0()</code> - is an internal function exported for the sake of
the <code>Populate_INFC_CVgrid()</code> function **)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INFCaccuracyPlot(
  EPPOcod,
  quantity = "vol",
  ie.Var = FALSE,
  cv.ul = 0.1,
  fixed = TRUE,
  plot.est = FALSE,
  dbh.step = 5,
  htot.step = dbh.step,
  dbh.buf = 1,
  htot.buf = dbh.buf
)

INFCaccuracyPlot0(
  EPPOcod,
  quantity = "vol",
  ie.Var = FALSE,
  cv.ul = 0.1,
  fixed = TRUE,
  plot.est = FALSE
)

compute_grid0(pag, EPPOcod, quantity)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlottingINFCaccuracy_+3A_eppocod">EPPOcod</code></td>
<td>
<p>A string, one of the EPPO tree species codes listed in
<code>INFCspecies</code> table (Reference: <a href="https://gd.eppo.int">https://gd.eppo.int</a> )</p>
</td></tr>
<tr><td><code id="PlottingINFCaccuracy_+3A_quantity">quantity</code></td>
<td>
<p>(optional) A string specifying the quantity to be estimated,
one of <code>c("vol", "dw1" : "dw4")</code>.
Lookup <code>Qantities</code> table to retrieve codes definitions.
Defaults to &quot;vol&quot;.</p>
</td></tr>
<tr><td><code id="PlottingINFCaccuracy_+3A_ie.var">ie.Var</code></td>
<td>
<p>(optional) Logical. Choose variance estimator:
</p>

<ul>
<li> <p><code>TRUE</code> = variance for an 'individual estimate'
</p>
</li>
<li> <p><code>FALSE</code> = variance for the 'estimate of an average' value
Default <code>ie.Va = FALSE</code></p>
</li></ul>
</td></tr>
<tr><td><code id="PlottingINFCaccuracy_+3A_cv.ul">cv.ul</code></td>
<td>
<p>(optional) Numeric. Cutoff CV level for the plot. Defaults to 0.1</p>
</td></tr>
<tr><td><code id="PlottingINFCaccuracy_+3A_fixed">fixed</code></td>
<td>
<p>(optional) Logical. Contour plot breaks:
</p>

<ul>
<li> <p><code>TRUE</code> = break levels are fixed
</p>
</li>
<li> <p><code>FALSE</code> = breaks are tailored to the specific case
(in order to split the values within the range of interest [0, <code>cv.ul</code>],
into equally numerous bins)
Default <code>fixed = TRUE</code></p>
</li></ul>
</td></tr>
<tr><td><code id="PlottingINFCaccuracy_+3A_plot.est">plot.est</code></td>
<td>
<p>(optional) Logical. Add the 'estimated quantity' layer as
contour lines. Default <code>plot.est = FALSE</code></p>
</td></tr>
<tr><td><code id="PlottingINFCaccuracy_+3A_dbh.step">dbh.step</code></td>
<td>
<p>(optional) Numeric. Computation with smaller step produces a
plot with better resolution but increases consistently computation time
(see <code>INFCaccuracyPlot0()</code>). To reduce computation time, the step
defaults to 5.</p>
</td></tr>
<tr><td><code id="PlottingINFCaccuracy_+3A_htot.step">htot.step</code></td>
<td>
<p>(optional) Numeric. As for dbh.</p>
</td></tr>
<tr><td><code id="PlottingINFCaccuracy_+3A_dbh.buf">dbh.buf</code></td>
<td>
<p>(optional) Numeric. Extra space in the plot beyond the 'domain'.
Default: 1</p>
</td></tr>
<tr><td><code id="PlottingINFCaccuracy_+3A_htot.buf">htot.buf</code></td>
<td>
<p>(optional) Numeric. As for dbh.</p>
</td></tr>
<tr><td><code id="PlottingINFCaccuracy_+3A_pag">pag</code></td>
<td>
<p>for the internal function <code>compute_grid0()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>INFCaccuracyPlot</code> The function returns a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
INFCaccuracyPlot("FRXAN") # 'INFCaccuracyPlot()' can be slow because
#       it computes all the CV values needed to fill backgroud plot,
#              hence default values are set to a coarser resolution.
\donttest{
  INFCaccuracyPlot("FRXAN",
                   dbh.step = 1,
                   htot.step = 1) 
  # computing with high resolution is slow
}

INFCaccuracyPlot0("FRXAN") 
# 'INFCaccuracyPlot0()' is quick, it uses stored values
INFCaccuracyPlot0("FRXAN", "dw4")
INFCaccuracyPlot0("FRXAN", "dw4", ie.Var = TRUE) 
# deafult fixed break values are not alwais optimal
INFCaccuracyPlot0("FRXAN", "dw4", ie.Var = TRUE, fixed = FALSE, cv.ul=.9) 
# tailoring can improve
INFCaccuracyPlot0("FRXAN", plot.est = TRUE) 
# 'quantity' estimation iso-lines can be superimposed


background &lt;- INFCaccuracyPlot0("ACROP", plot.est = TRUE)
foreground &lt;-  ForIT_test_data %&gt;%
  dplyr::filter(specie == "ACROP") %&gt;%
  dplyr::mutate(vol = INFCvpe(specie, d130, h_dendro)) %&gt;%
  ggplot2::geom_point(map = ggplot2::aes(h_dendro, d130, size = vol))
background + foreground  # Adding a custom foreground
rm(background, foreground)

INFCaccuracyPlot0("ABIAL") 
# high resolution and quick, using pre-calculated backgroung values
INFCaccuracyPlot("ABIAL") 
# default values produce a coarser resolution

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
