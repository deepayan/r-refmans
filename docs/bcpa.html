<!DOCTYPE html><html><head><title>Help for package bcpa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bcpa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bcpa-package'><p>Behavioral Change Point Analysis</p></a></li>
<li><a href='#ChangePointSummary'><p>Obtain summary of BCPA analysis</p></a></li>
<li><a href='#DiagPlot'><p>Diagnostic plot for BCPA</p></a></li>
<li><a href='#GetBestBreak'><p>Find most likely change point in irregular time series</p></a></li>
<li><a href='#GetDoubleL'><p>Obtain log-likelihood and parameter estimates for a given break point.</p></a></li>
<li><a href='#GetL'><p>Obtain likelihood estimates of gappy Gaussian time series</p></a></li>
<li><a href='#GetModels'><p>Model selection at a known breakpoint</p></a></li>
<li><a href='#GetRho'><p>Characteristic time / auto-correlation for irregular time series</p></a></li>
<li><a href='#GetVT'><p>Obtain VT table from Track</p></a></li>
<li><a href='#MakeTrack'><p>Make Track</p></a></li>
<li><a href='#PartitionParameters'><p>Partition parameters</p></a></li>
<li><a href='#PathPlot'><p>Path plot of BCPA output</p></a></li>
<li><a href='#PhasePlot'><p>Phase plot of BCPA output</p></a></li>
<li><a href='#plot.bcpa'><p>Plotting method for BCPA output</p></a></li>
<li><a href='#plot.track'><p>Plot Track</p></a></li>
<li><a href='#Simp'><p>Simulated Chim</p>
(Simp) Data</a></li>
<li><a href='#WindowSweep'><p>Perform window sweep for BCPA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Behavioral Change Point Analysis of Animal Movement</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Eliezer Gurarie &lt;egurarie@esf.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eliezer Gurarie &lt;egurarie@esf.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Behavioral Change Point Analysis (BCPA) is a method of
    identifying hidden shifts in the underlying parameters of a time series,
    developed specifically to be applied to animal movement data which is
    irregularly sampled.  The method is based on: E. Gurarie, R. Andrews and 
    K. Laidre A novel method for identifying behavioural changes in animal 
    movement data (2009) Ecology Letters 12:5 395-408. A development version is 
    on <a href="https://github.com/EliGurarie/bcpa">https://github.com/EliGurarie/bcpa</a>. NOTE: the BCPA method may be useful 
    for any univariate, irregularly sampled Gaussian time-series, but animal 
    movement analysts are encouraged to apply correlated velocity change point 
    analysis as implemented in the smoove package, as of this writing on GitHub 
    at <a href="https://github.com/EliGurarie/smoove">https://github.com/EliGurarie/smoove</a>. An example of a univariate analysis
    is provided in the UnivariateBCPA vignette. </td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>Depends:</td>
<td>plyr</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, lubridate, magrittr, circular, digest, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-27 15:30:10 UTC; elie</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-30 12:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='bcpa-package'>Behavioral Change Point Analysis</h2><span id='topic+bcpa-package'></span><span id='topic+_PACKAGE'></span><span id='topic+bcpa'></span>

<h3>Description</h3>

<p>A collection of functions that allows one to perform the behavioral change
point analysis (BCPA) as described by Gurarie et al. (2009, Ecology Letters,
12: 395-408).  The key features are estimation of discrete changes in
time-series data, notable linear and turning components of gappy velocity
times series extracted from movement data.
</p>


<h3>Details</h3>

<p>For more movement-appropriate change point analysis, users are
encouraged to apply correlated velocity change point analysis as implemented
in the <code>smoove</code> package (as of this writing on GitHub at
<a href="https://github.com/EliGurarie/smoove">https://github.com/EliGurarie/smoove</a>)
which implements methods described in Gurarie et al. 2017.
</p>
<p>There is a fairly detailed vignette - type in <code>vignette("bcpa")</code>, and an
updated vignette <code>vignette("UnivariateBCPA")</code> with a univariate example.
The key analysis function is <code><a href="#topic+WindowSweep">WindowSweep</a></code>, and
reading its documentation is a good way to start using this package.
</p>
<p><code><a href="#topic+WindowSweep">WindowSweep</a></code> uses a suite of functions that might be
useful for more narrow analysis. These functions are all available and
documented, and are listed here hierarchically, from the most fundamental
to the most complex:
</p>

<ul>
<li> <p><code><a href="#topic+GetRho">GetRho</a></code>  maximizes the likelihood to estimate
autocorrelation rho or characteristic time-scale tau.
</p>
</li>
<li> <p><code><a href="#topic+GetDoubleL">GetDoubleL</a></code>  estimates the parameters and returns the
log-likelihood at either side of a given break
</p>
</li>
<li> <p><code><a href="#topic+GetBestBreak">GetBestBreak</a></code>  finds the single best change point
according to the likelihood returned by  <code><a href="#topic+GetDoubleL">GetDoubleL</a></code>'](GetDoubleL)
</p>
</li>
<li> <p><code><a href="#topic+GetModels">GetModels</a></code>   uses a (modified) BIC model selection
for all combinations from M0 (<code class="reqn">\mu_1 = \mu_2</code>, <code class="reqn">\sigma_1 = \sigma_2</code>,
<code class="reqn">\rho_1 = \rho_2</code>) to M7 (<code class="reqn">\mu_1 \neq \mu_2</code>,
<code class="reqn">\sigma_1 \neq \sigma_2</code>, <code class="reqn">\rho_1 \neq \rho_2</code>) to
characterize the &quot;Best Break&quot;
</p>
</li>
<li><p> Finally, <code><a href="#topic+WindowSweep">WindowSweep</a></code> sweeps a longer time series
with the Best Break / Model Selection analysis, identifying most likely break
points and BIC selected models across the time series.
</p>
</li></ul>

<p>Summary, diagnostic, and plotting functions are:
</p>

<ul>
<li> <p><code><a href="#topic+PartitionParameters">PartitionParameters</a></code> - estimated
parameters of a BCPA.
</p>
</li>
<li> <p><code><a href="#topic+ChangePointSummary">ChangePointSummary</a></code>  - summary table of
the change points.
</p>
</li>
<li> <p><code><a href="#topic+plot.bcpa">plot.bcpa</a></code> - a plotting method for
visualizing the time series with vertical lines as change points.
</p>
</li>
<li> <p><code><a href="#topic+PathPlot">PathPlot</a></code> - a method for drawing a color-coded track of
the analysis.
</p>
</li>
<li> <p><code><a href="#topic+DiagPlot">DiagPlot</a></code> - diagnostic plots for BCPA.
</p>
</li></ul>

<p>A few preprocessing functions are also available:
</p>

<ul>
<li> <p><code><a href="#topic+plot.track">plot.track</a></code> - method for plotting a generic &quot;track&quot;
object.
</p>
</li>
<li> <p><code><a href="#topic+GetVT">GetVT</a></code> - returns step-lengths, absolute and turning angles
from track data.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>References</h3>


<ul>
<li><p> Gurarie, E., R. Andrews and K. Laidre. 2009. A novel method for
identifying behavioural changes in animal movement data. Ecology Letters.
12: 395-408.
</p>
</li>
<li><p> Gurarie, E., C. Fleming, W.F. Fagan, K. Laidre, J.
Hernandez-Pliego, O. Ovaskainen. 2017. Correlated velocity models as a
fundamental unit of animal movement: synthesis and applications. Movement
Ecology, 5:13.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Running through a complete analysis:
## loading data
  data(Simp)
## plotting the track (using the plot.track method)
  plot(Simp)
## Obtaining the movement summary table (with turning angles and step lengths)
  Simp.VT &lt;- GetVT(Simp)
## Applying the analysis
 if(interactive()){
  Simp.ws &lt;- WindowSweep(Simp.VT, "V*cos(Theta)", windowsize = 50, 
                         windowstep = 1, progress=TRUE)
                         } else
 Simp.ws &lt;- WindowSweep(Simp.VT, "V*cos(Theta)", windowsize = 50, 
                         windowstep = 1, progress=FALSE)
                                            
## plotting outpots
  plot(Simp.ws, threshold=7)
  plot(Simp.ws, type="flat", clusterwidth=3)
  PathPlot(Simp, Simp.ws)
  PathPlot(Simp, Simp.ws, type="flat")
## Diagnostic of assumptions
  DiagPlot(Simp.ws)

</code></pre>

<hr>
<h2 id='ChangePointSummary'>Obtain summary of BCPA analysis</h2><span id='topic+ChangePointSummary'></span>

<h3>Description</h3>

<p>Produces a summary of change points for a &quot;flat&quot; analysis, identifying phases (periods between change points) with estimated parameters, clustering neighboring ones according to a kernel density of the windowsweep breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChangePointSummary(windowsweep, clusterwidth = 1, tau = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ChangePointSummary_+3A_windowsweep">windowsweep</code></td>
<td>
<p>a <code>windowsweep</code> object, i.e. the output of the <code><a href="#topic+WindowSweep">WindowSweep</a></code> function.</p>
</td></tr>
<tr><td><code id="ChangePointSummary_+3A_clusterwidth">clusterwidth</code></td>
<td>
<p>the temporal range within which change points are considered to be within the same cluster.  Corresponds to the bandwidth of the density of the break distribution.</p>
</td></tr>
<tr><td><code id="ChangePointSummary_+3A_tau">tau</code></td>
<td>
<p>logical, whether to estimate the characteristic time tau (preferred) or not.  If FALSE, the autocorrelation parameter rho is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing two elements: 
</p>
<table>
<tr><td><code>breaks</code></td>
<td>
<p>a data frame containing columns:  <code>middle</code> - each change point, <code>size</code> - the number of windows that selected the change point, <code>modelmode</code> - the most frequently selected of the seven possible models (M0 - the null model - is excluded), and <code>middle.POSIX</code> - the mid-point as a POSIX time object.</p>
</td></tr> 
<tr><td><code>phases</code></td>
<td>
<p>a data frame containing columns <code>mu.hat, s.hat, rho.hat</code> - the estimated mean, standard deviation, and time scale (or auto-correlation) within each phase (i.e. period between change points), <code>t0</code> - the beginning of the phase, <code>t1</code> - the end of the phase, and <code>interval</code> - the total duration of the phase.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WindowSweep">WindowSweep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!exists("Simp.VT")){
 data(Simp)
 Simp.VT &lt;- GetVT(Simp)}
if(!exists("Simp.ws"))
 Simp.ws &lt;- WindowSweep(Simp.VT, "V*cos(Theta)", windowsize = 50, windowstep = 1, progress=TRUE)
# too many change points:
ChangePointSummary(Simp.ws)
# about the right number of change points:
ChangePointSummary(Simp.ws, clusterwidth=3)
</code></pre>

<hr>
<h2 id='DiagPlot'>Diagnostic plot for BCPA</h2><span id='topic+DiagPlot'></span>

<h3>Description</h3>

<p>Draws diagnostic plots for BCPA analysis.  Specifically: a qqplot, a histogram (with a N(0,1) density curve), and an acf of the standardized residuals of an analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiagPlot(
  windowsweep,
  type = c("smooth", "flat")[1],
  plotme = TRUE,
  values = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiagPlot_+3A_windowsweep">windowsweep</code></td>
<td>
<p>a <code>windowsweep</code> object, i.e. the output of the <code><a href="#topic+WindowSweep">WindowSweep</a></code> analysis.</p>
</td></tr>
<tr><td><code id="DiagPlot_+3A_type">type</code></td>
<td>
<p>whether to diagnose the model fitted for a smooth or flat BCPA.</p>
</td></tr>
<tr><td><code id="DiagPlot_+3A_plotme">plotme</code></td>
<td>
<p>logical - whether or not to plot the diagnostics</p>
</td></tr>
<tr><td><code id="DiagPlot_+3A_values">values</code></td>
<td>
<p>logical - whether or not to return the values of the standardized residuals.</p>
</td></tr>
<tr><td><code id="DiagPlot_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to the <code><a href="#topic+PartitionParameters">PartitionParameters</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>values</code> is TRUE, returns the values of the standardized residuals.
</p>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PartitionParameters">PartitionParameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Simp)
if(!exists("Simp.VT"))
 Simp.VT &lt;- GetVT(Simp)
if(!exists("Simp.ws"))
 Simp.ws &lt;- WindowSweep(Simp.VT, "V*cos(Theta)", windowsize = 50, windowstep = 1, progress=TRUE)
DiagPlot(Simp.ws)
DiagPlot(Simp.ws, type="flat")
# The Simp's diagnostic plots are excellent.
</code></pre>

<hr>
<h2 id='GetBestBreak'>Find most likely change point in irregular time series</h2><span id='topic+GetBestBreak'></span>

<h3>Description</h3>

<p>Finds the single best change point according to the likelihood function.  Used internally within <code><a href="#topic+WindowSweep">WindowSweep</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetBestBreak(x, t, range = 0.6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetBestBreak_+3A_x">x</code></td>
<td>
<p>vector of time series values.</p>
</td></tr>
<tr><td><code id="GetBestBreak_+3A_t">t</code></td>
<td>
<p>vector of times of measurements associated with x.</p>
</td></tr>
<tr><td><code id="GetBestBreak_+3A_range">range</code></td>
<td>
<p>of possible breaks. Default (0.6) runs approximately from 1/5 to 4/5 of the total length of the time series.</p>
</td></tr>
<tr><td><code id="GetBestBreak_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code><a href="#topic+GetDoubleL">GetDoubleL</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a single row (vector) with elements: <code>breaks</code>,<code>tbreaks</code>,<code>mu1</code>,<code>sigma1</code>,<code>rho1</code>,<code>LL1</code>,<code>mu2</code>,<code>sigma2</code>,<code>rho2</code>,<code>LL2</code>,<code>LL</code>. The breakpoint is calculated for a range of possible values of width <code>range*l</code> (where <code>l</code> is the length of the time series). The output of this function feeds <code><a href="#topic+WindowSweep">WindowSweep</a></code>.
</p>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WindowSweep">WindowSweep</a></code> which uses it, and <code><a href="#topic+GetDoubleL">GetDoubleL</a></code> for the likelihood estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An example with a single break:
x &lt;- c(arima.sim(list(ar = 0.9), 20) + 10, arima.sim(list(ar = 0.1), 20)) 
t &lt;- 1:length(x)
plot(t,x, type="l")
(bb &lt;- GetBestBreak(x,t, tau=FALSE))
abline(v = bb[2], col=2)
</code></pre>

<hr>
<h2 id='GetDoubleL'>Obtain log-likelihood and parameter estimates for a given break point.</h2><span id='topic+GetDoubleL'></span>

<h3>Description</h3>

<p>Takes a time series with values <code>x</code> obtained at time <code>t</code> and a time break <code>tbreak</code>, and returns the estimates of <code class="reqn">\mu</code>, <code class="reqn">\sigma</code> and <code class="reqn">\tau</code> (or <code class="reqn">\rho</code>) as well as the negative log-likelihood of those estimates before and after the break. Mostly for use internally within <code><a href="#topic+GetBestBreak">GetBestBreak</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetDoubleL(x, t, tbreak, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetDoubleL_+3A_x">x</code></td>
<td>
<p>vector of time series values.</p>
</td></tr>
<tr><td><code id="GetDoubleL_+3A_t">t</code></td>
<td>
<p>vector of times of measurements associated with x.</p>
</td></tr>
<tr><td><code id="GetDoubleL_+3A_tbreak">tbreak</code></td>
<td>
<p>breakpoint to test (in terms of the INDEX within &quot;t&quot; and &quot;x&quot;, not actual time value).</p>
</td></tr>
<tr><td><code id="GetDoubleL_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code><a href="#topic+GetRho">GetRho</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the parameters and the negative log-likelihoods in order: <code>mu1, sigma1, tau1, LL1, mu2, sigma2, tau2, LL2</code>
</p>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetBestBreak">GetBestBreak</a></code> uses this function, while this function uses <code><a href="#topic+GetRho">GetRho</a></code>
</p>

<hr>
<h2 id='GetL'>Obtain likelihood estimates of gappy Gaussian time series</h2><span id='topic+GetL'></span>

<h3>Description</h3>

<p>Obtain likelihood of gappy standardized Gaussian time series &quot;x&quot; sampled at
times &quot;t&quot; given parameter &quot;rho&quot; (autocorrelation).  Alternatively computes
the characteristic time scale &quot;tau&quot;.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetL_+3A_x">x</code></td>
<td>
<p>Time series</p>
</td></tr>
<tr><td><code id="GetL_+3A_t">t</code></td>
<td>
<p>Sampling times</p>
</td></tr>
<tr><td><code id="GetL_+3A_rho">rho</code></td>
<td>
<p>Auto-correlation</p>
</td></tr>
<tr><td><code id="GetL_+3A_tau">tau</code></td>
<td>
<p>logical: Whether or not to compute characteristic time scale
instead of rho.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log-likelihood of the data.
</p>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p>Core function of BCPA, used directly in <code><a href="#topic+GetRho">GetRho</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate autocorrelated time series
  rho.true &lt;- 0.8
  x.full &lt;- arima.sim(1000, model=list(ar = rho.true))
  t.full &lt;- 1:1000
  
# subsample time series
  keep &lt;- sort(sample(1:1000, 200))
  x &lt;- x.full[keep]
  t &lt;- t.full[keep]
  plot(t,x, type="l")
  
# Obtain MLE of rho
  rhos &lt;- seq(0,.99,.01)
  L &lt;- sapply(rhos, function(r) GetL(x, t, r))
  rho.hat &lt;- rhos[which.max(L)]
  plot(rhos, L, type = "l")
  abline(v = c(rho.true, rho.hat), lty=3:2, lwd=2)
  legend("bottomleft", legend=c("true value","MLE"), lty=3:2, lwd=2, 
         title = expression(rho))
         
# Why tau is better
  tau.true &lt;- -1/log(rho.true)
  taus &lt;- seq(1,10,.1)
  L &lt;- sapply(taus, function(r) GetL(x, t, r, tau = TRUE))
  tau.hat &lt;- taus[which.max(L)]

  plot(taus, L, type = "l")
  abline(v = c(tau.true, tau.hat), lty=3:2, lwd=2)
  legend("bottomleft", legend=c("true value","MLE"), lty=3:2, lwd=2, 
         title = expression(tau))
</code></pre>

<hr>
<h2 id='GetModels'>Model selection at a known breakpoint</h2><span id='topic+GetModels'></span>

<h3>Description</h3>

<p>Returns all parameter estimates and log-likelihoods for all possible models at a selected breakpoint.  These are: </p>
 <ul>
<li><p>M0 - all parameters equal </p>
</li>
<li><p>M1 - <code class="reqn">\mu_1 != \mu_2</code> </p>
</li>
<li><p>M2 - <code class="reqn">\sigma_1 != \sigma_2</code> </p>
</li>
<li><p>M3 - <code class="reqn">\tau_1 != \tau_2</code> </p>
</li>
<li><p>M4 - <code class="reqn">\mu_1 != \mu_2</code> AND <code class="reqn">\sigma_1 != \sigma_2</code> </p>
</li>
<li><p>M5 - <code class="reqn">\mu_1 != \mu_2</code> AND <code class="reqn">\tau_1 != \tau_2</code> </p>
</li>
<li><p>M6 - <code class="reqn">\sigma_1 != \sigma_2</code> AND <code class="reqn">\tau_1 != \tau_2</code> </p>
</li>
<li><p>M7 - all parameters unequal</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>GetModels(x, t, breakpoint, K = 2, tau = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetModels_+3A_x">x</code></td>
<td>
<p>vector of time series values.</p>
</td></tr>
<tr><td><code id="GetModels_+3A_t">t</code></td>
<td>
<p>vector of times of measurements associated with x.</p>
</td></tr>
<tr><td><code id="GetModels_+3A_breakpoint">breakpoint</code></td>
<td>
<p>breakpoint to test (in terms of the INDEX within &quot;t&quot; and &quot;x&quot;, not actual time value).</p>
</td></tr>
<tr><td><code id="GetModels_+3A_k">K</code></td>
<td>
<p>sensitivity parameter.  Standard definition of BIC, K = 2.  Smaller values of K mean less sensitive selection, i.e. higher likelihood of selecting null (or simpler) models.</p>
</td></tr>
<tr><td><code id="GetModels_+3A_tau">tau</code></td>
<td>
<p>whether or not to estimate time scale <code class="reqn">\tau</code> (preferred) or autocorrelation <code class="reqn">\rho</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a names matrix with 8 rows (one for each model) and columns: <code>Model</code>, <code>LL, bic, mu1, s1, rho1, mu2, s2, rho2</code>.  Fairly self-explanatory.  Note that the <code>rho</code> columns include the <code>tau</code> values, if <code>tau</code> is TRUE (as it usually should be).
</p>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p>Used directly within <code><a href="#topic+WindowSweep">WindowSweep</a></code>.  Relies heavily on <code><a href="#topic+GetRho">GetRho</a></code>.
</p>

<hr>
<h2 id='GetRho'>Characteristic time / auto-correlation for irregular time series</h2><span id='topic+GetRho'></span><span id='topic+GetRho2'></span>

<h3>Description</h3>

<p>Estimates characteristic time <code class="reqn">\tau</code> or auto-correlation <code class="reqn">\rho</code> from 
a gappy time series dataset.  It works first by estimating the mean and 
standard deviation directly from the time series X, using these to 
standardize the time series, and then optimizes for the likelihood of the 
value of <code class="reqn">\tau</code> or <code class="reqn">\rho</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetRho(x, t, tau = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetRho_+3A_x">x</code></td>
<td>
<p>vector of time series values.</p>
</td></tr>
<tr><td><code id="GetRho_+3A_t">t</code></td>
<td>
<p>vector of times of measurements associated with x.</p>
</td></tr>
<tr><td><code id="GetRho_+3A_tau">tau</code></td>
<td>
<p>whether or not to estimate time scale <code class="reqn">\tau</code> (preferred) or 
autocorrelation <code class="reqn">\rho</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of length two: the estimate and the negative 
log-likelihood
</p>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>

<hr>
<h2 id='GetVT'>Obtain VT table from Track</h2><span id='topic+GetVT'></span>

<h3>Description</h3>

<p>The VT table computes speeds, step lengths, orientations, turning angles and 
ancillary variables from a track. The output of this function is (typically) 
meant to feed the <code><a href="#topic+WindowSweep">WindowSweep</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetVT(Data, units = "hour", skiplast = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetVT_+3A_data">Data</code></td>
<td>
<p>a track to analyze.  Must contain columns: X, Y and Time (as a 
POSIX object).  The <code>track</code> class is a robust entry.</p>
</td></tr>
<tr><td><code id="GetVT_+3A_units">units</code></td>
<td>
<p>the time units for the analysis; one of <code>sec, min, hour, 
day</code>.</p>
</td></tr>
<tr><td><code id="GetVT_+3A_skiplast">skiplast</code></td>
<td>
<p>filters away last step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the following columns:
</p>
<table>
<tr><td><code>Z.start</code>, <code>Z.end</code></td>
<td>
<p>the start and end locations (as complex coordinates)</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>the step length</p>
</td></tr>
<tr><td><code>Phi</code>, <code>Theta</code></td>
<td>
<p>absolute and turning angle, respectively</p>
</td></tr>
<tr><td><code>T.start</code>, <code>T.end</code></td>
<td>
<p>start and time of steps (numeric - in given units)</p>
</td></tr>
<tr><td><code>T.mid</code></td>
<td>
<p>temporal midpoint of the step </p>
</td></tr>
<tr><td><code>dT</code></td>
<td>
<p>duration of the step</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>approximate speed (S/dT)</p>
</td></tr>
<tr><td><code>T.POSIX</code></td>
<td>
<p>the temporal midpoint of the step as a POSIX objects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WindowSweep">WindowSweep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Simp)
plot(Simp)
Simp.VT &lt;- GetVT(Simp)
head(Simp.VT)
# Distribution of estimated speeds
hist(Simp.VT$V, col="grey", breaks=20)
# Distribution of turning angles

if (requireNamespace("circular", quietly = TRUE)) 
   circular::rose.diag(Simp.VT$Theta, bins=24) else
     hist(Simp.VT$Theta)
</code></pre>

<hr>
<h2 id='MakeTrack'>Make Track</h2><span id='topic+MakeTrack'></span>

<h3>Description</h3>

<p>Simple convenience function for creating a <code>track</code> class object from X-Y-Time movement data. A <code>track</code> class object can be conveniently plotted and analyzed within <code>bcpa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeTrack(X, Y, Time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeTrack_+3A_x">X</code></td>
<td>
<p>vector of X locations</p>
</td></tr>
<tr><td><code id="MakeTrack_+3A_y">Y</code></td>
<td>
<p>vector of Y locations</p>
</td></tr>
<tr><td><code id="MakeTrack_+3A_time">Time</code></td>
<td>
<p>vector of time (can be POSIX)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>track</code> class data frame, with three columns: <code>X</code>, <code>Y</code> and <code>Time</code>.
</p>


<h3>See Also</h3>

<p>plot.track
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- cumsum(arima.sim(n=100, model=list(ar=0.8)))
Y &lt;- cumsum(arima.sim(n=100, model=list(ar=0.8)))
Time &lt;- 1:100
mytrack &lt;- MakeTrack(X,Y,Time)
plot(mytrack)
</code></pre>

<hr>
<h2 id='PartitionParameters'>Partition parameters</h2><span id='topic+PartitionParameters'></span>

<h3>Description</h3>

<p>Partitions - and, ultimately, estimates - all parameters of a BCPA, either 
as a rolling average (smooth BCPA), or as constant values within fixed 
change points (flat BCPA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PartitionParameters(
  windowsweep,
  type = c("smooth", "flat")[1],
  clusterwidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PartitionParameters_+3A_windowsweep">windowsweep</code></td>
<td>
<p>a <code>windowsweep</code> object, i.e. the output of the 
<code><a href="#topic+WindowSweep">WindowSweep</a></code> function.</p>
</td></tr>
<tr><td><code id="PartitionParameters_+3A_type">type</code></td>
<td>
<p>type of estimate to output, whether &quot;smooth&quot; or &quot;flat&quot;.</p>
</td></tr>
<tr><td><code id="PartitionParameters_+3A_clusterwidth">clusterwidth</code></td>
<td>
<p>the temporal range within which changepoints are 
considered to be within the same cluster (for a &quot;smooth&quot; BCPA).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the three estimates: <code>mu.hat</code>, 
<code>s.hat</code>, <code>rho.hat</code>.
</p>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p>used in <code><a href="#topic+ChangePointSummary">ChangePointSummary</a></code> and 
<code><a href="#topic+PhasePlot">PhasePlot</a></code>
</p>

<hr>
<h2 id='PathPlot'>Path plot of BCPA output</h2><span id='topic+PathPlot'></span>

<h3>Description</h3>

<p>Plots the animal's trajectory, with segments color-coded according to the 
time scale / auto-correlation of the BCPA output, and width of segments 
proportional to the estimated mean of the BCPA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PathPlot(
  Data,
  windowsweep,
  type = c("smooth", "flat")[1],
  clusterwidth = 1,
  plotlegend = FALSE,
  tauwhere = "topleft",
  n.legend = 5,
  ncol.legend = 1,
  bty.legend = "n",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PathPlot_+3A_data">Data</code></td>
<td>
<p>the track data to be plotted - most typically, output of the 
<code><a href="#topic+GetVT">GetVT</a></code> function.</p>
</td></tr>
<tr><td><code id="PathPlot_+3A_windowsweep">windowsweep</code></td>
<td>
<p><code>windowsweep</code> object, i.e. the output of the 
<code><a href="#topic+WindowSweep">WindowSweep</a></code> function.</p>
</td></tr>
<tr><td><code id="PathPlot_+3A_type">type</code></td>
<td>
<p>whether to plot smooth or flat bcpa output</p>
</td></tr>
<tr><td><code id="PathPlot_+3A_clusterwidth">clusterwidth</code></td>
<td>
<p>for flat BCPA, this is the temporal range within which 
change points are considered to be within the same cluster.</p>
</td></tr>
<tr><td><code id="PathPlot_+3A_plotlegend">plotlegend</code></td>
<td>
<p>whether to plot a legend.</p>
</td></tr>
<tr><td><code id="PathPlot_+3A_tauwhere">tauwhere</code></td>
<td>
<p>where to place the legend for the time-scale / 
auto-correlation.  Can be one of &quot;nowhere&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, 
&quot;right&quot;, &quot;topleft&quot;, &quot;topright&quot;, &quot;bottomright&quot;, &quot;bottomleft&quot;.</p>
</td></tr>
<tr><td><code id="PathPlot_+3A_n.legend">n.legend</code></td>
<td>
<p>number of labels in legend.</p>
</td></tr>
<tr><td><code id="PathPlot_+3A_ncol.legend">ncol.legend</code></td>
<td>
<p>number of columns in the legend.</p>
</td></tr>
<tr><td><code id="PathPlot_+3A_bty.legend">bty.legend</code></td>
<td>
<p>whether to draw a box around the legend.</p>
</td></tr>
<tr><td><code id="PathPlot_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to the <code>plot</code> base function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!exists("Simp.ws"))
{
 data(Simp)
 Simp.ws &lt;- WindowSweep(GetVT(Simp), "V*cos(Theta)", windowsize = 50, 
 windowstep = 1, progress=TRUE)
}

PathPlot(Simp, Simp.ws, plotlegend=TRUE, n.legend=3)
PathPlot(Simp, Simp.ws, type="flat", clusterwidth=3, plotlegend=TRUE)
</code></pre>

<hr>
<h2 id='PhasePlot'>Phase plot of BCPA output</h2><span id='topic+PhasePlot'></span>

<h3>Description</h3>

<p>Behavioral phase plot of BCPA output.  Mean and standard deviation are on the x and y axis.  Size and color of points represent the time scale of autocorrelation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhasePlot(
  windowsweep,
  type = c("smooth", "flat")[1],
  clusterwidth = 1,
  ...,
  legend.where = "bottomright"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhasePlot_+3A_windowsweep">windowsweep</code></td>
<td>
<p><code>windowsweep</code> object, i.e. the output of the <code><a href="#topic+WindowSweep">WindowSweep</a></code> function.</p>
</td></tr>
<tr><td><code id="PhasePlot_+3A_type">type</code></td>
<td>
<p>whether to plot smooth or flat bcpa output</p>
</td></tr>
<tr><td><code id="PhasePlot_+3A_clusterwidth">clusterwidth</code></td>
<td>
<p>for flat BCPA, this is the temporal range within which change points are considered to be within the same cluster.</p>
</td></tr>
<tr><td><code id="PhasePlot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> base function.</p>
</td></tr>
<tr><td><code id="PhasePlot_+3A_legend.where">legend.where</code></td>
<td>
<p>where to place the tau legend (see <code><a href="graphics.html#topic+legend">legend</a></code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WindowSweep">WindowSweep</a></code>, <code><a href="#topic+PartitionParameters">PartitionParameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!exists("Simp.ws"))
{
 data(Simp)
 Simp.ws &lt;- WindowSweep(GetVT(Simp), "V*cos(Theta)", windowsize = 50, windowstep = 1, progress=TRUE)
}

PhasePlot(Simp.ws)
</code></pre>

<hr>
<h2 id='plot.bcpa'>Plotting method for BCPA output</h2><span id='topic+plot.bcpa'></span>

<h3>Description</h3>

<p>Plotting method for the output of a BCPA analysis with vertical break points, 
superimposed estimates of the partitioned mean and variance estimates and 
color-coded autocorrelation estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bcpa'
plot(
  x,
  type = c("smooth", "flat")[1],
  threshold = 3,
  clusterwidth = 1,
  col.cp = rgb(0.5, 0, 0.5, 0.5),
  pt.cex = 0.5,
  legend = TRUE,
  rho.where = "topleft",
  mu.where = "nowhere",
  col.sd = "red",
  col.mean = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bcpa_+3A_x">x</code></td>
<td>
<p>a <code>windowsweep</code> object, i.e. the output of the 
<code><a href="#topic+WindowSweep">WindowSweep</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.bcpa_+3A_type">type</code></td>
<td>
<p>whether to plot smooth or flat bcpa output</p>
</td></tr>
<tr><td><code id="plot.bcpa_+3A_threshold">threshold</code></td>
<td>
<p>for smooth BCPA, this is the minimum number of windows that 
must have identified a given changepoint to be illustrated.</p>
</td></tr>
<tr><td><code id="plot.bcpa_+3A_clusterwidth">clusterwidth</code></td>
<td>
<p>for flat BCPA, this is the temporal range within which 
change points are considered to be within the same cluster.</p>
</td></tr>
<tr><td><code id="plot.bcpa_+3A_col.cp">col.cp</code>, <code id="plot.bcpa_+3A_col.mean">col.mean</code>, <code id="plot.bcpa_+3A_col.sd">col.sd</code></td>
<td>
<p>color of the vertical change points, mean 
estimate, and prediction interval (mu +- sigma), respectively.</p>
</td></tr>
<tr><td><code id="plot.bcpa_+3A_pt.cex">pt.cex</code></td>
<td>
<p>expansion coefficient for point sizes.</p>
</td></tr>
<tr><td><code id="plot.bcpa_+3A_legend">legend</code></td>
<td>
<p>logical - whether to draw a legend or not.</p>
</td></tr>
<tr><td><code id="plot.bcpa_+3A_rho.where">rho.where</code></td>
<td>
<p>where to place the legend for the time-scale / 
auto-correlation.  Can be one of &quot;nowhere&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, 
&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomright&quot;, &quot;bottomleft&quot;</p>
</td></tr>
<tr><td><code id="plot.bcpa_+3A_mu.where">mu.where</code></td>
<td>
<p>where (and whether) to place the legend box for the mean - 
same options as for <code>rho.where</code></p>
</td></tr>
<tr><td><code id="plot.bcpa_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the <code>plot</code> base function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p>Plots output of the <code><a href="#topic+WindowSweep">WindowSweep</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!exists("Simp.ws"))
{
 data(Simp)
 Simp.ws &lt;- WindowSweep(GetVT(Simp), "V*cos(Theta)", windowsize = 50, 
 windowstep = 1, progress=TRUE)
}

plot(Simp.ws)
# this actually provides basically the exact original changepoints
plot(Simp.ws, threshold=7)
# here's a flat analysis
plot(Simp.ws, type="flat", clusterwidth=3, legend=FALSE)
</code></pre>

<hr>
<h2 id='plot.track'>Plot Track</h2><span id='topic+plot.track'></span>

<h3>Description</h3>

<p>Default method for plotting tracks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'track'
plot(x, pch = 19, col = rgb(0, 0, 0, 0.2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.track_+3A_x">x</code></td>
<td>
<p>object of class &quot;track&quot; to plot</p>
</td></tr>
<tr><td><code id="plot.track_+3A_pch">pch</code></td>
<td>
<p>default point style: filled circle</p>
</td></tr>
<tr><td><code id="plot.track_+3A_col">col</code></td>
<td>
<p>default color: transparent grey</p>
</td></tr>
<tr><td><code id="plot.track_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code>plot</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Simp)
is(Simp)
plot(Simp)
</code></pre>

<hr>
<h2 id='Simp'>Simulated Chim
(Simp) Data</h2><span id='topic+Simp'></span>

<h3>Description</h3>

<p>This is a simulated movement track from a continuous auto-correlated process 
of total duration 60 time units with four behavioral phases that switch at 
times T=10, 20 and 50 from, variously, higher or lower velocity and longer or 
shorter characteristic time scale of autocorrelation. The original data was 
simulated with time intervals of 0.01 (leading to a complete track with 6000 
data points). 200 points were randomly sampled from the &quot;true&quot; movement 
track, such that the intervals between locations are random with mean 
interval 0.3 units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Simp)
</code></pre>


<h3>Format</h3>


<dl>
<dt>Time</dt><dd><p>times of observation</p>
</dd> 
<dt>X, Y</dt><dd><p>coordinates</p>
</dd></dl>



<h3>Source</h3>

<p>simulated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Simp)
plot(Simp)
</code></pre>

<hr>
<h2 id='WindowSweep'>Perform window sweep for BCPA</h2><span id='topic+WindowSweep'></span>

<h3>Description</h3>

<p>This is the workhorse function of the BCPA.  It performs a sweep of the time 
series, searching for most significant change points and identifying the 
parsimonious model according to an adjusted BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WindowSweep(
  data,
  variable,
  time.var = "T.mid",
  windowsize = 50,
  windowstep = 1,
  units = "hours",
  K = 2,
  tau = TRUE,
  range = 0.6,
  progress = TRUE,
  plotme = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WindowSweep_+3A_data">data</code></td>
<td>
<p>the data to be analyzed.  Generically, the output of the 
<code><a href="#topic+GetVT">GetVT</a></code> function containing step lengths, absolute and turning 
angles, etc, but can be any data frame with a column representing times and 
any column (or set of columns) that can be converted to a time series for 
change point analysis.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_variable">variable</code></td>
<td>
<p>a character string representing the response variable to 
apply the BCPA to.  For example <code>"V*cos(theta)"</code>  for persistence 
velocity, <code>"log(V)"</code> for log of velocity if the data are outputs of 
'code<a href="#topic+GetVT">GetVT</a>'.   Otherwise, any column (e.g. <code>"Depth"</code>) in the 
data.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_time.var">time.var</code></td>
<td>
<p>character string for the time variable.  The default is 
<code>T.mid</code>  from the output of the 'code<a href="#topic+GetVT">GetVT</a>'.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_windowsize">windowsize</code></td>
<td>
<p>integer size of the analysis window as a number of data 
points (not time units).  Should probably be no smaller than 20.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_windowstep">windowstep</code></td>
<td>
<p>integer step size of analysis. Values greater than 1 speed 
the analysis up.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_units">units</code></td>
<td>
<p>if the times are POSIX, <code>units</code> (one of &quot;secs&quot;, &quot;mins&quot;, 
&quot;hours&quot;, &quot;days&quot;, &quot;weeks&quot;) determine the unit of the <code>windowstep</code>.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_k">K</code></td>
<td>
<p>sensitivity parameter for the adjusted BIC.  Smaller values make 
for a less sensitive model selection, i.e. more likely that the null model 
of no significant changes will be selected.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_tau">tau</code></td>
<td>
<p>a logical indicating whether the autocorrelation &quot;rho&quot; or the 
characteristic time &quot;tau&quot; should be estimated.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_range">range</code></td>
<td>
<p>a number between 0 and 1 that determines the extent of each 
window that is scanned for changepoints.  I.e., if the window is 100 
datapoints long, at the default <code>range=0.6</code>, changepoints will be 
scanned between 20 and 80.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_progress">progress</code></td>
<td>
<p>logical - whether or not to output a progress bar as the 
analysis is being performed.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_plotme">plotme</code></td>
<td>
<p>logical - whether or not to plot the analysis as it is 
happening.  This slows the analysis considerably, especially in non-dynamic 
graphic environments like RStudio.</p>
</td></tr>
<tr><td><code id="WindowSweep_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the 
<code><a href="#topic+PartitionParameters">PartitionParameters</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>windowsweep</code>, which is a list containing: 
</p>
<table>
<tr><td><code>ws</code></td>
<td>
<p>a data frame containing the change point, selected model, and 
parameter estimates</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>the response variable</p>
</td></tr> 
<tr><td><code>t</code></td>
<td>
<p>the time variable - in the units specified in the data object</p>
</td></tr> 
<tr><td><code>t.POSIX</code></td>
<td>
<p>the time variable as a POSIX object (containing Y-M-D H:S)</p>
</td></tr> 
<tr><td><code>windowsize</code></td>
<td>
<p>the window size</p>
</td></tr>
<tr><td><code>windowstep</code></td>
<td>
<p>the window step size</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliezer Gurarie
</p>


<h3>See Also</h3>

<p>for internal functions: <code><a href="#topic+GetModels">GetModels</a></code>, 
<code><a href="#topic+GetBestBreak">GetBestBreak</a></code>, <code><a href="#topic+GetDoubleL">GetDoubleL</a></code>; for summarizing 
output: <code><a href="#topic+ChangePointSummary">ChangePointSummary</a></code>; for plotting output: 
<code><a href="#topic+plot.bcpa">plot.bcpa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the included simulated  movement data
require(bcpa)
data(Simp)
plot(Simp)
Simp.VT &lt;- GetVT(Simp)
## note: column names of Simp.VT include:
###  "S" - step length
### "Theta" - turning angle
###  T.start" "T.end"   "T.mid"  "T.POSIX" - time variables

if(interactive())
  Simp.ws &lt;- WindowSweep(Simp.VT, "V*cos(Theta)", windowsize = 50, 
                         windowstep = 1, progress=TRUE) else
  Simp.ws &lt;- WindowSweep(Simp.VT, "V*cos(Theta)", windowsize = 50, 
                         windowstep = 1, progress=FALSE)

plot(Simp.ws, threshold = 7)
plot(Simp.ws, type = "flat", clusterwidth = 3)
PathPlot(Simp, Simp.ws)
PathPlot(Simp, Simp.ws, type="flat")
DiagPlot(Simp.ws)

# Example of application on one dimensional data (e.g. depth)

# simulate some data with three change points: surface, medium, deep, surface

## random times within 100 hours of now
n.obs &lt;- 100
time = sort(Sys.time() - runif(n.obs, 0, n.obs) * 60 * 60)

d1 &lt;- 50; d2 &lt;- 100
t1 &lt;- 25; t2 &lt;- 65; t3 &lt;- 85
sd1 &lt;- 1; sd2 &lt;- 5; sd3 &lt;- 10

dtime &lt;- as.numeric(difftime(time, min(time), units="hours"))
phases &lt;- cut(dtime, c(-1, t1, t2, t3, 200), labels = c("P1","P2","P3","P4")) 
means &lt;- c(0,d1,d2,0)[phases]
sds &lt;- c(sd1,sd2,sd3,sd1)[phases]
depth &lt;- rnorm(n.obs,means, sds)
# make all depths positive!
depth &lt;- abs(depth)
mydata &lt;- data.frame(time, depth)

# perform windowsweep
ws &lt;- WindowSweep(mydata, "depth", time.var = "time", windowsize = 30, 
                  windowstep = 1, progress=interactive())
plot(ws)
plot(ws, type = "flat", cluster = 6)
ChangePointSummary(ws, cluster = 6)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
