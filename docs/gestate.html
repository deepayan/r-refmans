<!DOCTYPE html><html><head><title>Help for package gestate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gestate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyse_sim'><p>Analyse simulations of time-to-event data using arbitrary event, censoring and recruitment distributions.</p></a></li>
<li><a href='#Blank'><p>Blank Curve constructor function</p></a></li>
<li><a href='#create_tte_prior'><p>Create an arbitrary prior data set from a specified Curve object</p></a></li>
<li><a href='#createRFfunction'><p>Method for creating a random draw function from a Curve object</p></a></li>
<li><a href='#createRFfunction,Curve-method'><p>Method for creating a random draw function from a Curve object</p></a></li>
<li><a href='#Curve-class'><p>Curve Class for defining distributions</p></a></li>
<li><a href='#evaluateCDFfunction'><p>Method for evaluating the CDF function for a Curve object at q</p></a></li>
<li><a href='#evaluateCDFfunction,Curve-method'><p>Method for evaluating the CDF function for a Curve object at q</p></a></li>
<li><a href='#evaluateInvfunction'><p>Method for evaluating the inverse-CDF function for a Curve object at p</p></a></li>
<li><a href='#evaluateInvfunction,Curve-method'><p>Method for evaluating the inverse-CDF function for a Curve object at p</p></a></li>
<li><a href='#evaluatePDFfunction'><p>Method for evaluating the PDF function for a Curve object at x</p></a></li>
<li><a href='#evaluatePDFfunction,Curve-method'><p>Method for evaluating the PDF function for a Curve object at x</p></a></li>
<li><a href='#event_prediction'><p>Event prediction using patient-level survival data and a recruitment RCurve</p></a></li>
<li><a href='#event_prediction_KM'><p>Event prediction using a lifetable and a recruitment RCurve</p></a></li>
<li><a href='#event_prediction_prior'><p>Event prediction using patient-level survival data, prior data and a recruitment RCurve</p></a></li>
<li><a href='#events2power'><p>Calculate Schoenfeld or Event Proportion power from number of events</p></a></li>
<li><a href='#Exponential'><p>Exponential Curve constructor function</p></a></li>
<li><a href='#fit_KM'><p>Fit Weibull, Log-Normal or Exponential survival curves to Kaplan Meier estimates</p></a></li>
<li><a href='#fit_tte_data'><p>Fit Weibull, Log-Normal or Exponential survival curves to patient-level time-to-event data</p></a></li>
<li><a href='#fit_tte_data_prior'><p>Fit Weibull survival curves to patient-level time-to-event data by including patient-level weighted prior data</p></a></li>
<li><a href='#freedmanpower'><p>Calculate Freedman power from number of events</p></a></li>
<li><a href='#frontierpower'><p>Calculate Frontier power from number of events</p></a></li>
<li><a href='#getAssessCDFfunction'><p>Method for returning the CDF function for a RCurve object</p></a></li>
<li><a href='#getAssessCDFfunction,RCurve-method'><p>Method for returning the CDF function for a RCurve object</p></a></li>
<li><a href='#getCDFfunction'><p>Method for returning the CDF function for a Curve object</p></a></li>
<li><a href='#getCDFfunction,Curve-method'><p>Method for returning the CDF function for a Curve object</p></a></li>
<li><a href='#getInvfunction'><p>Method for returning the inverse-CDF function for a Curve object</p></a></li>
<li><a href='#getInvfunction,Curve-method'><p>Method for returning the inverse-CDF function for a Curve object</p></a></li>
<li><a href='#getLength'><p>Method for returning the recruitment length from a RCurve</p></a></li>
<li><a href='#getLength,RCurve-method'><p>Method for returning the recruitment length from a RCurve</p></a></li>
<li><a href='#getMaxF'><p>Method for returning maximum duration of patient follow-up from a RCurve</p></a></li>
<li><a href='#getMaxF,RCurve-method'><p>Method for returning maximum duration of patient follow-up from a RCurve</p></a></li>
<li><a href='#getN'><p>Method for returning the total patient number from a RCurve</p></a></li>
<li><a href='#getN,RCurve-method'><p>Method for returning the total patient number from a RCurve</p></a></li>
<li><a href='#getNactive'><p>Method for returning the active arm patient number from a RCurve</p></a></li>
<li><a href='#getNactive,RCurve-method'><p>Method for returning the active arm patient number from a RCurve</p></a></li>
<li><a href='#getNames'><p>Method for returning all parameter names from a Curve object</p></a></li>
<li><a href='#getNames,Curve-method'><p>Method for returning all parameter names from a Curve object</p></a></li>
<li><a href='#getNcontrol'><p>Method for returning the control arm patient number from a RCurve</p></a></li>
<li><a href='#getNcontrol,RCurve-method'><p>Method for returning the control arm patient number from a RCurve</p></a></li>
<li><a href='#getParam'><p>Method for returning a single parameter from a Curve object</p></a></li>
<li><a href='#getParam,Curve-method'><p>Method for returning a single parameter from a Curve object</p></a></li>
<li><a href='#getParams'><p>Method for returning all parameters from a Curve object as a list</p></a></li>
<li><a href='#getParams,Curve-method'><p>Method for returning all parameters from a Curve object as a list</p></a></li>
<li><a href='#getParamsV'><p>Method for returning all parameters from a Curve object as a vector</p></a></li>
<li><a href='#getParamsV,Curve-method'><p>Method for returning all parameters from a Curve object as a vector</p></a></li>
<li><a href='#getPatients'><p>Method for calculating expected number of recruited patients at a given time from an RCurve</p></a></li>
<li><a href='#getPatients,RCurve-method'><p>Method for calculating expected number of recruited patients at a given time from an RCurve</p></a></li>
<li><a href='#getPDFfunction'><p>Method for returning the PDF function for a Curve object</p></a></li>
<li><a href='#getPDFfunction,Curve-method'><p>Method for returning the PDF function for a Curve object</p></a></li>
<li><a href='#getRatio'><p>Method for returning the recruitment ratio from a RCurve</p></a></li>
<li><a href='#getRatio,RCurve-method'><p>Method for returning the recruitment ratio from a RCurve</p></a></li>
<li><a href='#getRFfunction'><p>Method for returning the RF function for a Curve object</p></a></li>
<li><a href='#getRFfunction,Curve-method'><p>Method for returning the RF function for a Curve object</p></a></li>
<li><a href='#getType'><p>Method for returning the Curve type</p></a></li>
<li><a href='#getType,Curve-method'><p>Method for returning the Curve type</p></a></li>
<li><a href='#GGamma'><p>Generalised Gamma Curve constructor function</p></a></li>
<li><a href='#Gompertz'><p>Gompertz Curve constructor function</p></a></li>
<li><a href='#InstantR'><p>InstantR RCurve constructor function</p></a></li>
<li><a href='#LinearR'><p>LinearR RCurve constructor function</p></a></li>
<li><a href='#LogLogistic'><p>Log-logistic Curve constructor function</p></a></li>
<li><a href='#Lognormal'><p>Log-normal Curve constructor function</p></a></li>
<li><a href='#MixExp'><p>Mixture Exponential Curve constructor function</p></a></li>
<li><a href='#MixWei'><p>Mixture Weibull Curve constructor function</p></a></li>
<li><a href='#nph_traj'><p>Calculate analytic time-to-event trial properties under non-proportional hazards and complex assumptions</p></a></li>
<li><a href='#PieceExponential'><p>Piecewise Exponential Curve constructor function</p></a></li>
<li><a href='#PieceR'><p>PieceR RCurve constructor function</p></a></li>
<li><a href='#PieceRMaxF'><p>PieceR RCurve constructor function</p></a></li>
<li><a href='#plot_ep'><p>Plot event prediction output</p></a></li>
<li><a href='#plot_km_fit'><p>Kaplan Meier Plot of Curve-Fit</p></a></li>
<li><a href='#plot_npht'><p>Plot output from nph_traj</p></a></li>
<li><a href='#plotCDF'><p>Method for plotting the CDF of a Curve object</p></a></li>
<li><a href='#plotCDF,Curve-method'><p>Method for plotting the CDF of a Curve object</p></a></li>
<li><a href='#plotRecruitment'><p>Method for plotting the Recruitment Function of a RCurve object</p></a></li>
<li><a href='#plotRecruitment,RCurve-method'><p>Method for plotting the Recruitment Function of a RCurve object</p></a></li>
<li><a href='#plotSF'><p>Method for plotting the Survival Function of a Curve object</p></a></li>
<li><a href='#plotSF,Curve-method'><p>Method for plotting the Survival Function of a Curve object</p></a></li>
<li><a href='#power2events'><p>Calculate Schoenfeld or Event Proportion based event numbers from power</p></a></li>
<li><a href='#random_draw'><p>Method for taking random draws from a Curve object distribution</p></a></li>
<li><a href='#random_draw,Curve-method'><p>Method for taking random draws from a Curve object distribution</p></a></li>
<li><a href='#RCurve-class'><p>RCurve Class for defining recruitment distributions</p></a></li>
<li><a href='#run_gestate'><p>Load Shiny for Gestate</p>
Loads the Shiny interactive GUI for gestate</a></li>
<li><a href='#set_assess_time'><p>Adjusts assessment time for simulations</p></a></li>
<li><a href='#set_event_number'><p>Adjusts simulations so that administrative censoring occurs at a fixed event number, rather than a fixed time</p></a></li>
<li><a href='#setPatients'><p>Method for setting N's in an RCurve</p></a></li>
<li><a href='#setPatients,RCurve-method'><p>Method for setting N's in an RCurve</p></a></li>
<li><a href='#show,Curve-method'><p>Method for displaying Curve objects neatly - replaces standard show method</p></a></li>
<li><a href='#show,RCurve-method'><p>Method for displaying RCurve objects neatly - replaces standard show method</p></a></li>
<li><a href='#simulate_trials'><p>Perform simulations of time-to-event data using arbitrary event, censoring and recruitment distributions.</p></a></li>
<li><a href='#simulate_trials_strata'><p>Perform multi-strata simulations of time-to-event data using arbitrary event, censoring and recruitment distributions.</p></a></li>
<li><a href='#summarise_analysis'><p>Summarise analyses of simulations of time-to-event data using arbitrary event, censoring and recruitment distributions.</p></a></li>
<li><a href='#survfit_fast'><p>Create lifetable quickly</p></a></li>
<li><a href='#Weibull'><p>Weibull Curve constructor function</p></a></li>
<li><a href='#ZV2power'><p>Calculate Normal distribution test power based on Effect size and Variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generalised Survival Trial Assessment Tool Environment</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools to assist planning and monitoring of time-to-event trials under complicated censoring assumptions and/or non-proportional hazards. There are three main components: The first is analytic calculation of predicted time-to-event trial properties, providing estimates of expected hazard ratio, event numbers and power under different analysis methods. The second is simulation, allowing stochastic estimation of these same properties. Thirdly, it provides parametric event prediction using blinded trial data, including creation of prediction intervals. Methods are based upon numerical integration and a flexible object-orientated structure for defining event, censoring and recruitment distributions (Curves).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach, doParallel, shiny, shinythemes, survival, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-26 10:06:53 UTC; James</td>
</tr>
<tr>
<td>Author:</td>
<td>James Bell [aut, cre],
  Jasmin Ruehl [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Bell &lt;james.bell.ext@boehringer-ingelheim.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-26 11:02:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyse_sim'>Analyse simulations of time-to-event data using arbitrary event, censoring and recruitment distributions.</h2><span id='topic+analyse_sim'></span>

<h3>Description</h3>

<p>Function for analysing simulated time-to-event trial data produced by simulate_trials() or simulate_trials_strata().<br />
This function automatically reads in either list or matrix simulate_trials() data formats.
It performs log rank test and Cox regression analysis by default, but can also/instead perform RMST and/or landmark analyses.
Covariate adjusted (/ stratified) analysis may be selected by using the &quot;stratum&quot; argument.
If a stratum is specified, it will be included as a covariate in Cox and RMST analysis, and as a stratum in a stratified log-rank test and an inverse-precision-weighted landmark test.
Strata values are handled as factors, so continuous covariates are not supported.<br />
Analysis is typically the slowest part of simulation studies, so parallel processing using the doParallel package is built in.
Parallel processing is enabled by setting the number of cores in the &quot;parallel_cores&quot; argument.
Use of parallel processing is recommended for largescale (e.g. 100,000 iteration) simulations.
To avoid unnecessary issues, ensure that the number of cores specified does not exceed number of threads provided by hardware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_sim(
  data,
  LR = TRUE,
  RMST = NA,
  landmark = NA,
  stratum = "",
  parallel_cores = 1,
  Time = "Time",
  Event = "Censored",
  censoringOne = TRUE,
  Trt = "Trt",
  Iter = "Iter"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyse_sim_+3A_data">data</code></td>
<td>
<p>Output file from simulate_trials(). Only simulate_trials() or simulate_trials_strata() output is supported, in either &quot;list&quot; or &quot;matrix&quot; format.</p>
</td></tr>
<tr><td><code id="analyse_sim_+3A_lr">LR</code></td>
<td>
<p>Requests log-rank test and Cox regression. Default=TRUE</p>
</td></tr>
<tr><td><code id="analyse_sim_+3A_rmst">RMST</code></td>
<td>
<p>Requests Restricted Mean Survival Time analysis with specified (positive integer) restriction time, leave NULL for no analysis. Default=NULL (no RMST analysis).</p>
</td></tr>
<tr><td><code id="analyse_sim_+3A_landmark">landmark</code></td>
<td>
<p>Requests Landmark analysis at specified (positive integer) time, leave NULL for no analysis. Default=NULL (no landmark analysis).</p>
</td></tr>
<tr><td><code id="analyse_sim_+3A_stratum">stratum</code></td>
<td>
<p>Specify name of column of a stratification factor and turn on stratified (LR/LM) and covariate-adjusted (Cox/RMST) analysis. By default, &quot;&quot;, and no stratification.</p>
</td></tr>
<tr><td><code id="analyse_sim_+3A_parallel_cores">parallel_cores</code></td>
<td>
<p>Positive integer specifying number of cores to use. If 1 specified then no parallel processing. Default=1 (no parallel processing).</p>
</td></tr>
<tr><td><code id="analyse_sim_+3A_time">Time</code></td>
<td>
<p>String specifying the name of the time column. Default=&quot;Time&quot;</p>
</td></tr>
<tr><td><code id="analyse_sim_+3A_event">Event</code></td>
<td>
<p>String specifying the name of the censoring/event column. Default=&quot;Censored&quot; (and by default it is a censoring column unless censoringOne=FALSE)</p>
</td></tr>
<tr><td><code id="analyse_sim_+3A_censoringone">censoringOne</code></td>
<td>
<p>Boolean specifying whether censoring is denoted in the censoring/event column by a one (TRUE) or zero (FALSE). Default=TRUE (censorings denoted by 1, events by 0)</p>
</td></tr>
<tr><td><code id="analyse_sim_+3A_trt">Trt</code></td>
<td>
<p>String specifying the name of the treatment column. Default=&quot;Trt&quot;</p>
</td></tr>
<tr><td><code id="analyse_sim_+3A_iter">Iter</code></td>
<td>
<p>String specifying the name of the iterations column. Default=&quot;Iter&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table with one row per simulation. Table contains the following columns:
</p>

<ul>
<li><p>&quot;HR&quot; Cox Hazard Ratio (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;LogHR&quot; Cox Log Hazard Ratio (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;LogHR_SE&quot; Cox Standard Error of log Hazard Ratio (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;HR_Z&quot; Cox Z-Score (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;HR_P&quot; 1-sided Cox p-value (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;LR_Z&quot; Log-Rank Test Z-Score (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;LR_P&quot; 1-sided Log-Rank Test p-value (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;Events_Active&quot; Events in Active arm (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;Events_Control&quot; Events in Control arm (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;RMST_Time&quot; RMST restriction time (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Active&quot; RMST for Active arm (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Active_SE&quot; RMST Standard Error for Active arm (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Control&quot; RMST for Control arm (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Control_SE&quot; RMST Standard Error for Control arm (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Delta&quot; RMST difference between arms active-control (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Delta_SE&quot; RMST difference between arms Standard Error (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Z&quot; Z-score for RMST (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_P&quot; 1-sided RMST p-value (RMST analysis only)
</p>
</li>
<li><p>&quot;LM_Time&quot; Landmark time, i.e. time of survival function comparison  (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Active&quot; Survival function for active arm at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Active_SE&quot; Greenwood standard error for active arm at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Control&quot; Survival function for control arm at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Control_SE&quot; Greenwood standard error for control arm at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Delta&quot; Survival function difference between arms active-control at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Delta_SE&quot; Greenwood standard error for difference between arms at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Z&quot; Z-score for landmark analysis (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_P&quot; 1-sided landmark analysis p-value (Landmark analysis only)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>References</h3>

<p>Uno H, Claggett B, Tian L, Inoue E, Gallo P, Miyata T, Schrag D, Takeuchi M, Uyama Y, Zhao L,
Skali H, Solomon S, Jacobus S, Hughes M, Packer M, Wei LJ. Moving beyond the hazard ratio in
quantifying the between-group difference in survival analysis. Journal of clinical Oncology 2014,32, 2380-2385.
Tian L, Zhao L, Wei LJ. Predicting the restricted mean event time with the subjects baseline covariates in survival analysis.
Biostatistics 2014, 15, 222-233.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_sim &lt;- simulate_trials(active_ecurve=Weibull(250,0.8),control_ecurve=Weibull(100,1),
rcurve=LinearR(12,100,100), assess=20,iterations=100,seed=12345,detailed_output=TRUE)

example_analysis1 &lt;- analyse_sim(example_sim)
example_analysis2 &lt;- analyse_sim(data=example_sim,RMST=15,landmark=15)

example_strat_sim &lt;- simulate_trials_strata(stratum_probs=c(0.5,0.5),
active_ecurve=c(Weibull(250,0.8),Weibull(100,1)), control_ecurve=Weibull(100,1),
rcurve=LinearR(12,100,100),assess=20,iterations=100,seed=12345)

example_strat_analysis &lt;- analyse_sim(data=example_strat_sim,RMST=15,landmark=15,stratum="Stratum")
</code></pre>

<hr>
<h2 id='Blank'>Blank Curve constructor function</h2><span id='topic+Blank'></span>

<h3>Description</h3>

<p>This creates a Curve object for a 'Blank' pseudo-distribution.<br />
Curve objects contain all necessary information to describe a distribution, including functions and parameters describing it.<br />
This distribution is 0 by definition for all times. It is not therefore a true probability distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Blank()
</code></pre>


<h3>Details</h3>

<p>The blank pseudo-distribution is used for impossible events, notably where censoring is not possible/allowed.<br />
f(x) = 0<br />
F(x) = 0
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Blank()
</code></pre>

<hr>
<h2 id='create_tte_prior'>Create an arbitrary prior data set from a specified Curve object</h2><span id='topic+create_tte_prior'></span>

<h3>Description</h3>

<p>This is a function to create a patient-level prior data set from a specified Curve.<br />
It can be used to create a prior data set where only summary parameters are known.
It requires a 'curve' object containing the desired distribution, the 'time' over which events occur and the number of 'events'.
Designed to be used in conjunction with event prediction methods.
Note that the output can be 'too perfect', so that when the output is used for curve-fitting it may result in over-precision.
To minimise this effect, it may better to derive the prior data set using a different distribution to the one later used for fitting or specifying down-weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_tte_prior(
  curve,
  duration,
  events,
  Time = "Time",
  Event = "Event",
  censoringOne = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_tte_prior_+3A_curve">curve</code></td>
<td>
<p>Curve object with the desired prior distribution</p>
</td></tr>
<tr><td><code id="create_tte_prior_+3A_duration">duration</code></td>
<td>
<p>The positive number for the time over which events should occur. This controls data maturity.
When used as a prior, the longer the time, the more information is provided.</p>
</td></tr>
<tr><td><code id="create_tte_prior_+3A_events">events</code></td>
<td>
<p>The positive integer for the number of events that should occur. The more events, the more information contained when used as a prior.</p>
</td></tr>
<tr><td><code id="create_tte_prior_+3A_time">Time</code></td>
<td>
<p>The output column name for the times. Default is &quot;Time&quot;</p>
</td></tr>
<tr><td><code id="create_tte_prior_+3A_event">Event</code></td>
<td>
<p>The output column name for the events column (i.e. the binary variable denoting events vs censorings). Default is &quot;Event&quot;</p>
</td></tr>
<tr><td><code id="create_tte_prior_+3A_censoringone">censoringOne</code></td>
<td>
<p>Specify whether output censoring is denoted in the Event column by a one (TRUE) or zero (FALSE). Default=FALSE (censorings denoted by 0, events by 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-column data frame containing times in the first column and an event/censoring indicator in the second.
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_prior &lt;- create_tte_prior(curve=Weibull(100,0.8),duration=20,events=50)
</code></pre>

<hr>
<h2 id='createRFfunction'>Method for creating a random draw function from a Curve object</h2><span id='topic+createRFfunction'></span>

<h3>Description</h3>

<p>This creates a random draw function from the Curve object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRFfunction(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createRFfunction_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="createRFfunction_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>createRFfunction(Weibull(100,1))
</code></pre>

<hr>
<h2 id='createRFfunction+2CCurve-method'>Method for creating a random draw function from a Curve object</h2><span id='topic+createRFfunction+2CCurve-method'></span>

<h3>Description</h3>

<p>This creates a random draw function from the Curve object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
createRFfunction(theObject, n = "n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createRFfunction+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="createRFfunction+2B2CCurve-method_+3A_n">n</code></td>
<td>
<p>The parameter name for the number of random draws to make. Default=n</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>createRFfunction(Weibull(100,1))
</code></pre>

<hr>
<h2 id='Curve-class'>Curve Class for defining distributions</h2><span id='topic+Curve-class'></span>

<h3>Description</h3>

<p>This class allows distributions to be defined. It contains all information needed to reproduce a distribution.<br />
References to functions that store the PDF, CDF and random number generator.<br />
Parameters are also stored.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Type of Curve (character). Typically the distribution name.</p>
</dd>
<dt><code>PDF</code></dt><dd><p>Name of the PDF function describing the Curve.</p>
</dd>
<dt><code>CDF</code></dt><dd><p>Name of the CDF function describing the Curve.</p>
</dd>
<dt><code>RF</code></dt><dd><p>Name of the random generator function describing the Curve.</p>
</dd>
<dt><code>inverse</code></dt><dd><p>Name of the inverse CDF function describing the Curve. Optional; set to NULL if unavailable.</p>
</dd>
<dt><code>paramno</code></dt><dd><p>Number of parameters required to define the distribution.</p>
</dd>
<dt><code>pnames</code></dt><dd><p>Names of parameters defining the distribution. Should be a vector of length paramno.</p>
</dd>
<dt><code>pvalue</code></dt><dd><p>Values of parameters defining the distribution. Should be a list of length paramno.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new("Curve", type="ExampleCurve",PDF="pdf_fn_name",CDF="CDF_fn_name",
  RF="random_draw_fn_name", inverse="inv_fn_name",paramno=2,pnames=c('param1','param2'),
  pvalue=list(1,2))
</code></pre>

<hr>
<h2 id='evaluateCDFfunction'>Method for evaluating the CDF function for a Curve object at q</h2><span id='topic+evaluateCDFfunction'></span>

<h3>Description</h3>

<p>This numerically evaluates the CDF function of the Curve object at the specified q
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateCDFfunction(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluateCDFfunction_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="evaluateCDFfunction_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>evaluateCDFfunction(Weibull(100,1),10)
</code></pre>

<hr>
<h2 id='evaluateCDFfunction+2CCurve-method'>Method for evaluating the CDF function for a Curve object at q</h2><span id='topic+evaluateCDFfunction+2CCurve-method'></span>

<h3>Description</h3>

<p>This numerically evaluates the CDF function of the Curve object at the specified q
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
evaluateCDFfunction(theObject, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluateCDFfunction+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="evaluateCDFfunction+2B2CCurve-method_+3A_q">q</code></td>
<td>
<p>The time to evaluate at</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>evaluateCDFfunction(Weibull(100,1),10)
</code></pre>

<hr>
<h2 id='evaluateInvfunction'>Method for evaluating the inverse-CDF function for a Curve object at p</h2><span id='topic+evaluateInvfunction'></span>

<h3>Description</h3>

<p>This numerically evaluates the inverse-CDF function of the Curve object at the specified p
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateInvfunction(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluateInvfunction_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="evaluateInvfunction_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>evaluateInvfunction(Weibull(100,1), 0.5)
</code></pre>

<hr>
<h2 id='evaluateInvfunction+2CCurve-method'>Method for evaluating the inverse-CDF function for a Curve object at p</h2><span id='topic+evaluateInvfunction+2CCurve-method'></span>

<h3>Description</h3>

<p>This numerically evaluates the inverse-CDF function of the Curve object at the specified p
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
evaluateInvfunction(theObject, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluateInvfunction+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="evaluateInvfunction+2B2CCurve-method_+3A_p">p</code></td>
<td>
<p>The probability to evaluate the time at</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>evaluateInvfunction(Weibull(100,1), 0.5)
</code></pre>

<hr>
<h2 id='evaluatePDFfunction'>Method for evaluating the PDF function for a Curve object at x</h2><span id='topic+evaluatePDFfunction'></span>

<h3>Description</h3>

<p>This numerically evaluates the PDF function of the Curve object at the specified x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluatePDFfunction(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluatePDFfunction_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="evaluatePDFfunction_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>evaluatePDFfunction(Weibull(100,1),10)
</code></pre>

<hr>
<h2 id='evaluatePDFfunction+2CCurve-method'>Method for evaluating the PDF function for a Curve object at x</h2><span id='topic+evaluatePDFfunction+2CCurve-method'></span>

<h3>Description</h3>

<p>This numerically evaluates the PDF function of the Curve object at the specified x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
evaluatePDFfunction(theObject, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluatePDFfunction+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="evaluatePDFfunction+2B2CCurve-method_+3A_x">x</code></td>
<td>
<p>The time to evaluate at</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>evaluatePDFfunction(Weibull(100,1),10)
</code></pre>

<hr>
<h2 id='event_prediction'>Event prediction using patient-level survival data and a recruitment RCurve</h2><span id='topic+event_prediction'></span>

<h3>Description</h3>

<p>This is a function to perform event prediction<br />
It uses the fit_KM_tte_data function to perform MLE regression of Weibull and log-normal curves to the provided survival data.<br />
It creates an event Curve object from this, and combines it with a recruitment RCurve and an optional dropout(censoring) Curve.<br />
Using the same numerical integration approach as nph_curve_trajectories it performs an unconditional event prediction.<br />
If a conditioning time and event number (preferably also a number at risk) are provided, a conditional event prediction is also calculated.<br />
Analytic standard errors for conditional and unconditional event numbers are provided for the whole trajectory.<br />
SEs calculated by propagating parameter estimate errors through the integrals by the delta method and then invoking a beta-binomial distribution.<br /><br />
For event prediction, conditional predictions with the Conditional SE of Prediction are most accurate and appropriate.<br />
Unconditional predictions should be close to conditional ones but technically relate to predictions if the trial were rerun, rather than this specific instance.
Point estimates are usually very close to the unconditional ones, but the prediction intervals are typically much wider than necessary.
The conditional and unconditional SEs of fitting relate to the accuracy of the estimated mean event number at a given time, rather than the spread of future observations.
The conditional and unconditional SEs of prediction relate to the accuracy of prediction of future observations, and should therefore be used for event prediction.
Note that the Prediction SEs are wider than the Fitting SEs as they also take into account the binomial uncertainty of events occurring (beta-binomial model).
As of version 1.4.0, the 'CI' argument has been renamed 'PI', and the 'condition' argument has been removed entirely (conditioning automatically occurs if cond_Event specified).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_prediction(
  data,
  Time = "Time",
  Event = "Event",
  censoringOne = FALSE,
  type = c("automatic", "Exponential", "Weibull", "Lognormal"),
  rcurve,
  max_time = 100,
  dcurve = Blank(),
  CI = NULL,
  PI = 0.95,
  condition = NULL,
  cond_Events = NULL,
  cond_NatRisk = NULL,
  cond_Time = NULL,
  units = c("Days", "Months"),
  init = NULL,
  discountHR = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_prediction_+3A_data">data</code></td>
<td>
<p>The dataframe object containing the patient-level survival data</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_time">Time</code></td>
<td>
<p>The column name for the times. Default is &quot;Time&quot;</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_event">Event</code></td>
<td>
<p>The column name for the events column (i.e. the binary variable denoting events vs censorings). Default is &quot;Event&quot;</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_censoringone">censoringOne</code></td>
<td>
<p>Specify whether censoring is denoted in the Event column by a one (TRUE) or zero (FALSE). Default=FALSE (censorings denoted by 0, events by 1)</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_type">type</code></td>
<td>
<p>Type of event curve to fit. Default is &quot;Automatic&quot;, fitting both Weibull and Log-normal curves.
Alternatively accepts &quot;Weibull&quot;, &quot;Lognormal&quot; or &quot;Exponential&quot; to force the type.</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_rcurve">rcurve</code></td>
<td>
<p>Observed and/or expected recruitment distribution as an RCurve object. This should typically be of PieceR type (piecewise linear recruitment).</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_max_time">max_time</code></td>
<td>
<p>Maximum time to predict events up to.</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_dcurve">dcurve</code></td>
<td>
<p>Dropout/censoring distribution as a Curve object. This is Blank() by default, i.e. no dropout.</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_ci">CI</code></td>
<td>
<p>DEPRECATED As of version 1.4.0 this argument has been renamed to 'PI'.</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_pi">PI</code></td>
<td>
<p>Number between 0 and 1 for the size of prediction interval to calculate. As of 1.4.0 this replaces the 'CI' argument. Default is 0.95 (95 percent prediction interval).</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_condition">condition</code></td>
<td>
<p>DEPRECATED This argument has been removed as of version 1.4.0. Specifying a value for 'cond_Events' will now enable conditioned predictions.</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_cond_events">cond_Events</code></td>
<td>
<p>Number of observed events at the conditioning time to condition on. If NULL, no conditioned event prediction will be performed. Default=NULL (no conditioning).
Note that if the discountHR option is used to predict adjusted event numbers, it would be possible to condition on either observed or adjusted events, but the observed number is required by this function.</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_cond_natrisk">cond_NatRisk</code></td>
<td>
<p>Number of patients at risk to condition on. Default=NULL.
By default, the program will estimate the number at risk assuming no censoring. It is highly recommended to specify this if conditioning.</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_cond_time">cond_Time</code></td>
<td>
<p>Time, in months, to condition on. A non-negative integer less than max_time is required if conditioning is requested, i.e. cond_Events is non-NULL. Not required otherwise.</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_units">units</code></td>
<td>
<p>Units that the KM-curve is specified in. Accepts &quot;Days&quot;, &quot;Months&quot;. Default=&quot;Days&quot;. Note: gestate assumes conversion factor of 365.25/12.</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_init">init</code></td>
<td>
<p>Vector of starting values for parameter values; useful if survreg experiences convergence issues. Default=NULL (no values specified)</p>
</td></tr>
<tr><td><code id="event_prediction_+3A_discounthr">discountHR</code></td>
<td>
<p>Hazard ratio for discounting events e.g. used to predict adjudicated events from unadjudicated data where patients remain 'at risk' after an event is adjudicated not to have occurred.
Values below 1 indicate fewer events will occur than predicted by the curve-fitting.
When a discountHR is user-specified (i.e. not 1), conditioning event numbers need to be specified in terms of observed values, and not adjusted ones.
Note that changing this argument is only allowed if type=&quot;Weibull&quot; since log-normal curves are not compatible with proportional hazards.
If patients become not at risk following a failed adjudication (i.e. removed from study), do not use this argument and instead adjust the output event numbers by the required factor.
Default=1 (No discounting for adjudication)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list object with the prediction ecurve (after adjustments for unit, discountHR), dcurve, rcurve, required PI, original fitted ecurve parameters (before adjustments)
and a summary table with one row per month up to max_time containing the following columns:
</p>

<ul>
<li><p>&quot;Assessment_Time&quot;Time of assessment.
</p>
</li>
<li><p>&quot;Patients&quot;Number of patients recruited by the assessment time.
</p>
</li>
<li><p>&quot;Predicted_Events&quot;Number of events unconditionally predicted at the assessment time.
</p>
</li>
<li><p>&quot;SE_Fitting&quot;SE of the estimate of the fitted mean. Note that this corresponds to the accuracy of the estimate of the underlying parameter, not future observed event numbers.
</p>
</li>
<li><p>&quot;SE_Prediction&quot;SE of event prediction.
</p>
</li>
<li><p>&quot;Prediction_Lower&quot;Lower bound of X percent interval of unconditional event prediction, where X is the 'PI' argument. This PI is based on the quantiles of the beta-binomial distribution and so is discrete and asymmetric.
</p>
</li>
<li><p>&quot;Prediction_Upper&quot;Upper bound of X percent interval of unconditional event prediction, where X is the 'PI' argument. This PI is based on the quantiles of the beta-binomial distribution and so is discrete and asymmetric.
</p>
</li>
<li><p>&quot;Conditioned_Events&quot;Number of events conditionally predicted at the assessment time (Column present only if conditioning specified).
</p>
</li>
<li><p>&quot;Cond_SE_Fitting&quot;SE of the estimate of the fitted conditional mean. Note that this corresponds to the accuracy of the estimate of the underlying parameter, not future observed event numbers (Column present only if conditioning specified).
</p>
</li>
<li><p>&quot;Cond_SE_Prediction&quot;SE of the conditional event prediction (Column present only if conditioning specified).
</p>
</li>
<li><p>&quot;Cond_Prediction_Lower&quot;Lower bound of X percent interval of conditional event prediction, where X is the 'PI' argument. This PI is based on the quantiles of the beta-binomial distribution and so is discrete and asymmetric.
</p>
</li>
<li><p>&quot;Cond_Prediction_Upper&quot;Upper bound of X percent interval of conditional event prediction, where X is the 'PI' argument. This PI is based on the quantiles of the beta-binomial distribution and so is discrete and asymmetric.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>References</h3>

<p>Bell J, &quot;Are we nearly there yet?&quot; Quantifying uncertainty in event prediction, 2019, presentation at PSI Conference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recruit &lt;- PieceR(matrix(c(rep(1,12),10,15,25,30,45,60,55,50,65,60,55,30),ncol=2),1)
trial_short &lt;- simulate_trials(active_ecurve=Weibull(50,0.8),control_ecurve=Weibull(50,0.8),
rcurve=recruit, assess=10,iterations=1,seed=12345,detailed_output=TRUE)

predictions &lt;- event_prediction(data=trial_short, Event="Censored", censoringOne=TRUE,
type="Weibull", rcurve=recruit, max_time=60, cond_Events=49, cond_NatRisk=451,
cond_Time=10, units="Months")
</code></pre>

<hr>
<h2 id='event_prediction_KM'>Event prediction using a lifetable and a recruitment RCurve</h2><span id='topic+event_prediction_KM'></span>

<h3>Description</h3>

<p>This is a function to perform event prediction using summary-level data. As of 1.4.0 this function is deprecated as event_prediction gives improved accuracy.<br />
It uses the fit_KM function to perform non-linear regression of Weibull and log-normal curves to the provided survival data.<br />
It creates an event Curve object from this, and combines it with a recruitment RCurve and an optional dropout(censoring) Curve.<br />
Using the same numerical integration approach as nph_curve_trajectories it performs an unconditional event prediction.<br />
If a conditioning time, event number (and preferably number at risk) are provided, a conditional event prediction is also calculated.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_prediction_KM(
  KMcurve,
  Survival = "Survival",
  Time = "Time",
  weighting = FALSE,
  Weights = "Weights",
  Weight_power = 1,
  rcurve,
  max_time = 100,
  dcurve = Blank(),
  type = c("automatic", "Weibull", "Lognormal", "Exponential"),
  startbeta = 1,
  startsigma = 1,
  condition = FALSE,
  cond_Events = 0,
  cond_NatRisk = NULL,
  cond_Time = 0,
  units = c("Days", "Months"),
  discountHR = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_prediction_KM_+3A_kmcurve">KMcurve</code></td>
<td>
<p>The dataframe object containing the survival data</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_survival">Survival</code></td>
<td>
<p>The column name for the survival function (i.e. the probabilities). Default is &quot;Survival&quot;</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_time">Time</code></td>
<td>
<p>The column name for the times. Default is &quot;Time&quot;
Alternatively accepts &quot;Weibull&quot; or &quot;Lognormal&quot; to force the type.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_weighting">weighting</code></td>
<td>
<p>Boolean for whether to use weighting. Default=TRUE as it greatly improves curve fitting.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_weights">Weights</code></td>
<td>
<p>Name of Weights column. Default=&quot;Weights&quot;. Optional if weighting=FALSE. Recommended to use number at risk or remaining.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_weight_power">Weight_power</code></td>
<td>
<p>Power to raise the weights to. Useful in large trials to give added weight to later points where numbers may still be high. Default=1 (Use weights as specified).</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_rcurve">rcurve</code></td>
<td>
<p>Observed and/or expected recruitment distribution as an RCurve object. This should typically be of PieceR type (piecewise linear recruitment).</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_max_time">max_time</code></td>
<td>
<p>Maximum time to predict events up to.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_dcurve">dcurve</code></td>
<td>
<p>Dropout/censoring distribution as a Curve object. This is Blank() by default, i.e. no dropout.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_type">type</code></td>
<td>
<p>Type of event curve to fit. Default is &quot;Automatic&quot;, fitting both Weibull and Log-normal curves.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_startbeta">startbeta</code></td>
<td>
<p>Starting value for the Weibull beta (shape) parameter to be used in the non-linear regression. Default=1 (exponential).</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_startsigma">startsigma</code></td>
<td>
<p>Starting value for the Lognormal sigma (sd) parameter to be used in the non-linear regression. Default=1.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_condition">condition</code></td>
<td>
<p>Boolean whether to also do a conditional event prediction. Default=FALSE
Note that If all conditioning options are left as defaults, conditioned calculation will equal the unconditional one.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_cond_events">cond_Events</code></td>
<td>
<p>Number of events to condition on. Default=0. Optional unless condition=TRUE.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_cond_natrisk">cond_NatRisk</code></td>
<td>
<p>Number of patients at risk to condition on. By default, the program will estimate the number at risk assuming no censoring.
It is highly recommended to specify this if conditioning. Default=NULL(takes value of N - cond_Events). Optional unless condition=TRUE.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_cond_time">cond_Time</code></td>
<td>
<p>Time, in months, to condition on. Default=0. Optional unless condition=TRUE.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_units">units</code></td>
<td>
<p>Units that the KM-curve is specified in. Accepts &quot;Days&quot;, &quot;Months&quot;. Default=&quot;Days&quot;.</p>
</td></tr>
<tr><td><code id="event_prediction_KM_+3A_discounthr">discountHR</code></td>
<td>
<p>Hazard ratio for discounting events e.g. used to predict adjudicated events from unadjudicated data where patients remain 'at risk' after an event is adjudicated not to have occurred.
Values below 1 indicate fewer events will occur than predicted by the curve-fitting.
Note that changing this argument is only allowed if type=&quot;Weibull&quot; since log-normal curves are not compatible with proportional hazards.
Default=1 (No discounting)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list object with the fitted ecurve, the dcurve, the rcurve, the fitting details, and a summary table with one row per month up to max_time containing the following columns:
</p>

<ul>
<li><p>&quot;Time&quot;Time of assessment.
</p>
</li>
<li><p>&quot;Patients&quot;Number of patients recruited by the assessment time.
</p>
</li>
<li><p>&quot;Predicted_Events&quot;Number of events unconditionally predicted at the assessment time.
</p>
</li>
<li><p>&quot;Conditioned_Events&quot;Number of events unconditionally predicted at the assessment time (Column present only if conditioning specified).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recruit &lt;- PieceR(matrix(c(rep(1,12),10,15,25,30,45,60,55,50,65,60,55,30),ncol=2),1)
example_data_short &lt;- simulate_trials(active_ecurve=Weibull(50,0.8),control_ecurve=Weibull(50,0.8),
rcurve=recruit, assess=10,iterations=1,seed=12345,detailed_output=TRUE)

library(survival)

temp1 &lt;- summary(survfit(Surv(example_data_short[,"Time"],1-example_data_short[,"Censored"])~ 1,
error="greenwood"))
out1 &lt;- cbind(temp1$time,temp1$n.risk,temp1$surv,temp1$std.err)
out1 &lt;- rbind(c(0,out1[1,2],1,0),out1)
colnames(out1) &lt;- c("Time","NAR","Survival","Std.Err")
x1 &lt;- ceiling(max(out1[,"Time"]))
example_lifetable &lt;- out1[findInterval(0:x1,out1[,"Time"]),]
example_lifetable[,"Time"] &lt;- 0:x1

event_prediction_KM(KMcurve=example_lifetable, weighting=TRUE, Weights="NAR", rcurve=recruit,
max_time=60, type="automatic", condition=TRUE, cond_Events=49, cond_NatRisk=451, cond_Time=10, 
units="Months")
</code></pre>

<hr>
<h2 id='event_prediction_prior'>Event prediction using patient-level survival data, prior data and a recruitment RCurve</h2><span id='topic+event_prediction_prior'></span>

<h3>Description</h3>

<p>This performs event prediction with a Weibull distribution integrating (weighted) prior data .<br />
Where relevant prior data is available, this function can increase the precision of curve fitting, particularly in cases where there is low data maturity.<br />
This function uses the fit_tte_data_prior function to fit a Weibull distribution to the provided survival data by including weighted prior patient-level data.<br />
An event Curve object is created, which is then used in the same way as that from the frequentist approach in event_prediction.<br />
It consequently operates very similarly to event_prediction in terms of inputs, outputs and methods. Consult its documentation for aspects unrelated to the prior approach.<br />
If a patient-level prior data set is not available, use the create_tte_prior function to create an artificial one from a distribution.
Note that this may cause a small amount of over-precision; this may be minimised by deriving the prior data using a different distribution or specifying down-weighting.<br />
Prior data can be down-weighted using the priorweight variable. Some degree of down-weighting is generally recommended to reflect differences with prior trials.<br />
Column names and the censoring parity in the prior data set are by default the same as those specified for the main data set, but may be manually changed to be different.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_prediction_prior(
  data,
  Time = "Time",
  Event = "Event",
  censoringOne = FALSE,
  priordata,
  priorTime = Time,
  priorEvent = Event,
  priorcensoringOne = censoringOne,
  priorweight = 1,
  type = c("Weibull"),
  rcurve,
  max_time = 100,
  dcurve = Blank(),
  CI = NULL,
  PI = 0.95,
  condition = NULL,
  cond_Events = NULL,
  cond_NatRisk = NULL,
  cond_Time = NULL,
  units = c("Days", "Months"),
  init = NULL,
  discountHR = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_prediction_prior_+3A_data">data</code></td>
<td>
<p>The dataframe object containing the patient-level survival data</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_time">Time</code></td>
<td>
<p>The column name for the times in the 'data' set. Default is &quot;Time&quot;</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_event">Event</code></td>
<td>
<p>The column name for the events column (i.e. the binary variable denoting events vs censorings) in the 'data' set. Default is &quot;Event&quot;</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_censoringone">censoringOne</code></td>
<td>
<p>Specify whether in the 'data' set censoring is denoted by a one (TRUE) or zero (FALSE). Default=FALSE (censorings denoted by 0, events by 1)</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_priordata">priordata</code></td>
<td>
<p>The dataframe object containing the patient-level survival data for the prior</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_priortime">priorTime</code></td>
<td>
<p>The column name for the times in the 'priordata' set. Default= Value specified for Time</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_priorevent">priorEvent</code></td>
<td>
<p>The column name for the events column (i.e. the binary variable denoting events vs censorings) in the 'priordata' set. Default= Value specified for Event</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_priorcensoringone">priorcensoringOne</code></td>
<td>
<p>Specify whether in the 'priordata' set censoring is denoted by a one (TRUE) or zero (FALSE). Default= Value specified for censoringOne</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_priorweight">priorweight</code></td>
<td>
<p>The weight that should be allocated to each patient's data in the prior data, typically between 0 and 1. 0 implies prior data is ignored, 1 that prior patient data is given full weight, i.e. prior patients are exchangeable with observed patients. Default = 1</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_type">type</code></td>
<td>
<p>Type of event curve to fit. Default is &quot;Automatic&quot;, fitting both Weibull and Log-normal curves.
Alternatively accepts &quot;Weibull&quot;, &quot;Lognormal&quot; or &quot;Exponential&quot; to force the type.</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_rcurve">rcurve</code></td>
<td>
<p>Observed and/or expected recruitment distribution as an RCurve object. This should typically be of PieceR type (piecewise linear recruitment).</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_max_time">max_time</code></td>
<td>
<p>Maximum time to predict events up to.</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_dcurve">dcurve</code></td>
<td>
<p>Dropout/censoring distribution as a Curve object. This is Blank() by default, i.e. no dropout.</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_ci">CI</code></td>
<td>
<p>DEPRECATED As of version 1.4.0 this argument has been renamed to 'PI'.</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_pi">PI</code></td>
<td>
<p>Number between 0 and 1 for the size of prediction interval to calculate. As of 1.4.0 this replaces the 'CI' argument. Default is 0.95 (95 percent prediction interval).</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_condition">condition</code></td>
<td>
<p>DEPRECATED This argument has been removed as of version 1.4.0. Specifying a value for 'cond_Events' will now enable conditioned predictions.</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_cond_events">cond_Events</code></td>
<td>
<p>Number of observed events at the conditioning time to condition on. If NULL, no conditioned event prediction will be performed. Default=NULL (no conditioning).
Note that if the discountHR option is used to predict adjusted event numbers, it would be possible to condition on either observed or adjusted events, but the observed number is required by this function.</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_cond_natrisk">cond_NatRisk</code></td>
<td>
<p>Number of patients at risk to condition on. Default=NULL.
By default, the program will estimate the number at risk assuming no censoring. It is highly recommended to specify this if conditioning.</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_cond_time">cond_Time</code></td>
<td>
<p>Time, in months, to condition on. A non-negative integer less than max_time is required if conditioning is requested, i.e. cond_Events is non-NULL. Not required otherwise.</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_units">units</code></td>
<td>
<p>Units that the KM-curve is specified in. Accepts &quot;Days&quot;, &quot;Months&quot;. Default=&quot;Days&quot;.</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_init">init</code></td>
<td>
<p>Vector of starting values for parameter values; useful if survreg experiences convergence issues. Default=NULL (no values specified)</p>
</td></tr>
<tr><td><code id="event_prediction_prior_+3A_discounthr">discountHR</code></td>
<td>
<p>Hazard ratio for discounting events e.g. used to predict adjudicated events from unadjudicated data where patients remain 'at risk' after an event is adjudicated not to have occurred.
Values below 1 indicate fewer events will occur than predicted by the curve-fitting.
When a discountHR is user-specified (i.e. not 1), conditioning event numbers need to be specified in terms of observed values, and not adjusted ones.
Note that changing this argument is only allowed if type=&quot;Weibull&quot; since log-normal curves are not compatible with proportional hazards.
If patients become not at risk following a failed adjudication (i.e. removed from study), do not use this argument and instead adjust the output event numbers by the required factor.
Default=1 (No discounting for adjudication)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list object with the prediction ecurve (after adjustments for unit, discountHR), dcurve, rcurve, required PI, original fitted ecurve parameters (before adjustments)
and a summary table with one row per month up to max_time containing the following columns:
</p>

<ul>
<li><p>&quot;Assessment_Time&quot;Time of assessment.
</p>
</li>
<li><p>&quot;Patients&quot;Number of patients recruited by the assessment time.
</p>
</li>
<li><p>&quot;Predicted_Events&quot;Number of events unconditionally predicted at the assessment time.
</p>
</li>
<li><p>&quot;SE_Fitting&quot;SE of the estimate of the fitted mean. Note that this corresponds to the accuracy of the estimate of the underlying parameter, not future observed event numbers.
</p>
</li>
<li><p>&quot;SE_Prediction&quot;SE of event prediction.
</p>
</li>
<li><p>&quot;Prediction_Lower&quot;Lower bound of X percent interval of unconditional event prediction, where X is the 'PI' argument. This PI is based on the quantiles of the beta-binomial distribution and so is discrete and asymmetric.
</p>
</li>
<li><p>&quot;Prediction_Upper&quot;Upper bound of X percent interval of unconditional event prediction, where X is the 'PI' argument. This PI is based on the quantiles of the beta-binomial distribution and so is discrete and asymmetric.
</p>
</li>
<li><p>&quot;Conditioned_Events&quot;Number of events conditionally predicted at the assessment time (Column present only if conditioning specified).
</p>
</li>
<li><p>&quot;Cond_SE_Fitting&quot;SE of the estimate of the fitted conditional mean. Note that this corresponds to the accuracy of the estimate of the underlying parameter, not future observed event numbers (Column present only if conditioning specified).
</p>
</li>
<li><p>&quot;Cond_SE_Prediction&quot;SE of the conditional event prediction (Column present only if conditioning specified).
</p>
</li>
<li><p>&quot;Cond_Prediction_Lower&quot;Lower bound of X percent interval of conditional event prediction, where X is the 'PI' argument. This PI is based on the quantiles of the beta-binomial distribution and so is discrete and asymmetric.
</p>
</li>
<li><p>&quot;Cond_Prediction_Upper&quot;Upper bound of X percent interval of conditional event prediction, where X is the 'PI' argument. This PI is based on the quantiles of the beta-binomial distribution and so is discrete and asymmetric.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>References</h3>

<p>Bell J, unpublished work.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recruit &lt;- PieceR(matrix(c(rep(1,12),10,15,25,30,45,60,55,50,65,60,55,30),ncol=2),1)
trial_short &lt;- simulate_trials(active_ecurve=Weibull(50,0.8),control_ecurve=Weibull(50,0.8),
rcurve=recruit, assess=10,iterations=1,seed=12345,detailed_output=TRUE,Event="Event",
censoringOne=FALSE)
example_prior &lt;- create_tte_prior(curve=Weibull(alpha=100,beta=0.8),duration=20,events=50)

predictions &lt;- event_prediction_prior(data=trial_short, priordata=example_prior,
type="Weibull", rcurve=recruit, max_time=60, cond_Events=49, cond_NatRisk=451,
cond_Time=10, units="Months")
</code></pre>

<hr>
<h2 id='events2power'>Calculate Schoenfeld or Event Proportion power from number of events</h2><span id='topic+events2power'></span>

<h3>Description</h3>

<p>Calculate Schoenfeld or Event Proportion power from number of events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>events2power(events, HR, ratio = 1, alpha1 = 0.025, HRbound = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="events2power_+3A_events">events</code></td>
<td>
<p>Number of events.</p>
</td></tr>
<tr><td><code id="events2power_+3A_hr">HR</code></td>
<td>
<p>Hazard Ratio. Values below 1 indicate a benefit to the active arm vs control.</p>
</td></tr>
<tr><td><code id="events2power_+3A_ratio">ratio</code></td>
<td>
<p>Randomisation ratio (Schoenfeld), or event ratio (event proportion method). Default=1.</p>
</td></tr>
<tr><td><code id="events2power_+3A_alpha1">alpha1</code></td>
<td>
<p>1-sided alpha. Default=0.025.</p>
</td></tr>
<tr><td><code id="events2power_+3A_hrbound">HRbound</code></td>
<td>
<p>HRvalue to test against. Default=1 (superiority).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Power as a decimal
</p>

<hr>
<h2 id='Exponential'>Exponential Curve constructor function</h2><span id='topic+Exponential'></span>

<h3>Description</h3>

<p>This creates a Curve object for a Exponential distribution.<br />
Curve objects contain all necessary information to describe a distribution, including functions and parameters describing it.<br />
Parameterisation follows that used by pexp etc. Note that lambda = 1/alpha from the Weibull constructor. See Details for more information on parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Exponential(lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exponential_+3A_lambda">lambda</code></td>
<td>
<p>Rate parameter for Exponential distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential distribution has parameterisation:<br />
f(x) = lambda e^(- lambda x)<br />
F(x) = 1 - e^(- lambda x)
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Exponential(0.01)
</code></pre>

<hr>
<h2 id='fit_KM'>Fit Weibull, Log-Normal or Exponential survival curves to Kaplan Meier estimates</h2><span id='topic+fit_KM'></span>

<h3>Description</h3>

<p>This is a function to fit Weibull and log-normal curves to Survival data in life-table form using non-linear regression.<br />
By default it fits both, then picks the best fit based on the lowest (un)weighted residual sum of squares.<br />
Alternatively, just one shape may be fitted, by changing the 'type' argument to either &quot;Weibull&quot; or &quot;Lognormal&quot;.
Weighted or unweighted fitting are possible. In general, weighted fitting using the number at risk as the weights seems to work best.<br />
This function is primarily used by event_prediction function, but also useful for general KM curve fitting.<br />
One useful aspect of this is for fitting the 'inverse KM', where drop-outs are events, while events and 'time-outs' are censored.
This allows for finding a suitable parameterisation for the censoring curve.<br />
Primary advantage over likelihood-based methods is ability to use aggregated, rather than patient-level data.
Primary disadvantage is that the covariance matrix is unusable due to strong correlation between the input data points going into the regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_KM(
  KMcurve,
  Survival = "Survival",
  Time = "Time",
  type = c("automatic", "Weibull", "Lognormal", "Exponential"),
  weighting = TRUE,
  Weights = "Weights",
  Weight_power = 1,
  startbeta = 1,
  startsigma = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_KM_+3A_kmcurve">KMcurve</code></td>
<td>
<p>The dataframe object containing the survival data in lifetable form</p>
</td></tr>
<tr><td><code id="fit_KM_+3A_survival">Survival</code></td>
<td>
<p>The column name for the survival function (i.e. the probabilities). Default is &quot;Survival&quot;</p>
</td></tr>
<tr><td><code id="fit_KM_+3A_time">Time</code></td>
<td>
<p>The column name for the times. Default is &quot;Time&quot;</p>
</td></tr>
<tr><td><code id="fit_KM_+3A_type">type</code></td>
<td>
<p>Type of event curve to fit.Default is &quot;Automatic&quot;, fitting both Weibull and Log-normal curves.
Alternatively accepts &quot;Weibull&quot;, &quot;Lognormal&quot; or &quot;Exponential&quot; to force the type.</p>
</td></tr>
<tr><td><code id="fit_KM_+3A_weighting">weighting</code></td>
<td>
<p>Boolean for whether to use weighting. Default=TRUE as it greatly improves curve fitting.</p>
</td></tr>
<tr><td><code id="fit_KM_+3A_weights">Weights</code></td>
<td>
<p>Name of Weights column. Default=&quot;Weights&quot;. Optional if weighting=FALSE. Recommended to use number at risk or remaining.</p>
</td></tr>
<tr><td><code id="fit_KM_+3A_weight_power">Weight_power</code></td>
<td>
<p>Power to raise the weights to. Useful in large trials to give added weight to later points where numbers may still be high. Default=1 (Use weights as specified)</p>
</td></tr>
<tr><td><code id="fit_KM_+3A_startbeta">startbeta</code></td>
<td>
<p>Starting value for the Weibull beta (shape) parameter to be used in the non-linear regression. Default=1 (exponential).</p>
</td></tr>
<tr><td><code id="fit_KM_+3A_startsigma">startsigma</code></td>
<td>
<p>Starting value for the Lognormal sigma (sd) parameter to be used in the non-linear regression. Default=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3-item list providing information needed to define a Curve object:
</p>

<ul>
<li><p>&quot;Item 1&quot;The type of Curve object fitted.
</p>
</li>
<li><p>&quot;Item 2&quot;A list of fitted parameters for the curve type.
</p>
</li>
<li><p>&quot;Item 3&quot;A placeholder vector of NAs where the covariance-matrix parameters should be.
</p>
</li>
<li><p>&quot;Item 4&quot;A data frame containing the goodness of fit metrics for each curve type.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recruit &lt;- PieceR(matrix(c(rep(1,12),10,15,25,30,45,60,55,50,65,60,55,30),ncol=2),1)
example_data_short &lt;- simulate_trials(active_ecurve=Weibull(50,0.8),
control_ecurve=Weibull(50,0.8), rcurve=recruit,assess=10,iterations=1,seed=12345,
detailed_output=TRUE)

library(survival)

temp1  &lt;- summary(survfit(Surv(example_data_short[,"Time"],1-example_data_short[,"Censored"])~ 1,
error="greenwood"))
out1 &lt;- cbind(temp1$time,temp1$n.risk,temp1$surv,temp1$std.err)
out1 &lt;- rbind(c(0,out1[1,2],1,0),out1)
colnames(out1) &lt;- c("Time","NAR","Survival","Std.Err")
x1 &lt;- ceiling(max(out1[,"Time"]))
example_lifetable &lt;- out1[findInterval(0:x1,out1[,"Time"]),]
example_lifetable[,"Time"] &lt;- 0:x1

fit_KM(KMcurve=example_lifetable,Survival="Survival",Time="Time",Weights="NAR",type="automatic")
</code></pre>

<hr>
<h2 id='fit_tte_data'>Fit Weibull, Log-Normal or Exponential survival curves to patient-level time-to-event data</h2><span id='topic+fit_tte_data'></span>

<h3>Description</h3>

<p>This is a function to fit Weibull and log-normal curves to patient-level Survival data using maximum likelihood estimation.<br />
By default it fits both, then picks the best fit based on the log-likelihood (and implicitly the AIC).<br />
Alternatively, just one shape may be fitted, by changing the 'type' argument to either &quot;Weibull&quot; or &quot;Lognormal&quot;.
This function is primarily used by event_prediction_data function, but also useful for general Survival function curve fitting.<br />
One useful aspect of this is for fitting the 'inverse KM', where drop-outs are events, while events and 'time-outs' are censored.
This allows for finding a suitable parameterisation for the censoring curve.<br />
Where patient-level data is available, this function will typically perform substantially better than fit_KM, with lower variability of point estimates (and more accurate quantification of it).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_tte_data(
  data,
  Time = "Time",
  Event = "Event",
  censoringOne = FALSE,
  type = c("automatic", "Weibull", "Lognormal", "Exponential"),
  init = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_tte_data_+3A_data">data</code></td>
<td>
<p>The dataframe object containing the patient-level survival data</p>
</td></tr>
<tr><td><code id="fit_tte_data_+3A_time">Time</code></td>
<td>
<p>The column name for the times. Default is &quot;Time&quot;</p>
</td></tr>
<tr><td><code id="fit_tte_data_+3A_event">Event</code></td>
<td>
<p>The column name for the events column (i.e. the binary variable denoting events vs censorings). Default is &quot;Event&quot;</p>
</td></tr>
<tr><td><code id="fit_tte_data_+3A_censoringone">censoringOne</code></td>
<td>
<p>Specify whether censoring is denoted in the Event column by a one (TRUE) or zero (FALSE). Default=FALSE (censorings denoted by 0, events by 1)</p>
</td></tr>
<tr><td><code id="fit_tte_data_+3A_type">type</code></td>
<td>
<p>Type of event curve to fit. Default is &quot;Automatic&quot;, fitting both Weibull and Log-normal curves.
Alternatively accepts &quot;Weibull&quot; or &quot;Lognormal&quot; to force the type.</p>
</td></tr>
<tr><td><code id="fit_tte_data_+3A_init">init</code></td>
<td>
<p>Vector of starting values for parameter values; useful if survreg experiences convergence issues. Default=NULL (no values specified)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3-item list providing information needed to define a Curve object:
</p>

<ul>
<li><p>&quot;Item 1&quot;The type of Curve object fitted.
</p>
</li>
<li><p>&quot;Item 2&quot;A list of fitted parameters for the curve type.
</p>
</li>
<li><p>&quot;Item 3&quot;A vector containing the covariance-matrix parameters for the curve type.
</p>
</li>
<li><p>&quot;Item 4&quot;A data frame containing the goodness of fit metrics for each curve type.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recruit &lt;- PieceR(matrix(c(rep(1,12),10,15,25,30,45,60,55,50,65,60,55,30),ncol=2),1)
example_data &lt;- simulate_trials(active_ecurve=Weibull(50,0.8),control_ecurve=Weibull(50,0.8),
rcurve=recruit, assess=10,iterations=1,seed=12345,detailed_output=TRUE)

fit_tte_data(data=example_data,Time="Time",Event="Censored",censoringOne=TRUE,type="automatic")
</code></pre>

<hr>
<h2 id='fit_tte_data_prior'>Fit Weibull survival curves to patient-level time-to-event data by including patient-level weighted prior data</h2><span id='topic+fit_tte_data_prior'></span>

<h3>Description</h3>

<p>This is a function to fit Weibull curves to patient-level Survival data integrating (weighted) prior data.<br />
Where relevant prior data is available, this function can increase the precision of curve fitting, particularly in cases where there is low data maturity.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_tte_data_prior(
  data,
  Time = "Time",
  Event = "Event",
  censoringOne = FALSE,
  type = c("Weibull"),
  priordata,
  priorTime = Time,
  priorEvent = Event,
  priorcensoringOne = censoringOne,
  priorweight = 1,
  init = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_tte_data_prior_+3A_data">data</code></td>
<td>
<p>The dataframe object containing the patient-level survival data</p>
</td></tr>
<tr><td><code id="fit_tte_data_prior_+3A_time">Time</code></td>
<td>
<p>The column name for the times. Default is &quot;Time&quot;</p>
</td></tr>
<tr><td><code id="fit_tte_data_prior_+3A_event">Event</code></td>
<td>
<p>The column name for the events column (i.e. the binary variable denoting events vs censorings). Default is &quot;Event&quot;</p>
</td></tr>
<tr><td><code id="fit_tte_data_prior_+3A_censoringone">censoringOne</code></td>
<td>
<p>Specify whether censoring is denoted in the Event column by a one (TRUE) or zero (FALSE). Default=FALSE (censorings denoted by 0, events by 1)</p>
</td></tr>
<tr><td><code id="fit_tte_data_prior_+3A_type">type</code></td>
<td>
<p>Type of event curve to fit. Default is &quot;Weibull&quot;, the only type currently accepted</p>
</td></tr>
<tr><td><code id="fit_tte_data_prior_+3A_priordata">priordata</code></td>
<td>
<p>The dataframe object containing a patient-level prior dataset.
Where a patient-level prior data set is not readily available, the function create_tte_prior can be used to create one from summary parameters.
Naming and format of time and event columns should match that of 'data'. Default=NULL (no prior data)</p>
</td></tr>
<tr><td><code id="fit_tte_data_prior_+3A_priortime">priorTime</code></td>
<td>
<p>The column name for the prior times. Default is the same value as Time</p>
</td></tr>
<tr><td><code id="fit_tte_data_prior_+3A_priorevent">priorEvent</code></td>
<td>
<p>The column name for the prior events (i.e. the binary variable denoting events vs censorings). Default is the same value as Event</p>
</td></tr>
<tr><td><code id="fit_tte_data_prior_+3A_priorcensoringone">priorcensoringOne</code></td>
<td>
<p>Specify whether censoring is denoted in the prior Event column by a one (TRUE) or zero (FALSE). Default is the same as censoringOne</p>
</td></tr>
<tr><td><code id="fit_tte_data_prior_+3A_priorweight">priorweight</code></td>
<td>
<p>The weight to assign the prior data; a non-negative number, where 0 corresponds to no weight, i.e. ignore prior data, and 1 corresponds to equal
weighting of prior and observed data.
The prior weight should typically not be greater than 1. Default=1 (prior patients weighted equivalently to observed data)</p>
</td></tr>
<tr><td><code id="fit_tte_data_prior_+3A_init">init</code></td>
<td>
<p>Vector of starting values for parameter values; useful if survreg experiences convergence issues. Default=NULL (no values specified)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily used by the event_prediction_prior function, but also useful for Weibull curve fitting across two patient-level data sets.<br />
If a patient-level prior data set is not available, use the create_tte_prior function to create an artificial one from a distribution.
Note that this may cause a small amount of over-precision; this may be minimised by deriving the prior data using a different distribution or specifying down-weighting.<br />
</p>


<h3>Value</h3>

<p>Returns a 3-item list providing information needed to define a Curve object:
</p>

<ul>
<li><p>&quot;Item 1&quot;The type of Curve object fitted.
</p>
</li>
<li><p>&quot;Item 2&quot;A list of fitted parameters for the curve type.
</p>
</li>
<li><p>&quot;Item 3&quot;A vector containing the covariance-matrix parameters for the curve type.
</p>
</li>
<li><p>&quot;Item 4&quot;A data frame containing the goodness of fit metrics for each curve type.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>References</h3>

<p>Bell J, unpublished work.
D Fink, A Compendium of Conjugate Priors, 1997
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recruit &lt;- PieceR(matrix(c(rep(1,12),10,15,25,30,45,60,55,50,65,60,55,30),ncol=2),1)
example_data &lt;- simulate_trials(active_ecurve=Weibull(50,0.8),control_ecurve=Weibull(50,0.8),
rcurve=recruit, assess=10,iterations=1,seed=12345,detailed_output=TRUE,Event="Event",
censoringOne=FALSE)
example_prior &lt;- create_tte_prior(curve=Weibull(alpha=100,beta=0.8),duration=20,events=50)

fit_tte_data_prior(data=example_data,priordata=example_prior,priorweight=0.5)
</code></pre>

<hr>
<h2 id='freedmanpower'>Calculate Freedman power from number of events</h2><span id='topic+freedmanpower'></span>

<h3>Description</h3>

<p>Calculate Freedman power from number of events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freedmanpower(events, HR, ratio = 1, alpha1 = 0.025)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freedmanpower_+3A_events">events</code></td>
<td>
<p>Number of events.</p>
</td></tr>
<tr><td><code id="freedmanpower_+3A_hr">HR</code></td>
<td>
<p>Hazard Ratio.</p>
</td></tr>
<tr><td><code id="freedmanpower_+3A_ratio">ratio</code></td>
<td>
<p>Randomisation ratio. Default=1.</p>
</td></tr>
<tr><td><code id="freedmanpower_+3A_alpha1">alpha1</code></td>
<td>
<p>1-sided alpha. Default=0.025.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Power as a decimal
</p>

<hr>
<h2 id='frontierpower'>Calculate Frontier power from number of events</h2><span id='topic+frontierpower'></span>

<h3>Description</h3>

<p>Calculate Frontier power from number of events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frontierpower(
  events,
  HR,
  Eratio,
  Rratio = 1,
  startpower = 0.5,
  alpha1 = 0.025,
  HRbound = 1,
  iter = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frontierpower_+3A_events">events</code></td>
<td>
<p>Number of events.</p>
</td></tr>
<tr><td><code id="frontierpower_+3A_hr">HR</code></td>
<td>
<p>Hazard Ratio. Values below 1 indicate a benefit to the active arm vs control.</p>
</td></tr>
<tr><td><code id="frontierpower_+3A_eratio">Eratio</code></td>
<td>
<p>Event ratio.</p>
</td></tr>
<tr><td><code id="frontierpower_+3A_rratio">Rratio</code></td>
<td>
<p>Randomisation ratio. Default=1.</p>
</td></tr>
<tr><td><code id="frontierpower_+3A_startpower">startpower</code></td>
<td>
<p>Initial estimate of power. Default=0.5.</p>
</td></tr>
<tr><td><code id="frontierpower_+3A_alpha1">alpha1</code></td>
<td>
<p>1-sided alpha. Default=0.025.</p>
</td></tr>
<tr><td><code id="frontierpower_+3A_hrbound">HRbound</code></td>
<td>
<p>HRvalue to test against. Default=1 (superiority).</p>
</td></tr>
<tr><td><code id="frontierpower_+3A_iter">iter</code></td>
<td>
<p>Number of iterations to perform. Default=10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Power as a decimal
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>References</h3>

<p>Bell J, Power Calculations for Time-to-Event Trials Using Predicted Event Proportions, 2019, paper under review.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frontierpower(events=300,HR=0.7,Eratio=1.2,Rratio=1.5,alpha1=0.025)
</code></pre>

<hr>
<h2 id='getAssessCDFfunction'>Method for returning the CDF function for a RCurve object</h2><span id='topic+getAssessCDFfunction'></span>

<h3>Description</h3>

<p>This retrieves the CDF function of the specified RCurve object as a string, writing in the assessment time parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAssessCDFfunction(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAssessCDFfunction_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="getAssessCDFfunction_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getAssessCDFfunction(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getAssessCDFfunction+2CRCurve-method'>Method for returning the CDF function for a RCurve object</h2><span id='topic+getAssessCDFfunction+2CRCurve-method'></span>

<h3>Description</h3>

<p>This retrieves the CDF function of the specified RCurve object as a string, writing in the assessment time parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
getAssessCDFfunction(theObject, q = "q")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAssessCDFfunction+2B2CRCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="getAssessCDFfunction+2B2CRCurve-method_+3A_q">q</code></td>
<td>
<p>The parameter name to use in the CDF function. Default=q</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getAssessCDFfunction(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getCDFfunction'>Method for returning the CDF function for a Curve object</h2><span id='topic+getCDFfunction'></span>

<h3>Description</h3>

<p>This retrieves the full CDF function of the Curve object as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCDFfunction(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCDFfunction_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="getCDFfunction_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getCDFfunction(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getCDFfunction+2CCurve-method'>Method for returning the CDF function for a Curve object</h2><span id='topic+getCDFfunction+2CCurve-method'></span>

<h3>Description</h3>

<p>This retrieves the CDF function of the specified Curve object as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
getCDFfunction(theObject, q = "q")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCDFfunction+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="getCDFfunction+2B2CCurve-method_+3A_q">q</code></td>
<td>
<p>The parameter name to use in the CDF function. Default=q</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getCDFfunction(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getInvfunction'>Method for returning the inverse-CDF function for a Curve object</h2><span id='topic+getInvfunction'></span>

<h3>Description</h3>

<p>This retrieves the full inverse-CDF function of the Curve object as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInvfunction(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInvfunction_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="getInvfunction_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getInvfunction(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getInvfunction+2CCurve-method'>Method for returning the inverse-CDF function for a Curve object</h2><span id='topic+getInvfunction+2CCurve-method'></span>

<h3>Description</h3>

<p>This retrieves the inverse CDF function of the specified Curve object as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
getInvfunction(theObject, p = "p")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInvfunction+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="getInvfunction+2B2CCurve-method_+3A_p">p</code></td>
<td>
<p>The probability parameter name to use in the CDF function. Default=p</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getCDFfunction(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getLength'>Method for returning the recruitment length from a RCurve</h2><span id='topic+getLength'></span>

<h3>Description</h3>

<p>This returns the RCurve recruitment length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLength(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLength_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getLength(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getLength+2CRCurve-method'>Method for returning the recruitment length from a RCurve</h2><span id='topic+getLength+2CRCurve-method'></span>

<h3>Description</h3>

<p>This returns the RCurve recruitment length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
getLength(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLength+2B2CRCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getLength(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getMaxF'>Method for returning maximum duration of patient follow-up from a RCurve</h2><span id='topic+getMaxF'></span>

<h3>Description</h3>

<p>This returns the RCurve maximum patient follow-up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxF(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMaxF_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getMaxF(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getMaxF+2CRCurve-method'>Method for returning maximum duration of patient follow-up from a RCurve</h2><span id='topic+getMaxF+2CRCurve-method'></span>

<h3>Description</h3>

<p>This returns the RCurve maximum patient follow-up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
getMaxF(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMaxF+2B2CRCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getMaxF(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getN'>Method for returning the total patient number from a RCurve</h2><span id='topic+getN'></span>

<h3>Description</h3>

<p>This returns the RCurve total patient number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getN(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getN_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getN(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getN+2CRCurve-method'>Method for returning the total patient number from a RCurve</h2><span id='topic+getN+2CRCurve-method'></span>

<h3>Description</h3>

<p>This returns the RCurve total patient number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
getN(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getN+2B2CRCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getN(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getNactive'>Method for returning the active arm patient number from a RCurve</h2><span id='topic+getNactive'></span>

<h3>Description</h3>

<p>This returns the RCurve active arm patient number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNactive(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNactive_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getNactive(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getNactive+2CRCurve-method'>Method for returning the active arm patient number from a RCurve</h2><span id='topic+getNactive+2CRCurve-method'></span>

<h3>Description</h3>

<p>This returns the RCurve active arm patient number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
getNactive(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNactive+2B2CRCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getNactive(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getNames'>Method for returning all parameter names from a Curve object</h2><span id='topic+getNames'></span>

<h3>Description</h3>

<p>This retrieves all parameter names from a Curve object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNames(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNames_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getNames(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getNames+2CCurve-method'>Method for returning all parameter names from a Curve object</h2><span id='topic+getNames+2CCurve-method'></span>

<h3>Description</h3>

<p>This retrieves all parameter names from a Curve object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
getNames(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNames+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getNames(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getNcontrol'>Method for returning the control arm patient number from a RCurve</h2><span id='topic+getNcontrol'></span>

<h3>Description</h3>

<p>This returns the RCurve control arm patient number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNcontrol(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNcontrol_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getNcontrol(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getNcontrol+2CRCurve-method'>Method for returning the control arm patient number from a RCurve</h2><span id='topic+getNcontrol+2CRCurve-method'></span>

<h3>Description</h3>

<p>This returns the RCurve control arm patient number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
getNcontrol(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNcontrol+2B2CRCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getNcontrol(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getParam'>Method for returning a single parameter from a Curve object</h2><span id='topic+getParam'></span>

<h3>Description</h3>

<p>This retrieves a single parameter from a Curve object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParam(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParam_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="getParam_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getParam(Weibull(100,1),1)
</code></pre>

<hr>
<h2 id='getParam+2CCurve-method'>Method for returning a single parameter from a Curve object</h2><span id='topic+getParam+2CCurve-method'></span>

<h3>Description</h3>

<p>This retrieves a single parameter from a Curve object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
getParam(theObject, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParam+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="getParam+2B2CCurve-method_+3A_param">param</code></td>
<td>
<p>The number of the parameter that is required</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getParam(Weibull(100,1),1)
</code></pre>

<hr>
<h2 id='getParams'>Method for returning all parameters from a Curve object as a list</h2><span id='topic+getParams'></span>

<h3>Description</h3>

<p>This retrieves all parameters from a Curve object as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParams(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParams_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getParams(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getParams+2CCurve-method'>Method for returning all parameters from a Curve object as a list</h2><span id='topic+getParams+2CCurve-method'></span>

<h3>Description</h3>

<p>This retrieves all parameters from a Curve object as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
getParams(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParams+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getParams(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getParamsV'>Method for returning all parameters from a Curve object as a vector</h2><span id='topic+getParamsV'></span>

<h3>Description</h3>

<p>This retrieves all parameters from a Curve object as a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParamsV(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParamsV_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getParamsV(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getParamsV+2CCurve-method'>Method for returning all parameters from a Curve object as a vector</h2><span id='topic+getParamsV+2CCurve-method'></span>

<h3>Description</h3>

<p>This retrieves all parameters from a Curve object as a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
getParamsV(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParamsV+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getParamsV(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getPatients'>Method for calculating expected number of recruited patients at a given time from an RCurve</h2><span id='topic+getPatients'></span>

<h3>Description</h3>

<p>This calculates the expected number of recruited patients at a given time based upon an RCurve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPatients(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPatients_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="getPatients_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getPatients(LinearR(12,100,100),7)
</code></pre>

<hr>
<h2 id='getPatients+2CRCurve-method'>Method for calculating expected number of recruited patients at a given time from an RCurve</h2><span id='topic+getPatients+2CRCurve-method'></span>

<h3>Description</h3>

<p>This calculates the expected number of recruited patients at a given time based upon an RCurve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
getPatients(theObject, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPatients+2B2CRCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="getPatients+2B2CRCurve-method_+3A_x">x</code></td>
<td>
<p>time at which to calculate expected patients recruited&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getPatients(LinearR(12,100,100),7)
</code></pre>

<hr>
<h2 id='getPDFfunction'>Method for returning the PDF function for a Curve object</h2><span id='topic+getPDFfunction'></span>

<h3>Description</h3>

<p>This retrieves the PDF function of the Curve object as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPDFfunction(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPDFfunction_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="getPDFfunction_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getPDFfunction(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getPDFfunction+2CCurve-method'>Method for returning the PDF function for a Curve object</h2><span id='topic+getPDFfunction+2CCurve-method'></span>

<h3>Description</h3>

<p>This retrieves the PDF function of the Curve object as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
getPDFfunction(theObject, x = "x")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPDFfunction+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="getPDFfunction+2B2CCurve-method_+3A_x">x</code></td>
<td>
<p>The parameter name to use in the PDF function. Default=x</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getPDFfunction(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getRatio'>Method for returning the recruitment ratio from a RCurve</h2><span id='topic+getRatio'></span>

<h3>Description</h3>

<p>This returns the RCurve recruitment ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRatio(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRatio_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getRatio(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getRatio+2CRCurve-method'>Method for returning the recruitment ratio from a RCurve</h2><span id='topic+getRatio+2CRCurve-method'></span>

<h3>Description</h3>

<p>This returns the RCurve recruitment ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
getRatio(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRatio+2B2CRCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getRatio(LinearR(12,100,100))
</code></pre>

<hr>
<h2 id='getRFfunction'>Method for returning the RF function for a Curve object</h2><span id='topic+getRFfunction'></span>

<h3>Description</h3>

<p>This retrieves the full RF function of the Curve object as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRFfunction(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRFfunction_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="getRFfunction_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getRFfunction(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getRFfunction+2CCurve-method'>Method for returning the RF function for a Curve object</h2><span id='topic+getRFfunction+2CCurve-method'></span>

<h3>Description</h3>

<p>This retrieves the full RF function of the Curve object as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
getRFfunction(theObject, n = "n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRFfunction+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="getRFfunction+2B2CCurve-method_+3A_n">n</code></td>
<td>
<p>The parameter name for the number of random draws to make. Default=n</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getRFfunction(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getType'>Method for returning the Curve type</h2><span id='topic+getType'></span>

<h3>Description</h3>

<p>This returns the Curve object type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getType(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getType_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getType(Weibull(100,1))
</code></pre>

<hr>
<h2 id='getType+2CCurve-method'>Method for returning the Curve type</h2><span id='topic+getType+2CCurve-method'></span>

<h3>Description</h3>

<p>This returns the Curve object type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
getType(theObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getType+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getType(Weibull(100,1))
</code></pre>

<hr>
<h2 id='GGamma'>Generalised Gamma Curve constructor function</h2><span id='topic+GGamma'></span>

<h3>Description</h3>

<p>This creates a Curve object for a Generalised Gamma distribution.<br />
Curve objects contain all necessary information to describe a distribution, including functions and parameters describing it.<br />
See Details for information on parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GGamma(theta, eta, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GGamma_+3A_theta">theta</code></td>
<td>
<p>Scale parameter for Generalised Gamma distribution.</p>
</td></tr>
<tr><td><code id="GGamma_+3A_eta">eta</code></td>
<td>
<p>Shape parameter for Generalised Gamma distribution.</p>
</td></tr>
<tr><td><code id="GGamma_+3A_rho">rho</code></td>
<td>
<p>Family parameter for Generalised Gamma distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Generalised Gamma distribution has parameterisation:<br />
f(x) = (rho x^((rho eta)-1) e^(-(x/theta)^rho) theta^(-rho eta) )/Gamma(eta)<br />
F(x) = LPGamma(eta,(x/theta)^rho)/Gamma(eta)<br />
where Gamma is the gamma function, and LPGamma is the lower partial gamma function.<br />
As of v1.4.0, all values of eta are now fully supported.<br />
</p>


<h3>Author(s)</h3>

<p>Jasmin Ruehl
</p>


<h3>References</h3>

<p>Tadikamalla PR, Random Sampling from the Generalized Gamma Distribution. Computing, 1979, 23(2), 199-203.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GGamma(theta=20,eta=2,rho=0.7)
</code></pre>

<hr>
<h2 id='Gompertz'>Gompertz Curve constructor function</h2><span id='topic+Gompertz'></span>

<h3>Description</h3>

<p>This creates a Curve object for a Gompertz distribution.<br />
Curve objects contain all necessary information to describe a distribution, including functions and parameters describing it.<br />
See Details for information on parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gompertz(theta, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gompertz_+3A_theta">theta</code></td>
<td>
<p>Scale parameter for Log-logistic distribution.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_eta">eta</code></td>
<td>
<p>Shape parameter for Log-logistic distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gompertz distribution has parameterisation:<br />
f(x) = theta eta e^(eta + theta x - eta e^(theta x))<br />
F(x) = 1 - exp(eta - eta e^(theta x))
</p>


<h3>Author(s)</h3>

<p>Jasmin Ruehl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gompertz(theta=0.02,eta=2)
</code></pre>

<hr>
<h2 id='InstantR'>InstantR RCurve constructor function</h2><span id='topic+InstantR'></span>

<h3>Description</h3>

<p>This creates a RCurve object for an instant recruitment distribution.<br />
RCurve objects contain all necessary information to describe a recruitment distribution. They are a particular type of Curve object containing additional recruitment-related information, including patient numbers and the randomisation ratio.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InstantR(Nactive, Ncontrol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InstantR_+3A_nactive">Nactive</code></td>
<td>
<p>Number of patients recruited in the active arm.</p>
</td></tr>
<tr><td><code id="InstantR_+3A_ncontrol">Ncontrol</code></td>
<td>
<p>Number of patients recruited in the control arm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This RCurve is used when either all patients enter at the same time, or a fixed-length follow-up design is used. Note that a PDF function is not provided for this RCurve type, but is not required for standard calculations.
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>InstantR(Nactive=100,Ncontrol=100)
</code></pre>

<hr>
<h2 id='LinearR'>LinearR RCurve constructor function</h2><span id='topic+LinearR'></span>

<h3>Description</h3>

<p>This creates a RCurve object for a linear recruitment distribution.<br />
RCurve objects contain all necessary information to describe a recruitment distribution. They are a particular type of Curve object containing additional recruitment-related information, including patient numbers and the randomisation ratio.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinearR(rlength, Nactive, Ncontrol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinearR_+3A_rlength">rlength</code></td>
<td>
<p>Length of recruitment.</p>
</td></tr>
<tr><td><code id="LinearR_+3A_nactive">Nactive</code></td>
<td>
<p>Number of patients recruited in the active arm.</p>
</td></tr>
<tr><td><code id="LinearR_+3A_ncontrol">Ncontrol</code></td>
<td>
<p>Number of patients recruited in the control arm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This RCurve is used when it is expected that patients enter a trial at a constant rate until the required number is achieved.
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LinearR(rlength=12,Nactive=100,Ncontrol=100)
</code></pre>

<hr>
<h2 id='LogLogistic'>Log-logistic Curve constructor function</h2><span id='topic+LogLogistic'></span>

<h3>Description</h3>

<p>This creates a Curve object for a Log-logistic distribution.<br />
Curve objects contain all necessary information to describe a distribution, including functions and parameters describing it.<br />
See Details for information on parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogLogistic(theta, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogLogistic_+3A_theta">theta</code></td>
<td>
<p>Scale parameter for Log-logistic distribution.</p>
</td></tr>
<tr><td><code id="LogLogistic_+3A_eta">eta</code></td>
<td>
<p>Shape parameter for Log-logistic distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-logistic distribution has parameterisation:<br />
f(x) = eta (theta^beta) x^(eta-1) (theta^eta + x^eta)^-2<br />
F(x) = (x^eta) /(theta^eta+x^eta)
</p>


<h3>Author(s)</h3>

<p>Jasmin Ruehl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LogLogistic(theta=20,eta=2)
</code></pre>

<hr>
<h2 id='Lognormal'>Log-normal Curve constructor function</h2><span id='topic+Lognormal'></span>

<h3>Description</h3>

<p>This creates a Curve object for a Log-normal distribution.<br />
Curve objects contain all necessary information to describe a distribution, including functions and parameters describing it.<br />
Parameterisation follows that used by plnorm etc. See Details for more information on parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lognormal(mu, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lognormal_+3A_mu">mu</code></td>
<td>
<p>Mean (on log scale) parameter for Log-normal distribution.</p>
</td></tr>
<tr><td><code id="Lognormal_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation (on log scale) parameter for Log-normal distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log normal distribution has parameterisation:<br />
f(x) = 1/(sqrt(2*pi) sigma  x) e^-((log x - mu)^2 / (2 sigma^2))<br />
F(x) = 0.5(1 + erf((log(x)-mu)/(sigma sqrt(2))))<br />
where erf is the error function.
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lognormal(mu=5,sigma=1.2)
Lognormal(6)
</code></pre>

<hr>
<h2 id='MixExp'>Mixture Exponential Curve constructor function</h2><span id='topic+MixExp'></span>

<h3>Description</h3>

<p>This creates a Curve object for a Mixture Exponential distribution, commonly used for modelling distributions with subpopulations.<br />
Curve objects contain all necessary information to describe a distribution, including functions and parameters describing it.<br />
Parameterisation follows that used by pexp etc. See Details for more information on parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixExp(props, lambdas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixExp_+3A_props">props</code></td>
<td>
<p>Vector of length x for the probabilities of the subpopulations. Must sum to 1.</p>
</td></tr>
<tr><td><code id="MixExp_+3A_lambdas">lambdas</code></td>
<td>
<p>Vector of length x for the rate parameters for the corresponding subpopulations define by props.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mixture distribution with rates lambda1 to lambda2 etc and prevalence p1 and p2 etc has parameterisation:<br />
f(x) = p1 lambda1 e^(- lambda1 x) + p2 lambda2 e^(- lambda2 x)+...<br />
F(x) = p1 (1 - e^(- lambda1 x)) + p2 (1 - e^(- lambda2 x))+...
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MixExp(props=c(0.8,0.2),lambdas=c(0.01,0.1))
</code></pre>

<hr>
<h2 id='MixWei'>Mixture Weibull Curve constructor function</h2><span id='topic+MixWei'></span>

<h3>Description</h3>

<p>This creates a Curve object for a Mixture Weibull distribution.<br />
Curve objects contain all necessary information to describe a distribution, including functions and parameters describing it.<br />
Parameterisation follows that used by pweibull etc. See Details for more information on parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixWei(props, alphas, betas = rep(1, length(props)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixWei_+3A_props">props</code></td>
<td>
<p>Vector of length x for the probabilities of the two subpopulations. Must sum to 1.</p>
</td></tr>
<tr><td><code id="MixWei_+3A_alphas">alphas</code></td>
<td>
<p>Vector of length x for the scale parameters for the corresponding subpopulations define by props.</p>
</td></tr>
<tr><td><code id="MixWei_+3A_betas">betas</code></td>
<td>
<p>Vector of length x for the shape parameters for the corresponding subpopulations define by props. Default is rep(1,length(props)), i.e. all exponential distributions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mixture distribution with scales alpha1 and alpha2 etc, shapes beta1 and beta2 etc, and prevalences p1 and p2 etc has parameterisation:<br />
f(x) = p1 (beta1/alpha1) (x/alpha1)^(beta1-1) exp(- (x/alpha1)^beta1) + p2 (beta2/alpha2) (x/alpha2)^(beta2-1) exp(- (x/alpha2)^beta2)+...<br />
F(x) = p1 (1 - exp(- (x/alpha1)^beta1) + p2 (1 - exp(- (x/alpha2)^beta2)+...
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MixWei(props=c(0.8,0.2),alphas=c(100,10),betas=c(1.1,0.9))
</code></pre>

<hr>
<h2 id='nph_traj'>Calculate analytic time-to-event trial properties under non-proportional hazards and complex assumptions</h2><span id='topic+nph_traj'></span>

<h3>Description</h3>

<p>This function calculates the expected parameters/outputs/properties for a two-arm Time-To-Event trial under complex assumptions.
It is designed to work with non-proportional hazards and ought to be able to accommodate any distributional assumptions for
events, censoring and recruitment, so long as they are correctly detailed in Curve or RCurve objects.<br />
The function performs power calculations and hence can be used for sample size planning. By creating trajectories of properties
over time, the function also assists with identifying the optimum assessment time.<br />
The function uses numerical integration across event, censoring and recruitment functions to estimate observed and expected event numbers.
From these, it estimates an expected HR, with the same interpretation as that found using Cox regression, using the Pike method.
The estimated event numbers and HR can be used to calculate power by one of several methods, including the Schoenfeld and Frontier methods.
A separate, direct, power calculation can also be performed using the log-rank test formula and its Z-distribution.<br />
To assist sample size finding, the function will also optionally estimate the required sample size to reach a given power
keeping all variables other than recruitment.<br />
Expected RMST and landmark analysis properties may also be calculated. This also uses numerical integration techniques.
Power is also then estimated for such analyses.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nph_traj(
  active_ecurve,
  control_ecurve,
  active_dcurve = Blank(),
  control_dcurve = Blank(),
  rcurve,
  max_assessment = 100,
  landmark = NULL,
  RMST = NULL,
  HRbound = 1,
  alpha1 = 0.025,
  required_power = NULL,
  detailed_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nph_traj_+3A_active_ecurve">active_ecurve</code></td>
<td>
<p>Event distribution for the active arm, specified as a Curve object</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_control_ecurve">control_ecurve</code></td>
<td>
<p>Event distribution for the control arm, specified as a Curve object</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_active_dcurve">active_dcurve</code></td>
<td>
<p>Dropout/censoring distribution for the active arm, specified as a Curve object. By default, a Blank() object, i.e. no dropout.</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_control_dcurve">control_dcurve</code></td>
<td>
<p>Dropout/censoring distribution for the control arm, specified as a Curve object. By default, a Blank() object, i.e. no dropout.</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_rcurve">rcurve</code></td>
<td>
<p>Recruitment distribution, specified as an RCurve object</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_max_assessment">max_assessment</code></td>
<td>
<p>Maximum assessment time to calculate properties up to</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_landmark">landmark</code></td>
<td>
<p>(Optional) Time in months of landmark analysis, if required. Otherwise NULL (Not calculated; default).</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_rmst">RMST</code></td>
<td>
<p>(Optional) Restriction time for RMST analysis in months, if required. Otherwise NULL (Not calculated; default).</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_hrbound">HRbound</code></td>
<td>
<p>(Optional) Specify HR value to test landmark significance against. Default is 1 (superiority testing). Values above 1 would be non-inferiority.</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_alpha1">alpha1</code></td>
<td>
<p>One-sided alpha required, as a decimal. 0.025 by default. Requires 0 &lt; alpha1 &lt;= 0.5.</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_required_power">required_power</code></td>
<td>
<p>(Optional) Power required for estimated sample sizes. Otherwise NULL (not calculated; default).</p>
</td></tr>
<tr><td><code id="nph_traj_+3A_detailed_output">detailed_output</code></td>
<td>
<p>Boolean to require a more detailed output table, including Peto LogHR, expectations of various quantities and alternative power calculations. Default = FALSE (detailed outputs omitted).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table with one row per assessment time. Table contains both all input parameters as well as the following expected quantities:
</p>

<ul>
<li><p>&quot;Time&quot; Time at which the assessment is made
</p>
</li>
<li><p>&quot;Patients&quot; Number of patients expected to be recruited to date
</p>
</li>
<li><p>&quot;Events_Active&quot; Expected number of observed events in active arm
</p>
</li>
<li><p>&quot;Events_Control&quot; Expected number of observed events in control arm
</p>
</li>
<li><p>&quot;Events_Total&quot; Expected number of events across both arms
</p>
</li>
<li><p>&quot;HR&quot; Expected Hazard Ratio (using the Pike method)
</p>
</li>
<li><p>&quot;LogHR&quot; Log of the expected Hazard Ratio
</p>
</li>
<li><p>&quot;LogHR_SE&quot; SE of the log of the expected Hazard Ratio
</p>
</li>
<li><p>&quot;Schoenfeld_Power&quot; Estimated power based on Schoenfeld formula
</p>
</li>
<li><p>&quot;Frontier_Power&quot; Estimated power based on Frontier method, using estimated event ratio at 0.5 power
</p>
</li></ul>

<p>In addition, if the detailed_output argument is set to TRUE, the following additional columns are provided:
</p>

<ul>
<li><p>&quot;E_Events_Active&quot; Expected number of expected events in active arm
</p>
</li>
<li><p>&quot;E_Events_Control&quot; Expected number of expected events in control arm
</p>
</li>
<li><p>&quot;HR_CI_Upper&quot; Estimated Upper Bound of the CI for the Hazard Ratio
</p>
</li>
<li><p>&quot;HR_CI_Lower&quot; Estimated Lower Bound of the CI for the Hazard Ratio
</p>
</li>
<li><p>&quot;Peto_LogHR&quot; Expected Log Hazard Ratio using the Peto method
</p>
</li>
<li><p>&quot;Expected_Z&quot; Estimated Z-score based on expected quantities for O, E and V, and log-rank test formula
</p>
</li>
<li><p>&quot;Expected_P&quot; Estimated p-value based on estimated Z-score
</p>
</li>
<li><p>&quot;Log_Rank_Stat&quot; Expected log-rank statistic
</p>
</li>
<li><p>&quot;Variance&quot; Expected variance of LR-statistic by integration of V_function
</p>
</li>
<li><p>&quot;V_Pike_Peto&quot; Expected variance based upon Pike and Peto approximations
</p>
</li>
<li><p>&quot;Event_Ratio&quot; Expected ratio of events between arms; active divided by control
</p>
</li>
<li><p>&quot;Event_Prop_Power&quot; Estimated power based on event proportion method, using event ratio rather than randomisation ratio
</p>
</li>
<li><p>&quot;Z_Power&quot; Estimated power based on expected value of Z
</p>
</li></ul>

<p>If RMST calculations are requested, the following columns are included:
</p>

<ul>
<li><p>&quot;RMST_Restrict&quot; Specified RMST restriction time
</p>
</li>
<li><p>&quot;RMST_Active&quot; Expected RMST for active arm
</p>
</li>
<li><p>&quot;RMST_Control&quot; Expected RMST for control arm
</p>
</li>
<li><p>&quot;RMST_Delta&quot; Absolute difference in expected RMSTs between arms (active minus control)
</p>
</li>
<li><p>&quot;RMST_SE&quot; Estimated SE of the RMST delta
</p>
</li>
<li><p>&quot;RMST_Z&quot; Estimated RMST Z score
</p>
</li>
<li><p>&quot;RMST_Failure&quot; Estimated probability of RMST difference being uncomputable for the specified restriction time
</p>
</li>
<li><p>&quot;RMST_Power&quot; Estimated RMST Power
</p>
</li></ul>

<p>If landmark calculations are requested, the following columns are included:
</p>

<ul>
<li><p>&quot;LM_Time&quot; Time of landmark analysis
</p>
</li>
<li><p>&quot;LM_Active&quot; Expected Kaplan Meier estimate of active arm at landmark time 
</p>
</li>
<li><p>&quot;LM_Control&quot; Expected Kaplan Meier estimate of control arm at landmark time 
</p>
</li>
<li><p>&quot;LM_Delta&quot; Expected absolute difference in Kaplan Meiers estimates at landmark time (active-control) 
</p>
</li>
<li><p>&quot;LM_A_SE&quot; Estimated Greenwood SE for active arm at landmark time 
</p>
</li>
<li><p>&quot;LM_C_SE&quot; Estimated Greenwood SE for control arm at landmark time 
</p>
</li>
<li><p>&quot;LM_D_SE&quot; Estimated Greenwood SE for delta at landmark time 
</p>
</li>
<li><p>&quot;LM_Z&quot; Estimated landmark analysis Z-score based on Greenwood SE 
</p>
</li>
<li><p>&quot;LM_Power&quot; Estimated landmark analysis power based on Greenwood SE 
</p>
</li></ul>

<p>If a required power is requested, the following column is included:
</p>

<ul>
<li><p>&quot;Estimated_SS&quot; Estimated sample size required, keeping constant all parameters other than rate of recruitment and total sample size
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>References</h3>

<p>Bell J, Accurate Sample Size Calculations in Trials with Non-Proportional Hazards, 2018, presentation at PSI Conference.
<a href="https://www.psiweb.org/docs/default-source/default-document-library/james-bell-slides.pdf?sfvrsn=3324dedb_0">https://www.psiweb.org/docs/default-source/default-document-library/james-bell-slides.pdf?sfvrsn=3324dedb_0</a>
Bell J, Power Calculations for Time-to-Event Trials Using Predicted Event Proportions, 2019, unpublished.
Ruehl J, Sample Size Calculation in Time-To-Event Trials with Non-Proportional Hazards Using GESTATE, 2018, BSc thesis at University of Ulm.
Pike MC, Contribution to discussion in Asymptotically efficient rank invariant test procedures by Peto R and Peto J,
Journal of the Royal Statistical Society Series A, 135(2), 201-203.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nph_traj(max_assessment=100,rcurve=LinearR(12,100,100),control_ecurve=Weibull(100,1),
active_ecurve=Weibull(250,0.8))
</code></pre>

<hr>
<h2 id='PieceExponential'>Piecewise Exponential Curve constructor function</h2><span id='topic+PieceExponential'></span>

<h3>Description</h3>

<p>This creates a Curve object for a Piecewise Exponential distribution.<br />
Curve objects contain all necessary information to describe a distribution, including functions and parameters describing it.<br />
Parameterisation follows that used by pexp etc. This function requires a vector of start times (beginning with 0) and a corresponding vector of rates. See Details for more information on parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PieceExponential(start, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PieceExponential_+3A_start">start</code></td>
<td>
<p>Vector of start times for each period. First element must be 0. Must be same length as lambda vector.</p>
</td></tr>
<tr><td><code id="PieceExponential_+3A_lambda">lambda</code></td>
<td>
<p>Vector of rate parameters from the corresponding respective time defined in start vector until the start of the next period. Must be same length as start vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The piecewise exponential distribution with rates lambda_1 to lambda_n and start times t_1 to t_n has parameterisation:<br />
Product(x=1:length(lambda)) of (e^(-lambda[x].t[x])) where t[x] = min(start[x+1],max(0,t-start[x])). start[x+1] is defined as Inf if otherwise undefined.
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PieceExponential(start=c(0,6,24),lambda=c(0.05,0.01,0.001))
</code></pre>

<hr>
<h2 id='PieceR'>PieceR RCurve constructor function</h2><span id='topic+PieceR'></span>

<h3>Description</h3>

<p>This creates a RCurve object for a piecewise-linear recruitment distribution.<br />
RCurve objects contain all necessary information to describe a recruitment distribution. They are a particular type of Curve object containing additional recruitment-related information, including patient numbers and the randomisation ratio.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PieceR(recruitment, ratio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PieceR_+3A_recruitment">recruitment</code></td>
<td>
<p>2-column matrix with recruitment parameters. First column gives the lengths of each period of recruitment. Second column gives the corresponding rates of recruitment for each period.</p>
</td></tr>
<tr><td><code id="PieceR_+3A_ratio">ratio</code></td>
<td>
<p>Randomisation ratio; active arm divided by control arm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This RCurve is used when it is expected that patients enter a trial at a rate that varies over time.
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmatrix &lt;- matrix(c(rep(4,3),5,10,15),ncol=2)
rmatrix
PieceR(rmatrix,1)
</code></pre>

<hr>
<h2 id='PieceRMaxF'>PieceR RCurve constructor function</h2><span id='topic+PieceRMaxF'></span>

<h3>Description</h3>

<p>This creates a RCurve object for a piecewise-linear recruitment distribution with a fixed (maximum) per-patient follow-up time.<br />
RCurve objects contain all necessary information to describe a recruitment distribution. They are a particular type of Curve object containing additional recruitment-related information, including patient numbers and the randomisation ratio.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PieceRMaxF(recruitment, ratio, maxF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PieceRMaxF_+3A_recruitment">recruitment</code></td>
<td>
<p>2-column matrix with recruitment parameters. First column gives the lengths of each period of recruitment. Second column gives the corresponding rates of recruitment for each period.</p>
</td></tr>
<tr><td><code id="PieceRMaxF_+3A_ratio">ratio</code></td>
<td>
<p>Randomisation ratio; active arm divided by control arm.</p>
</td></tr>
<tr><td><code id="PieceRMaxF_+3A_maxf">maxF</code></td>
<td>
<p>Fixed follow-up time per patient, i.e. maximum time a patient will be at risk independent of length of study.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This RCurve is used when it is expected that patients enter a trial at a rate that varies over time and there is a fixed maximum follow-up time per patient.
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmatrix &lt;- matrix(c(rep(4,3),5,10,15),ncol=2)
rmatrix
PieceRMaxF(recruitment=rmatrix,ratio=1,maxF=12)
</code></pre>

<hr>
<h2 id='plot_ep'>Plot event prediction output</h2><span id='topic+plot_ep'></span>

<h3>Description</h3>

<p>This function plots the output from event_prediction().<br />
By default, produces a plot of predicted events over time, with confidence intervals if available.<br />
Alternatively, produces a plot with the fitting CI over time with same percentage as prediction interval.<br />
By default, both conditional and unconditional trajectories are plotted (if conditional event prediction is available).<br />
Options are available to customise inclusion.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ep(
  data,
  trajectory = c("both", "conditional", "unconditional"),
  which_PI = c("both", "conditional", "unconditional", "none"),
  prediction_fitting = c("prediction", "fitting"),
  observed = NULL,
  target = NULL,
  max_time = NULL,
  max_E = NULL,
  legend_position = c("top_left", "bottom_right"),
  no_legend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ep_+3A_data">data</code></td>
<td>
<p>Full output list from event_prediction().</p>
</td></tr>
<tr><td><code id="plot_ep_+3A_trajectory">trajectory</code></td>
<td>
<p>String, choice of &quot;both&quot;,&quot;conditional&quot;,&quot;unconditional&quot;, for which trajectory to plot. (Default=&quot;both&quot;)</p>
</td></tr>
<tr><td><code id="plot_ep_+3A_which_pi">which_PI</code></td>
<td>
<p>String, choice of &quot;both&quot;,&quot;conditional&quot;,&quot;unconditional&quot;,&quot;none&quot;, for which PIs to plot. (Default=&quot;both&quot;)</p>
</td></tr>
<tr><td><code id="plot_ep_+3A_prediction_fitting">prediction_fitting</code></td>
<td>
<p>String, choice of &quot;prediction&quot; or &quot;fitting&quot; (Default = &quot;prediction&quot;). Determines the nature of the intervals; PIs are relevant for prediction of the observation of future trajectories (sample level), whereas fitting CIs concern the interval for the mean trajectory itself (population level).</p>
</td></tr>
<tr><td><code id="plot_ep_+3A_observed">observed</code></td>
<td>
<p>Optional trajectory of observed event numbers. If vector specified, will plot values at integer times starting from 1. If 2-column matrix specified, will take x-values from column 1 and y-values from column 2. (Default=NULL; not plotted).</p>
</td></tr>
<tr><td><code id="plot_ep_+3A_target">target</code></td>
<td>
<p>Optional target number of events to plot. (Default=NULL; not plotted)</p>
</td></tr>
<tr><td><code id="plot_ep_+3A_max_time">max_time</code></td>
<td>
<p>Optional maximum time to plot up to if you do not want to plot full trajectory. (Default=NULL; maximum time determined by input data)</p>
</td></tr>
<tr><td><code id="plot_ep_+3A_max_e">max_E</code></td>
<td>
<p>Optional maximum number of events to plot up to. (Default=NULL; maximum event number is the number of patients)</p>
</td></tr>
<tr><td><code id="plot_ep_+3A_legend_position">legend_position</code></td>
<td>
<p>String with any of &quot;top_left&quot;, or &quot;bottom_right&quot;, corresponding to legend position in power plot. (Default=&quot;top_left&quot;).</p>
</td></tr>
<tr><td><code id="plot_ep_+3A_no_legend">no_legend</code></td>
<td>
<p>Boolean to turn off legend. Default is FALSE; legend shown.</p>
</td></tr>
<tr><td><code id="plot_ep_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recruit &lt;- PieceR(matrix(c(rep(1,12),10,15,25,30,45,60,55,50,65,60,55,30),ncol=2),1)
trial_long &lt;- simulate_trials(active_ecurve=Weibull(50,0.8),control_ecurve=Weibull(50,0.8),
rcurve=recruit,fix_events=200, iterations=1,seed=12345,detailed_output=TRUE)
trial_short &lt;- set_assess_time(data=trial_long,time=10,detailed_output = FALSE)

maxtime &lt;- max(ceiling(trial_long[,"Assess"]))
events &lt;- rep(NA,maxtime)
for (i in 1:maxtime){events[i] &lt;- sum(1-set_assess_time(trial_long,i)[,"Censored"])}

predictions &lt;- event_prediction(data=trial_short, Event="Censored", censoringOne=TRUE, 
type="Weibull", rcurve=recruit, max_time=60, cond_Events=49, cond_NatRisk=451, 
cond_Time=10, units="Months")

plot_ep(predictions,trajectory="conditional",which_PI="conditional",max_time=40,observed=events,
target=200,max_E=200)

plot_ep(predictions,trajectory="unconditional",which_PI="unconditional",max_time=40,
observed=events,target=200,max_E=200)

plot_ep(predictions,trajectory="conditional",which_PI="none",observed=events[1:10],max_time=20,
max_E=150)

</code></pre>

<hr>
<h2 id='plot_km_fit'>Kaplan Meier Plot of Curve-Fit</h2><span id='topic+plot_km_fit'></span>

<h3>Description</h3>

<p>This function creates a Kaplan Meier plot with the fitted curve from the output of event_prediction(), fit_tte_data() or fit_KM().<br />
Where available, it will include fitting confidence intervals based upon the variance derived by the delta method.<br />
Options are available to customise inclusion.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_km_fit(
  fit,
  data,
  Time = "Time",
  Event = "Event",
  censoringOne = FALSE,
  CI = 0.95,
  colour_CI = TRUE,
  maxT = NULL,
  xlim = NULL,
  ylim = c(0, 1),
  main = "Kaplan Meier Curve Fit Plot",
  fit_col = 2,
  km_col = 1,
  area_col = "skyblue",
  CI_col = 4,
  CI_lty = 2,
  no_legend = FALSE,
  legend_position = c("bottom_left", "top_right"),
  overlay = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_km_fit_+3A_fit">fit</code></td>
<td>
<p>Full output list from event_prediction(), fit_tte_data() or fit_KM().</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_data">data</code></td>
<td>
<p>Name of patient-level data set, used to generate the KM plot.</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_time">Time</code></td>
<td>
<p>The column name for the times. Default is &quot;Time&quot;</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_event">Event</code></td>
<td>
<p>The column name for the events column (i.e. the binary variable denoting events vs censorings). Default is &quot;Event&quot;</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_censoringone">censoringOne</code></td>
<td>
<p>Specify whether censoring is denoted in the Event column by a one (TRUE) or zero (FALSE). Default=FALSE (censorings denoted by 0, events by 1)</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_ci">CI</code></td>
<td>
<p>Number between 0 and 1 for the size of Kaplan Meier confidence interval to calculate. Default is 0.95 (95 percent confidence interval).</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_colour_ci">colour_CI</code></td>
<td>
<p>Boolean for whether to colour the fitting confidence interval area. Default=TRUE (colour area)</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_maxt">maxT</code></td>
<td>
<p>Maximum time to calculate point estimate and CIs up to. Default=NULL (Calculate up to last time in patient data)</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_xlim">xlim</code></td>
<td>
<p>Standard graphical parameter for x-axis limits. Default=NULL (Plots from 0 to maximum patient time)</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_ylim">ylim</code></td>
<td>
<p>Graphical parameter for y-axis limits. Default=c(0,1) (Plots survival function from 0 to 1)</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_main">main</code></td>
<td>
<p>String for plot title. Default=&quot;Kaplan Meier Curve Fit Plot&quot;</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_fit_col">fit_col</code></td>
<td>
<p>Colour for fitting curve Default=2 (red)</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_km_col">km_col</code></td>
<td>
<p>Colour for km curve Default=1 (black)</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_area_col">area_col</code></td>
<td>
<p>Colour for CI area Default=&quot;skyblue&quot; (sky blue)</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_ci_col">CI_col</code></td>
<td>
<p>Colour for CI Default=4 (blue)</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_ci_lty">CI_lty</code></td>
<td>
<p>Line type for CI Default=2 (dashed)</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_no_legend">no_legend</code></td>
<td>
<p>Boolean to turn off legend. Default is FALSE; legend shown.</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_legend_position">legend_position</code></td>
<td>
<p>String with &quot;top_right&quot;, or &quot;bottom_left&quot;, corresponding to legend position in power plot. (Default=&quot;bottom_left&quot;).</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_overlay">overlay</code></td>
<td>
<p>Boolean whether to overlay on existing plot (vs start a new one). Default=FALSE</p>
</td></tr>
<tr><td><code id="plot_km_fit_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recruit &lt;- PieceR(matrix(c(rep(1,12),10,15,25,30,45,60,55,50,65,60,55,30),ncol=2),1)
trial_long &lt;- simulate_trials(active_ecurve=Weibull(50,0.8),control_ecurve=Weibull(50,0.8),
rcurve=recruit,fix_events=200, iterations=1,seed=12345,detailed_output=TRUE)
trial_short &lt;- set_assess_time(data=trial_long,time=10,detailed_output = FALSE)

maxtime &lt;- max(ceiling(trial_long[,"Assess"]))
events &lt;- rep(NA,maxtime)
for (i in 1:maxtime){events[i] &lt;- sum(1-set_assess_time(trial_long,i)[,"Censored"])}

predictions &lt;- event_prediction(data=trial_short, Event="Censored", censoringOne=TRUE, 
type="Weibull", rcurve=recruit, max_time=60, cond_Events=49, cond_NatRisk=451, 
cond_Time=10, units="Months")

plot_km_fit(fit=predictions,data=trial_short,Event="Censored",censoringOne=TRUE,maxT=70)

</code></pre>

<hr>
<h2 id='plot_npht'>Plot output from nph_traj</h2><span id='topic+plot_npht'></span>

<h3>Description</h3>

<p>This function plots the output from nph_traj().<br />
By default, it produces 6 plots:
</p>

<ul>
<li><p>&quot;KM plot&quot; Kaplan Meier plot for events. This is in patient time.
</p>
</li>
<li><p>&quot;Censoring plot&quot; Plot of CDFs for censoring functions. This is in patient time.
</p>
</li>
<li><p>&quot;Recruitment plot&quot; Number of patients expected to have been recruited over time. This is in trial time.
</p>
</li>
<li><p>&quot;Event plot&quot; Total number of events expected to occur over time. This is in trial time.
</p>
</li>
<li><p>&quot;log(HR) plot&quot; Expected log(HR), with expected confidence interval, over time. This is in trial time.
</p>
</li>
<li><p>&quot;Power plot&quot; Expected power over time for various methods. This is in trial time.
</p>
</li></ul>

<p>Plots may be omitted via arguments.<br />
All calculated powers automatically plotted unless specified otherwise.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_npht(
  data,
  KM = TRUE,
  censor = TRUE,
  recruitment = TRUE,
  events = TRUE,
  logHR = TRUE,
  power = TRUE,
  include_frontier = TRUE,
  include_RMST = TRUE,
  include_landmark = TRUE,
  alpha1 = 0.025,
  legend_position = c("top_left", "top_right", "bottom_right")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_npht_+3A_data">data</code></td>
<td>
<p>Full output list from nph_traj()</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_km">KM</code></td>
<td>
<p>Boolean to include KM plot (Default = TRUE)</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_censor">censor</code></td>
<td>
<p>Boolean to include censoring plot (Default = TRUE)</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_recruitment">recruitment</code></td>
<td>
<p>Boolean to include recruitment plot (Default = TRUE)</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_events">events</code></td>
<td>
<p>Boolean to include events plot (Default = TRUE)</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_loghr">logHR</code></td>
<td>
<p>Boolean to include log(HR) plot (Default = TRUE)</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_power">power</code></td>
<td>
<p>Boolean to include power plot (Default = TRUE)</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_include_frontier">include_frontier</code></td>
<td>
<p>Boolean to include frontier power curve in power plot (Default = TRUE)</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_include_rmst">include_RMST</code></td>
<td>
<p>Boolean to include RMST power curve in power plot if available (Default = TRUE)</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_include_landmark">include_landmark</code></td>
<td>
<p>Boolean to include landmark power curve in power plot if available (Default = TRUE)</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_alpha1">alpha1</code></td>
<td>
<p>One-sided alpha to use for estimation of log(HR) confidence intervals (Default = 0.025)</p>
</td></tr>
<tr><td><code id="plot_npht_+3A_legend_position">legend_position</code></td>
<td>
<p>String with any of &quot;top_left&quot;,&quot;top_right&quot; or &quot;bottom_right&quot;, corresponding to legend position in power plot. Default is &quot;top_left&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trial &lt;- nph_traj(Weibull(100,1),Weibull(70,1),rcurve=LinearR(12,100,100),RMST=20,
  landmark=20,max_assessment=30)

plot_npht(trial)
plot_npht(data=trial,KM=FALSE,censor=FALSE,recruitment=FALSE)
plot_npht(data=trial,KM=FALSE,censor=FALSE,recruitment=FALSE,events=FALSE,logHR=FALSE,
include_frontier=FALSE, include_RMST=FALSE,include_landmark=FALSE,legend_position="top_right")

</code></pre>

<hr>
<h2 id='plotCDF'>Method for plotting the CDF of a Curve object</h2><span id='topic+plotCDF'></span>

<h3>Description</h3>

<p>This plots a Curve CDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCDF(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCDF_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="plotCDF_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotCDF(Weibull(100,1))
plotCDF(Weibull(100,1),xlab="Test x label",maxT=60)
plotCDF(Weibull(80,0.8),overlay=TRUE,col=2,lty=2)
</code></pre>

<hr>
<h2 id='plotCDF+2CCurve-method'>Method for plotting the CDF of a Curve object</h2><span id='topic+plotCDF+2CCurve-method'></span>

<h3>Description</h3>

<p>This plots a Curve CDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
plotCDF(
  theObject,
  overlay = FALSE,
  maxT = 100,
  maxCDF = 1,
  increment = 0.1,
  xlab = "Time",
  ylab = "CDF",
  main = "CDF plot",
  type = "l",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCDF+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="plotCDF+2B2CCurve-method_+3A_overlay">overlay</code></td>
<td>
<p>Boolean whether to overlay on existing plot (vs start a new one). Default=FALSE</p>
</td></tr>
<tr><td><code id="plotCDF+2B2CCurve-method_+3A_maxt">maxT</code></td>
<td>
<p>Maximum time to plot up to. Default=100</p>
</td></tr>
<tr><td><code id="plotCDF+2B2CCurve-method_+3A_maxcdf">maxCDF</code></td>
<td>
<p>Maximum CDF to plot up to. Default=1</p>
</td></tr>
<tr><td><code id="plotCDF+2B2CCurve-method_+3A_increment">increment</code></td>
<td>
<p>Plotting time increment. Default=0.1</p>
</td></tr>
<tr><td><code id="plotCDF+2B2CCurve-method_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label. Default=&quot;Time&quot;</p>
</td></tr>
<tr><td><code id="plotCDF+2B2CCurve-method_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label. Default=&quot;CDF&quot;</p>
</td></tr>
<tr><td><code id="plotCDF+2B2CCurve-method_+3A_main">main</code></td>
<td>
<p>title of plot. Default=&quot;CDF plot&quot;</p>
</td></tr>
<tr><td><code id="plotCDF+2B2CCurve-method_+3A_type">type</code></td>
<td>
<p>type of plot (see standard graphical parameters). Default=&quot;l&quot; (lines).</p>
</td></tr>
<tr><td><code id="plotCDF+2B2CCurve-method_+3A_...">...</code></td>
<td>
<p>Standard graphical parameter arguments to be passed on to 'plot'/'lines', e.g. to change appearance of plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotCDF(Weibull(100,1))
plotCDF(Weibull(100,1),xlab="Test x label",maxT=60)
plotCDF(Weibull(80,0.8),overlay=TRUE,col=2,lty=2)
</code></pre>

<hr>
<h2 id='plotRecruitment'>Method for plotting the Recruitment Function of a RCurve object</h2><span id='topic+plotRecruitment'></span>

<h3>Description</h3>

<p>This plots an RCurve Recruitment Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRecruitment(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRecruitment_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="plotRecruitment_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotRecruitment(LinearR(12,100,100))
plotRecruitment(LinearR(12,100,100),xlab="Test x label",maxT=60)
plotRecruitment(LinearR(20,90,90),overlay=TRUE,col=2,lty=2)
</code></pre>

<hr>
<h2 id='plotRecruitment+2CRCurve-method'>Method for plotting the Recruitment Function of a RCurve object</h2><span id='topic+plotRecruitment+2CRCurve-method'></span>

<h3>Description</h3>

<p>This plots an RCurve Recruitment Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
plotRecruitment(
  theObject,
  overlay = FALSE,
  maxT = 100,
  increment = 0.1,
  xlab = "Time",
  ylab = "Patients",
  main = "Recruitment plot",
  type = "l",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRecruitment+2B2CRCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="plotRecruitment+2B2CRCurve-method_+3A_overlay">overlay</code></td>
<td>
<p>Boolean whether to overlay on existing one (vs start a new one). Default=FALSE</p>
</td></tr>
<tr><td><code id="plotRecruitment+2B2CRCurve-method_+3A_maxt">maxT</code></td>
<td>
<p>Maximum time to plot up to. Default=100</p>
</td></tr>
<tr><td><code id="plotRecruitment+2B2CRCurve-method_+3A_increment">increment</code></td>
<td>
<p>Plotting time increment. Default=0.1</p>
</td></tr>
<tr><td><code id="plotRecruitment+2B2CRCurve-method_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label. Default=&quot;Time&quot;</p>
</td></tr>
<tr><td><code id="plotRecruitment+2B2CRCurve-method_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label. Default=&quot;Patients&quot;</p>
</td></tr>
<tr><td><code id="plotRecruitment+2B2CRCurve-method_+3A_main">main</code></td>
<td>
<p>title of plot. Default=&quot;Recruitment plot&quot;</p>
</td></tr>
<tr><td><code id="plotRecruitment+2B2CRCurve-method_+3A_type">type</code></td>
<td>
<p>type of plot (see standard graphical parameters). Default=&quot;l&quot; (lines).</p>
</td></tr>
<tr><td><code id="plotRecruitment+2B2CRCurve-method_+3A_...">...</code></td>
<td>
<p>Standard graphical parameter arguments to be passed on to 'plot'/'lines', e.g. to change appearance of plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotRecruitment(LinearR(12,100,100))
plotRecruitment(LinearR(12,100,100),xlab="Test x label",maxT=60)
plotRecruitment(LinearR(20,90,90),overlay=TRUE,col=2,lty=2)
</code></pre>

<hr>
<h2 id='plotSF'>Method for plotting the Survival Function of a Curve object</h2><span id='topic+plotSF'></span>

<h3>Description</h3>

<p>This plots a Curve Survival Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSF(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSF_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="plotSF_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotSF(Weibull(100,1))
plotSF(Weibull(100,1),xlab="Test x label",maxT=60)
plotSF(Weibull(80,0.8),overlay=TRUE,col=2,lty=2)
</code></pre>

<hr>
<h2 id='plotSF+2CCurve-method'>Method for plotting the Survival Function of a Curve object</h2><span id='topic+plotSF+2CCurve-method'></span>

<h3>Description</h3>

<p>This plots a Curve Survival Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
plotSF(
  theObject,
  overlay = FALSE,
  maxT = 100,
  minSF = 0,
  increment = 0.1,
  xlab = "Time",
  ylab = "S(t)",
  main = "Kaplan Meier plot",
  type = "l",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSF+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="plotSF+2B2CCurve-method_+3A_overlay">overlay</code></td>
<td>
<p>Boolean whether to overlay on existing one (vs start a new one). Default=FALSE</p>
</td></tr>
<tr><td><code id="plotSF+2B2CCurve-method_+3A_maxt">maxT</code></td>
<td>
<p>Maximum time to plot up to. Default=100</p>
</td></tr>
<tr><td><code id="plotSF+2B2CCurve-method_+3A_minsf">minSF</code></td>
<td>
<p>Minimum SF to plot down to. Default=0</p>
</td></tr>
<tr><td><code id="plotSF+2B2CCurve-method_+3A_increment">increment</code></td>
<td>
<p>Plotting time increment. Default=0.1</p>
</td></tr>
<tr><td><code id="plotSF+2B2CCurve-method_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label. Default=&quot;Time&quot;</p>
</td></tr>
<tr><td><code id="plotSF+2B2CCurve-method_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label. Default=&quot;S(t)&quot;</p>
</td></tr>
<tr><td><code id="plotSF+2B2CCurve-method_+3A_main">main</code></td>
<td>
<p>title of plot. Default=&quot;Kaplan Meier plot&quot;</p>
</td></tr>
<tr><td><code id="plotSF+2B2CCurve-method_+3A_type">type</code></td>
<td>
<p>type of plot (see standard graphical parameters). Default=&quot;l&quot; (lines).</p>
</td></tr>
<tr><td><code id="plotSF+2B2CCurve-method_+3A_...">...</code></td>
<td>
<p>Standard graphical parameter arguments to be passed on to 'plot'/'lines', e.g. to change appearance of plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotSF(Weibull(100,1))
plotSF(Weibull(100,1),xlab="Test x label",maxT=60)
plotSF(Weibull(80,0.8),overlay=TRUE,col=2,lty=2)
</code></pre>

<hr>
<h2 id='power2events'>Calculate Schoenfeld or Event Proportion based event numbers from power</h2><span id='topic+power2events'></span>

<h3>Description</h3>

<p>Calculate Schoenfeld or Event Proportion based event numbers from power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power2events(power, HR, ratio = 1, alpha1 = 0.025, HRbound = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power2events_+3A_power">power</code></td>
<td>
<p>Desired power (decimal).</p>
</td></tr>
<tr><td><code id="power2events_+3A_hr">HR</code></td>
<td>
<p>Hazard Ratio. Values below 1 indicate a benefit to the active arm vs control.</p>
</td></tr>
<tr><td><code id="power2events_+3A_ratio">ratio</code></td>
<td>
<p>Randomisation ratio (Schoenfeld), or event ratio (event proportion method). Default=1.</p>
</td></tr>
<tr><td><code id="power2events_+3A_alpha1">alpha1</code></td>
<td>
<p>1-sided alpha. Default=0.025.</p>
</td></tr>
<tr><td><code id="power2events_+3A_hrbound">HRbound</code></td>
<td>
<p>HRvalue to test against. Default=1 (superiority).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Required event number
</p>

<hr>
<h2 id='random_draw'>Method for taking random draws from a Curve object distribution</h2><span id='topic+random_draw'></span>

<h3>Description</h3>

<p>This takes random draws from the Curve object distribution
Note that the seed should always be appropriately set before invoking this
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_draw(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_draw_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="random_draw_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>random_draw(Weibull(100,1),1000)
</code></pre>

<hr>
<h2 id='random_draw+2CCurve-method'>Method for taking random draws from a Curve object distribution</h2><span id='topic+random_draw+2CCurve-method'></span>

<h3>Description</h3>

<p>This takes random draws from the Curve object distribution
Note that the seed should always be appropriately set before invoking this
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
random_draw(theObject, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_draw+2B2CCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
<tr><td><code id="random_draw+2B2CCurve-method_+3A_n">n</code></td>
<td>
<p>Number of random draws required</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>random_draw(Weibull(100,1),1000)
</code></pre>

<hr>
<h2 id='RCurve-class'>RCurve Class for defining recruitment distributions</h2><span id='topic+RCurve-class'></span>

<h3>Description</h3>

<p>This class extends the Curve class, adding recruitment-related quantities such as patient numbers.
</p>


<h3>Slots</h3>


<dl>
<dt><code>N</code></dt><dd><p>Total number of patients recruited.</p>
</dd>
<dt><code>Nactive</code></dt><dd><p>Number of patients recruited in active arm. Nactive+Ncontrol=N.</p>
</dd>
<dt><code>Ncontrol</code></dt><dd><p>Number of patients recruited in control arm. Nactive+Ncontrol=N.</p>
</dd>
<dt><code>Ratio</code></dt><dd><p>Randomisation ratio. Nactive divided by Ncontrol = Ratio.</p>
</dd>
<dt><code>Length</code></dt><dd><p>Total length of the recruitment period.</p>
</dd>
<dt><code>RF</code></dt><dd><p>Name of the random generator function describing the Curve.</p>
</dd>
<dt><code>inverse</code></dt><dd><p>Name of the inverse CDF function describing the Curve. Optional; set to NULL if unavailable.</p>
</dd>
<dt><code>paramno</code></dt><dd><p>Number of parameters required to define the distribution.</p>
</dd>
<dt><code>pnames</code></dt><dd><p>Names of parameters defining the distribution. Should be a vector of length paramno.</p>
</dd>
<dt><code>pnames</code></dt><dd><p>Values of parameters defining the distribution. Should be a list of length paramno.</p>
</dd>
<dt><code>maxF</code></dt><dd><p>Maximum length of patient follow-up. Typically should be Inf.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new("RCurve", type="ExampleCurve",PDF="pdf_fn_name", CDF="CDF_fn_name",
  RF="random_draw_fn_name", inverse="inv_fn_name", paramno=2, pnames=c('param1','param2'),
  pvalue=list(1,2), 
N=100,Nactive=50,Ncontrol=40, Ratio=50/40, Length = 5, maxF = Inf)
</code></pre>

<hr>
<h2 id='run_gestate'>Load Shiny for Gestate
Loads the Shiny interactive GUI for gestate</h2><span id='topic+run_gestate'></span>

<h3>Description</h3>

<p>Load Shiny for Gestate
Loads the Shiny interactive GUI for gestate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_gestate()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>run_gestate()
</code></pre>

<hr>
<h2 id='set_assess_time'>Adjusts assessment time for simulations</h2><span id='topic+set_assess_time'></span>

<h3>Description</h3>

<p>Function for modifying the assessment time of simulate_trials() or simulate_trials_strata() simulations.<br />
It is set up to automatically read in either matrix or list formats from simulate_trials() or simulate_trials_strata(), and only these inputs are supported.<br />
Note that if recruitment had not finished in the input then any increases in assessment time cannot account for the missing patients.
It is therefore strongly recommended to initially simulate for at least the duration of the recruitment before reducing the number to missing patients.<br />
This function can also be used to change format and/or slim down data for time-driven simulations.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_assess_time(
  data,
  time,
  output_type = c("input", "matrix", "list"),
  detailed_output = TRUE,
  Time = "Time",
  Event = "Censored",
  censoringOne = TRUE,
  Iter = "Iter"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_assess_time_+3A_data">data</code></td>
<td>
<p>Output file from simulate_trials() or simulate_trials_strata() created with detailed_output=TRUE, in either &quot;list&quot; or &quot;matrix&quot; format. Only these formats are supported.</p>
</td></tr>
<tr><td><code id="set_assess_time_+3A_time">time</code></td>
<td>
<p>Positive number specifying the required assessment time.</p>
</td></tr>
<tr><td><code id="set_assess_time_+3A_output_type">output_type</code></td>
<td>
<p>Choice of &quot;input&quot; (output in same format as input),&quot;matrix&quot; (matrix format output) or &quot;list&quot; (list format output). Default=&quot;input&quot;.</p>
</td></tr>
<tr><td><code id="set_assess_time_+3A_detailed_output">detailed_output</code></td>
<td>
<p>Boolean to require full details of timings of competing processes. If FALSE, the simplified data only includes the *'ed output columns - this approximately halves RAM requirements. Default=TRUE (detailed).</p>
</td></tr>
<tr><td><code id="set_assess_time_+3A_time">Time</code></td>
<td>
<p>String specifying the name of the time column. Default=&quot;Time&quot;</p>
</td></tr>
<tr><td><code id="set_assess_time_+3A_event">Event</code></td>
<td>
<p>String specifying the name of the censoring/event column. Default=&quot;Censored&quot; (and by default it is a censoring column unless censoringOne=FALSE)</p>
</td></tr>
<tr><td><code id="set_assess_time_+3A_censoringone">censoringOne</code></td>
<td>
<p>Boolean specifying whether censoring is denoted in the censoring/event column by a one (TRUE) or zero (FALSE). Default=TRUE (censorings denoted by 1, events by 0)</p>
</td></tr>
<tr><td><code id="set_assess_time_+3A_iter">Iter</code></td>
<td>
<p>String specifying the name of the iterations column. Default=&quot;Iter&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input simulated trial, in either matrix or list format, with modified assessment times. All columns dependent on this are also updated.
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_sim &lt;- simulate_trials(active_ecurve=Weibull(250,0.8),control_ecurve=Weibull(100,1),
rcurve=LinearR(12,100,100), assess=20, iterations=5,seed=12345,detailed_output=TRUE)

adjusted_example &lt;- set_assess_time(data=example_sim,time=10)
</code></pre>

<hr>
<h2 id='set_event_number'>Adjusts simulations so that administrative censoring occurs at a fixed event number, rather than a fixed time</h2><span id='topic+set_event_number'></span>

<h3>Description</h3>

<p>Function for converting trials simulated by simulate_trials() or simulate_trials_strata() from a fixed censoring time to a fixed number of total events.<br />
It is set up to automatically read in either matrix or list formats from simulate_trials() or simulate_trials_strata(), and only these inputs are supported.<br />
Note that if recruitment had not finished in the input then any increases in assessment time cannot account for the missing patients.
It is therefore strongly recommended to initially simulate for at least the duration of the recruitment before fixing the event number.<br />
This function can also be used to change format and/or slim down data for event-driven simulations.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_event_number(
  data,
  events,
  output_type = c("input", "matrix", "list"),
  detailed_output = TRUE,
  Time = "Time",
  Event = "Censored",
  censoringOne = TRUE,
  Iter = "Iter"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_event_number_+3A_data">data</code></td>
<td>
<p>Output file from simulate_trials() or simulate_trials_strata() created with detailed_output=TRUE, in either &quot;list&quot; or &quot;matrix&quot; format. Only these formats are supported.</p>
</td></tr>
<tr><td><code id="set_event_number_+3A_events">events</code></td>
<td>
<p>Positive integer specifying the required number of events.</p>
</td></tr>
<tr><td><code id="set_event_number_+3A_output_type">output_type</code></td>
<td>
<p>Choice of &quot;input&quot; (output in same format as input),&quot;matrix&quot; (matrix format output) or &quot;list&quot; (list format output). Default=&quot;input&quot;.</p>
</td></tr>
<tr><td><code id="set_event_number_+3A_detailed_output">detailed_output</code></td>
<td>
<p>Boolean to require full details of timings of competing processes. If FALSE, the simplified data only includes the *'ed output columns - this approximately halves RAM requirements. Default=TRUE (detailed).</p>
</td></tr>
<tr><td><code id="set_event_number_+3A_time">Time</code></td>
<td>
<p>String specifying the name of the time column. Default=&quot;Time&quot;</p>
</td></tr>
<tr><td><code id="set_event_number_+3A_event">Event</code></td>
<td>
<p>String specifying the name of the censoring/event column. Default=&quot;Censored&quot; (and by default it is a censoring column unless censoringOne=FALSE)</p>
</td></tr>
<tr><td><code id="set_event_number_+3A_censoringone">censoringOne</code></td>
<td>
<p>Boolean specifying whether censoring is denoted in the censoring/event column by a one (TRUE) or zero (FALSE). Default=TRUE (censorings denoted by 1, events by 0)</p>
</td></tr>
<tr><td><code id="set_event_number_+3A_iter">Iter</code></td>
<td>
<p>String specifying the name of the iterations column. Default=&quot;Iter&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input simulated trial, in either matrix or list format, with modified assessment times. All columns dependent on this are also updated.
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_sim &lt;- simulate_trials(active_ecurve=Weibull(250,0.8),control_ecurve=Weibull(100,1),
rcurve=LinearR(12,100,100), assess=20,iterations=5,seed=12345,detailed_output=TRUE)

adjusted_examples &lt;- set_event_number(data=example_sim,events=50)
</code></pre>

<hr>
<h2 id='setPatients'>Method for setting N's in an RCurve</h2><span id='topic+setPatients'></span>

<h3>Description</h3>

<p>This sets the RCurve patient numbers per arm directly and updates N and Ratio accordingly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPatients(theObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPatients_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="setPatients_+3A_...">...</code></td>
<td>
<p>Pass-through arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>setPatients(LinearR(12,100,100),200,150)
</code></pre>

<hr>
<h2 id='setPatients+2CRCurve-method'>Method for setting N's in an RCurve</h2><span id='topic+setPatients+2CRCurve-method'></span>

<h3>Description</h3>

<p>This sets the RCurve patient numbers per arm directly and updates N and Ratio accordingly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
setPatients(theObject, Nactive, Ncontrol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPatients+2B2CRCurve-method_+3A_theobject">theObject</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
<tr><td><code id="setPatients+2B2CRCurve-method_+3A_nactive">Nactive</code></td>
<td>
<p>Number of patients to set in active arm</p>
</td></tr>
<tr><td><code id="setPatients+2B2CRCurve-method_+3A_ncontrol">Ncontrol</code></td>
<td>
<p>Number of patients to set in control arm</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>setPatients(LinearR(12,100,100),200,150)
</code></pre>

<hr>
<h2 id='show+2CCurve-method'>Method for displaying Curve objects neatly - replaces standard show method</h2><span id='topic+show+2CCurve-method'></span>

<h3>Description</h3>

<p>This is the standard print method for a Curve object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Curve'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CCurve-method_+3A_object">object</code></td>
<td>
<p>The name of the Curve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Weibull(100,1)
</code></pre>

<hr>
<h2 id='show+2CRCurve-method'>Method for displaying RCurve objects neatly - replaces standard show method</h2><span id='topic+show+2CRCurve-method'></span>

<h3>Description</h3>

<p>This is the standard print method for an RCurve Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCurve'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CRCurve-method_+3A_object">object</code></td>
<td>
<p>The name of the RCurve Object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>LinearR(12,100,100)
</code></pre>

<hr>
<h2 id='simulate_trials'>Perform simulations of time-to-event data using arbitrary event, censoring and recruitment distributions.</h2><span id='topic+simulate_trials'></span>

<h3>Description</h3>

<p>Function for simulating generalised two-arm time-to-event trial data for NPH trials with arbitrary event, censoring and recruitment distributions.<br />
Event and censoring distributions are specified via Curve objects, with recruitment specified through an RCurve object.
As it uses same architecture and similar syntax to nph_traj(), analysis results ought to be directly comparable.
It is designed to complement nph_traj(), either as a stochastic alternative, or as a means to validate its outputs.
It can also be used to build more complex simulations by combining the outputs of multiple runs; e.g. multi-arm trials.<br />
Data sets created by this function are formatted so they may be automatically recognised and analysed by analyse_sim().<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_trials(
  active_ecurve,
  control_ecurve,
  active_dcurve = Blank(),
  control_dcurve = Blank(),
  rcurve,
  assess = NULL,
  fix_events = NULL,
  iterations,
  seed,
  detailed_output = FALSE,
  output_type = c("matrix", "list"),
  Time = "Time",
  Event = "Censored",
  censoringOne = TRUE,
  Trt = "Trt",
  Iter = "Iter"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_trials_+3A_active_ecurve">active_ecurve</code></td>
<td>
<p>Event distribution for the active arm, specified as a Curve object</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_control_ecurve">control_ecurve</code></td>
<td>
<p>Event distribution for the control arm, specified as a Curve object</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_active_dcurve">active_dcurve</code></td>
<td>
<p>Dropout/censoring distribution for the active arm, specified as a Curve object. By default, Blank(), i.e. no dropout.</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_control_dcurve">control_dcurve</code></td>
<td>
<p>Dropout/censoring distribution for the control arm, specified as a Curve object. By default, Blank(), i.e. no dropout.</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_rcurve">rcurve</code></td>
<td>
<p>Recruitment distribution, specified as an RCurve object</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_assess">assess</code></td>
<td>
<p>Positive number for the assessment time at which administrative censoring will be performed.</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_fix_events">fix_events</code></td>
<td>
<p>Positive integer for the number of events to fix (if required), letting the assessment time vary. Alternatively, NULL for fixed time assessment with variable event numbers. Notes: Fixing event numbers overrides any specified assessment time and slows simulation considerably. Default = NULL (fixed analysis time)</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_iterations">iterations</code></td>
<td>
<p>Number of simulations to perform. Depending on trial size, 10,000-20,000 is typically OK to analyse on 8GB RAM.</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_seed">seed</code></td>
<td>
<p>Seed number to use. Numerical, although if &quot;Rand&quot; is specified, a system-time-derived number will be used.</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_detailed_output">detailed_output</code></td>
<td>
<p>Boolean to require full details of timings of competing processes. Full details required for any future adjustments to assessment time. Simplified option approximately halves RAM requirements. Default=FALSE (simplified).</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_output_type">output_type</code></td>
<td>
<p>&quot;matrix&quot; or &quot;list&quot; specifying the type of output required. &quot;matrix&quot; requests a single matrix with a column &quot;iter&quot; to denote the simulation, while &quot;list&quot; creates a list with one entry per simulation. Default=&quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_time">Time</code></td>
<td>
<p>String specifying the name of the output time column. Default=&quot;Time&quot;</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_event">Event</code></td>
<td>
<p>String specifying the name of the output censoring/event column. Default=&quot;Censored&quot; (and by default it is a censoring column unless censoringOne=FALSE)</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_censoringone">censoringOne</code></td>
<td>
<p>Boolean specifying whether censoring is denoted in the censoring/event column by a one (TRUE) or zero (FALSE). Default=TRUE (censorings denoted by 1, events by 0)</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_trt">Trt</code></td>
<td>
<p>String specifying the name of the output treatment column. Default=&quot;Trt&quot;</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_iter">Iter</code></td>
<td>
<p>String specifying the name of the output iterations column. Default=&quot;Iter&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table with one row per patient per simulation. Table contains the following columns:
</p>

<ul>
<li><p>&quot;Time&quot; Simulated actually observed (patient) time of event or censoring: This is the main column of interest for analysis. Named by Time argument.
</p>
</li>
<li><p>&quot;Event&quot; Simulated event indicator denoting censorings/events as 1/0 if censoringOne=TRUE and 0/1 if censoringOne=FALSE. Named by Event argument.
</p>
</li>
<li><p>&quot;Trt&quot; Treatment group number - 1 is active, 2 is control. Named by Trt argument.
</p>
</li>
<li><p>&quot;Iter&quot; Simulation number. Named by Iter argument.
</p>
</li>
<li><p>&quot;ETime&quot; Simulated actual event (patient) time (may or may not be observed). Only produced when detailed_output=TRUE.
</p>
</li>
<li><p>&quot;CTime&quot; Simulated actual censoring/dropout (patient) time (may or may not be observed).Only produced when detailed_output=TRUE.
</p>
</li>
<li><p>&quot;Rec_Time&quot; Simulated (trial) time of recruitment. Only produced when detailed_output=TRUE.
</p>
</li>
<li><p>&quot;Assess&quot; Prespecified (trial) time of assessment. Only produced when detailed_output=TRUE.
</p>
</li>
<li><p>&quot;Max_F&quot; Prespecified maximum patient follow-up time. Only produced when detailed_output=TRUE.
</p>
</li>
<li><p>&quot;RCTime&quot; Simulated actual administrative censoring (patient) time (may or may not be observed)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_sim &lt;- simulate_trials(active_ecurve=Weibull(250,0.8),control_ecurve=Weibull(100,1),
rcurve=LinearR(12,100,100), assess=20, iterations=5,seed=12345)
</code></pre>

<hr>
<h2 id='simulate_trials_strata'>Perform multi-strata simulations of time-to-event data using arbitrary event, censoring and recruitment distributions.</h2><span id='topic+simulate_trials_strata'></span>

<h3>Description</h3>

<p>Function for simulating generalised two-arm multi-strata time-to-event trial data for NPH trials with arbitrary event, censoring and recruitment distributions.<br />
Acts as a wrapper for simulate_trials.<br />
Vector of strata proportions supplies number of strata. Event and censoring distributions specified via lists of Curve objects. If only one Curve supplied then assumed to be common to all strata. Recruitment specified via a single RCurve object.<br />
As it uses same architecture and similar syntax to nph_traj(), results in simple cases may be directly comparable to e.g. use of MixExp() or MixWei() Curves.<br />
Can be used to validate outputs from nph_traj().<br />
Data sets from this are set up to be automatically analysed with the analyse_sim function (including stratified analysis if you provide it the name of stratum column).<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_trials_strata(
  stratum_probs,
  active_ecurve,
  control_ecurve,
  active_dcurve = Blank(),
  control_dcurve = Blank(),
  rcurve,
  assess = NULL,
  fix_events = NULL,
  stratum_name = "Stratum",
  iterations,
  seed,
  detailed_output = FALSE,
  output_type = c("matrix", "list"),
  Time = "Time",
  Event = "Censored",
  censoringOne = TRUE,
  Trt = "Trt",
  Iter = "Iter"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_trials_strata_+3A_stratum_probs">stratum_probs</code></td>
<td>
<p>Vector of probabilities that patients belong to each stratum. Must sum to 1. Its length determines the number of strata.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_active_ecurve">active_ecurve</code></td>
<td>
<p>List of event distributions for the active arm, specified as a list of Curve objects. If single Curve is specified, will be used for all strata.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_control_ecurve">control_ecurve</code></td>
<td>
<p>List of event distributions for the control arm, specified as a list of Curve objects. If single Curve is specified, will be used for all strata.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_active_dcurve">active_dcurve</code></td>
<td>
<p>List of dropout/censoring distribution for the active arm, specified as a Curve object. If single Curve is specified, will be used for all strata. By default, Blank(), i.e. no dropout in any stratum.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_control_dcurve">control_dcurve</code></td>
<td>
<p>List of dropout/censoring distribution for the control arm, specified as a Curve object. If single Curve is specified, will be used for all strata. By default, Blank(), i.e. no dropout in any stratum.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_rcurve">rcurve</code></td>
<td>
<p>Recruitment distribution, specified as a single RCurve object.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_assess">assess</code></td>
<td>
<p>Positive number for the assessment time at which administrative censoring will be performed.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_fix_events">fix_events</code></td>
<td>
<p>Positive integer for the number of events to fix (if required), letting the assessment time vary. Alternatively, NULL for fixed time assessment with variable event numbers. Notes: Fixing event numbers overrides any specified assessment time and slows simulation considerably. Default = NULL (fixed analysis time)</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_stratum_name">stratum_name</code></td>
<td>
<p>Name of the column defining the stratum. Default=&quot;Stratum&quot;.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_iterations">iterations</code></td>
<td>
<p>Number of simulations to perform. Depending on trial size, 10,000-20,000 is typically OK to analyse on 8GB RAM.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_seed">seed</code></td>
<td>
<p>Seed number to use. Numerical, although if &quot;Rand&quot; is specified, a system-time-derived number will be used.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_detailed_output">detailed_output</code></td>
<td>
<p>Boolean to require full details of timings of competing processes. Full details required for any future adjustments to assessment time. Simplified option approximately halves RAM requirements. Default=FALSE (simplified).</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_output_type">output_type</code></td>
<td>
<p>&quot;matrix&quot; or &quot;list&quot; specifying the type of output required. &quot;matrix&quot; requests a single matrix with a column &quot;iter&quot; to denote the simulation, while &quot;list&quot; creates a list with one entry per simulation. Default=&quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_time">Time</code></td>
<td>
<p>String specifying the name of the output time column. Default=&quot;Time&quot;</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_event">Event</code></td>
<td>
<p>String specifying the name of the output censoring/event column. Default=&quot;Censored&quot; (and by default it is a censoring column unless censoringOne=FALSE)</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_censoringone">censoringOne</code></td>
<td>
<p>Boolean specifying whether censoring is denoted in the censoring/event column by a one (TRUE) or zero (FALSE). Default=TRUE (censorings denoted by 1, events by 0)</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_trt">Trt</code></td>
<td>
<p>String specifying the name of the output treatment column. Default=&quot;Trt&quot;</p>
</td></tr>
<tr><td><code id="simulate_trials_strata_+3A_iter">Iter</code></td>
<td>
<p>String specifying the name of the output iterations column. Default=&quot;Iter&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table with one row per patient per simulation. Table contains the following columns:
</p>

<ul>
<li><p>&quot;Time&quot; Simulated actually observed (patient) time of event or censoring: This is the main column of interest for analysis. Named by Time argument.
</p>
</li>
<li><p>&quot;Event&quot; Simulated event indicator denoting censorings/events as 1/0 if censoringOne=TRUE and 0/1 if censoringOne=FALSE. Named by Event argument.
</p>
</li>
<li><p>&quot;Trt&quot; Treatment group number - 1 is active, 2 is control. Named by Trt argument.
</p>
</li>
<li><p>&quot;Iter&quot; Simulation number. Named by Iter argument.
</p>
</li>
<li><p>&quot;Stratum&quot; Stratum number. Column name will be the value of the stratum_name argument.)
</p>
</li>
<li><p>&quot;ETime&quot; Simulated actual event (patient) time (may or may not be observed). Only produced when detailed_output=TRUE.
</p>
</li>
<li><p>&quot;CTime&quot; Simulated actual censoring/dropout (patient) time (may or may not be observed).Only produced when detailed_output=TRUE.
</p>
</li>
<li><p>&quot;Rec_Time&quot; Simulated (trial) time of recruitment. Only produced when detailed_output=TRUE.
</p>
</li>
<li><p>&quot;Assess&quot; Prespecified (trial) time of assessment. Only produced when detailed_output=TRUE.
</p>
</li>
<li><p>&quot;Max_F&quot; Prespecified maximum patient follow-up time. Only produced when detailed_output=TRUE.
</p>
</li>
<li><p>&quot;RCTime&quot; Simulated actual administrative censoring (patient) time (may or may not be observed. Only produced when detailed_output=TRUE.)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_strat_sim &lt;- simulate_trials_strata(stratum_probs=c(0.5,0.5),
active_ecurve=c(Weibull(250,0.8),Weibull(100,1)), control_ecurve=Weibull(100,1),
rcurve=LinearR(12,100,100),assess=20,iterations=5,seed=12345)
</code></pre>

<hr>
<h2 id='summarise_analysis'>Summarise analyses of simulations of time-to-event data using arbitrary event, censoring and recruitment distributions.</h2><span id='topic+summarise_analysis'></span>

<h3>Description</h3>

<p>Function for summarising the analyses of simulated time-to-event trial data produced by analyse_sim().<br />
Automatically reads in format from analyse_sim(); no other input format is supported.<br />
It automatically detects types of analysis performed and provides relevant summaries (log-rank, Cox, RMST, landmark).<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_analysis(analysed_results, alpha1 = 0.025)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_analysis_+3A_analysed_results">analysed_results</code></td>
<td>
<p>Output file from analyse_sim(). Only analyse_sim() output is supported.</p>
</td></tr>
<tr><td><code id="summarise_analysis_+3A_alpha1">alpha1</code></td>
<td>
<p>1-sided alpha to be used for analysis. Default=0.025.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table with one row. Table contains the following columns:
</p>

<ul>
<li><p>&quot;Simulations&quot; Number of simulations conducted
</p>
</li>
<li><p>&quot;HR&quot; Exponent of Mean Cox Log Hazard Ratio (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;LogHR&quot; Mean Cox Log Hazard Ratio (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;LogHR_SE&quot; Root mean square of the Cox Standard Errors for Log Hazard Ratio (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;HR_Z&quot; Mean Cox Z-Score (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;HR_P&quot; p-value of Mean Cox Z-Score (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;HR_Power&quot; Simulated power of Cox-regression (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;HR_Failed&quot; Proportion of simulations failing to calculate a Cox HR (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;LR_Z&quot; Mean Log-Rank Test Z-Score (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;LR_P&quot; p-value of Mean Log-Rank Test Z-Score (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;LR_Power&quot; Simulated power of the log-rank test (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;LR_Failed&quot; Proportion of simulations failing to calculate a log-rank test statistic (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;Events_Active&quot; Mean events in active arm (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;Events_Control&quot; Mean events in control arm (LR/Cox analysis only)
</p>
</li>
<li><p>&quot;Events_Total&quot; Mean total events(LR/Cox analysis only)
</p>
</li>
<li><p>&quot;RMST_Time&quot; Restriction time for RMST analysis (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Control&quot; Mean RMST for active arm (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_C_SE&quot; Root mean square of RMST Standard Errors for active arm (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Active&quot; Mean RMST for control arm (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_A_SE&quot; Root mean square of RMST Standard Errors for control arm (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Delta&quot; Mean RMST difference between arms active-control (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_D_SE&quot; Root mean square of RMST difference Standard Errors (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Power&quot; Simulated power of RMST (RMST analysis only)
</p>
</li>
<li><p>&quot;RMST_Failed&quot; Proportion of simulations failing to calculate the RMST (RMST analysis only)
</p>
</li>
<li><p>&quot;LM_Time&quot; Landmark analysis time, i.e. assessment time of Survival function (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Control&quot; Mean survival function for active arm at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_C_SE&quot; Root mean square of Greenwood standard errors for active arm at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Active&quot; Mean survival function for control arm at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_A_SE&quot; Root mean square of Greenwood standard errors for control arm at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Delta&quot; Mean survival function difference active-control at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_D_SE&quot; Root mean square of Greenwood standard errors for survival differences at landmark time (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Power&quot; Power of landmark analysis (Landmark analysis only)
</p>
</li>
<li><p>&quot;LM_Failed&quot; Proportion of simulations failing to calculate the survival difference at landmark time (Landmark analysis only)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_sim &lt;- simulate_trials(active_ecurve=Weibull(250,0.8),control_ecurve=Weibull(100,1),
rcurve=LinearR(12,100,100), assess=40, iterations=5,seed=12345,detailed_output=TRUE)

example_analysis1 &lt;- analyse_sim(example_sim)
example_analysis2 &lt;- analyse_sim(data=example_sim,RMST=30,landmark=30)

example_summary1 &lt;- summarise_analysis(example_analysis1)
example_summary2 &lt;- summarise_analysis(example_analysis2)
</code></pre>

<hr>
<h2 id='survfit_fast'>Create lifetable quickly</h2><span id='topic+survfit_fast'></span>

<h3>Description</h3>

<p>Simple, fast function to generate basic lifetables. No error checking is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survfit_fast(time, events)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survfit_fast_+3A_time">time</code></td>
<td>
<p>Vector of event/censoring times</p>
</td></tr>
<tr><td><code id="survfit_fast_+3A_events">events</code></td>
<td>
<p>Vector of indicators for whether each time is an event (1) or a censoring (0). Must be same length vector as time argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list format lifetable with the following entries:
</p>

<ul>
<li><p>&quot;n&quot;Number of patients
</p>
</li>
<li><p>&quot;time&quot;Vector of times
</p>
</li>
<li><p>&quot;n.risk&quot;Vector of numbers of patients at risk at each time
</p>
</li>
<li><p>&quot;n.event&quot;Vector of numbers of patients with an event at each time
</p>
</li>
<li><p>&quot;n.censor&quot;Vector of numbers of patients censored at each time
</p>
</li>
<li><p>&quot;surv&quot;Vector of estimates of Survival function at each time
</p>
</li>
<li><p>&quot;se&quot;Vector of standard errors of estimates of Survival function at each time
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>survfit_fast(c(1,2,3,3,4,5),c(1,0,1,1,0,1))
</code></pre>

<hr>
<h2 id='Weibull'>Weibull Curve constructor function</h2><span id='topic+Weibull'></span>

<h3>Description</h3>

<p>This creates a Curve object for a Weibull distribution.<br />
Curve objects contain all necessary information to describe a distribution, including functions and parameters describing it.<br />
Parameterisation follows that used by pweibull etc. See Details for more information on parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Weibull(alpha, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Weibull_+3A_alpha">alpha</code></td>
<td>
<p>Scale parameter for Weibull distribution.</p>
</td></tr>
<tr><td><code id="Weibull_+3A_beta">beta</code></td>
<td>
<p>Shape parameter for Weibull distribution. Default is 1; an exponential distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Weibull distribution with shape parameter beta and scale parameter alpha has parameterisation:<br />
f(x) = (beta/alpha) (x/alpha)^(beta-1) exp(- (x/alpha)^beta)<br />
F(x) = 1 - exp(- (x/alpha)^beta)
</p>


<h3>Author(s)</h3>

<p>James Bell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Weibull(alpha=100,beta=0.8)
</code></pre>

<hr>
<h2 id='ZV2power'>Calculate Normal distribution test power based on Effect size and Variance</h2><span id='topic+ZV2power'></span>

<h3>Description</h3>

<p>Calculate Normal distribution test power based on Effect size and Variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZV2power(Z, V = 1, alpha1 = 0.025)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZV2power_+3A_z">Z</code></td>
<td>
<p>effect size.</p>
</td></tr>
<tr><td><code id="ZV2power_+3A_v">V</code></td>
<td>
<p>variance. Default=1.</p>
</td></tr>
<tr><td><code id="ZV2power_+3A_alpha1">alpha1</code></td>
<td>
<p>1-sided alpha. Default=0.025.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Power as a decimal
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
