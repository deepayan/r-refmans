<!DOCTYPE html><html><head><title>Help for package DIscBIO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DIscBIO}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.DISCBIO'><p>Convert Single Cell Data Objects to DISCBIO.</p></a></li>
<li><a href='#check.format'><p>Check format</p></a></li>
<li><a href='#ClassVectoringDT'><p>Generating a class vector to be used for the decision tree analysis.</p></a></li>
<li><a href='#ClustDiffGenes'><p>ClustDiffGenes</p></a></li>
<li><a href='#Clustexp'><p>Clustering of single-cell transcriptome data</p></a></li>
<li><a href='#clustheatmap'><p>Plotting clusters in a heatmap representation of the cell distances</p></a></li>
<li><a href='#comptSNE'><p>Computing tSNE</p></a></li>
<li><a href='#customConvertFeats'><p>Automatic Feature Id Conversion.</p></a></li>
<li><a href='#DEGanalysis'><p>Determining differentially expressed genes (DEGs) between all</p>
individual clusters.</a></li>
<li><a href='#DEGanalysis2clust'><p>Determining differentially expressed genes (DEGs) between two</p>
particular clusters.</a></li>
<li><a href='#DISCBIO'><p>The DISCBIO Class</p></a></li>
<li><a href='#DISCBIO2SingleCellExperiment'><p>Convert a DISCBIO object to a SingleCellExperiment.</p></a></li>
<li><a href='#Exprmclust'><p>Performing Model-based clustering on expression values</p></a></li>
<li><a href='#FinalPreprocessing'><p>Final Preprocessing</p></a></li>
<li><a href='#FindOutliers'><p>Inference of outlier cells</p></a></li>
<li><a href='#foldchange.seq.twoclass.unpaired'><p>Foldchange of twoclass unpaired sequencing data</p></a></li>
<li><a href='#HumanMouseGeneIds'><p>Human and Mouse Gene Identifiers.</p></a></li>
<li><a href='#J48DT'><p>J48 Decision Tree</p></a></li>
<li><a href='#J48DTeval'><p>Evaluating the performance of the J48 decision tree.</p></a></li>
<li><a href='#Jaccard'><p>Jaccard’s similarity</p></a></li>
<li><a href='#KmeanOrder'><p>Pseudo-time ordering based on k-means clusters</p></a></li>
<li><a href='#NetAnalysis'><p>Networking analysis.</p></a></li>
<li><a href='#Networking'><p>Plotting the network.</p></a></li>
<li><a href='#NoiseFiltering'><p>Noise Filtering</p></a></li>
<li><a href='#Normalizedata'><p>Normalizing and filtering</p></a></li>
<li><a href='#PCAplotSymbols'><p>Plot PCA symbols</p></a></li>
<li><a href='#plotExptSNE'><p>Highlighting gene expression in the t-SNE map</p></a></li>
<li><a href='#plotGap'><p>Plotting Gap Statistics</p></a></li>
<li><a href='#plotLabelstSNE'><p>tSNE map with labels</p></a></li>
<li><a href='#PlotMBpca'><p>Plotting pseudo-time ordering or gene expression in Model-based</p>
clustering in PCA</a></li>
<li><a href='#PlotmclustMB'><p>Plotting the Model-based clusters in PCA.</p></a></li>
<li><a href='#plotOrderTsne'><p>Plotting the pseudo-time ordering in the t-SNE map</p></a></li>
<li><a href='#plotSilhouette'><p>Silhouette Plot for K-means clustering</p></a></li>
<li><a href='#plotSymbolstSNE'><p>tSNE map for K-means clustering with symbols</p></a></li>
<li><a href='#plottSNE'><p>tSNE map</p></a></li>
<li><a href='#PPI'><p>Defining protein-protein interactions (PPI) over a list of genes,</p></a></li>
<li><a href='#prepExampleDataset'><p>Prepare Example Dataset</p></a></li>
<li><a href='#pseudoTimeOrdering'><p>Pseudo-time ordering</p></a></li>
<li><a href='#rankcols'><p>Rank columns</p></a></li>
<li><a href='#reformatSiggenes'><p>Reformat Siggenes Table</p></a></li>
<li><a href='#replaceDecimals'><p>Replace Decimals</p></a></li>
<li><a href='#resa'><p>Resampling</p></a></li>
<li><a href='#retrieveURL'><p>Retries a URL</p></a></li>
<li><a href='#RpartDT'><p>RPART Decision Tree</p></a></li>
<li><a href='#RpartEVAL'><p>Evaluating the performance of the RPART Decision Tree.</p></a></li>
<li><a href='#sammy'><p>Significance analysis of microarrays</p></a></li>
<li><a href='#samr.estimate.depth'><p>Estimate sequencing depths</p></a></li>
<li><a href='#valuesG1msTest'><p>Single-cells data from a myxoid liposarcoma cell line</p></a></li>
<li><a href='#VolcanoPlot'><p>Volcano Plot</p></a></li>
<li><a href='#wilcoxon.unpaired.seq.func'><p>Twoclass Wilcoxon statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Date:</td>
<td>2023-11-06</td>
</tr>
<tr>
<td>Title:</td>
<td>A User-Friendly Pipeline for Biomarker Discovery in Single-Cell
Transcriptomics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>An open, multi-algorithmic pipeline for easy, fast and efficient
  analysis of cellular sub-populations and the molecular signatures that
  characterize them. The pipeline consists of four successive steps: data
  pre-processing, cellular clustering with pseudo-temporal ordering, defining
  differential expressed genes and biomarker identification. More details on
  Ghannoum et. al. (2021) &lt;<a href="https://doi.org/10.3390%2Fijms22031399">doi:10.3390/ijms22031399</a>&gt;. This package implements
  extensions of the work published by Ghannoum et. al. (2019)
  &lt;<a href="https://doi.org/10.1101%2F700989">doi:10.1101/700989</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, TSCAN, httr, mclust, statmod, igraph, RWeka, vegan,
NetIndices, png, grDevices, RColorBrewer, ggplot2, rpart, fpc,
cluster, rpart.plot, tsne, AnnotationDbi, org.Hs.eg.db,
graphics, stats, utils, impute, withr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), SingleCellExperiment</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, Seurat</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ocbe-uio/DIscBIO">https://github.com/ocbe-uio/DIscBIO</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ocbe-uio/DIscBIO/issues">https://github.com/ocbe-uio/DIscBIO/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'DIscBIO-classes.R' 'DIscBIO-generic-ClassVectoringDT.R'
'DIscBIO-generic-ClustDiffGenes.R' 'DIscBIO-generic-Clustexp.R'
'DIscBIO-generic-DEGanalysis.R'
'DIscBIO-generic-DEGanalysis2clust.R'
'DIscBIO-generic-Exprmclust.R'
'DIscBIO-generic-FinalPreprocessing.R'
'DIscBIO-generic-FindOutliers.R'
'DIscBIO-generic-NoiseFiltering.R'
'DIscBIO-generic-Normalizedata.R'
'DIscBIO-generic-PCAplotSymbols.R'
'DIscBIO-generic-PlotmclustMB.R'
'DIscBIO-generic-clusteringOrder.R'
'DIscBIO-generic-clustheatmap.R' 'DIscBIO-generic-comptSNE.R'
'DIscBIO-generic-plotExptSNE.R' 'DIscBIO-generic-plotGap.R'
'DIscBIO-generic-plotLabelstSNE.R'
'DIscBIO-generic-plotOrderTsne.R'
'DIscBIO-generic-plotSilhouette.R'
'DIscBIO-generic-plotSymbolstSNE.R'
'DIscBIO-generic-plottSNE.R'
'DIscBIO-generic-pseudoTimeOrdering.R' 'J48DT.R' 'J48DTeval.R'
'Jaccard.R' 'NetAnalysis.R' 'Networking.R' 'PPI.R'
'PlotMBpca.R' 'RpartDT.R' 'RpartEVAL.R' 'VolcanoPlot.R'
'bootstrap.R' 'calc_pcareduceres.R' 'cross.val.R'
'customConverters.R' 'datasets.R'
'internal-functions-samr-adapted.R' 'internal-functions.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-06 09:18:46 UTC; waldir</td>
</tr>
<tr>
<td>Author:</td>
<td>Salim Ghannoum [aut, cph],
  Alvaro Köhn-Luque [aut, ths],
  Waldir Leoncio [cre, aut],
  Damiano Fantini [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Waldir Leoncio &lt;w.l.netto@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-06 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.DISCBIO'>Convert Single Cell Data Objects to DISCBIO.</h2><span id='topic+as.DISCBIO'></span>

<h3>Description</h3>

<p>Initialize a DISCBIO-class object starting from a
SingleCellExperiment object or a Seurat object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.DISCBIO(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.DISCBIO_+3A_x">x</code></td>
<td>
<p>an object of class Seurat or SingleCellExperiment</p>
</td></tr>
<tr><td><code id="as.DISCBIO_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional parameters to pass to 'list' include, if x is
a Seurat object, &quot;assay&quot;, which is a string indicating the assay slot
used to obtain data from (defaults to 'RNA')
</p>


<h3>Value</h3>

<p>a DISCBIO-class object
</p>

<hr>
<h2 id='check.format'>Check format</h2><span id='topic+check.format'></span>

<h3>Description</h3>

<p>Check format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.format(y, resp.type, censoring.status = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.format_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="check.format_+3A_resp.type">resp.type</code></td>
<td>
<p>resp type</p>
</td></tr>
<tr><td><code id="check.format_+3A_censoring.status">censoring.status</code></td>
<td>
<p>censoring status</p>
</td></tr>
</table>

<hr>
<h2 id='ClassVectoringDT'>Generating a class vector to be used for the decision tree analysis.</h2><span id='topic+ClassVectoringDT'></span><span id='topic+ClassVectoringDT+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This function generates a class vector for the input dataset so
the decision tree analysis can be implemented afterwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClassVectoringDT(
  object,
  Clustering = "K-means",
  K,
  First = "CL1",
  Second = "CL2",
  sigDEG,
  quiet = FALSE
)

## S4 method for signature 'DISCBIO'
ClassVectoringDT(
  object,
  Clustering = "K-means",
  K,
  First = "CL1",
  Second = "CL2",
  sigDEG,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClassVectoringDT_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="ClassVectoringDT_+3A_clustering">Clustering</code></td>
<td>
<p>Clustering has to be one of the following: [&quot;K-means&quot;,
&quot;MB&quot;]. Default is &quot;K-means&quot;</p>
</td></tr>
<tr><td><code id="ClassVectoringDT_+3A_k">K</code></td>
<td>
<p>A numeric value of the number of clusters.</p>
</td></tr>
<tr><td><code id="ClassVectoringDT_+3A_first">First</code></td>
<td>
<p>A string vector showing the first target cluster.  Default is
&quot;CL1&quot;</p>
</td></tr>
<tr><td><code id="ClassVectoringDT_+3A_second">Second</code></td>
<td>
<p>A string vector showing the second target cluster.  Default is
&quot;CL2&quot;</p>
</td></tr>
<tr><td><code id="ClassVectoringDT_+3A_sigdeg">sigDEG</code></td>
<td>
<p>A data frame of the differentially expressed genes (DEGs)
generated by running &quot;DEGanalysis()&quot; or &quot;DEGanalysisM()&quot;.</p>
</td></tr>
<tr><td><code id="ClassVectoringDT_+3A_quiet">quiet</code></td>
<td>
<p>If 'TRUE', suppresses intermediary output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>

<hr>
<h2 id='ClustDiffGenes'>ClustDiffGenes</h2><span id='topic+ClustDiffGenes'></span><span id='topic+ClustDiffGenes+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>Creates a table of cluster differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClustDiffGenes(
  object,
  K,
  pValue = 0.05,
  fdr = 0.01,
  export = FALSE,
  quiet = FALSE,
  filename_up = "Up-DEG-cluster",
  filename_down = "Down-DEG-cluster",
  filename_binom = "binomial-DEGsTable",
  filename_sigdeg = "binomial-sigDEG"
)

## S4 method for signature 'DISCBIO'
ClustDiffGenes(
  object,
  K,
  pValue = 0.05,
  fdr = 0.01,
  export = FALSE,
  quiet = FALSE,
  filename_up = "Up-DEG-cluster",
  filename_down = "Down-DEG-cluster",
  filename_binom = "binomial-DEGsTable",
  filename_sigdeg = "binomial-sigDEG"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClustDiffGenes_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="ClustDiffGenes_+3A_k">K</code></td>
<td>
<p>A numeric value of the number of clusters.</p>
</td></tr>
<tr><td><code id="ClustDiffGenes_+3A_pvalue">pValue</code></td>
<td>
<p>A numeric value of the p-value. Default is 0.05.</p>
</td></tr>
<tr><td><code id="ClustDiffGenes_+3A_fdr">fdr</code></td>
<td>
<p>A numeric value of the false discovery rate. Default is 0.01.</p>
</td></tr>
<tr><td><code id="ClustDiffGenes_+3A_export">export</code></td>
<td>
<p>A logical vector that allows writing the final gene list in
excel file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ClustDiffGenes_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', suppresses intermediate text output</p>
</td></tr>
<tr><td><code id="ClustDiffGenes_+3A_filename_up">filename_up</code></td>
<td>
<p>Name of the exported &quot;up&quot; file (if 'export=TRUE')</p>
</td></tr>
<tr><td><code id="ClustDiffGenes_+3A_filename_down">filename_down</code></td>
<td>
<p>Name of the exported &quot;down&quot; file (if 'export=TRUE')</p>
</td></tr>
<tr><td><code id="ClustDiffGenes_+3A_filename_binom">filename_binom</code></td>
<td>
<p>Name of the exported binomial file</p>
</td></tr>
<tr><td><code id="ClustDiffGenes_+3A_filename_sigdeg">filename_sigdeg</code></td>
<td>
<p>Name of the exported sigDEG file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- DISCBIO(valuesG1msTest)
sc &lt;- Clustexp(sc, cln = 3, quiet = TRUE)
cdiff &lt;- ClustDiffGenes(sc, K = 3, fdr = .3, export = FALSE)
str(cdiff)
cdiff[[2]]
</code></pre>

<hr>
<h2 id='Clustexp'>Clustering of single-cell transcriptome data</h2><span id='topic+Clustexp'></span><span id='topic+Clustexp+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This functions performs the initial clustering of the RaceID
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Clustexp(
  object,
  clustnr = 3,
  bootnr = 50,
  metric = "pearson",
  do.gap = TRUE,
  SE.method = "Tibs2001SEmax",
  SE.factor = 0.25,
  B.gap = 50,
  cln = 0,
  rseed = NULL,
  quiet = FALSE
)

## S4 method for signature 'DISCBIO'
Clustexp(
  object,
  clustnr = 3,
  bootnr = 50,
  metric = "pearson",
  do.gap = TRUE,
  SE.method = "Tibs2001SEmax",
  SE.factor = 0.25,
  B.gap = 50,
  cln = 0,
  rseed = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Clustexp_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="Clustexp_+3A_clustnr">clustnr</code></td>
<td>
<p>Maximum number of clusters for the derivation of the cluster
number by the saturation of mean within-cluster-dispersion. Default is 20.</p>
</td></tr>
<tr><td><code id="Clustexp_+3A_bootnr">bootnr</code></td>
<td>
<p>A numeric value of booststrapping runs for <code>clusterboot</code>.
Default is 50.</p>
</td></tr>
<tr><td><code id="Clustexp_+3A_metric">metric</code></td>
<td>
<p>Is the method to transform the input data to a distance object.
Metric has to be one of the following: [&quot;spearman&quot;, &quot;pearson&quot;, &quot;kendall&quot;,
&quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, &quot;minkowski&quot;].</p>
</td></tr>
<tr><td><code id="Clustexp_+3A_do.gap">do.gap</code></td>
<td>
<p>A logical vector that allows generating the number of clusters
based on the gap statistics. Default is TRUE.</p>
</td></tr>
<tr><td><code id="Clustexp_+3A_se.method">SE.method</code></td>
<td>
<p>The SE.method determines the first local maximum of the gap
statistics. The SE.method has to be one of the following:[&quot;firstSEmax&quot;,
&quot;Tibs2001SEmax&quot;, &quot;globalSEmax&quot;, &quot;firstmax&quot;, &quot;globalmax&quot;]. Default is
&quot;Tibs2001SEmax&quot;</p>
</td></tr>
<tr><td><code id="Clustexp_+3A_se.factor">SE.factor</code></td>
<td>
<p>A numeric value of the fraction of the standard deviation by
which the local maximum is required to differ from the neighboring points
it is compared to. Default is 0.25.</p>
</td></tr>
<tr><td><code id="Clustexp_+3A_b.gap">B.gap</code></td>
<td>
<p>Number of bootstrap runs for the calculation of the gap
statistics. Default is 50</p>
</td></tr>
<tr><td><code id="Clustexp_+3A_cln">cln</code></td>
<td>
<p>Number of clusters to be used. Default is <code>NULL</code> and the
cluster number is inferred by the saturation criterion.</p>
</td></tr>
<tr><td><code id="Clustexp_+3A_rseed">rseed</code></td>
<td>
<p>Random integer to enforce reproducible clustering results.</p>
</td></tr>
<tr><td><code id="Clustexp_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', intermediate output is suppressed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DISCBIO-class object input with the cpart slot filled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- DISCBIO(valuesG1msTest) # changes signature of data
sc &lt;- Clustexp(sc, cln = 2)
</code></pre>

<hr>
<h2 id='clustheatmap'>Plotting clusters in a heatmap representation of the cell distances</h2><span id='topic+clustheatmap'></span><span id='topic+clustheatmap+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This functions plots a heatmap of the distance matrix grouped
by clusters. Individual clusters are highlighted with rainbow colors along
the x and y-axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustheatmap(
  object,
  clustering_method = "k-means",
  hmethod = "single",
  rseed = NULL,
  quiet = FALSE,
  plot = TRUE
)

## S4 method for signature 'DISCBIO'
clustheatmap(
  object,
  clustering_method = "k-means",
  hmethod = "single",
  rseed = NULL,
  quiet = FALSE,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustheatmap_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="clustheatmap_+3A_clustering_method">clustering_method</code></td>
<td>
<p>either &quot;k-means&quot; or &quot;model-based&quot; (&quot;k&quot; and &quot;mb&quot; are
also accepted)</p>
</td></tr>
<tr><td><code id="clustheatmap_+3A_hmethod">hmethod</code></td>
<td>
<p>Agglomeration method used for determining the cluster order
from hierarchical clustering of the cluster medoids. This should be one of
&quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;. Default is &quot;single&quot;.</p>
</td></tr>
<tr><td><code id="clustheatmap_+3A_rseed">rseed</code></td>
<td>
<p>Random integer to fix random results.</p>
</td></tr>
<tr><td><code id="clustheatmap_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', intermediary output is suppressed</p>
</td></tr>
<tr><td><code id="clustheatmap_+3A_plot">plot</code></td>
<td>
<p>if 'TRUE', plots the heatmap; otherwise, just prints cclmo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Unless otherwise specified, a heatmap and a vector of the underlying
cluster order.
</p>

<hr>
<h2 id='comptSNE'>Computing tSNE</h2><span id='topic+comptSNE'></span><span id='topic+comptSNE+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This function is used to compute the t-Distributed Stochastic
Neighbor Embedding (t-SNE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comptSNE(
  object,
  rseed = NULL,
  max_iter = 5000,
  epoch = 500,
  quiet = FALSE,
  ...
)

## S4 method for signature 'DISCBIO'
comptSNE(
  object,
  rseed = NULL,
  max_iter = 5000,
  epoch = 500,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comptSNE_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="comptSNE_+3A_rseed">rseed</code></td>
<td>
<p>Random integer to to yield reproducible maps across different
runs</p>
</td></tr>
<tr><td><code id="comptSNE_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="comptSNE_+3A_epoch">epoch</code></td>
<td>
<p>The number of iterations in between update messages.</p>
</td></tr>
<tr><td><code id="comptSNE_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', suppresses intermediate output</p>
</td></tr>
<tr><td><code id="comptSNE_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to 'tsne::tsne'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DISCBIO-class object input with the tsne slot filled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- DISCBIO(valuesG1msTest) # changes signature of data
sc &lt;- Clustexp(sc, cln = 2) # data must be clustered before plottin
sc &lt;- comptSNE(sc, max_iter = 30)
head(sc@tsne)

</code></pre>

<hr>
<h2 id='customConvertFeats'>Automatic Feature Id Conversion.</h2><span id='topic+customConvertFeats'></span>

<h3>Description</h3>

<p>Attempt to automatically convert non-ENSEMBL feature identifiers to
ENSEMBL identifiers. Features are included as rownames of the input
data.frame (or matrix). It is assumed that feature identifiers
(i.e., rownames of x) come from human or mouse genomes, and
are either OFFICIAL SYMBOLS or ENTREZIDS. If less than 20
is identified, an error will be thrown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>customConvertFeats(x, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="customConvertFeats_+3A_x">x</code></td>
<td>
<p>data.frame or matrix including raw counts (typically, UMIs),
where rows are features (genes) and rownames are feature identifiers
(SYMBOLs or ENTREZIDs).</p>
</td></tr>
<tr><td><code id="customConvertFeats_+3A_verbose">verbose</code></td>
<td>
<p>logical, shall messages be printed to inform about
conversion advances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame where rownames are ENSEMBL IDs. The new feature IDs are
automatically imputed based on existing feature IDs (SYMBOLs or ENTREZIDs).
</p>

<hr>
<h2 id='DEGanalysis'>Determining differentially expressed genes (DEGs) between all
individual clusters.</h2><span id='topic+DEGanalysis'></span><span id='topic+DEGanalysis+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This function defines DEGs between all individual clusters
generated by either K-means or model based clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEGanalysis(
  object,
  K,
  Clustering = "K-means",
  fdr = 0.05,
  name = "Name",
  export = FALSE,
  quiet = FALSE,
  plot = TRUE,
  filename_deg = "DEGsTable",
  filename_sigdeg = "sigDEG",
  ...
)

## S4 method for signature 'DISCBIO'
DEGanalysis(
  object,
  K,
  Clustering = "K-means",
  fdr = 0.05,
  name = "Name",
  export = FALSE,
  quiet = FALSE,
  plot = TRUE,
  filename_deg = "DEGsTable",
  filename_sigdeg = "sigDEG",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEGanalysis_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="DEGanalysis_+3A_k">K</code></td>
<td>
<p>A numeric value of the number of clusters.</p>
</td></tr>
<tr><td><code id="DEGanalysis_+3A_clustering">Clustering</code></td>
<td>
<p>Clustering has to be one of the following:
[&quot;K-means&quot;,&quot;MB&quot;]. Default is &quot;K-means&quot;</p>
</td></tr>
<tr><td><code id="DEGanalysis_+3A_fdr">fdr</code></td>
<td>
<p>A numeric value of the false discovery rate. Default is 0.05.</p>
</td></tr>
<tr><td><code id="DEGanalysis_+3A_name">name</code></td>
<td>
<p>A string vector showing the name to be used to save the resulted
tables.</p>
</td></tr>
<tr><td><code id="DEGanalysis_+3A_export">export</code></td>
<td>
<p>A logical vector that allows writing the final gene list in
excel file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="DEGanalysis_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', suppresses intermediate text output</p>
</td></tr>
<tr><td><code id="DEGanalysis_+3A_plot">plot</code></td>
<td>
<p>if 'TRUE', plots are generated</p>
</td></tr>
<tr><td><code id="DEGanalysis_+3A_filename_deg">filename_deg</code></td>
<td>
<p>Name of the exported DEG table</p>
</td></tr>
<tr><td><code id="DEGanalysis_+3A_filename_sigdeg">filename_sigdeg</code></td>
<td>
<p>Name of the exported sigDEG table</p>
</td></tr>
<tr><td><code id="DEGanalysis_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to samr()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two tables.
</p>

<hr>
<h2 id='DEGanalysis2clust'>Determining differentially expressed genes (DEGs) between two
particular clusters.</h2><span id='topic+DEGanalysis2clust'></span><span id='topic+DEGanalysis2clust+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This function defines DEGs between particular clusters generated
by either K-means or model based clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEGanalysis2clust(
  object,
  K,
  Clustering = "K-means",
  fdr = 0.05,
  name = "Name",
  First = "CL1",
  Second = "CL2",
  export = FALSE,
  quiet = FALSE,
  plot = TRUE,
  filename_deg = "DEGsTable",
  filename_sigdeg = "sigDEG",
  ...
)

## S4 method for signature 'DISCBIO'
DEGanalysis2clust(
  object,
  K,
  Clustering = "K-means",
  fdr = 0.05,
  name = "Name",
  First = "CL1",
  Second = "CL2",
  export = FALSE,
  quiet = FALSE,
  plot = TRUE,
  filename_deg = "DEGsTable",
  filename_sigdeg = "sigDEG",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEGanalysis2clust_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_k">K</code></td>
<td>
<p>A numeric value of the number of clusters.</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_clustering">Clustering</code></td>
<td>
<p>Clustering has to be one of the following:
[&quot;K-means&quot;,&quot;MB&quot;]. Default is &quot;K-means&quot;</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_fdr">fdr</code></td>
<td>
<p>A numeric value of the false discovery rate. Default is 0.05.</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_name">name</code></td>
<td>
<p>A string vector showing the name to be used to save the resulted
tables.</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_first">First</code></td>
<td>
<p>A string vector showing the first target cluster.  Default is
&quot;CL1&quot;</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_second">Second</code></td>
<td>
<p>A string vector showing the second target cluster.  Default is
&quot;CL2&quot;</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_export">export</code></td>
<td>
<p>A logical vector that allows writing the final gene list in
excel file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', suppresses intermediate text output</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_plot">plot</code></td>
<td>
<p>if 'TRUE', plots are generated</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_filename_deg">filename_deg</code></td>
<td>
<p>Name of the exported DEG table</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_filename_sigdeg">filename_sigdeg</code></td>
<td>
<p>Name of the exported sigDEG table</p>
</td></tr>
<tr><td><code id="DEGanalysis2clust_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to samr()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two tables.
</p>

<hr>
<h2 id='DISCBIO'>The DISCBIO Class</h2><span id='topic+DISCBIO'></span><span id='topic+DISCBIO-class+2C'></span><span id='topic+DISCBIO-class'></span>

<h3>Description</h3>

<p>The DISCBIO class is the central object storing all information
generated throughout the pipeline.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="DISCBIO_+3A_object">object</code></td>
<td>
<p>An DISCBIO object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DISCBIO
</p>


<h3>Slots</h3>


<dl>
<dt><code>SingleCellExperiment</code></dt><dd><p>Representation of the single cell input data,
including both cells from regular and ERCC spike-in samples. Data are
stored in a SingleCellExperiment object.</p>
</dd>
<dt><code>expdata</code></dt><dd><p>The raw expression data matrix with cells as columns and
genes as rows in sparse matrix format. It does not contain ERCC spike-ins.</p>
</dd>
<dt><code>expdataAll</code></dt><dd><p>The raw expression data matrix with cells as columns
and genes as rows in sparse matrix format. It can contain ERCC spike-ins.</p>
</dd>
<dt><code>ndata</code></dt><dd><p>Data with expression normalized to one for each cell.</p>
</dd>
<dt><code>fdata</code></dt><dd><p>Filtered data with expression normalized to one for each
cell.</p>
</dd>
<dt><code>distances</code></dt><dd><p>A distance matrix.</p>
</dd>
<dt><code>tsne</code></dt><dd><p>A data.frame with coordinates of two-dimensional tsne layout
for the K-means clustering.</p>
</dd>
<dt><code>background</code></dt><dd><p>A list storing the polynomial fit for the background
model of gene expression variability. It is used for outlier
identification.</p>
</dd>
<dt><code>out</code></dt><dd><p>A list storing information on outlier cells used for the
prediction of rare cell types.</p>
</dd>
<dt><code>cpart</code></dt><dd><p>A vector containing the final clustering partition computed
by K-means.</p>
</dd>
<dt><code>fcol</code></dt><dd><p>A vector contaning the colour scheme for the clusters.</p>
</dd>
<dt><code>filterpar</code></dt><dd><p>A list containing the parameters used for cell and gene
filtering based on expression.</p>
</dd>
<dt><code>clusterpar</code></dt><dd><p>A list containing the parameters used for the K-means
clustering.</p>
</dd>
<dt><code>outlierpar</code></dt><dd><p>A list containing the parameters used for outlier
identification.</p>
</dd>
<dt><code>kmeans</code></dt><dd><p>A list containing the results of running the Clustexp()
function.</p>
</dd>
<dt><code>MBclusters</code></dt><dd><p>A vector containing the final clustering partition
computed by Model-based clustering.</p>
</dd>
<dt><code>kordering</code></dt><dd><p>A vector containing the Pseudo-time ordering based on
k-means clusters.</p>
</dd>
<dt><code>MBordering</code></dt><dd><p>A vector containing the Pseudo-time ordering based on
Model-based clusters.</p>
</dd>
<dt><code>MBtsne</code></dt><dd><p>A data.frame with coordinates of two-dimensional tsne
layout for the Model-based clustering.</p>
</dd>
<dt><code>noiseF</code></dt><dd><p>A vector containing the gene list resulted from running the
noise filtering.</p>
</dd>
<dt><code>FinalGeneList</code></dt><dd><p>A vector containing the final gene list resulted
from running the noise filtering or/and the expression filtering.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>class(valuesG1msTest)
G1_reclassified &lt;- DISCBIO(valuesG1msTest)
class(G1_reclassified)
str(G1_reclassified, max.level = 2)
identical(G1_reclassified@expdataAll, valuesG1msTest)
</code></pre>

<hr>
<h2 id='DISCBIO2SingleCellExperiment'>Convert a DISCBIO object to a SingleCellExperiment.</h2><span id='topic+DISCBIO2SingleCellExperiment'></span>

<h3>Description</h3>

<p>Extract the SingleCellExperiment input data from the corresponding input slot
in a DISCBIO-class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DISCBIO2SingleCellExperiment(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DISCBIO2SingleCellExperiment_+3A_x">x</code></td>
<td>
<p>an object of class DISCBIO</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SingleCellExperiment-class object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1_disc &lt;- DISCBIO(valuesG1msTest)
class(g1_disc)
g1_sce &lt;- DISCBIO2SingleCellExperiment(g1_disc)
class(g1_sce)

</code></pre>

<hr>
<h2 id='Exprmclust'>Performing Model-based clustering on expression values</h2><span id='topic+Exprmclust'></span><span id='topic+Exprmclust+2CDISCBIO-method'></span><span id='topic+Exprmclust+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>this function first uses principal component analysis (PCA) to
reduce dimensionality of original data. It then performs model-based
clustering on the transformed expression values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Exprmclust(
  object,
  K = 3,
  modelNames = "VVV",
  reduce = TRUE,
  cluster = NULL,
  quiet = FALSE
)

## S4 method for signature 'DISCBIO'
Exprmclust(
  object,
  K = 3,
  modelNames = "VVV",
  reduce = TRUE,
  cluster = NULL,
  quiet = FALSE
)

## S4 method for signature 'data.frame'
Exprmclust(
  object,
  K = 3,
  modelNames = "VVV",
  reduce = TRUE,
  cluster = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exprmclust_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="Exprmclust_+3A_k">K</code></td>
<td>
<p>An integer vector specifying all possible cluster numbers. Default
is 3.</p>
</td></tr>
<tr><td><code id="Exprmclust_+3A_modelnames">modelNames</code></td>
<td>
<p>model to be used in model-based clustering. By default
&quot;ellipsoidal, varying volume, shape, and orientation&quot; is used.</p>
</td></tr>
<tr><td><code id="Exprmclust_+3A_reduce">reduce</code></td>
<td>
<p>A logical vector that allows performing the PCA on the
expression data. Default is TRUE.</p>
</td></tr>
<tr><td><code id="Exprmclust_+3A_cluster">cluster</code></td>
<td>
<p>A vector showing the ID of cells in the clusters.</p>
</td></tr>
<tr><td><code id="Exprmclust_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', suppresses intermediary output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'object' is of class DISCBIO, the output is the same object  with
the MBclusters slot filled. If the 'object' is a data frame, the function
returns a named list containing the four objects that together correspond
to the contents of the MBclusters slot.
</p>

<hr>
<h2 id='FinalPreprocessing'>Final Preprocessing</h2><span id='topic+FinalPreprocessing'></span><span id='topic+FinalPreprocessing+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This function generates the final filtered normalized dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FinalPreprocessing(
  object,
  GeneFlitering = "NoiseF",
  export = FALSE,
  quiet = FALSE,
  fileName = "filteredDataset"
)

## S4 method for signature 'DISCBIO'
FinalPreprocessing(
  object,
  GeneFlitering = "NoiseF",
  export = FALSE,
  quiet = FALSE,
  fileName = "filteredDataset"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FinalPreprocessing_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="FinalPreprocessing_+3A_geneflitering">GeneFlitering</code></td>
<td>
<p>GeneFlitering has to be one of the followings:
[&quot;NoiseF&quot;,&quot;ExpF&quot;]. Default is &quot;NoiseF&quot;</p>
</td></tr>
<tr><td><code id="FinalPreprocessing_+3A_export">export</code></td>
<td>
<p>A logical vector that allows writing the final gene list in
excel file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="FinalPreprocessing_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', intermediary output is suppressed</p>
</td></tr>
<tr><td><code id="FinalPreprocessing_+3A_filename">fileName</code></td>
<td>
<p>File name for exporting (if 'export = TRUE')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DISCBIO-class object input with the FinalGeneList slot filled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#sc &lt;- DISCBIO(valuesG1msTest)
#sc &lt;- NoiseFiltering(sc, percentile = 0.9, CV = 0.2, export = FALSE)
#sc &lt;- FinalPreprocessing(sc, GeneFlitering = "NoiseF", export = FALSE)

</code></pre>

<hr>
<h2 id='FindOutliers'>Inference of outlier cells</h2><span id='topic+FindOutliers'></span><span id='topic+FindOutliers+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This functions performs the outlier identification for k-means
and model-based clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindOutliers(
  object,
  K,
  outminc = 5,
  outlg = 2,
  probthr = 0.001,
  thr = 2^-(1:40),
  outdistquant = 0.75,
  plot = TRUE,
  quiet = FALSE
)

## S4 method for signature 'DISCBIO'
FindOutliers(
  object,
  K,
  outminc = 5,
  outlg = 2,
  probthr = 0.001,
  thr = 2^-(1:40),
  outdistquant = 0.75,
  plot = TRUE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindOutliers_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="FindOutliers_+3A_k">K</code></td>
<td>
<p>Number of clusters to be used.</p>
</td></tr>
<tr><td><code id="FindOutliers_+3A_outminc">outminc</code></td>
<td>
<p>minimal transcript count of a gene in a clusters to be tested
for being an outlier gene. Default is 5.</p>
</td></tr>
<tr><td><code id="FindOutliers_+3A_outlg">outlg</code></td>
<td>
<p>Minimum number of outlier genes required for being an outlier
cell. Default is 2.</p>
</td></tr>
<tr><td><code id="FindOutliers_+3A_probthr">probthr</code></td>
<td>
<p>outlier probability threshold for a minimum of <code>outlg</code>
genes to be an outlier cell. This probability is computed from a negative
binomial background model of expression in a cluster. Default is 0.001.</p>
</td></tr>
<tr><td><code id="FindOutliers_+3A_thr">thr</code></td>
<td>
<p>probability values for which the number of outliers is computed in
order to plot the dependence of the number of outliers on the probability
threshold. Default is 2**-(1:40).set</p>
</td></tr>
<tr><td><code id="FindOutliers_+3A_outdistquant">outdistquant</code></td>
<td>
<p>Real number between zero and one. Outlier cells are
merged to outlier clusters if their distance smaller than the
outdistquant-quantile of the distance distribution of  pairs of cells in
the orginal clusters after outlier removal. Default is 0.75.</p>
</td></tr>
<tr><td><code id="FindOutliers_+3A_plot">plot</code></td>
<td>
<p>if 'TRUE', produces a plot of -log10prob per K</p>
</td></tr>
<tr><td><code id="FindOutliers_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', intermediary output is suppressed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of the genes containing outlying cells and the number
of cells on each.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- DISCBIO(valuesG1msTest)
sc &lt;- Clustexp(sc, cln = 2) # K-means clustering
FindOutliers(sc, K = 2)

</code></pre>

<hr>
<h2 id='foldchange.seq.twoclass.unpaired'>Foldchange of twoclass unpaired sequencing data</h2><span id='topic+foldchange.seq.twoclass.unpaired'></span>

<h3>Description</h3>

<p>Foldchange of twoclass unpaired sequencing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foldchange.seq.twoclass.unpaired(x, y, depth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foldchange.seq.twoclass.unpaired_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="foldchange.seq.twoclass.unpaired_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="foldchange.seq.twoclass.unpaired_+3A_depth">depth</code></td>
<td>
<p>depth</p>
</td></tr>
</table>

<hr>
<h2 id='HumanMouseGeneIds'>Human and Mouse Gene Identifiers.</h2><span id='topic+HumanMouseGeneIds'></span>

<h3>Description</h3>

<p>Data.frame including ENTREZID, SYMBOL, and ENSEMBL gene identifiers
of human and mouse genes.
</p>


<h3>Source</h3>

<p>Data were imported, modified, and formatted from the
Mus.musculus (ver 1.3.1) and the Homo.sapiens (ver 1.3.1)
BioConductor libraries.
</p>

<hr>
<h2 id='J48DT'>J48 Decision Tree</h2><span id='topic+J48DT'></span>

<h3>Description</h3>

<p>The decision tree analysis is implemented over a training
dataset, which consisted of the DEGs obtained by either SAMseq or the
binomial differential expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>J48DT(data, quiet = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="J48DT_+3A_data">data</code></td>
<td>
<p>A data frame resulted from running the function ClassVectoringDT.</p>
</td></tr>
<tr><td><code id="J48DT_+3A_quiet">quiet</code></td>
<td>
<p>If 'TRUE', suppresses intermediary output</p>
</td></tr>
<tr><td><code id="J48DT_+3A_plot">plot</code></td>
<td>
<p>If 'FALSE', suppresses plot output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information about the J48 model and, by default, a plot of the
decision tree.
</p>

<hr>
<h2 id='J48DTeval'>Evaluating the performance of the J48 decision tree.</h2><span id='topic+J48DTeval'></span>

<h3>Description</h3>

<p>This function evaluates the performance of the generated trees
for error estimation by ten-fold cross validation assessment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>J48DTeval(data, num.folds = 10, First = "CL1", Second = "CL2", quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="J48DTeval_+3A_data">data</code></td>
<td>
<p>The resulted data from running the function J48DT.</p>
</td></tr>
<tr><td><code id="J48DTeval_+3A_num.folds">num.folds</code></td>
<td>
<p>A numeric value of the number of folds for the cross
validation assessment. Default is 10.</p>
</td></tr>
<tr><td><code id="J48DTeval_+3A_first">First</code></td>
<td>
<p>A string vector showing the first target cluster.  Default is
&quot;CL1&quot;</p>
</td></tr>
<tr><td><code id="J48DTeval_+3A_second">Second</code></td>
<td>
<p>A string vector showing the second target cluster.  Default is
&quot;CL2&quot;</p>
</td></tr>
<tr><td><code id="J48DTeval_+3A_quiet">quiet</code></td>
<td>
<p>If 'TRUE', suppresses intermediary output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Statistics about the J48 model
</p>

<hr>
<h2 id='Jaccard'>Jaccard’s similarity</h2><span id='topic+Jaccard'></span>

<h3>Description</h3>

<p>Robustness of the clusters can be assessed by Jaccard’s
similarity, which reflects the reproducibility of individual clusters
across bootstrapping runs. Jaccard’s similarity is the intersect of two
clusters divided by the union.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jaccard(object, Clustering = "K-means", K, plot = TRUE, R = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jaccard_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="Jaccard_+3A_clustering">Clustering</code></td>
<td>
<p>Clustering has to be one of the following:
[&quot;K-means&quot;,&quot;MB&quot;]. Default is &quot;K-means&quot;</p>
</td></tr>
<tr><td><code id="Jaccard_+3A_k">K</code></td>
<td>
<p>A numeric value of the number of clusters</p>
</td></tr>
<tr><td><code id="Jaccard_+3A_plot">plot</code></td>
<td>
<p>if 'TRUE', plots the mean Jaccard similarities</p>
</td></tr>
<tr><td><code id="Jaccard_+3A_r">R</code></td>
<td>
<p>number of bootstrap replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the mean Jaccard similarity coefficient per cluster.
</p>

<hr>
<h2 id='KmeanOrder'>Pseudo-time ordering based on k-means clusters</h2><span id='topic+KmeanOrder'></span><span id='topic+KmeanOrder+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This function takes the exact output of exprmclust function and
construct Pseudo-time ordering by mapping all cells onto the path that
connects cluster centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KmeanOrder(
  object,
  quiet = FALSE,
  export = FALSE,
  filename = "Cellular_pseudo-time_ordering_based_on_k-meansc-lusters"
)

## S4 method for signature 'DISCBIO'
KmeanOrder(
  object,
  quiet = FALSE,
  export = FALSE,
  filename = "Cellular_pseudo-time_ordering_based_on_k-meansc-lusters"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KmeanOrder_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="KmeanOrder_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', suppresses intermediary output</p>
</td></tr>
<tr><td><code id="KmeanOrder_+3A_export">export</code></td>
<td>
<p>if 'TRUE', exports order table to csv</p>
</td></tr>
<tr><td><code id="KmeanOrder_+3A_filename">filename</code></td>
<td>
<p>Name of the exported file (if 'export=TRUE')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DISCBIO-class object input with the kordering slot filled.
</p>


<h3>Note</h3>

<p>This function has been replaced by pseudoTimeOrdering(), but it is
being kept for legacy purposes. It will, however, be removed from future
versions of DIscBIO.
</p>

<hr>
<h2 id='NetAnalysis'>Networking analysis.</h2><span id='topic+NetAnalysis'></span>

<h3>Description</h3>

<p>This function checks the connectivity degree and the betweenness
centrality, which reflect the communication flow in the defined PPI
networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetAnalysis(data, export = FALSE, FileName = "NetworkAnalysisTable-1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetAnalysis_+3A_data">data</code></td>
<td>
<p>Protein-protein interaction data frame resulted from running the
PPI function.</p>
</td></tr>
<tr><td><code id="NetAnalysis_+3A_export">export</code></td>
<td>
<p>if 'TRUE', exports the analysis table as a csv file</p>
</td></tr>
<tr><td><code id="NetAnalysis_+3A_filename">FileName</code></td>
<td>
<p>suffix for the file name (if export = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network analysis table
</p>

<hr>
<h2 id='Networking'>Plotting the network.</h2><span id='topic+Networking'></span>

<h3>Description</h3>

<p>This function uses STRING API to plot the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Networking(
  data,
  FileName = NULL,
  species = "9606",
  plot_width = 25,
  plot_height = 15,
  retries = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Networking_+3A_data">data</code></td>
<td>
<p>A gene list.</p>
</td></tr>
<tr><td><code id="Networking_+3A_filename">FileName</code></td>
<td>
<p>A string vector showing the name to be used to save the
resulted network. If 'NULL', the network will be saved to a temporary
directory</p>
</td></tr>
<tr><td><code id="Networking_+3A_species">species</code></td>
<td>
<p>The taxonomy name/id. Default is &quot;9606&quot; for Homo sapiens.</p>
</td></tr>
<tr><td><code id="Networking_+3A_plot_width">plot_width</code></td>
<td>
<p>Plot width</p>
</td></tr>
<tr><td><code id="Networking_+3A_plot_height">plot_height</code></td>
<td>
<p>Plot height</p>
</td></tr>
<tr><td><code id="Networking_+3A_retries">retries</code></td>
<td>
<p>maximum number of attempts to connect to the STRING api.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the network
</p>


<h3>References</h3>

<p>https://string-db.org/api/
</p>

<hr>
<h2 id='NoiseFiltering'>Noise Filtering</h2><span id='topic+NoiseFiltering'></span><span id='topic+NoiseFiltering+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>Given a matrix or data frame of count data, this function
estimates the size factors as follows: Each column is divided by the
geometric means of the rows. The median (or, if requested, another location
estimator) of these ratios (skipping the genes with a # geometric mean of
zero) is used as the size factor for this column. Source: DESeq package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NoiseFiltering(
  object,
  percentile = 0.8,
  CV = 0.3,
  geneCol = "yellow",
  FgeneCol = "black",
  erccCol = "blue",
  Val = TRUE,
  plot = TRUE,
  export = FALSE,
  quiet = FALSE,
  filename = "Noise_filtering_genes_test"
)

## S4 method for signature 'DISCBIO'
NoiseFiltering(
  object,
  percentile = 0.8,
  CV = 0.3,
  geneCol = "yellow",
  FgeneCol = "black",
  erccCol = "blue",
  Val = TRUE,
  plot = TRUE,
  export = FALSE,
  quiet = FALSE,
  filename = "Noise_filtering_genes_test"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NoiseFiltering_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="NoiseFiltering_+3A_percentile">percentile</code></td>
<td>
<p>A numeric value of the percentile. It is used to validate
the ERCC spik-ins. Default is 0.8.</p>
</td></tr>
<tr><td><code id="NoiseFiltering_+3A_cv">CV</code></td>
<td>
<p>A numeric value of the coefficient of variation. It is used to
validate the ERCC spik-ins. Default is 0.5.</p>
</td></tr>
<tr><td><code id="NoiseFiltering_+3A_genecol">geneCol</code></td>
<td>
<p>Color of the genes that did not pass the filtration.</p>
</td></tr>
<tr><td><code id="NoiseFiltering_+3A_fgenecol">FgeneCol</code></td>
<td>
<p>Color of the genes that passt the filtration.</p>
</td></tr>
<tr><td><code id="NoiseFiltering_+3A_ercccol">erccCol</code></td>
<td>
<p>Color of the ERCC spik-ins.</p>
</td></tr>
<tr><td><code id="NoiseFiltering_+3A_val">Val</code></td>
<td>
<p>A logical vector that allows plotting only the validated ERCC
spike-ins. Default is TRUE. If Val=FALSE will plot all the ERCC spike-ins.</p>
</td></tr>
<tr><td><code id="NoiseFiltering_+3A_plot">plot</code></td>
<td>
<p>A logical vector that allows plotting the technical noise.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="NoiseFiltering_+3A_export">export</code></td>
<td>
<p>A logical vector that allows writing the final gene list in
excel file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="NoiseFiltering_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', suppresses printed output</p>
</td></tr>
<tr><td><code id="NoiseFiltering_+3A_filename">filename</code></td>
<td>
<p>Name of the exported file (if 'export=TRUE')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DISCBIO-class object input with the noiseF slot filled.
</p>


<h3>Note</h3>

<p>This function should be used only if the dataset has ERCC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- DISCBIO(valuesG1msTest) # changes signature of data
sd_filtered &lt;- NoiseFiltering(sc, export = FALSE)
str(sd_filtered)

</code></pre>

<hr>
<h2 id='Normalizedata'>Normalizing and filtering</h2><span id='topic+Normalizedata'></span><span id='topic+Normalizedata+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This function allows filtering of genes and cells to be used in
the downstream analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normalizedata(
  object,
  mintotal = 1000,
  minexpr = 0,
  minnumber = 0,
  maxexpr = Inf,
  downsample = FALSE,
  dsn = 1,
  rseed = NULL
)

## S4 method for signature 'DISCBIO'
Normalizedata(
  object,
  mintotal = 1000,
  minexpr = 0,
  minnumber = 0,
  maxexpr = Inf,
  downsample = FALSE,
  dsn = 1,
  rseed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalizedata_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="Normalizedata_+3A_mintotal">mintotal</code></td>
<td>
<p>minimum total transcript number required. Cells with less
than <code>mintotal</code> transcripts are filtered out. Default is 1000.</p>
</td></tr>
<tr><td><code id="Normalizedata_+3A_minexpr">minexpr</code></td>
<td>
<p>minimum required transcript count of a gene in at least
<code>minnumber</code> cells. All other genes are filtered out. Default is 0.</p>
</td></tr>
<tr><td><code id="Normalizedata_+3A_minnumber">minnumber</code></td>
<td>
<p>minimum number of cells that are expressing each gene at
minexpr transcripts. Default is 0.</p>
</td></tr>
<tr><td><code id="Normalizedata_+3A_maxexpr">maxexpr</code></td>
<td>
<p>maximum allowed transcript count of a gene in at least a
single cell after normalization or downsampling. All other genes are
filtered out. Default is Inf.</p>
</td></tr>
<tr><td><code id="Normalizedata_+3A_downsample">downsample</code></td>
<td>
<p>A logical vector. Default is FALSE. If downsample is set to
TRUE, then transcript counts are downsampled to mintotal transcripts per
cell, instead of the normalization. Downsampled versions of the transcript
count data are averaged across dsn samples</p>
</td></tr>
<tr><td><code id="Normalizedata_+3A_dsn">dsn</code></td>
<td>
<p>A numeric value of the number of samples to be used to average the
downsampled versions of the transcript count data. Default is 1 which means
that sampling noise should be comparable across cells. For high numbers of
dsn the data will become similar to the median normalization.</p>
</td></tr>
<tr><td><code id="Normalizedata_+3A_rseed">rseed</code></td>
<td>
<p>Random integer to enforce reproducible clustering.
results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DISCBIO-class object input with the ndata and fdata slots filled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- DISCBIO(valuesG1msTest) # changes signature of data

# In this case this function is used to normalize the reads
sc_normal &lt;- Normalizedata(
  sc,
  mintotal = 1000, minexpr = 0, minnumber = 0, maxexpr = Inf,
  downsample = FALSE, dsn = 1, rseed = 17000
)
summary(sc_normal@fdata)

</code></pre>

<hr>
<h2 id='PCAplotSymbols'>Plot PCA symbols</h2><span id='topic+PCAplotSymbols'></span><span id='topic+PCAplotSymbols+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>Generates a plot of grouped PCA components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCAplotSymbols(object, types = NULL)

## S4 method for signature 'DISCBIO'
PCAplotSymbols(object, types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCAplotSymbols_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="PCAplotSymbols_+3A_types">types</code></td>
<td>
<p>If types=NULL then the names of the cells will be grouped
automatically. Default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the Principal Components
</p>

<hr>
<h2 id='plotExptSNE'>Highlighting gene expression in the t-SNE map</h2><span id='topic+plotExptSNE'></span><span id='topic+plotExptSNE+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>The t-SNE map representation can also be used to analyze
expression of a gene or a group of genes, to investigate cluster specific
gene expression patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotExptSNE(object, g, n = NULL)

## S4 method for signature 'DISCBIO'
plotExptSNE(object, g, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotExptSNE_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="plotExptSNE_+3A_g">g</code></td>
<td>
<p>Individual gene name or vector with a group of gene names
corresponding to a subset of valid row names of the <code>ndata</code> slot of
the <code>DISCBIO</code> object.</p>
</td></tr>
<tr><td><code id="plotExptSNE_+3A_n">n</code></td>
<td>
<p>String of characters representing the title of the plot. Default is
NULL and the first element of <code>g</code> is chosen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>t-SNE plot for one particular gene
</p>

<hr>
<h2 id='plotGap'>Plotting Gap Statistics</h2><span id='topic+plotGap'></span><span id='topic+plotGap+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>Plotting Gap Statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGap(object, y_limits = NULL)

## S4 method for signature 'DISCBIO'
plotGap(object, y_limits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGap_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="plotGap_+3A_y_limits">y_limits</code></td>
<td>
<p>2-length numeric vector with the limits for the gap plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the gap statistics
</p>

<hr>
<h2 id='plotLabelstSNE'>tSNE map with labels</h2><span id='topic+plotLabelstSNE'></span><span id='topic+plotLabelstSNE+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>Visualizing k-means or model-based clusters using tSNE maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLabelstSNE(object)

## S4 method for signature 'DISCBIO'
plotLabelstSNE(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLabelstSNE_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot containing the ID of the cells in each cluster
</p>

<hr>
<h2 id='PlotMBpca'>Plotting pseudo-time ordering or gene expression in Model-based
clustering in PCA</h2><span id='topic+PlotMBpca'></span>

<h3>Description</h3>

<p>The PCA representation can either be used to show pseudo-time
ordering or the gene expression of a particular gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotMBpca(object, type = "order", g = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotMBpca_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="PlotMBpca_+3A_type">type</code></td>
<td>
<p>either 'order' to plot pseudo-time ordering or 'exp' to plot gene
expression</p>
</td></tr>
<tr><td><code id="PlotMBpca_+3A_g">g</code></td>
<td>
<p>Individual gene name or vector with a group of gene names
corresponding to a subset of valid row names of the <code>ndata</code> slot of
the <code>DISCBIO</code> object. Ignored if 'type=&quot;order&quot;'.</p>
</td></tr>
<tr><td><code id="PlotMBpca_+3A_n">n</code></td>
<td>
<p>String of characters representing the title of the plot. Default is
NULL and the first element of <code>g</code> is chosen. Ignored if
'type=&quot;order&quot;'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the PCA.
</p>

<hr>
<h2 id='PlotmclustMB'>Plotting the Model-based clusters in PCA.</h2><span id='topic+PlotmclustMB'></span><span id='topic+PlotmclustMB+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>Plot the model-based clustering results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotmclustMB(object)

## S4 method for signature 'DISCBIO'
PlotmclustMB(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotmclustMB_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the PCA.
</p>

<hr>
<h2 id='plotOrderTsne'>Plotting the pseudo-time ordering in the t-SNE map</h2><span id='topic+plotOrderTsne'></span><span id='topic+plotOrderTsne+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>The tSNE representation can also be used to show the pseudo-time
ordering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOrderTsne(object)

## S4 method for signature 'DISCBIO'
plotOrderTsne(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotOrderTsne_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the pseudo-time ordering.
</p>

<hr>
<h2 id='plotSilhouette'>Silhouette Plot for K-means clustering</h2><span id='topic+plotSilhouette'></span><span id='topic+plotSilhouette+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>The silhouette provides a representation of how well each point
is represented by its cluster in comparison to the closest neighboring
cluster. It computes for each point the difference between the average
similarity to all points in the same cluster and to all points in the
closest neighboring cluster. This difference it normalize such that it can
take values between -1 and 1 with higher values reflecting better
representation of a point by its cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSilhouette(object, K)

## S4 method for signature 'DISCBIO'
plotSilhouette(object, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSilhouette_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="plotSilhouette_+3A_k">K</code></td>
<td>
<p>A numeric value of the number of clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A silhouette plot
</p>

<hr>
<h2 id='plotSymbolstSNE'>tSNE map for K-means clustering with symbols</h2><span id='topic+plotSymbolstSNE'></span><span id='topic+plotSymbolstSNE+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>Visualizing the K-means clusters using tSNE maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSymbolstSNE(object, types = NULL, legloc = "bottomright")

## S4 method for signature 'DISCBIO'
plotSymbolstSNE(object, types = NULL, legloc = "bottomright")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSymbolstSNE_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="plotSymbolstSNE_+3A_types">types</code></td>
<td>
<p>If types=NULL then the names of the cells will be grouped
automatically. Default is NULL</p>
</td></tr>
<tr><td><code id="plotSymbolstSNE_+3A_legloc">legloc</code></td>
<td>
<p>A keyword from the list &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;,
&quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;. Default is
&quot;bottomright&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of tsne objet slot, grouped by gene.
</p>

<hr>
<h2 id='plottSNE'>tSNE map</h2><span id='topic+plottSNE'></span><span id='topic+plottSNE+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>Visualizing the k-means or model-based clusters using tSNE maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plottSNE(object)

## S4 method for signature 'DISCBIO'
plottSNE(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plottSNE_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of t-SNEs.
</p>

<hr>
<h2 id='PPI'>Defining protein-protein interactions (PPI) over a list of genes,</h2><span id='topic+PPI'></span>

<h3>Description</h3>

<p>This function uses STRING-api. The outcome of STRING analysis
will be stored in comma-separated values files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPI(data, FileName = NULL, species = "9606")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPI_+3A_data">data</code></td>
<td>
<p>A gene list.</p>
</td></tr>
<tr><td><code id="PPI_+3A_filename">FileName</code></td>
<td>
<p>A string vector showing the name to be used to save the
resulted table. If null, no file will be exported</p>
</td></tr>
<tr><td><code id="PPI_+3A_species">species</code></td>
<td>
<p>The taxonomy name/id. Default is &quot;9606&quot; for Homo sapiens.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either CSV files stored in the user's file system and its
corresponding 'data.frame' object in R or and R object containing that
information.
</p>

<hr>
<h2 id='prepExampleDataset'>Prepare Example Dataset</h2><span id='topic+prepExampleDataset'></span>

<h3>Description</h3>

<p>Internal function that prepares a pre-treated dataset for use in
several examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepExampleDataset(dataset, save = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepExampleDataset_+3A_dataset">dataset</code></td>
<td>
<p>Dataset used for transformation</p>
</td></tr>
<tr><td><code id="prepExampleDataset_+3A_save">save</code></td>
<td>
<p>save results?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves the purpose of treating datasets such as
valuesG1msReduced to reduce examples of other functions by bypassing some
analysis steps covered in the vignettes.
</p>


<h3>Value</h3>

<p>Two rda files, ones for K-means clustering and another for
Model-based clustering.
</p>


<h3>Author(s)</h3>

<p>Waldir Leoncio
</p>

<hr>
<h2 id='pseudoTimeOrdering'>Pseudo-time ordering</h2><span id='topic+pseudoTimeOrdering'></span><span id='topic+pseudoTimeOrdering+2CDISCBIO-method'></span>

<h3>Description</h3>

<p>This function takes the exact output of exprmclust function and
construct Pseudo-time ordering by mapping all cells onto the path that
connects cluster centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudoTimeOrdering(
  object,
  quiet = FALSE,
  export = FALSE,
  filename = "Cellular_pseudo-time_ordering"
)

## S4 method for signature 'DISCBIO'
pseudoTimeOrdering(
  object,
  quiet = FALSE,
  export = FALSE,
  filename = "Cellular_pseudo-time_ordering"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoTimeOrdering_+3A_object">object</code></td>
<td>
<p><code>DISCBIO</code> class object.</p>
</td></tr>
<tr><td><code id="pseudoTimeOrdering_+3A_quiet">quiet</code></td>
<td>
<p>if 'TRUE', suppresses intermediary output</p>
</td></tr>
<tr><td><code id="pseudoTimeOrdering_+3A_export">export</code></td>
<td>
<p>if 'TRUE', exports order table to csv</p>
</td></tr>
<tr><td><code id="pseudoTimeOrdering_+3A_filename">filename</code></td>
<td>
<p>Name of the exported file (if 'export=TRUE')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DISCBIO-class object input with the kordering slot filled.
</p>

<hr>
<h2 id='rankcols'>Rank columns</h2><span id='topic+rankcols'></span>

<h3>Description</h3>

<p>Ranks the elements within each col of the matrix x and returns
these ranks in a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankcols(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankcols_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
</table>


<h3>Note</h3>

<p>this function is equivalent to 'samr::rankcol', but uses 'apply' to
rank the colums instead of a compiled Fortran function which was causing our
DEGanalysis functions to freeze in large datasets.
</p>

<hr>
<h2 id='reformatSiggenes'>Reformat Siggenes Table</h2><span id='topic+reformatSiggenes'></span>

<h3>Description</h3>

<p>Reformats the Siggenes table output from the SAMR package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reformatSiggenes(table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reformatSiggenes_+3A_table">table</code></td>
<td>
<p>output from 'samr::samr.compute.siggenes.table'</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Waldir Leoncio
</p>


<h3>See Also</h3>

<p>replaceDecimals
</p>

<hr>
<h2 id='replaceDecimals'>Replace Decimals</h2><span id='topic+replaceDecimals'></span>

<h3>Description</h3>

<p>Replaces decimals separators between comma and periods on a
character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceDecimals(x, from = ",", to = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceDecimals_+3A_x">x</code></td>
<td>
<p>vector of characters</p>
</td></tr>
<tr><td><code id="replaceDecimals_+3A_from">from</code></td>
<td>
<p>decimal separator on input file</p>
</td></tr>
<tr><td><code id="replaceDecimals_+3A_to">to</code></td>
<td>
<p>decimal separator for output file</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was especially designed to be used with retormatSiggenes
</p>


<h3>See Also</h3>

<p>reformatSiggenes
</p>

<hr>
<h2 id='resa'>Resampling</h2><span id='topic+resa'></span>

<h3>Description</h3>

<p>Corresponds to 'samr::resample'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resa(x, d, nresamp = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resa_+3A_x">x</code></td>
<td>
<p>data matrix. nrow=#gene, ncol=#sample</p>
</td></tr>
<tr><td><code id="resa_+3A_d">d</code></td>
<td>
<p>estimated sequencing depth</p>
</td></tr>
<tr><td><code id="resa_+3A_nresamp">nresamp</code></td>
<td>
<p>number of resamplings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xresamp: an rank array with dim #gene*#sample*nresamp
</p>

<hr>
<h2 id='retrieveURL'>Retries a URL</h2><span id='topic+retrieveURL'></span>

<h3>Description</h3>

<p>Retries a URL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieveURL(data, species, outputFormat, maxRetries = 3, successCode = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrieveURL_+3A_data">data</code></td>
<td>
<p>A gene list</p>
</td></tr>
<tr><td><code id="retrieveURL_+3A_species">species</code></td>
<td>
<p>The taxonomy name/id. Default is &quot;9606&quot; for Homo sapiens</p>
</td></tr>
<tr><td><code id="retrieveURL_+3A_outputformat">outputFormat</code></td>
<td>
<p>format of the output. Can be &quot;highres_image&quot;, &quot;tsv&quot;,
&quot;json&quot;, &quot;tsv-no-header&quot;, &quot;xml&quot;</p>
</td></tr>
<tr><td><code id="retrieveURL_+3A_maxretries">maxRetries</code></td>
<td>
<p>maximum number of attempts to connect to the STRING api.</p>
</td></tr>
<tr><td><code id="retrieveURL_+3A_successcode">successCode</code></td>
<td>
<p>Status code number that represents success</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either the output of httr::GET or an error message
</p>


<h3>Author(s)</h3>

<p>Waldir Leoncio
</p>

<hr>
<h2 id='RpartDT'>RPART Decision Tree</h2><span id='topic+RpartDT'></span>

<h3>Description</h3>

<p>The decision tree analysis is implemented over a training
dataset, which consisted of the DEGs obtained by either SAMseq or the
binomial differential expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RpartDT(data, quiet = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RpartDT_+3A_data">data</code></td>
<td>
<p>The exact output of the exprmclust function.</p>
</td></tr>
<tr><td><code id="RpartDT_+3A_quiet">quiet</code></td>
<td>
<p>If 'TRUE', suppresses intermediary output</p>
</td></tr>
<tr><td><code id="RpartDT_+3A_plot">plot</code></td>
<td>
<p>If 'FALSE', suppresses plot output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information about the model and, by default, a plot of the decision
tree.
</p>

<hr>
<h2 id='RpartEVAL'>Evaluating the performance of the RPART Decision Tree.</h2><span id='topic+RpartEVAL'></span>

<h3>Description</h3>

<p>This function evaluates the performance of the generated trees
for error estimation by ten-fold cross validation assessment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RpartEVAL(data, num.folds = 10, First = "CL1", Second = "CL2", quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RpartEVAL_+3A_data">data</code></td>
<td>
<p>The resulted data from running the function J48DT.</p>
</td></tr>
<tr><td><code id="RpartEVAL_+3A_num.folds">num.folds</code></td>
<td>
<p>A numeric value of the number of folds for the cross
validation assessment. Default is 10.</p>
</td></tr>
<tr><td><code id="RpartEVAL_+3A_first">First</code></td>
<td>
<p>A string vector showing the first target cluster.  Default is
&quot;CL1&quot;</p>
</td></tr>
<tr><td><code id="RpartEVAL_+3A_second">Second</code></td>
<td>
<p>A string vector showing the second target cluster.  Default is
&quot;CL2&quot;</p>
</td></tr>
<tr><td><code id="RpartEVAL_+3A_quiet">quiet</code></td>
<td>
<p>If 'TRUE', suppresses intermediary output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Performance statistics of the model
</p>

<hr>
<h2 id='sammy'>Significance analysis of microarrays</h2><span id='topic+sammy'></span>

<h3>Description</h3>

<p>This function is an adaptation of 'samr::samr'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sammy(
  data,
  resp.type = c("Quantitative", "Two class unpaired", "Survival", "Multiclass",
    "One class", "Two class paired", "Two class unpaired timecourse",
    "One class timecourse", "Two class paired timecourse", "Pattern discovery"),
  assay.type = c("array", "seq"),
  s0 = NULL,
  s0.perc = NULL,
  nperms = 100,
  center.arrays = FALSE,
  testStatistic = c("standard", "wilcoxon"),
  time.summary.type = c("slope", "signed.area"),
  regression.method = c("standard", "ranks"),
  return.x = FALSE,
  knn.neighbors = 10,
  random.seed = NULL,
  nresamp = 20,
  nresamp.perm = NULL,
  xl.mode = c("regular", "firsttime", "next20", "lasttime"),
  xl.time = NULL,
  xl.prevfit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sammy_+3A_data">data</code></td>
<td>
<p>Data object with components x- p by n matrix of features, one
observation per column (missing values allowed); y- n-vector of outcome
measurements; censoring.status- n-vector of censoring censoring.status
(1= died or event occurred, 0=survived, or event was censored), needed for a
censored survival outcome</p>
</td></tr>
<tr><td><code id="sammy_+3A_resp.type">resp.type</code></td>
<td>
<p>Problem type: &quot;Quantitative&quot; for a continuous parameter
(Available for both array and sequencing data); &quot;Two class unpaired&quot; (for
both array and sequencing data); &quot;Survival&quot; for censored survival outcome
(for both array and sequencingdata); &quot;Multiclass&quot;: more than 2 groups (for
both array and sequencing data); &quot;One class&quot; for a single group (only for
array data); &quot;Two class paired&quot; for two classes with paired observations
(for both array and sequencing data); &quot;Two class unpaired timecourse&quot; (only
for array data), &quot;One class time course&quot; (only for array data),
&quot;Two class.paired timecourse&quot; (only for array data), or &quot;Pattern discovery&quot;
(only for array data)</p>
</td></tr>
<tr><td><code id="sammy_+3A_assay.type">assay.type</code></td>
<td>
<p>Assay type: &quot;array&quot; for microarray data, &quot;seq&quot; for counts
from sequencing</p>
</td></tr>
<tr><td><code id="sammy_+3A_s0">s0</code></td>
<td>
<p>Exchangeability factor for denominator of test statistic; Default
is automatic choice. Only used for array data.</p>
</td></tr>
<tr><td><code id="sammy_+3A_s0.perc">s0.perc</code></td>
<td>
<p>Percentile of standard deviation values to use for s0; default
is automatic choice; -1 means s0=0 (different from s0.perc=0, meaning
s0=zeroeth percentile of standard deviation values= min of sd values.
Only used for array data.</p>
</td></tr>
<tr><td><code id="sammy_+3A_nperms">nperms</code></td>
<td>
<p>Number of permutations used to estimate false discovery rates</p>
</td></tr>
<tr><td><code id="sammy_+3A_center.arrays">center.arrays</code></td>
<td>
<p>Should the data for each sample (array) be median
centered at the outset? Default =FALSE. Only used for array data.</p>
</td></tr>
<tr><td><code id="sammy_+3A_teststatistic">testStatistic</code></td>
<td>
<p>Test statistic to use in two class unpaired case.Either
&quot;standard&quot; (t-statistic) or ,&quot;wilcoxon&quot; (Two-sample wilcoxon or Mann-Whitney
test). Only used for array data.</p>
</td></tr>
<tr><td><code id="sammy_+3A_time.summary.type">time.summary.type</code></td>
<td>
<p>Summary measure for each time course: &quot;slope&quot;, or
&quot;signed.area&quot;). Only used for array data.</p>
</td></tr>
<tr><td><code id="sammy_+3A_regression.method">regression.method</code></td>
<td>
<p>Regression method for quantitative case: &quot;standard&quot;,
(linear least squares) or &quot;ranks&quot; (linear least squares on ranked data).
Only used for array data.</p>
</td></tr>
<tr><td><code id="sammy_+3A_return.x">return.x</code></td>
<td>
<p>Should the matrix of feature values be returned? Only useful
for time course data, where x contains summaries of the features over time.
Otherwise x is the same as the input data</p>
</td></tr>
<tr><td><code id="sammy_+3A_knn.neighbors">knn.neighbors</code></td>
<td>
<p>Number of nearest neighbors to use for imputation of
missing features values. Only used for array data.</p>
</td></tr>
<tr><td><code id="sammy_+3A_random.seed">random.seed</code></td>
<td>
<p>Optional initial seed for random number generator
(integer)</p>
</td></tr>
<tr><td><code id="sammy_+3A_nresamp">nresamp</code></td>
<td>
<p>For assay.type=&quot;seq&quot;, number of resamples used to construct
test statistic. Default 20. Only used for sequencing data.</p>
</td></tr>
<tr><td><code id="sammy_+3A_nresamp.perm">nresamp.perm</code></td>
<td>
<p>For assay.type=&quot;seq&quot;, number of resamples used to
construct test statistic for permutations. Default is equal to nresamp and it
must be at most nresamp. Only used for sequencing data.</p>
</td></tr>
<tr><td><code id="sammy_+3A_xl.mode">xl.mode</code></td>
<td>
<p>Used by Excel interface</p>
</td></tr>
<tr><td><code id="sammy_+3A_xl.time">xl.time</code></td>
<td>
<p>Used by Excel interface</p>
</td></tr>
<tr><td><code id="sammy_+3A_xl.prevfit">xl.prevfit</code></td>
<td>
<p>Used by Excel interface</p>
</td></tr>
</table>

<hr>
<h2 id='samr.estimate.depth'>Estimate sequencing depths</h2><span id='topic+samr.estimate.depth'></span>

<h3>Description</h3>

<p>Estimate sequencing depths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr.estimate.depth(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.estimate.depth_+3A_x">x</code></td>
<td>
<p>data matrix. nrow=#gene, ncol=#sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>depth: estimated sequencing depth. a vector with len sample.
</p>

<hr>
<h2 id='valuesG1msTest'>Single-cells data from a myxoid liposarcoma cell line</h2><span id='topic+valuesG1msTest'></span>

<h3>Description</h3>

<p>A sample of single cells from a myxoid liposarcoma cell
line. Columns refer to samples and rows refer to genes. The last rows
refer to external RNA controls consortium (ERCC) spike-ins. This dataset is
part of a larger dataset containing 94 single cells. The complete dataset
is fully compatible with this package and an rda file can be obtained at
https://github.com/ocbe-uio/DIscBIO/blob/dev/data/valuesG1ms.rda
</p>

<hr>
<h2 id='VolcanoPlot'>Volcano Plot</h2><span id='topic+VolcanoPlot'></span>

<h3>Description</h3>

<p>Plotting differentially expressed genes (DEGs) in a particular
cluster. Volcano plots are used to readily show the DEGs by plotting
significance versus fold-change on the y and x axes, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VolcanoPlot(object, value = 0.05, name = NULL, fc = 0.5, FS = 0.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VolcanoPlot_+3A_object">object</code></td>
<td>
<p>A data frame showing the differentially expressed genes (DEGs)
in a particular cluster</p>
</td></tr>
<tr><td><code id="VolcanoPlot_+3A_value">value</code></td>
<td>
<p>A numeric value of the false discovery rate. Default is 0.05..
Default is 0.05</p>
</td></tr>
<tr><td><code id="VolcanoPlot_+3A_name">name</code></td>
<td>
<p>A string vector showing the name to be used on the plot title</p>
</td></tr>
<tr><td><code id="VolcanoPlot_+3A_fc">fc</code></td>
<td>
<p>A numeric value of the fold change. Default is 0.5.</p>
</td></tr>
<tr><td><code id="VolcanoPlot_+3A_fs">FS</code></td>
<td>
<p>A numeric value of the font size. Default is 0.4.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A volcano plot
</p>

<hr>
<h2 id='wilcoxon.unpaired.seq.func'>Twoclass Wilcoxon statistics</h2><span id='topic+wilcoxon.unpaired.seq.func'></span>

<h3>Description</h3>

<p>Twoclass Wilcoxon statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilcoxon.unpaired.seq.func(xresamp, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilcoxon.unpaired.seq.func_+3A_xresamp">xresamp</code></td>
<td>
<p>an rank array with dim #gene*#sample*nresamp</p>
</td></tr>
<tr><td><code id="wilcoxon.unpaired.seq.func_+3A_y">y</code></td>
<td>
<p>outcome vector of values 1 and 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the statistic.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
