<!DOCTYPE html><html><head><title>Help for package smerc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smerc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_shape_dists'><p>Return all shapes and distances for each zone</p></a></li>
<li><a href='#arg_check_dist_ellipse'><p>Check argments if dist.ellipse</p></a></li>
<li><a href='#bn.test'><p>Besag-Newell Test</p></a></li>
<li><a href='#bn.zones'><p>Determine case windows (circles)</p></a></li>
<li><a href='#cepp.sim'><p>Perform <code>cepp.test</code> on simulated data</p></a></li>
<li><a href='#cepp.test'><p>Cluster Evalation Permutation Procedure Test</p></a></li>
<li><a href='#cepp.weights'><p>Compute region weights for <code>cepp.test</code></p></a></li>
<li><a href='#clusters'><p>Extract clusters</p></a></li>
<li><a href='#color.clusters'><p>Color clusters</p></a></li>
<li><a href='#combine.zones'><p>Combine distinct zones</p></a></li>
<li><a href='#csg2'><p>Construct connected subgraphs</p></a></li>
<li><a href='#dc.sim'><p>Perform <code>dc.test</code> on simulated data</p></a></li>
<li><a href='#dc.test'><p>Double Connection spatial scan test</p></a></li>
<li><a href='#dc.zones'><p>Determine zones for the Double Connected scan test</p></a></li>
<li><a href='#dist.ellipse'><p>Compute minor axis distance of ellipse</p></a></li>
<li><a href='#distinct'><p>Distinct elements of a list</p></a></li>
<li><a href='#dmst.sim'><p>Perform <code>dmst.test</code> on simulated data</p></a></li>
<li><a href='#dmst.test'><p>Dynamic Minimum Spanning Tree spatial scan test</p></a></li>
<li><a href='#dmst.zones'><p>Determine zones for the Dynamic Minimum Spanning Tree scan test</p></a></li>
<li><a href='#edmst.sim'><p>Perform <code>edmst.test</code> on simulated data</p></a></li>
<li><a href='#edmst.test'><p>Early Stopping Dynamic Minimum Spanning Tree spatial scan</p>
test</a></li>
<li><a href='#edmst.zones'><p>Determine zones for the early stopping dynamic Minimum</p>
Spanning Tree scan test</a></li>
<li><a href='#elbow_point'><p>Compute Elbow Point</p></a></li>
<li><a href='#elliptic.nn'><p>Nearest neighbors for elliptic scan</p></a></li>
<li><a href='#elliptic.penalty'><p>Compute elliptic penalty</p></a></li>
<li><a href='#elliptic.sim'><p>Perform <code>elliptic.test</code> on simulated data</p></a></li>
<li><a href='#elliptic.sim.adj'><p>Perform <code>elliptic.test</code> on simulated data</p></a></li>
<li><a href='#elliptic.test'><p>Elliptical Spatial Scan Test</p></a></li>
<li><a href='#elliptic.zones'><p>Determine zones for <code>elliptic.test</code></p></a></li>
<li><a href='#fast.sim'><p>Perform <code>fast.test</code> on simulated data</p></a></li>
<li><a href='#fast.test'><p>Fast Subset Scan Test</p></a></li>
<li><a href='#fast.zones'><p>Determine sequence of fast subset scan zones</p></a></li>
<li><a href='#flex_test'><p>Flexibly-shaped Spatial Scan Test</p></a></li>
<li><a href='#flex_zones'><p>Determine zones for flexibly shaped spatial scan test</p></a></li>
<li><a href='#flex.sim'><p>Perform <code>flex.test</code> on simualated data</p></a></li>
<li><a href='#flex.test'><p>Flexibly-shaped Spatial Scan Test</p></a></li>
<li><a href='#flex.zones'><p>Determine zones for flexibly shaped spatial scan test</p></a></li>
<li><a href='#gedist'><p>Compute distance for geographic coordinates</p></a></li>
<li><a href='#knn'><p>K nearest neighbors</p></a></li>
<li><a href='#lget'><p>Apply getElement over a list</p></a></li>
<li><a href='#logical2zones'><p>Convert logical vector to zone</p></a></li>
<li><a href='#mc.pvalue'><p>Compute Monte Carlo p-value</p></a></li>
<li><a href='#mlf.test'><p>Maxima Likelihood First Scan Test</p></a></li>
<li><a href='#mlf.zones'><p>Determine zones for the maxima likelihood</p>
first algorithm.</a></li>
<li><a href='#mlink.sim'><p>Perform <code>mlink.test</code> on simulated data</p></a></li>
<li><a href='#mlink.test'><p>Maximum Linkage spatial scan test</p></a></li>
<li><a href='#mlink.zones'><p>Determine zones for the Maximum Linkage scan test</p></a></li>
<li><a href='#morancr.sim'><p>Constant-risk Moran's I statistic</p></a></li>
<li><a href='#morancr.stat'><p>Constant-risk Moran's I statistic</p></a></li>
<li><a href='#morancr.test'><p>Constant-risk Moran's I-based test</p></a></li>
<li><a href='#mst.all'><p>Minimum spanning tree for all regions</p></a></li>
<li><a href='#mst.seq'><p>Minimum spanning tree sequence</p></a></li>
<li><a href='#nclusters'><p>Number of clusters</p></a></li>
<li><a href='#neast'><p>Breast cancer mortality in the Northeastern United States</p></a></li>
<li><a href='#neastw'><p>Binary adjacency matrix for <code>neast</code></p></a></li>
<li><a href='#nn.cumsum'><p>Cumulative sum over nearest neighbors</p></a></li>
<li><a href='#nn2zones'><p>Convert nearest neighbors list to zones</p></a></li>
<li><a href='#nndist'><p>Determine nearest neighbors based on maximum distance</p></a></li>
<li><a href='#nndup'><p>Determine duplicates in nearest neighbor list</p></a></li>
<li><a href='#nnpop'><p>Determine nearest neighbors with population constraint</p></a></li>
<li><a href='#noc_enn'><p>Returned ordered non-overlapping clusters</p></a></li>
<li><a href='#noc_nn'><p>Returned ordered non-overlapping clusters</p></a></li>
<li><a href='#noz'><p>Determine non-overlapping zones</p></a></li>
<li><a href='#nydf'><p>Leukemia data for 281 regions in New York.</p></a></li>
<li><a href='#nypoly'><p><code>SpatialPolygons</code> object for New York</p>
leukemia data.</a></li>
<li><a href='#nysf'><p><code>sf</code> object for New York leukemia data.</p></a></li>
<li><a href='#nysp'><p><code>SpatialPolygonsDataFrame</code> for New York</p>
leukemia data.</a></li>
<li><a href='#nyw'><p>Adjacency matrix for New York leukemia data.</p></a></li>
<li><a href='#optimal_ubpop'><p>Optimal Population Upper Bound Statistics</p></a></li>
<li><a href='#plot.smerc_cluster'><p>Plot object of class <code>smerc_cluster</code>.</p></a></li>
<li><a href='#plot.smerc_optimal_ubpop'><p>Plot object of class <code>smerc_optimal_ubpop</code>.</p></a></li>
<li><a href='#plot.tango'><p>Plots an object of class <code>tango</code>.</p></a></li>
<li><a href='#precog.sim'><p>Perform <code>precog.test</code> on simulated data.</p></a></li>
<li><a href='#precog.test'><p>PreCoG Scan Test</p></a></li>
<li><a href='#prep.mst'><p>Return nicely formatted results from mst.all</p></a></li>
<li><a href='#print.smerc_cluster'><p>Print object of class <code>smerc_cluster</code>.</p></a></li>
<li><a href='#print.smerc_optimal_ubpop'><p>Print object of class <code>smerc_optimal_ubpop</code>.</p></a></li>
<li><a href='#print.smerc_similarity_test'><p>Print object of class <code>smerc_similarity_test</code>.</p></a></li>
<li><a href='#print.tango'><p>Print object of class <code>tango</code>.</p></a></li>
<li><a href='#rflex_zones'><p>Determine zones for flexibly shaped spatial scan test</p></a></li>
<li><a href='#rflex.midp'><p>Compute middle p-value</p></a></li>
<li><a href='#rflex.sim'><p>Perform <code>rflex.test</code> on simualated data</p></a></li>
<li><a href='#rflex.test'><p>Restricted Flexibly-shaped Spatial Scan Test</p></a></li>
<li><a href='#rflex.zones'><p>Determine zones for flexibly shaped spatial scan test</p></a></li>
<li><a href='#scan_stat'><p>Spatial scan statistic</p></a></li>
<li><a href='#scan.sim'><p>Perform <code>scan.test</code> on simulated data</p></a></li>
<li><a href='#scan.sim.adj'><p>Perform <code>scan.test</code> on simulated data</p></a></li>
<li><a href='#scan.stat'><p>Spatial scan statistic</p></a></li>
<li><a href='#scan.test'><p>Spatial Scan Test</p></a></li>
<li><a href='#scan.zones'><p>Determine zones for the spatial scan test</p></a></li>
<li><a href='#seq_scan_sim'><p>Perform scan test on simulated data sequentially</p></a></li>
<li><a href='#seq_scan_test'><p>Sequential Scan Test</p></a></li>
<li><a href='#sig_noc'><p>Return most significant, non-overlapping zones</p></a></li>
<li><a href='#sig_prune'><p>Prune significant, non-overlapping zones</p></a></li>
<li><a href='#smerc'><p>smerc</p></a></li>
<li><a href='#smerc_cluster'><p>Prepare <code>smerc_cluster</code></p></a></li>
<li><a href='#stat.poisson.adj'><p>Compute Poisson test statistic</p></a></li>
<li><a href='#summary.smerc_cluster'><p>Summary of <code>smerc_cluster</code> object</p></a></li>
<li><a href='#tango.stat'><p>Tango's statistic</p></a></li>
<li><a href='#tango.test'><p>Tango's clustering detection test</p></a></li>
<li><a href='#tango.weights'><p>Distance-based weights for <code>tango.test</code></p></a></li>
<li><a href='#uls.sim'><p>Perform <code>uls.test</code> on simulated data</p></a></li>
<li><a href='#uls.test'><p>Upper Level Set Spatial Scan Test</p></a></li>
<li><a href='#uls.zones'><p>Determine sequence of ULS zones.</p></a></li>
<li><a href='#w2segments'><p>Returns segments connecting neighbors</p></a></li>
<li><a href='#zones.sum'><p>Sum over zones</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Methods for Regional Counts</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua French &lt;joshua.french@ucdenver.edu&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jfrench/smerc/issues">https://github.com/jfrench/smerc/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implements statistical methods for analyzing the counts of areal data, with a focus on the detection of spatial clusters and clustering.  The package has a heavy emphasis on spatial scan methods, which were first introduced by Kulldorff and Nagarwalla (1995) &lt;<a href="https://doi.org/10.1002%2Fsim.4780140809">doi:10.1002/sim.4780140809</a>&gt; and Kulldorff (1997) &lt;<a href="https://doi.org/10.1080%2F03610929708831995">doi:10.1080/03610929708831995</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>pbapply, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>crayon, lintr, maps, testthat, SpatialEpi, knitr, rmarkdown,
sf, sp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-08 21:06:23 UTC; frencjos</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua French <a href="https://orcid.org/0000-0002-9708-3353"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mohammad Meysami <a href="https://orcid.org/0000-0002-3322-5244"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-10 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_shape_dists'>Return all shapes and distances for each zone</h2><span id='topic+all_shape_dists'></span>

<h3>Description</h3>

<p>Return all shapes and distances for each zone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_shape_dists(s, na, coords)
</code></pre>

<hr>
<h2 id='arg_check_dist_ellipse'>Check argments if dist.ellipse</h2><span id='topic+arg_check_dist_ellipse'></span>

<h3>Description</h3>

<p>Check argments if dist.ellipse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arg_check_dist_ellipse(coords, shape, angle)
</code></pre>

<hr>
<h2 id='bn.test'>Besag-Newell Test</h2><span id='topic+bn.test'></span>

<h3>Description</h3>

<p><code>bn.test</code> implements the Besag-Newell test of Besag
and Newell (1991) for finding disease clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bn.test(
  coords,
  cases,
  pop,
  cstar,
  ex = sum(cases)/sum(pop) * pop,
  alpha = 0.1,
  longlat = FALSE,
  modified = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bn.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="bn.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="bn.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="bn.test_+3A_cstar">cstar</code></td>
<td>
<p>A non-negative integer indicating the
minimum number of cases to include in each window.</p>
</td></tr>
<tr><td><code id="bn.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="bn.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="bn.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="bn.test_+3A_modified">modified</code></td>
<td>
<p>A logical value indicating whether a
modified version of the test should be performed.  The
original paper recommends computing the p-value for
each cluster as <code>1 - ppois(cstar - 1, lambda =
expected)</code>. The modified version replaces <code>cstar</code>
with <code>cases</code>, the observed number of cases in the
region, and computes the p-value for the cluster as
<code>1 - ppois(cases - 1, lambda = ex)</code>. The default
is <code>modified = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>smerc_cluster</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Besag, J. and Newell, J.  (1991). The
detection of clusters in rare diseases, Journal of the
Royal Statistical Society, Series A, 154, 327-333.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(x, y))
out &lt;- bn.test(
  coords = coords, cases = nydf$cases,
  pop = nydf$pop, cstar = 6,
  alpha = 0.1
)
plot(out)

# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='bn.zones'>Determine case windows (circles)</h2><span id='topic+bn.zones'></span><span id='topic+casewin'></span>

<h3>Description</h3>

<p><code>bn.zones</code> determines the case windows (circles) for
the Besag-Newell method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bn.zones(d, cases, cstar)

casewin(d, cases, cstar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bn.zones_+3A_d">d</code></td>
<td>
<p>An <code class="reqn">n\times n</code> square distance matrix
containing the intercentroid distance between the
<code class="reqn">n</code> region centroids.</p>
</td></tr>
<tr><td><code id="bn.zones_+3A_cases">cases</code></td>
<td>
<p>A vector of length <code class="reqn">n</code> containing the
observed number of cases for the <code class="reqn">n</code> region
centroids.</p>
</td></tr>
<tr><td><code id="bn.zones_+3A_cstar">cstar</code></td>
<td>
<p>A non-negative integer indicating the
minimum number of cases to include in each window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the distances provided in <code>d</code>, for each
observation, the nearest neighbors are included in
increasingly larger windows until at least <code>cstar</code>
cases are included in the window.  Each row of <code>d</code>
is matched with the same position in <code>cases</code>.
</p>


<h3>Value</h3>

<p>Returns the indices of the regions in each case
window as a list.  For each element of the list, the
indices are ordered from nearest to farthest from each
centroid (and include the starting region).
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Besag, J. and Newell, J.  (1991). The
detection of clusters in rare diseases, Journal of the
Royal Statistical Society, Series A, 154, 327-333.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
d &lt;- gedist(coords, longlat = FALSE)
cwins &lt;- bn.zones(d, cases = nydf$cases, cstar = 6)
</code></pre>

<hr>
<h2 id='cepp.sim'>Perform <code>cepp.test</code> on simulated data</h2><span id='topic+cepp.sim'></span>

<h3>Description</h3>

<p><code>cepp.sim</code> efficiently performs
<code><a href="#topic+cepp.test">cepp.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+cepp.test">cepp.test</a></code> function, but is informative for
better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cepp.sim(nsim = 1, nn, ty, ex, wts, simdist = "multinomial")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cepp.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="cepp.sim_+3A_nn">nn</code></td>
<td>
<p>A list of nearest neighbors produced by <code><a href="#topic+casewin">casewin</a></code>.</p>
</td></tr>
<tr><td><code id="cepp.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="cepp.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="cepp.sim_+3A_wts">wts</code></td>
<td>
<p>A list that has the weights associated with each
region of each element of <code>nn</code>.</p>
</td></tr>
<tr><td><code id="cepp.sim_+3A_simdist">simdist</code></td>
<td>
<p>A character string indicating whether the
simulated data should come from a <code>"multinomial"</code>
or <code>"poisson"</code> distribution.  The default is
<code>"multinomial"</code>, which fixes the total number of
cases observed in each simulated data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
d &lt;- gedist(as.matrix(coords), longlat = TRUE)
nn &lt;- casewin(d, cases = nydf$pop, cstar = 15000)
cases &lt;- floor(nydf$cases)
ty &lt;- sum(cases)
ex &lt;- ty / sum(nydf$pop) * nydf$pop
# find smallest windows with at least n* pop
nstar &lt;- 1000
nn &lt;- casewin(d, cases = nydf$pop, cstar = nstar)
# determine ts
wts &lt;- cepp.weights(nn, nydf$pop, nstar)
tsim &lt;- cepp.sim(1, nn = nn, ty = ty, ex = ex, wts = wts)
</code></pre>

<hr>
<h2 id='cepp.test'>Cluster Evalation Permutation Procedure Test</h2><span id='topic+cepp.test'></span>

<h3>Description</h3>

<p><code>cepp.test</code> implements the Cluster Evaluation
Permutation Procedure test of Turnbull et al. (1990)
for finding disease clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cepp.test(
  coords,
  cases,
  pop,
  nstar,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  longlat = FALSE,
  simdist = "multinomial"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cepp.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="cepp.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="cepp.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="cepp.test_+3A_nstar">nstar</code></td>
<td>
<p>The size of the at-risk population
in each window.</p>
</td></tr>
<tr><td><code id="cepp.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="cepp.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="cepp.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="cepp.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="cepp.test_+3A_simdist">simdist</code></td>
<td>
<p>A character string indicating whether the
simulated data should come from a <code>"multinomial"</code>
or <code>"poisson"</code> distribution.  The default is
<code>"multinomial"</code>, which fixes the total number of
cases observed in each simulated data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>smerc_cluster</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Bruce W. Turnbull, Eric J. Iwano, William S. Burnett,
Holly L. Howe, Larry C. Clark (1990).  Monitoring for Clusters of Disease:
Application to Leukemia Incidence in Upstate New York,
American Journal of Epidemiology, 132(supp1):136-143.
&lt;doi:10.1093/oxfordjournals.aje.a115775&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(x, y))
cases &lt;- nydf$cases
pop &lt;- nydf$pop
out &lt;- cepp.test(
  coords = coords, cases = cases, pop = pop,
  nstar = 1000, alpha = 0.99
)
plot(out)
summary(out)

# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='cepp.weights'>Compute region weights for <code>cepp.test</code></h2><span id='topic+cepp.weights'></span>

<h3>Description</h3>

<p>Compute region weights for <code>cepp.test</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cepp.weights(nn, pop, nstar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cepp.weights_+3A_nn">nn</code></td>
<td>
<p>A list of nearest neighbors produced by
<code><a href="#topic+casewin">casewin</a></code>.</p>
</td></tr>
<tr><td><code id="cepp.weights_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="cepp.weights_+3A_nstar">nstar</code></td>
<td>
<p>The size of the at-risk population
in each window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements related to the weight
each nearest neighbor region will have in the
corresponding weighted sum used to compute the test
statistic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(x, y))
pop &lt;- nydf$pop
# intercentroid distances
d &lt;- gedist(coords)
# find smallest windows with cumulative population of
# at least n* = 1000
nn &lt;- casewin(d, pop, 1000)
# compute weights
w &lt;- cepp.weights(nn, pop, 1000)
</code></pre>

<hr>
<h2 id='clusters'>Extract clusters</h2><span id='topic+clusters'></span>

<h3>Description</h3>

<p><code>clusters</code> extracts the clusters contained in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusters(x, idx = seq_along(x$clusters), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusters_+3A_x">x</code></td>
<td>
<p>An object with clusters.</p>
</td></tr>
<tr><td><code id="clusters_+3A_idx">idx</code></td>
<td>
<p>An index vector indicating the elements of
<code>x$clusters</code> to print information for. The default
is all clusters.</p>
</td></tr>
<tr><td><code id="clusters_+3A_...">...</code></td>
<td>
<p>Currently unimplemented</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- scan.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, nsim = 19,
  alpha = 0.2, longlat = TRUE
)
clusters(out)
clusters(out, idx = 1:2)
</code></pre>

<hr>
<h2 id='color.clusters'>Color clusters</h2><span id='topic+color.clusters'></span>

<h3>Description</h3>

<p><code>color.clusters</code> is a helper function to color
clusters of regions produced by an appropriate method,
e.g., <code>scan.test</code> or <code>uls.test</code>.  Regions that
are not part of any cluster have no color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color.clusters(
  x,
  idx = seq_along(x$clusters),
  col = grDevices::hcl.colors(length(idx))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color.clusters_+3A_x">x</code></td>
<td>
<p>An object of class scan produced by a function
such as <code>scan.test</code>.</p>
</td></tr>
<tr><td><code id="color.clusters_+3A_idx">idx</code></td>
<td>
<p>An index vector indicating the elements of
<code>object$clusters</code> to print information for. The default
is all clusters.</p>
</td></tr>
<tr><td><code id="color.clusters_+3A_col">col</code></td>
<td>
<p>A vector of colors to color the clusters in
<code>x</code>.  Should have same length as the number of
clusters in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with colors for each
region/centroid for the data set used to construct
<code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- scan.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, alpha = 0.2, longlat = TRUE,
  nsim = 9
)
#' # better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
   # plot only clusters 2 and 3
   plot(st_geometry(nysf),
        col = color.clusters(out, idx = c(2, 3)),
        border = "white")
}
</code></pre>

<hr>
<h2 id='combine.zones'>Combine distinct zones</h2><span id='topic+combine.zones'></span>

<h3>Description</h3>

<p><code>combine.zones</code> combines the elements of <code>z1</code>
and <code>z2</code> into a single list, returning only the
unique zones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.zones(z1, z2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.zones_+3A_z1">z1</code></td>
<td>
<p>A list of zones</p>
</td></tr>
<tr><td><code id="combine.zones_+3A_z2">z2</code></td>
<td>
<p>A list of zones</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of distinct zones
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z1 &lt;- list(1:2, 1:3)
z2 &lt;- list(2:1, 1:4)
combine.zones(z1, z2)
</code></pre>

<hr>
<h2 id='csg2'>Construct connected subgraphs</h2><span id='topic+csg2'></span><span id='topic+lcsg2'></span><span id='topic+scsg2'></span>

<h3>Description</h3>

<p><code>csg2</code>, <code>lcsg2</code>, and <code>scsg2</code> construct
connected subgraphs. These functions are not intended
for users.
<code>nn</code> contains a list of nearest
neighbors for each region. <code>idx</code> is a
vector of possible vertices being considered as a
subgraph. <code>w</code> is a connectivity matrix relating the
N vertices. <code>w[i,j] = 1</code> if vertices i and j are
connected, i.e., if they share an edge. The dimensions of
<code>w</code> are <code class="reqn">N times k</code>, where <code>k =
length(idx)</code>. While the rows of <code>w</code> contain
adjacency information for all N vertices, only the
<code>idx</code> columns of the complete adjacency matrix are
used in <code>w</code>.  See Details for discussion of
<code>scsg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg2(cz, cnn, cw)

lcsg2(lcz, cnn, cw)

scsg2(
  nn,
  w,
  idx = seq_along(nn),
  nlevel = NULL,
  verbose = FALSE,
  logical = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg2_+3A_cz">cz</code></td>
<td>
<p>A logical vector representing the current subgraph.</p>
</td></tr>
<tr><td><code id="csg2_+3A_cnn">cnn</code></td>
<td>
<p>The indices of the neighbors of the current vertex.</p>
</td></tr>
<tr><td><code id="csg2_+3A_cw">cw</code></td>
<td>
<p>A binary adjacency matrix for the neighbors of the current vertex.</p>
</td></tr>
<tr><td><code id="csg2_+3A_lcz">lcz</code></td>
<td>
<p>A list of current zones (in the form of logical vectors).</p>
</td></tr>
<tr><td><code id="csg2_+3A_nn">nn</code></td>
<td>
<p>A list of the nearest neighbors for each vertex (region).</p>
</td></tr>
<tr><td><code id="csg2_+3A_w">w</code></td>
<td>
<p>A binary adjacency matrix indicating connected neighbors.</p>
</td></tr>
<tr><td><code id="csg2_+3A_idx">idx</code></td>
<td>
<p>A vector of vertices for which to construct the set of connected subgraphs.</p>
</td></tr>
<tr><td><code id="csg2_+3A_nlevel">nlevel</code></td>
<td>
<p>The maximum size of each subgraph.</p>
</td></tr>
<tr><td><code id="csg2_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether descriptive messages should be provided.  Default is
<code>FALSE</code>.  If <code>TRUE</code>, this can be useful for
diagnosing where the sequences of connected subgraphs
is slowing down/having problems.</p>
</td></tr>
<tr><td><code id="csg2_+3A_logical">logical</code></td>
<td>
<p>A logical value indicating whether a list of logical vectors should be returned. The default is <code>FALSE</code>,
indicating that the <code>scsg</code> function should return a list of vectors with
each vector containing the vertex indices included in each subgraph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scsg2</code> performs a sequence of <code>lcsg2</code> calls.
Starting with <code>lcz == list(idx[1])</code>, <code>scsg</code>
keeps iteratively building more connected subsgraphs by
perfoming something like:  lcz1 = list(idx[1]).  lcz2 =
lcsg2(lcz1, ...). lcz3 = lcsg2(lcz2, ...).  This is
done until there are no more connected subgraphs among
the elements of <code>idx</code>.
</p>


<h3>Value</h3>

<p>A list with all possible connected subgraphs based on the
user-provided parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
# determine 50 nn of region 1 for NY data
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
nn3 &lt;- knn(coords, longlat = TRUE, k = 3)
z1 &lt;- scsg2(nn3, nyw)
z2 &lt;- flex.zones(coords, nyw, k = 3, longlat = TRUE)
all.equal(z1, z2)
</code></pre>

<hr>
<h2 id='dc.sim'>Perform <code>dc.test</code> on simulated data</h2><span id='topic+dc.sim'></span>

<h3>Description</h3>

<p><code>dc.sim</code> efficiently performs <code><a href="#topic+dc.test">dc.test</a></code>
on a simulated data set.  The function is meant to be
used internally by the <code><a href="#topic+dc.test">dc.test</a></code> function,
but is informative for better understanding the
implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.sim(nsim = 1, nn, ty, ex, w, pop, max_pop, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="dc.sim_+3A_nn">nn</code></td>
<td>
<p>A list of distance-based nearest neighbors,
preferably from the <code><a href="#topic+nndist">nndist</a></code> function.</p>
</td></tr>
<tr><td><code id="dc.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="dc.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="dc.sim_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="dc.sim_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="dc.sim_+3A_max_pop">max_pop</code></td>
<td>
<p>The population upperbound (in total
population) for a candidate zone.</p>
</td></tr>
<tr><td><code id="dc.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$pop
ty &lt;- sum(cases)
ex &lt;- ty / sum(pop) * pop
d &lt;- gedist(coords, longlat = TRUE)
nn &lt;- nndist(d, ubd = 0.05)
max_pop &lt;- sum(pop) * 0.25
tsim &lt;- dc.sim(1, nn, ty, ex, nyw,
  pop = pop,
  max_pop = max_pop
)
</code></pre>

<hr>
<h2 id='dc.test'>Double Connection spatial scan test</h2><span id='topic+dc.test'></span>

<h3>Description</h3>

<p><code>dc.test</code> implements the Double Connection spatial
scan test of Costa et al. (2012). Starting with a single
region as a current zone, new candidate zones are
constructed by combining the current zone with the
connected region that maximizes the resulting likelihood
ratio test statistic, with the added constraint that the
region must have at least two connection (i.e., shares a
border with) at least two of the regoins in the current
zone.  This procedure is repeated until adding a
connected region does not increase the test statistic (or
the population or distance upper bounds are reached).
The same procedure is repeated for each region.  The
clusters returned are non-overlapping, ordered from most
significant to least significant. The first cluster is
the most likely to be a cluster. If no significant
clusters are found, then the most likely cluster is
returned (along with a warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.test(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  ubd = 1,
  longlat = FALSE,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="dc.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="dc.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="dc.test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="dc.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="dc.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="dc.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="dc.test_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="dc.test_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
<tr><td><code id="dc.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="dc.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum intercentroid distance can be found by
executing the command:
<code>gedist(as.matrix(coords), longlat = longlat)</code>,
based on the specified values of <code>coords</code> and
<code>longlat</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>smerc_cluster</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Costa, M.A. and Assuncao, R.M. and Kulldorff,
M. (2012) Constrained spanning tree algorithms for
irregularly-shaped spatial clustering, Computational
Statistics &amp; Data Analysis, 56(6), 1771-1783.
&lt;doi:10.1016/j.csda.2011.11.001&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- dc.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$population, w = nyw,
  alpha = 0.12, longlat = TRUE,
  nsim = 5, ubpop = 0.1, ubd = 0.2
)
# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='dc.zones'>Determine zones for the Double Connected scan test</h2><span id='topic+dc.zones'></span>

<h3>Description</h3>

<p><code>dc.zones</code> determines the zones for the Double
Connected scan test (<code><a href="#topic+dc.test">dc.test</a></code>).  The
function returns the zones, as well as the associated
test statistic, cases in each zone, the expected number
of cases in each zone, and the population in each zone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.zones(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  ubpop = 0.5,
  ubd = 1,
  longlat = FALSE,
  cl = NULL,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.zones_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="dc.zones_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="dc.zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="dc.zones_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="dc.zones_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="dc.zones_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="dc.zones_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
<tr><td><code id="dc.zones_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="dc.zones_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="dc.zones_+3A_progress">progress</code></td>
<td>
<p>A logical value indicating whether a
progress bar should be displayed.  The default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every zone considered must have a total population less
than <code>ubpop * sum(pop)</code>.  Additionally, the maximum
intercentroid distance for the regions within a zone must
be no more than <code>ubd * the maximum intercentroid
distance across all regions</code>.
</p>


<h3>Value</h3>

<p>Returns a list with elements: </p>
<table>
<tr><td><code>zones</code></td>
<td>
<p>A list
contained the location ids of each potential cluster.</p>
</td></tr>
<tr><td><code>loglikrat</code></td>
<td>
<p>The loglikelihood ratio for each zone
(i.e., the log of the test statistic).</p>
</td></tr>
<tr><td><code>cases</code></td>
<td>
<p>The observed number of cases in each
zone.</p>
</td></tr> <tr><td><code>expected</code></td>
<td>
<p>The expected number of cases
each zone.</p>
</td></tr> <tr><td><code>pop</code></td>
<td>
<p>The total population in each
zone.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Costa, M.A. and Assuncao, R.M. and Kulldorff,
M. (2012) Constrained spanning tree algorithms for
irregularly-shaped spatial clustering, Computational
Statistics &amp; Data Analysis, 56(6), 1771-1783.
&lt;doi:10.1016/j.csda.2011.11.001&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
# find zone with max statistic starting from each individual region
all_zones &lt;- dc.zones(coords,
  cases = floor(nydf$cases),
  nydf$pop, w = nyw, ubpop = 0.25,
  ubd = .25, longlat = TRUE
)
</code></pre>

<hr>
<h2 id='dist.ellipse'>Compute minor axis distance of ellipse</h2><span id='topic+dist.ellipse'></span>

<h3>Description</h3>

<p><code>dist.ellipse</code> computes the length of the minor axis
needed for an ellipse of a certain <code>shape</code> and
<code>angle</code> to intersect each of the other coordinates
from a starting coordinate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.ellipse(coords, shape, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.ellipse_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">N \times 2</code> matrix of coordinates</p>
</td></tr>
<tr><td><code id="dist.ellipse_+3A_shape">shape</code></td>
<td>
<p>The ratio of the major axis to the minor
axis of the ellipse</p>
</td></tr>
<tr><td><code id="dist.ellipse_+3A_angle">angle</code></td>
<td>
<p>The angle of the ellipse in the range [0,
180).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of distances between each coordinate and
all other coordinates (and itself).  Each row contains
the distances for a coordinate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- as.matrix(nydf[, c("x", "y")])
d &lt;- dist.ellipse(coords, 4, 15)
</code></pre>

<hr>
<h2 id='distinct'>Distinct elements of a list</h2><span id='topic+distinct'></span>

<h3>Description</h3>

<p><code>distinct</code> takes a list of integer vectors and
returns the list indices that contain unique combinations
of elements.  This function is NOT robust against misuse,
so please use properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinct(x, N = max(unlist(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct_+3A_x">x</code></td>
<td>
<p>A list of integers</p>
</td></tr>
<tr><td><code id="distinct_+3A_n">N</code></td>
<td>
<p>The largest integer value across all elements of
<code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that <code>k</code> is the largest integer value in
<code>x</code>.  A vector of the largest <code>k</code> prime numbers
is obtained (call this <code>pri</code>).  The algorithm takes
the sum of the log of <code>pri[x[[i]]]</code> for each element
of <code>x</code>, and determines which sums are unique.  This
is why the elements of <code>x</code> must be integer vectors.
The prime aspect of the algorithm is critical, as it
ensures that a none of the values are multiples of the
others, ensuring uniqueness.
</p>
<p>Note: this algorithm has only been applied to data sets
where each element of <code>x[[i]]</code> appears only once,
though it should work for repeats also.
</p>


<h3>Value</h3>

<p>A vector with the distinct indices.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Algorithm based on suggestion at
<a href="https://stackoverflow.com/a/29824978">https://stackoverflow.com/a/29824978</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(1:3, 3:1, 1:4, 4:1, c(1, 2, 4, 6), c(6, 4, 1, 2))
x[distinct(x)]
</code></pre>

<hr>
<h2 id='dmst.sim'>Perform <code>dmst.test</code> on simulated data</h2><span id='topic+dmst.sim'></span>

<h3>Description</h3>

<p><code>dmst.sim</code> efficiently performs
<code><a href="#topic+dmst.test">dmst.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+dmst.test">dmst.test</a></code> function, but is informative for
better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmst.sim(nsim = 1, nn, ty, ex, w, pop, max_pop, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmst.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="dmst.sim_+3A_nn">nn</code></td>
<td>
<p>A list of distance-based nearest neighbors,
preferably from the <code><a href="#topic+nndist">nndist</a></code> function.</p>
</td></tr>
<tr><td><code id="dmst.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="dmst.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="dmst.sim_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="dmst.sim_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="dmst.sim_+3A_max_pop">max_pop</code></td>
<td>
<p>The population upperbound (in total
population) for a candidate zone.</p>
</td></tr>
<tr><td><code id="dmst.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$pop
ty &lt;- sum(cases)
ex &lt;- ty / sum(pop) * pop
d &lt;- gedist(coords, longlat = TRUE)
nn &lt;- nndist(d, ubd = 0.05)
max_pop &lt;- sum(pop) * 0.25
tsim &lt;- dmst.sim(1, nn, ty, ex, nyw,
  pop = pop,
  max_pop = max_pop
)
</code></pre>

<hr>
<h2 id='dmst.test'>Dynamic Minimum Spanning Tree spatial scan test</h2><span id='topic+dmst.test'></span>

<h3>Description</h3>

<p><code>dmst.test</code> implements the dynamic Minimum Spanning
Tree scan test of Assuncao et al. (2006). Starting with a
single region as a current zone, new candidate zones are
constructed by combining the current zone with the
connected region that maximizes the resulting likelihood
ratio test statistic.  This procedure is repeated until
the population or distance upper bounds are reached.  The
same procedure is repeated for each region.  The clusters
returned are non-overlapping, ordered from most
significant to least significant. The first cluster is
the most likely to be a cluster. If no significant
clusters are found, then the most likely cluster is
returned (along with a warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmst.test(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  ubd = 1,
  longlat = FALSE,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmst.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="dmst.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="dmst.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="dmst.test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="dmst.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="dmst.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="dmst.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="dmst.test_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="dmst.test_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
<tr><td><code id="dmst.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="dmst.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum intercentroid distance can be found by
executing the command:
<code>gedist(as.matrix(coords), longlat = longlat)</code>,
based on the specified values of <code>coords</code> and
<code>longlat</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>smerc_cluster</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Assuncao, R.M., Costa, M.A., Tavares, A. and
Neto, S.J.F. (2006). Fast detection of arbitrarily
shaped disease clusters, Statistics in Medicine, 25,
723-742.  &lt;doi:10.1002/sim.2411&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- dmst.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, w = nyw,
  alpha = 0.12, longlat = TRUE,
  nsim = 2, ubpop = 0.05, ubd = 0.1
)
# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='dmst.zones'>Determine zones for the Dynamic Minimum Spanning Tree scan test</h2><span id='topic+dmst.zones'></span>

<h3>Description</h3>

<p><code>dmst.zones</code> determines the zones for the Dynamic
Minimum Spanning Tree scan test (<code><a href="#topic+dmst.test">dmst.test</a></code>).  The
function returns the zones, as well as the associated
test statistic, cases in each zone, the expected number
of cases in each zone, and the population in each zone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmst.zones(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  ubpop = 0.5,
  ubd = 1,
  longlat = FALSE,
  cl = NULL,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmst.zones_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="dmst.zones_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="dmst.zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="dmst.zones_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="dmst.zones_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="dmst.zones_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="dmst.zones_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
<tr><td><code id="dmst.zones_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="dmst.zones_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="dmst.zones_+3A_progress">progress</code></td>
<td>
<p>A logical value indicating whether a
progress bar should be displayed.  The default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every zone considered must have a total population less
than <code>ubpop * sum(pop)</code>.  Additionally, the maximum
intercentroid distance for the regions within a zone must
be no more than <code>ubd * the maximum intercentroid
distance across all regions</code>.
</p>


<h3>Value</h3>

<p>Returns a list with elements: </p>
<table>
<tr><td><code>zones</code></td>
<td>
<p>A list
contained the location ids of each potential cluster.</p>
</td></tr>
<tr><td><code>loglikrat</code></td>
<td>
<p>The loglikelihood ratio for each zone
(i.e., the log of the test statistic).</p>
</td></tr>
<tr><td><code>cases</code></td>
<td>
<p>The observed number of cases in each
zone.</p>
</td></tr> <tr><td><code>expected</code></td>
<td>
<p>The expected number of cases
each zone.</p>
</td></tr> <tr><td><code>pop</code></td>
<td>
<p>The total population in each
zone.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Assuncao, R.M., Costa, M.A., Tavares, A. and
Neto, S.J.F. (2006). Fast detection of arbitrarily
shaped disease clusters, Statistics in Medicine, 25,
723-742.  &lt;doi:10.1002/sim.2411&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
# find zone with max statistic starting from each individual region
all_zones &lt;- dmst.zones(coords,
  cases = floor(nydf$cases),
  nydf$pop, w = nyw, ubpop = 0.25,
  ubd = .25, longlat = TRUE
)
</code></pre>

<hr>
<h2 id='edmst.sim'>Perform <code>edmst.test</code> on simulated data</h2><span id='topic+edmst.sim'></span>

<h3>Description</h3>

<p><code>edmst.sim</code> efficiently performs
<code><a href="#topic+edmst.test">edmst.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+edmst.test">edmst.test</a></code> function, but is informative for
better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edmst.sim(nsim = 1, nn, ty, ex, w, pop, max_pop, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edmst.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="edmst.sim_+3A_nn">nn</code></td>
<td>
<p>A list of distance-based nearest neighbors,
preferably from the <code><a href="#topic+nndist">nndist</a></code> function.</p>
</td></tr>
<tr><td><code id="edmst.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="edmst.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="edmst.sim_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="edmst.sim_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="edmst.sim_+3A_max_pop">max_pop</code></td>
<td>
<p>The population upperbound (in total
population) for a candidate zone.</p>
</td></tr>
<tr><td><code id="edmst.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$pop
ty &lt;- sum(cases)
ex &lt;- ty / sum(pop) * pop
d &lt;- gedist(coords, longlat = TRUE)
nn &lt;- nndist(d, ubd = 0.05)
max_pop &lt;- sum(pop) * 0.25
tsim &lt;- edmst.sim(1, nn, ty, ex, nyw,
  pop = pop,
  max_pop = max_pop
)
</code></pre>

<hr>
<h2 id='edmst.test'>Early Stopping Dynamic Minimum Spanning Tree spatial scan
test</h2><span id='topic+edmst.test'></span>

<h3>Description</h3>

<p><code>edmst.test</code> implements the early stopping dynamic
Minimum Spanning Tree scan test of Costa et al. (2012).
Starting with a single region as a current zone, new
candidate zones are constructed by combining the current
zone with the connected region that maximizes the
resulting likelihood ratio test statistic.  This
procedure is repeated until adding a connected region
does not increase the test statistic (or the population
or distance upper bounds are reached).  The same
procedure is repeated for each region.  The clusters
returned are non-overlapping, ordered from most
significant to least significant. The first cluster is
the most likely to be a cluster. If no significant
clusters are found, then the most likely cluster is
returned (along with a warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edmst.test(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  ubd = 1,
  longlat = FALSE,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edmst.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="edmst.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="edmst.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="edmst.test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="edmst.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="edmst.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="edmst.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="edmst.test_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="edmst.test_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
<tr><td><code id="edmst.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="edmst.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum intercentroid distance can be found by
executing the command:
<code>gedist(as.matrix(coords), longlat = longlat)</code>,
based on the specified values of <code>coords</code> and
<code>longlat</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>smerc_cluster</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Costa, M.A. and Assuncao, R.M. and Kulldorff,
M. (2012) Constrained spanning tree algorithms for
irregularly-shaped spatial clustering, Computational
Statistics &amp; Data Analysis, 56(6), 1771-1783.
&lt;doi:10.1016/j.csda.2011.11.001&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- edmst.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, w = nyw,
  alpha = 0.12, longlat = TRUE,
  nsim = 5, ubpop = 0.1, ubd = 0.2
)
# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='edmst.zones'>Determine zones for the early stopping dynamic Minimum
Spanning Tree scan test</h2><span id='topic+edmst.zones'></span>

<h3>Description</h3>

<p><code>edmst.zones</code> determines the zones for the early
stopping Dynamic Minimum Spanning Tree scan test
(<code><a href="#topic+edmst.test">edmst.test</a></code>).  The function returns the
zones, as well as the associated test statistic, cases in
each zone, the expected number of cases in each zone, and
the population in each zone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edmst.zones(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  ubpop = 0.5,
  ubd = 1,
  longlat = FALSE,
  cl = NULL,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edmst.zones_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="edmst.zones_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="edmst.zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="edmst.zones_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="edmst.zones_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="edmst.zones_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="edmst.zones_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
<tr><td><code id="edmst.zones_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="edmst.zones_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="edmst.zones_+3A_progress">progress</code></td>
<td>
<p>A logical value indicating whether a
progress bar should be displayed.  The default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every zone considered must have a total population less
than <code>ubpop * sum(pop)</code>.  Additionally, the maximum
intercentroid distance for the regions within a zone must
be no more than <code>ubd * the maximum intercentroid
distance across all regions</code>.
</p>


<h3>Value</h3>

<p>Returns a list with elements: </p>
<table>
<tr><td><code>zones</code></td>
<td>
<p>A list
contained the location ids of each potential cluster.</p>
</td></tr>
<tr><td><code>loglikrat</code></td>
<td>
<p>The loglikelihood ratio for each zone
(i.e., the log of the test statistic).</p>
</td></tr>
<tr><td><code>cases</code></td>
<td>
<p>The observed number of cases in each
zone.</p>
</td></tr> <tr><td><code>expected</code></td>
<td>
<p>The expected number of cases
each zone.</p>
</td></tr> <tr><td><code>pop</code></td>
<td>
<p>The total population in each
zone.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Costa, M.A. and Assuncao, R.M. and Kulldorff,
M. (2012) Constrained spanning tree algorithms for
irregularly-shaped spatial clustering, Computational
Statistics &amp; Data Analysis, 56(6), 1771-1783.
&lt;doi:10.1016/j.csda.2011.11.001&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
# find zone with max statistic starting from each individual region
all_zones &lt;- edmst.zones(coords,
  cases = floor(nydf$cases),
  nydf$pop, w = nyw, ubpop = 0.25,
  ubd = .25, longlat = TRUE
)
</code></pre>

<hr>
<h2 id='elbow_point'>Compute Elbow Point</h2><span id='topic+elbow_point'></span>

<h3>Description</h3>

<p><code>elbow_point</code> computes the elbow point based on the maximum distance
between each point and the line passing through the end points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elbow_point(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elbow_point_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="elbow_point_+3A_y">y</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the index (<code>idx</code>), x-value (<code>x</code>) and
y-value (<code>y</code>) of the elbow point.
</p>


<h3>Author(s)</h3>

<p>Joshua French and Mohammad Meysami
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line">https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimal_ubpop">optimal_ubpop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some data
x &lt;- c(0, 0.5, 1)
y &lt;- c(1, 0.1, 0)
# plot data (the second point is clearly the elbow)
plot(x, y)
elbow_point(x, y)
</code></pre>

<hr>
<h2 id='elliptic.nn'>Nearest neighbors for elliptic scan</h2><span id='topic+elliptic.nn'></span>

<h3>Description</h3>

<p><code>elliptic.nn</code> computes the nearest neighbors
relationships for <code>elliptic.test</code>.  It will provide
a list of nearest neighbors, and a list of the associated
shape and angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elliptic.nn(
  coords,
  pop,
  ubpop = 0.5,
  shape = c(1, 1.5, 2, 3, 4, 5),
  nangle = c(1, 4, 6, 9, 12, 15)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elliptic.nn_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="elliptic.nn_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="elliptic.nn_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="elliptic.nn_+3A_shape">shape</code></td>
<td>
<p>The ratios of the major and minor axes of
the desired ellipses.</p>
</td></tr>
<tr><td><code id="elliptic.nn_+3A_nangle">nangle</code></td>
<td>
<p>The number of angles (between 0 and 180) to
consider for each shape.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of nested nearest neighbors, the
associated shapes and angles for each set of nn, and
all of the shapes and angles you get for each zone
constructed from the set of nearest neighbors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
enn &lt;- elliptic.nn(coords, nydf$pop, 0.1,
  shape = c(1, 1.5), nangle = c(1, 4)
)
</code></pre>

<hr>
<h2 id='elliptic.penalty'>Compute elliptic penalty</h2><span id='topic+elliptic.penalty'></span>

<h3>Description</h3>

<p>Compute eccentricity penalty for elliptic scan method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elliptic.penalty(a, shape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elliptic.penalty_+3A_a">a</code></td>
<td>
<p>Penalty scale</p>
</td></tr>
<tr><td><code id="elliptic.penalty_+3A_shape">shape</code></td>
<td>
<p>Shape of ellipse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of penalities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elliptic.penalty(a = 0.5, shape = c(1, 1.5, 2))
</code></pre>

<hr>
<h2 id='elliptic.sim'>Perform <code>elliptic.test</code> on simulated data</h2><span id='topic+elliptic.sim'></span>

<h3>Description</h3>

<p><code>elliptic.sim</code> efficiently performs
<code><a href="#topic+elliptic.test">elliptic.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+elliptic.test">elliptic.test</a></code> function, but is informative
for better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elliptic.sim(
  nsim = 1,
  nn,
  ty,
  ex,
  a,
  shape_all,
  ein,
  eout,
  cl = NULL,
  min.cases = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elliptic.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="elliptic.sim_+3A_nn">nn</code></td>
<td>
<p>A list of nearest neighbors produced by
<code><a href="#topic+elliptic.nn">elliptic.nn</a></code>.</p>
</td></tr>
<tr><td><code id="elliptic.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="elliptic.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="elliptic.sim_+3A_a">a</code></td>
<td>
<p>The penalty for the spatial scan statistic.  The
default is 0.5.</p>
</td></tr>
<tr><td><code id="elliptic.sim_+3A_shape_all">shape_all</code></td>
<td>
<p>A vector of the shapes associated with
all of the possible zones constructed from <code>nn</code>.
This can be obtained from <code><a href="#topic+elliptic.nn">elliptic.nn</a></code>.</p>
</td></tr>
<tr><td><code id="elliptic.sim_+3A_ein">ein</code></td>
<td>
<p>The expected number of cases in the zone.
Conventionally, this is the estimated overall disease
risk across the study area, multiplied by the total
population size of the zone.</p>
</td></tr>
<tr><td><code id="elliptic.sim_+3A_eout">eout</code></td>
<td>
<p>The expected number of cases outside the
zone.  This should be <code>ty - ein</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="elliptic.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="elliptic.sim_+3A_min.cases">min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
pop &lt;- nydf$pop
enn &lt;- elliptic.nn(coords, pop,
  ubpop = 0.1,
  shape = c(1, 1.5), nangle = c(1, 4)
)
cases &lt;- floor(nydf$cases)
ty &lt;- sum(cases)
ex &lt;- ty / sum(pop) * pop
yin &lt;- nn.cumsum(enn$nn, cases)
ein &lt;- nn.cumsum(enn$nn, ex)
tsim &lt;- elliptic.sim(
  nsim = 2, nn = enn$nn, ty = ty, ex = ex,
  a = 0.5, shape_all = enn$shape_all,
  ein = ein, eout = ty - ein
)
</code></pre>

<hr>
<h2 id='elliptic.sim.adj'>Perform <code>elliptic.test</code> on simulated data</h2><span id='topic+elliptic.sim.adj'></span>

<h3>Description</h3>

<p><code>elliptic.sim</code> efficiently performs
<code><a href="#topic+elliptic.test">elliptic.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+elliptic.test">elliptic.test</a></code> function, but is informative
for better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elliptic.sim.adj(
  nsim = 1,
  ex,
  nn,
  ty,
  logein,
  logeout,
  a,
  pen,
  min.cases = 2,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elliptic.sim.adj_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="elliptic.sim.adj_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="elliptic.sim.adj_+3A_nn">nn</code></td>
<td>
<p>A list of nearest neighbors produced by
<code><a href="#topic+elliptic.nn">elliptic.nn</a></code>.</p>
</td></tr>
<tr><td><code id="elliptic.sim.adj_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="elliptic.sim.adj_+3A_logein">logein</code></td>
<td>
<p>The <code>log</code> of the expected number of
cases in each candidate zone.</p>
</td></tr>
<tr><td><code id="elliptic.sim.adj_+3A_logeout">logeout</code></td>
<td>
<p>The <code>log</code> of the expected number of
cases outside of each candidate zone.</p>
</td></tr>
<tr><td><code id="elliptic.sim.adj_+3A_a">a</code></td>
<td>
<p>The penalty for the spatial scan statistic.  The
default is 0.5.</p>
</td></tr>
<tr><td><code id="elliptic.sim.adj_+3A_pen">pen</code></td>
<td>
<p>The eccentricity penalty for each candidate
zone.</p>
</td></tr>
<tr><td><code id="elliptic.sim.adj_+3A_min.cases">min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td></tr>
<tr><td><code id="elliptic.sim.adj_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
pop &lt;- nydf$pop
enn &lt;- elliptic.nn(coords, pop, ubpop = 0.5)
cases &lt;- floor(nydf$cases)
ty &lt;- sum(cases)
ex &lt;- ty / sum(pop) * pop
yin &lt;- nn.cumsum(enn$nn, cases)
ein &lt;- nn.cumsum(enn$nn, ex)
logein &lt;- log(ein)
logeout &lt;- log(ty - ein)
pen &lt;- elliptic.penalty(0.5, enn$shape_all)
tsim &lt;- elliptic.sim.adj(
  nsim = 3, ex = ex,
  nn = enn$nn, ty = ty,
  logein = logein, logeout = logeout,
  a = 0.5, pen = pen
)
</code></pre>

<hr>
<h2 id='elliptic.test'>Elliptical Spatial Scan Test</h2><span id='topic+elliptic.test'></span>

<h3>Description</h3>

<p><code>elliptic.test</code> performs the elliptical scan test of
Kulldorf et al. (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elliptic.test(
  coords,
  cases,
  pop,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  shape = c(1, 1.5, 2, 3, 4, 5),
  nangle = c(1, 4, 6, 9, 12, 15),
  a = 0.5,
  cl = NULL,
  type = "poisson",
  min.cases = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elliptic.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_shape">shape</code></td>
<td>
<p>The ratios of the major and minor axes of
the desired ellipses.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_nangle">nangle</code></td>
<td>
<p>The number of angles (between 0 and 180) to
consider for each shape.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_a">a</code></td>
<td>
<p>The penalty for the spatial scan statistic.  The
default is 0.5.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="elliptic.test_+3A_min.cases">min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is performed using the spatial scan test based
on the Poisson test statistic and a fixed number of
cases.  Candidate zones are elliptical and extend from the
observed data locations.  The clusters returned are
non-overlapping, ordered from most significant to least
significant.  The first cluster is the most likely to
be a cluster.  If no significant clusters are found, then
the most likely cluster is returned (along with a
warning).
</p>


<h3>Value</h3>

<p>Returns a <code>smerc_cluster</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Kulldorff, M. (1997) A spatial scan
statistic. Communications in Statistics - Theory and
Methods, 26(6): 1481-1496,
&lt;doi:10.1080/03610929708831995&gt;
</p>
<p>Kulldorff, M., Huang, L., Pickle,
L. and Duczmal, L. (2006) An elliptic spatial scan
statistic. Statististics in Medicine, 25:3929-3943.
&lt;doi:10.1002/sim.2490&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- nydf[, c("x", "y")]
## Not run: 
# run only a small number of sims to make example fast
out &lt;- elliptic.test(
  coords = coords,
  cases = floor(nydf$cases),
  pop = nydf$pop, ubpop = 0.1,
  nsim = 19,
  alpha = 0.12)

## End(Not run)
</code></pre>

<hr>
<h2 id='elliptic.zones'>Determine zones for <code>elliptic.test</code></h2><span id='topic+elliptic.zones'></span>

<h3>Description</h3>

<p><code>elliptic.zones</code> constructs the elliptical zones
for <code><a href="#topic+elliptic.test">elliptic.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elliptic.zones(
  coords,
  pop,
  ubpop = 0.5,
  shape = c(1, 1.5, 2, 3, 4, 5),
  nangle = c(1, 4, 6, 9, 12, 15)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elliptic.zones_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="elliptic.zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="elliptic.zones_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="elliptic.zones_+3A_shape">shape</code></td>
<td>
<p>The ratios of the major and minor axes of
the desired ellipses.</p>
</td></tr>
<tr><td><code id="elliptic.zones_+3A_nangle">nangle</code></td>
<td>
<p>The number of angles (between 0 and 180) to
consider for each shape.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with all distinct zones, the associated
shape parameters, and the associated angle parameters.
</p>


<h3>References</h3>

<p>Kulldorff, M., Huang, L., Pickle,
L. and Duczmal, L. (2006) An elliptic spatial scan
statistic. Statististics in Medicine, 25:3929-3943.
&lt;doi:10.1002/sim.2490&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- elliptic.zones(
  coords = coords, pop = nydf$pop,
  shape = 1.5, nangle = 4
)

## End(Not run)

</code></pre>

<hr>
<h2 id='fast.sim'>Perform <code>fast.test</code> on simulated data</h2><span id='topic+fast.sim'></span>

<h3>Description</h3>

<p><code>fast.sim</code> efficiently performs
<code><a href="#topic+fast.test">fast.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+fast.test">fast.test</a></code> function, but is informative for
better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.sim(nsim = 1, ty, ex, pop, ubpop, type = "poisson", cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="fast.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="fast.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="fast.sim_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="fast.sim_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="fast.sim_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="fast.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$pop
ty &lt;- sum(cases)
ex &lt;- ty / sum(pop) * pop
tsim &lt;- fast.sim(1, ty, ex, pop = pop, ubpop = 0.5)
</code></pre>

<hr>
<h2 id='fast.test'>Fast Subset Scan Test</h2><span id='topic+fast.test'></span>

<h3>Description</h3>

<p><code>fast.test</code> performs the fast subset scan test of
Neill (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.test(
  coords,
  cases,
  pop,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  longlat = FALSE,
  cl = NULL,
  type = "poisson"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="fast.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="fast.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="fast.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="fast.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="fast.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="fast.test_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="fast.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="fast.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="fast.test_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is performed using the spatial scan test based
on the Poisson test statistic and a fixed number of
cases.  The windows are based on the Upper Level Sets
proposed by Patil and Taillie (2004).  The clusters
returned are non-overlapping, ordered from most
significant to least significant.  The first cluster is
the most likely to be a cluster.  If no significant
clusters are found, then the most likely cluster is
returned (along with a warning).
</p>


<h3>Value</h3>

<p>Returns a list of length two of class scan. The
first element (clusters) is a list containing the
significant, non-ovlappering clusters, and has the the
following components: </p>
<table>
<tr><td><code>locids</code></td>
<td>
<p>The location ids of
regions in a significant cluster.</p>
</td></tr> <tr><td><code>pop</code></td>
<td>
<p>The total
population in the cluser window.</p>
</td></tr> <tr><td><code>cases</code></td>
<td>
<p>The
observed number of cases in the cluster window.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>The expected number of cases in the
cluster window.</p>
</td></tr> <tr><td><code>smr</code></td>
<td>
<p>Standarized mortaility
ratio (observed/expected) in the cluster window.</p>
</td></tr>
<tr><td><code>rr</code></td>
<td>
<p>Relative risk in the cluster window.</p>
</td></tr>
<tr><td><code>loglikrat</code></td>
<td>
<p>The loglikelihood ratio for the
cluster window (i.e., the log of the test statistic).</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The pvalue of the test statistic
associated with the cluster window.</p>
</td></tr></table>
<p> The second element
of the list is the centroid coordinates.  This is
needed for plotting purposes.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Neill, D. B. (2012), Fast subset scan for
spatial pattern detection. Journal of the Royal
Statistical Society: Series B (Statistical
Methodology), 74: 337-360.
&lt;doi:10.1111/j.1467-9868.2011.01014.x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- fast.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop,
  alpha = 0.05, longlat = TRUE,
  nsim = 49, ubpop = 0.5
)
</code></pre>

<hr>
<h2 id='fast.zones'>Determine sequence of fast subset scan zones</h2><span id='topic+fast.zones'></span>

<h3>Description</h3>

<p><code>fast.zones</code> determines the unique zones obtained by
implementing the fast subset scan method of Neill (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.zones(cases, pop, ubpop = 0.5, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast.zones_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="fast.zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="fast.zones_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="fast.zones_+3A_simple">simple</code></td>
<td>
<p>A logical value indicating whether a simple
version of the fast zones should be returned.  See
Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>simple</code> argument determines the formatting of
the returned zones.  If <code>simple = TRUE</code>, then a
vector containing the sequential indices of the regions
in each successive zones is returned.  If <code>simple =
FALSE</code>, then the complete list of all zones is returned
(which is the standard format of most of the other
<code>*.zones</code> functions.
</p>
<p>The zones returned must have a total population less than
<code>ubpop * sum(pop)</code> of all regions in the study area.
</p>


<h3>Value</h3>

<p>Returns a vector of regions to sequentially and
cumulatively consider for clustering.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Neill, D. B. (2012), Fast subset scan for
spatial pattern detection. Journal of the Royal
Statistical Society: Series B (Statistical
Methodology), 74: 337-360.
&lt;doi:10.1111/j.1467-9868.2011.01014.x&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
cases &lt;- nydf$cases
pop &lt;- nydf$pop
# compare output format
fast.zones(cases, pop, ubpop = 0.05)
fast.zones(cases, pop, ubpop = 0.05, simple = FALSE)
</code></pre>

<hr>
<h2 id='flex_test'>Flexibly-shaped Spatial Scan Test</h2><span id='topic+flex_test'></span>

<h3>Description</h3>

<p><code>flex_test</code> performs the flexibly-shaped scan test
of Tango and Takahashi (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex_test(
  coords,
  cases,
  pop,
  w,
  k = 10,
  ex = sum(cases)/sum(pop) * pop,
  type = "poisson",
  nsim = 499,
  alpha = 0.1,
  longlat = FALSE,
  cl = NULL,
  lonlat = longlat,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flex_test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="flex_test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="flex_test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="flex_test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="flex_test_+3A_k">k</code></td>
<td>
<p>An integer indicating the maximum number of
regions to inclue in a potential cluster.  Default is
10</p>
</td></tr>
<tr><td><code id="flex_test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="flex_test_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="flex_test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="flex_test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="flex_test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="flex_test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="flex_test_+3A_lonlat">lonlat</code></td>
<td>
<p>Deprecated in favor of <code>longlat</code>.</p>
</td></tr>
<tr><td><code id="flex_test_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is performed using the spatial scan test based
on the Poisson test statistic and a fixed number of
cases.  The first cluster is the most likely to be a
cluster.  If no significant clusters are found, then the
most likely cluster is returned (along with a warning).
</p>


<h3>Value</h3>

<p>Returns a list of length two of class scan. The
first element (clusters) is a list containing the
significant, non-ovlappering clusters, and has the the
following components:
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T., &amp; Takahashi, K. (2005). A flexibly
shaped spatial scan statistic for detecting clusters.
International journal of health geographics, 4(1), 11.
Kulldorff, M. (1997) A spatial scan statistic.
Communications in Statistics &ndash; Theory and Methods 26,
1481-1496.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- flex_test(
  coords = coords, cases = floor(nydf$cases),
  w = nyw, k = 3,
  pop = nydf$pop, nsim = 49,
  alpha = 0.12, longlat = TRUE
)

# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='flex_zones'>Determine zones for flexibly shaped spatial scan test</h2><span id='topic+flex_zones'></span>

<h3>Description</h3>

<p><code>flex_zones</code> determines the unique zones to consider
for the flexibly shaped spatial scan test of Tango and
Takahashi (2005).  The algorithm uses a breadth-first
search to find all subgraphs connected to each vertex
(region) in the data set of size <code class="reqn">k</code> or less.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex_zones(
  coords,
  w,
  k = 10,
  longlat = FALSE,
  cl = NULL,
  loop = FALSE,
  verbose = FALSE,
  pfreq = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flex_zones_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="flex_zones_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="flex_zones_+3A_k">k</code></td>
<td>
<p>An integer indicating the maximum number of
regions to inclue in a potential cluster.  Default is
10</p>
</td></tr>
<tr><td><code id="flex_zones_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="flex_zones_+3A_cl">cl</code></td>
<td>
<p>Ignored, but retained for backwards compatibility</p>
</td></tr>
<tr><td><code id="flex_zones_+3A_loop">loop</code></td>
<td>
<p>A logical value indicating whether a loop
should be used to implement the function instead of
<code><a href="pbapply.html#topic+pbapply">pbapply</a></code>.  The default is
<code>FALSE</code>. If <code>TRUE</code>, then memory-saving steps
are also taken.</p>
</td></tr>
<tr><td><code id="flex_zones_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether
progress messages should be provided.
The default is <code>FALSE</code>.  If both <code>loop</code> and
<code>verbose</code> are <code>TRUE</code>, informative messages
are displayed that can be useful for diagnosing where
the sequences of connected subgraphs are slowing down
or having problems.</p>
</td></tr>
<tr><td><code id="flex_zones_+3A_pfreq">pfreq</code></td>
<td>
<p>The frequency that messages are reported
from the loop (if <code>verbose = TRUE</code>). The default
is <code>pfreq = 1</code>, meaning a message is returned for
each index of the loop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of zones to consider for
clustering.  Each element of the list contains a vector
with the location ids of the regions in that zone.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T., &amp; Takahashi, K. (2005). A flexibly
shaped spatial scan statistic for detecting clusters.
International journal of health geographics, 4(1), 11.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- cbind(nydf$x, nydf$y)
zones &lt;- flex_zones(coords, w = nyw, k = 3)
## Not run: 
# see what happens when verbose = TRUE
zones &lt;- flex_zones(coords, w = nyw, k = 3, verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='flex.sim'>Perform <code>flex.test</code> on simualated data</h2><span id='topic+flex.sim'></span>

<h3>Description</h3>

<p><code>flex.sim</code> efficiently performs
<code><a href="#topic+flex.test">flex.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+flex.test">flex.test</a></code> function, but is informative for
better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex.sim(
  nsim = 1,
  zones,
  ty,
  ex,
  type = "poisson",
  ein = NULL,
  eout = NULL,
  tpop = NULL,
  popin = NULL,
  popout = NULL,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flex.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="flex.sim_+3A_zones">zones</code></td>
<td>
<p>A list of zones to compute the test statistic
over for each simulated data set.</p>
</td></tr>
<tr><td><code id="flex.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="flex.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="flex.sim_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="flex.sim_+3A_ein">ein</code></td>
<td>
<p>The expected number of cases in the zone.
Conventionally, this is the estimated overall disease
risk across the study area, multiplied by the total
population size of the zone.</p>
</td></tr>
<tr><td><code id="flex.sim_+3A_eout">eout</code></td>
<td>
<p>The expected number of cases outside the
zone.  This should be <code>ty - ein</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="flex.sim_+3A_tpop">tpop</code></td>
<td>
<p>The total population in the study area.</p>
</td></tr>
<tr><td><code id="flex.sim_+3A_popin">popin</code></td>
<td>
<p>The total population in the zone.</p>
</td></tr>
<tr><td><code id="flex.sim_+3A_popout">popout</code></td>
<td>
<p>The population outside the zone.  This
should be <code>tpop - popin</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="flex.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
zones &lt;- flex.zones(coords, w = nyw, k = 3, longlat = TRUE)
cases &lt;- floor(nydf$cases)
ty &lt;- sum(cases)
ex &lt;- ty / sum(nydf$pop) * nydf$pop
ein &lt;- zones.sum(zones, ex)
tsim &lt;- flex.sim(nsim = 2, zones, ty, ex, ein = ein, eout = ty - ein)
</code></pre>

<hr>
<h2 id='flex.test'>Flexibly-shaped Spatial Scan Test</h2><span id='topic+flex.test'></span>

<h3>Description</h3>

<p><code>flex.test</code> performs the flexibly-shaped scan test
of Tango and Takahashi (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex.test(
  coords,
  cases,
  pop,
  w,
  k = 10,
  ex = sum(cases)/sum(pop) * pop,
  type = "poisson",
  nsim = 499,
  alpha = 0.1,
  longlat = FALSE,
  cl = NULL,
  lonlat = longlat,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flex.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="flex.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="flex.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="flex.test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="flex.test_+3A_k">k</code></td>
<td>
<p>An integer indicating the maximum number of
regions to inclue in a potential cluster.  Default is
10</p>
</td></tr>
<tr><td><code id="flex.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="flex.test_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="flex.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="flex.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="flex.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="flex.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="flex.test_+3A_lonlat">lonlat</code></td>
<td>
<p>Deprecated in favor of <code>longlat</code>.</p>
</td></tr>
<tr><td><code id="flex.test_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is performed using the spatial scan test based
on the Poisson test statistic and a fixed number of
cases.  The first cluster is the most likely to be a
cluster.  If no significant clusters are found, then the
most likely cluster is returned (along with a warning).
</p>


<h3>Value</h3>

<p>Returns a list of length two of class scan. The
first element (clusters) is a list containing the
significant, non-ovlappering clusters, and has the the
following components:
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T., &amp; Takahashi, K. (2005). A flexibly
shaped spatial scan statistic for detecting clusters.
International journal of health geographics, 4(1), 11.
Kulldorff, M. (1997) A spatial scan statistic.
Communications in Statistics &ndash; Theory and Methods 26,
1481-1496.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- flex.test(
  coords = coords, cases = floor(nydf$cases),
  w = nyw, k = 3,
  pop = nydf$pop, nsim = 49,
  alpha = 0.12, longlat = TRUE
)

# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='flex.zones'>Determine zones for flexibly shaped spatial scan test</h2><span id='topic+flex.zones'></span>

<h3>Description</h3>

<p><code>flex.zones</code> determines the unique zones to consider
for the flexibly shaped spatial scan test of Tango and
Takahashi (2005).  The algorithm uses a breadth-first
search to find all subgraphs connected to each vertex
(region) in the data set of size <code class="reqn">k</code> or less.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex.zones(
  coords,
  w,
  k = 10,
  longlat = FALSE,
  cl = NULL,
  loop = FALSE,
  verbose = FALSE,
  pfreq = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flex.zones_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="flex.zones_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="flex.zones_+3A_k">k</code></td>
<td>
<p>An integer indicating the maximum number of
regions to inclue in a potential cluster.  Default is
10</p>
</td></tr>
<tr><td><code id="flex.zones_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="flex.zones_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="flex.zones_+3A_loop">loop</code></td>
<td>
<p>A logical value indicating whether a loop
should be used to implement the function instead of
<code><a href="pbapply.html#topic+pbapply">pbapply</a></code>.  The default is
<code>FALSE</code>. If <code>TRUE</code>, then memory-saving steps
are also taken.</p>
</td></tr>
<tr><td><code id="flex.zones_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether
progress messages should be provided.
The default is <code>FALSE</code>.  If both <code>loop</code> and
<code>verbose</code> are <code>TRUE</code>, informative messages
are displayed that can be useful for diagnosing where
the sequences of connected subgraphs are slowing down
or having problems.</p>
</td></tr>
<tr><td><code id="flex.zones_+3A_pfreq">pfreq</code></td>
<td>
<p>The frequency that messages are reported
from the loop (if <code>verbose = TRUE</code>). The default
is <code>pfreq = 1</code>, meaning a message is returned for
each index of the loop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of zones to consider for
clustering.  Each element of the list contains a vector
with the location ids of the regions in that zone.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T., &amp; Takahashi, K. (2005). A flexibly
shaped spatial scan statistic for detecting clusters.
International journal of health geographics, 4(1), 11.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- cbind(nydf$x, nydf$y)
zones &lt;- flex.zones(coords, w = nyw, k = 3)
## Not run: 
# see what happens when verbose = TRUE
zones &lt;- flex.zones(coords, w = nyw, k = 3, verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='gedist'>Compute distance for geographic coordinates</h2><span id='topic+gedist'></span><span id='topic+eucdist'></span><span id='topic+gcdist'></span>

<h3>Description</h3>

<p><code>gedist</code> computes the distance between the
coordinates in <code>x</code> and <code>y</code>. If <code>y</code> isn't
supplied, then the distances are computed between the
coordinates in <code>x</code> alone. Otherwise, the pairwise
distances between the points in <code>x</code> and <code>y</code> are
computed. If <code>longlat = TRUE</code>, then the great circle
distance is computed. <code>eucdist</code> is a simplified
version of <code>gedist</code> that computes Euclidean
distances alone while <code>gcdist</code> is a simplified
version of <code>gedist</code> that computes great circle
distance alone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gedist(x, y = NULL, longlat = FALSE)

eucdist(x, y = NULL)

gcdist(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gedist_+3A_x">x</code></td>
<td>
<p>A two-dimensional matrix of coordinates.</p>
</td></tr>
<tr><td><code id="gedist_+3A_y">y</code></td>
<td>
<p>A two-dimensional matrix of coordinates.</p>
</td></tr>
<tr><td><code id="gedist_+3A_longlat">longlat</code></td>
<td>
<p>A logical value indicating whether
Euclidean distance (<code>longlat = FALSE</code>) or great
circle distance (<code>longlat = FALSE</code>) should be
computed. The default is <code>longlat = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm used when <code>longlat = TRUE</code> is a C++
port of the C code written by Roger Bivand for the
<code>spDists</code> function in the <code>sp</code> package, which
appears to be based on a special case of the Vincenty
formula with a slight correction based on the WGS84
flattening constant. See
<a href="https://en.wikipedia.org/wiki/Great-circle_distance">https://en.wikipedia.org/wiki/Great-circle_distance</a>.
</p>


<h3>Value</h3>

<p>A matrix of distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords = matrix(runif(10), ncol = 2)
# euclidean distance
d = gedist(coords)
all.equal(d, as.matrix(dist(coords)),
          check.attributes = FALSE)
all.equal(gedist(coords), eucdist(coords))

# great circle distance
all.equal(gedist(coords, longlat = TRUE),
          gcdist(coords))
</code></pre>

<hr>
<h2 id='knn'>K nearest neighbors</h2><span id='topic+knn'></span>

<h3>Description</h3>

<p><code>knn</code> returns the k nearest neighbors of the
n coordinates in <code>coords</code>.  The nearest neighbors
are constructed to be self-inclusive, i.e., an
observations is its closest neighbor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn(coords, longlat = FALSE, k = 1, d = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="knn_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="knn_+3A_k">k</code></td>
<td>
<p>An integer indicating the maximum number of
regions to inclue in a potential cluster.  Default is
10</p>
</td></tr>
<tr><td><code id="knn_+3A_d">d</code></td>
<td>
<p>An n by n distance matrix.  If provided,
this is used instead of computing <code>d</code> based on
<code>coords</code> and <code>longlat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n \times k</code> matrix of nearest neighbors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- nydf[, c("longitude", "latitude")]
knn(coords, longlat = TRUE, k = 4)
</code></pre>

<hr>
<h2 id='lget'>Apply getElement over a list</h2><span id='topic+lget'></span><span id='topic+lgetElement'></span><span id='topic+sget'></span><span id='topic+sgetElement'></span>

<h3>Description</h3>

<p><code>lget</code> or <code>lgetElement</code> applies
<code>getElement</code> to a
list using <code><a href="base.html#topic+lapply">lapply</a></code>. <code>sget</code> and
<code>sgetElement</code> do the same thing with
<code>sapply</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lget(X, name)

lgetElement(X, name)

sget(X, name, simplify = TRUE, USE.NAMES = TRUE)

sgetElement(X, name, simplify = TRUE, USE.NAMES = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lget_+3A_x">X</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="lget_+3A_name">name</code></td>
<td>

<p>A literal character string or a <a href="base.html#topic+name">name</a> (possibly <a href="base.html#topic+backtick">backtick</a>
quoted).  For extraction, this is normally (see under
&lsquo;Environments&rsquo;) partially matched to the <code><a href="base.html#topic+names">names</a></code>
of the object.
</p>
</td></tr>
<tr><td><code id="lget_+3A_simplify">simplify</code></td>
<td>
<p>logical or character string; should the result be
simplified to a vector, matrix or higher dimensional array if
possible?  For <code>sapply</code> it must be named and not abbreviated.
The default value, <code>TRUE</code>, returns a vector or matrix if appropriate,
whereas if <code>simplify = "array"</code> the result may be an
<code><a href="base.html#topic+array">array</a></code> of &ldquo;rank&rdquo;
(<code class="reqn">=</code><code>length(dim(.))</code>) one higher than the result
of <code>FUN(X[[i]])</code>.</p>
</td></tr>
<tr><td><code id="lget_+3A_use.names">USE.NAMES</code></td>
<td>
<p>logical; if <code>TRUE</code> and if <code>X</code> is character,
use <code>X</code> as <code><a href="base.html#topic+names">names</a></code> for the result unless it had names
already.  Since this argument follows <code>...</code> its name cannot
be abbreviated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (<code>lget</code>) or vector (<code>sget</code>)
of the same length as <code>X</code> with the
<code>name</code> parts of each element of <code>X</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- list(
  x = rnorm(5),
  y = letters[c(1:2, 2:1, 3)],
  z = c(TRUE, TRUE, FALSE, TRUE, TRUE)
)
e2 &lt;- list(
  x = rnorm(5),
  y = letters[c(1:4, 1)],
  z = c(FALSE, TRUE, FALSE, TRUE, FALSE)
)
X &lt;- list(e1, e2)
lget(X, name = "x")
sget(X, name = "y")
</code></pre>

<hr>
<h2 id='logical2zones'>Convert logical vector to zone</h2><span id='topic+logical2zones'></span>

<h3>Description</h3>

<p>Convert logical vector to zone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logical2zones(czones, nn, idx = seq_along(nn))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logical2zones_+3A_czones">czones</code></td>
<td>
<p>List of list of logical vectors</p>
</td></tr>
<tr><td><code id="logical2zones_+3A_nn">nn</code></td>
<td>
<p>List of nearest neighbor indices</p>
</td></tr>
<tr><td><code id="logical2zones_+3A_idx">idx</code></td>
<td>
<p>Relevant nn indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of list of zones
</p>

<hr>
<h2 id='mc.pvalue'>Compute Monte Carlo p-value</h2><span id='topic+mc.pvalue'></span>

<h3>Description</h3>

<p><code>mc.pvalue</code> computes the Monte Carlo p-value of each
element of <code>tobs</code> using the relationship
<code>(sum(tsim &gt;= x) + 1)/(nsim + 1)</code> where <code>x</code> is
a specific element of <code>tobs</code> and <code>nsim =
length(tsim)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc.pvalue(tobs, tsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc.pvalue_+3A_tobs">tobs</code></td>
<td>
<p>A vector observed test statistics</p>
</td></tr>
<tr><td><code id="mc.pvalue_+3A_tsim">tsim</code></td>
<td>
<p>A vector of test statistics from simulated
data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mc.pvalue(8:10, 1:9)
</code></pre>

<hr>
<h2 id='mlf.test'>Maxima Likelihood First Scan Test</h2><span id='topic+mlf.test'></span>

<h3>Description</h3>

<p><code>mlf.test</code> implements the Maxima Likelihood First
scan test of Yao et al. (2011), which is actually a
special case of the Dynamic Minimum Spanning Tree of
Assuncao et al. (2006).  Find the single region that
maximizes the likelihood ratio test statistic.  Starting
with this single region as a current zone, new candidate
zones are constructed by combining the current zone with
the connected region that maximizes the likelihood ratio
test statisic.  This procedure is repeated until the
population and/or distance upper bound is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlf.test(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  ubd = 0.5,
  longlat = FALSE,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlf.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="mlf.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="mlf.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="mlf.test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="mlf.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="mlf.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="mlf.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="mlf.test_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="mlf.test_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
<tr><td><code id="mlf.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="mlf.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only a single candidate zone is ever returned because the
algorithm only constructs a single sequence of starting
zones, and overlapping zones are not returned.  Only the
zone that maximizes the likelihood ratio test statistic
is returned.
</p>


<h3>Value</h3>

<p>Returns a list of length two of class scan. The
first element (clusters) is a list containing the
significant, non-ovlappering clusters, and has the the
following components: </p>
<table>
<tr><td><code>locids</code></td>
<td>
<p>The location ids of
regions in a significant cluster.</p>
</td></tr> <tr><td><code>pop</code></td>
<td>
<p>The total
population in the cluser window.</p>
</td></tr> <tr><td><code>cases</code></td>
<td>
<p>The
observed number of cases in the cluster window.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>The expected number of cases in the
cluster window.</p>
</td></tr> <tr><td><code>smr</code></td>
<td>
<p>Standarized mortaility
ratio (observed/expected) in the cluster window.</p>
</td></tr>
<tr><td><code>rr</code></td>
<td>
<p>Relative risk in the cluster window.</p>
</td></tr>
<tr><td><code>loglikrat</code></td>
<td>
<p>The loglikelihood ratio for the
cluster window (i.e., the log of the test statistic).</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The pvalue of the test statistic
associated with the cluster window.</p>
</td></tr> <tr><td><code>w</code></td>
<td>
<p>The
adjacency matrix of the cluster.</p>
</td></tr> <tr><td><code>r</code></td>
<td>
<p>The maximum
radius of the cluster (in terms of intercentroid
distance from the starting region).</p>
</td></tr></table>
<p> The second element
of the list is the centroid coordinates.  This is
needed for plotting purposes.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Yao, Z., Tang, J., &amp; Zhan, F. B. (2011).
Detection of arbitrarily-shaped clusters using a
neighbor-expanding approach: A case study on murine
typhus in South Texas. International journal of health
geographics, 10(1), 1.
</p>
<p>Assuncao, R.M., Costa, M.A., Tavares, A. and Neto,
S.J.F. (2006). Fast detection of arbitrarily shaped
disease clusters, Statistics in Medicine, 25, 723-742.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- mlf.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, w = nyw,
  alpha = 0.12, longlat = TRUE,
  nsim = 10, ubpop = 0.1, ubd = 0.5
)
plot(out)
</code></pre>

<hr>
<h2 id='mlf.zones'>Determine zones for the maxima likelihood
first algorithm.</h2><span id='topic+mlf.zones'></span>

<h3>Description</h3>

<p><code>mlf.zones</code> determines the most likely cluster zone
obtained by implementing the maxima likelihood first
scann method of Yao et al. (2011).  Note that this is
really just a special case of the dynamic minimum
spanning tree (DMST) algorithm of Assuncao et al. (2006)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlf.zones(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  ubpop = 0.5,
  ubd = 1,
  longlat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlf.zones_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="mlf.zones_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="mlf.zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="mlf.zones_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="mlf.zones_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="mlf.zones_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="mlf.zones_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
<tr><td><code id="mlf.zones_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each step of the mlf scan test seeks to maximize the
likelihood ratio test statistic used in the original
spatial scan test (Kulldorff 1997).  The first zone
considered is the region that maximizes this likelihood
ration test statistic, providing that no more than
<code>ubpop</code> proportion of the total population is in the
zone.  The second zone is the first zone and the
connected region that maximizes the scan statistic,
subject to the population and distance constraints.  This
pattern continues until no additional zones can be added
due to population or distance constraints.
</p>
<p>Every zone considered must have a total population less
than <code>ubpop * sum(pop)</code> in the study area.
Additionally, the maximum intercentroid distance for the
regions within a zone must be no more than <code>ubd *
the maximum intercentroid distance across all regions</code>.
</p>


<h3>Value</h3>

<p>Returns a list with elements: </p>
<table>
<tr><td><code>zones</code></td>
<td>
<p>A list
contained the location ids of each potential cluster.</p>
</td></tr>
<tr><td><code>loglikrat</code></td>
<td>
<p>The loglikelihood ratio for each zone
(i.e., the log of the test statistic).</p>
</td></tr>
<tr><td><code>cases</code></td>
<td>
<p>The observed number of cases in each
zone.</p>
</td></tr> <tr><td><code>expected</code></td>
<td>
<p>The expected number of cases
each zone.</p>
</td></tr> <tr><td><code>pop</code></td>
<td>
<p>The total population in each
zone.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Yao, Z., Tang, J., &amp; Zhan, F. B. (2011).
Detection of arbitrarily-shaped clusters using a
neighbor-expanding approach: A case study on murine
typhus in South Texas. International Journal of Health
Geographics, 10(1), 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- as.matrix(nydf[, c("x", "y")])
mlf.zones(coords,
  cases = floor(nydf$cases),
  pop = nydf$pop, w = nyw, longlat = TRUE
)
</code></pre>

<hr>
<h2 id='mlink.sim'>Perform <code>mlink.test</code> on simulated data</h2><span id='topic+mlink.sim'></span>

<h3>Description</h3>

<p><code>mlink.sim</code> efficiently performs
<code><a href="#topic+mlink.test">mlink.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+mlink.test">mlink.test</a></code> function, but is informative for
better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlink.sim(nsim = 1, nn, ty, ex, w, pop, max_pop, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlink.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="mlink.sim_+3A_nn">nn</code></td>
<td>
<p>A list of distance-based nearest neighbors,
preferably from the <code><a href="#topic+nndist">nndist</a></code> function.</p>
</td></tr>
<tr><td><code id="mlink.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="mlink.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="mlink.sim_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="mlink.sim_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="mlink.sim_+3A_max_pop">max_pop</code></td>
<td>
<p>The population upperbound (in total
population) for a candidate zone.</p>
</td></tr>
<tr><td><code id="mlink.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$pop
ty &lt;- sum(cases)
ex &lt;- ty / sum(pop) * pop
d &lt;- gedist(coords, longlat = TRUE)
nn &lt;- nndist(d, ubd = 0.05)
max_pop &lt;- sum(pop) * 0.25
tsim &lt;- mlink.sim(1, nn, ty, ex, nyw,
  pop = pop,
  max_pop = max_pop
)
</code></pre>

<hr>
<h2 id='mlink.test'>Maximum Linkage spatial scan test</h2><span id='topic+mlink.test'></span>

<h3>Description</h3>

<p><code>mlink.test</code> implements the Maximum Linkage spatial
scan test of Costa et al. (2012). Starting with a single
region as a current zone, new candidate zones are
constructed by combining the current zone with the
connected region that maximizes the resulting likelihood
ratio test statistic, with the added constraint that the
region has the maximum connections (i.e., shares a border
with) with the regions in the current zone.  This
procedure is repeated until the population or distance
upper bounds constraints are reached.  The same procedure
is repeated for each region.  The clusters returned are
non-overlapping, ordered from most significant to least
significant. The first cluster is the most likely to be a
cluster. If no significant clusters are found, then the
most likely cluster is returned (along with a warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlink.test(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  ubd = 1,
  longlat = FALSE,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlink.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="mlink.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="mlink.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="mlink.test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="mlink.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="mlink.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="mlink.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="mlink.test_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="mlink.test_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
<tr><td><code id="mlink.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="mlink.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum intercentroid distance can be found by
executing the command:
<code>gedist(as.matrix(coords), longlat = longlat)</code>,
based on the specified values of <code>coords</code> and
<code>longlat</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>smerc_cluster</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Costa, M.A. and Assuncao, R.M. and Kulldorff,
M. (2012) Constrained spanning tree algorithms for
irregularly-shaped spatial clustering, Computational
Statistics &amp; Data Analysis, 56(6), 1771-1783.
&lt;doi:10.1016/j.csda.2011.11.001&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- mlink.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, w = nyw,
  alpha = 0.12, longlat = TRUE,
  nsim = 2, ubpop = 0.05, ubd = 0.1
)
# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='mlink.zones'>Determine zones for the Maximum Linkage scan test</h2><span id='topic+mlink.zones'></span>

<h3>Description</h3>

<p><code>mlink.zones</code> determines the zones for the Maximum
Linkage scan test (<code><a href="#topic+mlink.test">mlink.test</a></code>).  The
function returns the zones, as well as the associated
test statistic, cases in each zone, the expected number
of cases in each zone, and the population in each zone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlink.zones(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  ubpop = 0.5,
  ubd = 1,
  longlat = FALSE,
  cl = NULL,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlink.zones_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="mlink.zones_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="mlink.zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="mlink.zones_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="mlink.zones_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="mlink.zones_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="mlink.zones_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
<tr><td><code id="mlink.zones_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="mlink.zones_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="mlink.zones_+3A_progress">progress</code></td>
<td>
<p>A logical value indicating whether a
progress bar should be displayed.  The default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every zone considered must have a total population less
than <code>ubpop * sum(pop)</code>.  Additionally, the maximum
intercentroid distance for the regions within a zone must
be no more than <code>ubd * the maximum intercentroid
distance across all regions</code>.
</p>


<h3>Value</h3>

<p>Returns a list with elements: </p>
<table>
<tr><td><code>zones</code></td>
<td>
<p>A list
contained the location ids of each potential cluster.</p>
</td></tr>
<tr><td><code>loglikrat</code></td>
<td>
<p>The loglikelihood ratio for each zone
(i.e., the log of the test statistic).</p>
</td></tr>
<tr><td><code>cases</code></td>
<td>
<p>The observed number of cases in each
zone.</p>
</td></tr> <tr><td><code>expected</code></td>
<td>
<p>The expected number of cases
each zone.</p>
</td></tr> <tr><td><code>pop</code></td>
<td>
<p>The total population in each
zone.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Costa, M.A. and Assuncao, R.M. and Kulldorff, M. (2012)
Constrained spanning tree algorithms for
irregularly-shaped spatial clustering, Computational
Statistics &amp; Data Analysis, 56(6), 1771-1783.
&lt;doi:10.1016/j.csda.2011.11.001&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
# find zone with max statistic starting from each individual region
all_zones &lt;- mlink.zones(coords,
  cases = floor(nydf$cases),
  nydf$pop, w = nyw, ubpop = 0.25,
  ubd = .25, longlat = TRUE
)
</code></pre>

<hr>
<h2 id='morancr.sim'>Constant-risk Moran's I statistic</h2><span id='topic+morancr.sim'></span>

<h3>Description</h3>

<p><code>morancr.stat</code> computes the constant-risk version of the Moran's I
statistic proposed by Walter (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morancr.sim(nsim = 1, cases, w, ex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="morancr.sim_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="morancr.sim_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="morancr.sim_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="morancr.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Walter, S. D. (1992). The analysis of regional patterns in health
data: I. Distributional considerations. American Journal of Epidemiology,
136(6), 730-741.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+morancr.test">morancr.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
ex &lt;- sum(nydf$cases) / sum(nydf$pop) * nydf$pop
morancr.sim(nsim = 10, cases = nydf$cases, w = nyw, ex = ex)
</code></pre>

<hr>
<h2 id='morancr.stat'>Constant-risk Moran's I statistic</h2><span id='topic+morancr.stat'></span>

<h3>Description</h3>

<p><code>morancr.stat</code> computes the constant-risk version of the Moran's I
statistic proposed by Walter (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morancr.stat(cases, w, ex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="morancr.stat_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="morancr.stat_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="morancr.stat_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Walter, S. D. (1992). The analysis of regional patterns in health
data: I. Distributional considerations. American Journal of Epidemiology,
136(6), 730-741.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+morancr.test">morancr.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
ex &lt;- sum(nydf$cases) / sum(nydf$pop) * nydf$pop
morancr.stat(cases = nydf$cases, w = nyw, ex = ex)
</code></pre>

<hr>
<h2 id='morancr.test'>Constant-risk Moran's I-based test</h2><span id='topic+morancr.test'></span>

<h3>Description</h3>

<p><code>morancr.test</code> performs a test of clustering using the constant-risk
version of the Moran's I statistic proposed by Walter (1992) under the
constant risk hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morancr.test(
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alternative = "greater"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="morancr.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="morancr.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="morancr.test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="morancr.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="morancr.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="morancr.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of &quot;greater&quot; (default), &quot;two.sided&quot;, or &quot;less&quot;. You can specify
just the initial letter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>smerc_similarity_test</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Walter, S. D. (1992). The analysis of regional patterns in health
data: I. Distributional considerations. American Journal of Epidemiology,
136(6), 730-741.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+morancr.stat">morancr.stat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
morancr.test(cases = nydf$cases, pop = nydf$pop, w = nyw, nsim = 9)
</code></pre>

<hr>
<h2 id='mst.all'>Minimum spanning tree for all regions</h2><span id='topic+mst.all'></span>

<h3>Description</h3>

<p><code>mst.all</code> finds the set of connected regions that
maximize the spatial scan statistic (the likelihood ratio
test statistic) from each starting region, subject to
relevant constraints.  The function can be used to
construct candidate zones for the dynamic minimum
spanning tree (dmst), early stopping dynamic minimum
spanning tree (edmst), double connected spatial scan test
(dc), and maximum linkage (mlink) spatial scan test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mst.all(
  neighbors,
  cases,
  pop,
  w,
  ex,
  ty,
  max_pop,
  type = "maxonly",
  nlinks = "one",
  early = FALSE,
  cl = NULL,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mst.all_+3A_neighbors">neighbors</code></td>
<td>
<p>A list containing the vector of
neighbors for each region (in ascending order of
distance from the region).  The starting region itself
is included among the neighbors.</p>
</td></tr>
<tr><td><code id="mst.all_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="mst.all_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="mst.all_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="mst.all_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="mst.all_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="mst.all_+3A_max_pop">max_pop</code></td>
<td>
<p>The population upperbound (in total
population) for a candidate zone.</p>
</td></tr>
<tr><td><code id="mst.all_+3A_type">type</code></td>
<td>
<p>One of <code>"maxonly"</code>, <code>"pruned"</code>, or
<code>"all"</code>.  See Details.</p>
</td></tr>
<tr><td><code id="mst.all_+3A_nlinks">nlinks</code></td>
<td>
<p>A character vector.  The options are
<code>"one"</code>, <code>"two"</code>, or <code>"max"</code>.  See
Details.</p>
</td></tr>
<tr><td><code id="mst.all_+3A_early">early</code></td>
<td>
<p>A logical value indicating whether the
&quot;early&quot; stopping criterion should be used.  If
<code>TRUE</code>, each sequence is stopped when the next
potential zone doesn't produce a test statistic larger
than the current zone. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mst.all_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="mst.all_+3A_progress">progress</code></td>
<td>
<p>A logical value indicating whether a
progress bar should be displayed.  The default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not intended to be used by users
directly. Consequently, it prioritizes efficiency over
user friendliness.
</p>
<p><code>type</code> is a character vector indicating what should
be returned by the function.  If <code>type = "maxonly"</code>,
then the maximum test statistic from each starting region
is returned .  If <code>type = "pruned"</code>, the function
returns a list that includes the location ids, test
statistic, total cases, expected cases, and total
population for the zone with the maximum test statistic
for each starting region.  If <code>type = "all"</code>, the
function returns a list of lists that includes the
location ids, test statistic, total cases, expected
cases, and total population for the sequence of candidate
zones associated with each starting region.
</p>
<p>If <code>nlinks = "one"</code>, then a region only needs to be
connected to one other region in the current zone to be
considered for inclusion in the next zone.  If
<code>nlinks = "two"</code>, then the region must be connected
to at least two other regions in the current zone.  If
<code>nlinks = "max"</code>, then only regions with the maximum
number of connections to the current zone are considered
for inclusion in the next zone.
</p>


<h3>Value</h3>

<p>Returns a list of relevant information.  See
Details.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Assuncao, R.M., Costa, M.A., Tavares, A. and
Neto, S.J.F. (2006). Fast detection of arbitrarily
shaped disease clusters, Statistics in Medicine, 25,
723-742.  &lt;doi:10.1002/sim.2411&gt;
</p>
<p>Costa, M.A. and Assuncao, R.M. and Kulldorff, M. (2012)
Constrained spanning tree algorithms for
irregularly-shaped spatial clustering, Computational
Statistics &amp; Data Analysis, 56(6), 1771-1783.
&lt;doi:10.1016/j.csda.2011.11.001&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(nydf)
data(nyw)

# create relevant data
coords &lt;- nydf[, c("longitude", "latitude")]
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$population
w &lt;- nyw
ex &lt;- sum(cases) / sum(pop) * pop
ubpop &lt;- 0.5
ubd &lt;- 0.5
ty &lt;- sum(cases) # total number of cases
# intercentroid distances
d &lt;- gedist(as.matrix(coords), longlat = TRUE)
# upperbound for population in zone
max_pop &lt;- ubpop * sum(pop)
# upperbound for distance between centroids in zone
max_dist &lt;- ubd * max(d)
# create list of neighbors for each region
# (inclusive of region itself)
all_neighbors &lt;- nndist(d, ubd)
# find the dmst max zone
## Not run: 
out &lt;- mst.all(all_neighbors, cases, pop, w, ex, ty, max_pop,
  type = "maxonly"
)
head(out)

out &lt;- mst.all(all_neighbors, cases, pop, w, ex, ty, max_pop,
  type = "pruned"
)
head(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='mst.seq'>Minimum spanning tree sequence</h2><span id='topic+mst.seq'></span>

<h3>Description</h3>

<p><code>mst.seq</code> finds the sequence of connected regions
that maximize the spatial scan statistic (the likelihood
ratio test statistic) from a starting region. The set of
connected regions at each step is a candidate zone. The
zone continues to grow until no region should be added to
the zone due to relevant constraints (size, connectivity,
or other stopping criteria).  This function is not
intended to be used by users directly, but it can be
quite educational for seeing the spread of the cluster.
Consequently, it prioritizes efficiency over user
friendliness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mst.seq(
  start,
  neighbors,
  cases,
  pop,
  w,
  ex,
  ty,
  max_pop,
  type = "maxonly",
  nlinks = "one",
  early = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mst.seq_+3A_start">start</code></td>
<td>
<p>The initial region to start the candidate
zone.</p>
</td></tr>
<tr><td><code id="mst.seq_+3A_neighbors">neighbors</code></td>
<td>
<p>A vector containing the neighbors for
the starting region (in ascending order of distance
from the region).  The staring region itself is
included among the neighbors.</p>
</td></tr>
<tr><td><code id="mst.seq_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="mst.seq_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="mst.seq_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="mst.seq_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="mst.seq_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="mst.seq_+3A_max_pop">max_pop</code></td>
<td>
<p>The population upperbound (in total
population) for a candidate zone.</p>
</td></tr>
<tr><td><code id="mst.seq_+3A_type">type</code></td>
<td>
<p>One of <code>"maxonly"</code>, <code>"pruned"</code>, or
<code>"all"</code>.  The default is <code>"maxonly"</code>.  See
Details.</p>
</td></tr>
<tr><td><code id="mst.seq_+3A_nlinks">nlinks</code></td>
<td>
<p>A character vector.  The options are
<code>"one"</code>, <code>"two"</code>, or <code>"max"</code>.  See
Details.</p>
</td></tr>
<tr><td><code id="mst.seq_+3A_early">early</code></td>
<td>
<p>A logical value indicating whether the
&quot;early&quot; stopping criterion should be used.  If
<code>TRUE</code>, the sequence is stopped when the next
potential zone doesn't produce a test statistic larger
than the current zone. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used to construct candidate zones for
the dynamic minimum spanning tree (dmst), early stopping
dynamic minimum spanning tree (edmst), double connection
spatial scan test (dc), and maximum linkage spatial scan
test (mlink).
</p>
<p><code>type</code> is a character vector indicating what should
be returned by the function.  If <code>type = "maxonly"</code>,
then only the maximum of the log likelihood ratio test
statistic across all candidate zones is returned.  If
<code>type = "pruned"</code>,, the function returns a list that
includes the location ids, test statistic, total cases,
expected cases, and total population for the zone with
the maximum test statistic.  It <code>type = "all"</code>, the
same information the same information is returned for the
entire sequence of zones.
</p>
<p>If <code>nlinks = "one"</code>, then a region only needs to be
connected to one other region in the current zone to be
considered for inclusion in the next zone.  If
<code>nlinks = "two"</code>, then the region must be connected
to at least two other regions in the current zone.  If
<code>nlinks = "max"</code>, then only regions with the maximum
number of connections to the current zone are considered
for inclusion in the next zone.
</p>


<h3>Value</h3>

<p>Returns a list of relevant information.  See
Details.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(nydf)
data(nyw)

# create relevant data
coords &lt;- nydf[, c("longitude", "latitude")]
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$population
w &lt;- nyw
ex &lt;- sum(cases) / sum(pop) * pop
ubpop &lt;- 0.5
ubd &lt;- 0.5
ty &lt;- sum(cases) # total number of cases
# intercentroid distances
d &lt;- gedist(as.matrix(coords), longlat = TRUE)
# upperbound for population in zone
max_pop &lt;- ubpop * sum(pop)
# upperbound for distance between centroids in zone
max_dist &lt;- ubd * max(d)
# create list of neighbors for each region (inclusive of region itself)
all_neighbors &lt;- nndist(d, ubd)
# find the dmst max zone
mst.seq(
  start = 1, all_neighbors[[1]], cases, pop, w, ex,
  ty, max_pop
)
mst.seq(
  start = 1, all_neighbors[[1]], cases, pop, w, ex,
  ty, max_pop, "pruned"
)
bigout &lt;- mst.seq(
  start = 1, all_neighbors[[1]], cases, pop,
  w, ex, ty, max_pop, "all"
)
head(bigout)
</code></pre>

<hr>
<h2 id='nclusters'>Number of clusters</h2><span id='topic+nclusters'></span>

<h3>Description</h3>

<p><code>nclusters</code> returns the number of clusters
identified in a <code>smerc_cluster</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nclusters(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nclusters_+3A_x">x</code></td>
<td>
<p>A <code>smerc_cluster object</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A non-negative integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- scan.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, nsim = 19,
  alpha = 0.3, longlat = TRUE
)
nclusters(out)
</code></pre>

<hr>
<h2 id='neast'>Breast cancer mortality in the Northeastern United States</h2><span id='topic+neast'></span>

<h3>Description</h3>

<p>An <code><a href="sf.html#topic+sf">sf</a></code> object containing data related to
breast cancer mortality in the Northeastern United
States.  The data include several variables observed for
245 counties (or similar) as well polygon information defined using
longitude/latitude coordinates in the WGS84 coordinate
system. The following variables are included in the
object:
</p>

<ul>
<li> <p><code>id</code>: A name-based id for each county.
</p>
</li>
<li> <p><code>cases</code>: The number of breast cancer
mortality cases between 1988-1992.
</p>
</li>
<li> <p><code>population</code>: The number of residents in the county
based on 1990 U.S. census results.
</p>
</li>
<li> <p><code>x</code>: An x coordinate of a centroid associated
with each county provided by Kulldorff et al. (2003). See
Details.
</p>
</li>
<li> <p><code>y</code>: A y coordinate of a centroid associated
with each county provided by Kulldorff et al. (2003). See
Details.
</p>
</li></ul>



<h3>Details</h3>

<p>The <code>x</code> and <code>y</code> coordinates define centroids
associated with each county. The coordinates were
provided by Kulldorf et al. (2003). They are appropriate
for computing standard Euclidean intercentroid distance
between counties but are not consistent with the polygon
geometry of the data set.  The coordinate system
of these coordinates is unknown.
</p>
<p>Alternative centroids for the geometry can be obtained
using the following commands.
</p>
<p><code>sf::sf_use_s2(FALSE)</code> <br />
<code>pts &lt;- sf::st_centroid(sf::st_geometry(neast))</code>
</p>


<h3>References</h3>

<p>Martin Kulldorff, Eric J. Feuer, Barry A.
Miller, Laurence S. Freedman; Breast Cancer Clusters in
the Northeast United States: A Geographic Analysis,
American Journal of Epidemiology, Volume 146, Issue 2,
15 July 1997, Pages 161–170.
<a href="https://doi.org/10.1093/oxfordjournals.aje.a009247">doi:10.1093/oxfordjournals.aje.a009247</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(sf)) {
data(neast)
plot(st_geometry(neast))
plot(neast["cases"])
}
</code></pre>

<hr>
<h2 id='neastw'>Binary adjacency matrix for <code>neast</code></h2><span id='topic+neastw'></span>

<h3>Description</h3>

<p>A binary adjacency matrix for the <code>neast</code> data set.
Some of the islands (e.g., Nantucket) are considered
adjacent to the mainland because of ferries traveling
from certain mainland regions to these islands. Manual
connections were added for many of the New York counties
because they are on islands.
</p>


<h3>References</h3>

<p>Martin Kulldorff, Eric J. Feuer, Barry A.
Miller, Laurence S. Freedman; Breast Cancer Clusters in
the Northeast United States: A Geographic Analysis,
American Journal of Epidemiology, Volume 146, Issue 2,
15 July 1997, Pages 161–170.
<a href="https://doi.org/10.1093/oxfordjournals.aje.a009247">doi:10.1093/oxfordjournals.aje.a009247</a>.
</p>


<h3>See Also</h3>

<p>neast
</p>

<hr>
<h2 id='nn.cumsum'>Cumulative sum over nearest neighbors</h2><span id='topic+nn.cumsum'></span>

<h3>Description</h3>

<p><code>nn.cumsum</code> computes the cumulative sum of <code>y</code>
for the sequences of indices in each element of the list
contained in <code>nn</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nn.cumsum(nn, y, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nn.cumsum_+3A_nn">nn</code></td>
<td>
<p>A list of nearest neighbors in the format
produced by <code><a href="#topic+nnpop">nnpop</a></code>.</p>
</td></tr>
<tr><td><code id="nn.cumsum_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to be summed over.</p>
</td></tr>
<tr><td><code id="nn.cumsum_+3A_simplify">simplify</code></td>
<td>
<p>A logical value indicating whether the
results should be simplified to a numeric vector.  The
default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or list, depending on the value of
<code>simplify</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># show nn.cumsum example for a circular scan setting
data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
cases &lt;- floor(nydf$cases)
d &lt;- gedist(coords, longlat = TRUE)
# compute circular nearest neigbhors
nn &lt;- nnpop(d, pop = nydf$pop, ubpop = 0.1)
# compute cumulative sums over all nn
cnn &lt;- nn.cumsum(nn, cases)
# compute cumulative sums over just the first set of nn
cnn1 &lt;- cumsum(cases[nn[[1]]])
# check equality
all.equal(cnn1, cnn[seq_along(cnn1)])
</code></pre>

<hr>
<h2 id='nn2zones'>Convert nearest neighbors list to zones</h2><span id='topic+nn2zones'></span>

<h3>Description</h3>

<p><code>nn2zones</code> converts a list of nearest neighbors to
a list of zones.  The list of nearest neighbors will
come from functions such as <code><a href="#topic+nnpop">nnpop</a></code> or
<code>knn</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nn2zones(nn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nn2zones_+3A_nn">nn</code></td>
<td>
<p>A list of nearest neighbors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of zones
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(x, y))
nn &lt;- knn(coords, k = 2)
nn2zones(nn)
</code></pre>

<hr>
<h2 id='nndist'>Determine nearest neighbors based on maximum distance</h2><span id='topic+nndist'></span>

<h3>Description</h3>

<p><code>nndist</code> determines the nearest
neighbors for a set of observations within a certain
radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nndist(d, ubd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nndist_+3A_d">d</code></td>
<td>
<p>An <code class="reqn">n\times n</code> square distance matrix
containing the intercentroid distance between the
<code class="reqn">n</code> region centroids.</p>
</td></tr>
<tr><td><code id="nndist_+3A_ubd">ubd</code></td>
<td>
<p>A proportion in (0, 1].  The distance of
potential clusters must be no more than <code>ubd * m</code>,
where <code>m</code> is the maximum intercentroid distance
between all coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines the nearest neighbors of each
centroid based on the intercentroid distance.  The number
of nearest neighbors is limited by the furthest distance
between the starting centroid and the farthest neighbor.
</p>


<h3>Value</h3>

<p>Returns the indices of the nearest neighbors as a
list.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
d &lt;- as.matrix(dist(coords))
nn &lt;- nndist(d, ubd = 0.01)
</code></pre>

<hr>
<h2 id='nndup'>Determine duplicates in nearest neighbor list</h2><span id='topic+nndup'></span>

<h3>Description</h3>

<p><code>nndup</code> determines the indices of duplicated
elements for a nearest neighbors list created by a
function such as <code><a href="#topic+nnpop">nnpop</a></code> or
<code><a href="#topic+knn">knn</a></code>.  The indices are related to the list
returned by <code><a href="#topic+nn2zones">nn2zones</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nndup(nn, N = max(unlist(nn)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nndup_+3A_nn">nn</code></td>
<td>
<p>A list of nearest neighbors.</p>
</td></tr>
<tr><td><code id="nndup_+3A_n">N</code></td>
<td>
<p>The largest value in <code>nn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of indicating duplicate indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nn &lt;- list(1:3, c(2:1, 4))
nndup(nn, 4)
</code></pre>

<hr>
<h2 id='nnpop'>Determine nearest neighbors with population constraint</h2><span id='topic+nnpop'></span><span id='topic+scan.nn'></span>

<h3>Description</h3>

<p><code>scan.nn</code> determines the nearest
neighbors for a set of observations based on the
distance matrix according to a population-based
upperbound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnpop(d, pop, ubpop)

scan.nn(d, pop, ubpop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnpop_+3A_d">d</code></td>
<td>
<p>An <code class="reqn">n\times n</code> square distance matrix
containing the intercentroid distance between the
<code class="reqn">n</code> region centroids.</p>
</td></tr>
<tr><td><code id="nnpop_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="nnpop_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines the nearest neighbors of each
centroid based on the intercentroid distance.  The number
of nearest neighbors is limited by the sum of the
population values among the nearest neighbors.  The set
of nearest neighbors can contain no more than <code>ubpop
* sum(pop)</code> members of the population.  The nearest
neighbors are ordered from nearest to farthest.
</p>


<h3>Value</h3>

<p>Returns the indices of the nearest neighbors as a
list.  For each element of the list, the indices are
ordered from nearest to farthest from each centroid.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
d &lt;- as.matrix(dist(coords))
nn &lt;- scan.nn(d, pop = nydf$pop, ubpop = 0.1)
</code></pre>

<hr>
<h2 id='noc_enn'>Returned ordered non-overlapping clusters</h2><span id='topic+noc_enn'></span>

<h3>Description</h3>

<p><code>noc_nn</code> returns the non-overlapping clusters
ordered by the values on <code>tobs_nn</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noc_enn(nn, tobs_nn, shape_nn, angle_nn, nnoc = length(nn))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noc_enn_+3A_nn">nn</code></td>
<td>
<p>A nearest neighbor list.</p>
</td></tr>
<tr><td><code id="noc_enn_+3A_tobs_nn">tobs_nn</code></td>
<td>
<p>The test statistics for each sequence
candidate zone.</p>
</td></tr>
<tr><td><code id="noc_enn_+3A_nnoc">nnoc</code></td>
<td>
<p>The number of non-overlapping clusters to
return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>clusts</code>, a list with elements
containing the non-overlapping clusters, and
<code>tobs</code>, the associated test statistic for each
cluster.
</p>

<hr>
<h2 id='noc_nn'>Returned ordered non-overlapping clusters</h2><span id='topic+noc_nn'></span>

<h3>Description</h3>

<p><code>noc_nn</code> returns the non-overlapping clusters
ordered by the values on <code>tobs_nn</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noc_nn(nn, tobs_nn, nnoc = length(nn))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noc_nn_+3A_nn">nn</code></td>
<td>
<p>A nearest neighbor list.</p>
</td></tr>
<tr><td><code id="noc_nn_+3A_tobs_nn">tobs_nn</code></td>
<td>
<p>The test statistics for each sequence
candidate zone.</p>
</td></tr>
<tr><td><code id="noc_nn_+3A_nnoc">nnoc</code></td>
<td>
<p>The number of non-overlapping clusters to
return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>clusts</code>, a list with elements
containing the non-overlapping clusters, and
<code>tobs</code>, the associated test statistic for each
cluster.
</p>

<hr>
<h2 id='noz'>Determine non-overlapping zones</h2><span id='topic+noz'></span>

<h3>Description</h3>

<p>Determine non-overlapping zones from a list of
candidate zones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noz(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noz_+3A_x">x</code></td>
<td>
<p>A list containing the candidate zones.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes a list of candidate zones. Each
element of the list contains a candidate zones. The
candidate zones are defined by the location indices of
the regions comprising the zones.  Starting with the
first candidate zone, the function excludes every
candidate zone that intersects the first (any other
candidate zone that shares indices with the first zone).
Moving onto the next non-overlapping candidate zone,
the process is repeated.
The function returns the indices (in the list of
zones) of the zones that do not overlap.
</p>


<h3>Value</h3>

<p>A vector with the list indices of the
non-overlapping zones.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(1:2, 1:3, 4:5, 4:6, 7:8)
noz(x)
</code></pre>

<hr>
<h2 id='nydf'>Leukemia data for 281 regions in New York.</h2><span id='topic+nydf'></span>

<h3>Description</h3>

<p>This data set contains 281 observations
related to leukeumia cases in an 8 county area of the
state of New York.  The data were made available in Waller
and Gotway (2005) and details are provided there.
These data are related to a similar data set in Waller et
al. (1994).  The longitude and latitude coordinates are
taken from the NYleukemia data set in the SpatialEpi
package for plotting purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nydf)
</code></pre>


<h3>Format</h3>

<p>A data frame with 281 rows and 4 columns:
</p>

<dl>
<dt>longitude</dt><dd><p>The longitude of the region centroid.
These are NOT the original values provided by Waller and
Gotway (2005), but are the right ones for plotting correctly.</p>
</dd>
<dt>latitude</dt><dd><p>The latitude of the region centroid.
These are NOT the original values provided by Waller and
Gotway (2005), but are the right ones for plotting
correctly.</p>
</dd>
<dt>population</dt><dd><p>The population (1980 census) of the region.</p>
</dd>
<dt>cases</dt><dd><p>The number of leukemia cases between 1978-1982.</p>
</dd>
<dt>x</dt><dd><p>The original 'longitude' coordinate provided by
Waller and Gotway (2005).</p>
</dd>
<dt>y</dt><dd><p>The original 'latitude' coordinate provided by
Waller and Gotway (2005).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Waller, L.A. and Gotway, C.A. (2005).
Applied Spatial Statistics for Public Health Data.
Hoboken, NJ: Wiley.
</p>


<h3>References</h3>

<p>Waller, L.A., Turnbull, B.W., Clark, L.C.,
and Nasca, P. (1994) &quot;Spatial Pattern Analysis to Detect
Rare Disease Clusters&quot; in Case Studies in Biometry, N. Lange,
L. Ryan, L. Billard, D. Brillinger, L. Conquest, and
J. Greenhouse (eds.) New York: John Wiley and Sons.
</p>

<hr>
<h2 id='nypoly'><code>SpatialPolygons</code> object for New York
leukemia data.</h2><span id='topic+nypoly'></span>

<h3>Description</h3>

<p>A <code>SpatialPolygons</code> object for the
New York leukemia data in <code>nydf</code>.  Note that the
coordinates in the polygon have been projected to a
different coordinate system (UTM, zone 18), but the
order of the regions/polygons is the same as in
<code>nydf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nypoly)
</code></pre>


<h3>Format</h3>

<p>A SpatialPolygonDataFrame
</p>


<h3>Source</h3>

<p>Bivand, R. S., Pebesma, E. J., Gomez-Rubio, V.,
and Pebesma, E. J. (2013). Applied Spatial Data Analysis
with R, 2nd edition. New York: Springer.
</p>

<hr>
<h2 id='nysf'><code>sf</code> object for New York leukemia data.</h2><span id='topic+nysf'></span>

<h3>Description</h3>

<p>The number of incident leukemia cases from
1978-1982 per census tract for an 8-county region of
upstate New York.
</p>
<p>This is the same data as in <code>nydf</code> in a different
format.
</p>
<p>Note that the coordinates in the polygons have been
projected to a different coordinate system (UTM, zone
18) compared to <code>nydf</code>, but the order of the
regions/polygons is the same as in <code>nydf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nysf)
</code></pre>


<h3>Format</h3>

<p>A <code>sf</code> with 281 rows and 18 columns:
</p>

<dl>
<dt>areaname</dt><dd><p>The name of the region.</p>
</dd>
<dt>areakey</dt><dd><p>Census tract id.</p>
</dd>
<dt>xorig</dt><dd><p>x-coordinate associated with the centroid of each region on the ORIGINAL scale.</p>
</dd>
<dt>yirug</dt><dd><p>y-coordinate associated with the centroid of each region on the ORIGINAL scale.</p>
</dd>
<dt>pop8</dt><dd><p>The population (1980 census) of the region.</p>
</dd>
<dt>tractcas</dt><dd><p>The number of leukemia cases between 1978-1982, rounded to two decimal places.</p>
</dd>
<dt>propcas</dt><dd><p>The proportion of cases relative to population.</p>
</dd>
<dt>pctownhome</dt><dd><p>The percentage of homeowners in the tract.</p>
</dd>
<dt>pctage65p</dt><dd><p>The percentage of residents aged 65 or older.</p>
</dd>
<dt>Z</dt><dd><p>A transformation of exposure to TCE, specifically log(1000(TCE + 1)/pop8).</p>
</dd>
<dt>avgidist</dt><dd><p>Average inverse distance to the nearest TCE site.</p>
</dd>
<dt>pexpossure</dt><dd></dd>
<dt>cases</dt><dd><p>The number of leukemia cases between 1978-1982.</p>
</dd>
<dt>xm</dt><dd><p>A shifted version of <code>x</code>.</p>
</dd>
<dt>ym</dt><dd><p>A shifted version of <code>y</code>.</p>
</dd>
<dt>x</dt><dd><p>x-coordinate associated with the centroid of each region.</p>
</dd>
<dt>y</dt><dd><p>y-coordinate associated with the centroid of each region.</p>
</dd>
<dt>geometry</dt><dd><p>The geometry list column of the object.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Bivand, R. S., Pebesma, E. J., Gomez-Rubio, V.,
and Pebesma, E. J. (2013). Applied Spatial Data Analysis
with R, 2nd edition. New York: Springer.
</p>

<hr>
<h2 id='nysp'><code>SpatialPolygonsDataFrame</code> for New York
leukemia data.</h2><span id='topic+nysp'></span>

<h3>Description</h3>

<p>A <code>SpatialPolygonsDataFrame</code> object containing New
York leukemia data. Methods for
<code>SpatialPolygonsDataFrame</code> are provided by the
<code>sp</code> package, which must be loaded to make full use
of this data format.
</p>
<p>The number of incident leukemia cases from 1978-1982 per
census tract for an 8-county region of upstate New York.
</p>
<p>This is the same data as in <code>nydf</code> in a different
format.
</p>
<p>Note that the coordinates in the polygons have been
projected to a different coordinate system (UTM, zone 18)
compared to <code>nydf</code>, but the order of the
regions/polygons is the same as in <code>nydf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nysp)
</code></pre>


<h3>Format</h3>

<p>A <code>SpatialPolygonsDataFrame</code> with 281 rows
and 17 columns:
</p>

<dl>
<dt>areaname</dt><dd><p>The name of the region.</p>
</dd>
<dt>areakey</dt><dd><p>Census tract id.</p>
</dd>
<dt>xorig</dt><dd><p>x-coordinate associated with the centroid of each region on the ORIGINAL scale.</p>
</dd>
<dt>yirug</dt><dd><p>y-coordinate associated with the centroid of each region on the ORIGINAL scale.</p>
</dd>
<dt>pop8</dt><dd><p>The population (1980 census) of the region.</p>
</dd>
<dt>tractcas</dt><dd><p>The number of leukemia cases between 1978-1982, rounded to two decimal places.</p>
</dd>
<dt>propcas</dt><dd><p>The proportion of cases relative to population.</p>
</dd>
<dt>pctownhome</dt><dd><p>The percentage of homeowners in the tract.</p>
</dd>
<dt>pctage65p</dt><dd><p>The percentage of residents aged 65 or older.</p>
</dd>
<dt>Z</dt><dd><p>A transformation of exposure to TCE, specifically log(1000(TCE + 1)/pop8).</p>
</dd>
<dt>avgidist</dt><dd><p>Average inverse distance to the nearest TCE site.</p>
</dd>
<dt>pexpossure</dt><dd></dd>
<dt>cases</dt><dd><p>The number of leukemia cases between 1978-1982.</p>
</dd>
<dt>xm</dt><dd><p>A shifted version of <code>x</code>.</p>
</dd>
<dt>ym</dt><dd><p>A shifted version of <code>y</code>.</p>
</dd>
<dt>x</dt><dd><p>x-coordinate associated with the centroid of each region.</p>
</dd>
<dt>y</dt><dd><p>y-coordinate associated with the centroid of each region.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Waller, L.A. and Gotway, C.A. (2005). Applied
Spatial Statistics for Public Health Data. Hoboken, NJ:
Wiley.
</p>
<p>Bivand, R. S., Pebesma, E. J., Gomez-Rubio, V.,
and Pebesma, E. J. (2013). Applied Spatial Data
Analysis with R, 2nd edition. New York: Springer.
</p>

<hr>
<h2 id='nyw'>Adjacency matrix for New York leukemia data.</h2><span id='topic+nyw'></span>

<h3>Description</h3>

<p>This data set contains a 281 x 281 adjacency
matrix for the New York leukemia data in <code>nydf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nyw)
</code></pre>


<h3>Format</h3>

<p>A matrix of dimension 281 x 281.
</p>


<h3>Source</h3>

<p>Waller, L.A. and Gotway, C.A. (2005).  Applied
Spatial Statistics for Public Health Data.  Hoboken, NJ:
Wiley.
</p>


<h3>References</h3>

<p>Waller, L.A., Turnbull, B.W., Clark, L.C.,
and Nasca, P. (1994) &quot;Spatial Pattern Analysis to Detect
Rare Disease Clusters&quot; in Case Studies in Biometry,
N. Lange, L. Ryan, L. Billard, D. Brillinger, L. Conquest,
and J. Greenhouse (eds.) New York: John Wiley and Sons.
</p>

<hr>
<h2 id='optimal_ubpop'>Optimal Population Upper Bound Statistics</h2><span id='topic+optimal_ubpop'></span>

<h3>Description</h3>

<p><code>optimal_ubpop</code> computes statistics for choosing an optimal population
upper bound. <code>ubpop_seq</code> is a sequence of values to consider as the
optimal choice of upper bound. The smallest value must be at least
<code>min(pop)/sum(pop)</code> and should generally be less than or equal to 0.5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal_ubpop(
  coords,
  cases,
  pop,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.05,
  ubpop_seq = seq(0.01, 0.5, len = 50),
  longlat = FALSE,
  cl = NULL,
  type = "poisson",
  min.cases = 0,
  simdist = "multinomial"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal_ubpop_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_ubpop_seq">ubpop_seq</code></td>
<td>
<p>A strictly increasing numeric vector with values between
min(pop)/sum(pop) and 1. The default is <code>seq(0.01, 0.5, len = 50)</code>.</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_min.cases">min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td></tr>
<tr><td><code id="optimal_ubpop_+3A_simdist">simdist</code></td>
<td>
<p>Character string indicating the simulation
distribution. The default is <code>"multinomial"</code>, which
conditions on the total number of cases observed. The
other options are <code>"poisson"</code> and <code>"binomial"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>smerc_optimal_ubpop</code> object. This includes:
</p>
<table>
<tr><td><code>ubpop_seq</code></td>
<td>
<p>The sequence of population bounds considered</p>
</td></tr>
<tr><td><code>elbow_method</code></td>
<td>
<p>An object with statistics related to the elbow method</p>
</td></tr>
<tr><td><code>gini_method</code></td>
<td>
<p>An object with statistics related to the gini method</p>
</td></tr>
<tr><td><code>elbow_ubpop</code></td>
<td>
<p>The population upperbound suggested by the elbow method</p>
</td></tr>
<tr><td><code>gini_ubpop</code></td>
<td>
<p>The population upperbound suggested by the Gini method</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Meysami, Mohammad, French, Joshua P., and Lipner, Ettie M. The estimation of
the optimal cluster upper bound for scan methods in retrospective disease
surveillance. Submitted.
</p>
<p>Han, J., Zhu, L., Kulldorff, M. et al. Using Gini coefficient to determining
optimal cluster reporting sizes for spatial scan statistics. Int J Health
Geogr 15, 27 (2016). &lt;doi:10.1186/s12942-016-0056-6&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
ubpop_stats &lt;- optimal_ubpop(
  coords = coords, cases = nydf$cases,
  pop = nydf$pop, nsim = 49,
  ubpop_seq = seq(0.05, 0.5, by = 0.05)
)
ubpop_stats
## Not run: 
plot(ubpop_stats)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.smerc_cluster'>Plot object of class <code>smerc_cluster</code>.</h2><span id='topic+plot.smerc_cluster'></span>

<h3>Description</h3>

<p>Plot clusters (the centroids of the regions in each
cluster) in different colors.  The most likely cluster is
plotted with solid red circles by default.  Points not in
a cluster are black open circles.  The other cluster
points are plotted with different symbols and colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smerc_cluster'
plot(
  x,
  ...,
  idx = seq_along(x$clusters),
  nclusters = NULL,
  ccol = NULL,
  cpch = NULL,
  add = FALSE,
  usemap = FALSE,
  mapargs = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smerc_cluster_+3A_x">x</code></td>
<td>
<p>An object of class scan to be plotted.</p>
</td></tr>
<tr><td><code id="plot.smerc_cluster_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to the
<code>plot</code> function.</p>
</td></tr>
<tr><td><code id="plot.smerc_cluster_+3A_idx">idx</code></td>
<td>
<p>An index vector indicating the elements of
<code>x$clusters</code> to print information for. The default
is all clusters.</p>
</td></tr>
<tr><td><code id="plot.smerc_cluster_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to plot. Deprecated. Use <code>idx</code>.</p>
</td></tr>
<tr><td><code id="plot.smerc_cluster_+3A_ccol">ccol</code></td>
<td>
<p>Fill color of the plotted points.  Default is
<code>grDevices::hcl.colors(nclusters, palette = "viridis")</code>.</p>
</td></tr>
<tr><td><code id="plot.smerc_cluster_+3A_cpch">cpch</code></td>
<td>
<p>Plotting character to use for points in each
cluster.  Default is NULL, indicating pch = 20 for the
most likely cluster and then pch = 2, 3, .., up to the
remaining number of clusters.</p>
</td></tr>
<tr><td><code id="plot.smerc_cluster_+3A_add">add</code></td>
<td>
<p>A logical indicating whether results should be
drawn on existing map.</p>
</td></tr>
<tr><td><code id="plot.smerc_cluster_+3A_usemap">usemap</code></td>
<td>
<p>Logical indicating whether the maps::map
function should be used to create a plot background for
the coordinates.  Default is <code>FALSE</code>.  Use
<code>TRUE</code> if you have longitude/latitude coordinates.</p>
</td></tr>
<tr><td><code id="plot.smerc_cluster_+3A_mapargs">mapargs</code></td>
<td>
<p>A list of arguments for the map function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- scan.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, nsim = 0,
  longlat = TRUE, alpha = 1
)
# plot only 3 most likely clusters
plot(out, idx = 1:3)
## plot output for new york state
# specify desired argument values
mapargs &lt;- list(
  database = "county", region = "new york",
  xlim = range(out$coords[, 1]),
  ylim = range(out$coords[, 2])
)
# needed for "county" database (unless you execute library(maps))
data(countyMapEnv, package = "maps")
# plot only the 1st and 3rd clusters
plot(out, idx = 1:3, usemap = TRUE, mapargs = mapargs)
</code></pre>

<hr>
<h2 id='plot.smerc_optimal_ubpop'>Plot object of class <code>smerc_optimal_ubpop</code>.</h2><span id='topic+plot.smerc_optimal_ubpop'></span>

<h3>Description</h3>

<p>Plot results of <code><a href="#topic+optimal_ubpop">optimal_ubpop</a></code>. This is only meant for a visual
summary of the results. Users will need to access the elements of the <code>smerc_optimal_ubpop</code> object <code>x</code>
if they want to create a custom plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smerc_optimal_ubpop'
plot(x, ..., method = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smerc_optimal_ubpop_+3A_x">x</code></td>
<td>
<p>An object of class <code>smerc_optimal_ubpop</code>.</p>
</td></tr>
<tr><td><code id="plot.smerc_optimal_ubpop_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="plot.smerc_optimal_ubpop_+3A_method">method</code></td>
<td>
<p>The method to plot. The default is <code>"all"</code>.
The other valid options are <code>"elbow"</code> and <code>"gini"</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+optimal_ubpop">optimal_ubpop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
ubpop_stats &lt;- optimal_ubpop(
  coords = coords, cases = nydf$cases,
  pop = nydf$pop, nsim = 49,
  ubpop = seq(0.05, 0.5, by = 0.05)
)
## Not run: 
plot(ubpop_stats)

## End(Not run)
plot(ubpop_stats, method = "elbow")
plot(ubpop_stats$ubpop_seq, ubpop_stats$elbow_method$stats)
plot(ubpop_stats, method = "gini")
plot(ubpop_stats$ubpop_seq, ubpop_stats$gini_method$stats)
</code></pre>

<hr>
<h2 id='plot.tango'>Plots an object of class <code>tango</code>.</h2><span id='topic+plot.tango'></span>

<h3>Description</h3>

<p>Plots results of <code><a href="#topic+tango.test">tango.test</a></code>.  If Monte
Carlo simulation was not used to produce <code>x</code>, then a  a density plot of
the (approximate) null distribution of <code>tstat.chisq</code> is produced, along
with a vertical line for the observed <code>tstat</code>.
If a Monte Carlo test was used to produce <code>x</code>, then a scatterplot of
the <code>gof.sim</code> versus <code>sa.sim</code> is compared to the observed values
<code>gof</code> and <code>sa</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tango'
plot(x, ..., obs.list = list(pch = 20), sim.list = list(pch = 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tango_+3A_x">x</code></td>
<td>
<p>An object of class <code>tango</code> to be plotted.</p>
</td></tr>
<tr><td><code id="plot.tango_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="plot.tango_+3A_obs.list">obs.list</code></td>
<td>
<p>A list containing arguments for the
<code><a href="graphics.html#topic+points">points</a></code> function, which is used to
plot the <code>gof</code> and <code>sa</code> components,
when appropriate.</p>
</td></tr>
<tr><td><code id="plot.tango_+3A_sim.list">sim.list</code></td>
<td>
<p>A list containing arguments for the
<code><a href="graphics.html#topic+points">points</a></code> function, which is used to
plot the <code>gof.sim</code> and <code>sa.sim</code> components,
when appropriate.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tango.test">tango.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- as.matrix(nydf[, c("x", "y")])
w &lt;- dweights(coords, kappa = 1)
x1 &lt;- tango.test(nydf$cases, nydf$pop, w)
plot(x1)
x2 &lt;- tango.test(nydf$cases, nydf$pop, w, nsim = 49)
plot(x2)
</code></pre>

<hr>
<h2 id='precog.sim'>Perform <code>precog.test</code> on simulated data.</h2><span id='topic+precog.sim'></span>

<h3>Description</h3>

<p><code>procog.sim</code> efficiently performs
<code><a href="#topic+precog.test">precog.test</a></code> on a simulated data set.
The function is meant to be used internally by the
<code><a href="#topic+precog.test">precog.test</a></code> function, but is
informative for better understanding the implementation
of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precog.sim(
  nsim = 1,
  zones,
  ty,
  ex,
  w,
  pop,
  max_pop,
  logein,
  logeout,
  d,
  cl = NULL,
  tol_prob = 0.9,
  ysim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precog.sim_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_zones">zones</code></td>
<td>
<p>A list with of candidate zones that includes
each regions and its adjacent neighbors.</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_max_pop">max_pop</code></td>
<td>
<p>The maximum population size allowable for
a cluster.</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_logein">logein</code></td>
<td>
<p>The <code>log</code> of the expected number of
cases in each candidate zone.</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_logeout">logeout</code></td>
<td>
<p>The <code>log</code> of the expected number of
cases outside of each candidate zone.</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_d">d</code></td>
<td>
<p>A precomputed distance matrix based on <code>coords</code></p>
</td></tr>
<tr><td><code id="precog.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_tol_prob">tol_prob</code></td>
<td>
<p>A single numeric value between 0 and 1
that describes the quantile of the tolerance envelopes
used to prefilter regions from the candidate zones.</p>
</td></tr>
<tr><td><code id="precog.sim_+3A_ysim">ysim</code></td>
<td>
<p>A matrix of size <code>nsim</code><code class="reqn">\times n</code>,
where <code class="reqn">n</code> is the number of regions in the study
area. This is a matrix of <code>nsim</code> realizations of
the case counts for each region in the study area under
the null hypothesis. This argument is only not meant to
be used by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the vector of tolerance quantiles
associated with each region and a vector with the
maximum test statistic for each simulated data set.
</p>


<h3>Author(s)</h3>

<p>Joshua French and Mohammad Meysami
</p>

<hr>
<h2 id='precog.test'>PreCoG Scan Test</h2><span id='topic+precog.test'></span>

<h3>Description</h3>

<p><code>precog.test</code> is an implementation of the
Prefiltered Component-based Greedy Scan Method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precog.test(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  tol_prob = 0.9,
  alpha = 0.1,
  ubpop = 0.5,
  longlat = FALSE,
  cl = NULL,
  ysim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precog.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="precog.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="precog.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="precog.test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="precog.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="precog.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="precog.test_+3A_tol_prob">tol_prob</code></td>
<td>
<p>A single numeric value between 0 and 1
that describes the quantile of the tolerance envelopes
used to prefilter regions from the candidate zones.</p>
</td></tr>
<tr><td><code id="precog.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="precog.test_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="precog.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="precog.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="precog.test_+3A_ysim">ysim</code></td>
<td>
<p>A matrix of size <code>nsim</code><code class="reqn">\times n</code>,
where <code class="reqn">n</code> is the number of regions in the study
area. This is a matrix of <code>nsim</code> realizations of
the case counts for each region in the study area under
the null hypothesis. This argument is only not meant to
be used by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>smerc_cluster</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French and Mohammad Meysami
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
out &lt;- precog.test(coords = nydf[,c("x", "y")],
                   cases = floor(nydf$cases),
                   pop = nydf$pop, w = nyw, nsim = 19,
                   alpha = 0.2)
# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='prep.mst'>Return nicely formatted results from mst.all</h2><span id='topic+prep.mst'></span>

<h3>Description</h3>

<p>Return nicely formatted results from mst.all
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.mst(mstout)
</code></pre>

<hr>
<h2 id='print.smerc_cluster'>Print object of class <code>smerc_cluster</code>.</h2><span id='topic+print.smerc_cluster'></span>

<h3>Description</h3>

<p>Print <code>smerc_cluster</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smerc_cluster'
print(x, ..., extra = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.smerc_cluster_+3A_x">x</code></td>
<td>
<p>An object of class <code>smerc_cluster</code>.</p>
</td></tr>
<tr><td><code id="print.smerc_cluster_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
<tr><td><code id="print.smerc_cluster_+3A_extra">extra</code></td>
<td>
<p>A logical value. Default is <code>FALSE</code>.
<code>TRUE</code> indicates that extra information should be
printed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(x, y))
out &lt;- scan.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, nsim = 49,
  longlat = TRUE, alpha = 0.12
)
out
</code></pre>

<hr>
<h2 id='print.smerc_optimal_ubpop'>Print object of class <code>smerc_optimal_ubpop</code>.</h2><span id='topic+print.smerc_optimal_ubpop'></span>

<h3>Description</h3>

<p>Print <code>smerc_optimal_ubpop</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smerc_optimal_ubpop'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.smerc_optimal_ubpop_+3A_x">x</code></td>
<td>
<p>An object of class <code>smerc_optimal_ubpop</code>.</p>
</td></tr>
<tr><td><code id="print.smerc_optimal_ubpop_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
ubpop_stats &lt;- optimal_ubpop(
  coords = coords, cases = nydf$cases,
  pop = nydf$pop, nsim = 49,
  ubpop = seq(0.05, 0.5, by = 0.05)
)
ubpop_stats
</code></pre>

<hr>
<h2 id='print.smerc_similarity_test'>Print object of class <code>smerc_similarity_test</code>.</h2><span id='topic+print.smerc_similarity_test'></span>

<h3>Description</h3>

<p>Print a <code>smerc_similarity_test</code> object. If the <code>crayon</code> package
is installed, then the results are printed in color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smerc_similarity_test'
print(x, ..., digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.smerc_similarity_test_+3A_x">x</code></td>
<td>
<p>An object of class <code>smerc_similarity+test</code>.</p>
</td></tr>
<tr><td><code id="print.smerc_similarity_test_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
<tr><td><code id="print.smerc_similarity_test_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
</table>

<hr>
<h2 id='print.tango'>Print object of class <code>tango</code>.</h2><span id='topic+print.tango'></span>

<h3>Description</h3>

<p>Print a <code>tango</code> object. If the <code>crayon</code> package
is installed, then the results are printed in color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tango'
print(x, ..., digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tango_+3A_x">x</code></td>
<td>
<p>An object of class <code>tango</code>.</p>
</td></tr>
<tr><td><code id="print.tango_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
<tr><td><code id="print.tango_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- as.matrix(nydf[, c("x", "y")])
w &lt;- dweights(coords, kappa = 1)
results &lt;- tango.test(nydf$cases, nydf$pop, w, nsim = 49)
results
</code></pre>

<hr>
<h2 id='rflex_zones'>Determine zones for flexibly shaped spatial scan test</h2><span id='topic+rflex_zones'></span>

<h3>Description</h3>

<p><code>rflex_zones</code> determines the unique zones to
consider for the flexibly shaped spatial scan test of
Tango and Takahashi (2012).  The algorithm uses a
breadth-first search to find all subgraphs connected to
each vertex (region) in the data set of size <code class="reqn">k</code> or
less with the constraint that the middle p-value of each
region must be less than <code>alpha1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rflex_zones(
  nn,
  w,
  cases,
  ex,
  alpha1 = 0.2,
  type = "poisson",
  pop = NULL,
  cl = NULL,
  loop = FALSE,
  verbose = FALSE,
  pfreq = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rflex_zones_+3A_nn">nn</code></td>
<td>
<p>An n by k matrix providing the k nearest
neighbors of each region, presumably produced by the
<code><a href="#topic+knn">knn</a></code> function.</p>
</td></tr>
<tr><td><code id="rflex_zones_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="rflex_zones_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="rflex_zones_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="rflex_zones_+3A_alpha1">alpha1</code></td>
<td>
<p>The middle p-value threshold.</p>
</td></tr>
<tr><td><code id="rflex_zones_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="rflex_zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.  The default is <code>NULL</code> since this argument
is only needed for <code>type = "binomial"</code>.</p>
</td></tr>
<tr><td><code id="rflex_zones_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="rflex_zones_+3A_loop">loop</code></td>
<td>
<p>A logical value indicating whether a loop
should be used to implement the function instead of
<code><a href="pbapply.html#topic+pbapply">pbapply</a></code>.  The default is
<code>FALSE</code>. If <code>TRUE</code>, then memory-saving steps
are also taken.</p>
</td></tr>
<tr><td><code id="rflex_zones_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether
progress messages should be provided.
The default is <code>FALSE</code>.  If both <code>loop</code> and
<code>verbose</code> are <code>TRUE</code>, informative messages
are displayed that can be useful for diagnosing where
the sequences of connected subgraphs are slowing down
or having problems.</p>
</td></tr>
<tr><td><code id="rflex_zones_+3A_pfreq">pfreq</code></td>
<td>
<p>The frequency that messages are reported
from the loop (if <code>verbose = TRUE</code>). The default
is <code>pfreq = 1</code>, meaning a message is returned for
each index of the loop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of zones to consider for
clustering.  Each element of the list contains a vector
with the location ids of the regions in that zone.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T. and Takahashi, K. (2012), A
flexible spatial scan statistic with a restricted
likelihood ratio for detecting disease clusters.
Statist. Med., 31: 4207-4218. &lt;doi:10.1002/sim.5478&gt;
</p>


<h3>See Also</h3>

<p>rflex.midp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- cbind(nydf$x, nydf$y)
nn &lt;- knn(coords, k = 5)
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$pop
ex &lt;- pop * sum(cases) / sum(pop)
# zones for poisson model
pzones &lt;- rflex_zones(nn, w = nyw, cases = cases, ex = ex)
## Not run: 
pzones &lt;- rflex_zones(nn,
  w = nyw, cases = cases,
  ex = ex, verbose = TRUE
)
# zones for binomial model
bzones &lt;- rflex_zones(nn,
  w = nyw, cases = cases, ex = ex,
  type = "binomial", pop = pop
)

## End(Not run)
</code></pre>

<hr>
<h2 id='rflex.midp'>Compute middle p-value</h2><span id='topic+rflex.midp'></span>

<h3>Description</h3>

<p>Computes P(Y &gt; cases) + P(Y = cases)/2 when Y ~
Poisson(ex) or Y ~ Binomial(n = pop, p = ex/pop).  This
is middle p-value computed by Tango and Takahashi (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rflex.midp(cases, ex, type = "poisson", pop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rflex.midp_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="rflex.midp_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="rflex.midp_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="rflex.midp_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of middle p-values
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T. and Takahashi, K. (2012), A
flexible spatial scan statistic with a restricted
likelihood ratio for detecting disease clusters.
Statist. Med., 31: 4207-4218. &lt;doi:10.1002/sim.5478&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$pop
ex &lt;- pop * sum(cases) / sum(pop)
# zones for poisson model
pp &lt;- rflex.midp(cases, ex)
# zones for binomial model
bp &lt;- rflex.midp(cases, ex, type = "binomial", pop = pop)
</code></pre>

<hr>
<h2 id='rflex.sim'>Perform <code>rflex.test</code> on simualated data</h2><span id='topic+rflex.sim'></span>

<h3>Description</h3>

<p><code>rflex.sim</code> efficiently performs
<code><a href="#topic+rflex.test">rflex.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+rflex.test">rflex.test</a></code> function, but is informative for
better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rflex.sim(
  nsim = 1,
  nn,
  w,
  ex,
  alpha1 = 0.2,
  type = "poisson",
  pop = NULL,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rflex.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="rflex.sim_+3A_nn">nn</code></td>
<td>
<p>A matrix of the k nearest neighbors for the
regions described by <code>w</code>.</p>
</td></tr>
<tr><td><code id="rflex.sim_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="rflex.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="rflex.sim_+3A_alpha1">alpha1</code></td>
<td>
<p>The middle p-value threshold.</p>
</td></tr>
<tr><td><code id="rflex.sim_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="rflex.sim_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="rflex.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
# determine knn
coords &lt;- with(nydf, cbind(longitude, latitude))
nn &lt;- knn(coords, longlat = TRUE, k = 50)
# determine expected number of cases in each region
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$pop
ex &lt;- pop * sum(cases) / sum(pop)
tsim &lt;- rflex.sim(nsim = 5, nn = nn, w = nyw, ex = ex)
</code></pre>

<hr>
<h2 id='rflex.test'>Restricted Flexibly-shaped Spatial Scan Test</h2><span id='topic+rflex.test'></span>

<h3>Description</h3>

<p><code>rflex.test</code> performs the restricted flexibly shaped
spatial scan test of Tango and Takahashi (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rflex.test(
  coords,
  cases,
  pop,
  w,
  k = 50,
  ex = sum(cases)/sum(pop) * pop,
  type = "poisson",
  nsim = 499,
  alpha = 0.1,
  longlat = FALSE,
  alpha1 = 0.2,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rflex.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_k">k</code></td>
<td>
<p>An integer indicating the maximum number of
regions to inclue in a potential cluster.  Default is
10</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_alpha1">alpha1</code></td>
<td>
<p>The middle p-value threshold.</p>
</td></tr>
<tr><td><code id="rflex.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is performed using the spatial scan test based
on the Poisson test statistic and a fixed number of
cases.  The first cluster is the most likely to be a
cluster.  If no significant clusters are found, then the
most likely cluster is returned (along with a warning).
</p>


<h3>Value</h3>

<p>Returns a list of length two of class scan. The
first element (clusters) is a list containing the
significant, non-ovlappering clusters, and has the the
following components: </p>
<table>
<tr><td><code>coords</code></td>
<td>
<p>The centroid of the
significant clusters.</p>
</td></tr> <tr><td><code>r</code></td>
<td>
<p>The radius of the
window of the clusters.</p>
</td></tr> <tr><td><code>pop</code></td>
<td>
<p>The total
population in the cluster window.</p>
</td></tr> <tr><td><code>cases</code></td>
<td>
<p>The
observed number of cases in the cluster window.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>The expected number of cases in the
cluster window.</p>
</td></tr> <tr><td><code>smr</code></td>
<td>
<p>Standarized mortaility
ratio (observed/expected) in the cluster window.</p>
</td></tr>
<tr><td><code>rr</code></td>
<td>
<p>Relative risk in the cluster window.</p>
</td></tr>
<tr><td><code>loglikrat</code></td>
<td>
<p>The loglikelihood ratio for the
cluster window (i.e., the log of the test statistic).</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The pvalue of the test statistic
associated with the cluster window.</p>
</td></tr></table>
<p> The second element
of the list is the centroid coordinates.  This is
needed for plotting purposes.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T. and Takahashi, K. (2012), A
flexible spatial scan statistic with a restricted
likelihood ratio for detecting disease clusters.
Statist. Med., 31: 4207-4218. &lt;doi:10.1002/sim.5478&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- rflex.test(
  coords = coords, cases = floor(nydf$cases),
  w = nyw, k = 10,
  pop = nydf$pop, nsim = 49,
  alpha = 0.05, longlat = TRUE
)

# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='rflex.zones'>Determine zones for flexibly shaped spatial scan test</h2><span id='topic+rflex.zones'></span>

<h3>Description</h3>

<p><code>rflex.zones</code> determines the unique zones to
consider for the flexibly shaped spatial scan test of
Tango and Takahashi (2012).  The algorithm uses a
breadth-first search to find all subgraphs connected to
each vertex (region) in the data set of size <code class="reqn">k</code> or
less with the constraint that the middle p-value of each
region must be less than <code>alpha1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rflex.zones(
  nn,
  w,
  cases,
  ex,
  alpha1 = 0.2,
  type = "poisson",
  pop = NULL,
  cl = NULL,
  loop = FALSE,
  verbose = FALSE,
  pfreq = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rflex.zones_+3A_nn">nn</code></td>
<td>
<p>An n by k matrix providing the k nearest
neighbors of each region, presumably produced by the
<code><a href="#topic+knn">knn</a></code> function.</p>
</td></tr>
<tr><td><code id="rflex.zones_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="rflex.zones_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="rflex.zones_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="rflex.zones_+3A_alpha1">alpha1</code></td>
<td>
<p>The middle p-value threshold.</p>
</td></tr>
<tr><td><code id="rflex.zones_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="rflex.zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.  The default is <code>NULL</code> since this argument
is only needed for <code>type = "binomial"</code>.</p>
</td></tr>
<tr><td><code id="rflex.zones_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="rflex.zones_+3A_loop">loop</code></td>
<td>
<p>A logical value indicating whether a loop
should be used to implement the function instead of
<code><a href="pbapply.html#topic+pbapply">pbapply</a></code>.  The default is
<code>FALSE</code>. If <code>TRUE</code>, then memory-saving steps
are also taken.</p>
</td></tr>
<tr><td><code id="rflex.zones_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether
progress messages should be provided.
The default is <code>FALSE</code>.  If both <code>loop</code> and
<code>verbose</code> are <code>TRUE</code>, informative messages
are displayed that can be useful for diagnosing where
the sequences of connected subgraphs are slowing down
or having problems.</p>
</td></tr>
<tr><td><code id="rflex.zones_+3A_pfreq">pfreq</code></td>
<td>
<p>The frequency that messages are reported
from the loop (if <code>verbose = TRUE</code>). The default
is <code>pfreq = 1</code>, meaning a message is returned for
each index of the loop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of zones to consider for
clustering.  Each element of the list contains a vector
with the location ids of the regions in that zone.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T. and Takahashi, K. (2012), A
flexible spatial scan statistic with a restricted
likelihood ratio for detecting disease clusters.
Statist. Med., 31: 4207-4218. &lt;doi:10.1002/sim.5478&gt;
</p>


<h3>See Also</h3>

<p>rflex.midp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- cbind(nydf$x, nydf$y)
nn &lt;- knn(coords, k = 5)
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$pop
ex &lt;- pop * sum(cases) / sum(pop)
# zones for poisson model
pzones &lt;- rflex.zones(nn, w = nyw, cases = cases, ex = ex)
## Not run: 
pzones &lt;- rflex.zones(nn,
  w = nyw, cases = cases,
  ex = ex, verbose = TRUE
)
# zones for binomial model
bzones &lt;- rflex.zones(nn,
  w = nyw, cases = cases, ex = ex,
  type = "binomial", pop = pop
)

## End(Not run)
</code></pre>

<hr>
<h2 id='scan_stat'>Spatial scan statistic</h2><span id='topic+scan_stat'></span><span id='topic+stat_poisson'></span><span id='topic+stat_binom'></span>

<h3>Description</h3>

<p><code>scan_stat</code> calculates the spatial scan statistic
for a zone (a set of spatial regions).  The statistic is
the log of the likelihood ratio test statistic of the
chosen distribution.  If <code>type = "poisson"</code> and
<code>a</code> is more than zero, this statistic is penalized.
See references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_stat(
  yin,
  ein = NULL,
  eout = NULL,
  ty,
  type = "poisson",
  popin = NULL,
  tpop = NULL,
  a = 0,
  shape = 1,
  yout = NULL,
  popout = NULL
)

stat_poisson(yin, yout, ein, eout, a = 0, shape = 1)

stat_binom(yin, yout, ty, popin, popout, tpop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_stat_+3A_yin">yin</code></td>
<td>
<p>The total number of cases in the zone.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_ein">ein</code></td>
<td>
<p>The expected number of cases in the zone.
Conventionally, this is the estimated overall disease
risk across the study area, multiplied by the total
population size of the zone.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_eout">eout</code></td>
<td>
<p>The expected number of cases outside the
zone.  This should be <code>ty - ein</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to implement. The
default choice are <code>"poisson"</code>.  The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_popin">popin</code></td>
<td>
<p>The total population in the zone.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_tpop">tpop</code></td>
<td>
<p>The total population in the study area.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_a">a</code></td>
<td>
<p>A tuning parameter for the adjusted
log-likelihood ratio.  See details.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_shape">shape</code></td>
<td>
<p>The shape of the ellipse, which is the ratio
of the length of the longest and shortest axes of the
ellipse.  The default is 1, meaning it is a circle.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_yout">yout</code></td>
<td>
<p>The observed number of cases outside the
zone.  This should be <code>ty - yin</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_popout">popout</code></td>
<td>
<p>The population outside the zone.  This
should be <code>tpop - popin</code> and is computed
automatically if not provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of scan statistics.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Poisson scan statistic:  Kulldorff, M. (1997) A spatial
scan statistic. Communications in Statistics - Theory and
Methods, 26(6): 1481-1496,
&lt;doi:10.1080/03610929708831995&gt;
</p>
<p>Penalized Poisson scan statistic: Kulldorff, M., Huang,
L., Pickle, L. and Duczmal, L. (2006) An elliptic spatial
scan statistic. Statistics in Medicine, 25:3929-3943.
&lt;doi:10.1002/sim.2490&gt;
</p>
<p>Binomial scan statistic: Duczmal, L. and Assuncao, R.
(2004) A simulated annealing strategy for the detection
of arbitrarily shaped spatial clusters. Computational
Statistics &amp; Data Analysis, 45(2):269-286.
&lt;doi:10.1016/S0167-9473(02)00302-X&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># New York leukemia data
# total cases
ty &lt;- 552
# total population
tpop &lt;- 1057673

# poisson example with yin = 106 and ein = 62.13
scan_stat(yin = 106, ty = ty, ein = 62.13)
stat_poisson(
  yin = 106, yout = 552 - 106,
  ein = 62.13, eout = 552 - 62.13
)

# binomial example with yin = 41 and popin = 38999
scan_stat(
  yin = 41, ty = ty,
  popin = 38999, tpop = tpop, type = "binomial"
)
stat_binom(41, ty - 41, ty, 38999, tpop - 38999, tpop)
</code></pre>

<hr>
<h2 id='scan.sim'>Perform <code>scan.test</code> on simulated data</h2><span id='topic+scan.sim'></span>

<h3>Description</h3>

<p><code>scan.sim</code> efficiently performs
<code><a href="#topic+scan.test">scan.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+scan.test">scan.test</a></code> function, but is informative for
better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.sim(
  nsim = 1,
  nn,
  ty,
  ex,
  type = "poisson",
  ein = NULL,
  eout = NULL,
  tpop = NULL,
  popin = NULL,
  popout = NULL,
  cl = NULL,
  simdist = "multinomial",
  pop = NULL,
  min.cases = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_nn">nn</code></td>
<td>
<p>A list of nearest neighbors produced by <code><a href="#topic+nnpop">nnpop</a></code>.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_ein">ein</code></td>
<td>
<p>The expected number of cases in the zone.
Conventionally, this is the estimated overall disease
risk across the study area, multiplied by the total
population size of the zone.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_eout">eout</code></td>
<td>
<p>The expected number of cases outside the
zone.  This should be <code>ty - ein</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_tpop">tpop</code></td>
<td>
<p>The total population in the study area.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_popin">popin</code></td>
<td>
<p>The total population in the zone.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_popout">popout</code></td>
<td>
<p>The population outside the zone.  This
should be <code>tpop - popin</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_simdist">simdist</code></td>
<td>
<p>Character string indicating the simulation
distribution. The default is <code>"multinomial"</code>, which
conditions on the total number of cases observed. The
other options are <code>"poisson"</code> and <code>"binomial"</code></p>
</td></tr>
<tr><td><code id="scan.sim_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="scan.sim_+3A_min.cases">min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
d &lt;- gedist(as.matrix(coords), longlat = TRUE)
nn &lt;- scan.nn(d, pop = nydf$pop, ubpop = 0.1)
cases &lt;- floor(nydf$cases)
ty &lt;- sum(cases)
ex &lt;- ty / sum(nydf$pop) * nydf$pop
yin &lt;- nn.cumsum(nn, cases)
ein &lt;- nn.cumsum(nn, ex)
tsim &lt;- scan.sim(nsim = 1, nn, ty, ex, ein = ein, eout = sum(ex) - ein)
</code></pre>

<hr>
<h2 id='scan.sim.adj'>Perform <code>scan.test</code> on simulated data</h2><span id='topic+scan.sim.adj'></span>

<h3>Description</h3>

<p><code>scan.sim</code> efficiently performs
<code><a href="#topic+scan.test">scan.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+scan.test">scan.test</a></code> function, but is informative for
better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.sim.adj(
  nsim = 1,
  nn,
  ty,
  ex,
  type = "poisson",
  logein = NULL,
  logeout = NULL,
  tpop = NULL,
  popin = NULL,
  popout = NULL,
  logpopin = NULL,
  logpopout = NULL,
  cl = NULL,
  simdist = "multinomial",
  pop = NULL,
  min.cases = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan.sim.adj_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_nn">nn</code></td>
<td>
<p>A list of nearest neighbors produced by <code><a href="#topic+nnpop">nnpop</a></code>.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_logein">logein</code></td>
<td>
<p>The <code>log</code> of the expected number of
cases in each candidate zone.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_logeout">logeout</code></td>
<td>
<p>The <code>log</code> of the expected number of
cases outside of each candidate zone.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_tpop">tpop</code></td>
<td>
<p>The total population in the study area.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_popin">popin</code></td>
<td>
<p>The total population in the zone.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_popout">popout</code></td>
<td>
<p>The population outside the zone.  This
should be <code>tpop - popin</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_logpopin">logpopin</code></td>
<td>
<p>The <code>log</code> of the population in each
candidate zone.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_logpopout">logpopout</code></td>
<td>
<p>The <code>log</code> of the population outside
of each candidate zone.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_simdist">simdist</code></td>
<td>
<p>Character string indicating the simulation
distribution. The default is <code>"multinomial"</code>, which
conditions on the total number of cases observed. The
other options are <code>"poisson"</code> and <code>"binomial"</code></p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="scan.sim.adj_+3A_min.cases">min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
d &lt;- gedist(as.matrix(coords), longlat = TRUE)
nn &lt;- scan.nn(d, pop = nydf$pop, ubpop = 0.1)
cases &lt;- floor(nydf$cases)
ty &lt;- sum(cases)
ex &lt;- ty / sum(nydf$pop) * nydf$pop
yin &lt;- nn.cumsum(nn, cases)
ein &lt;- nn.cumsum(nn, ex)
tsim &lt;- scan.sim.adj(
  nsim = 2, nn, ty, ex,
  logein = log(ein),
  logeout = log(sum(ex) - ein)
)
</code></pre>

<hr>
<h2 id='scan.stat'>Spatial scan statistic</h2><span id='topic+scan.stat'></span><span id='topic+stat.poisson'></span><span id='topic+stat.binom'></span>

<h3>Description</h3>

<p><code>scan.stat</code> calculates the spatial scan statistic
for a zone (a set of spatial regions).  The statistic is
the log of the likelihood ratio test statistic of the
chosen distribution.  If <code>type = "poisson"</code> and
<code>a</code> is more than zero, this statistic is penalized.
See references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.stat(
  yin,
  ein = NULL,
  eout = NULL,
  ty,
  type = "poisson",
  popin = NULL,
  tpop = NULL,
  a = 0,
  shape = 1,
  yout = NULL,
  popout = NULL
)

stat.poisson(yin, yout, ein, eout, a = 0, shape = 1)

stat.binom(yin, yout, ty, popin, popout, tpop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan.stat_+3A_yin">yin</code></td>
<td>
<p>The total number of cases in the zone.</p>
</td></tr>
<tr><td><code id="scan.stat_+3A_ein">ein</code></td>
<td>
<p>The expected number of cases in the zone.
Conventionally, this is the estimated overall disease
risk across the study area, multiplied by the total
population size of the zone.</p>
</td></tr>
<tr><td><code id="scan.stat_+3A_eout">eout</code></td>
<td>
<p>The expected number of cases outside the
zone.  This should be <code>ty - ein</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="scan.stat_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="scan.stat_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to implement. The
default choice are <code>"poisson"</code>.  The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="scan.stat_+3A_popin">popin</code></td>
<td>
<p>The total population in the zone.</p>
</td></tr>
<tr><td><code id="scan.stat_+3A_tpop">tpop</code></td>
<td>
<p>The total population in the study area.</p>
</td></tr>
<tr><td><code id="scan.stat_+3A_a">a</code></td>
<td>
<p>A tuning parameter for the adjusted
log-likelihood ratio.  See details.</p>
</td></tr>
<tr><td><code id="scan.stat_+3A_shape">shape</code></td>
<td>
<p>The shape of the ellipse, which is the ratio
of the length of the longest and shortest axes of the
ellipse.  The default is 1, meaning it is a circle.</p>
</td></tr>
<tr><td><code id="scan.stat_+3A_yout">yout</code></td>
<td>
<p>The observed number of cases outside the
zone.  This should be <code>ty - yin</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="scan.stat_+3A_popout">popout</code></td>
<td>
<p>The population outside the zone.  This
should be <code>tpop - popin</code> and is computed
automatically if not provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of scan statistics.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Poisson scan statistic:  Kulldorff, M. (1997) A spatial
scan statistic. Communications in Statistics - Theory and
Methods, 26(6): 1481-1496,
&lt;doi:10.1080/03610929708831995&gt;
</p>
<p>Penalized Poisson scan statistic: Kulldorff, M., Huang,
L., Pickle, L. and Duczmal, L. (2006) An elliptic spatial
scan statistic. Statistics in Medicine, 25:3929-3943.
&lt;doi:10.1002/sim.2490&gt;
</p>
<p>Binomial scan statistic: Duczmal, L. and Assuncao, R.
(2004) A simulated annealing strategy for the detection
of arbitrarily shaped spatial clusters. Computational
Statistics &amp; Data Analysis, 45(2):269-286.
&lt;doi:10.1016/S0167-9473(02)00302-X&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># New York leukemia data
# total cases
ty &lt;- 552
# total population
tpop &lt;- 1057673

# poisson example with yin = 106 and ein = 62.13
scan.stat(yin = 106, ty = ty, ein = 62.13)
stat.poisson(
  yin = 106, yout = 552 - 106,
  ein = 62.13, eout = 552 - 62.13
)

# binomial example with yin = 41 and popin = 38999
scan.stat(
  yin = 41, ty = ty,
  popin = 38999, tpop = tpop, type = "binomial"
)
stat.binom(41, ty - 41, ty, 38999, tpop - 38999, tpop)
</code></pre>

<hr>
<h2 id='scan.test'>Spatial Scan Test</h2><span id='topic+scan.test'></span>

<h3>Description</h3>

<p><code>scan.test</code> performs the original spatial scan test
of Kulldorf (1997) based on a fixed number of cases.
Candidate zones are circular and extend from the observed
region centroids.  The clusters returned are
non-overlapping, ordered from most significant to least
significant.  The first cluster is the most  likely to be
a cluster.  If no significant clusters are found, then
the most likely cluster is returned (along with a
warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.test(
  coords,
  cases,
  pop,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  longlat = FALSE,
  cl = NULL,
  type = "poisson",
  min.cases = 2,
  simdist = "multinomial"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="scan.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="scan.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="scan.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="scan.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="scan.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="scan.test_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="scan.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="scan.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="scan.test_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="scan.test_+3A_min.cases">min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td></tr>
<tr><td><code id="scan.test_+3A_simdist">simdist</code></td>
<td>
<p>Character string indicating the simulation
distribution. The default is <code>"multinomial"</code>, which
conditions on the total number of cases observed. The
other options are <code>"poisson"</code> and <code>"binomial"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>smerc_cluster</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Kulldorff, M. (1997) A spatial scan
statistic. Communications in Statistics - Theory and
Methods, 26(6): 1481-1496,
&lt;doi:10.1080/03610929708831995&gt;
</p>
<p>Waller, L.A. and Gotway, C.A. (2005). Applied Spatial
Statistics for Public Health Data. Hoboken, NJ: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- scan.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, nsim = 0,
  alpha = 1, longlat = TRUE
)

# basic plot
plot(out, idx = 1:3)

# better plot
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf),
        col = color.clusters(out, idx = 1:3))
}

## plot output for new york state
# specify desired argument values
mapargs &lt;- list(
  database = "county", region = "new york",
  xlim = range(out$coords[, 1]),
  ylim = range(out$coords[, 2])
)
# only run this example if maps available
if (require("maps", quietly = TRUE)) {
# needed for "state" database (unless you execute library(maps))
data(countyMapEnv, package = "maps")
plot(out, usemap = TRUE, mapargs = mapargs, idx = 1:3)
}
# extract detected clusteers
clusters(out)

# a second example to match the results of Waller and Gotway (2005)
# in chapter 7 of their book (pp. 220-221).
# Note that the 'longitude' and 'latitude' used by them has
# been switched.  When giving their input to SatScan, the coords
# were given in the order 'longitude' and 'latitude'.
# However, the SatScan program takes coordinates in the order
# 'latitude' and 'longitude', so the results are slightly different
# from the example above.
# Note: the correct code below would use cbind(x, y), i.e.,
# cbind(longitude, latitude)
coords &lt;- with(nydf, cbind(y, x))
out2 &lt;- scan.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, nsim = 0,
  alpha = 1, longlat = TRUE
)
# the cases observed for the clusters in Waller and Gotway: 117, 47, 44
# the second set of results match
clusters(out2, idx = 1:3)
</code></pre>

<hr>
<h2 id='scan.zones'>Determine zones for the spatial scan test</h2><span id='topic+scan.zones'></span>

<h3>Description</h3>

<p><code>scan.zones</code> determines the unique candidate
zones to consider for the circular spatial scan test of
Kulldorff (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.zones(coords, pop, ubpop = 0.5, longlat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan.zones_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="scan.zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="scan.zones_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="scan.zones_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of zones to consider for
clustering.  Each element of the list contains a vector
with the location ids of the regions in that zone.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Kulldorff, M. (1997) A spatial
scan statistic. Communications in Statistics - Theory and
Methods, 26(6): 1481-1496,
&lt;doi:10.1080/03610929708831995&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- cbind(nydf$longitude, nydf$latitude)
zones &lt;- scan.zones(
  coords = coords, pop = nydf$pop,
  ubpop = 0.1, longlat = TRUE
)
</code></pre>

<hr>
<h2 id='seq_scan_sim'>Perform scan test on simulated data sequentially</h2><span id='topic+seq_scan_sim'></span>

<h3>Description</h3>

<p><code>seq_scan_sim</code> efficiently performs <code><a href="#topic+scan.test">scan.test</a></code> on a
simulated data set.  The function is meant to be used internally by the
<code><a href="#topic+optimal_ubpop">optimal_ubpop</a></code> function in the smerc package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_scan_sim(
  nsim = 1,
  nn,
  ty,
  ex,
  type = "poisson",
  ein = NULL,
  eout = NULL,
  tpop = NULL,
  popin = NULL,
  popout = NULL,
  cl = NULL,
  simdist = "multinomial",
  pop = NULL,
  min.cases = 0,
  ldup = NULL,
  lseq_zones
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_scan_sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_nn">nn</code></td>
<td>
<p>A list of nearest neighbors produced by <code><a href="#topic+nnpop">nnpop</a></code>.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_ein">ein</code></td>
<td>
<p>The expected number of cases in the zone.
Conventionally, this is the estimated overall disease
risk across the study area, multiplied by the total
population size of the zone.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_eout">eout</code></td>
<td>
<p>The expected number of cases outside the
zone.  This should be <code>ty - ein</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_tpop">tpop</code></td>
<td>
<p>The total population in the study area.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_popin">popin</code></td>
<td>
<p>The total population in the zone.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_popout">popout</code></td>
<td>
<p>The population outside the zone.  This
should be <code>tpop - popin</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_simdist">simdist</code></td>
<td>
<p>Character string indicating the simulation
distribution. The default is <code>"multinomial"</code>, which
conditions on the total number of cases observed. The
other options are <code>"poisson"</code> and <code>"binomial"</code></p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_min.cases">min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_ldup">ldup</code></td>
<td>
<p>A logical vector indicating positions of duplicated zones. Not
intended for user use.</p>
</td></tr>
<tr><td><code id="seq_scan_sim_+3A_lseq_zones">lseq_zones</code></td>
<td>
<p>A list of logical vectors specifying the sequence of
relevant zones based on ubpop constraints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the maximum statistic for each population upperbound for
each simulated data set. Each element will have a vector of maximums for
each simulated data set corresponding to the sequence of ubpop values. The
list will have <code>nsim</code> elements.
</p>

<hr>
<h2 id='seq_scan_test'>Sequential Scan Test</h2><span id='topic+seq_scan_test'></span>

<h3>Description</h3>

<p>Performs a series of sequential scan tests by ubpop. Only minimal information is returned
for each test. This is intended for internal use by the smerc package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_scan_test(
  coords,
  cases,
  pop,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.05,
  ubpop_seq = seq(0.01, 0.5, len = 50),
  longlat = FALSE,
  cl = NULL,
  type = "poisson",
  min.cases = 0,
  simdist = "multinomial"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_scan_test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_ubpop_seq">ubpop_seq</code></td>
<td>
<p>A strictly increasing numeric vector with values between
min(pop)/sum(pop) and 1. The default is <code>seq(0.01, 0.5, len = 50)</code>.</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_min.cases">min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td></tr>
<tr><td><code id="seq_scan_test_+3A_simdist">simdist</code></td>
<td>
<p>Character string indicating the simulation
distribution. The default is <code>"multinomial"</code>, which
conditions on the total number of cases observed. The
other options are <code>"poisson"</code> and <code>"binomial"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of <code>length(ubpop_seq)</code>. Each element of the
list has &quot;pruned&quot; set of results (as a list) for a scan test. Element of
the pruned list has the elements <code>tobs</code>, <code>zones</code>, <code>pvalue</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan.test">scan.test</a></code>
</p>

<hr>
<h2 id='sig_noc'>Return most significant, non-overlapping zones</h2><span id='topic+sig_noc'></span>

<h3>Description</h3>

<p><code>sig_noc</code> return the significant, non-overlapping
zones order from most significant to least significant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_noc(tobs, zones, pvalue, alpha, order_by = "tobs")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_noc_+3A_tobs">tobs</code></td>
<td>
<p>The vector of observed test statistics for each zone</p>
</td></tr>
<tr><td><code id="sig_noc_+3A_zones">zones</code></td>
<td>
<p>A list of zones</p>
</td></tr>
<tr><td><code id="sig_noc_+3A_pvalue">pvalue</code></td>
<td>
<p>The p-value associated with each test statistic</p>
</td></tr>
<tr><td><code id="sig_noc_+3A_alpha">alpha</code></td>
<td>
<p>The significance level of the test.</p>
</td></tr>
<tr><td><code id="sig_noc_+3A_order_by">order_by</code></td>
<td>
<p>Either <code>'tobs'</code> or <code>'pvalue'</code>,
indicating the argument by which to order <code>zones</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the significant, ordered,
non-overlapping <code>tobs</code>, <code>zones</code>, <code>pvalue</code>.,
and <code>idx</code> (a vector with the relevant indices of
the original zones).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tobs &lt;- c(1, 3, 2)
zones &lt;- list(1:2, 1:3, 2:3)
pvalue &lt;- c(0.5, 0.01, 0.02)
sig_noc(tobs, zones, pvalue, alpha = 0.05)
</code></pre>

<hr>
<h2 id='sig_prune'>Prune significant, non-overlapping zones</h2><span id='topic+sig_prune'></span>

<h3>Description</h3>

<p><code>sig_prune</code> returns the significant
zones ordered from most significant to least significant (assuming the zones are already in order)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_prune(tobs, zones, pvalue, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_prune_+3A_tobs">tobs</code></td>
<td>
<p>The vector of observed test statistics for each zone</p>
</td></tr>
<tr><td><code id="sig_prune_+3A_zones">zones</code></td>
<td>
<p>A list of zones</p>
</td></tr>
<tr><td><code id="sig_prune_+3A_pvalue">pvalue</code></td>
<td>
<p>The p-value associated with each test statistic</p>
</td></tr>
<tr><td><code id="sig_prune_+3A_alpha">alpha</code></td>
<td>
<p>The significance level of the test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the significant, ordered,
non-overlapping <code>tobs</code>, <code>zones</code>, <code>pvalue</code>.,
and <code>idx</code> (a vector with the relevant indices of
the original zones).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tobs &lt;- c(3, 2, 1)
zones &lt;- list(1:2, 3:4, 5:6)
pvalue &lt;- c(0.001, 0.05, 0.15)
sig_prune(tobs, zones, pvalue, alpha = 0.05)
</code></pre>

<hr>
<h2 id='smerc'>smerc</h2><span id='topic+smerc'></span><span id='topic+smerc-package'></span>

<h3>Description</h3>

<p>*S*tatistical *ME*thods for *R*egional *C*ounts
</p>


<h3>Details</h3>

<p>The **smerc** package implements statistical methods for
analyzing the counts of areal data, with a focus on the
detection of spatial clusters and clustering. The package
has a heavy emphasis on spatial scan methods.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joshua French <a href="mailto:joshua.french@ucdenver.edu">joshua.french@ucdenver.edu</a> (<a href="https://orcid.org/0000-0002-9708-3353">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Mohammad Meysami (<a href="https://orcid.org/0000-0002-3322-5244">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/jfrench/smerc/issues">https://github.com/jfrench/smerc/issues</a>
</p>
</li></ul>


<hr>
<h2 id='smerc_cluster'>Prepare <code>smerc_cluster</code></h2><span id='topic+smerc_cluster'></span>

<h3>Description</h3>

<p><code>smerc_cluster</code> prepares a <code>smerc_cluster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smerc_cluster(
  tobs,
  zones,
  pvalue,
  coords,
  cases,
  pop,
  ex,
  longlat,
  method,
  rel_param,
  alpha,
  w = NULL,
  d = NULL,
  a = NULL,
  shape_all = NULL,
  angle_all = NULL,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smerc_cluster_+3A_tobs">tobs</code></td>
<td>
<p>The vector of observed test statistics for each zone</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_zones">zones</code></td>
<td>
<p>A list of zones</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_pvalue">pvalue</code></td>
<td>
<p>The p-value associated with each test statistic</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_method">method</code></td>
<td>
<p>A character string indicating the method
used to construct the <code>smerc_cluster</code>.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_rel_param">rel_param</code></td>
<td>
<p>A names list with the relevant parameters
associated with <code>method</code>.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_alpha">alpha</code></td>
<td>
<p>The significance level of the test.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_d">d</code></td>
<td>
<p>A precomputed distance matrix based on <code>coords</code></p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_a">a</code></td>
<td>
<p>A single value &gt;= 0 indicating the penalty to use
for <code><a href="#topic+elliptic.test">elliptic.test</a></code>.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_shape_all">shape_all</code></td>
<td>
<p>A vector of shape parameters associated
with <code>zones</code>.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_angle_all">angle_all</code></td>
<td>
<p>A vector of angle parameter associated with
<code>zones</code>.</p>
</td></tr>
<tr><td><code id="smerc_cluster_+3A_weights">weights</code></td>
<td>
<p>A vector of weights that multiply the <code>cases</code>, <code>ex</code>, and
<code>pop</code> prior to computing summary statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>smerc_cluster</code> object. The object
generally has the following components:
</p>
<table>
<tr><td><code>clusters</code></td>
<td>
<p>A list containing information about the significant
clusters.  See further details below.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>The matrix of centroid coordinates.</p>
</td></tr>
<tr><td><code>number_of_regions</code></td>
<td>
<p>The number of regions considered.</p>
</td></tr>
<tr><td><code>total_population</code></td>
<td>
<p>The total population in the regions.</p>
</td></tr>
<tr><td><code>total_cases</code></td>
<td>
<p>The total number of cases in the regions.</p>
</td></tr>
<tr><td><code>cases_per_100k</code></td>
<td>
<p>The rate of cases per 100,000 persons.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of the method applied.</p>
</td></tr>
<tr><td><code>rel_param</code></td>
<td>
<p>A list of relevant method parameters.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The significance level.</p>
</td></tr>
<tr><td><code>longlat</code></td>
<td>
<p>A logical value indicating which type
of distance was used.</p>
</td></tr>
</table>
<p>Each element of the <code>clusters</code> component has:
</p>
<table>
<tr><td><code>locids</code></td>
<td>
<p>The ids of the regions in the cluster.</p>
</td></tr>
<tr><td><code>centroid</code></td>
<td>
<p>The cluster centroid.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The radius of the region (from the starting
region to last region of the cluster).</p>
</td></tr>
<tr><td><code>max_dist</code></td>
<td>
<p>The maximum intercentroid distance between
all the regions in the cluster.</p>
</td></tr>
<tr><td><code>population</code></td>
<td>
<p>The total population in the cluster.</p>
</td></tr>
<tr><td><code>cases</code></td>
<td>
<p>The number of cases in the cluster.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>The expected number of cases in the cluster.</p>
</td></tr>
<tr><td><code>smr</code></td>
<td>
<p>Standardized mortality ratio
(<code>cases/expected</code>) in the cluster.</p>
</td></tr>
<tr><td><code>rr</code></td>
<td>
<p>Relative risk in the cluster window. This is
<code>(cases/pop)/((total_cases - cases)/
(total_population - population))</code>.</p>
</td></tr>
<tr><td><code>loglikrat</code></td>
<td>
<p>The log of the likelihood ratio test
statistic for the cluster. Only valid for the scan-type
tests.</p>
</td></tr>
<tr><td><code>test_statistic</code></td>
<td>
<p>The test statistic for the cluster.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The p-value of the test statistic
associated with the cluster.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>The adjacency information for the cluster.</p>
</td></tr>
</table>
<p>For <code><a href="#topic+elliptic.test">elliptic.test</a></code>, <code>clusters</code>
additionally has:
</p>
<table>
<tr><td><code>semiminor_axis</code></td>
<td>
<p>The semi-minor axis length for the
ellipse.</p>
</td></tr>
<tr><td><code>semimajor_axis</code></td>
<td>
<p>The
semi-major axis length for the ellipse.</p>
</td></tr>
<tr><td><code>angle</code></td>
<td>
<p>The rotation angle of the ellipse.</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>The shape of the ellipse.</p>
</td></tr>
</table>

<hr>
<h2 id='stat.poisson.adj'>Compute Poisson test statistic</h2><span id='topic+stat.poisson.adj'></span><span id='topic+stat_poisson_adj'></span><span id='topic+stat_binom_adj'></span>

<h3>Description</h3>

<p>Efficiently compute a vector of Poisson test statistics.
This function does no sanity checking. We encourage you
to compare the results against
<code><a href="#topic+scan.stat">scan.stat</a></code> for correctness.
<code>stat_poisson_adj</code> is a C++ version implementation
of the code and should be faster.
<code>stat_binomial_adj</code> is a C++ version implementation
of <code><a href="#topic+stat.binom">stat.binom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat.poisson.adj(
  yin,
  ty,
  logein,
  logeout,
  a = 0,
  pen = 1,
  min.cases = 2,
  return.max = FALSE
)

stat_poisson_adj(
  yin,
  ty,
  logein,
  logeout,
  a = 0,
  pen = 1,
  min.cases = 2,
  return.max = FALSE
)

stat_binom_adj(
  yin,
  ty,
  popin,
  popout,
  logpopin,
  logpopout,
  tpop,
  min.cases = 2,
  return.max = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat.poisson.adj_+3A_yin">yin</code></td>
<td>
<p>The total number of cases in the zone.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_logein">logein</code></td>
<td>
<p>The <code>log</code> of the expected number of
cases in each candidate zone.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_logeout">logeout</code></td>
<td>
<p>The <code>log</code> of the expected number of
cases outside of each candidate zone.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_a">a</code></td>
<td>
<p>A tuning parameter for the adjusted
log-likelihood ratio.  See details.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_pen">pen</code></td>
<td>
<p>The eccentricity penalty for each candidate
zone.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_min.cases">min.cases</code></td>
<td>
<p>The minimum number of cases required for
a cluster.  The default is 2.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_return.max">return.max</code></td>
<td>
<p>A logical value. Default is <code>FALSE</code>. If
<code>TRUE</code>, then only the maximum statistic is returned.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_popin">popin</code></td>
<td>
<p>The total population in the zone.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_popout">popout</code></td>
<td>
<p>The population outside the zone.  This
should be <code>tpop - popin</code> and is computed
automatically if not provided.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_logpopin">logpopin</code></td>
<td>
<p>The <code>log</code> of the population in each
candidate zone.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_logpopout">logpopout</code></td>
<td>
<p>The <code>log</code> of the population outside
of each candidate zone.</p>
</td></tr>
<tr><td><code id="stat.poisson.adj_+3A_tpop">tpop</code></td>
<td>
<p>The total population in the study area.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
enn &lt;- elliptic.nn(coords, nydf$pop, ubpop = 0.015)
cases &lt;- floor(nydf$cases)
ty &lt;- sum(cases)
ex &lt;- ty / sum(nydf$pop) * nydf$pop
yin &lt;- nn.cumsum(enn$nn, cases)
ein &lt;- nn.cumsum(enn$nn, ex)
logein &lt;- log(ein)
logeout &lt;- log(ty - ein)
pen &lt;- elliptic.penalty(a = 0.5, enn$shape_all)
stat.poisson.adj(yin, ty, logein, logeout,
  a = 0.5, pen = pen, return.max = TRUE
)
</code></pre>

<hr>
<h2 id='summary.smerc_cluster'>Summary of <code>smerc_cluster</code> object</h2><span id='topic+summary.smerc_cluster'></span>

<h3>Description</h3>

<p>Summary of object of class <code>smerc_cluster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smerc_cluster'
summary(object, ..., idx = seq_along(object$clusters), digits = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.smerc_cluster_+3A_object">object</code></td>
<td>
<p>An object of class <code>smerc_cluster</code>.</p>
</td></tr>
<tr><td><code id="summary.smerc_cluster_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+summary">base::summary</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
<tr><td><code id="summary.smerc_cluster_+3A_idx">idx</code></td>
<td>
<p>An index vector indicating the elements of
<code>object$clusters</code> to print information for. The default
is all clusters.</p>
</td></tr>
<tr><td><code id="summary.smerc_cluster_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns:
</p>
<table>
<tr><td><code>nregions</code></td>
<td>
<p>The number of regions in the cluster.</p>
</td></tr>
<tr><td><code>max_dist</code></td>
<td>
<p>The maximum intercentroid distance between all the regions
in the cluster.</p>
</td></tr>
<tr><td><code>cases</code></td>
<td>
<p>The number of cases in the cluster.</p>
</td></tr>
<tr><td><code>ex</code></td>
<td>
<p>The expected number of cases in the cluster.</p>
</td></tr>
<tr><td><code>rr</code></td>
<td>
<p>Relative risk in the cluster window. This is
<code>(cases/pop)/((total_cases - cases)/
(total_population - population))</code>.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>The test statistic for the cluster.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The p-value of the test statistic associated with the cluster.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- with(nydf, cbind(x, y))
out &lt;- scan.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, nsim = 49,
  longlat = TRUE, alpha = 0.2
)
# summarize all clusters
summary(out)
# summarize clusters 1 and 3
summary(out, idx = c(1, 3))
</code></pre>

<hr>
<h2 id='tango.stat'>Tango's statistic</h2><span id='topic+tango.stat'></span>

<h3>Description</h3>

<p><code>tango.stat</code> computes Tango's index (Tango, 1995),
including both the goodness-of-fit and spatial
autocorrelation components.  See Waller and Gotway
(2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tango.stat(cases, pop, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tango.stat_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="tango.stat_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="tango.stat_+3A_w">w</code></td>
<td>
<p>An <code class="reqn">n \times n</code> weights matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the test statistic
(<code>tstat</code>), the goodness-of-fit component
(<code>gof</code>), and the spatial autocorrelation component
(<code>sa</code>).
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T.  (1995) A class of tests for
detecting &quot;general&quot; and &quot;focused&quot; clustering of rare
diseases.  Statistics in Medicine.  14:2323-2334.
</p>
<p>Waller, L.A. and Gotway, C.A. (2005).  Applied Spatial
Statistics for Public Health Data.  Hoboken, NJ: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
w &lt;- dweights(coords, kappa = 1, type = "tango", longlat = TRUE)
tango.stat(nydf$cases, nydf$pop, w)
</code></pre>

<hr>
<h2 id='tango.test'>Tango's clustering detection test</h2><span id='topic+tango.test'></span>

<h3>Description</h3>

<p><code>tango.test</code> performs a test for clustering proposed
by Tango (1995).  The test uses Tango's chi-square
approximation for significance testing by default, but
also uses Monto Carlo simulation when <code>nsim &gt; 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tango.test(cases, pop, w, nsim = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tango.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="tango.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="tango.test_+3A_w">w</code></td>
<td>
<p>An <code class="reqn">n \times n</code> weights matrix.</p>
</td></tr>
<tr><td><code id="tango.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations for which to
perform a Monto Carlo test of significance.  Counts are
simulated according to a multinomial distribution with
<code>sum(cases)</code> total cases and class probabilities
<code>pop/sum(pop)</code>. <code>sum(cases)</code> .</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+dweights">dweights</a></code> function can be used to
construct a weights matrix <code>w</code> using the method of
Tango (1995), Rogerson (1999), or a basic style.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>tango</code> with
elements: </p>
<table>
<tr><td><code>tstat</code></td>
<td>
<p>Tango's index</p>
</td></tr>
<tr><td><code>tstat.chisq</code></td>
<td>
<p>The approximately chi-squared
statistic proposed by Tango that is derived from
<code>tstat</code></p>
</td></tr> <tr><td><code>dfc</code></td>
<td>
<p>The degrees of freedom of
<code>tstat.chisq</code></p>
</td></tr> <tr><td><code>pvalue.chisq</code></td>
<td>
<p>The p-value
associated with <code>tstat.chisq</code></p>
</td></tr>
<tr><td><code>tstat.sim</code></td>
<td>
<p>The vector of test statistics from the
simulated data if <code>nsim &gt; 0</code></p>
</td></tr>
<tr><td><code>pvalue.sim</code></td>
<td>
<p>The p-value associated with the Monte
Carlo test of significance when <code>nsim &gt; 0</code></p>
</td></tr>
</table>
<p>Additionally, the goodness-of-fit <code>gof</code> and
spatial autocorrelation <code>sa</code> components of the
Tango's index are provided (and for the simulated data
sets also, if appropriate).
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T.  (1995) A class of tests for
detecting &quot;general&quot; and &quot;focused&quot; clustering of rare
diseases.  Statistics in Medicine.  14, 2323-2334.
</p>
<p>Rogerson, P. (1999) The Detection of Clusters Using A
Spatial Version of the Chi-Square Goodness-of-fit Test.
Geographical Analysis. 31, 130-147
</p>
<p>Tango, T.  (2010) Statistical Methods for Disease
Clustering. Springer.
</p>
<p>Waller, L.A. and Gotway, C.A. (2005).  Applied Spatial
Statistics for Public Health Data.  Hoboken, NJ: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dweights">dweights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- as.matrix(nydf[, c("x", "y")])
w &lt;- dweights(coords, kappa = 1)
results &lt;- tango.test(nydf$cases, nydf$pop, w, nsim = 49)
</code></pre>

<hr>
<h2 id='tango.weights'>Distance-based weights for <code>tango.test</code></h2><span id='topic+tango.weights'></span><span id='topic+dweights'></span>

<h3>Description</h3>

<p><code>tango.weights</code> constructs a distance-based weights
matrix. The <code>tango.weights</code> function can be used to
construct a weights matrix <code>w</code> using the method of
Tango (1995), Rogerson (1999), or a basic style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tango.weights(coords, kappa = 1, longlat = FALSE, type = "basic", pop = NULL)

dweights(coords, kappa = 1, longlat = FALSE, type = "basic", pop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tango.weights_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="tango.weights_+3A_kappa">kappa</code></td>
<td>
<p>A positive constant related to strength of
spatial autocorrelation.</p>
</td></tr>
<tr><td><code id="tango.weights_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="tango.weights_+3A_type">type</code></td>
<td>
<p>The type of weights matrix to construct.
Current options are <code>"basic"</code>, <code>"tango"</code>, and
<code>"rogerson"</code>.  Default is <code>"basic"</code>.  See
Details.</p>
</td></tr>
<tr><td><code id="tango.weights_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coords</code> is used to construct an <code class="reqn">n \times n</code>
distance matrix <code>d</code>.
</p>
<p>If <code>type = "basic"</code>, then <code class="reqn">w_{ij} =
exp(-d_{ij}/\kappa)</code>.
</p>
<p>If <code>type = "rogerson"</code>, then <code class="reqn">w_{ij} =
exp(-d_{ij}/\kappa)/\sqrt(pop_i/pop * pop_j/pop)</code>.
</p>
<p>If <code>type = "tango"</code>, then <code class="reqn">w_{ij} = exp(-4 *
d_{ij}^2/\kappa^2)</code>.
</p>


<h3>Value</h3>

<p>Returns an <code class="reqn">n \times n</code> matrix of weights.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Tango, T.  (1995) A class of tests for
detecting &quot;general&quot; and &quot;focused&quot; clustering of rare
diseases.  Statistics in Medicine.  14:2323-2334.
</p>
<p>Rogerson, P. (1999) The Detection of Clusters Using A
Spatial Version of the Chi-Square Goodness-of-fit Test.
Geographical Analysis. 31:130-147
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tango.test">tango.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
coords &lt;- as.matrix(nydf[, c("longitude", "latitude")])
w &lt;- tango.weights(coords, kappa = 1, longlat = TRUE)
</code></pre>

<hr>
<h2 id='uls.sim'>Perform <code>uls.test</code> on simulated data</h2><span id='topic+uls.sim'></span>

<h3>Description</h3>

<p><code>uls.sim</code> efficiently performs
<code><a href="#topic+uls.test">uls.test</a></code> on a simulated data set.  The
function is meant to be used internally by the
<code><a href="#topic+uls.test">uls.test</a></code> function, but is informative for
better understanding the implementation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uls.sim(
  nsim = 1,
  ty,
  ex,
  w,
  pop,
  ubpop,
  type = "poisson",
  check.unique = FALSE,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uls.sim_+3A_nsim">nsim</code></td>
<td>
<p>A positive integer indicating the number of
simulations to perform.</p>
</td></tr>
<tr><td><code id="uls.sim_+3A_ty">ty</code></td>
<td>
<p>The total number of cases in the study area.</p>
</td></tr>
<tr><td><code id="uls.sim_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="uls.sim_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="uls.sim_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="uls.sim_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="uls.sim_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="uls.sim_+3A_check.unique">check.unique</code></td>
<td>
<p>A logical value indicating whether a
check for unique values should be determined.  The
default is <code>FALSE</code>.  This is unlikely to make a
practical different for most real data sets.</p>
</td></tr>
<tr><td><code id="uls.sim_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the maximum test statistic for each
simulated data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
cases &lt;- floor(nydf$cases)
pop &lt;- nydf$pop
ty &lt;- sum(cases)
ex &lt;- ty / sum(pop) * pop
tsim &lt;- uls.sim(1, ty, ex, nyw, pop = pop, ubpop = 0.5)
</code></pre>

<hr>
<h2 id='uls.test'>Upper Level Set Spatial Scan Test</h2><span id='topic+uls.test'></span>

<h3>Description</h3>

<p><code>uls.test</code> performs the Upper Level Set (ULS)
spatial scan test of Patil and Taillie (2004).  The test
is performed using the spatial scan test based on a fixed
number of cases.  The windows are based on the Upper
Level Sets proposed by Patil and Taillie (2004).  The
clusters returned are non-overlapping, ordered from most
significant to least significant.  The first cluster is
the most likely to be a cluster.  If no significant
clusters are found, then the most likely cluster is
returned (along with a warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uls.test(
  coords,
  cases,
  pop,
  w,
  ex = sum(cases)/sum(pop) * pop,
  nsim = 499,
  alpha = 0.1,
  ubpop = 0.5,
  longlat = FALSE,
  cl = NULL,
  type = "poisson",
  check.unique = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uls.test_+3A_coords">coords</code></td>
<td>
<p>An <code class="reqn">n \times 2</code> matrix of centroid
coordinates for the regions in the form (x, y) or
(longitude, latitude) is using great circle distance.</p>
</td></tr>
<tr><td><code id="uls.test_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="uls.test_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="uls.test_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="uls.test_+3A_ex">ex</code></td>
<td>
<p>The expected number of cases for each region.
The default is calculated under the constant risk
hypothesis.</p>
</td></tr>
<tr><td><code id="uls.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute the p-value.</p>
</td></tr>
<tr><td><code id="uls.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether
a cluster is signficant.  Default is 0.10.</p>
</td></tr>
<tr><td><code id="uls.test_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="uls.test_+3A_longlat">longlat</code></td>
<td>
<p>The default is <code>FALSE</code>, which
specifies that Euclidean distance should be used. If
<code>longlat</code> is <code>TRUE</code>, then the great circle
distance is used to calculate the intercentroid
distance.</p>
</td></tr>
<tr><td><code id="uls.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="uls.test_+3A_type">type</code></td>
<td>
<p>The type of scan statistic to compute. The
default is <code>"poisson"</code>. The other choice
is <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="uls.test_+3A_check.unique">check.unique</code></td>
<td>
<p>A logical value indicating whether a
check for unique values should be determined.  The
default is <code>FALSE</code>.  This is unlikely to make a
practical different for most real data sets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ULS method has a special (and time consuming)
construction when the observed rates aren't unique.  This
is unlikely to arise for real data, except with observed
rates of 0, which are of little interest.  The method can
take substantially if this is considered.
</p>


<h3>Value</h3>

<p>Returns a list of length two of class scan. The
first element (clusters) is a list containing the
significant, non-ovlappering clusters, and has the the
following components: </p>
<table>
<tr><td><code>locids</code></td>
<td>
<p>The location ids of
regions in a significant cluster.</p>
</td></tr> <tr><td><code>pop</code></td>
<td>
<p>The total
population in the cluser window.</p>
</td></tr> <tr><td><code>cases</code></td>
<td>
<p>The
observed number of cases in the cluster window.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>The expected number of cases in the
cluster window.</p>
</td></tr> <tr><td><code>smr</code></td>
<td>
<p>Standarized mortaility
ratio (observed/expected) in the cluster window.</p>
</td></tr>
<tr><td><code>rr</code></td>
<td>
<p>Relative risk in the cluster window.</p>
</td></tr>
<tr><td><code>loglikrat</code></td>
<td>
<p>The loglikelihood ratio for the
cluster window (i.e., the log of the test statistic).</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The pvalue of the test statistic
associated with the cluster window.</p>
</td></tr></table>
<p> The second element
of the list is the centroid coordinates.  This is
needed for plotting purposes.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Patil, G.P. &amp; Taillie, C. Upper level set
scan statistic for detecting arbitrarily shaped
hotspots. Environmental and Ecological Statistics
(2004) 11(2):183-197.
&lt;doi:10.1023/B:EEST.0000027208.48919.7e&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.smerc_cluster">print.smerc_cluster</a></code>,
<code><a href="#topic+summary.smerc_cluster">summary.smerc_cluster</a></code>,
<code><a href="#topic+plot.smerc_cluster">plot.smerc_cluster</a></code>,
<code><a href="#topic+scan.stat">scan.stat</a></code>, <code><a href="#topic+scan.test">scan.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
coords &lt;- with(nydf, cbind(longitude, latitude))
out &lt;- uls.test(
  coords = coords, cases = floor(nydf$cases),
  pop = nydf$pop, w = nyw,
  alpha = 0.05, longlat = TRUE,
  nsim = 9, ubpop = 0.5
)
# better plotting
if (require("sf", quietly = TRUE)) {
   data(nysf)
   plot(st_geometry(nysf), col = color.clusters(out))
}
</code></pre>

<hr>
<h2 id='uls.zones'>Determine sequence of ULS zones.</h2><span id='topic+uls.zones'></span>

<h3>Description</h3>

<p><code>uls.zones</code> determines the unique zones obtained by
implementing the ULS (Upper Level Set) test of Patil and
Taillie (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uls.zones(cases, pop, w, ubpop = 0.5, check.unique = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uls.zones_+3A_cases">cases</code></td>
<td>
<p>The number of cases observed in each region.</p>
</td></tr>
<tr><td><code id="uls.zones_+3A_pop">pop</code></td>
<td>
<p>The population size associated with each
region.</p>
</td></tr>
<tr><td><code id="uls.zones_+3A_w">w</code></td>
<td>
<p>A binary spatial adjacency matrix for the
regions.</p>
</td></tr>
<tr><td><code id="uls.zones_+3A_ubpop">ubpop</code></td>
<td>
<p>The upperbound of the proportion of the
total population to consider for a cluster.</p>
</td></tr>
<tr><td><code id="uls.zones_+3A_check.unique">check.unique</code></td>
<td>
<p>A logical value indicating whether a
check for unique values should be determined.  The
default is <code>FALSE</code>.  This is unlikely to make a
practical different for most real data sets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zones returned must have a total population less than
<code>ubpop * sum(pop)</code> of all regions in the study area.
</p>


<h3>Value</h3>

<p>Returns a list of zones to consider for
clustering.  Each element of the list contains a vector
with the location ids of the regions in that zone.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Patil, G.P. &amp; Taillie, C. Upper level set
scan statistic for detecting arbitrarily shaped
hotspots. Environmental and Ecological Statistics
(2004) 11(2):183-197.
&lt;doi:10.1023/B:EEST.0000027208.48919.7e&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nydf)
data(nyw)
uls.zones(cases = nydf$cases, pop = nydf$population, w = nyw)
</code></pre>

<hr>
<h2 id='w2segments'>Returns segments connecting neighbors</h2><span id='topic+w2segments'></span>

<h3>Description</h3>

<p>w2segments takes a binary spatial proximity matrix and
associated coordinates.  It returns segments connecting
the neighbors for plotting purposes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w2segments(w, coords)
</code></pre>

<hr>
<h2 id='zones.sum'>Sum over zones</h2><span id='topic+zones.sum'></span>

<h3>Description</h3>

<p><code>zones.sum</code> computes the sum of <code>y</code> for the
indices in each element of the list contained in <code>zones</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zones.sum(zones, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zones.sum_+3A_zones">zones</code></td>
<td>
<p>A list of nearest neighbors in the format
produced by <code><a href="#topic+scan.zones">scan.zones</a></code>.</p>
</td></tr>
<tr><td><code id="zones.sum_+3A_y">y</code></td>
<td>
<p>A numeric vector of values to be summed over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># show nn.cumsum example for a circular scan setting
data(nydf)
coords &lt;- with(nydf, cbind(longitude, latitude))
cases &lt;- floor(nydf$cases)
zones &lt;- scan.zones(coords, pop = nydf$pop, ubpop = 0.1)
# compute cumulative sums over all nn
szones &lt;- zones.sum(zones, cases)
# compute cumulative sums over just the first set of nn
szones2 &lt;- sapply(zones, function(x) sum(cases[x]))
# check equality
all.equal(szones, szones2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
