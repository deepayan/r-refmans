<!DOCTYPE html><html lang="en"><head><title>Help for package windAC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {windAC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calcAC'><p>Calculate the area correction value(s) with confidence intervals</p></a></li>
<li><a href='#carcassDistance'><p>Carcass distance example data set</p></a></li>
<li><a href='#circleBoxInt'><p>Integration of the intersection of a rectangle and a circle</p></a></li>
<li><a href='#estTWL'><p>Truncated Weighted Likelihood Estimation</p></a></li>
<li><a href='#estWD'><p>Weighted Distribution Estimation</p></a></li>
<li><a href='#geometricRectanglePropSearchTable'><p>Create proportion of area searched table for a rectangular full plot</p></a></li>
<li><a href='#geometricRoadPadPropSearchTable'><p>Calculate the areas of intersection of a series of nested annuli with an idealized access road and turbine pad.</p></a></li>
<li><a href='#getDistanceProbability'><p>Calculate probabilities within one unit increments.</p></a></li>
<li><a href='#getDistributionFunction'><p>Getting distribution functions</p></a></li>
<li><a href='#getDistributionSummary'><p>Summary statistics from the fitted distribution</p></a></li>
<li><a href='#getProportionAreaSearched'><p>Create proportion of area searched table from spatial data</p></a></li>
<li><a href='#getStartValue'><p>Calculate the start values to be passed to the optimizer.</p></a></li>
<li><a href='#hallingstad'><p>Data sets from Hallingstad et al. 2018</p></a></li>
<li><a href='#hullMuirAreaCorrection'><p>Calculate an area correction based on the Hull and Muir (2010) maximum</p>
distance and a triangular distribution as proposed by Huso and Dalthorp (2014).</a></li>
<li><a href='#hullMuirMaxDistance'><p>Calculate the Hull and Muir (2010) maximum distance</p></a></li>
<li><a href='#LogLogistic'><p>Log-Logistic Distribution</p></a></li>
<li><a href='#print.windAC'><p>Print <code>windAC</code> object</p></a></li>
<li><a href='#proportionAreaSearched'><p>Proportion of area searched example data set</p></a></li>
<li><a href='#secondDerivative'><p>secondDerivative</p></a></li>
<li><a href='#triangleProb'><p>Calculate probabilities from a triangle distribution based on Hull and</p>
Muir (2010) maximum distance as proposed by Huso and Dalthorp (2014).</a></li>
<li><a href='#truncatedDistribution'><p>Truncated Distributions</p></a></li>
<li><a href='#turbineSpatial'><p>Data sets of spatial area searched at a wind farm</p></a></li>
<li><a href='#weightFun'><p>weight function</p></a></li>
<li><a href='#windAC'><p>A package for calculating area correction values for fatality estimation at wind farms.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Area Correction Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Rabie [aut],
  Daniel Riser-Espinoza [aut, cre],
  Trent McDonald [ctb]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), sf</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Riser-Espinoza &lt;despinoza@west-inc.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Post-construction fatality monitoring studies at wind facilities are based on data from searches for bird and bat carcasses in plots beneath turbines. Bird and bat carcasses can fall outside of the search plot. Bird and bat carcasses from wind turbines often fall outside of the searched area. To compensate, area correction (AC) estimations are calculated to estimate the percentage of fatalities that fall within the searched area versus those that fall outside of it. This package provides two likelihood based methods and one physics based method (Hull and Muir (2010) &lt;<a href="https://doi.org/10.1080%2F14486563.2010.9725253">doi:10.1080/14486563.2010.9725253</a>&gt;, Huso and Dalthorp (2014) &lt;<a href="https://doi.org/10.1002%2Fjwmg.663">doi:10.1002/jwmg.663</a>&gt;) to estimate the carcass fall distribution. There are also functions for calculating the proportion of area searched within one unit annuli, log logistic distribution functions, and truncated distribution functions.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GNU General Public License]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-22 18:35:40 UTC; cmurray</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-22 19:20:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='calcAC'>Calculate the area correction value(s) with confidence intervals</h2><span id='topic+calcAC'></span>

<h3>Description</h3>

<p>Use a fitted carcass density distribution and data describing the search area to calculate area correction values and confidence intervals using a
parametric bootstrap approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcAC(
  distribution,
  paramVec,
  varcovVec = NULL,
  proportionSearchDF,
  distanceCol,
  proportionCol,
  additionalCol = NULL,
  nBoot = NULL,
  truncBounds = NULL,
  ciLevel = 0.9,
  randomSeed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcAC_+3A_distribution">distribution</code></td>
<td>
<p>Character indicating the distribution, passed to
<code><a href="#topic+getDistanceProbability">getDistanceProbability</a></code>.</p>
</td></tr>
<tr><td><code id="calcAC_+3A_paramvec">paramVec</code></td>
<td>
<p>Numeric vector for the parameters associated with distribution. Assumed to be in the same order as the function indicated by <code>distribution</code>.</p>
</td></tr>
<tr><td><code id="calcAC_+3A_varcovvec">varcovVec</code></td>
<td>
<p>Numeric vector for the variances and covariances for
<code>paramVec</code>, default is NULL, see details.</p>
</td></tr>
<tr><td><code id="calcAC_+3A_proportionsearchdf">proportionSearchDF</code></td>
<td>
<p>Data frame with at least two columns: distance of the outer edge of an annulus from
turbine and proportion of area searched within each annulus.</p>
</td></tr>
<tr><td><code id="calcAC_+3A_distancecol">distanceCol</code></td>
<td>
<p>Character indicating the column name for the distance from
turbine</p>
</td></tr>
<tr><td><code id="calcAC_+3A_proportioncol">proportionCol</code></td>
<td>
<p>Character indicating the column name for the proportion of
area searched.</p>
</td></tr>
<tr><td><code id="calcAC_+3A_additionalcol">additionalCol</code></td>
<td>
<p>Character vector, default is NULL, indicating additional
columns of how the area correction value should be calculated, see details and examples.</p>
</td></tr>
<tr><td><code id="calcAC_+3A_nboot">nBoot</code></td>
<td>
<p>Integer, indicating the number of parametric
bootstrap replicates to use. Default is NULL, and not confidence intervals are produced.</p>
</td></tr>
<tr><td><code id="calcAC_+3A_truncbounds">truncBounds</code></td>
<td>
<p>Numeric, indicating bounds for the area
correction calculation, see details. Default is NULL, and the bounds are set to <code>c(0,Inf)</code>.</p>
</td></tr>
<tr><td><code id="calcAC_+3A_cilevel">ciLevel</code></td>
<td>
<p>Numeric, default is 0.9, desired confidence level for the
bootstrap confidence interval.</p>
</td></tr>
<tr><td><code id="calcAC_+3A_randomseed">randomSeed</code></td>
<td>
<p>Numeric value of random seed, default is NULL.</p>
</td></tr>
<tr><td><code id="calcAC_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+getDistanceProbability">getDistanceProbability</a></code> and <code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+getDistanceProbability">getDistanceProbability</a></code> is used to calculate
the probability (fraction of carcasses) in the intervals between distances in <code>proportionSearchDF</code>.
</p>
<p>The <code>truncBounds</code> argument defaults to zero as a lower bound and infinity
as the upper bound. If a single value is provided, it is assumed as the upper
bound with zero as the lower bound. If two or more values are provided, the
<code>max(truncBounds)</code> is the upper bound and <code>min(truncBounds)</code> is the
lower bound.
</p>
<p>If <code>varcovVec</code> is NULL, then parametric bootstrapping is impossible and a confidence interval is not estimated. The
<code>varcovVec</code> should be in such an order that correctly fills the lower
triangle including the diagonal. The first column is filled, then the second,
and so on. This forms the variance-covariance matrix for the parameters.
</p>
<p>If <code>nBoot</code> is greater than zero, a parametric bootstrap is done.
Bootstrap parameters are generated using the <code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>
function.
</p>
<p>If the additionalCol argument is not NULL, separate area corrections are estimated for each unique value within the column.
</p>


<h3>Value</h3>

<p><code>windAC</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weightedLikelihood">weightedLikelihood</a></code> <code><a href="#topic+weightedDistribution">weightedDistribution</a></code> <code><a href="#topic+getDistanceProbability">getDistanceProbability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## proportion of area searched data
data(proportionAreaSearched)

## no parametric bootstrap
noBootstrap &lt;- calcAC(distribution = 'gamma',
                      paramVec = c(2.483323, 0.02495139),
                      varcovVec = NULL,
                      proportionSearchDF = proportionAreaSearched,
                      distanceCol = 'distanceFromTurbine',
                      proportionCol = 'proportionAreaSearched',
                      additionalCol = 'plotType')

## with a parametric bootstrap

withBootstrap &lt;- calcAC(distribution = 'gamma',
                        paramVec = c(2.483323, 0.02495139),
                        varcovVec = c(0.041189428, 0.0008825275, 2.118081e-05),
                        proportionSearchDF = proportionAreaSearched,
                        distanceCol = 'distanceFromTurbine',
                        proportionCol = 'proportionAreaSearched',
                        additionalCol = 'plotType',
                        nBoot = 10)

</code></pre>

<hr>
<h2 id='carcassDistance'>Carcass distance example data set</h2><span id='topic+carcassDistance'></span>

<h3>Description</h3>

<p>Example data set of carcass distance found during searches under wind turbines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(carcassDistance)
</code></pre>


<h3>Format</h3>

<p>A data frame with 56 rows and 6 variables:
</p>

<dl>
<dt>season</dt><dd><p>The season in which that carcass was found.</p>
</dd>
<dt>plotType</dt><dd><p>The plot type (either FULL or RP) that was being searched when the carcass was found.</p>
</dd>
<dt>proportionTurbineType</dt><dd><p> The proportion of turbines that have that plot type. For <code>plotType=FULL</code> the value is 0.1 and 0.9 for <code>plotType=RP</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>distanceFromTurbine</dt><dd><p> Meters, carcass distance from the turbine.</p>
</dd>
<dt>compassBearingDegree</dt><dd><p>Degrees, the compass bearing from the turbine to the carcass location. Zero degrees is north, 90 degrees is east, etc.</p>
</dd>
<dt>probabilityDetection</dt><dd><p>The summarized probability of detection from the bias trial information.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The fictitious wind farm has 100 turbines.
For 90 turbines the search plot consists of the turbine pad and the road out to 100 meters (RP = road and pad).
The remaining 10 turbines had full plots (FULL) that are circular with a radius of 100 meters.
The wind farm was searched during two seasons: Spring and Fall.
</p>
<p>The example carcasses are all the same size class (bats).
</p>
<p>Bias trials are also done to account for searcher efficiency and carcass removal.
These results are summarized as a probability of detection in the data set.
</p>


<h3>References</h3>

<p><a href="https://tethys.pnnl.gov/publications/us-fish-wildlife-service-land-based-wind-energy-guidelines">https://tethys.pnnl.gov/publications/us-fish-wildlife-service-land-based-wind-energy-guidelines</a>
</p>

<hr>
<h2 id='circleBoxInt'>Integration of the intersection of a rectangle and a circle</h2><span id='topic+circleBoxInt'></span>

<h3>Description</h3>

<p>Calculates the area of the intersection between a rectangle and and circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleBoxInt(R, S, L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circleBoxInt_+3A_r">R</code></td>
<td>
<p>Numeric, circle radius.</p>
</td></tr>
<tr><td><code id="circleBoxInt_+3A_s">S</code></td>
<td>
<p>Numeric, short side of the rectangle</p>
</td></tr>
<tr><td><code id="circleBoxInt_+3A_l">L</code></td>
<td>
<p>Numeric, long side of the rectangle</p>
</td></tr>
<tr><td><code id="circleBoxInt_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rectangle is defined with lower left corner being the origin and upper right corner at (L, S). The area returned is the intersection between the circle, centered at the origin, and the rectangle.
</p>
<p>If <code class="reqn">R \leq S</code> then <code class="reqn">(\pi R^2)/4</code> is returned.
</p>
<p>If <code class="reqn">R \geq \sqrt{S^2 + L^2}</code> then <code class="reqn">L*S</code> is returned.
</p>
<p>If <code class="reqn">R \leq L</code> then <code class="reqn">R^2*sin^{-1}(S/R)/2 + S*\sqrt(R^2-S^2)/2</code>
This is the area of a circle in the first quadrant between the horizontial line <code class="reqn">y=S</code>
</p>
<p>if <code class="reqn">R &gt; L</code> and <code class="reqn">R &lt; \sqrt{S^2 + L^2}</code> then
</p>
<p style="text-align: center;"><code class="reqn">(R^2*sin^{-1}(S/R)/2 + S*\sqrt(R^2-S^2)/2) - (R^2*sin^{-1}(B/R)/2 + S*\sqrt(R^2-B^2)/2) + B*L</code>
</p>

<p>where <code class="reqn">B = \sqrt{R^2 - L^2}</code>. In this case the there is part of the circle to the right of the rectangle. First set of parenthesis is the area of the circle below <code>S</code>, the second set is the area below <code>B</code>. Substracting the two gives the area between <code>B</code> and <code>S</code>. The rectangle defined by <code>B</code> and <code>L</code> needs to be added back in.
</p>


<h3>Value</h3>

<p>Numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
radius &lt;- 115
short &lt;- 80
long &lt;- 100
circleBoxInt(R=radius,S=short,L=long)

## not run
## the integral is the area inside the polygon

 x &lt;- seq(0,max(radius,long),length=100)
outlineY &lt;- function(x,R,S,L){
    suppressWarnings(y &lt;- sqrt(R^2-x^2))
   y[x&gt;R] &lt;- 0
   y[x&gt;L] &lt;- 0
   y[y&gt;=S] &lt;- S
   return(y)
}
y &lt;- outlineY(x=x,R=radius,S=short,L=long)
plot(x,y,type='l',ylim=c(-10,short))
text(long,0,label='L',pos=1)
text(0,short,label='S',pos=1)
text(long,sqrt(radius^2-long^2),label='B',pos=4)

</code></pre>

<hr>
<h2 id='estTWL'>Truncated Weighted Likelihood Estimation</h2><span id='topic+estTWL'></span><span id='topic+weightedLikelihood'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of a (possibly truncated) probability density function is completed with weights on the likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estTWL(fatDist, fatW, distribution, plotBounds = NULL, ...)

weightedLikelihood(fatDist, fatW, distribution, plotBounds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estTWL_+3A_fatdist">fatDist</code></td>
<td>
<p>Vector of fatality distances from the turbine.</p>
</td></tr>
<tr><td><code id="estTWL_+3A_fatw">fatW</code></td>
<td>
<p>Vector of weights, to weight the likelihood for estimatation. This must be the same length as fatDist and is assumed to be in the same order as fatDist.</p>
</td></tr>
<tr><td><code id="estTWL_+3A_distribution">distribution</code></td>
<td>
<p>Character indicating the distribution for <code>weightedLikelihood</code> or vector for <code>estTWL</code>.</p>
</td></tr>
<tr><td><code id="estTWL_+3A_plotbounds">plotBounds</code></td>
<td>
<p>Vector of length 1 or 2. If the length is 2 (or greater) the max value is used as the upper truncation bound and the min value is used as the lower truncation bound. If the length is 1 this value is taken as the upper truncation bound and zero is set as the lower truncation bound. The default is NULL, in which case the bounds are zero and positive infinity.</p>
</td></tr>
<tr><td><code id="estTWL_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The truncated likelihood for a single observation is
</p>
<p style="text-align: center;"><code class="reqn">L^*(\theta|x_i) = \frac{f(x_i|\theta)}{\int_{a}^{b}f(y|\theta)dy}</code>
</p>

<p>Where <code class="reqn">x_i</code> is <code>fatDist</code>, <code class="reqn">\theta</code> is the vector of parameters to be estimated, <code>a</code> and <code>b</code> correspond to the <code>plotBounds</code> and <code>f()</code> is the <code>distribution</code> chosen.
</p>
<p>The truncated weighted likelihood is
</p>
<p style="text-align: center;"><code class="reqn">TWL(\theta|\underbar{x}) = \prod_{i=1}^{n}L^*(\theta|x_i)^{w_i}</code>
</p>

<p>Where <code>n=length(fatDist)</code> and <code class="reqn">w_i</code> is <code>fatW</code>.
</p>
<p>The truncated weighted likelihood is then estimated using standard maximum likelihood techniques.
</p>
<p>See <code><a href="#topic+estTWL">estTWL</a></code> for examples.
</p>


<h3>Value</h3>

<p>Data frame of the parameter estimates for the distribution with fit statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcAC">calcAC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the data
data(carcassDistance)
data(proportionAreaSearched)

## add proportion of area searched to each carcass
carcDist &lt;- merge(carcassDistance,proportionAreaSearched,
by=c('plotType','distanceFromTurbine'),all.x=TRUE)

## create the weight for each carcass
carcDist$w &lt;- with(carcDist,1/(proportionAreaSearched*probabilityDetection))

twlOutput &lt;- with(carcDist,estTWL(fatDist=distanceFromTurbine,fatW=w,plotBounds=c(0,100),
distribution=c('norm','weibull','gamma')))

</code></pre>

<hr>
<h2 id='estWD'>Weighted Distribution Estimation</h2><span id='topic+estWD'></span><span id='topic+weightedDistribution'></span>

<h3>Description</h3>

<p>Maximum likelihood estimatation of a weighted probability density function is completed. is done on a weighted distribution.
The weighted distribution is a typical probability density distribution multiplied by a weight function. The weight function can be used to truncate the distribution by returning zero beyond some threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estWD(fatDist, weightFun, distribution, ...)

weightedDistribution(fatDist, weightFun, distribution, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estWD_+3A_fatdist">fatDist</code></td>
<td>
<p>Vector of fatality distanes from the turbine.</p>
</td></tr>
<tr><td><code id="estWD_+3A_weightfun">weightFun</code></td>
<td>
<p>R function that is multipled by the probability distribution, see details.</p>
</td></tr>
<tr><td><code id="estWD_+3A_distribution">distribution</code></td>
<td>
<p>Character indicating the distribution for <code>weightedDistribution</code> or vector for <code>estWD</code>.</p>
</td></tr>
<tr><td><code id="estWD_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>weightFun</code> or <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>estWD</code> is a convient wrapper function to <code>weightedDistribution</code>, for fitting multiple distributions.
</p>
<p>The weight function should return a (relative) probability of detection at every distance.
Typically this is the proportion of area searched.
The function <code><a href="#topic+weightFun">weightFun</a></code> is set up to take a table of proportion of area searched and return values in a function format.
</p>
<p>Let <code class="reqn">h(x)</code> be the weight function (<code>weightFun</code>), <code class="reqn">f(x|\theta)</code> be a probability density function (specified by <code>distribution</code>, <code class="reqn">x</code> be the vector of carcass distances from the turbine (<code>fatDist</code>), and <code class="reqn">\theta</code> be the parameter vector to be estimated.
The weighted distribution is
</p>
<p style="text-align: center;"><code class="reqn">f_{d}(x|\theta) = \frac{h(x)f(x|\theta)}{\int h(y)f(y|\theta)dy}</code>
</p>

<p>The likelihood that is maximized is
</p>
<p style="text-align: center;"><code class="reqn">L_{d}(\theta|\underbar{x}) = \prod_{i=1}^{n}\frac{h(x_i)f(x_i|\theta)}{\int h(y)f(y|\theta)dy}</code>
</p>



<h3>Value</h3>

<p>Data frame of the parameter estimates with fit statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcAC">calcAC</a></code>
</p>
<p><code><a href="#topic+weightFun">weightFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the data
data(carcassDistance)
data(proportionAreaSearched)

###############################################
## fit for fall carcasses found on road and pad (RP)
distanceFallRP &lt;- subset(carcassDistance,plotType=='RP'&amp;season=='fall',
select=distanceFromTurbine,drop=TRUE)


fallRPFit &lt;- estWD(fatDist=distanceFallRP,weightFun=weightFun,
distribution=c('norm','gamma','weibull'),propTable=proportionAreaSearched,type='RP',
typeCol='plotType',distanceCol='distanceFromTurbine',propCol='proportionAreaSearched',
maxDistance=100)


###############################################
## fit for fall carcasses found on full plots
distanceFallFP &lt;- subset(carcassDistance,plotType=='FULL'&amp;season=='fall',
select=distanceFromTurbine,drop=TRUE)


fallFPFit &lt;- estWD(fatDist=distanceFallFP,weightFun=weightFun,
distribution=c('norm','gamma','weibull'),propTable=proportionAreaSearched,type='FULL',
typeCol='plotType',distanceCol='distanceFromTurbine',propCol='proportionAreaSearched',
maxDistance=100)


</code></pre>

<hr>
<h2 id='geometricRectanglePropSearchTable'>Create proportion of area searched table for a rectangular full plot</h2><span id='topic+geometricRectanglePropSearchTable'></span>

<h3>Description</h3>

<p>Calculate the areas of intersection of a series of nested annuli with a rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geometricRectanglePropSearchTable(
  side1,
  side2 = side1,
  mastRadius,
  annulusWidth = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geometricRectanglePropSearchTable_+3A_side1">side1</code></td>
<td>
<p>Numeric, length of the side of the rectangle</p>
</td></tr>
<tr><td><code id="geometricRectanglePropSearchTable_+3A_side2">side2</code></td>
<td>
<p>Numeric, length of the second side of the rectangle, default is
<code>side1</code> which produces a square.</p>
</td></tr>
<tr><td><code id="geometricRectanglePropSearchTable_+3A_mastradius">mastRadius</code></td>
<td>
<p>Integer, radius of the turbine mast.</p>
</td></tr>
<tr><td><code id="geometricRectanglePropSearchTable_+3A_annuluswidth">annulusWidth</code></td>
<td>
<p>Integer, width of annulus, default is 1</p>
</td></tr>
<tr><td><code id="geometricRectanglePropSearchTable_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Searches are conducted around a turbine within a rectangle for bird
and bat carcasses. This function creates a data frame of proportion of area
searched within each annulus ring. The turbine is assumed to be centered
within the rectangle.
</p>


<h3>Value</h3>

<p>Data frame of proportion of area searched for each annulus. <code>distanceFromTurbine</code> column represents the outer radius of each annulus.
</p>


<h3>See Also</h3>

<p>geometricRoadPadPropSearchTable circleBoxInt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## square 50 x 50
propSearch &lt;- geometricRectanglePropSearchTable(side1 = 50,
                                                mastRadius = 2)


## square 50 x 70
propSearch &lt;- geometricRectanglePropSearchTable(side1 = 50,
                                                side2 = 70,
                                                mastRadius = 2)



</code></pre>

<hr>
<h2 id='geometricRoadPadPropSearchTable'>Calculate the areas of intersection of a series of nested annuli with an idealized access road and turbine pad.</h2><span id='topic+geometricRoadPadPropSearchTable'></span>

<h3>Description</h3>

<p>Calculate area of annulus bisected by 2 parallel lines (e.g. a
road of a road/pad plot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geometricRoadPadPropSearchTable(
  padRadius,
  roadWidth,
  maxSearchRadius,
  mastRadius,
  annulusWidth = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geometricRoadPadPropSearchTable_+3A_padradius">padRadius</code></td>
<td>
<p>Integer, radius of turbine pad from the center of the turbine.</p>
</td></tr>
<tr><td><code id="geometricRoadPadPropSearchTable_+3A_roadwidth">roadWidth</code></td>
<td>
<p>Integer, width of road leading to turbine pad.</p>
</td></tr>
<tr><td><code id="geometricRoadPadPropSearchTable_+3A_maxsearchradius">maxSearchRadius</code></td>
<td>
<p>Integer, maximum search distance from the center of turbine.</p>
</td></tr>
<tr><td><code id="geometricRoadPadPropSearchTable_+3A_mastradius">mastRadius</code></td>
<td>
<p>Integer, radius of the turbine mast.</p>
</td></tr>
<tr><td><code id="geometricRoadPadPropSearchTable_+3A_annuluswidth">annulusWidth</code></td>
<td>
<p>Integer, width of annulus, default is 1.</p>
</td></tr>
<tr><td><code id="geometricRoadPadPropSearchTable_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Searches are conducted on the road and turbine pad around wind
turbines for bird and bat fatalities. This function creates a data frame of
proportion of area searched within each annulus ring on an idealized road and pad.
The turbine is assumed to be centered on a perfectly circular turbine pad with radius <code>padRadius</code>, and a perfectly straight access road of width <code>roadWidth</code> is oriented from the center of the circle away from the turbine.
(The resulting road and pad looks like rather like a lollipop.)
</p>
<p>The <code>mastRadius</code> argument is to account for the area taken up by the turbine mast.
</p>
<p>The arguments <code>padRadius</code>, <code>roadWidth</code>, <code>mastRadius</code>, and
<code>annulusWidth</code> are all rounded to the nearest integer. The <code>maxSearchDistance</code>
is rounded up (ceiling function) to an integer. If half units are needed, then
convert to a smaller unit. See examples.
</p>


<h3>Value</h3>

<p>Data frame of proportion of area searched for each annulus.  <code>distanceFromTurbine</code> column represents the outer radius of each annulus.
</p>


<h3>See Also</h3>

<p>geometricRectanglePropSearchTable circleBoxInt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pad &lt;- 10 #meters, turbine pad radius
road &lt;- 4 #meters, width of the road to the turbine pad
maxDistance &lt;- 100 #meters, max distance
mast &lt;- 2 #meters, turbine mast radius

## proportion are area searched at each annulus
propSearch &lt;- geometricRoadPadPropSearchTable(padRadius = pad,
                                              roadWidth = road,
                                              maxSearchRadius = maxDistance,
                                              mastRadius = mast)
head(propSearch, 20)

## if half meter annulus rings are desired:
convert &lt;- 100 # meters * 100 = centimeters

## units in centimeters
propSearchHalfMeter &lt;- geometricRoadPadPropSearchTable(padRadius = pad * convert,
                                              roadWidth = road*convert,
                                              maxSearchRadius = maxDistance * convert,
                                              mastRadius = mast * convert,
                                              annulusWidth = 50) ##50cm = half a meter
head(propSearchHalfMeter, 30)

## convert back to meters
propSearchHalfMeter$distanceFromTurbine &lt;- propSearchHalfMeter$distanceFromTurbine/convert
head(propSearchHalfMeter, 30)

</code></pre>

<hr>
<h2 id='getDistanceProbability'>Calculate probabilities within one unit increments.</h2><span id='topic+getDistanceProbability'></span>

<h3>Description</h3>

<p>Probabilities are calculated between specified increments for a given distribution and parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistanceProbability(
  q,
  distribution,
  param1,
  param2 = NA,
  tbound = c(-Inf, Inf),
  unitSize = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDistanceProbability_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="getDistanceProbability_+3A_distribution">distribution</code></td>
<td>
<p>Character value; specifying the desired probability distribution, see <code><a href="#topic+ptrunc">ptrunc</a></code>.</p>
</td></tr>
<tr><td><code id="getDistanceProbability_+3A_param1">param1</code></td>
<td>
<p>Numeric; value of the first parameter of the specified distribution.</p>
</td></tr>
<tr><td><code id="getDistanceProbability_+3A_param2">param2</code></td>
<td>
<p>Numeric; default is <code>NA</code>. Value of the second parameter of the specified distribution, if applicable.</p>
</td></tr>
<tr><td><code id="getDistanceProbability_+3A_tbound">tbound</code></td>
<td>
<p>Numeric vector specifying the lower and upper truncation bounds. Default is <code>c(-Inf, Inf)</code>.</p>
</td></tr>
<tr><td><code id="getDistanceProbability_+3A_unitsize">unitSize</code></td>
<td>
<p>Numeric; either of length one or equal to <code>length(q)</code>, specific the desired width for the probability calculation. Default is 1.</p>
</td></tr>
<tr><td><code id="getDistanceProbability_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function that uses the <code><a href="#topic+ptrunc">ptrunc</a></code> function. The basic calculation is <code>ptrunc(q,...) - ptrunc(q-abs(unitSize),...)</code>
</p>


<h3>Value</h3>

<p>Vector of probabilities
</p>


<h3>See Also</h3>

<p>ptrunc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normal distribution
getDistanceProbability(q=8,distribution='norm',param1=10,param2=1)
pnorm(8,mean=10,sd=1)-pnorm(8-1,mean=10,sd=1)

## larger unitSize
getDistanceProbability(q=12,distribution='norm',param1=10,param2=1,unitSize=4)
pnorm(12,mean=10,sd=1)-pnorm(12-4,mean=10,sd=1)

</code></pre>

<hr>
<h2 id='getDistributionFunction'>Getting distribution functions</h2><span id='topic+getDistributionFunction'></span>

<h3>Description</h3>

<p>Determines if the distribution functions are available. This is intended for internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistributionFunction(type, dist, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDistributionFunction_+3A_type">type</code></td>
<td>
<p>Character, typically either 'r', 'q', 'p', or  'd'.</p>
</td></tr>
<tr><td><code id="getDistributionFunction_+3A_dist">dist</code></td>
<td>
<p>Character, typically something like 'norm', 'gamma', etc.</p>
</td></tr>
<tr><td><code id="getDistributionFunction_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is determined that <code>paste0(type, dist)</code> is a function and returns that function.  The nature of the returned function is not verified.
</p>


<h3>Value</h3>

<p>Function, the first function in the search path that matches the name <code>paste0(type, dist)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fun &lt;- getDistributionFunction(type="q",dist="norm")

</code></pre>

<hr>
<h2 id='getDistributionSummary'>Summary statistics from the fitted distribution</h2><span id='topic+getDistributionSummary'></span>

<h3>Description</h3>

<p>Summary statistics are calculated for the distribution with parameter estimates. Right now only the median is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistributionSummary(distribution, paramVec, truncBounds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDistributionSummary_+3A_distribution">distribution</code></td>
<td>
<p>String indicating which distribution to use.</p>
</td></tr>
<tr><td><code id="getDistributionSummary_+3A_paramvec">paramVec</code></td>
<td>
<p>Numeric vector for the parameters associated with distribution. Assumed to be in the same order as the function indicated by <code>distribution</code>.</p>
</td></tr>
<tr><td><code id="getDistributionSummary_+3A_truncbounds">truncBounds</code></td>
<td>
<p>Numeric, indicating bounds for the area correction calculation, see details. Default is NULL, and the bounds are set to <code>c(0,Inf)</code>.</p>
</td></tr>
<tr><td><code id="getDistributionSummary_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>truncBounds</code> argument defaults to zero as a lower bound and infinity
as the upper bound. If a single value is provided, it is assumed as the upper
bound with zero as the lower bound. If two or more values are provided, the
<code>max(truncBounds)</code> is the upper bound and <code>min(truncBounds)</code> is the
lower bound.
</p>


<h3>Value</h3>

<p>Data frame with the summary statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
getDistributionSummary('norm',c(40,25),truncBounds=c(-Inf,Inf))

getDistributionSummary('norm',c(40,25),truncBounds=NULL)

getDistributionSummary('norm',c(40,25),truncBounds=c(0,30))

</code></pre>

<hr>
<h2 id='getProportionAreaSearched'>Create proportion of area searched table from spatial data</h2><span id='topic+getProportionAreaSearched'></span>

<h3>Description</h3>

<p>Calculate proportion of area searched around wind turbine based on turbine location data and polygons of search area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProportionAreaSearched(
  turbinePoints,
  turbineName,
  turbinePlots,
  turbineMastRadius,
  maxDistance
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getProportionAreaSearched_+3A_turbinepoints">turbinePoints</code></td>
<td>
<p>Spatial points object with with data frame indicating turbine names</p>
</td></tr>
<tr><td><code id="getProportionAreaSearched_+3A_turbinename">turbineName</code></td>
<td>
<p>Character, indicating the variable name for the turbine names in <code>turbinePoints</code> and plot names in <code>turbinePlots</code></p>
</td></tr>
<tr><td><code id="getProportionAreaSearched_+3A_turbineplots">turbinePlots</code></td>
<td>
<p>Spatial polygon objects indicating the search area around the turbine points</p>
</td></tr>
<tr><td><code id="getProportionAreaSearched_+3A_turbinemastradius">turbineMastRadius</code></td>
<td>
<p>Integer of length 1. radius of the turbine mast</p>
</td></tr>
<tr><td><code id="getProportionAreaSearched_+3A_maxdistance">maxDistance</code></td>
<td>
<p>Integer, indicating how far from the turbine that searches occurred</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="sf.html#topic+sf">sf</a></code> package is used to calculate overlapping areas between the searched area <code>turbinePlots</code> and one unit annulus around the <code>turbinePoints</code>. The annuli increase out to a distance of <code>maxDistance</code>.
</p>
<p>Caution, the function does some basic checks on the spatial objects but it is assumed that the points and polygons do not have any boundary, geometry, or other issues.
</p>


<h3>Value</h3>

<p>Data frame of proportion of area searched for each annulus around each turbine point. <code>distanceFromTurbine</code> column represents outer radius of each annulus.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(turbineSpatial)

propSearch &lt;- getProportionAreaSearched(turbinePoints=turbineSpatial$turbinePoints,
turbineName='turbName',turbinePlots=turbineSpatial$turbinePlots,
 turbineMastRadius=2,maxDistance=10)


</code></pre>

<hr>
<h2 id='getStartValue'>Calculate the start values to be passed to the optimizer.</h2><span id='topic+getStartValue'></span>

<h3>Description</h3>

<p>Calculate start values for <code><a href="#topic+weightedLikelihood">weightedLikelihood</a></code> or <code><a href="#topic+weightedDistribution">weightedDistribution</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStartValue(x, distribution, w = rep(1, length(x)), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getStartValue_+3A_x">x</code></td>
<td>
<p>Numeric vector of the data observations.</p>
</td></tr>
<tr><td><code id="getStartValue_+3A_distribution">distribution</code></td>
<td>
<p>String indicating which distribution to use.</p>
</td></tr>
<tr><td><code id="getStartValue_+3A_w">w</code></td>
<td>
<p>Numeric Vector of weights. This is assumed to be in the same order as <code>x</code>. Default is a vector of ones the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="getStartValue_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended for internal purposes only and is called by <a href="#topic+weightedLikelihood">weightedLikelihood</a> and <a href="#topic+weightedDistribution">weightedDistribution</a>.
The function calculates the weighted mean and weighted variance and performs a method of moments approach to obtain start values for the likelihood estimation.
</p>


<h3>Value</h3>

<p>Vector of estimated parameters for the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100,10,5)

getStartValue(x,'norm')
mean(x)
sd(x)


</code></pre>

<hr>
<h2 id='hallingstad'>Data sets from Hallingstad et al. 2018</h2><span id='topic+hallingstad'></span>

<h3>Description</h3>

<p>List containing two data frames from Hallingstad et al. 2018
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hallingstad)
</code></pre>


<h3>Format</h3>

<p>The carcass element is a data frame with 26 rows and 3 variables:
</p>

<dl>
<dt>study</dt><dd><p>The name of the study for that wind farm.</p>
</dd>
<dt>species</dt><dd><p>The species of the carcass found.</p>
</dd>
<dt>distanceFromTurbine</dt><dd><p>The distance (meters) from the turbine of the location of the found carcass.</p>
</dd>
</dl>

<p>The weight element is a data frame with 2414 rows and 7 variables:
</p>

<dl>
<dt>study</dt><dd><p>The name of the study for that wind farm.</p>
</dd>
<dt>distanceFromTurbine</dt><dd><p>The distance (meters) from the turbine for the outer radius of a one meter ring or annulus.</p>
</dd>
<dt>detectionProbability</dt><dd><p>The probability of detection, incorporating search efficiency and carcass persistence, for a given study and distance from turbine.</p>
</dd>
<dt>proportionAreaSearch</dt><dd><p>The proportion of area searched within the ring (annulus).</p>
</dd>
<dt>scaledNumberTurbine</dt><dd><p>The number of turbines at a study divided by the total number of turbines for all studies considered, does not change with distance from turbine. </p>
</dd>
<dt>scaledFatalityRate</dt><dd><p>The fatality rate at a study divided by the sum of the fatality rates across all studies considered, does not change with distance from turbine.</p>
</dd>
<dt>finalWeight</dt><dd><p>The product of
<code>detectionProbability*proportionAreaSearched*scaledNumberTurbine*scaledFatalityRate</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>A list of data frames, with two elements named <code>carcass</code> and <code>weight</code>.
</p>


<h3>References</h3>

<p>Hallingstad EC, Rabie PA, Telander AC, Roppe JA, Nagy LR (2018) Developing an efficient protocol for monitoring eagle fatalities at wind energy facilities. PLoS ONE 13(12): e0208700. https://doi.org/10.1371/journal.pone.0208700
</p>

<hr>
<h2 id='hullMuirAreaCorrection'>Calculate an area correction based on the Hull and Muir (2010) maximum
distance and a triangular distribution as proposed by Huso and Dalthorp (2014).</h2><span id='topic+hullMuirAreaCorrection'></span>

<h3>Description</h3>

<p>Calculate the maximum fall distance from a turbine using the
regression model from Hull and Muir (2010). Calculate the carcass fall proabilities
between one-unit increments of a right triangle distribution as proposed by Huso and Dalthorp (2014). Use the
probabilities and proportion of area searched to calculate an area correction
value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hullMuirAreaCorrection(
  hubHeight,
  bladeRadius,
  lowerBound = 0,
  upperBound = Inf,
  proportionSearchDF,
  distanceCol,
  proportionCol,
  additionalCol = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hullMuirAreaCorrection_+3A_hubheight">hubHeight</code></td>
<td>
<p>Numeric, turbine hub height.</p>
</td></tr>
<tr><td><code id="hullMuirAreaCorrection_+3A_bladeradius">bladeRadius</code></td>
<td>
<p>Numeric, turbine blade radius.</p>
</td></tr>
<tr><td><code id="hullMuirAreaCorrection_+3A_lowerbound">lowerBound</code></td>
<td>
<p>Numeric, default is zero, see <code><a href="#topic+triangleProb">triangleProb</a></code>.</p>
</td></tr>
<tr><td><code id="hullMuirAreaCorrection_+3A_upperbound">upperBound</code></td>
<td>
<p>Numeric, default is <code>Inf</code>, see <code><a href="#topic+triangleProb">triangleProb</a></code>.</p>
</td></tr>
<tr><td><code id="hullMuirAreaCorrection_+3A_proportionsearchdf">proportionSearchDF</code></td>
<td>
<p>Data frame with at least two columns: distance from
turbine and proportion of area searched at each distance.</p>
</td></tr>
<tr><td><code id="hullMuirAreaCorrection_+3A_distancecol">distanceCol</code></td>
<td>
<p>Character string indicating the distance column in
<code>proportionSearchDF</code>.</p>
</td></tr>
<tr><td><code id="hullMuirAreaCorrection_+3A_proportioncol">proportionCol</code></td>
<td>
<p>Character string indicating the proportion column in
<code>proportionSearchDF</code>.</p>
</td></tr>
<tr><td><code id="hullMuirAreaCorrection_+3A_additionalcol">additionalCol</code></td>
<td>
<p>Character vector, default is NULL, indicating additional
columns of how the area correction value should be calculated, see examples.</p>
</td></tr>
<tr><td><code id="hullMuirAreaCorrection_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum Hull and Muir distances are calculated using
<code><a href="#topic+hullMuirMaxDistance">hullMuirMaxDistance</a></code> and the carcass fall probabilities are calculated using
<code><a href="#topic+triangleProb">triangleProb</a></code>. The probabilites are multipled by the proportion
of area searched from <code>proportionSearchDF</code> by distance. These products are
summed across distances by size class and <code>additionalCol</code>.
</p>
<p>The distances in the <code>distanceCol</code> will be rounded to the nearest
integer for matching up with the probabilities. The distances, <code>hubHeight</code>, and <code>bladeRadius</code> are assumed to be in the same units.
</p>


<h3>Value</h3>

<p>Data frame of size class, <code>additionalCol</code> columns, and area
correction
</p>


<h3>References</h3>

<p>Hull, C. L., &amp; Muir, S. (2010).
Search areas for monitoring bird and bat carcasses at wind farms using a Monte-Carlo model.
Australasian Journal of Environmental Management, 17(2), 77-87.
</p>
<p>Huso, M. &amp; Dalthorp,D (2014).
Accounting for Unsearched Areas in Estimating Wind Turbine-Caused Fatality.
The Journal of Wildlife Management. 78. 10.1002/jwmg.663.
</p>


<h3>See Also</h3>

<p>hullMuirMaxDistance triangleProb
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## proportion of area searched data
data(proportionAreaSearched)

hullMuirAreaCorrection(hubHeight = 87.5, bladeRadius = 62.5,
                       proportionSearchDF = proportionAreaSearched,
                       distanceCol = 'distanceFromTurbine',
                       proportionCol = 'proportionAreaSearched',
                       additionalCol = 'plotType')

## without additional columns but must separate the proportion of area searched
## data frame
hullMuirAreaCorrection(hubHeight = 87.5, bladeRadius = 62.5,
                       proportionSearchDF = subset(proportionAreaSearched, plotType == 'RP'),
                       distanceCol = 'distanceFromTurbine',
                       proportionCol = 'proportionAreaSearched')

hullMuirAreaCorrection(hubHeight = 87.5, bladeRadius = 62.5,
                       proportionSearchDF = subset(proportionAreaSearched, plotType == 'FULL'),
                       distanceCol = 'distanceFromTurbine',
                       proportionCol = 'proportionAreaSearched')
</code></pre>

<hr>
<h2 id='hullMuirMaxDistance'>Calculate the Hull and Muir (2010) maximum distance</h2><span id='topic+hullMuirMaxDistance'></span>

<h3>Description</h3>

<p>Calculate the maximum fall distance from a turbine using the
regression model from Hull and Muir (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hullMuirMaxDistance(hubHeight, bladeRadius, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hullMuirMaxDistance_+3A_hubheight">hubHeight</code></td>
<td>
<p>Numeric, turbine hub height.</p>
</td></tr>
<tr><td><code id="hullMuirMaxDistance_+3A_bladeradius">bladeRadius</code></td>
<td>
<p>Numeric, turbine blade radius.</p>
</td></tr>
<tr><td><code id="hullMuirMaxDistance_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the linear regression coefficients from Hull and Muir (2010), a
maximum distance is calculated. This is done for three size classes (bats,
small birds (SB), and large birds (LB)) separately.
</p>
<p>It is assumed that <code>hubHeight</code> and <code>bladeRadius</code> have the same units.
</p>
<p>Note: Hull and Muir (2010) used the range of 65 m &lt; <code>hubHeight</code> &lt; 94 m  and  33 m &lt; <code>bladeRadius</code> &lt; 55 m.
Anything outside of this range is extrapolation and should only be done with care.
</p>


<h3>Value</h3>

<p>data frame of maximum distance by size class, <code>hubHeight</code>, and
<code>bladeRadius</code>. Distance will be in the same units as were provided for <code>hubHeight</code> and <code>bladeRadius</code>
</p>


<h3>References</h3>

<p>Hull, C. L., &amp; Muir, S. (2010).
Search areas for monitoring bird and bat carcasses at wind farms using a Monte-Carlo model.
Australasian Journal of Environmental Management, 17(2), 77-87.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hubHeights &lt;- rnorm(10, mean = 87.5, sd = 10)
bladeRadii &lt;- rnorm(10, mean = 62.5, sd = 10)

hullMuirMaxDistance(hubHeight = hubHeights, bladeRadius = bladeRadii)
</code></pre>

<hr>
<h2 id='LogLogistic'>Log-Logistic Distribution</h2><span id='topic+LogLogistic'></span><span id='topic+dllog'></span><span id='topic+pllog'></span><span id='topic+rllog'></span><span id='topic+llogSummaryStats'></span><span id='topic+qllog'></span>

<h3>Description</h3>

<p>The probability density function, cumulative density function, inverse cumulative density function, random generation for the log logistic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dllog(x, shape = 1, scale = 1, log = FALSE, ...)

llogSummaryStats(shape, scale)

pllog(q, shape = 1, scale = 1, lower.tail = TRUE, log.p = FALSE, ...)

qllog(p, shape = 1, scale = 1, lower.tail = TRUE, log.p = FALSE, ...)

rllog(n, shape = 1, scale = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LogLogistic_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="LogLogistic_+3A_shape">shape</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="LogLogistic_+3A_scale">scale</code></td>
<td>
<p>Scale parameter.</p>
</td></tr>
<tr><td><code id="LogLogistic_+3A_log">log</code></td>
<td>
<p>Logical; if TRUE, log densities are returned.</p>
</td></tr>
<tr><td><code id="LogLogistic_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="LogLogistic_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="LogLogistic_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are P(X &lt;= x) otherwise, P(X &gt; x).</p>
</td></tr>
<tr><td><code id="LogLogistic_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="LogLogistic_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="LogLogistic_+3A_n">n</code></td>
<td>
<p>Number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If X is a random variable distributed according to a logistic distribution, then Y = exp(X) has a log-logistic distribution.
</p>
<p>The log-logistic distribution with parameters <code>shape = a</code> and <code>scale = s</code> has density
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{(\frac{1}{a*exp(s))})(\frac{x}{\exp{s}})^{\frac{1}{a} - 1}}{(1+(\frac{x}{\exp{s}})^{1/a})^2}</code>
</p>

<p>for <code>x &gt;= 0</code>, <code>a &gt; 1</code>, and <code>s &gt; 0</code>.
</p>
<p>The median is <code>exp(s)</code>, mean is
</p>
<p style="text-align: center;"><code class="reqn">\frac{a\pi*exp(s)}{sin(a*\pi)}</code>
</p>

<p>for <code>1/a &gt; 1</code>. The variance is
</p>
<p style="text-align: center;"><code class="reqn">(exp(s))^2(\frac{2*\pi*a}{(sin(2*pi*a))}- \frac{(a*\pi)^2}{(sin^2(a*\pi))})</code>
</p>

<p>for <code>1/a &gt; 2</code>. The mode is
</p>
<p style="text-align: center;"><code class="reqn">exp(s)(\frac{(1/a) - 1}{(1/a) + 1})^{a}</code>
</p>

<p>for <code>1/a &gt; 1</code> otherwise it is zero.
</p>


<h3>Value</h3>

<p><code>dllog</code> returns vector of the densities.
</p>
<p><code>pllog</code> returns a vector of probabilities.
</p>
<p><code>qllog</code> returns a vector of quantiles.
</p>
<p><code>rllog</code> returns a vector of random log-logistic variates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dlogis">dlogis</a></code> <code><a href="stats.html#topic+plogis">plogis</a></code> <code><a href="stats.html#topic+qlogis">qlogis</a></code> <code><a href="stats.html#topic+rlogis">rlogis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rllog(5,shape=1,scale=1/3)
dllog(x=y,shape=1,scale=1/3)
dlogis(x=log(y),location=1/3,scale=1)/y

pllog(q=y,shape=1,scale=1/3)
qllog(p=seq(0,1,by=.25),shape=1,scale=1/3)


</code></pre>

<hr>
<h2 id='print.windAC'>Print <code>windAC</code> object</h2><span id='topic+print.windAC'></span>

<h3>Description</h3>

<p>Print <code>windAC</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'windAC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.windAC_+3A_x">x</code></td>
<td>
<p>A <code>windAC</code> object.</p>
</td></tr>
<tr><td><code id="print.windAC_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+calcAC">calcAC</a></code>
</p>


<h3>Value</h3>

<p>Print for windAC object
</p>

<hr>
<h2 id='proportionAreaSearched'>Proportion of area searched example data set</h2><span id='topic+proportionAreaSearched'></span>

<h3>Description</h3>

<p>An example data set of the proportion of area searched within 1 m annuli around turbines at a wind farm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(proportionAreaSearched)
</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows and 3 variables:
</p>

<dl>
<dt>plotType</dt><dd><p>Either FULL or RP, the type of plot searched at the turbine</p>
</dd>
<dt>distanceFromTurbine</dt><dd><p>The outer radius distance from the turbine, for the one unit annulus.</p>
</dd>
<dt>proportionAreaSearched</dt><dd><p>The proportion of area searched within the annulus at the turbine.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Plots around turbines are searched for bird and bat carcasses. The area searched is summarized into the proportion of area searched with one unit annuli (or rings).
The distance here corresponds to the outer radius of the annuli.
</p>
<p>For example:
<code>plotType</code>    <code>distanceFromTurbine</code>    <code>portionAreaSearched</code>
RP                           11                    0.12441226
</p>
<p>This row is corresponds to the annulus with outer radius of 11 and inner radius of 10.
The proportion of area search on RP (road and pad) plot types is 0.12441226, or approximately 12 percent.
</p>

<hr>
<h2 id='secondDerivative'>secondDerivative</h2><span id='topic+secondDerivative'></span>

<h3>Description</h3>

<p>Computes numeric second derivatives (hessian) of an
arbitrary multidimensional function at a particular location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secondDerivative(loc, FUN, ..., eps = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secondDerivative_+3A_loc">loc</code></td>
<td>
<p>The location (a vector) where the second derivatives
of <code>FUN</code> are desired.</p>
</td></tr>
<tr><td><code id="secondDerivative_+3A_fun">FUN</code></td>
<td>
<p>An R function to compute second derivatives for.
This must be a function of the form FUN &lt;- function(x, ...)...
where x is the parameters of the function (e.g., location <code>loc</code>).
<code>FUN</code> must return a single value (scalar), the height of the
surface above <code>x</code>, i.e., <code>FUN</code> evaluated at <code>x</code>.</p>
</td></tr>
<tr><td><code id="secondDerivative_+3A_...">...</code></td>
<td>
<p>Additional agruments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="secondDerivative_+3A_eps">eps</code></td>
<td>
<p>Radius argument, see details. Default is <code>10e-7</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the &quot;5-point&quot; numeric second derivative
method advocated in numerous numerical recipe texts.  During computation
of the second derivative, FUN will be evaluated at locations within a hyper-elipsoid
with cardinal radius <code>2*loc*(eps)^0.25</code>.
</p>
<p>A handy way to use this function is to call an optimization routine
like <code>nlminb</code> with FUN, then call this function with the
optimized values (solution) and FUN.  This will yeild the hessian
at the solution rather than the hessian at the previous step of the
optimization.
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
func &lt;- function(x){-x*x} # second derivative should be -2
secondDerivative(0,func)
secondDerivative(3,func)

func &lt;- function(x){3 + 5*x^2 + 2*x^3} # second derivative should be 10+12x
secondDerivative(0,func)
secondDerivative(2,func)

func &lt;- function(x){x[1]^2 + 5*x[2]^2} # should be rbind(c(2,0),c(0,10))
secondDerivative(c(1,1),func)
secondDerivative(c(4,9),func)
</code></pre>

<hr>
<h2 id='triangleProb'>Calculate probabilities from a triangle distribution based on Hull and
Muir (2010) maximum distance as proposed by Huso and Dalthorp (2014).</h2><span id='topic+triangleProb'></span>

<h3>Description</h3>

<p>Calculate the probabilities between one-unit increments of a right
triangle distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangleProb(hubHeight, bladeRadius, lowerBound = 0, upperBound = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triangleProb_+3A_hubheight">hubHeight</code></td>
<td>
<p>Numeric, turbine hub height.</p>
</td></tr>
<tr><td><code id="triangleProb_+3A_bladeradius">bladeRadius</code></td>
<td>
<p>Numeric, turbine blade radius.</p>
</td></tr>
<tr><td><code id="triangleProb_+3A_lowerbound">lowerBound</code></td>
<td>
<p>Numeric, default is zero, see Details.</p>
</td></tr>
<tr><td><code id="triangleProb_+3A_upperbound">upperBound</code></td>
<td>
<p>Numeric, default is <code>Inf</code>, see Details.</p>
</td></tr>
<tr><td><code id="triangleProb_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A right triangle is constructed with the 90 degree corner at the
origin in the first quadrant of the cartesian plane. The <code>lowerBound</code>
will move the left edge of the triangle to the right. The <code>upperBound</code> will truncate the
triangle distribution at that value.
</p>
<p>The maximum horizontal distance is calculated using
<code><a href="#topic+hullMuirMaxDistance">hullMuirMaxDistance</a></code>. This is typically not a
whole number and the <code><a href="base.html#topic+ceiling">ceiling</a></code> is used. The maximum
vertical distance is such that the area under the hypotenuse edge of triangle
integrates to one. This is done using the equation for the area of a triangle.
</p>
<p>The two points that make up the hypotenuse are used to calculate the slope
and intercept of the line. The area under the line in one-unit increments is
calculated using
</p>
<p style="text-align: center;"><code class="reqn">\int_{x-1}^{x}mZ+b dZ = m(x-.5)+b</code>
</p>

<p>where <code>m</code> is
the slope, <code>b</code> is the intercept, and <code>x</code> is a distance. Integrating
between <code>x-1</code> and <code>x</code> gives the probability between the one-unit
increments.
</p>
<p>All of this is done for three size classes (bats, small birds (SB), and large
birds (LB)) separately. An additional size class (RAPTOR) is included and
identical to the large bird result.
</p>
<p>The <code><a href="base.html#topic+floor">floor</a></code> function is applied to <code>lowerBound</code>.
</p>
<p>It is assumed that <code>hubHeight</code> and <code>bladeRadius</code> have the same units.
</p>


<h3>Value</h3>

<p>List of two data frames: the first has distances in one-unit increments
(the outer distance), the probabilities between the distances, and a column
indicating size class; the second gives the maximum distance of each size class.
</p>


<h3>References</h3>

<p>Hull, C. L., &amp; Muir, S. (2010).
Search areas for monitoring bird and bat carcasses at wind farms using a Monte-Carlo model.
Australasian Journal of Environmental Management, 17(2), 77-87.
</p>
<p>Huso, M. &amp; Dalthorp,D (2014).
Accounting for Unsearched Areas in Estimating Wind Turbine-Caused Fatality.
The Journal of Wildlife Management. 78. 10.1002/jwmg.663.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hullMuirMaxDistance">hullMuirMaxDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
triResult &lt;- triangleProb(hubHeight = 100, bladeRadius = 50, lowerBound = 0)
names(triResult) ## list names
triResult$maxDist ## max distance for each size class
head(triResult$triDistProb)
</code></pre>

<hr>
<h2 id='truncatedDistribution'>Truncated Distributions</h2><span id='topic+truncatedDistribution'></span><span id='topic+dtrunc'></span><span id='topic+ptrunc'></span><span id='topic+qtrunc'></span><span id='topic+rtrunc'></span>

<h3>Description</h3>

<p>Truncated probability density function, truncated cumulative density function, inverse truncated cumulative density function, and random variates from a truncated distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtrunc(x, distribution, tbound = c(-Inf, Inf), ..., log = FALSE)

ptrunc(
  q,
  distribution,
  tbound = c(-Inf, Inf),
  ...,
  lower.tail = TRUE,
  log.p = NULL
)

qtrunc(
  p,
  distribution,
  tbound = c(-Inf, Inf),
  ...,
  lower.tail = TRUE,
  log.p = NULL
)

rtrunc(n, distribution, tbound = c(-Inf, Inf), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truncatedDistribution_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="truncatedDistribution_+3A_distribution">distribution</code></td>
<td>
<p>Character value specifying the desired probability distribution.</p>
</td></tr>
<tr><td><code id="truncatedDistribution_+3A_tbound">tbound</code></td>
<td>
<p>Numeric vector specifying the lower and upper truncation bounds. Default is <code>c(-Inf, Inf)</code>.</p>
</td></tr>
<tr><td><code id="truncatedDistribution_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the non-truncated distribution functions.</p>
</td></tr>
<tr><td><code id="truncatedDistribution_+3A_log">log</code></td>
<td>
<p>Logical; if TRUE, log densities are returned.</p>
</td></tr>
<tr><td><code id="truncatedDistribution_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="truncatedDistribution_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are P(X &lt;= x) otherwise, P(X &gt; x).</p>
</td></tr>
<tr><td><code id="truncatedDistribution_+3A_log.p">log.p</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="truncatedDistribution_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="truncatedDistribution_+3A_n">n</code></td>
<td>
<p>A positive integer specifying the desired number of random variates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The non truncated distribution functions are assumed to be available. For example if the normal distribution is desired then used <code>distribution='norm'</code>, the functions then look for 'qnorm', 'pnorm', etc.
</p>
<p>The <code>max(tbound)</code> and <code>min(tbound)</code> are considered the upper and lower truncation bounds, respectively.
</p>
<p>The random variates are produced using the direct method (see Casella and Berger 2002).
</p>


<h3>Value</h3>

<p><code>dtrunc</code> returns a vector of densities.
</p>
<p><code>ptrunc</code> returns a vector of probabilities.
</p>
<p><code>qtrunc</code> returns a vector of quantiles.
</p>
<p><code>rtrunc</code> returns a vector of random variates.
</p>


<h3>References</h3>

<p>G. Casella and R. L. Berger. Statistical inference. Vol. 2. Duxbury Pacific Grove, CA, 2002.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## dtrunc
# not truncted
dnorm(5,mean=5)
# truncated
dtrunc(x=5,distribution='norm',tbound=c(4,5.5),mean=5)



## ptrunc
#not truncated
pgamma(2,shape=3,rate=2)
# truncated
ptrunc(2, distribution = 'gamma', tbound=c(1,5),shape=3,rate=2)

## upper tail
# not truncated
pgamma(2,shape=3,rate=2,lower.tail=FALSE)
# truncated
ptrunc(2,distribution='gamma',tbound=c(1,5),shape=3,rate=2,lower.tail=FALSE)

## qtrunc
#not truncated
qnorm(p=.975)
# truncted
qtrunc(p=.975,distribution='norm',tbound=c(0,1))

## upper tail
# not truncted
qnorm(p=.975,lower.tail=FALSE)
# truncated
qtrunc(p=.975,distribution='norm',tbound=c(0,1),lower.tail=FALSE)

## rtrunc
rtrunc(n=5, distribution = 'gamma', tbound=c(2,5),shape=3,rate=2)
</code></pre>

<hr>
<h2 id='turbineSpatial'>Data sets of spatial area searched at a wind farm</h2><span id='topic+turbineSpatial'></span>

<h3>Description</h3>

<p>List containing two spatial data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(turbineSpatial)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Details</h3>

<p>A list of data frames, with two elements named <code>turbinePlots</code> and <code>turbinePoints</code>. These are fictious data for example purposes only. The <code>turbinePlots</code> element is a spatial polygon data frame with the polygons being the area searched round the turbines. The <code>turbinePoints</code> element is a spatial points data frame with the turbine locations.
</p>

<hr>
<h2 id='weightFun'>weight function</h2><span id='topic+weightFun'></span>

<h3>Description</h3>

<p>Generic weight function for use with <code><a href="#topic+estWD">estWD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightFun(
  x,
  propTable,
  type,
  typeCol,
  distanceCol,
  propCol,
  xFun = ceiling,
  maxDistance = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightFun_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="weightFun_+3A_proptable">propTable</code></td>
<td>
<p>Data frame contain the proportion of area searched by distance and plot type.</p>
</td></tr>
<tr><td><code id="weightFun_+3A_type">type</code></td>
<td>
<p>Character, indicating which plot type to subset <code>propTable</code>.</p>
</td></tr>
<tr><td><code id="weightFun_+3A_typecol">typeCol</code></td>
<td>
<p>Character, column name of the plot type in <code>propTable</code>.</p>
</td></tr>
<tr><td><code id="weightFun_+3A_distancecol">distanceCol</code></td>
<td>
<p>Character, column name of the distance in <code>propTable</code>.</p>
</td></tr>
<tr><td><code id="weightFun_+3A_propcol">propCol</code></td>
<td>
<p>Character, column name of the proportion of area searched in <code>propTable</code>.</p>
</td></tr>
<tr><td><code id="weightFun_+3A_xfun">xFun</code></td>
<td>
<p>Function, default is <code><a href="base.html#topic+ceiling">ceiling</a></code>, see details.</p>
</td></tr>
<tr><td><code id="weightFun_+3A_maxdistance">maxDistance</code></td>
<td>
<p>Numeric, default is <code>NULL</code>. If a value is given then <code>propTable</code> is subsetted to where <code>propTable[,distanceCol] &lt;= maxDistance</code>.</p>
</td></tr>
<tr><td><code id="weightFun_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>xFun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+weightedDistribution">weightedDistribution</a></code> function requires the weights be described using a function.
This allows integration to happen.
</p>
<p>Typically <code>propTable</code> has integer values for the distances, but the function needs to take in any numeric values, the <code>xFun</code> function is how any numeric value can be matched up to the values in <code>propTable</code>.
If the distances in <code>propTable</code> correspond to the outer radius of the annuli, for calculating proportion of area searched, then the <code><a href="base.html#topic+ceiling">ceiling</a></code> is appropriate.
If the distances in <code>propTable</code> correspond to the inner radius of the annuli then the <code><a href="base.html#topic+floor">floor</a></code> might be more appropriate.
</p>


<h3>Value</h3>

<p>Numeric vector of weights with length equal to <code>length(x)</code>, and with a 1:1 relationship to the values in <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estWD">estWD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(proportionAreaSearched)

d &lt;- c(-300.23,14.3,16,75)

## RP proportion of area searched
weightFun(x=d,propTable=proportionAreaSearched,type='RP',typeCol='plotType',
distanceCol='distanceFromTurbine',propCol='proportionAreaSearched')
#[1] 0.00000000 0.08896480 0.08308577 0.01709869

## FULL plot proportion of area searched
weightFun(x=d,propTable=proportionAreaSearched,type='FULL',typeCol='plotType',
distanceCol='distanceFromTurbine',propCol='proportionAreaSearched')
# [1] 0 1 1 1

### with a max distance restriction
## RP proportion of area searched
weightFun(x=d,propTable=proportionAreaSearched,type='RP',typeCol='plotType',
distanceCol='distanceFromTurbine',propCol='proportionAreaSearched',maxDistance=40)
# [1] 0.00000000 0.08896480 0.08308577 0.00000000

## FULL plot proportion of area searched
weightFun(x=d,propTable=proportionAreaSearched,type='FULL',typeCol='plotType',
distanceCol='distanceFromTurbine',propCol='proportionAreaSearched',maxDistance=40)
# [1] 0 1 1 0


</code></pre>

<hr>
<h2 id='windAC'>A package for calculating area correction values for fatality estimation at wind farms.</h2><span id='topic+windAC'></span>

<h3>Description</h3>

<p>Post-construction fatality monitoring studies at wind facilities are based on data from searches for bird and bat carcasses in plots beneath turbines. Bird and bat carcasses can fall outside of the search plot. Bird and bat carcasses from wind turbines often fall outside of the searched area. To compensate, area correction (AC) estimations are calculated to estimate the percentage of fatalities that fall within the searched area versus those that fall outside of it. This package provides two likelihood based methods and one physics based method (Hull and Muir (2010), Huso and Dalthorp (2014)) to estimate the carcass fall distribution. There are also functions for calculating the proportion of area searched within one unit annuli, log logistic distribution functions, and truncated distribution functions.
</p>
<p>The two likelihood methods are the truncated weighted likelihood (<code><a href="#topic+estTWL">estTWL</a></code>) and the weighted distribution (<code><a href="#topic+estWD">estWD</a></code>). Both use carcass distances from the turbine, accounting for unequal detection by distance, to estimate the distance distribution. Alternatively, a right triangle distribution can be used for the carcass density distribution with the max distance estimated (<code><a href="#topic+hullMuirMaxDistance">hullMuirMaxDistance</a></code> from the regression from Hull and Muir (2010) as proposed by Huso and Dalthorp (2014).
</p>
<p>The area correction value is calculated from the combination of the carcass distance density and the proportion of area searched at each distance. The function <code><a href="#topic+getProportionAreaSearched">getProportionAreaSearched</a></code> uses the <code><a href="sf.html#topic+sf">sf</a></code> package to do this from turbine points spatial data and search area polygons. The functions <code><a href="#topic+geometricRectanglePropSearchTable">geometricRectanglePropSearchTable</a></code> and <code><a href="#topic+geometricRoadPadPropSearchTable">geometricRoadPadPropSearchTable</a></code> also calculate proportion of area searched but assuming perfect geometric shapes, meaning no spatial data is required.
</p>
<p>Search areas are often irregular. <code><a href="#topic+proportionAreaSearched">proportionAreaSearched</a></code> summarizes the area searched into the proportion of area searched with one unit annuli (or ring).
</p>
<p>Two sets of distribution functions are available. Log logistic distribution functions (see <code><a href="#topic+dllog">dllog</a></code>). These are a transformation of the logistic distribution and use the base R functions (see <code><a href="stats.html#topic+dlogis">dlogis</a></code>).
The second is truncation functions (see <code><a href="#topic+dtrunc">dtrunc</a></code>), that provide truncation for R function distributions.
</p>
<p>Example data sets:
</p>

<ul>
<li><p><code><a href="#topic+carcassDistance">carcassDistance</a></code>: Example data set of carcass distances found during searches under wind turbines.
</p>
</li>
<li><p><code><a href="#topic+hallingstad">hallingstad</a></code>: List containing two data frames from Hallingstad et al. 2018. Data frames list carcass and detection probability data for a few wind farm studies.
</p>
</li>
<li><p><code><a href="#topic+proportionAreaSearched">proportionAreaSearched</a></code>: An example data set of the proportion of area searched around turbines at a wind farm.
</p>
</li></ul>



<h3>References</h3>

<p>Hallingstad EC, Rabie PA, Telander AC, Roppe JA, Nagy LR (2018) Developing an efficient protocol for monitoring eagle fatalities at wind energy facilities. PLoS ONE 13(12): e0208700. https://doi.org/10.1371/journal.pone.0208700
</p>
<p>Huso, M. &amp; Dalthorp,D (2014).
Accounting for Unsearched Areas in Estimating Wind Turbine-Caused Fatality.
The Journal of Wildlife Management. 78. 10.1002/jwmg.663.
</p>
<p>Hull, C. L., &amp; Muir, S. (2010). Search areas for monitoring bird and bat carcasses at wind farms using a Monte-Carlo model.Australasian Journal of Environmental Management, 17(2), 77-87.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
