<!DOCTYPE html><html lang="en"><head><title>Help for package ltmle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ltmle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ltmle-package'><p>Targeted Maximum Likelihood Estimation for Longitudinal Data</p></a></li>
<li><a href='#BinaryToCensoring'><p>BinaryToCensoring</p></a></li>
<li><a href='#deterministic.g.function_template'><p>Deterministic g/Q functions - examples and templates</p></a></li>
<li><a href='#ltmle'><p>Longitudinal Targeted Maximum Likelihood Estimation</p></a></li>
<li><a href='#sampleDataForLtmleMSM'><p>Sample data, regimes, and summary measures</p></a></li>
<li><a href='#summary.ltmle'><p>Get standard error, p-value, and confidence interval for one ltmle object</p>
Summarizing results from Longitudinal Targeted Maximum Likelihood Estimation
(ltmle)</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Longitudinal Targeted Maximum Likelihood Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-4-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua Schwab &lt;jschwab77@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SuperLearner, testthat, tmle, knitr, rmarkdown, nnls, arm</td>
</tr>
<tr>
<td>Description:</td>
<td>Targeted Maximum Likelihood Estimation ('TMLE') of
    treatment/censoring specific mean outcome or marginal structural model for
    point-treatment and longitudinal data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'ltmle-package.R' 'GeneralUtilities.R' 'ltmle.R' 'ltmle_sg.R'
'BinaryToCensoring.R' 'DeterministicFunctions.R' 'zzz.R'</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/joshuaschwab/ltmle">https://github.com/joshuaschwab/ltmle</a>,
<a href="http://joshuaschwab.github.io/ltmle/">http://joshuaschwab.github.io/ltmle/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/joshuaschwab/ltmle/issues">https://github.com/joshuaschwab/ltmle/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-13 21:15:50 UTC; joshua</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua Schwab [aut, cre],
  Samuel Lendle [aut],
  Maya Petersen [aut],
  Mark van der Laan [aut],
  Susan Gruber [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-15 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ltmle-package'>Targeted Maximum Likelihood Estimation for Longitudinal Data</h2><span id='topic+ltmle-package'></span>

<h3>Description</h3>

<p>Targeted Maximum Likelihood Estimation (TMLE) of treatment/censoring
specific mean outcome or marginal structural model for point-treatment and
longitudinal data. Also provides Inverse Probability of Treatment/Censoring
Weighted estimate (IPTW) and maximum likelihood based G-computation estimate
(G-comp). Can be used to calculate additive treatment effect, risk ratio,
and odds ratio.
</p>


<h3>Author(s)</h3>

<p>Joshua Schwab, Samuel Lendle, Maya Petersen, and Mark van der Laan,
with contributions from Susan Gruber
</p>
<p>Maintainer: Joshua Schwab <a href="mailto:jschwab77@berkeley.edu">jschwab77@berkeley.edu</a>
</p>


<h3>References</h3>

<p>Bang, Heejung, and James M. Robins. &quot;Doubly robust estimation in missing data
and causal inference models.&quot; Biometrics 61.4 (2005): 962-973.
</p>
<p>Lendle SD, Schwab J, Petersen ML and van der Laan MJ (2017). &quot;ltmle: An R
Package Implementing Targeted Minimum Loss-Based Estimation for Longitudinal
Data.&quot; _Journal of Statistical Software_, *81*(1), pp. # ' 1-21.
doi: 10.18637/jss.v081.i01  <a href="https://doi.org/10.18637/jss.v081.i01">doi:10.18637/jss.v081.i01</a>
</p>
<p>Petersen, Maya, Schwab, Joshua and van der Laan, Mark J, &quot;Targeted Maximum
Likelihood Estimation of Marginal Structural Working Models for Dynamic
Treatments Time-Dependent Outcomes&quot;, Journal of Causal Inference, 2014
<a href="https://pubmed.ncbi.nlm.nih.gov/25909047/">https://pubmed.ncbi.nlm.nih.gov/25909047/</a>
</p>
<p>Robins JM, Sued M, Lei-Gomez Q, Rotnitsky A. (2007). Comment: Performance of
double-robust estimators when Inverse Probability weights are highly
variable. Statistical Science 22(4):544-559.
</p>
<p>van der Laan, Mark J. and Gruber, Susan, &quot;Targeted Minimum Loss Based
Estimation of an Intervention Specific Mean Outcome&quot; (August 2011). U.C.
Berkeley Division of Biostatistics Working Paper Series. Working Paper 290.
<a href="https://biostats.bepress.com/ucbbiostat/paper290/">https://biostats.bepress.com/ucbbiostat/paper290/</a>
</p>
<p>van der Laan, Mark J. and Rose, Sherri, &quot;Targeted Learning: Causal Inference
for Observational and Experimental Data&quot; New York: Springer, 2011.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltmle">ltmle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## For examples see examples(ltmle) and \url{http://joshuaschwab.github.io/ltmle/}

</code></pre>

<hr>
<h2 id='BinaryToCensoring'>BinaryToCensoring</h2><span id='topic+BinaryToCensoring'></span>

<h3>Description</h3>

<p>Helper function for creating censoring columns as factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinaryToCensoring(is.censored, is.uncensored)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BinaryToCensoring_+3A_is.censored">is.censored</code></td>
<td>
<p>binary vector: 0=uncensored, 1=censored</p>
</td></tr>
<tr><td><code id="BinaryToCensoring_+3A_is.uncensored">is.uncensored</code></td>
<td>
<p>binary vector: 0=censored, 1=uncensored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of <code>is.censored</code> and <code>is.uncensored</code> must be specified
as a <em>named</em> argument.  All elements of the input vector must be 0, 1,
or <code>NA</code>
</p>


<h3>Value</h3>

<p>an object of class &quot;<code>factor</code>&quot; with levels &quot;censored&quot; and
&quot;uncensored&quot;
</p>


<h3>Author(s)</h3>

<p>Joshua Schwab <a href="mailto:jschwab77@berkeley.edu">jschwab77@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factor">factor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 BinaryToCensoring(is.censored=c(0, 1, 1, 0, NA))
 BinaryToCensoring(is.uncensored=c(1, 0, 0, 1, NA))   #the same
 
 ## Not run: 
 BinaryToCensoring(c(0, 1))   #error because the input must be named
 
## End(Not run)

</code></pre>

<hr>
<h2 id='deterministic.g.function_template'>Deterministic g/Q functions - examples and templates</h2><span id='topic+deterministic.g.function_template'></span><span id='topic+MaintainTreatment'></span><span id='topic+MaintainControl'></span><span id='topic+deterministic.Q.function_template'></span>

<h3>Description</h3>

<p>Template for the <code>deterministic.g.function</code> 
argument to <code><a href="#topic+ltmle">ltmle</a></code> or <code><a href="#topic+ltmleMSM">ltmleMSM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deterministic.g.function_template(data, current.node, nodes)

deterministic.Q.function_template(
  data,
  current.node,
  nodes,
  called.from.estimate.g
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deterministic.g.function_template_+3A_data">data</code></td>
<td>
<p>the 'data' data.frame passed to <code>ltmle</code> or <code>ltmleMSM</code></p>
</td></tr>
<tr><td><code id="deterministic.g.function_template_+3A_current.node">current.node</code></td>
<td>
<p>the column index of data corresponding to the A or C
node (for g) or L or Y node (for Q)</p>
</td></tr>
<tr><td><code id="deterministic.g.function_template_+3A_nodes">nodes</code></td>
<td>
<p>list of column indicies, components: </p>
 <ul>
<li> <p><code>A</code>
Anodes (treatment) </p>
</li>
<li> <p><code>C</code> Cnodes (censoring) </p>
</li>
<li> <p><code>L</code> Lnodes
(time-varying covariates) </p>
</li>
<li> <p><code>Y</code> Ynodes (events) </p>
</li>
<li> <p><code>AC</code>
Anodes and Cnodes combined and sorted </p>
</li>
<li> <p><code>LY</code> Lnodes and Ynodes
combined, sorted, &quot;blocks&quot; removed - see <code><a href="#topic+ltmle">ltmle</a></code> </p>
</li></ul>
</td></tr>
<tr><td><code id="deterministic.g.function_template_+3A_called.from.estimate.g">called.from.estimate.g</code></td>
<td>
<p>TRUE or FALSE - your function will be called
with <code>called.from.estimate.g=TRUE</code> during estimation of g and
<code>called.from.estimate.g=FALSE</code> during estimation of Q.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MaintainTreatment</code> and <code>MaintainControl</code> are two commonly used
<code>deterministic.g.function</code>s.
</p>
<p>The intended use of the templates is for the user to copy and paste the
function arguments and body and then fill in the required sections. They
will not run as-is. Note that there are no comments in the functions as
saved. Versions with comments may be found in Examples section below.
</p>
<p>MaintainTreatment and MaintainControl may be passed as-is for the
<code>deterministic.g.function</code> argument to <code><a href="#topic+ltmle">ltmle</a></code> or
<code><a href="#topic+ltmleMSM">ltmleMSM</a></code>
</p>
<p>Note that censoring nodes in <code>data</code> may be passed as binaries but they
are converted to the preferred format of factors with levels &quot;censored&quot; and
&quot;uncensored&quot; before deterministic functions are called.  Also note that
nodes may be passed to ltmle as either the names of nodes or numerical
column indicies, but they are all converted to numerical indicies before
deterministic functions are called.  If the <code>survivalFunction</code> argument
to <code>ltmle</code> or <code>ltmleMSM</code> is <code>TRUE</code>, the package automatically
assumes that once Y jumps to 1, all future Y nodes stay 1 and treatment does
not change. It is not necessary to specify this in deterministic functions.
</p>


<h3>Value</h3>

<p>A deterministic.g.function should return a list with components:
</p>
<table role = "presentation">
<tr><td><code>is.deterministic</code></td>
<td>
<p>vector of logicals, length=nrow(data)</p>
</td></tr> <tr><td><code>prob1</code></td>
<td>
<p>the probability that data[is.deterministic, current.node] == 1, vector of
length 1 or length(which(is.deterministic))</p>
</td></tr></table>
<p> A deterministic.Q.function
should return a list with components: </p>
<table role = "presentation">
<tr><td><code>is.deterministic</code></td>
<td>
<p>vector of
logicals, length=nrow(data)</p>
</td></tr> <tr><td><code>Q.value</code></td>
<td>
<p>the iterated expectation of the
final Y, vector of length 1 or length(which(is.deterministic))</p>
</td></tr>
</table>
<p>NOTE: The <code>Q.value</code> component is not used or required when
<code>called.from.estimate.g</code> is <code>TRUE</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>deterministic.Q.function_template()</code>: Template for the <code>deterministic.Q.function</code> 
argument to <code><a href="#topic+ltmle">ltmle</a></code> or <code><a href="#topic+ltmleMSM">ltmleMSM</a></code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Joshua Schwab <a href="mailto:jschwab77@berkeley.edu">jschwab77@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltmle">ltmle</a></code>, <code><a href="#topic+ltmleMSM">ltmleMSM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Show template for a deterministic.g.function (comments will not be
# shown, see below for comments)
deterministic.g.function_template

# Show template for a deterministic.Q.function (comments will not be
# shown, see below for comments)
deterministic.Q.function_template

# Use MaintainTreatment
set.seed(1)
rexpit &lt;- function(x) rbinom(n = length(x), size = 1, prob = plogis(x))
n &lt;- 100
W &lt;- rnorm(n)
A1 &lt;- rexpit(W)
A2 &lt;- as.numeric(rexpit(W) | A1)  #treatment at time 1 implies treatment at time 2
Y &lt;- rexpit(W + A1 + A2 + rnorm(n))
data &lt;- data.frame(W, A1, A2, Y)

result &lt;- ltmle(data, Anodes = c("A1", "A2"), Ynodes = "Y", abar = c(1, 1), 
    deterministic.g.function = MaintainTreatment)

# deterministic.g.function_template with comments:

deterministic.g.function_template &lt;- function(data, current.node, nodes) {
    # data: the 'data' data.frame passed to ltmle/ltmleMSM current.node: the
    # column index of data corresponding to the A or C node (see
    # is.deterministic below) nodes: list of column indicies, components: A,
    # C, L, Y, AC (Anodes and Cnodes combined and sorted), LY (Lnodes and
    # Ynodes combined, sorted, 'blocks' removed - see ?ltmle) Note that nodes
    # may be passed to ltmle as either the names of nodes or numerical column
    # indicies, but they are all converted to numerical indicies before
    # deterministic.g.function is called
    
    # deterministic.g.function will be called at all Anodes and Cnodes
    # return(NULL) is equivalent to return(list(is.deterministic=rep(FALSE,
    # nrow(data)), prob1=numeric(0)))
    
    # define is.deterministic here: vector of logicals, length=nrow(data)
    # define prob1 here: the probability that data[is.deterministic,
    # current.node] == 1, vector of length 1 or
    # length(which(is.deterministic))
    is.deterministic &lt;- stop("replace me!")
    prob1 &lt;- stop("replace me!")
    return(list(is.deterministic = is.deterministic, prob1 = prob1))
}

# deterministic.Q.function_template with comments:

deterministic.Q.function_template &lt;- function(data, current.node, nodes, 
    called.from.estimate.g) {
    # data: the 'data' data.frame passed to ltmle/ltmleMSM current.node: the
    # column index of data corresponding to the A or C node (see
    # is.deterministic below) nodes: list of column indicies, components: A,
    # C, L, Y, AC (Anodes and Cnodes combined and sorted), LY (Lnodes and
    # Ynodes combined, sorted, 'blocks' removed - see ?ltmle)
    # called.from.estimate.g: TRUE or FALSE - your function will be called
    # with called.from.estimate.g=TRUE during estimation of g and
    # called.from.estimate.g=FALSE during estimation of Q. During estimation
    # of g, only the is.deterministic element of the return list will be
    # used.  Note that nodes may be passed to ltmle as either the names of
    # nodes or numerical column indicies, but they are all converted to
    # numerical indicies before deterministic.Q.function is called
    
    # It is not necessary to specify that deterministic Y events (Y==1)
    # indicate a deterministic Q value of 1; this is automatic 
    # if the survivalFunction input to ltmle/ltmleMSM is TRUE.
    # deterministic.Q.function will be called at all Lnodes and Ynodes (after
    # removing 'blocks') and Anodes and Cnodes (see called.from.estimate.g
    # above) return(NULL) is equivalent to
    # return(list(is.deterministic=rep(FALSE, nrow(data)),
    # Q.value=numeric(0)))
    
    # define is.deterministic here: vector of logicals, length=nrow(data)
    # define Q.value here: the iterated expectation of the final Y, vector of
    # length 1 or length(which(is.deterministic))
    is.deterministic &lt;- stop("replace me!")
    Q.value &lt;- stop("replace me!")
    return(list(is.deterministic = is.deterministic, Q.value = Q.value))
}

</code></pre>

<hr>
<h2 id='ltmle'>Longitudinal Targeted Maximum Likelihood Estimation</h2><span id='topic+ltmle'></span><span id='topic+ltmleMSM'></span>

<h3>Description</h3>

<p><code>ltmle</code> is Targeted Maximum Likelihood Estimation (TMLE) of
treatment/censoring specific mean outcome for point-treatment and
longitudinal data. <code>ltmleMSM</code> adds Marginal Structural Models. Both
always provide Inverse Probability of Treatment/Censoring Weighted estimate
(IPTW) as well. Maximum likelihood based G-computation estimate (G-comp) can
be obtained instead of TMLE. <code>ltmle</code> can be used to calculate additive
treatment effect, risk ratio, and odds ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltmle(
  data,
  Anodes,
  Cnodes = NULL,
  Lnodes = NULL,
  Ynodes,
  survivalOutcome = NULL,
  Qform = NULL,
  gform = NULL,
  abar,
  rule = NULL,
  gbounds = c(0.01, 1),
  Yrange = NULL,
  deterministic.g.function = NULL,
  stratify = FALSE,
  SL.library = "glm",
  SL.cvControl = list(),
  estimate.time = TRUE,
  gcomp = FALSE,
  iptw.only = FALSE,
  deterministic.Q.function = NULL,
  variance.method = "tmle",
  observation.weights = NULL,
  id = NULL
)

ltmleMSM(
  data,
  Anodes,
  Cnodes = NULL,
  Lnodes = NULL,
  Ynodes,
  survivalOutcome = NULL,
  Qform = NULL,
  gform = NULL,
  gbounds = c(0.01, 1),
  Yrange = NULL,
  deterministic.g.function = NULL,
  SL.library = "glm",
  SL.cvControl = list(),
  regimes,
  working.msm,
  summary.measures,
  final.Ynodes = NULL,
  stratify = FALSE,
  msm.weights = "empirical",
  estimate.time = TRUE,
  gcomp = FALSE,
  iptw.only = FALSE,
  deterministic.Q.function = NULL,
  variance.method = "tmle",
  observation.weights = NULL,
  id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ltmle_+3A_data">data</code></td>
<td>
<p>data frame following the time-ordering of the nodes. See
'Details'.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_anodes">Anodes</code></td>
<td>
<p>column names or indicies in <code>data</code> of treatment nodes</p>
</td></tr>
<tr><td><code id="ltmle_+3A_cnodes">Cnodes</code></td>
<td>
<p>column names or indicies in <code>data</code> of censoring nodes</p>
</td></tr>
<tr><td><code id="ltmle_+3A_lnodes">Lnodes</code></td>
<td>
<p>column names or indicies in <code>data</code> of time-dependent
covariate nodes</p>
</td></tr>
<tr><td><code id="ltmle_+3A_ynodes">Ynodes</code></td>
<td>
<p>column names or indicies in <code>data</code> of outcome nodes</p>
</td></tr>
<tr><td><code id="ltmle_+3A_survivaloutcome">survivalOutcome</code></td>
<td>
<p>If <code>TRUE</code>, then Y nodes are indicators of an
event, and if Y at some time point is 1, then all following should be 1.
Required to be <code>TRUE</code> or <code>FALSE</code> if outcomes are binary and there
are multiple Ynodes.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_qform">Qform</code></td>
<td>
<p>character vector of regression formulas for <code class="reqn">Q</code>. See
'Details'.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_gform">gform</code></td>
<td>
<p>character vector of regression formulas for <code class="reqn">g</code> or a
matrix/array of prob(A=1). See 'Details'.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_abar">abar</code></td>
<td>
<p>binary vector (numAnodes x 1) or matrix (n x numAnodes) of
counterfactual treatment or a list of length 2. See 'Details'.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_rule">rule</code></td>
<td>
<p>a function to be applied to each row (a named vector) of
<code>data</code> that returns a numeric vector of length numAnodes. See 'Details'.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_gbounds">gbounds</code></td>
<td>
<p>lower and upper bounds on estimated cumulative probabilities
for g-factors. Vector of length 2, order unimportant.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_yrange">Yrange</code></td>
<td>
<p>NULL or a numerical vector where the min and max of
<code>Yrange</code> specify the range of all Y nodes. See 'Details'.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_deterministic.g.function">deterministic.g.function</code></td>
<td>
<p>optional information on A and C nodes that
are given deterministically. See 'Details'. Default <code>NULL</code> indicates no
deterministic links.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_stratify">stratify</code></td>
<td>
<p>if <code>TRUE</code> stratify on following <code>abar</code> when
estimating Q and g. If <code>FALSE</code>, pool over <code>abar</code>.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_sl.library">SL.library</code></td>
<td>
<p>optional character vector of libraries to pass to
<code><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a></code>. <code>NULL</code> indicates
<a href="stats.html#topic+glm">glm</a> should be called instead of
<code><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a></code>. '<code>default</code>'
indicates a standard set of libraries. May be separately specified for
<code class="reqn">Q</code> and <code class="reqn">g</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_sl.cvcontrol">SL.cvControl</code></td>
<td>
<p>optional list to be passed as <code>cvControl</code> to <code><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a></code></p>
</td></tr>
<tr><td><code id="ltmle_+3A_estimate.time">estimate.time</code></td>
<td>
<p>if <code>TRUE</code>, run an initial estimate using only 50
observations and use this to print a very rough estimate of the total time
to completion. No action if there are fewer than 50 observations.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_gcomp">gcomp</code></td>
<td>
<p>if <code>TRUE</code>, run the maximum likelihood based G-computation
estimate <em>instead</em> of TMLE</p>
</td></tr>
<tr><td><code id="ltmle_+3A_iptw.only">iptw.only</code></td>
<td>
<p>by default (<code>iptw.only = FALSE</code>), both TMLE and IPTW
are run in <code>ltmle</code> and <code>ltmleMSM</code>. If <code>iptw.only = TRUE</code>,
only IPTW is run, which is faster.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_deterministic.q.function">deterministic.Q.function</code></td>
<td>
<p>optional information on Q given
deterministically. See 'Details'. Default <code>NULL</code> indicates no
deterministic links.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_variance.method">variance.method</code></td>
<td>
<p>Method for estimating variance of TMLE.
One of &quot;ic&quot;, &quot;tmle&quot;, &quot;iptw&quot;. If &quot;tmle&quot;, compute both the robust variance
estimate using TMLE and the influence curve based variance estimate (use the
larger of the two). If &quot;iptw&quot;, compute both the robust variance
estimate using IPTW and the influence curve based variance estimate (use the
larger of the two). If &quot;ic&quot;, only compute the influence curve based
variance estimate. &quot;ic&quot; is fastest, but may be substantially
anti-conservative if there are positivity violations or rare outcomes. &quot;tmle&quot; is
slowest but most robust if there are positivity violations or rare outcomes.
&quot;iptw&quot; is a compromise between speed and robustness.
variance.method=&quot;tmle&quot; or &quot;iptw&quot; are not yet available with non-binary outcomes,
gcomp=TRUE, stratify=TRUE, or deterministic.Q.function.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_observation.weights">observation.weights</code></td>
<td>
<p>observation (sampling) weights. Vector of length
n. If <code>NULL</code>, assumed to be all 1.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_id">id</code></td>
<td>
<p>Household or subject identifiers. Vector of length n or <code>NULL</code>.
Integer, factor, or character recommended, but any type that can be coerced
to factor will work. <code>NULL</code> means all distinct ids.</p>
</td></tr>
<tr><td><code id="ltmle_+3A_regimes">regimes</code></td>
<td>
<p>binary array: n x numAnodes x numRegimes of counterfactual
treatment or a list of 'rule' functions</p>
</td></tr>
<tr><td><code id="ltmle_+3A_working.msm">working.msm</code></td>
<td>
<p>character formula for the working marginal structural
model</p>
</td></tr>
<tr><td><code id="ltmle_+3A_summary.measures">summary.measures</code></td>
<td>
<p>array: num.regimes x num.summary.measures x
num.final.Ynodes - measures summarizing the regimes that will be used on the
right hand side of <code>working.msm</code> (baseline covariates may also be used
in the right hand side of <code>working.msm</code> and do not need to be included
in <code>summary.measures</code>)</p>
</td></tr>
<tr><td><code id="ltmle_+3A_final.ynodes">final.Ynodes</code></td>
<td>
<p>vector subset of Ynodes - used in MSM to pool over a set
of outcome nodes</p>
</td></tr>
<tr><td><code id="ltmle_+3A_msm.weights">msm.weights</code></td>
<td>
<p>projection weights for the working MSM. If &quot;empirical&quot;,
weight by empirical proportions of rows matching each regime for each
final.Ynode, with duplicate regimes given zero weight. If <code>NULL</code>, no
weights. Or an array of user-supplied weights with dimensions c(n,
num.regimes, num.final.Ynodes) or c(num.regimes, num.final.Ynodes).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimates returned by <code>ltmle</code> are of a treatment specific mean,
<code class="reqn">E[Y_{\bar{a}}]</code>, the mean of the final treatment node, where all
treatment nodes, <code class="reqn">A</code>, are set to <code class="reqn">\bar{a}</code> (<code>abar</code>) and all
censoring nodes <code class="reqn">C</code> are set to 1 (uncensored). The estimates returned by
<code>ltmleMSM</code> are similar but are the parameters in a working marginal
structural model.
</p>
<p><code>data</code> should be a data frame where the order of the columns
corresponds to the time-ordering of the model.  </p>
 <ul>
<li><p> in censoring
columns (Cnodes): factor with two levels: &quot;censored&quot; and &quot;uncensored&quot;. The
helper function <code>BinaryToCensoring</code> can be used to create these
factors.  </p>
</li>
<li><p> in treatment columns (Anodes): 1 = treated, 0 = untreated
(must be binary) </p>
</li>
<li><p> in event columns (Ynodes): If <code>survivalOutcome</code>
is <code>TRUE</code>, then Y nodes are treated as indicators of a one-time event.
See details for <code>survivalOutocme</code>. If <code>survivalOutcome</code> is
<code>FALSE</code>, Y nodes are treated as binary if all values are 0 or 1, and
are treated as continuous otherwise. If Y nodes are continuous, they may be
automatically scaled. See details for <code>Yrange</code>.  </p>
</li>
<li><p> time-dependent
covariate columns (Lnodes): can be any numeric data </p>
</li>
<li><p> Data in
<code>Cnodes</code>, <code>Anodes</code>, <code>Lnodes</code> and <code>Ynodes</code> are not used
after (to the right of) censoring (or an event when
<code>survivalOutcome==TRUE</code>) and may be coded as <code>NA</code> or any other
value.  </p>
</li>
<li><p> Columns in <code>data</code> that are before (to the left of) the
first of <code>Cnodes</code> or <code>Anodes</code> are treated as baseline variables,
even if they are specified as <code>Lnodes</code>.  </p>
</li>
<li><p> After the first of
<code>Cnodes</code>, <code>Anodes</code>, <code>Ynodes</code>, or <code>Lnodes</code>, every column
must be in one of <code>Cnodes</code>, <code>Anodes</code>, <code>Ynodes</code>, or
<code>Lnodes</code>.  </p>
</li></ul>

<p>If <code>survivalOutcome</code> is <code>TRUE</code>, all Y values are indicators of an
event (e.g. death) at or before the current time, where 1 = event and 0 = no
event. The events in Ynodes must be of the form where once Y jumps to 1, Y
remains 1 at subsequent nodes.
</p>
<p>For continuous outcomes, (<code>survivalOutcome==FALSE</code> and some Y nodes are
not 0 or 1,) Y values are truncated at the minimum and maximum of
<code>Yrange</code> if specified, and then transformed and scaled to be in [0,1].
That is, transformed to <code>(Y-min(Yrange))/(max(Yrange)-min(Yrange))</code>. If
<code>Yrange</code> is <code>NULL</code>, it is set to the range of all Y nodes. In that
case, Y nodes are only scaled if any values fall outside of [0,1]. For
intervention specific means (<code>ltmle</code>), parameter estimates are
transformed back based <code>Yrange</code>.
</p>
<p><code>Qform</code> should be <code>NULL</code>, in which case all parent nodes of each L
and Y node will be used as regressors, or a named character vector that can
be coerced to class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot;. The length of <code>Qform</code> must
be equal to <code>length(Lnodes) + length(Ynodes)</code>** and the names and order
of the formulas must be the same as the names and order of the L and Y nodes
in <code>data</code>. The left hand side of each formula should be
&quot;<code>Q.kplus1</code>&quot;. If <code>SL.library</code> is <code>NULL</code>, <code>glm</code> will be
called using the elements of <code>Qform</code>. If <code>SL.library</code> is
specified, <code><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a></code> will be
called after a design matrix is created using <code>Qform.</code>
</p>
<p>** If there is a &quot;block&quot; of L and Y nodes not separated by A or C nodes,
only one regression is required at the first L/Y node in a block. You can
pass regression formulas for the other L/Y nodes, but they will be ignored
(with a message). See example 5.
</p>
<p><code>gform</code> should be <code>NULL</code>, in which case all parent nodes of each L
and Y node will be used as regressors, or a character vector that can be
coerced to class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot;, or a matrix/array of Prob(A=1). If
<code>gform</code> is a character vector, the length of <code>gform</code> must be equal
to <code>length(Anodes) + length(Cnodes)</code> and the order of the formulas must
be the same as the order the A and C nodes appear in <code>data</code>. The left
hand side of each formula should be the name of the Anode or Cnode. If
<code>SL.library</code> is <code>NULL</code>, <code>glm</code> will be called using the
elements of <code>gform</code>. If <code>SL.library</code> is specified,
<code><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a></code> will be called after a
design matrix is created using <code>gform</code>.
</p>
<p>In <code>ltmle</code>, <code>gform</code> can also be a n x numACnodes matrix where
entry (i, j) is the probability that the ith observation of the jth A/C node
is 1 (if an Anode) or uncensored (if a Cnode), conditional on following abar
up to that node. In <code>ltmleMSM</code>, <code>gform</code> can similarly be a n x
numACnodes x numRegimes array, where entry (i, j, k) is the probability that
the ith observation of the jth A/C node is 1 (if an Anode) or uncensored (if
a Cnode), conditional on following regime k up to that node. If <code>gform</code>
is a matrix/array, <code>deterministic.g.function</code> will not be used and
should be <code>NULL</code>.
</p>
<p><code>abar</code> specifies the counterfactual values of the Anodes, using the
order they appear in <code>data</code> and should have the same length (if abar is
a vector) or number of columns (if abar is a matrix) as <code>Anodes</code>.
</p>
<p><code>rule</code> can be used to specify a dynamic treatment rule. <code>rule</code> is
a function applied to each row of <code>data</code> which returns a numeric
vector of the same length as <code>Anodes</code>.
</p>
<p><code>abar</code> and <code>rule</code> cannot both be specified. If one of them if a
list of length 2, additive treatment effect, risk ratio, and odds ratio can
be computed using <code><a href="#topic+summary.ltmleEffectMeasures">summary.ltmleEffectMeasures</a></code>.
</p>
<p><code>regimes</code> can be a binary array: n x numAnodes x numRegimes of
counterfactual treatment or a list of 'rule' functions as described above
for the <code>rule</code> argument for the <code>ltmle</code> function
</p>
<p><code>deterministic.g.function</code> can be a function used to specify model
knowledge about value of Anodes and/or Cnodes that are set
deterministically. For example, it may be the case that once a patient
starts treatment, they always stay on treatment. For details on the form of
the function and examples, see
<code><a href="#topic+deterministic.g.function_template">deterministic.g.function_template</a></code>
</p>
<p><code>deterministic.Q.function</code> can be a function used to specify model
knowledge about the final event state. For example, it may be the case that
a patient can complete the study at some intermediate time point, in which
case the probability of death is 0 (assuming they have not died already).
For details on the form of the function and examples, see
<code><a href="#topic+deterministic.Q.function_template">deterministic.Q.function_template</a></code>
</p>
<p><code>SL.library</code> may be a character vector of libraries (or '<code>glm</code>' or
'<code>default</code>'), in which case these libraries are used to estimate both
<code class="reqn">Q</code> and <code class="reqn">g</code> OR a list with two components, <code>Q</code> and <code>g</code>,
where each is a character vector of libraries (or '<code>glm</code>' or
'<code>default</code>').  '<code>glm</code>' indicates <a href="stats.html#topic+glm">glm</a> should be called
instead of <code><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a></code> If
<code>SL.library</code> is the string '<code>default</code>', <code>SL.library</code> is set
to <code>list("SL.glm", "SL.stepAIC", "SL.bayesglm", c("SL.glm",
"screen.corP"), c("SL.step", "screen.corP"), c("SL.step.forward",
"screen.corP"), c("SL.stepAIC", "screen.corP"), c("SL.step.interaction",
"screen.corP"), c("SL.bayesglm", "screen.corP")</code>.  Note that the default set
of libraries consists of main terms models. It may be advisable to include
squared terms, interaction terms, etc in <code>gform</code> and <code>Qform</code> or
include libraries that consider non-linear terms.
</p>
<p>If <code>attr(SL.library, "return.fit") == TRUE</code>, then <code>fit$g</code> and
<code>fit$Q</code> will return full <code>SuperLearner</code> or <code>glm</code> objects.
If not, only a summary matrix will be returned to save memory.
</p>
<p>The print method for <code>ltmle</code> objects only prints the tmle estimates.
</p>


<h3>Value</h3>

<p><code>ltmle</code> returns an object of class &quot;<code>ltmle</code>&quot; (unless
<code>abar</code> or <code>rule</code> is a list, in which case it returns an object of
class <code>ltmleSummaryMeasures</code>, which has the same components as
<code>ltmleMSM</code>.) The function <code><a href="base.html#topic+summary">summary</a></code> (i.e.
<code><a href="#topic+summary.ltmle">summary.ltmle</a></code>) can be used to obtain or print a summary of the
results. An object of class &quot;<code>ltmle</code>&quot; is a list containing the
following components: </p>
<table role = "presentation">
<tr><td><code>estimates</code></td>
<td>
<p>a named vector of length 4 with
elements, each an estimate of <code class="reqn">E[Y_{bar{a}}]</code>: </p>
 <ul>
<li>
<p><code>tmle</code> - Targeted Maximum Likelihood Estimate [NULL if <code>gcomp</code> is
<code>TRUE</code>] </p>
</li>
<li> <p><code>iptw</code> - Inverse Probability of Treatment/Censoring
Weighted estimate </p>
</li>
<li> <p><code>gcomp</code> - maximum likelihood based
G-computation estimate [NULL if <code>gcomp</code> is <code>FALSE</code>] </p>
</li></ul>
 </td></tr>
<tr><td><code>IC</code></td>
<td>
<p>a list with the following components of Influence Curve values</p>
</td></tr>
</table>
 <ul>
<li> <p><code>tmle</code> - vector of influence curve values for Targeted
Maximum Likelihood Estimate [NULL if <code>gcomp</code> is <code>TRUE</code>] </p>
</li>
<li>
<p><code>iptw</code> - vector of influence curve values for Inverse Probability of
Treatment/Censoring Weighted estimate </p>
</li>
<li> <p><code>gcomp</code> - vector of
influence curve values for Targeted Maximum Likelihood Estimate without
updating [NULL if <code>gcomp</code> is <code>FALSE</code>] </p>
</li></ul>
 <table role = "presentation">
<tr><td><code>cum.g</code></td>
<td>
<p>cumulative g,
after bounding: for ltmle, n x numACnodes, for ltmleMSM, n x numACnodes x
num.regimes</p>
</td></tr> <tr><td><code>cum.g.unbounded</code></td>
<td>
<p>cumulative g, before bounding: for
ltmle, n x numACnodes, for ltmleMSM, n x numACnodes x num.regimes</p>
</td></tr>
<tr><td><code>cum.g.used</code></td>
<td>
<p>binary - TRUE if an entry of cum.g was used in the updating
step (note: even if cum.g.used is FALSE, a small value of cum.g.unbounded may
still indicate a positivity problem): for ltmle, n x numACnodes,
for ltmleMSM, n x numACnodes x num.regimes</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr> <tr><td><code>gcomp</code></td>
<td>
<p>the <code>gcomp</code> input</p>
</td></tr>
<tr><td><code>formulas</code></td>
<td>
<p>a <code>list</code> with elements <code>Qform</code> and <code>gform</code></p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a list with the following components</p>
</td></tr> </table>
 <ul>
<li> <p><code>g</code> -
list of length numACnodes - <code>glm</code> or <code>SuperLearner</code> (see Details)
return objects from fitting g regressions
</p>
</li>
<li> <p><code>Q</code> - list of length numLYnodes - <code>glm</code> or <code>SuperLearner</code>
(see Details) return objects from fitting Q regressions
</p>
</li>
<li> <p><code>Qstar</code> - list of length numLYnodes - <code>glm</code> (or numerical
optimization if <code>glm</code> fails to solve the score equation) return objects
from updating the Q fit </p>
</li></ul>

<p><code>ltmleMSM</code> returns an object of class &quot;<code>ltmleMSM</code>&quot; The function
<code><a href="base.html#topic+summary">summary</a></code> (i.e. <code><a href="#topic+summary.ltmleMSM">summary.ltmleMSM</a></code>) can be used to
obtain or print a summary of the results. An object of class
&quot;<code>ltmleMSM</code>&quot; is a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>parameter estimates for working.msm using TMLE (GCOMP if
<code>gcomp</code> input is <code>TRUE</code>)</p>
</td></tr> <tr><td><code>beta.iptw</code></td>
<td>
<p>parameter estimates for
working.msm using IPTW</p>
</td></tr> <tr><td><code>IC</code></td>
<td>
<p>matrix, n x numBetas - influence curve
values for TMLE (without updating if <code>gcomp</code> input is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code>IC.iptw</code></td>
<td>
<p>matrix, n x numBetas - influence curve values for IPTW</p>
</td></tr>
<tr><td><code>msm</code></td>
<td>
<p>object of class glm - the result of fitting the working.msm</p>
</td></tr>
<tr><td><code>cum.g</code></td>
<td>
<p>array, n x numACnodes x numRegimes - cumulative g, after
bounding</p>
</td></tr> <tr><td><code>cum.g.unbounded</code></td>
<td>
<p>array, n x numACnodes x numRegimes -
cumulative g, before bounding</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>gcomp</code></td>
<td>
<p>the <code>gcomp</code> input</p>
</td></tr> <tr><td><code>formulas</code></td>
<td>
<p>a <code>list</code> with
elements <code>Qform</code> and <code>gform</code></p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a list with the following components</p>
</td></tr>
</table>
 <ul>
<li> <p><code>g</code> - list of length numRegimes of list of length
numACnodes - <code>glm</code> or <code>SuperLearner</code> (see Details) return objects from
fitting g regressions </p>
</li>
<li> <p><code>Q</code> - list of length numLYnodes -
<code>glm</code> or <code>SuperLearner</code> (see Details) return objects from fitting Q
regressions
</p>
</li>
<li> <p><code>Qstar</code> - list of length numLYnodes - <code>glm</code> (or numerical
optimization if <code>glm</code> fails to solve the score equation) return objects
from updating the Q fit </p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>ltmleMSM()</code>: Longitudinal Targeted Maximum Likelihood Estimation for a Marginal Structural Model
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Joshua Schwab <a href="mailto:jschwab77@berkeley.edu">jschwab77@berkeley.edu</a>, Samuel Lendle, Maya
Petersen, and Mark van der Laan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ltmle">summary.ltmle</a></code>, <code><a href="#topic+summary.ltmleMSM">summary.ltmleMSM</a></code>,
<code><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a></code>,
<code><a href="#topic+deterministic.g.function_template">deterministic.g.function_template</a></code>,
<code><a href="#topic+deterministic.Q.function_template">deterministic.Q.function_template</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See \url{http://joshuaschwab.github.io/ltmle/} for more examples.

rexpit &lt;- function(x) rbinom(n=length(x), size=1, prob=plogis(x))

# Single time point Example
n &lt;- 1000
W &lt;- rnorm(n)
A &lt;- rexpit(-1 + 2 * W)
Y &lt;- rexpit(W + A)
data &lt;- data.frame(W, A, Y)

result1 &lt;- ltmle(data, Anodes="A", Ynodes="Y", abar=1)
summary(result1)
summary(result1, estimator="iptw")
# MSM Example
# Given data over 3 time points where A switches to 1 once and then stays 1. We want to know
# how death varies as a function of gender, time and an indicator of whether a patient's
# intended regime was to switch before time.
# Note that working.msm includes time and switch.time, which are columns of
# summary.measures; working.msm also includes male, which is ok because it is a baseline
# covariate (it comes before any A/C/L/Y nodes).
data(sampleDataForLtmleMSM)
Anodes &lt;- grep("^A", names(sampleDataForLtmleMSM$data))
Lnodes &lt;- c("CD4_1", "CD4_2")
Ynodes &lt;- grep("^Y", names(sampleDataForLtmleMSM$data))
msm.weights &lt;- matrix(1:12, nrow=4, ncol=3) #just an example (can also use a 200x3x4 array),
                                            #or NULL (for no weights), or "empirical" (the default)

result2 &lt;- ltmleMSM(sampleDataForLtmleMSM$data, Anodes=Anodes, Lnodes=Lnodes, Ynodes=Ynodes,
                   survivalOutcome=TRUE,
                   regimes=sampleDataForLtmleMSM$regimes,
                   summary.measures=sampleDataForLtmleMSM$summary.measures, final.Ynodes=Ynodes,
                   working.msm="Y ~ male + time + I(pmax(time - switch.time, 0))",
                   msm.weights=msm.weights, estimate.time=FALSE)
print(summary(result2))

</code></pre>

<hr>
<h2 id='sampleDataForLtmleMSM'>Sample data, regimes, and summary measures</h2><span id='topic+sampleDataForLtmleMSM'></span>

<h3>Description</h3>

<p>Sample data for use with ltmleMSM. Data: n=1000: male age CD4_1 A1 Y1 CD4_2
A2 Y2 CD4_3 A3 Y3 A1..A3 are treatment nodes, Y1..Y3 are death, CD4_1..CD4_3
are time varying covariates. We are interested in static regimes where a
patient switches at some time. In summary.measures, switch.time is first
time where At is 1 (4 if never switch), time is the horizon.
</p>


<h3>Format</h3>

<p>List with three components: data, regimes, summary.measures
</p>


<h3>Details</h3>

<p>regimes: 200 x 3 x 4 [n x numACnodes x numRegimes] summary.measures: 4 x 2 x
3 [numRegimes x numSummaryMeasures x numFinalYnodes]
</p>


<h3>Source</h3>

<p>simulated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sampleDataForLtmleMSM)

</code></pre>

<hr>
<h2 id='summary.ltmle'>Get standard error, p-value, and confidence interval for one ltmle object
Summarizing results from Longitudinal Targeted Maximum Likelihood Estimation
(ltmle)</h2><span id='topic+summary.ltmle'></span><span id='topic+print.ltmle'></span><span id='topic+print.summary.ltmle'></span><span id='topic+summary.ltmleMSM'></span><span id='topic+print.ltmleMSM'></span><span id='topic+print.summary.ltmleMSM'></span><span id='topic+summary.ltmleEffectMeasures'></span><span id='topic+print.ltmleEffectMeasures'></span><span id='topic+print.summary.ltmleEffectMeasures'></span>

<h3>Description</h3>

<p>These functions are methods for class <code>ltmle</code> or <code>summary.ltmle</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ltmle'
summary(object, estimator = ifelse(object$gcomp, "gcomp", "tmle"), ...)

## S3 method for class 'ltmleEffectMeasures'
summary(object, estimator = ifelse(object$gcomp, "gcomp", "tmle"), ...)

## S3 method for class 'ltmleMSM'
summary(object, estimator = ifelse(object$gcomp, "gcomp", "tmle"), ...)

## S3 method for class 'summary.ltmleMSM'
print(
  x,
  digits = max(3, getOption("digits") - 3),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'summary.ltmle'
print(x, ...)

## S3 method for class 'ltmleEffectMeasures'
print(x, ...)

## S3 method for class 'summary.ltmleEffectMeasures'
print(x, ...)

## S3 method for class 'ltmleMSM'
print(x, ...)

## S3 method for class 'ltmle'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ltmle_+3A_object">object</code></td>
<td>
<p>an object of class &quot;<code>ltmle</code>&quot; or &quot;<code>ltmleMSM</code>&quot; or
&quot;<code>ltmleEffectMeasures</code>&quot;, usually a result of a call to
<code><a href="#topic+ltmle">ltmle</a></code> or <code><a href="#topic+ltmleMSM">ltmleMSM</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ltmle_+3A_estimator">estimator</code></td>
<td>
<p>character; one of &quot;tmle&quot;, &quot;iptw&quot;, &quot;gcomp&quot;. The estimator
for which to get effect measures. &quot;tmle&quot; is valid iff the original
ltmle/ltmleMSM call used gcomp=FALSE. &quot;gcomp&quot; is valid iff the original
ltmle/ltmleMSM call used gcomp=TRUE</p>
</td></tr>
<tr><td><code id="summary.ltmle_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.ltmle_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>summary.ltmle</code>&quot; or
&quot;<code>summary.ltmleMSM</code>&quot; or &quot;<code>ltmleEffectMeasures</code>&quot;, usually a result
of a call to <code><a href="#topic+summary.ltmle">summary.ltmle</a></code> or <code><a href="#topic+summary.ltmleMSM">summary.ltmleMSM</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ltmle_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.ltmle_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, significance stars are printed
for each coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.ltmle</code> returns the parameter value of the estimator, the
estimated variance, a 95 percent confidence interval, and a p-value.
</p>
<p><code>summary.ltmleEffectMeasures</code> returns the additive treatment effect for
each of the two objects in the <code>abar</code> list passed to <code>ltmle</code>.
Relative risk, and odds ratio are also returned, along with the variance,
confidence interval, and p-value for each.
</p>
<p><code>summary.ltmleMSM</code> returns a matrix of MSM parameter estimates.
</p>


<h3>Value</h3>

<p><code>summary.ltmle</code> returns an object of class
&quot;<code>summary.ltmle</code>&quot;, a list with components </p>
<table role = "presentation">
<tr><td><code>treatment</code></td>
<td>
<p>a list with
components summarizing the estimate of <code>object</code> </p>
 <ul>
<li>
<p><code>estimate</code> - the parameter estimate of <code class="reqn">E[Y_d]</code> </p>
</li>
<li>
<p><code>std.dev</code> - estimated standard deviation of parameter </p>
</li>
<li>
<p><code>p.value</code> - two-sided p-value </p>
</li>
<li> <p><code>CI</code> - vector of length 2 with
95 percent confidence interval </p>
</li></ul>
 </td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call to <code>ltmle</code> for <code>object</code></p>
</td></tr>
<tr><td><code>estimator</code></td>
<td>
<p>the <code>estimator</code> input argument</p>
</td></tr>
<tr><td><code>variance.estimate.ratio</code></td>
<td>
<p>ratio of the TMLE based variance estimate to
the influence curve based variance estimate</p>
</td></tr>
</table>
<p><code>summary.ltmleEffectMeasures</code> returns an object of class
&quot;<code>summary.ltmleEffectMeasures</code>&quot;, a list with same components as
<code>summary.ltmle</code> above, but also includes: </p>
<table role = "presentation">
<tr><td><code>effect.measures</code></td>
<td>
<p>a list
with components, each with the same components as <code>treatment</code> in
<code>summary.ltmle</code> above </p>
 <ul>
<li> <p><code>treatment</code> - corresponds to
the first in the list <code>abar</code> (or <code>rule</code>) passed to <code>ltmle</code>
</p>
</li>
<li> <p><code>control</code> - corresponds to the second in the list <code>abar</code> (or
<code>rule</code>) passed to <code>ltmle</code> </p>
</li>
<li> <p><code>ATE</code> - average treatment
effect </p>
</li>
<li> <p><code>RR</code> - relative risk </p>
</li>
<li> <p><code>OR</code> - odds ratio </p>
</li></ul>
 </td></tr>
</table>
<p><code>summary.ltmleMSM</code> returns an object of class
&quot;<code>summary.ltmleMSM</code>&quot;, a matrix with rows for each MSM parameter and
columns for the point estimate, standard error, 2.5percent confidence
interval, 97.5percent confidence interval, and p-value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltmle">ltmle</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rexpit &lt;- function(x) rbinom(n = length(x), size = 1, prob = plogis(x))

# Compare the expected outcomes under two counterfactual plans: Treatment plan:
# set A1 to 1 if W &gt; 0, set A2 to 1 if W &gt; 1.5, always set A3 to 1 Control plan:
# always set A1, A2, and A3 to 0
W &lt;- rnorm(1000)
A1 &lt;- rexpit(W)
A2 &lt;- rexpit(W + 2 * A1)
A3 &lt;- rexpit(2 * A1 - A2)
Y &lt;- rexpit(W - A1 + 0.5 * A2 + 2 * A3)
data &lt;- data.frame(W, A1, A2, A3, Y)
treatment &lt;- cbind(W &gt; 0, W &gt; 1.5, 1)
control &lt;- matrix(0, nrow = 1000, ncol = 3)
result &lt;- ltmle(data, Anodes = c("A1", "A2", "A3"), Ynodes = "Y", abar = list(treatment,
    control))
print(summary(result))

## For examples of summary.ltmle and summary.ltmleMSM, see example(ltmle)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
