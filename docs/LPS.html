<!DOCTYPE html><html><head><title>Help for package LPS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LPS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clusterize'>
<p>Hierarchical clustering heat maps</p></a></li>
<li><a href='#heat'>
<p>Heatmap palette generation</p></a></li>
<li><a href='#heat.map'>
<p>Enhanced heat map ploting</p></a></li>
<li><a href='#heat.scale'>
<p>Plots a heat map color scale, for legend</p></a></li>
<li><a href='#LPS'>
<p>Linear Predictor Score fitting</p></a></li>
<li><a href='#LPS.coeff'>
<p>Linear Predictor Score coefficient computation</p></a></li>
<li><a href='#OVL'>
<p>Overlap quantification for LPS object</p></a></li>
<li><a href='#plot.LPS'>
<p>Plot method for LPS objects</p></a></li>
<li><a href='#predict.LPS'>
<p>Predict method for LPS objects</p></a></li>
<li><a href='#Rosenwald dataset'>
<p>Rosenwald et al. Lymphochip data</p></a></li>
<li><a href='#surv.colors'>
<p>Produces visual representation of survival data</p></a></li>
<li><a href='#surv.scale'>
<p>Plots a survival color scale, for legend</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear Predictor Score, for Binary Inference from Multiple
Continuous Variables</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.16</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Sylvain Mareschal</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sylvain Mareschal &lt;maressyl@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bioinformatics.ovsa.fr/LPS">https://bioinformatics.ovsa.fr/LPS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/maressyl/R.LPS/issues">https://github.com/maressyl/R.LPS/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the Linear Predictor Score approach, as initiated by Radmacher et al. (J Comput Biol 2001) and enhanced by Wright et al. (PNAS 2003) for gene expression signatures. Several tools for unsupervised clustering of gene expression data are also provided.</td>
</tr>
<tr>
<td>Depends:</td>
<td>graphics, grDevices, R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>limma</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-29 10:00:08 UTC; sylvain</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-29 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clusterize'>
Hierarchical clustering heat maps
</h2><span id='topic+clusterize'></span><span id='topic+hclust.ward'></span><span id='topic+dist.COR'></span>

<h3>Description</h3>

<p>This function draws a heat map ordered according to hierarchical clusterings, similarly to <code><a href="stats.html#topic+heatmap">heatmap</a></code>. It offers more control on layout and allows multiple row annotations.
</p>
<p><code>hclust.ward</code> is derivated from 'stats' package <code><a href="stats.html#topic+hclust">hclust</a></code>, with an alternative default (as arguments can not be passed to it).
</p>
<p><code>dist.COR</code> mimics 'stats' package <code><a href="stats.html#topic+dist">dist</a></code>, computing distances as 1 - Pearson's correlation coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  clusterize(expr, side = NULL, cex.col = NA, cex.row = NA, mai.left = NA,
    mai.bottom = NA, mai.right = 0.1, mai.top = 0.1, side.height = 1, side.col = NULL,
    side.srt = 0, side.cex = 1, col.heatmap = heat(), zlim = "0 centered",
	zlim.trim = 0.02, norm = c("rows", "columns", "none"), norm.clust = TRUE,
	norm.robust = FALSE, customLayout = FALSE, getLayout = FALSE, plot = TRUE,
	widths = c(1, 4), heights = c(1, 4), order.genes = NULL, order.samples = NULL,
	fun.dist = dist.COR, fun.hclust = hclust.ward, clust.genes = NULL,
	clust.samples = NULL)
  dist.COR(input)
  hclust.ward(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterize_+3A_expr">expr</code></td>
<td>

<p>A numeric matrix, holding features (genes) in columns and observations (samples) in rows. Rows and columns will be ordered according to hierarchical clustering results.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_side">side</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_cex.col">cex.col</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_cex.row">cex.row</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_mai.left">mai.left</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_mai.bottom">mai.bottom</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_mai.right">mai.right</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_mai.top">mai.top</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_side.height">side.height</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_side.col">side.col</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_side.srt">side.srt</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_side.cex">side.cex</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_col.heatmap">col.heatmap</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_zlim">zlim</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_zlim.trim">zlim.trim</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_norm">norm</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_norm.clust">norm.clust</code></td>
<td>

<p>Single logical value, whether to apply normalization before clustering or after. Normalization applied depends on <code>norm</code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_norm.robust">norm.robust</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_customlayout">customLayout</code></td>
<td>

<p>Single logical value, as <code><a href="graphics.html#topic+layout">layout</a></code> does not allow nested calls, set this to TRUE to make your own call to layout and embed this plot in a wider one.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_getlayout">getLayout</code></td>
<td>

<p>Single logical value, whether to only return the <code>layout</code> arguments that would be used with the set of arguments provided or not. It can prove useful to build custom layouts, e.g. merging this plot to an other. See also <code>customLayout</code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_plot">plot</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_widths">widths</code></td>
<td>

<p>To be passed to <code><a href="graphics.html#topic+layout">layout</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_heights">heights</code></td>
<td>

<p>To be passed to <code><a href="graphics.html#topic+layout">layout</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_order.genes">order.genes</code></td>
<td>

<p>A function taking the gene dendrogram and <code>expr</code> as arguments, and returning the same dendrogram ordered in a custom way.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_order.samples">order.samples</code></td>
<td>

<p>A function taking the sample dendrogram and <code>expr</code> as arguments, and returning the same dendrogram ordered in a custom way.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_fun.dist">fun.dist</code></td>
<td>

<p>A function to be used for distance computation in clustering. Default value uses 1 - Pearson's correlation as distance. See <code><a href="stats.html#topic+dist">dist</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_fun.hclust">fun.hclust</code></td>
<td>

<p>A function to be used for agglomeration in clustering. See <code><a href="stats.html#topic+hclust">hclust</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_clust.genes">clust.genes</code></td>
<td>

<p>If not <code>NULL</code>, an object coercible to the <code>dendrogram</code> class (typically the output from <code>hclust()</code>) to use instead of a fresh hierarchical clustering of genes. The <code>FALSE</code> value can also be used to disable computation and/or plotting of the dendrogram.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_clust.samples">clust.samples</code></td>
<td>

<p>If not <code>NULL</code>, an object coercible to the <code>dendrogram</code> class (typically the output from <code>hclust()</code>) to use instead of a fresh hierarchical clustering of samples. The <code>FALSE</code> value can also be used to disable computation and/or plotting of the dendrogram.
</p>
</td></tr>
<tr><td><code id="clusterize_+3A_input">input</code></td>
<td>

<p>See <code><a href="stats.html#topic+hclust">hclust</a></code> and <code><a href="stats.html#topic+dist">dist</a></code> respectively for further details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>clusterize</code> invisibly returns the same list as <code><a href="#topic+heat.map">heat.map</a></code>, plus :
</p>
<table>
<tr><td><code>genes</code></td>
<td>
<p>The gene dendrogram.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>The sample dendrogram.</p>
</td></tr>
</table>
<p>See <code><a href="stats.html#topic+hclust">hclust</a></code> and <code><a href="stats.html#topic+dist">dist</a></code> respectively for the other functions.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heat.map">heat.map</a></code>, <code><a href="stats.html#topic+heatmap">heatmap</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Data with features in columns
  data(rosenwald)
  group &lt;- rosenwald.cli$group
  expr &lt;- t(rosenwald.expr)[,1:100]
  
  # NA imputation (feature's mean to minimize impact)
  f &lt;- function(x) { x[ is.na(x) ] &lt;- round(mean(x, na.rm=TRUE), 3); x }
  expr &lt;- apply(expr, 2, f)
  
  # Simple heat map
  clusterize(expr)
  
  # With annotation (row named data.frame)
  side &lt;- data.frame(group, row.names=rownames(expr))
  clusterize(expr, side=side)
</code></pre>

<hr>
<h2 id='heat'>
Heatmap palette generation
</h2><span id='topic+heat'></span><span id='topic+heat.lin'></span><span id='topic+heat.exp'></span>

<h3>Description</h3>

<p>This function generates a ramp of colors for <code><a href="#topic+heat.map">heat.map</a></code> derivated functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  heat(colors = c("#8888FF", "#000000", "#FF4444"), n = 256, shapeFun = heat.exp, ...)
  heat.exp(n, part, base = 1.015)
  heat.lin(n, part)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heat_+3A_colors">colors</code></td>
<td>

<p>Character vector of length 3, determining starting, middle and final colors.
</p>
</td></tr>
<tr><td><code id="heat_+3A_n">n</code></td>
<td>

<p>Single integer value, amount of colors / values to generate.
</p>
</td></tr>
<tr><td><code id="heat_+3A_shapefun">shapeFun</code></td>
<td>

<p>Function taking at least 2 arguments : <code>n</code> and <code>part</code>. <code><a href="#topic+heat.exp">heat.exp</a></code> and <code><a href="#topic+heat.lin">heat.lin</a></code> are provided as examples.
</p>
</td></tr>
<tr><td><code id="heat_+3A_...">...</code></td>
<td>

<p>Further arguments to <code>heat</code> will be passed to <code>shapeFun</code>.
</p>
</td></tr>
<tr><td><code id="heat_+3A_part">part</code></td>
<td>

<p>Single integer, defined as 1 while generating colors between the first two boundaries, and 2 otherwise.
</p>
</td></tr>
<tr><td><code id="heat_+3A_base">base</code></td>
<td>

<p>Single numeric value, base for exponential slope.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>heat</code> returns a character vector of colors in hexadecimal representation.
</p>
<p><code>heat.lin</code> and <code>heat.expr</code> return <code>n</code> numeric values, defining a curve whose slope will be mimiced during color interpolation.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>
</p>
<p><code><a href="#topic+heat.map">heat.map</a></code>, <code><a href="#topic+clusterize">clusterize</a></code>, <code><a href="#topic+predict.LPS">predict.LPS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Classical heatmap colors
  palette &lt;- heat(c("green", "black", "red"))
  heat.scale(zlim=c(-2,2), col.heatmap=palette)
  
  # Two distinct shapes provided
  heat.scale(zlim=c(-2,2), col.heatmap=heat(shapeFun=heat.lin))
  heat.scale(zlim=c(-2,2), col.heatmap=heat(shapeFun=heat.exp))
</code></pre>

<hr>
<h2 id='heat.map'>
Enhanced heat map ploting
</h2><span id='topic+heat.map'></span>

<h3>Description</h3>

<p>This function draws a heatmap from a matrix, similarly to <code><a href="Matrix.html#topic+image">image</a></code>. It also offers normalization and annotation features, with more control than <code><a href="stats.html#topic+heatmap">heatmap</a></code>.
</p>
<p><code>side</code> can provide multiple sample annotations, and are handled differently depending on their class :
</p>

<dl>
<dt>numeric</dt><dd><p>are attributed grey shades from the minimum to the maximum, which are provided in the legend</p>
</dd>
<dt>factor</dt><dd><p>have their levels attributed colors using a default or custom palette. Hexadecimal color codes starting with <code>#</code> and color names known by R are used &quot;as is&quot;.</p>
</dd>
<dt>character</dt><dd><p>are printed as is in a blank cell. Hexadecimal color codes starting with <code>#</code> and color names known by R are used as background colors instead of text.</p>
</dd>
<dt>logical</dt><dd><p>are ploted in dark (TRUE) or light (FALSE) gray, leaving NAs in white.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>  heat.map(expr, side = NULL, cex.col = NA, cex.row = NA, mai.left = NA,
    mai.bottom = NA, mai.right = 0.1, mai.top = 0.1, side.height = 1, side.col = NULL,
    side.srt = 0, side.cex = 1, col.heatmap = heat(), zlim = "0 centered",
	zlim.trim = 0.02, norm = c("rows", "columns", "none"), norm.robust = FALSE,
	customLayout = FALSE, getLayout = FALSE, font = c(1, 3), xaxt = "s", yaxt = "s")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heat.map_+3A_expr">expr</code></td>
<td>

<p>A numeric matrix, holding features (genes) in columns and observations (samples) in rows. Column and row order will not be altered.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_side">side</code></td>
<td>

<p>An annotation <code>data.frame</code> for <code>expr</code>, or <code>NULL</code>. Must contain at least a row for each <code>expr</code> row, and one or many annotation column. Merging is performed on row names, so rows must be named following the same conventions as <code>expr</code>. Hexadecimal color definitions will be used &quot;as is&quot;, other values will be attributed colors according to <code>side.col</code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_cex.col">cex.col</code></td>
<td>

<p>Single numeric value, character exapansion factor for column names. <code>NA</code> will compute a value from <code>expr</code> size, similarly to <code><a href="stats.html#topic+heatmap">heatmap</a></code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_cex.row">cex.row</code></td>
<td>

<p>Single numeric value, character exapansion factor for row names. <code>NA</code> will compute a value from <code>expr</code> size, similarly to <code><a href="stats.html#topic+heatmap">heatmap</a></code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_mai.left">mai.left</code></td>
<td>

<p>Single numeric value, left margin in inches (for row names). Use <code>NA</code> for an automatic value computed from row name lengths. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_mai.bottom">mai.bottom</code></td>
<td>

<p>Single numeric value, bottom margin in inches (for column names). Use <code>NA</code> for an automatic value computed from column name lengths. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_mai.right">mai.right</code></td>
<td>

<p>Single numeric value, right margin in inches (for higher level functions). See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_mai.top">mai.top</code></td>
<td>

<p>Single numeric value, top margin in inches. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_side.height">side.height</code></td>
<td>

<p>Single numeric value, scaling factor for annotation track.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_side.col">side.col</code></td>
<td>

<p>A function returning as many colors as requested by its sole argument, defining the colors to be used for <code>side</code> legend. Default uses a custom palette for few values, and a derivative of <code><a href="grDevices.html#topic+rainbow">rainbow</a></code> if more than 8 colors are needed.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_side.srt">side.srt</code></td>
<td>

<p>Single numeric value, determining the string rotation angle when writing character side columns (default is 0, horizontal, 90 is suggested for vertical text on busy heat maps).
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_side.cex">side.cex</code></td>
<td>

<p>Single numeric value, the character expansion factor to use for character side columns.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_col.heatmap">col.heatmap</code></td>
<td>

<p>Character vector of colors, to be used for the cells of the heat map.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_zlim">zlim</code></td>
<td>

<p>Numeric vector of length two, defining minimal and maximal <code>expr</code> values that will be mapped to colors in <code>col.heatmap</code>. Values outside of this range will be rounded to the mearest boundary. Two special values are also allowed : &quot;0 centered&quot; to get a symetrical range around 0 (with the default palette, it enforces 0 as the center color), and &quot;range&quot; to get <code>expr</code> range after normalization.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_zlim.trim">zlim.trim</code></td>
<td>

<p>Single numeric value between 0 and 1, defining the proportion of extreme values (equally split on both sides) to remove before computing &quot;0 centered&quot; or &quot;range&quot; <code>zlim</code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_norm">norm</code></td>
<td>

<p>Single character value, normalization to be performed (use &quot;none&quot; to perform no normalization). &quot;rows&quot; will center and scale genes, while &quot;columns&quot; will center and scale samples. The functions used depend on <code>norm.robust</code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_norm.robust">norm.robust</code></td>
<td>

<p>Single logical value, if <code>TRUE</code> <code><a href="stats.html#topic+median">median</a></code> and <code><a href="stats.html#topic+mad">mad</a></code> will be used for centering and scaling, else <code><a href="base.html#topic+mean">mean</a></code> and <code><a href="stats.html#topic+sd">sd</a></code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_customlayout">customLayout</code></td>
<td>

<p>Single logical value, as <code><a href="graphics.html#topic+layout">layout</a></code> does not allow nested calls, set this to TRUE to make your own call to layout and embed this plot in a wider one. See also <code>getLayout</code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_getlayout">getLayout</code></td>
<td>

<p>Single logical value, whether to only return the <code>layout</code> arguments that would be used with the set of arguments provided or not. It can prove useful to build custom layouts, e.g. merging this plot to an other. See also <code>customLayout</code>.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_font">font</code></td>
<td>

<p>Integer vector of length two, the <code>font</code> used to draw X and Y axis labels respectively (see <code><a href="graphics.html#topic+par">par</a></code>). Default is to print X labels (usually samples) in normal font and Y labels (usually genes) in italic font.
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_xaxt">xaxt</code></td>
<td>

<p>Single letter, whether to print column labels (&quot;s&quot;) or not (&quot;n&quot;).
</p>
</td></tr>
<tr><td><code id="heat.map_+3A_yaxt">yaxt</code></td>
<td>

<p>Single letter, whether to print row labels (&quot;s&quot;) or not (&quot;n&quot;).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a named list :
</p>
<table>
<tr><td><code>zlim</code></td>
<td>
<p>Final value of the <code>zlim</code> argument.</p>
</td></tr>
<tr><td><code>col.heatmap</code></td>
<td>
<p>Final value of the <code>col.heatmap</code> argument.</p>
</td></tr>
<tr><td><code>legend</code></td>
<td>
<p>If <code>side</code> is used, a named character vector of colors used for annotation.</p>
</td></tr>
<tr><td><code>cex.col</code></td>
<td>
<p>Final value of the <code>cex.col</code> argument.</p>
</td></tr>
<tr><td><code>cex.row</code></td>
<td>
<p>Final value of the <code>cex.row</code> argument.</p>
</td></tr>
<tr><td><code>mai.left</code></td>
<td>
<p>Final value of the <code>mai.left</code> argument.</p>
</td></tr>
<tr><td><code>mai.bottom</code></td>
<td>
<p>Final value of the <code>mai.bottom</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusterize">clusterize</a></code>, <code><a href="stats.html#topic+heatmap">heatmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Data with features in columns
  data(rosenwald)
  group &lt;- rosenwald.cli$group
  expr &lt;- t(rosenwald.expr)[,1:100]
  
  # NA imputation (feature's mean to minimize impact)
  f &lt;- function(x) { x[ is.na(x) ] &lt;- round(mean(x, na.rm=TRUE), 3); x }
  expr &lt;- apply(expr, 2, f)
  
  # Simple heat map
  heat.map(expr)
  
  # With annotation (row named data.frame)
  side &lt;- data.frame(group, row.names=rownames(expr))
  heat.map(expr, side=side)
</code></pre>

<hr>
<h2 id='heat.scale'>
Plots a heat map color scale, for legend
</h2><span id='topic+heat.scale'></span>

<h3>Description</h3>

<p>This function plots a color scale using a custom color palette, to legend <code><a href="#topic+heat.map">heat.map</a></code> derivated functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  heat.scale(zlim, col.heatmap, at = -10:10, labels = NULL, horiz = TRUE,
    robust = FALSE, customMar = FALSE, title=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heat.scale_+3A_zlim">zlim</code></td>
<td>

<p>Numeric vector of length 2, minimum and maximum of values in the palette. Should correspond to <code>zlim</code> in <code><a href="#topic+heat.map">heat.map</a></code>, consider to use <code><a href="#topic+heat.map">heat.map</a></code> invisible return to get special values.
</p>
</td></tr>
<tr><td><code id="heat.scale_+3A_col.heatmap">col.heatmap</code></td>
<td>

<p>Character vector of colors used in the heat map. Should correspond to <code>col.heatmap</code> in <code><a href="#topic+heat.map">heat.map</a></code>, consider to use <code><a href="#topic+heat.map">heat.map</a></code> invisible return to get special values.
</p>
</td></tr>
<tr><td><code id="heat.scale_+3A_at">at</code></td>
<td>

<p>Numeric vector, values shown in the axis.
</p>
</td></tr>
<tr><td><code id="heat.scale_+3A_labels">labels</code></td>
<td>

<p>Character vector as long as <code>at</code>, defining the values to show at <code>at</code>.
</p>
</td></tr>
<tr><td><code id="heat.scale_+3A_horiz">horiz</code></td>
<td>

<p>Single logical value, whether to plot an horizontal or a vertical scale.
</p>
</td></tr>
<tr><td><code id="heat.scale_+3A_robust">robust</code></td>
<td>

<p>Single logical value, whether to legend <code>median</code> and <code>mad</code> or <code>mean</code> and <code>sd</code>. Should correspond to <code><a href="#topic+heat.map">heat.map</a></code> <code>norm.robust</code> value.
</p>
</td></tr>
<tr><td><code id="heat.scale_+3A_custommar">customMar</code></td>
<td>

<p>Single logical value, whether to skip the call to <code><a href="graphics.html#topic+par">par</a></code> to set <code>mar</code> or not.
</p>
</td></tr>
<tr><td><code id="heat.scale_+3A_title">title</code></td>
<td>

<p>Single character value, the axis title to use (<code>NA</code> for automatic generation).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heat.map">heat.map</a></code>, <code><a href="#topic+clusterize">clusterize</a></code>, <code><a href="#topic+predict.LPS">predict.LPS</a></code>
</p>

<hr>
<h2 id='LPS'>
Linear Predictor Score fitting
</h2><span id='topic+LPS'></span><span id='topic+LPS-class'></span>

<h3>Description</h3>

<p>This function trains a Linear Predictor Score model, given pre-computed coefficients. It uses data with known classes to fit the model.
</p>
<p>It has numerous way to be called, and all the arguments are not mandatory. See the 'Examples' section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LPS(data, coeff, response, k, threshold, formula, method = "fdr", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LPS_+3A_data">data</code></td>
<td>

<p>Continuous data used to retrieve classes, as a <code>data.frame</code> or <code>matrix</code>, with samples in rows and features (genes) in columns. Rows and columns should be named. <strong>Some precautions must be taken concerning data normalization, see the corresponding section below</strong>.
</p>
</td></tr>
<tr><td><code id="LPS_+3A_coeff">coeff</code></td>
<td>

<p>Pre-computed coefficients for the model, as returned by <code><a href="#topic+LPS.coeff">LPS.coeff</a></code> (see there for format details).
</p>
</td></tr>
<tr><td><code id="LPS_+3A_response">response</code></td>
<td>

<p>Already known classes for the samples provided in <code>data</code>, preferably as a two-level <code>factor</code>. Can be missing if a <code>formula</code> with a response element is provided, but this argument precedes.
</p>
</td></tr>
<tr><td><code id="LPS_+3A_k">k</code></td>
<td>

<p>Single <code>integer</code> value, amount of features to include in the model, in decreasing order of coefficient. Can be missing if <code>threshold</code> or <code>formula</code> are provided, but this argument precedes other both of them.
</p>
</td></tr>
<tr><td><code id="LPS_+3A_threshold">threshold</code></td>
<td>

<p>Single <code>numeric</code> value, p-value threshold to apply for feature selection. Can be missing if <code>k</code> or <code>formula</code> are provided, but <code>k</code> precedes on it and it precedes on <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="LPS_+3A_formula">formula</code></td>
<td>

<p>A <code>formula</code> object, describing the model to fit (several templates are handled, see 'Examples'). The formula response element (before the &quot;~&quot; sign) can replace the <code>response</code> argument if it is not provided. The variables (after the &quot;~&quot; sign) can be a single integer (standing for the <code>k</code> argument), a single numeric (standing for the <code>threshold</code> argument) or a sum of feature names to use directly. &quot;.&quot; is also handled in the usual way (all <code>data</code> columns), and &quot;1&quot; is a more efficient way to refer to all numeric columns of <code>data</code>.
</p>
</td></tr>
<tr><td><code id="LPS_+3A_method">method</code></td>
<td>

<p>Single character value, to be passed to <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> when <code>threshold</code> is provided.
</p>
</td></tr>
<tr><td><code id="LPS_+3A_...">...</code></td>
<td>

<p>Further arguments are passed to <code><a href="stats.html#topic+model.frame">model.frame</a></code> if <code>response</code> is missing (thus defined via <code>formula</code>). <code>subset</code> and <code>na.action</code> may be particularly useful for cross-validation schemes, see <code><a href="stats.html#topic+model.frame.default">model.frame.default</a></code> for details. <code>subset</code> is always handled but masked in &quot;...&quot; for compatibility reasons.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of (S3) class &quot;LPS&quot; :
</p>
<table>
<tr><td><code>coeff</code></td>
<td>
<p>Named numeric vector, the coefficients used in the model.</p>
</td></tr>
<tr><td><code>classes</code></td>
<td>
<p>Character vector, the labels of the two groups to be predicted.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>List of two numeric vectors, training dataset scores sorted by group.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>Numeric vector, score means of each group in the training dataset.</p>
</td></tr>
<tr><td><code>sds</code></td>
<td>
<p>Numeric vector, score <code><a href="stats.html#topic+sd">sd</a></code> of each group in the training dataset.</p>
</td></tr>
<tr><td><code>ovl</code></td>
<td>
<p>Numeric value, overlapping coefficient as returned by <code><a href="#topic+OVL">OVL</a></code>.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Integer value, amount of features selected in the model (if relevant).</p>
</td></tr>
<tr><td><code>p.threshold</code></td>
<td>
<p>Numeric value, threshold used for feature selection (if relevant).</p>
</td></tr>
<tr><td><code>p.method</code></td>
<td>
<p>Character value, p-value correction used for feature selection (if relevant).</p>
</td></tr>
</table>


<h3>Normalization</h3>

<p>As expression values are directly used in the score, gene centering and scaling are strongly recommended. For Affymetrix raw expression values (strictly positive, linear and absolute), Wright et al. suggests a multiplicative centering on a median of 1000 followed by a log2 transformation. For log-ratio, gene centering and scaling should not be necessary, as they are naturally 0-centered.
</p>


<h3>Time efficiency</h3>

<p>Using a numeric matrix as <code>data</code> and a factor as <code>response</code> is the fastest way to compute coefficients, if time consumption matters (as in cross-validation schemes). <code>formula</code> is there only for consistency with R modeling functions, and to provide <code>response</code>, <code>k</code> or <code>threshold</code> in a single way.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>References</h3>

<p>Radmacher MD, McShane LM, Simon R. <cite>A paradigm for class prediction using gene expression profiles.</cite> J Comput Biol. 2002;9(3):505-11.
</p>
<p>Wright G, Tan B, Rosenwald A, Hurt EH, Wiestner A, Staudt LM. <cite>A gene expression-based method to diagnose clinically distinct subgroups of diffuse large B cell lymphoma.</cite> Proc Natl Acad Sci U S A. 2003 Aug 19;100(17):9991-6.
</p>
<p>Bohers E, Mareschal S, Bouzelfen A, Marchand V, Ruminy P, Maingonnat C, Menard AL, Etancelin P, Bertrand P, Dubois S, Alcantara M, Bastard C, Tilly H, Jardin F. <cite>Targetable activating mutations are very frequent in GCB and ABC diffuse large B-cell lymphoma.</cite> Genes Chromosomes Cancer. 2014 Feb;53(2):144-53.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LPS.coeff">LPS.coeff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Data with features in columns
  data(rosenwald)
  group &lt;- rosenwald.cli$group
  expr &lt;- t(rosenwald.expr)
  
  # NA imputation (feature's mean to minimize impact)
  f &lt;- function(x) { x[ is.na(x) ] &lt;- round(mean(x, na.rm=TRUE), 3); x }
  expr &lt;- apply(expr, 2, f)
  
  # Coefficients
  coeff &lt;- LPS.coeff(data=expr, response=group)
  
  
  # 10 best features (straightforward)
  m &lt;- LPS(data=expr, coeff=coeff, response=group, k=10)
  
  # 10 best features (formula)
  ### 'k' MUST be an integer, or will be understood as a 'threshold'
  ### Numbers are "numeric", enforce integer with "L" or "as.integer"
  m &lt;- LPS(data=as.data.frame(expr), coeff=coeff, formula=group~10L)
  k &lt;- as.integer(10)
  m &lt;- LPS(data=as.data.frame(expr), coeff=coeff, formula=group~k)
  
  # FDR threshold
  thr &lt;- 0.01
  m &lt;- LPS(data=expr, coeff=coeff, response=group, threshold=thr)
  m &lt;- LPS(data=as.data.frame(expr), coeff=coeff, formula=group~0.01)
  m &lt;- LPS(data=as.data.frame(expr), coeff=coeff, formula=group~thr)
  
  # Custom model
  m &lt;- LPS(data=expr, coeff=coeff[ c("27481","17013") ,], response=group, k=2)
  m &lt;- LPS(data=as.data.frame(expr), coeff=coeff, formula=group~`27481`+`17013`)
  ### Notice backticks in formula for syntactically invalid names
  
  # Complete model
  m &lt;- LPS(data=expr, coeff=coeff, response=group, k=ncol(expr))
  m &lt;- LPS(data=expr, coeff=coeff, response=group, threshold=1)
  ### m &lt;- LPS(data=as.data.frame(expr), coeff=coeff, formula=group~.)
  ### The last is correct but (really) slow on large datasets
</code></pre>

<hr>
<h2 id='LPS.coeff'>
Linear Predictor Score coefficient computation
</h2><span id='topic+LPS.coeff'></span>

<h3>Description</h3>

<p>As Linear Predictor Score coefficients are genuinely t statistics, this function provides a faster implementation for large datasets than using <code><a href="stats.html#topic+t.test">t.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LPS.coeff(data, response, formula = ~1, type = c("t", "limma"),
    p.value = TRUE, log = FALSE, weighted = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LPS.coeff_+3A_data">data</code></td>
<td>

<p>Continuous data used to retrieve classes, as a <code>data.frame</code> or <code>matrix</code>, with samples in rows and features (genes) in columns. Rows and columns should be named. <code>NA</code> values are silently ignored. <strong>Some precautions must be taken concerning data normalization, see the corresponding section in <code><a href="#topic+LPS">LPS</a></code> manual page</strong>.
</p>
</td></tr>
<tr><td><code id="LPS.coeff_+3A_response">response</code></td>
<td>

<p>Already known classes for the samples provided in <code>data</code>, preferably as a two-level <code>factor</code>. Can be missing if a <code>formula</code> with a response element is provided, but this argument precedes.
</p>
</td></tr>
<tr><td><code id="LPS.coeff_+3A_formula">formula</code></td>
<td>

<p>A <code>formula</code> object, describing the features to consider in <code>data</code>. The formula response element (before the &quot;~&quot; sign) can replace the <code>response</code> argument if it is not provided. The features can be enumerated in the variable section of the formula (after the &quot;~&quot; sign). &quot;.&quot; is also handled in the usual way (all <code>data</code> columns), and &quot;1&quot; is a more efficient way to refer to all numeric columns of <code>data</code>.
</p>
</td></tr>
<tr><td><code id="LPS.coeff_+3A_type">type</code></td>
<td>

<p>Single character value, &quot;t&quot; to compute genuine t statistics (unequal variances and unpaired samples) or &quot;limma&quot; to use the lmFit() and eBayes() t statistics from this microarray oriented Bioconductor package.
</p>
</td></tr>
<tr><td><code id="LPS.coeff_+3A_p.value">p.value</code></td>
<td>

<p>Single logical value, whether to compute (two-sided) p-values or not.
</p>
</td></tr>
<tr><td><code id="LPS.coeff_+3A_log">log</code></td>
<td>

<p>Single logical value, whether to log-transform t or not (sign will be preserved). Original description of the LPS does not include log-transformation, but it may be useful to not over-weight discriminant genes in large series. Values between -1 and 1 are transformed to 0 to avoid sign shifting, as it generally comes with non significant p-values.
</p>
</td></tr>
<tr><td><code id="LPS.coeff_+3A_weighted">weighted</code></td>
<td>

<p>Single logical value, whether to divide t (or log-transformed t) by gene mean or not. We recommend to normalize data only by samples and use <code>weighted = TRUE</code> to include gene centering in the model, rather than centering and scaling genes by normalizing independantly each series as Wright et al. did.
</p>
</td></tr>
<tr><td><code id="LPS.coeff_+3A_...">...</code></td>
<td>

<p>Further arguments are passed to <code><a href="stats.html#topic+model.frame">model.frame</a></code> if <code>response</code> is missing (thus defined via <code>formula</code>). <code>subset</code> and <code>na.action</code> may be particularly useful for cross-validation schemes, see <code><a href="stats.html#topic+model.frame.default">model.frame.default</a></code> for details. <code>subset</code> is always handled but masked in &quot;...&quot; for compatibility reasons.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns a row named numeric matrix, with a &quot;t&quot; column holding statistics computed. If <code>p.value</code> is TRUE, a second &quot;p.value&quot; column is added.
</p>


<h3>Note</h3>

<p>Using a numeric matrix as <code>data</code> and a factor as <code>response</code> is the fastest way to compute coefficients, if time consumption matters (as in cross-validation schemes). <code>formula</code> was added only for consistency with other R modeling functions, and eventually to subset features to compute coefficients for.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>References</h3>

<p><a href="http://www.bioconductor.org/packages/release/bioc/html/limma.html">http://www.bioconductor.org/packages/release/bioc/html/limma.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LPS">LPS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Data with features in columns
  data(rosenwald)
  group &lt;- rosenwald.cli$group
  expr &lt;- t(rosenwald.expr)
  
  
  # All features, all samples
  k &lt;- LPS.coeff(data=expr, response=group)
  k &lt;- LPS.coeff(formula=group~1, data=as.data.frame(expr))
  ### LPS.coeff(formula=group~., data=as.data.frame(expr), na.action=na.pass)
  ### The last is correct but (really) slow on large datasets
  
  # Feature subset, all samples
  k &lt;- LPS.coeff(data=expr[, c("27481","17013") ], response=group)
  k &lt;- LPS.coeff(formula=group~`27481`+`17013`, data=as.data.frame(expr))
  ### Notice backticks in formula for syntactically invalid names
  
  # All features, sample subset
  training &lt;- rosenwald.cli$set == "Training"
  ### training &lt;- sample.int(nrow(expr), 10)
  ### training &lt;- which(rosenwald.cli$set == "Training")
  ### training &lt;- rownames(subset(rosenwald.cli, set == "Training"))
  k &lt;- LPS.coeff(data=expr, response=group, subset=training)
  k &lt;- LPS.coeff(formula=group~1, data=as.data.frame(expr), subset=training)

  # NA handling by model.frame()
  k &lt;- LPS.coeff(formula=group~1, data=as.data.frame(expr), na.action=na.omit)
</code></pre>

<hr>
<h2 id='OVL'>
Overlap quantification for LPS object
</h2><span id='topic+OVL'></span>

<h3>Description</h3>

<p>Quantify the overlap between gaussian distributions of the two group scores, to assess model efficiency (best models should not overlap, to prevent from false discovery).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  OVL(means, sds, cutoff=1e-4, n=1e4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OVL_+3A_means">means</code></td>
<td>

<p>Numeric vector of two values, the means of the gaussian distributions.
</p>
</td></tr>
<tr><td><code id="OVL_+3A_sds">sds</code></td>
<td>

<p>Numeric vector of two values, the standard deviations of the gaussian distributions.
</p>
</td></tr>
<tr><td><code id="OVL_+3A_cutoff">cutoff</code></td>
<td>

<p>Single numeric value, minimal quantile for integration range definition (distributions will be considered between their <code>cutoff</code> and <code>1 - cutoff</code> quantiles only). The lesser it is, the more precise the returned value will be.
</p>
</td></tr>
<tr><td><code id="OVL_+3A_n">n</code></td>
<td>

<p>Single integer value, the amount of equi-distant points to use for the computation. The greater it is, the more precise the returned value will be.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the proportion of the overlap between the two gaussian distributions N1 and N2, i.e. <code>min(N1, N2) / (N1 + N2)</code>.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LPS-class">LPS-class</a></code>, <code><a href="#topic+LPS">LPS</a></code>, <code>link{dnorm}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Full overlap between identical distributions
  OVL(c(0,0), c(1,1))
  
  # Increasing shift
  OVL(c(0,1), c(1,1))
  OVL(c(0,2), c(1,1))
  OVL(c(0,3), c(1,1))
  OVL(c(0,10), c(1,1))
</code></pre>

<hr>
<h2 id='plot.LPS'>
Plot method for LPS objects
</h2><span id='topic+plot.LPS'></span>

<h3>Description</h3>

<p>This function plots the distributions of the LPS scores in each group for a fitted <code><a href="#topic+LPS">LPS</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'LPS'
plot(x, y, method=c("Wright", "Radmacher", "exact"), threshold = 0.9,
    values = FALSE, col.classes = c("#FFCC00", "#1144CC"), xlim, yaxt = "s",
    xlab = "LPS", ylab, las = 0, lwd = 2,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.LPS_+3A_x">x</code></td>
<td>

<p>An object of class <code>"LPS"</code>, as returned by <code><a href="#topic+LPS">LPS</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_y">y</code></td>
<td>

<p>Single character value defining y axis : &quot;density&quot; or (bayesian) &quot;probability&quot;.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_method">method</code></td>
<td>

<p>Single character value, the method to use for predictions. See <code><a href="#topic+predict.LPS">predict.LPS</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_threshold">threshold</code></td>
<td>

<p>Single numeric value, the confidence threshold to use for the &quot;gray zone&quot; (scores for which none of the two groups can be assigned with a probability greater than this threshold). See <code><a href="#topic+predict.LPS">predict.LPS</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_values">values</code></td>
<td>

<p>Single logical value, whether to plot individual scores from the training series or not.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_col.classes">col.classes</code></td>
<td>

<p>Character vector of two values giving to each class a distinct color.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_xlim">xlim</code></td>
<td>

<p>To be passed to <code><a href="graphics.html#topic+plot">plot</a></code>, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_yaxt">yaxt</code></td>
<td>

<p>To be passed to <code><a href="graphics.html#topic+plot">plot</a></code>, see <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_xlab">xlab</code></td>
<td>

<p>To be passed to <code><a href="graphics.html#topic+plot">plot</a></code>, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_ylab">ylab</code></td>
<td>

<p>To be passed to <code><a href="graphics.html#topic+plot">plot</a></code>, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_las">las</code></td>
<td>

<p>To be passed to <code><a href="graphics.html#topic+plot">plot</a></code>, see <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_lwd">lwd</code></td>
<td>

<p>To be passed to <code><a href="graphics.html#topic+plot">plot</a></code>, see <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.LPS_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code> or <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LPS">LPS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Data with features in columns
  data(rosenwald)
  group &lt;- rosenwald.cli$group
  expr &lt;- t(rosenwald.expr)
  
  # NA imputation (feature's mean to minimize impact)
  f &lt;- function(x) { x[ is.na(x) ] &lt;- round(mean(x, na.rm=TRUE), 3); x }
  expr &lt;- apply(expr, 2, f)
  
  # Coefficients
  coeff &lt;- LPS.coeff(data=expr, response=group)
  
  # 10 best features model
  m &lt;- LPS(data=expr, coeff=coeff, response=group, k=10)
  
  
  # Distributions of scores in each group
  plot(m, "density")
  
  # Probability for each group along the score axis
  plot(m, "probability", yaxt="s")
</code></pre>

<hr>
<h2 id='predict.LPS'>
Predict method for LPS objects
</h2><span id='topic+predict.LPS'></span>

<h3>Description</h3>

<p>This function allow predictions to be made from a fitted <code><a href="#topic+LPS">LPS</a></code> model and a new dataset.
</p>
<p>It can also plot a gene expression heatmap to visualize results of the prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'LPS'
predict(object, newdata, type=c("class", "probability", "score"),
    method = c("Wright", "Radmacher", "exact"), threshold = 0.9, na.rm = TRUE,
    subset = NULL, col.lines = "#FFFFFF", col.classes = c("#FFCC00", "#1144CC"),
    plot = FALSE, side = NULL, cex.col = NA, cex.row = NA, mai.left = NA,
    mai.bottom = NA, mai.right = 1, mai.top = 0.1, side.height = 1, side.col = NULL,
    col.heatmap = heat(), zlim = "0 centered", norm = c("rows", "columns", "none"),
    norm.robust = FALSE, customLayout = FALSE, getLayout = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.LPS_+3A_object">object</code></td>
<td>

<p>An object of class <code>"LPS"</code>, as returned by <code><a href="#topic+LPS">LPS</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_newdata">newdata</code></td>
<td>

<p>Continuous data used to retrieve classes, as a <code>data.frame</code> or <code>matrix</code>, with samples in rows and features (genes) in columns. Rows and columns should be named. It can also be a named numeric vector of already computed scores. <strong>Some precautions must be taken concerning data normalization, see the corresponding section in <code><a href="#topic+LPS">LPS</a></code> manual page</strong>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_type">type</code></td>
<td>

<p>Single character value, return type of the predictions to be made (&quot;class&quot;, &quot;probability&quot; or &quot;score&quot;). See 'Value' section.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_method">method</code></td>
<td>

<p>Single character value, the method to use to make predictions (&quot;Wright&quot;, &quot;Radmacher&quot; or &quot;exact&quot;). See 'Details' section.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_threshold">threshold</code></td>
<td>

<p>Threshold to use for class prediction. &quot;Wright&quot; method was designed with 0.9, &quot;Radmacher&quot; method makes no use of the threshold.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_na.rm">na.rm</code></td>
<td>

<p>Single logical value, if TRUE samples with one or many <code>NA</code> features will be scored too (concerned feature is removed for the concerned sample, which might be discutable).
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_subset">subset</code></td>
<td>

<p>A subsetting vector to apply on <code>newdata</code> rows. See <code><a href="Matrix.html#topic++5B">[</a></code> for handled values.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_col.lines">col.lines</code></td>
<td>

<p>If <code>graph</code> is TRUE, a single character value to be used for line drawing on the heatmap.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_col.classes">col.classes</code></td>
<td>

<p>If <code>graph</code> is TRUE, a character vector of two values giving to each class a distinct color.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_plot">plot</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_side">side</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_cex.col">cex.col</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_cex.row">cex.row</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_mai.left">mai.left</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_mai.bottom">mai.bottom</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_mai.right">mai.right</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code> (used to plot score coefficients).
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_mai.top">mai.top</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_side.height">side.height</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_side.col">side.col</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_col.heatmap">col.heatmap</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_zlim">zlim</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_norm">norm</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_norm.robust">norm.robust</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_customlayout">customLayout</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_getlayout">getLayout</code></td>
<td>

<p>To be passed to <code><a href="#topic+heat.map">heat.map</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.LPS_+3A_...">...</code></td>
<td>

<p>Ignored, just there to match the <code><a href="stats.html#topic+predict">predict</a></code> generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;Compound covariate predictor&quot; from Radmacher et al. (<code>method</code> = &quot;Radmacher&quot;) simply assign each sample to the closest group (comparing the sample score to the mean scores of each group in the training dataset).
</p>
<p>The &quot;Linear Predictor Score&quot; from Wright et al. (<code>method</code> = &quot;Wright&quot;) modelizes scores in each training sub-group with a distinct gaussian distribution, and computes the probability for a sample to be in one of them or the other using a bayesian rule.
</p>
<p>The &quot;exact&quot; mode is still under development and should not be used.
</p>


<h3>Value</h3>

<p>For a &quot;class&quot; <code>type</code>, returns a character vector with group assignment for each new sample (possibly <code>NA</code>), named according to <code>data</code> row names.
</p>
<p>For a &quot;probability&quot; <code>type</code>, returns a numeric matrix with two columns (probabilities to be in each group) and a row for each new sample, row named according to <code>data</code> row names and column named according to the group labels.
</p>
<p>For a &quot;score&quot; <code>type</code>, returns a numeric vector with LPS score for each new sample, named according to <code>data</code> row names. Notice the score is the same for all <code>method</code>s.
</p>
<p>If <code>plot</code> is <code>TRUE</code>, returns the list returned by <code><a href="#topic+heat.map">heat.map</a></code>, with data described above in the first unammed element.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>References</h3>

<p>Radmacher MD, McShane LM, Simon R. <cite>A paradigm for class prediction using gene expression profiles.</cite> J Comput Biol. 2002;9(3):505-11.
</p>
<p>Wright G, Tan B, Rosenwald A, Hurt EH, Wiestner A, Staudt LM. <cite>A gene expression-based method to diagnose clinically distinct subgroups of diffuse large B cell lymphoma.</cite> Proc Natl Acad Sci U S A. 2003 Aug 19;100(17):9991-6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LPS">LPS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Data with features in columns
  data(rosenwald)
  group &lt;- rosenwald.cli$group
  expr &lt;- t(rosenwald.expr)
  
  # NA imputation (feature's mean to minimize impact)
  f &lt;- function(x) { x[ is.na(x) ] &lt;- round(mean(x, na.rm=TRUE), 3); x }
  expr &lt;- apply(expr, 2, f)
  
  # Coefficients
  coeff &lt;- LPS.coeff(data=expr, response=group)
  
  # 10 best features model
  m &lt;- LPS(data=expr, coeff=coeff, response=group, k=10)
  
  
  # Class prediction plot
  predict(m, expr, plot=TRUE)
  
  # Wright et al. class prediction
  table(
    group,
    prediction = predict(m, expr),
    exclude = NULL
  )
  
  # More stringent threshold
  table(
    group,
    prediction = predict(m, expr, threshold=0.99),
    exclude = NULL
  )
  
  # Radmacher et al. class prediction
  table(
    group,
    prediction = predict(m, expr, method="Radmacher"),
    exclude = NULL
  )
  
  # Probabilities
  predict(m, expr, type="probability", method="Wright")
  predict(m, expr, type="probability", method="Radmacher")
  predict(m, expr, type="probability", method="exact")
  
  # Probability plot
  predict(m, expr, type="probability", plot=TRUE)
  
  # Annotated probability plot
  side &lt;- data.frame(group, row.names=rownames(expr))
  predict(m, expr, side=side, type="probability", plot=TRUE)
  
  # Score plot
  predict(m, expr, type="score", plot=TRUE)
</code></pre>

<hr>
<h2 id='Rosenwald+20dataset'>
Rosenwald et al. Lymphochip data
</h2><span id='topic+rosenwald'></span><span id='topic+rosenwald.expr'></span><span id='topic+rosenwald.cli'></span>

<h3>Description</h3>

<p>This dataset contains 60 Diffuse Large B-Cell Lymphomas analysed on Lymphochip microarrays, as published by Rosenwald et al. The &quot;Germinal Center B-cell like&quot; and &quot;Activated B-Cell like&quot; subtypes, as determined by hierarchical clustering, were predicted by a LPS approach in Wright et al.
</p>
<p>To minimize package size, values were rounded at 3 decimals and only 60 DLBCL from the 240 series were randomly selected (40 from the &quot;Training&quot; set, 20 from the &quot;Validation&quot; set), excluding &quot;Type III&quot; sub-types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rosenwald)</code></pre>


<h3>Format</h3>

<p><code>rosenwald.expr</code> is a numeric matrix of expression values, with probes in rows and samples in columns. Both dimensions are named, probes by there &quot;UNIQID&quot; and samples by there &quot;LYM numbers&quot;. Many <code>NA</code> values are present.
</p>
<p><code>rosenwald.cli</code> is a data.frame with a row for each sample, and 4 <code>factor</code> columns described below. Rows are named by samples &quot;LYM numbers&quot;, in the same order than <code>rosenwald.expr</code>.
</p>

<dl>
<dt>set</dt><dd><p>the &quot;Training&quot; or &quot;Validation&quot; set the sample comes from.</p>
</dd>
<dt>group</dt><dd><p>the DLBCL sub-type that is to be predicted (&quot;GCB&quot; or &quot;ABC&quot;).</p>
</dd>
<dt>follow.up</dt><dd><p>follow-up of the patient, in years.</p>
</dd>
<dt>status</dt><dd><p>status of the patient at the end of the follow-up (&quot;Dead&quot; or &quot;Alive&quot;).</p>
</dd>
</dl>
  


<h3>Source</h3>

<p><a href="http://llmpp.nih.gov/DLBCL/">http://llmpp.nih.gov/DLBCL/</a>
</p>


<h3>References</h3>

<p>Rosenwald A et al. <cite>The use of molecular profiling to predict survival after chemotherapy for diffuse large-B-cell lymphoma.</cite> N Engl J Med. 2002 Jun 20;346(25):1937-47.
</p>
<p>Wright G et al. <cite>A gene expression-based method to diagnose clinically distinct subgroups of diffuse large B cell lymphoma.</cite> Proc Natl Acad Sci U S A. 2003 Aug 19;100(17):9991-6.
</p>

<hr>
<h2 id='surv.colors'>
Produces visual representation of survival data
</h2><span id='topic+surv.colors'></span>

<h3>Description</h3>

<p>This function generates color shades for each individual, according to their respective right-censored survival data (event occurred or not, after which follow-up time). This can prove useful to annotate heat maps with survival data.
</p>
<p>Two color scales are used, one for right-censored individuals (lost of sight before the event occurs, yellow with default colors) and an other for individual with observed events (death, relapse ... black in default colors). Shades are generated according to their impact : fast events and long follow-ups without event have strong colors, while late events and short follow-up without event are light-colored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  surv.colors(time, event, eventColors = c("#000000", "#CCCCCC"),
    censColors = c("#FFFFEE", "#FFDD00"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.colors_+3A_time">time</code></td>
<td>

<p>Numeric vector, the follow-up times of each individual (see <code><a href="survival.html#topic+Surv">Surv</a></code> in the <code>survival</code> package).
</p>
</td></tr>
<tr><td><code id="surv.colors_+3A_event">event</code></td>
<td>

<p>Logical vector, whether an event (death, relapse ...) occured at the end of each individual follow-up or not (see <code><a href="survival.html#topic+Surv">Surv</a></code> in the <code>survival</code> package).
</p>
</td></tr>
<tr><td><code id="surv.colors_+3A_eventcolors">eventColors</code></td>
<td>

<p>Character vector of length 2, the boundaries of the color scale to generate for individuals with events.
</p>
</td></tr>
<tr><td><code id="surv.colors_+3A_censcolors">censColors</code></td>
<td>

<p>Character vector of length 2, the boundaries of the color scale to generate for right-censored individuals.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector, named according to <code>time</code> names.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surv.scale">surv.scale</a></code>, <code><a href="#topic+heat.map">heat.map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Rosenwald's dataset (hand-picked prognostic probes)
  data(rosenwald)
  probes &lt;- c("30580", "16006", "32315", "16978", "26588")
  expr &lt;- t(rosenwald.expr[ probes ,])
  
  # NA imputation (feature's mean to minimize impact)
  f &lt;- function(x) { x[ is.na(x) ] &lt;- round(mean(x, na.rm=TRUE), 3); x }
  expr &lt;- apply(expr, 2, f)
  
  # Survival colors
  surv &lt;- with(rosenwald.cli, surv.colors(time=follow.up, event=status=="Dead"))
  
  # Color scale legend
  with(rosenwald.cli, surv.scale(time=follow.up, event=status=="Dead"))
  
  # Annotated clustering
  side &lt;- data.frame(OS=surv, row.names=rownames(rosenwald.cli))
  clusterize(expr, side=side)
</code></pre>

<hr>
<h2 id='surv.scale'>
Plots a survival color scale, for legend
</h2><span id='topic+surv.scale'></span>

<h3>Description</h3>

<p>This function plots a color scale using a custom color palette, to legend <code><a href="#topic+surv.colors">surv.colors</a></code> annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  surv.scale(time, event, eventColors = c("#000000", "#CCCCCC"),
    censColors = c("#FFFFEE", "#FFDD00"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.scale_+3A_time">time</code></td>
<td>

<p>Numeric vector, the follow-up times of each individual (see <code><a href="survival.html#topic+Surv">Surv</a></code> in the <code>survival</code> package).
</p>
</td></tr>
<tr><td><code id="surv.scale_+3A_event">event</code></td>
<td>

<p>Logical vector, whether an event (death, relapse ...) occured at the end of each individual follow-up or not (see <code><a href="survival.html#topic+Surv">Surv</a></code> in the <code>survival</code> package).
</p>
</td></tr>
<tr><td><code id="surv.scale_+3A_eventcolors">eventColors</code></td>
<td>

<p>Character vector of length 2, the boundaries of the color scale to generate for individuals with events.
</p>
</td></tr>
<tr><td><code id="surv.scale_+3A_censcolors">censColors</code></td>
<td>

<p>Character vector of length 2, the boundaries of the color scale to generate for right-censored individuals.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surv.colors">surv.colors</a></code>, survival::<code><a href="survival.html#topic+Surv">Surv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Rosenwald's dataset (hand-picked prognostic probes)
  data(rosenwald)
  probes &lt;- c("30580", "16006", "32315", "16978", "26588")
  expr &lt;- t(rosenwald.expr[ probes ,])
  
  # NA imputation (feature's mean to minimize impact)
  f &lt;- function(x) { x[ is.na(x) ] &lt;- round(mean(x, na.rm=TRUE), 3); x }
  expr &lt;- apply(expr, 2, f)
  
  # Survival colors
  surv &lt;- with(rosenwald.cli, surv.colors(time=follow.up, event=status=="Dead"))
  
  # Annotated clustering
  side &lt;- data.frame(OS=surv, row.names=rownames(rosenwald.cli))
  clusterize(expr, side=side)
  
  # Color scale legend
  with(rosenwald.cli, surv.scale(time=follow.up, event=status=="Dead"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
