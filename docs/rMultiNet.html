<!DOCTYPE html><html lang="en"><head><title>Help for package rMultiNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rMultiNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Community_cluster_dbscan'><p>Title</p></a></li>
<li><a href='#Community_cluster_km'><p>Title</p></a></li>
<li><a href='#Embedding_network'><p>Title</p></a></li>
<li><a href='#GenerateMMLSM'><p>Title</p></a></li>
<li><a href='#GenerateMMSBM'><p>Title</p></a></li>
<li><a href='#InitializationLSM'><p>Title</p></a></li>
<li><a href='#InitializationMMSBM'><p>Title  A function for initialization</p></a></li>
<li><a href='#PowerIteration'><p>Title</p></a></li>
<li><a href='#ProjectedGD'><p>Title</p></a></li>
<li><a href='#SpecClustering'><p>Title</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Multi-Layer Networks Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides two general frameworks to generate a multi-layer network. This also provides several methods to reveal the embedding of both nodes and layers. The reference paper can be found from the URL mentioned below. Ting Li, Zhongyuan Lyu, Chenyu Ren, Dong Xia (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2302.04437">doi:10.48550/arXiv.2302.04437</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dbscan, geigen, glmnet, graphics, Matrix, plotly, rTensor,
stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-26 02:31:21 UTC; Ren Chenyu</td>
</tr>
<tr>
<td>Author:</td>
<td>Chenyu Ren <a href="https://orcid.org/0000-0001-5422-7903"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chenyu Ren &lt;chenyu.ren@connect.polyu.hk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-27 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Community_cluster_dbscan'>Title</h2><span id='topic+Community_cluster_dbscan'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Community_cluster_dbscan(embedding, type, eps_value = 0.05, pts_value = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Community_cluster_dbscan_+3A_embedding">embedding</code></td>
<td>
<p>the embedding results from different methods</p>
</td></tr>
<tr><td><code id="Community_cluster_dbscan_+3A_type">type</code></td>
<td>
<p>node embedding ‘n’ or network embedding ‘N’</p>
</td></tr>
<tr><td><code id="Community_cluster_dbscan_+3A_eps_value">eps_value</code></td>
<td>
<p>parameters for DBSCAN</p>
</td></tr>
<tr><td><code id="Community_cluster_dbscan_+3A_pts_value">pts_value</code></td>
<td>
<p>parameters for DBSCAN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the embedding results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tnsr = GenerateMMSBM(200, 3, 10, 2, d = NULL, r = NULL)
U_list = InitializationMMSBM(tnsr, 3, 2, rank = NULL)
embed_list = PowerIteration(tnsr,3,2,rank=NULL,type="TUCKER",U_0_list=U_list)
em = embed_list[[2]]
Community_cluster_dbscan(em,"N")
</code></pre>

<hr>
<h2 id='Community_cluster_km'>Title</h2><span id='topic+Community_cluster_km'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Community_cluster_km(embedding, type, cluster_number)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Community_cluster_km_+3A_embedding">embedding</code></td>
<td>
<p>the embedding results from different methods</p>
</td></tr>
<tr><td><code id="Community_cluster_km_+3A_type">type</code></td>
<td>
<p>node embedding ‘n’ or network embedding ‘N’</p>
</td></tr>
<tr><td><code id="Community_cluster_km_+3A_cluster_number">cluster_number</code></td>
<td>
<p>the number of clusters for Kmeans</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the embedding results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tnsr = GenerateMMSBM(200, 3, 10, 2, d = NULL, r = NULL)
U_list = InitializationMMSBM(tnsr, 3, 2, rank = NULL)
embed_list = PowerIteration(tnsr,3,2,rank=NULL,type="TUCKER",U_0_list=U_list)
em = embed_list[[2]]
Community_cluster_km(em,"N",5)
</code></pre>

<hr>
<h2 id='Embedding_network'>Title</h2><span id='topic+Embedding_network'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Embedding_network(network_membership, L, paxis = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Embedding_network_+3A_network_membership">network_membership</code></td>
<td>
<p>the number of types of the network or the number of groups of vertices</p>
</td></tr>
<tr><td><code id="Embedding_network_+3A_l">L</code></td>
<td>
<p>the number of layers</p>
</td></tr>
<tr><td><code id="Embedding_network_+3A_paxis">paxis</code></td>
<td>
<p>the number of eigenvectors to use in the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot table If the number of eigenvectors is more than two or plot the image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tnsr = GenerateMMSBM(200, 3, 10, 2, d = NULL, r = NULL)
U_list = InitializationMMSBM(tnsr, 3, 2, rank = NULL)
embed_list = PowerIteration(tnsr,3,2,rank=NULL,type="TUCKER",U_0_list=U_list)
Embedding_network(embed_list[[2]],10,2)
</code></pre>

<hr>
<h2 id='GenerateMMLSM'>Title</h2><span id='topic+GenerateMMLSM'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateMMLSM(
  n,
  m,
  L,
  rank,
  U_mean = 0.5,
  cmax = 1,
  d,
  int_type = "Uniform",
  kernel_fun = "logit",
  scale_par = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateMMLSM_+3A_n">n</code></td>
<td>
<p>the number of vertices</p>
</td></tr>
<tr><td><code id="GenerateMMLSM_+3A_m">m</code></td>
<td>
<p>the number of types of the network</p>
</td></tr>
<tr><td><code id="GenerateMMLSM_+3A_l">L</code></td>
<td>
<p>the number of layers</p>
</td></tr>
<tr><td><code id="GenerateMMLSM_+3A_rank">rank</code></td>
<td>
<p>the rank of latent position matrix U</p>
</td></tr>
<tr><td><code id="GenerateMMLSM_+3A_u_mean">U_mean</code></td>
<td>
<p>the mean of the normal distribution of each entry of U</p>
</td></tr>
<tr><td><code id="GenerateMMLSM_+3A_cmax">cmax</code></td>
<td>
<p>the entrywise upper bound of core tensor C</p>
</td></tr>
<tr><td><code id="GenerateMMLSM_+3A_d">d</code></td>
<td>
<p>the average degree of the network</p>
</td></tr>
<tr><td><code id="GenerateMMLSM_+3A_int_type">int_type</code></td>
<td>
<p>represents the ways of generating tensor C (‘Uniform’ or ‘Norm’)</p>
</td></tr>
<tr><td><code id="GenerateMMLSM_+3A_kernel_fun">kernel_fun</code></td>
<td>
<p>the link function of generating the adjacency tensor (‘logit’ or ‘probit’ )</p>
</td></tr>
<tr><td><code id="GenerateMMLSM_+3A_scale_par">scale_par</code></td>
<td>
<p>the scaling factor of the parameter tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including an adjacency tensor and the generating parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateMMLSM(200,3,10,2,d=NULL)
</code></pre>

<hr>
<h2 id='GenerateMMSBM'>Title</h2><span id='topic+GenerateMMSBM'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateMMSBM(n, m, L, K, d = NULL, r = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateMMSBM_+3A_n">n</code></td>
<td>
<p>the number of vertices</p>
</td></tr>
<tr><td><code id="GenerateMMSBM_+3A_m">m</code></td>
<td>
<p>the number of types of the network</p>
</td></tr>
<tr><td><code id="GenerateMMSBM_+3A_l">L</code></td>
<td>
<p>the number of layers</p>
</td></tr>
<tr><td><code id="GenerateMMSBM_+3A_k">K</code></td>
<td>
<p>the number of groups of vertices</p>
</td></tr>
<tr><td><code id="GenerateMMSBM_+3A_d">d</code></td>
<td>
<p>the average degree of the network</p>
</td></tr>
<tr><td><code id="GenerateMMSBM_+3A_r">r</code></td>
<td>
<p>the out-in ratio in each layer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including an adjacency tensor and the generating parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateMMSBM(200, 3, 10, 2, d = NULL, r = NULL)
</code></pre>

<hr>
<h2 id='InitializationLSM'>Title</h2><span id='topic+InitializationLSM'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InitializationLSM(
  gen_list,
  n,
  m,
  k,
  rank = NULL,
  perturb = 0.1,
  int_type = "warm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InitializationLSM_+3A_gen_list">gen_list</code></td>
<td>
<p>a list including the adjacency tensor and the parameter of the mixture multilayer network</p>
</td></tr>
<tr><td><code id="InitializationLSM_+3A_n">n</code></td>
<td>
<p>the number of nodes</p>
</td></tr>
<tr><td><code id="InitializationLSM_+3A_m">m</code></td>
<td>
<p>the number of network types</p>
</td></tr>
<tr><td><code id="InitializationLSM_+3A_k">k</code></td>
<td>
<p>the number of groups of vertices</p>
</td></tr>
<tr><td><code id="InitializationLSM_+3A_rank">rank</code></td>
<td>
<p>rank of U</p>
</td></tr>
<tr><td><code id="InitializationLSM_+3A_perturb">perturb</code></td>
<td>
<p>the upper bound of Uniform distribution</p>
</td></tr>
<tr><td><code id="InitializationLSM_+3A_int_type">int_type</code></td>
<td>
<p>the method to initialize U and W ( ‘spec’, ‘rand’ or ‘warm’)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including the adjacency tensor, U0, W0 and tuning parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_list = GenerateMMLSM(200,3,10,2,d=NULL)
InitializationLSM(gen_list,200,3,2)
</code></pre>

<hr>
<h2 id='InitializationMMSBM'>Title  A function for initialization</h2><span id='topic+InitializationMMSBM'></span>

<h3>Description</h3>

<p>Title  A function for initialization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InitializationMMSBM(tnsr, m, k, rank = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InitializationMMSBM_+3A_tnsr">tnsr</code></td>
<td>
<p>the tensor of network</p>
</td></tr>
<tr><td><code id="InitializationMMSBM_+3A_m">m</code></td>
<td>
<p>the number of types of the network</p>
</td></tr>
<tr><td><code id="InitializationMMSBM_+3A_k">k</code></td>
<td>
<p>the number of groups of vertices</p>
</td></tr>
<tr><td><code id="InitializationMMSBM_+3A_rank">rank</code></td>
<td>
<p>the rank of the core tensor calculated by the equation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>U_list a list including the core tensor Z, network embedding and node embedding
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tnsr = GenerateMMSBM(200, 3, 10, 2, d = NULL, r = NULL)
U_list = InitializationMMSBM(tnsr, 3, 2, rank = NULL)
</code></pre>

<hr>
<h2 id='PowerIteration'>Title</h2><span id='topic+PowerIteration'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PowerIteration(
  tnsr,
  m,
  k,
  rank = NULL,
  type = "TWIST",
  U_0_list,
  delta1 = 1000,
  delta2 = 1000,
  max_iter = 5,
  tol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PowerIteration_+3A_tnsr">tnsr</code></td>
<td>
<p>the adjacency tensor of the network</p>
</td></tr>
<tr><td><code id="PowerIteration_+3A_m">m</code></td>
<td>
<p>the number of types of the network</p>
</td></tr>
<tr><td><code id="PowerIteration_+3A_k">k</code></td>
<td>
<p>the number of groups of vertices</p>
</td></tr>
<tr><td><code id="PowerIteration_+3A_rank">rank</code></td>
<td>
<p>the rank of the core tensor calculated by the equation</p>
</td></tr>
<tr><td><code id="PowerIteration_+3A_type">type</code></td>
<td>
<p>specifies the iterative algorithm to run ‘TWIST’ or ‘Tucker’</p>
</td></tr>
<tr><td><code id="PowerIteration_+3A_u_0_list">U_0_list</code></td>
<td>
<p>InitializationMMSBM outputs</p>
</td></tr>
<tr><td><code id="PowerIteration_+3A_delta1">delta1</code></td>
<td>
<p>tuning parameters for regularization in mode1</p>
</td></tr>
<tr><td><code id="PowerIteration_+3A_delta2">delta2</code></td>
<td>
<p>tuning parameters for regularization in mode2</p>
</td></tr>
<tr><td><code id="PowerIteration_+3A_max_iter">max_iter</code></td>
<td>
<p>the max times of iteration</p>
</td></tr>
<tr><td><code id="PowerIteration_+3A_tol">tol</code></td>
<td>
<p>the convergence tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including the core tensor Z, network embedding and node embedding
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tnsr = GenerateMMSBM(200, 3, 10, 2, d = NULL, r = NULL)
U_list = InitializationMMSBM(tnsr, 3, 2, rank = NULL)
embed_list = PowerIteration(tnsr,3,2,rank=NULL,type="TUCKER",U_0_list=U_list)
</code></pre>

<hr>
<h2 id='ProjectedGD'>Title</h2><span id='topic+ProjectedGD'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectedGD(
  Ini_list,
  cmax = 1,
  eta_outer = 0.001,
  tmax_outer = 10,
  p_type = "logit",
  rd = "Non",
  show = TRUE,
  sgma = 1,
  sample_size = 500
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ProjectedGD_+3A_ini_list">Ini_list</code></td>
<td>
<p>the output of function InitializationLSM</p>
</td></tr>
<tr><td><code id="ProjectedGD_+3A_cmax">cmax</code></td>
<td>
<p>the upper limits for adding the coefficient constraint</p>
</td></tr>
<tr><td><code id="ProjectedGD_+3A_eta_outer">eta_outer</code></td>
<td>
<p>the learning rate in gradient descent</p>
</td></tr>
<tr><td><code id="ProjectedGD_+3A_tmax_outer">tmax_outer</code></td>
<td>
<p>the number of iterations in gradient descent</p>
</td></tr>
<tr><td><code id="ProjectedGD_+3A_p_type">p_type</code></td>
<td>
<p>the type of link function (‘logit’, ‘probit’ or ‘poisson’ )</p>
</td></tr>
<tr><td><code id="ProjectedGD_+3A_rd">rd</code></td>
<td>
<p>whether to use stochastic sampling (‘rand’ or ‘Non’ )</p>
</td></tr>
<tr><td><code id="ProjectedGD_+3A_show">show</code></td>
<td>
<p>if print the ietation process</p>
</td></tr>
<tr><td><code id="ProjectedGD_+3A_sgma">sgma</code></td>
<td>
<p>the link function parameter</p>
</td></tr>
<tr><td><code id="ProjectedGD_+3A_sample_size">sample_size</code></td>
<td>
<p>the size of sampling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the embedding results of nodes and layers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_list = GenerateMMLSM(200,3,5,2,d=NULL)
Ini_list = InitializationLSM(gen_list,200,3,2)
</code></pre>

<hr>
<h2 id='SpecClustering'>Title</h2><span id='topic+SpecClustering'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpecClustering(tnsr, rank, embedding_type = "Layer")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SpecClustering_+3A_tnsr">tnsr</code></td>
<td>
<p>the adjacency tensor</p>
</td></tr>
<tr><td><code id="SpecClustering_+3A_rank">rank</code></td>
<td>
<p>the number of columns of the output matrix U</p>
</td></tr>
<tr><td><code id="SpecClustering_+3A_embedding_type">embedding_type</code></td>
<td>
<p>SumAdj for ‘Node’ and M3SC for ‘Layer’</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The embeddding result can be applied in cluster methods like kmeans.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tnsr = GenerateMMSBM(200, 3, 10, 2, d = NULL, r = NULL)
emb_result = SpecClustering(tnsr,3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
