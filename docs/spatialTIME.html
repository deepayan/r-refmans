<!DOCTYPE html><html><head><title>Help for package spatialTIME</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatialTIME}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#bi_NN_G'><p>Bivariate Nearest Neighbor G(r)</p></a></li>
<li><a href='#bi_pair_correlation'><p>Bivariate Pair Correlation Function</p></a></li>
<li><a href='#bi_ripleys_k'><p>Bivariate Ripley's K</p></a></li>
<li><a href='#bi_ripleys_k_WSI'><p>Bivariate Ripley's K for Whole Slide Images</p></a></li>
<li><a href='#compute_metrics'><p>Calculate Count Based Measures and NN Measures of Spatial Clustering for IF data</p></a></li>
<li><a href='#create_mif'><p>Create Multiplex Immunoflourescent object</p></a></li>
<li><a href='#dixons_s'><p>Dixon's S Segregation Statistic</p></a></li>
<li><a href='#example_clinical'><p>Clinical variables of 229 patients</p></a></li>
<li><a href='#example_spatial'><p>Example list of 5 spatial TMA data</p></a></li>
<li><a href='#example_summary'><p>Marker summaries of 229 samples</p></a></li>
<li><a href='#interaction_variable'><p>Bivariate Interaction Variable</p></a></li>
<li><a href='#merge_mifs'><p>Merge several MIF objects together</p></a></li>
<li><a href='#NN_G'><p>Univariate Nearest Neighbor G(r)</p></a></li>
<li><a href='#pair_correlation'><p>Univariate Pair Correlation Function</p></a></li>
<li><a href='#plot_immunoflo'><p>Generate plot of TMA point process</p></a></li>
<li><a href='#ripleys_k'><p>Calculate Ripley's K</p></a></li>
<li><a href='#subset_mif'><p>Subset mif object on cellular level</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Analysis of Vectra Immunoflourescent Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.4-3</td>
</tr>
<tr>
<td>Description:</td>
<td>Visualization and analysis  of Vectra Immunoflourescent
    data. Options for calculating both the univariate and bivariate Ripley's K
    are included. Calculations are performed using a permutation-based 
    approach presented by Wilson et al.  &lt;<a href="https://doi.org/10.1101%2F2021.04.27.21256104">doi:10.1101/2021.04.27.21256104</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, dplyr, tidyr, ggplot2, scales, grDevices, purrr,
spatstat.geom, spatstat.explore, RColorBrewer, furrr, future,
tidyselect, crayon, pbmcapply, dixon, tibble, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, devtools, rmarkdown, testthat (&ge; 3.0.0), gridExtra,
pheatmap</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/FridleyLab/spatialTIME">https://github.com/FridleyLab/spatialTIME</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/FridleyLab/spatialTIME/issues">https://github.com/FridleyLab/spatialTIME/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-11 00:03:32 UTC; 4471592</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Jordan Creed [aut],
  Ram Thapa [aut],
  Christopher Wilson [aut],
  Alex Soupir [aut],
  Oscar Ospina [aut],
  Julia Wrobel [aut],
  Brooke Fridley [cph],
  Fridley Lab [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fridley Lab &lt;fridley.lab@moffitt.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-11 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='bi_NN_G'>Bivariate Nearest Neighbor G(r)</h2><span id='topic+bi_NN_G'></span>

<h3>Description</h3>

<p>Bivariate Nearest Neighbor G(r)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_NN_G(
  mif,
  mnames,
  r_range = 0:100,
  num_permutations = 50,
  edge_correction = "rs",
  keep_perm_dis = FALSE,
  workers = 1,
  overwrite = FALSE,
  xloc = NULL,
  yloc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_NN_G_+3A_mif">mif</code></td>
<td>
<p>object of class 'mif' created by function 'create_mif()'</p>
</td></tr>
<tr><td><code id="bi_NN_G_+3A_mnames">mnames</code></td>
<td>
<p>character vector of column names within the spatial files, indicating whether a cell row is positive for a phenotype</p>
</td></tr>
<tr><td><code id="bi_NN_G_+3A_r_range">r_range</code></td>
<td>
<p>numeric vector of radii around marker positive cells which to use for G(r)</p>
</td></tr>
<tr><td><code id="bi_NN_G_+3A_num_permutations">num_permutations</code></td>
<td>
<p>integer number of permutations to use for estimating core specific complete spatial randomness (CSR)</p>
</td></tr>
<tr><td><code id="bi_NN_G_+3A_edge_correction">edge_correction</code></td>
<td>
<p>character vector of edge correction methods to use: &quot;rs&quot;, &quot;km&quot; or &quot;han&quot;</p>
</td></tr>
<tr><td><code id="bi_NN_G_+3A_keep_perm_dis">keep_perm_dis</code></td>
<td>
<p>boolean for whether to summarise permutations to a single value or maintain each permutations result</p>
</td></tr>
<tr><td><code id="bi_NN_G_+3A_workers">workers</code></td>
<td>
<p>integer number for the number of CPU cores to use in parallel to calculate all samples/markers</p>
</td></tr>
<tr><td><code id="bi_NN_G_+3A_overwrite">overwrite</code></td>
<td>
<p>boolean whether to overwrite previous run of NN G(r) or increment &quot;RUN&quot; and maintain  previous measurements</p>
</td></tr>
<tr><td><code id="bi_NN_G_+3A_xloc">xloc</code>, <code id="bi_NN_G_+3A_yloc">yloc</code></td>
<td>
<p>the x and y location columns in the spatial files that indicate the center of the respective cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'mif' containing a new slot under 'derived' got nearest neighbor distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- spatialTIME::create_mif(clinical_data = spatialTIME::example_clinical %&gt;% 
  dplyr::mutate(deidentified_id = as.character(deidentified_id)),
  sample_data = spatialTIME::example_summary %&gt;% 
  dplyr::mutate(deidentified_id = as.character(deidentified_id)),
  spatial_list = spatialTIME::example_spatial[1:2],
  patient_id = "deidentified_id", 
  sample_id = "deidentified_sample")
    
mnames_good &lt;- c("CD3..Opal.570..Positive","CD8..Opal.520..Positive",
  "FOXP3..Opal.620..Positive","PDL1..Opal.540..Positive",
  "PD1..Opal.650..Positive","CD3..CD8.","CD3..FOXP3.")
## Not run: 
x2 = bi_NN_G(mif = x, mnames = mnames_good[1:2], 
      r_range = 0:100, num_permutations = 10, 
      edge_correction = "rs", keep_perm_dis = FALSE, 
      workers = 1, overwrite = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='bi_pair_correlation'>Bivariate Pair Correlation Function</h2><span id='topic+bi_pair_correlation'></span>

<h3>Description</h3>

<p>Bivariate Pair Correlation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_pair_correlation(
  mif,
  mnames,
  r_range = NULL,
  num_permutations = 100,
  edge_correction = "translation",
  keep_permutation_distribution = FALSE,
  workers = 1,
  overwrite = FALSE,
  xloc = NULL,
  yloc = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_pair_correlation_+3A_mif">mif</code></td>
<td>
<p>object of class 'mif'</p>
</td></tr>
<tr><td><code id="bi_pair_correlation_+3A_mnames">mnames</code></td>
<td>
<p>character vector or dataframe with 2 columns containing markers/marker combinations to run</p>
</td></tr>
<tr><td><code id="bi_pair_correlation_+3A_r_range">r_range</code></td>
<td>
<p>numeric vector radii to measure</p>
</td></tr>
<tr><td><code id="bi_pair_correlation_+3A_num_permutations">num_permutations</code></td>
<td>
<p>integer for the number of permutations to run</p>
</td></tr>
<tr><td><code id="bi_pair_correlation_+3A_edge_correction">edge_correction</code></td>
<td>
<p>character string for which edge correction to implement for Ripley's K</p>
</td></tr>
<tr><td><code id="bi_pair_correlation_+3A_keep_permutation_distribution">keep_permutation_distribution</code></td>
<td>
<p>boolean whether to summarise the permutations or keep all</p>
</td></tr>
<tr><td><code id="bi_pair_correlation_+3A_workers">workers</code></td>
<td>
<p>integer for number of cores to use when calculating</p>
</td></tr>
<tr><td><code id="bi_pair_correlation_+3A_overwrite">overwrite</code></td>
<td>
<p>boolean for whether to overwrite existing bivariate pair correlation results</p>
</td></tr>
<tr><td><code id="bi_pair_correlation_+3A_xloc">xloc</code></td>
<td>
<p>x location column in spatial files</p>
</td></tr>
<tr><td><code id="bi_pair_correlation_+3A_yloc">yloc</code></td>
<td>
<p>y location column in spatial files</p>
</td></tr>
<tr><td><code id="bi_pair_correlation_+3A_...">...</code></td>
<td>
<p>other variables to pass to '[spatstat.explore::pcfcross]'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'mif' object with the bivariate_pair_correlation slot filled
</p>

<hr>
<h2 id='bi_ripleys_k'>Bivariate Ripley's K</h2><span id='topic+bi_ripleys_k'></span>

<h3>Description</h3>

<p>Bivariate Ripley's K function within spatialTIME, 'bi_ripleys_k' is a function that takes in a 'mIF' object, along with 
some parameters like marker names of interest and range of radii in which to assess bivariate clustering or colocalization.
In 1.3.3.3 we have introduced the ability to forsgo the need for permutations with the implementation of the exact CSR estimate.
This is both faster and being the exact CSR, produces an exact degree of clustering in the spatial files.
</p>
<p>Due to the availability of whole slide images (WSI), there's a possibility users will be running bivariate Ripley's K on samples
that have millions of cells. When doing this, keep in mind that a nearest neighbor matrix with *n* cell is *n* by *n* in size and 
therefore easily consumers high performance compute levels of RAM. To combat this, we have implemented a tiling method that performs
counts for small chunks of the distance matrix at a time before finally calculating the bivariate Ripley's K value on the total counts.
When doing this there are now 2 import parameters to keep in mind. The 'big' parameter is the size of the tile to use. We have found
1000 to be a good number that allows for high number of cores while maintaining low RAM usage. The other important parameter when
working with WSI is nlarge which is the fall over for switching to no edge correction. The spatstat.explore::Kest univariate 
Ripley's K uses a default of 3000 but we have defaulted to 1000 to keep compute minimized as edge correction uses large amounts
of RAM over 'none'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_ripleys_k(
  mif,
  mnames,
  r_range = 0:100,
  edge_correction = "translation",
  num_permutations = 50,
  permute = FALSE,
  keep_permutation_distribution = FALSE,
  overwrite = TRUE,
  workers = 6,
  xloc = NULL,
  yloc = NULL,
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_ripleys_k_+3A_mif">mif</code></td>
<td>
<p>mIF object with spatial data frames, clinical, and per-sample summary information</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_+3A_mnames">mnames</code></td>
<td>
<p>vector of column names for phenotypes or data frame of marker combinations</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_+3A_r_range">r_range</code></td>
<td>
<p>vector range of radii to calculate co-localization *K*</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_+3A_edge_correction">edge_correction</code></td>
<td>
<p>character edge_correction method, one of &quot;translation&quot;, &quot;border&quot;, &quot;or none&quot;</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_+3A_num_permutations">num_permutations</code></td>
<td>
<p>integer number of permutations to estimate CSR</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_+3A_permute">permute</code></td>
<td>
<p>whether or not to use permutations to estimate CSR (TRUE) or to calculate exact CSR (FALSE)</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_+3A_keep_permutation_distribution">keep_permutation_distribution</code></td>
<td>
<p>boolean as to whether to summarise permutations to mean</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_+3A_overwrite">overwrite</code></td>
<td>
<p>boolean as to whether to replace existing bivariate_Count if exists</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_+3A_workers">workers</code></td>
<td>
<p>integer number of CPU workers to use</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_+3A_xloc">xloc</code>, <code id="bi_ripleys_k_+3A_yloc">yloc</code></td>
<td>
<p>the x and y positions that correspond to cells. If left as NULL, XMin, XMax, YMin, and YMax must be present in the spatial files</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_+3A_force">force</code></td>
<td>
<p>logical whether or not to continue if sample has more than 10,000 cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mif object with bivariate Ripley's K calculated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- spatialTIME::create_mif(clinical_data = spatialTIME::example_clinical %&gt;% 
                               dplyr::mutate(deidentified_id = as.character(deidentified_id)),
                             sample_data = spatialTIME::example_summary %&gt;% 
                               dplyr::mutate(deidentified_id = as.character(deidentified_id)),
                             spatial_list = spatialTIME::example_spatial,
                             patient_id = "deidentified_id", 
                             sample_id = "deidentified_sample")
mnames_good &lt;- c("CD3..Opal.570..Positive","CD8..Opal.520..Positive",
                 "FOXP3..Opal.620..Positive","PDL1..Opal.540..Positive",
                 "PD1..Opal.650..Positive","CD3..CD8.","CD3..FOXP3.")
x2 = bi_ripleys_k(mif = x, mnames = mnames_good[1:2], 
                   r_range = 0:100, edge_correction = "none", permute = FALSE,
                   num_permutations = 50, keep_permutation_distribution = FALSE, 
                   workers = 1)
</code></pre>

<hr>
<h2 id='bi_ripleys_k_WSI'>Bivariate Ripley's K for Whole Slide Images</h2><span id='topic+bi_ripleys_k_WSI'></span>

<h3>Description</h3>

<p>Bivariate Ripley's K function within spatialTIME, 'bi_ripleys_k' is a function that takes in a 'mIF' object, along with 
some parameters like marker names of interest and range of radii in which to assess bivariate clustering or colocalization.
In 1.3.3.3 we have introduced the ability to forsgo the need for permutations with the implementation of the exact CSR estimate.
This is both faster and being the exact CSR, produces an exact degree of clustering in the spatial files.
</p>
<p>Due to the availability of whole slide images (WSI), there's a possibility users will be running bivariate Ripley's K on samples
that have millions of cells. When doing this, keep in mind that a nearest neighbor matrix with *n* cell is *n* by *n* in size and 
therefore easily consumers high performance compute levels of RAM. To combat this, we have implemented a tiling method that performs
counts for small chunks of the distance matrix at a time before finally calculating the bivariate Ripley's K value on the total counts.
When doing this there are now 2 import parameters to keep in mind. The 'big' parameter is the size of the tile to use. We have found
1000 to be a good number that allows for high number of cores while maintaining low RAM usage. The other important parameter when
working with WSI is nlarge which is the fall over for switching to no edge correction. The spatstat.explore::Kest univariate 
Ripley's K uses a default of 3000 but we have defaulted to 1000 to keep compute minimized as edge correction uses large amounts
of RAM over 'none'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_ripleys_k_WSI(
  mif,
  mnames,
  r_range = 0:100,
  edge_correction = "translation",
  num_permutations = 50,
  permute = FALSE,
  keep_permutation_distribution = FALSE,
  overwrite = TRUE,
  workers = 6,
  big = 1000,
  nlarge = 1000,
  xloc = NULL,
  yloc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_ripleys_k_WSI_+3A_mif">mif</code></td>
<td>
<p>mIF object with spatial data frames, clinical, and per-sample summary information</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_mnames">mnames</code></td>
<td>
<p>vector of column names for phenotypes or data frame of marker combinations</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_r_range">r_range</code></td>
<td>
<p>vector range of radii to calculate co-localization *K*</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_edge_correction">edge_correction</code></td>
<td>
<p>character edge_correction method, one of &quot;translation&quot;, or none&quot;</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_num_permutations">num_permutations</code></td>
<td>
<p>integer number of permutations to estimate CSR</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_permute">permute</code></td>
<td>
<p>whether or not to use permutations to estimate CSR (TRUE) or to calculate exact CSR (FALSE)</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_keep_permutation_distribution">keep_permutation_distribution</code></td>
<td>
<p>boolean as to whether to summarise permutations to mean</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_overwrite">overwrite</code></td>
<td>
<p>boolean as to whether to replace existing bivariate_Count if exists</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_workers">workers</code></td>
<td>
<p>integer number of CPU workers to use</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_big">big</code></td>
<td>
<p>integer used as the threshold for subsetting large samples, default is 1000 either *i* or *j*</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_nlarge">nlarge</code></td>
<td>
<p>number of cells in either *i* or *j* to flip to no edge correction - at small (relative to whole spatial region) *r* values differences in results between correction methods is negligible so running a few samples is recommended. Perhaps compute outweighs small differences in correction methods.</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_xloc">xloc</code></td>
<td>
<p>the x and y positions that correspond to cells. If left as NULL, XMin, XMax, YMin, and YMax must be present in the spatial files</p>
</td></tr>
<tr><td><code id="bi_ripleys_k_WSI_+3A_yloc">yloc</code></td>
<td>
<p>the x and y positions that correspond to cells. If left as NULL, XMin, XMax, YMin, and YMax must be present in the spatial files</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mif object with bivariate Ripley's K calculated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- spatialTIME::create_mif(clinical_data = spatialTIME::example_clinical %&gt;% 
                               dplyr::mutate(deidentified_id = as.character(deidentified_id)),
                             sample_data = spatialTIME::example_summary %&gt;% 
                               dplyr::mutate(deidentified_id = as.character(deidentified_id)),
                             spatial_list = spatialTIME::example_spatial,
                             patient_id = "deidentified_id", 
                             sample_id = "deidentified_sample")
mnames_good &lt;- c("CD3..Opal.570..Positive","CD8..Opal.520..Positive",
                 "FOXP3..Opal.620..Positive","PDL1..Opal.540..Positive",
                 "PD1..Opal.650..Positive","CD3..CD8.","CD3..FOXP3.")
x2 = bi_ripleys_k_WSI(mif = x, mnames = mnames_good[1:2], 
                   r_range = 0:100, edge_correction = "none", permute = FALSE,
                   num_permutations = 50, keep_permutation_distribution = FALSE, 
                   workers = 1, big = 1000)
</code></pre>

<hr>
<h2 id='compute_metrics'>Calculate Count Based Measures and NN Measures of Spatial Clustering for IF data</h2><span id='topic+compute_metrics'></span>

<h3>Description</h3>

<p>This function calculates count based Measures (Ripley's K, Besag 
L, and Marcon's M) of IF data to characterize correlation of spatial point
process. For neareast neighbor calculations of a given cell type, this function 
computes proportion of cells that have nearest neighbor less than r for the 
observed and permuted point processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_metrics(
  mif,
  mnames,
  r_range = seq(0, 100, 50),
  num_permutations = 50,
  edge_correction = c("translation"),
  method = c("K"),
  k_trans = "none",
  keep_perm_dis = FALSE,
  workers = 1,
  overwrite = FALSE,
  xloc = NULL,
  yloc = NULL,
  exhaustive = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_metrics_+3A_mif">mif</code></td>
<td>
<p>An MIF object</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_mnames">mnames</code></td>
<td>
<p>Character vector of marker names to estimate degree of 
spatial clustering.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_r_range">r_range</code></td>
<td>
<p>Numeric vector of potential r values this range must include 0.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_num_permutations">num_permutations</code></td>
<td>
<p>Numeric value indicating the number of permutations used. 
Default is 50.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_edge_correction">edge_correction</code></td>
<td>
<p>Character vector indicating the type of edge correction 
to use. Options for count based include &quot;translation&quot; or &quot;isotropic&quot; and for 
nearest neighboroOptions include &quot;rs&quot; or &quot;hans&quot;.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_method">method</code></td>
<td>
<p>Character vector indicating which count based measure (K, BiK, 
G, BiG) used to estimate the degree of spatial clustering. Description of the 
methods can be found in Details section.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_k_trans">k_trans</code></td>
<td>
<p>Character value of the transformation to apply to count based 
metrics (none, M, or L)</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_keep_perm_dis">keep_perm_dis</code></td>
<td>
<p>Logical value determining whether or not to keep the full 
distribution of permuted K or G values</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_workers">workers</code></td>
<td>
<p>Integer value for the number of workers to spawn</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical value determining if you want the results to replace the 
current output (TRUE) or be to be appended (FALSE).</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_xloc">xloc</code></td>
<td>
<p>a string corresponding to the x coordinates. If null the average of 
XMin and XMax will be used</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_yloc">yloc</code></td>
<td>
<p>a string corresponding to the y coordinates. If null the average of 
YMin and YMax will be used</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_exhaustive">exhaustive</code></td>
<td>
<p>whether or not to compute all combinations of markers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame
</p>
<table>
<tr><td><code>Theoretical CSR</code></td>
<td>
<p>Expected value assuming complete spatial randomnessn</p>
</td></tr>
<tr><td><code>Permuted CSR</code></td>
<td>
<p>Average observed K, L, or M for the permuted point 
process</p>
</td></tr>
<tr><td><code>Observed</code></td>
<td>
<p>Observed valuefor the observed point process</p>
</td></tr>
<tr><td><code>Degree of Clustering Permuted</code></td>
<td>
<p>Degree of spatial clustering where the
reference is the permutated estimate of CSR</p>
</td></tr>
<tr><td><code>Degree of Clustering Theoretical</code></td>
<td>
<p>Degree of spatial clustering where the
reference is the theoretical estimate of CSR</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create mif object
library(dplyr)
x &lt;- create_mif(clinical_data = example_clinical %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
sample_data = example_summary %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
spatial_list = example_spatial,
patient_id = "deidentified_id", 
sample_id = "deidentified_sample")

# Define the set of markers to study
mnames &lt;- c("CD3..Opal.570..Positive","CD8..Opal.520..Positive",
"FOXP3..Opal.620..Positive","CD3..CD8.","CD3..FOXP3.")

# Ripley's K and nearest neighbor G for all markers with a neighborhood size 
# of  10,20,...,100 (zero must be included in the input).


</code></pre>

<hr>
<h2 id='create_mif'>Create Multiplex Immunoflourescent object</h2><span id='topic+create_mif'></span>

<h3>Description</h3>

<p>Creates an MIF object for use in spatialIF functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_mif(
  clinical_data,
  sample_data,
  spatial_list = NULL,
  patient_id = "patient_id",
  sample_id = "image_tag"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_mif_+3A_clinical_data">clinical_data</code></td>
<td>
<p>A data frame containing patient level data with one row
per participant.</p>
</td></tr>
<tr><td><code id="create_mif_+3A_sample_data">sample_data</code></td>
<td>
<p>A data frame containing sample level data with one row per 
sample. Should at a minimum contain a 2 columns: one for sample names and 
one for the corresponding patient name.</p>
</td></tr>
<tr><td><code id="create_mif_+3A_spatial_list">spatial_list</code></td>
<td>
<p>A named list of data frames with the spatial data from 
each sample making up each individual data frame</p>
</td></tr>
<tr><td><code id="create_mif_+3A_patient_id">patient_id</code></td>
<td>
<p>A character string indicating the column name for patient id in 
sample and clinical data frames.</p>
</td></tr>
<tr><td><code id="create_mif_+3A_sample_id">sample_id</code></td>
<td>
<p>A character string indicating the column name for sample id
in the sample data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a custom MIF
</p>
<table>
<tr><td><code>clinical</code></td>
<td>
<p>Data frame of clinical data</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>Data frame of sample data</p>
</td></tr>
<tr><td><code>spatial</code></td>
<td>
<p>Named list of spatial data</p>
</td></tr>
<tr><td><code>derived</code></td>
<td>
<p>List of data derived using the MIF object</p>
</td></tr>
<tr><td><code>patient_id</code></td>
<td>
<p>The column name for sample id
in the sample data frame with the clinical data</p>
</td></tr>
<tr><td><code>sample_id</code></td>
<td>
<p>The column name for sample id
in the sample data frame to merge with the spatial data</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create mif object
library(dplyr)
x &lt;- create_mif(clinical_data = example_clinical %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
sample_data = example_summary %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
spatial_list = example_spatial,
patient_id = "deidentified_id", 
sample_id = "deidentified_sample")
</code></pre>

<hr>
<h2 id='dixons_s'>Dixon's S Segregation Statistic</h2><span id='topic+dixons_s'></span>

<h3>Description</h3>

<p>This function processes the spatial files in the mif object,
requiring a column that distinguishes between different groups i.e. tumor and 
stroma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dixons_s(
  mif,
  mnames,
  num_permutations = 1000,
  type = c("Z", "C"),
  workers = 1,
  overwrite = FALSE,
  xloc = NULL,
  yloc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dixons_s_+3A_mif">mif</code></td>
<td>
<p>An MIF object</p>
</td></tr>
<tr><td><code id="dixons_s_+3A_mnames">mnames</code></td>
<td>
<p>vector of markers corresponding to spatial columns to check Dixon's S between</p>
</td></tr>
<tr><td><code id="dixons_s_+3A_num_permutations">num_permutations</code></td>
<td>
<p>Numeric value indicating the number of permutations used. 
Default is 1000.</p>
</td></tr>
<tr><td><code id="dixons_s_+3A_type">type</code></td>
<td>
<p>a character string for the type that is wanted in the output which can
be &quot;Z&quot; for z-statistic results or &quot;C&quot; for Chi-squared statistic results</p>
</td></tr>
<tr><td><code id="dixons_s_+3A_workers">workers</code></td>
<td>
<p>Integer value for the number of workers to spawn</p>
</td></tr>
<tr><td><code id="dixons_s_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical value determining if you want the results to replace the 
current output (TRUE) or be to be appended (FALSE).</p>
</td></tr>
<tr><td><code id="dixons_s_+3A_xloc">xloc</code></td>
<td>
<p>a string corresponding to the x coordinates. If null the average of 
XMin and XMax will be used</p>
</td></tr>
<tr><td><code id="dixons_s_+3A_yloc">yloc</code></td>
<td>
<p>a string corresponding to the y coordinates. If null the average of 
YMin and YMax will be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame for Z-statistic
</p>
<table>
<tr><td><code>From</code></td>
<td>
</td></tr>
<tr><td><code>To</code></td>
<td>
</td></tr>
<tr><td><code>Obs.Count</code></td>
<td>
</td></tr>
<tr><td><code>Exp. Count</code></td>
<td>
</td></tr>
<tr><td><code>S</code></td>
<td>
</td></tr>
<tr><td><code>Z</code></td>
<td>
</td></tr>
<tr><td><code>p-val.Z</code></td>
<td>
</td></tr>
<tr><td><code>p-val.Nobs</code></td>
<td>
</td></tr>
<tr><td><code>Marker</code></td>
<td>
</td></tr>
<tr><td><code>Classifier Labeled Column Counts</code></td>
<td>
</td></tr>
<tr><td><code>Image.Tag</code></td>
<td>
</td></tr>
</table>
<p>Returns a data frame for C-statistic
</p>
<table>
<tr><td><code>Segregation</code></td>
<td>
</td></tr>
<tr><td><code>df</code></td>
<td>
</td></tr>
<tr><td><code>Chi-sq</code></td>
<td>
</td></tr>
<tr><td><code>P.asymp</code></td>
<td>
</td></tr>
<tr><td><code>P.rand</code></td>
<td>
</td></tr>
<tr><td><code>Marker</code></td>
<td>
</td></tr>
<tr><td><code>Classifier Labeled Column Counts</code></td>
<td>
</td></tr>
<tr><td><code>Image.Tag</code></td>
<td>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#' #Create mif object
library(dplyr)
x &lt;- create_mif(clinical_data = example_clinical %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
sample_data = example_summary %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
spatial_list = example_spatial,
patient_id = "deidentified_id", 
sample_id = "deidentified_sample")

</code></pre>

<hr>
<h2 id='example_clinical'>Clinical variables of 229 patients</h2><span id='topic+example_clinical'></span>

<h3>Description</h3>

<p>A tibble wuith clinical characteristics for 229 patients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_clinical
</code></pre>


<h3>Format</h3>

<p>A tibble with 229 rows and 6 variables
</p>

<dl>
<dt>age</dt><dd><p>age at diagnosis</p>
</dd>
<dt>race</dt><dd><p>self-idenitifed race</p>
</dd>
<dt>sex</dt><dd><p>patient biological sex</p>
</dd>
<dt>status</dt><dd><p>disease status</p>
</dd>
<dt>deidenitifed_sample</dt><dd><p>sample identifier</p>
</dd>
<dt>deidentified_id</dt><dd><p>patient identifier</p>
</dd>
</dl>


<hr>
<h2 id='example_spatial'>Example list of 5 spatial TMA data</h2><span id='topic+example_spatial'></span>

<h3>Description</h3>

<p>A list containing 5 spatial data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_spatial
</code></pre>


<h3>Format</h3>

<p>A list of 5 data frames: 
</p>

<ul>
<li><p> TMA_\[3,B\].tiff
</p>
</li>
<li><p> TMA_\[6,F\].tiff
</p>
</li>
<li><p> TMA_\[7,B\].tiff
</p>
</li>
<li><p> TMA_\[9,K\].tiff
</p>
</li>
<li><p> TMA_\[8,U\].tiff
</p>
</li></ul>


<hr>
<h2 id='example_summary'>Marker summaries of 229 samples</h2><span id='topic+example_summary'></span>

<h3>Description</h3>

<p>A dataset containing summaries of 25 markers and 229 samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_summary
</code></pre>


<h3>Format</h3>

<p>A tibble with 229 rows and 29 variables: 
</p>

<dl>
<dt>deidentified_id</dt><dd><p>patient-level id</p>
</dd>
<dt>deidentified_sample</dt><dd><p>sample-level id</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='interaction_variable'>Bivariate Interaction Variable</h2><span id='topic+interaction_variable'></span>

<h3>Description</h3>

<p>Single-cell spatial-protein metric introduce by Steinhart et al in https://doi.org/10.1158/1541-7786.mcr-21-0411
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interaction_variable(
  mif,
  mnames,
  r_range = NULL,
  num_permutations = 100,
  keep_permutation_distribution = FALSE,
  workers = 1,
  overwrite = FALSE,
  xloc = NULL,
  yloc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interaction_variable_+3A_mif">mif</code></td>
<td>
<p>object of class 'mif'</p>
</td></tr>
<tr><td><code id="interaction_variable_+3A_mnames">mnames</code></td>
<td>
<p>a character vector or table with 2 columns indicating the from-to markers to assess</p>
</td></tr>
<tr><td><code id="interaction_variable_+3A_r_range">r_range</code></td>
<td>
<p>numeric vector of radii for which to calculate the interaction variable at</p>
</td></tr>
<tr><td><code id="interaction_variable_+3A_num_permutations">num_permutations</code></td>
<td>
<p>integer for how many permutations to use to derive the interaction estimate under CSR</p>
</td></tr>
<tr><td><code id="interaction_variable_+3A_keep_permutation_distribution">keep_permutation_distribution</code></td>
<td>
<p>boolean for whether or not to keep all permutation results or average them</p>
</td></tr>
<tr><td><code id="interaction_variable_+3A_workers">workers</code></td>
<td>
<p>integer for the number of CPU cores to use for permutations, markers, and spatial samples</p>
</td></tr>
<tr><td><code id="interaction_variable_+3A_overwrite">overwrite</code></td>
<td>
<p>boolean for whether to overwrite existing interaction variable results</p>
</td></tr>
<tr><td><code id="interaction_variable_+3A_xloc">xloc</code></td>
<td>
<p>column name in spatial files containing the x location - if left NULL will average columns XMin and XMax</p>
</td></tr>
<tr><td><code id="interaction_variable_+3A_yloc">yloc</code></td>
<td>
<p>column name in spatial files containing the y location - if left NULL will average columns YMin and YMax</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class mif with the interaction variable derive slot filled
</p>

<hr>
<h2 id='merge_mifs'>Merge several MIF objects together</h2><span id='topic+merge_mifs'></span>

<h3>Description</h3>

<p>This function merges MIF objects that were run separately so they
can be used as a single MIF. MIF objects don't *need* but *should* have the same
column names in the summary file and clinical data file. The MIF objects **DO**
need to have the same patient_id and sample_id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_mifs(mifs = NULL, check.names = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_mifs_+3A_mifs">mifs</code></td>
<td>
<p>A list of MIF objects to merge together</p>
</td></tr>
<tr><td><code id="merge_mifs_+3A_check.names">check.names</code></td>
<td>
<p>whether to check names of spatial files and summary enttries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new MIF object list
</p>
<table>
<tr><td><code>clinical_data</code></td>
<td>
<p>clinical information from all</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>cell level summary data from all</p>
</td></tr>
<tr><td><code>spatial</code></td>
<td>
<p>contains all spatial files from all MIFs</p>
</td></tr>
<tr><td><code>derived</code></td>
<td>
<p>appended derived variables</p>
</td></tr>
<tr><td><code>patient_id</code></td>
<td>
<p>patient_id from the first MIF - this is
why it is important to have the same patient_id for all MIFs</p>
</td></tr>
<tr><td><code>sample_id</code></td>
<td>
<p>sample_id from the first MIF - also important
for all MIFs to have the same sample_id</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#merge several MIF objects
library(dplyr)
x &lt;- create_mif(clinical_data = example_clinical %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
sample_data = example_summary %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
spatial_list = example_spatial,
patient_id = "deidentified_id", 
sample_id = "deidentified_sample")
x &lt;- merge_mifs(mifs = list(x, x), check.names = FALSE)

</code></pre>

<hr>
<h2 id='NN_G'>Univariate Nearest Neighbor G(r)</h2><span id='topic+NN_G'></span>

<h3>Description</h3>

<p>Univariate Nearest Neighbor G(r)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NN_G(
  mif,
  mnames,
  r_range = 0:100,
  num_permutations = 50,
  edge_correction = "rs",
  keep_perm_dis = FALSE,
  workers = 1,
  overwrite = FALSE,
  xloc = NULL,
  yloc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NN_G_+3A_mif">mif</code></td>
<td>
<p>object of class 'mif' created by function 'create_mif()'</p>
</td></tr>
<tr><td><code id="NN_G_+3A_mnames">mnames</code></td>
<td>
<p>character vector of column names within the spatial files, indicating whether a cell row is positive for a phenotype</p>
</td></tr>
<tr><td><code id="NN_G_+3A_r_range">r_range</code></td>
<td>
<p>numeric vector of radii around marker positive cells which to use for G(r)</p>
</td></tr>
<tr><td><code id="NN_G_+3A_num_permutations">num_permutations</code></td>
<td>
<p>integer number of permutations to use for estimating core specific complete spatial randomness (CSR)</p>
</td></tr>
<tr><td><code id="NN_G_+3A_edge_correction">edge_correction</code></td>
<td>
<p>character vector of edge correction methods to use: &quot;rs&quot;, &quot;km&quot; or &quot;han&quot;</p>
</td></tr>
<tr><td><code id="NN_G_+3A_keep_perm_dis">keep_perm_dis</code></td>
<td>
<p>boolean for whether to summarise permutations to a single value or maintain each permutations result</p>
</td></tr>
<tr><td><code id="NN_G_+3A_workers">workers</code></td>
<td>
<p>integer number for the number of CPU cores to use in parallel to calculate all samples/markers</p>
</td></tr>
<tr><td><code id="NN_G_+3A_overwrite">overwrite</code></td>
<td>
<p>boolean whether to overwrite previous run of NN G(r) or increment &quot;RUN&quot; and maintain  previous measurements</p>
</td></tr>
<tr><td><code id="NN_G_+3A_xloc">xloc</code>, <code id="NN_G_+3A_yloc">yloc</code></td>
<td>
<p>the x and y location columns in the spatial files that indicate the center of the respective cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'mif' containing a new slot under 'derived' got nearest neighbor distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
x &lt;- spatialTIME::create_mif(clinical_data = spatialTIME::example_clinical %&gt;% 
  dplyr::mutate(deidentified_id = as.character(deidentified_id)),
  sample_data = spatialTIME::example_summary %&gt;% 
  dplyr::mutate(deidentified_id = as.character(deidentified_id)),
  spatial_list = spatialTIME::example_spatial,
  patient_id = "deidentified_id", 
  sample_id = "deidentified_sample")
    
mnames_good &lt;- c("CD3..Opal.570..Positive","CD8..Opal.520..Positive",
  "FOXP3..Opal.620..Positive","PDL1..Opal.540..Positive",
  "PD1..Opal.650..Positive","CD3..CD8.","CD3..FOXP3.")
  
x2 = NN_G(mif = x, mnames = mnames_good[1:2], 
r_range = 0:100, num_permutations = 10, 
edge_correction = "rs", keep_perm_dis = FALSE, 
workers = 1, overwrite = TRUE)
</code></pre>

<hr>
<h2 id='pair_correlation'>Univariate Pair Correlation Function</h2><span id='topic+pair_correlation'></span>

<h3>Description</h3>

<p>Implementation of the univariate pair correlation function from spatstat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair_correlation(
  mif,
  mnames,
  r_range = NULL,
  num_permutations = 100,
  edge_correction = "translation",
  keep_permutation_distribution = FALSE,
  workers = 1,
  overwrite = FALSE,
  xloc = NULL,
  yloc = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_correlation_+3A_mif">mif</code></td>
<td>
<p>object of class 'mif'</p>
</td></tr>
<tr><td><code id="pair_correlation_+3A_mnames">mnames</code></td>
<td>
<p>character vector of marker names</p>
</td></tr>
<tr><td><code id="pair_correlation_+3A_r_range">r_range</code></td>
<td>
<p>numeric vector including 0. If ignored, 'spatstat' will decide range</p>
</td></tr>
<tr><td><code id="pair_correlation_+3A_num_permutations">num_permutations</code></td>
<td>
<p>integer indicating how many permutations to run to determine CSR estimate</p>
</td></tr>
<tr><td><code id="pair_correlation_+3A_edge_correction">edge_correction</code></td>
<td>
<p>character string of edge correction to apply to Ripley's K estimation</p>
</td></tr>
<tr><td><code id="pair_correlation_+3A_keep_permutation_distribution">keep_permutation_distribution</code></td>
<td>
<p>boolean for whether to keep the permutations or not</p>
</td></tr>
<tr><td><code id="pair_correlation_+3A_workers">workers</code></td>
<td>
<p>integer for number of threads to use when calculating metrics</p>
</td></tr>
<tr><td><code id="pair_correlation_+3A_overwrite">overwrite</code></td>
<td>
<p>boolean whether to overwrite existing results in the univariate_pair_correlation slot</p>
</td></tr>
<tr><td><code id="pair_correlation_+3A_xloc">xloc</code></td>
<td>
<p>column name of single x value</p>
</td></tr>
<tr><td><code id="pair_correlation_+3A_yloc">yloc</code></td>
<td>
<p>column name of single y value</p>
</td></tr>
<tr><td><code id="pair_correlation_+3A_...">...</code></td>
<td>
<p>other parameters to provide 'spatstat::pcf' 
</p>
<p>The Pair Correlation Function uses the derivative of Ripley's K so it does take slightly longer to calculate
</p>
<p>'xloc' and 'yloc', if NULL, will be calculated from columns 'XMax', 'XMin', 'YMax', and 'YMin'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mif object with with the univariate_pair_correlation derived slot filled or appended to
</p>

<hr>
<h2 id='plot_immunoflo'>Generate plot of TMA point process</h2><span id='topic+plot_immunoflo'></span>

<h3>Description</h3>

<p>This function generates plot of point process in rectangular or circular window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_immunoflo(
  mif,
  plot_title,
  mnames,
  mcolors = NULL,
  cell_type = NULL,
  filename = NULL,
  path = NULL,
  xloc = NULL,
  yloc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_immunoflo_+3A_mif">mif</code></td>
<td>
<p>MIF object created using create_MIF().</p>
</td></tr>
<tr><td><code id="plot_immunoflo_+3A_plot_title">plot_title</code></td>
<td>
<p>Character string or vector of character strings of variable name(s) to serve as plot title(s).</p>
</td></tr>
<tr><td><code id="plot_immunoflo_+3A_mnames">mnames</code></td>
<td>
<p>Character vector containing marker names.</p>
</td></tr>
<tr><td><code id="plot_immunoflo_+3A_mcolors">mcolors</code></td>
<td>
<p>Character vector of color names to display markers in the plot.</p>
</td></tr>
<tr><td><code id="plot_immunoflo_+3A_cell_type">cell_type</code></td>
<td>
<p>Character vector of cell type</p>
</td></tr>
<tr><td><code id="plot_immunoflo_+3A_filename">filename</code></td>
<td>
<p>Character string of file name to store plots. Plots are generated as single .pdf file.</p>
</td></tr>
<tr><td><code id="plot_immunoflo_+3A_path">path</code></td>
<td>
<p>Different path than file name or to use in conjunction with filename ???</p>
</td></tr>
<tr><td><code id="plot_immunoflo_+3A_xloc">xloc</code>, <code id="plot_immunoflo_+3A_yloc">yloc</code></td>
<td>
<p>columns in the spatial files containing the x and y locations of cells. Default is 'NULL' which will result in 'xloc' and 'yloc' being calculated from 'XMin'/'YMin' and 'XMax'/'YMax'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mif object and the ggplot objects can be viewed form the derived slot of the mif object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create mif object
library(dplyr)
x &lt;- create_mif(clinical_data = example_clinical %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
sample_data = example_summary %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
spatial_list = example_spatial,
patient_id = "deidentified_id", 
sample_id = "deidentified_sample")

mnames_good &lt;- c("CD3..Opal.570..Positive","CD8..Opal.520..Positive",
"FOXP3..Opal.620..Positive","PDL1..Opal.540..Positive",
"PD1..Opal.650..Positive","CD3..CD8.","CD3..FOXP3.")

x &lt;- plot_immunoflo(x, plot_title = "deidentified_sample", mnames = mnames_good, 
cell_type = "Classifier.Label")

x[["derived"]][["spatial_plots"]][[4]]
</code></pre>

<hr>
<h2 id='ripleys_k'>Calculate Ripley's K</h2><span id='topic+ripleys_k'></span>

<h3>Description</h3>

<p>ripleys_k() calculates the emperical Ripley's K measurement for the cell types specified by mnames in the mIF object. This
is very useful when exploring the spatial clustering of single cell types on TMA cores or ROI spots following proccessing
with a program such as HALO for cell phenotyping.
</p>
<p>In the 'ripleys_k' function, there is the ability to perform permutations in order to assess whether the clustering
of a cell type is significant, or the ability to derive the exact CSR and forgo permutations for much faster sample
processing. Permutations can be helpful if the significance of clustering wasnts to be identified - run 1000 permutations 
and if observed is outside 95-percentile then significant clustering. We, however, recommend using the exact CSR estimate
due to speed.
</p>
<p>Some things to be aware of when computing the exact Ripley's K estimate, if your spatial file is greater than 
the &lsquo;big' size, the edge correction will be converted to &rsquo;none' in order to save on resources and compute time. 
Due to the introduction of Whole Slide Imaging (WSI), this can easily be well over 1,000,000 cells, and calculating 
edge correction for these spatial files will not succeed when attempting to force an edge correction on it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ripleys_k(
  mif,
  mnames,
  r_range = seq(0, 100, 1),
  num_permutations = 50,
  edge_correction = "translation",
  method = "K",
  permute = FALSE,
  keep_permutation_distribution = FALSE,
  workers = 1,
  overwrite = FALSE,
  xloc = NULL,
  yloc = NULL,
  big = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ripleys_k_+3A_mif">mif</code></td>
<td>
<p>object of class 'mif' created with 'create_mif'</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_mnames">mnames</code></td>
<td>
<p>cell phenotype markers to calculate Ripley's K for</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_r_range">r_range</code></td>
<td>
<p>radius range (including 0)</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_num_permutations">num_permutations</code></td>
<td>
<p>number of permutations to use to estimate CSR. If 'keep_perm_dis' is set to FALSE, this will be ignored</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_edge_correction">edge_correction</code></td>
<td>
<p>edge correction method to pass to &lsquo;Kest'. can take one of &quot;translation&quot;, &quot;isotropic&quot;, &quot;none&quot;, or &rsquo;border'</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_method">method</code></td>
<td>
<p>not used currently</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_permute">permute</code></td>
<td>
<p>whether to use CSR estimate or use permutations to determine CSR</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_keep_permutation_distribution">keep_permutation_distribution</code></td>
<td>
<p>whether to find mean of permutation distribution or each
permutation calculation</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_workers">workers</code></td>
<td>
<p>number of cores to use for calculations</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite the 'univariate_Count' slot within 'mif$derived'</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_xloc">xloc</code></td>
<td>
<p>the location of the center of cells. If left 'NULL', 'XMin', 'XMax', 'YMin', and 'YMax' must be present.</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_yloc">yloc</code></td>
<td>
<p>the location of the center of cells. If left 'NULL', 'XMin', 'XMax', 'YMin', and 'YMax' must be present.</p>
</td></tr>
<tr><td><code id="ripleys_k_+3A_big">big</code></td>
<td>
<p>the number of cells at which to flip from an edge correction method other than 'none' to 'none' due to size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'mif'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- spatialTIME::create_mif(clinical_data =spatialTIME::example_clinical %&gt;% 
  dplyr::mutate(deidentified_id = as.character(deidentified_id)),
  sample_data = spatialTIME::example_summary %&gt;% 
  dplyr::mutate(deidentified_id = as.character(deidentified_id)),
  spatial_list = spatialTIME::example_spatial,
  patient_id = "deidentified_id", 
  sample_id = "deidentified_sample")
mnames = x$spatial[[1]] %&gt;%
  colnames() %&gt;%
  grep("Pos|CD", ., value =TRUE) %&gt;%
  grep("Cyto|Nucle", ., value =TRUE, invert =TRUE)
x2 = ripleys_k(mif = x, 
  mnames = mnames[1], 
  r_range = seq(0, 100, 1), 
  num_permutations = 100,
  edge_correction = "translation", 
  method = "K", 
  permute = FALSE,
  keep_permutation_distribution =FALSE, 
  workers = 1, 
  overwrite =TRUE)
</code></pre>

<hr>
<h2 id='subset_mif'>Subset mif object on cellular level</h2><span id='topic+subset_mif'></span>

<h3>Description</h3>

<p>This function allows to subset the mif object into compartments. 
For instance a mif object includes all cells and the desired analysis is based
on only the tumor or stroma compartment then this function will subset the 
spatial list to just the cells in the desired compartment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_mif(mif, classifier, level, markers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_mif_+3A_mif">mif</code></td>
<td>
<p>An MIF object</p>
</td></tr>
<tr><td><code id="subset_mif_+3A_classifier">classifier</code></td>
<td>
<p>Column name for spatial dataframe to subset</p>
</td></tr>
<tr><td><code id="subset_mif_+3A_level">level</code></td>
<td>
<p>Determines which level of the classifier to keep.</p>
</td></tr>
<tr><td><code id="subset_mif_+3A_markers">markers</code></td>
<td>
<p>vector of</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mif object where the spatial list only as the cell that are the specified level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' #Create mif object
library(dplyr)
x &lt;- create_mif(clinical_data = example_clinical %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
sample_data = example_summary %&gt;% 
mutate(deidentified_id = as.character(deidentified_id)),
spatial_list = example_spatial,
patient_id = "deidentified_id", 
sample_id = "deidentified_sample")

markers = c("CD3..Opal.570..Positive","CD8..Opal.520..Positive",
"FOXP3..Opal.620..Positive","PDL1..Opal.540..Positive",
"PD1..Opal.650..Positive","CD3..CD8.","CD3..FOXP3.")

mif_tumor = subset_mif(mif = x, classifier = 'Classifier.Label', 
level = 'Tumor', markers = markers)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
