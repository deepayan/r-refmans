<!DOCTYPE html><html><head><title>Help for package smfishHmrf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smfishHmrf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkErrors'><p>checkErrors</p></a></li>
<li><a href='#checkErrorsMulti'><p>checkErrorsMulti</p></a></li>
<li><a href='#checkStopVerbose'><p>checkStopVerbose</p></a></li>
<li><a href='#checkStopVerboseMulti'><p>checkStopVerboseMulti</p></a></li>
<li><a href='#findDampFactor'><p>findDampFactor</p></a></li>
<li><a href='#getDen'><p>getDen</p></a></li>
<li><a href='#initialIndices'><p>initialIndices</p></a></li>
<li><a href='#initialIndicesMulti'><p>initialIndicesMulti</p></a></li>
<li><a href='#relerr'><p>relerr</p></a></li>
<li><a href='#relerr.multi'><p>relerr.multi</p></a></li>
<li><a href='#seqfishplus'><p>SeqFISHplus dataset</p></a></li>
<li><a href='#smfishHmrf'><p>smfishHmrf: A package for running hidden markov random field on smFISH and other spatial transcriptomic datasets</p></a></li>
<li><a href='#smfishHmrf.generate.centroid'><p>Generate cluster centroids, where input is given as a matrix.</p></a></li>
<li><a href='#smfishHmrf.generate.centroid.it'><p>Generate cluster centroids, where input is a file.</p></a></li>
<li><a href='#smfishHmrf.generate.centroid.save'><p>Save the cluster centroids to file</p></a></li>
<li><a href='#smfishHmrf.generate.centroid.use.exist'><p>Use existing cluster centroids</p></a></li>
<li><a href='#smfishHmrf.hmrfem'><p>smfishHmrf.hmrfem</p></a></li>
<li><a href='#smfishHmrf.hmrfem.multi'><p>Performs HMRF for multivariate normal distribution. Accepts R data structures as inputs. Accepts a single beta.</p></a></li>
<li><a href='#smfishHmrf.hmrfem.multi.it'><p>Perform HMRF for multivariate normal distribution. Accepts R data structures as inputs. Accepts multiple betas.</p></a></li>
<li><a href='#smfishHmrf.hmrfem.multi.it.min'><p>Perform HMRF on multivariate normal distributions. Accepts file names as inputs. Accepts multiple betas.</p></a></li>
<li><a href='#smfishHmrf.hmrfem.multi.save'><p>Save the HMRF result</p></a></li>
<li><a href='#smfishHmrf.read.expression'><p>smfishHmrf.read.expression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Hidden Markov Random Field for Spatial Transcriptomic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Qian Zhu and Guo-Cheng Yuan</td>
</tr>
<tr>
<td>Description:</td>
<td>Discovery of spatial patterns with Hidden Markov Random Field. This package is designed for spatial transcriptomic data and single molecule fluorescent in situ hybridization (FISH) data such as sequential fluorescence in situ hybridization (seqFISH) and multiplexed error-robust fluorescence in situ hybridization (MERFISH). The methods implemented in this package are described in Zhu et al. (2018) &lt;<a href="https://doi.org/10.1038%2Fnbt.4260">doi:10.1038/nbt.4260</a>&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Qian Zhu &lt;zqian@jimmy.harvard.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), pracma(&ge; 1.9.0), fs(&ge; 1.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bitbucket.org/qzhudfci/smfishhmrf-r/src/master/">https://bitbucket.org/qzhudfci/smfishhmrf-r/src/master/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://bitbucket.org/qzhudfci/smfishhmrf-r/issues">https://bitbucket.org/qzhudfci/smfishhmrf-r/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-26 16:09:45 UTC; qzhu</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-03 12:20:02 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
</table>
<hr>
<h2 id='checkErrors'>checkErrors</h2><span id='topic+checkErrors'></span>

<h3>Description</h3>

<p>check errors in mu and sigma (single variate)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkErrors(mu, sigma, err = NULL)
</code></pre>

<hr>
<h2 id='checkErrorsMulti'>checkErrorsMulti</h2><span id='topic+checkErrorsMulti'></span>

<h3>Description</h3>

<p>check errors in mu and sigma (multivariate)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkErrorsMulti(mu, sigma, err = NULL)
</code></pre>

<hr>
<h2 id='checkStopVerbose'>checkStopVerbose</h2><span id='topic+checkStopVerbose'></span>

<h3>Description</h3>

<p>check whether or not to stop (i.e. convergence)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkStopVerbose(muold, mu, sigmaold, sigma, err, it, maxit, verbose)
</code></pre>

<hr>
<h2 id='checkStopVerboseMulti'>checkStopVerboseMulti</h2><span id='topic+checkStopVerboseMulti'></span>

<h3>Description</h3>

<p>check whether or not to stop (i.e. convergence) (multivariate)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkStopVerboseMulti(muold, mu, sigmaold, sigma, err, it, maxit, verbose)
</code></pre>

<hr>
<h2 id='findDampFactor'>findDampFactor</h2><span id='topic+findDampFactor'></span>

<h3>Description</h3>

<p>find dampening factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findDampFactor(sigma, factor = 1.05, d_cutoff = 1e-60, startValue = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findDampFactor_+3A_sigma">sigma</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="findDampFactor_+3A_factor">factor</code></td>
<td>
<p>step factor</p>
</td></tr>
<tr><td><code id="findDampFactor_+3A_d_cutoff">d_cutoff</code></td>
<td>
<p>determinant cutoff</p>
</td></tr>
<tr><td><code id="findDampFactor_+3A_startvalue">startValue</code></td>
<td>
<p>starting value to initialize the finding</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(seqfishplus)
k&lt;-dim(seqfishplus$mu)[2]
damp&lt;-array(0, c(k))
for(i in 1:k){
    di&lt;-findDampFactor(seqfishplus$sigma[,,i], factor=1.05, d_cutoff=1e-5, startValue=0.0001)
    damp[i]&lt;-ifelse(is.null(di), 0, di)
} 
</code></pre>

<hr>
<h2 id='getDen'>getDen</h2><span id='topic+getDen'></span>

<h3>Description</h3>

<p>calculate density given multivariate normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDen(yunique, n.yunique, ymatch, mu, sigma)
</code></pre>

<hr>
<h2 id='initialIndices'>initialIndices</h2><span id='topic+initialIndices'></span>

<h3>Description</h3>

<p>initialize indices in the table (single variate)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialIndices(y, nvert, mu, sigma, k)
</code></pre>

<hr>
<h2 id='initialIndicesMulti'>initialIndicesMulti</h2><span id='topic+initialIndicesMulti'></span>

<h3>Description</h3>

<p>initialize indices for multivariate scenario
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialIndicesMulti(
  y,
  mu,
  sigma,
  k,
  dampFactor = NULL,
  forceDetectDamp = FALSE
)
</code></pre>

<hr>
<h2 id='relerr'>relerr</h2><span id='topic+relerr'></span>

<h3>Description</h3>

<p>compute the relative errors (single variate)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relerr(x, y)
</code></pre>

<hr>
<h2 id='relerr.multi'>relerr.multi</h2><span id='topic+relerr.multi'></span>

<h3>Description</h3>

<p>relative errors for multivariate scenario
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relerr.multi(x, y)
</code></pre>

<hr>
<h2 id='seqfishplus'>SeqFISHplus dataset</h2><span id='topic+seqfishplus'></span>

<h3>Description</h3>

<p>Data from SeqFISH experiment on SS cortex. This is a dataset with 523 cells and the expression of about 500 spatial genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seqfishplus)
</code></pre>


<h3>Format</h3>

<p>A list containing the following fields: y, nei, blocks, damp, mu, sigma
</p>

<dl>
<dt>y</dt><dd><p>gene expression matrix</p>
</dd>
<dt>nei</dt><dd><p>cell adjacency matrix</p>
</dd>
<dt>blocks</dt><dd><p>vertex (or cell) update order; a list of vertex colors; cells marked with the same color are updated at once</p>
</dd>
<dt>damp</dt><dd><p>dampening constants (length k, the number of clusters)</p>
</dd>
<dt>mu</dt><dd><p>initialization (means). Means is a (i,k) matrix</p>
</dd>
<dt>sigma</dt><dd><p>initialization (sigmas). Sigmas is a (i,j,k) 3D matrix. k is cluster id. (i,j) is covariance matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Eng CL, Lawson M, Zhu Q, Dries R, Koulena N, Takei Y, Yun J, Cronin C, Karp C, Yuan G, Cai L (2019-Apr-01).
&ldquo;Transcriptome-scale super-resolved imaging in tissues by RNA seqFISH+.&rdquo;
<em>Nature</em>, <b>568</b>, 235&ndash;239.
doi: <a href="https://doi.org/10.1038/s41586-019-1049-y">10.1038/s41586-019-1049-y</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(seqfishplus)
</code></pre>

<hr>
<h2 id='smfishHmrf'>smfishHmrf: A package for running hidden markov random field on smFISH and other spatial transcriptomic datasets</h2><span id='topic+smfishHmrf'></span>

<h3>Description</h3>

<p>A package for running hidden markov random field (Zhu et al. 2018-Dec-01) on smFISH and other spatial transcriptomic datasets.
</p>


<h3>Input</h3>

<p>The inputs of HMRF are the following:
</p>

<ul>
<li><p> Gene expression matrix
</p>
</li>
<li><p> Cell neighborhood matrix
</p>
</li>
<li><p> Initial centroids of clusters
</p>
</li>
<li><p> Number of clusters
</p>
</li>
<li><p> beta
</p>
</li></ul>

<p>smfishHmrf has been tested to work on seqFISH, MERFISH, starMAP, 10X Visium and other datasets. See Giotto (Dries et al. 2020) for examples of such datasets and to learn about the technologies.
smfishHmrf is a general algorithm, and should probably work with other data types.
</p>


<h3>Running</h3>

<p>The first step is to calculate initial centroids on the gene expression matrix given k (the number of clusters). The function <strong>smfishHmrf.generate.centroid.it</strong> is used for this purpose.
</p>
<p>The next step is to run the HMRF algorithm given the expression matrix, and cell neighborhood matrix. The function <strong>smfishHmrf.hmrfem.multi.it.min</strong> is used for this purpose.
</p>


<h3>Variations</h3>

<p>You might notice several variations of the functions:
</p>

<ul>
<li> <p><code>smfishHmrf.hmrfem.multi.it.min</code>: supports multiple betas; supports file names as inputs. <strong>This is the recommended function.</strong>
</p>
</li>
<li> <p><code>smfishHmrf.hmrfem.multi.it</code>: supports multiple betas; supports R data structures as inputs.
</p>
</li>
<li> <p><code>smfishHmrf.hmrfem.multi</code>: supports a single beta; supports R data structures as inputs.
</p>
</li>
<li><p> Note: beta is the smoothness parameter of HMRF
</p>
</li></ul>

<p>Also:
</p>

<ul>
<li> <p><code>smfishHmrf.generate.centroid.it</code>: supports file names as inputs. <strong>This is the recommended function</strong>
</p>
</li>
<li> <p><code>smfishHmrf.generate.centroid</code>: supports R matrices as inputs. Assumes input files have been read into R matrices.
</p>
</li>
<li> <p><code>smfishHmrf.generate.centroid.use.exist</code>: loads existing centroids. Assumes that centroids have been generated previously and saved to disk.
</p>
</li></ul>



<h3>References</h3>

<p>Zhu Q, Shah S, Dries R, Cai L, Yuan G (2018-Dec-01).
&ldquo;Identification of spatially associated subpopulations by combining scRNAseq and sequential fluorescence in situ hybridization data.&rdquo;
<em>Nature Biotechnology</em>, <b>36</b>, 1183&ndash;1190.
doi: <a href="https://doi.org/10.1038/nbt.4260">10.1038/nbt.4260</a>.
</p>
<p>Dries R, Zhu Q, Dong R, Eng CL, Li H, Liu K, Fu Y, Zhao T, Sarkar A, Bao F, George RE, Pierson N, Cai L, Yuan G (2020).
&ldquo;Giotto, a toolbox for integrative analysis and visualization of spatial expression data.&rdquo;
<em>bioRxiv</em>.
doi: <a href="https://doi.org/10.1101/701680">10.1101/701680</a>.
</p>

<hr>
<h2 id='smfishHmrf.generate.centroid'>Generate cluster centroids, where input is given as a matrix.</h2><span id='topic+smfishHmrf.generate.centroid'></span>

<h3>Description</h3>

<p>This function assumes that the input gene expression matrix file has been already loaded into a matrix. The function accepts a matrix and applies kmeans clustering to generate cluster centroids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smfishHmrf.generate.centroid(y, par_k, par_seed = -1, nstart)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smfishHmrf.generate.centroid_+3A_y">y</code></td>
<td>
<p>expression matrix</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid_+3A_par_k">par_k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid_+3A_par_seed">par_seed</code></td>
<td>
<p>random generator seed (to fix it set it to above 0, or -1 if no fixing). Change the par_seed to vary the initialization.</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid_+3A_nstart">nstart</code></td>
<td>
<p>number of starts (kmeans parameter). It is recommended to set nstart to at least 100 (preferrably 1000).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A kmeans list with centers and cluster fields
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(seqfishplus)
kk&lt;-smfishHmrf.generate.centroid(seqfishplus$y, par_k=9, par_seed=100, nstart=100)
</code></pre>

<hr>
<h2 id='smfishHmrf.generate.centroid.it'>Generate cluster centroids, where input is a file.</h2><span id='topic+smfishHmrf.generate.centroid.it'></span>

<h3>Description</h3>

<p>This function generates cluster centroids from applying kmeans. It accepts an expression matrix file as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smfishHmrf.generate.centroid.it(
  expr_file,
  par_k,
  par_seed = -1,
  nstart,
  name = "test",
  output_dir = "."
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smfishHmrf.generate.centroid.it_+3A_expr_file">expr_file</code></td>
<td>
<p>expression matrix file. The expression file should be a space-separated file. The rows are genes. The columns are cells. There is no header row. The first column is a gene index (ranges from 1 to the number of genes). Note the first column is not gene name.</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid.it_+3A_par_k">par_k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid.it_+3A_par_seed">par_seed</code></td>
<td>
<p>random generator seed (-1 if no fixing). Change the par_seed to vary the initialization.</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid.it_+3A_nstart">nstart</code></td>
<td>
<p>number of starts (kmeans). It is recommended to set nstart to at least 100 (preferrably 1000).</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid.it_+3A_name">name</code></td>
<td>
<p>name of this run</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid.it_+3A_output_dir">output_dir</code></td>
<td>
<p>output directory; where to store the kmeans results</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that after running kmeans step, the function also automatically saves the kmeans results to the <code>output_dir</code> directory. The results will be found in two files:
</p>

<ol>
<li> <p><code>{output_dir}</code>/k_<code>{par_k}</code>/f<code>{name}</code>.gene.ALL.centroid.txt
</p>
</li>
<li> <p><code>{output_dir}</code>/k_<code>{par_k}</code>/f<code>{name}</code>.gene.ALL.kmeans.txt
</p>
</li></ol>

<p>where <code>{}</code> refers to the value of parameters.
</p>


<h3>Value</h3>

<p>A kmeans object which is a list with centers and cluster fields
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mem_file = system.file("extdata", "ftest.expression.txt", package="smfishHmrf")
kk = smfishHmrf.generate.centroid.it(mem_file, par_k=9, par_seed=100, 
    nstart=100, name="test", output_dir=tempdir())
</code></pre>

<hr>
<h2 id='smfishHmrf.generate.centroid.save'>Save the cluster centroids to file</h2><span id='topic+smfishHmrf.generate.centroid.save'></span>

<h3>Description</h3>

<p>This function is run after the kmeans step. It takes a kmeans object (containing the kmeans result) as input and save the cluster centroids to file.
</p>
<p>Note that the location of saving and the file names are decided by the following rule:
</p>

<ol>
<li> <p><code>{output_dir}</code>/k_<code>{par_k}</code>/f<code>{name}</code>.gene.ALL.centroid.txt
</p>
</li>
<li> <p><code>{output_dir}</code>/k_<code>{par_k}</code>/f<code>{name}</code>.gene.ALL.kmeans.txt
</p>
</li></ol>

<p>where <code>{}</code> refers to the value of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smfishHmrf.generate.centroid.save(kk, name = "test", output_dir = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smfishHmrf.generate.centroid.save_+3A_kk">kk</code></td>
<td>
<p>kmeans object</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid.save_+3A_name">name</code></td>
<td>
<p>name of the run</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid.save_+3A_output_dir">output_dir</code></td>
<td>
<p>output directory; where to save the results</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>expr_file = system.file("extdata", "ftest.expression.txt", package="smfishHmrf")
y&lt;-smfishHmrf.read.expression(expr_file)
kk = smfishHmrf.generate.centroid(y, par_k=9, par_seed=100, nstart=100)
smfishHmrf.generate.centroid.save(kk, name="test", output_dir=tempdir())
</code></pre>

<hr>
<h2 id='smfishHmrf.generate.centroid.use.exist'>Use existing cluster centroids</h2><span id='topic+smfishHmrf.generate.centroid.use.exist'></span>

<h3>Description</h3>

<p>This function assumes that cluster centroids have already been generated from previously applying kmeans on the dataset. The results should have been saved. It will load cluster centroids from existing clustering result files. The results should be found in <code>input_dir</code> directory. The function looks for the following two kmeans result files:
</p>

<ol>
<li> <p><code>{input_dir}</code>/k_<code>{par_k}</code>/f<code>{name}</code>.gene.ALL.centroid.txt
</p>
</li>
<li> <p><code>{input_dir}</code>/k_<code>{par_k}</code>/f<code>{name}</code>.gene.ALL.kmeans.txt
</p>
</li></ol>

<p>where <code>{}</code> refers to the value of parameters down below
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smfishHmrf.generate.centroid.use.exist(name = "test", input_dir = ".", par_k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smfishHmrf.generate.centroid.use.exist_+3A_name">name</code></td>
<td>
<p>name of this run</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid.use.exist_+3A_input_dir">input_dir</code></td>
<td>
<p>input directory</p>
</td></tr>
<tr><td><code id="smfishHmrf.generate.centroid.use.exist_+3A_par_k">par_k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A kmeans object which is a list with centers and cluster fields
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_results = system.file("extdata", package="smfishHmrf")
kk = smfishHmrf.generate.centroid.use.exist(name="test", input_dir=kmeans_results, par_k=9)
</code></pre>

<hr>
<h2 id='smfishHmrf.hmrfem'>smfishHmrf.hmrfem</h2><span id='topic+smfishHmrf.hmrfem'></span>

<h3>Description</h3>

<p>HMRF for single variate normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smfishHmrf.hmrfem(
  y,
  neighbors,
  numnei,
  blocks,
  beta = 0.5,
  mu,
  sigma,
  err = 1e-04,
  maxit = 20,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smfishHmrf.hmrfem_+3A_y">y</code></td>
<td>
<p>gene expression matrix</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem_+3A_neighbors">neighbors</code></td>
<td>
<p>adjacency matrix between cells</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem_+3A_numnei">numnei</code></td>
<td>
<p>an array of number of neighbors per cell</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem_+3A_blocks">blocks</code></td>
<td>
<p>a list of cell colors for deciding the order of cell update</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem_+3A_beta">beta</code></td>
<td>
<p>the beta to try (smoothness parameter)</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem_+3A_mu">mu</code></td>
<td>
<p>an array of cluster mean</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem_+3A_sigma">sigma</code></td>
<td>
<p>an array of cluster standard deviation</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem_+3A_err">err</code></td>
<td>
<p>the error that is allowed between successive iterations</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of prob, new mu, and new sigma after iterations finish
</p>

<hr>
<h2 id='smfishHmrf.hmrfem.multi'>Performs HMRF for multivariate normal distribution. Accepts R data structures as inputs. Accepts a single beta.</h2><span id='topic+smfishHmrf.hmrfem.multi'></span>

<h3>Description</h3>

<p>This function performs HMRF (Zhu et al. 2018-Dec-01) on multivariate normal distributions. Different from other variations, this function accepts R data structures directly as inputs, and only accepts a single value of beta.
</p>
<p>This function exists for legacy and compatibility reason. User should use <strong>smfishHmrf.hmrfem.multi.it.min</strong> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smfishHmrf.hmrfem.multi(
  y,
  neighbors,
  numnei,
  blocks,
  beta = 0.5,
  mu,
  sigma,
  err = 1e-07,
  maxit = 50,
  verbose,
  dampFactor = NULL,
  forceDetectDamp = FALSE,
  tolerance = 1e-60
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_y">y</code></td>
<td>
<p>gene expression matrix</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_neighbors">neighbors</code></td>
<td>
<p>adjacency matrix between cells</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_numnei">numnei</code></td>
<td>
<p>a vector containing number of neighbors per cell</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_blocks">blocks</code></td>
<td>
<p>a list of cell colors for deciding the order of cell update</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_beta">beta</code></td>
<td>
<p>the beta to try (smoothness parameter)</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_mu">mu</code></td>
<td>
<p>a 2D matrix (i,j) of cluster mean (initialization)</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_sigma">sigma</code></td>
<td>
<p>a 3D matrix (i,j,k) where (i,j) is the covariance of cluster k (initialization)</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_err">err</code></td>
<td>
<p>the error that is allowed between successive iterations</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_dampfactor">dampFactor</code></td>
<td>
<p>the dampening factor</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_forcedetectdamp">forceDetectDamp</code></td>
<td>
<p>will auto detect a dampening factor instead of using the specified one</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi_+3A_tolerance">tolerance</code></td>
<td>
<p>applicable when forceDetectDamp is set to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of prob, new mu, new sigma, unnormalized prob after iterations finish
</p>


<h3>More information</h3>

<p>Arguments mu and sigma refer to the cluster centroids from running kmeans algorithm.
They serve as initialization of HMRF.
Users should refer to <strong>smfishHmrf.hmrfem.multi.it.min</strong> for more information about function parameters and the requirements.
</p>


<h3>References</h3>

<p>Zhu Q, Shah S, Dries R, Cai L, Yuan G (2018-Dec-01).
&ldquo;Identification of spatially associated subpopulations by combining scRNAseq and sequential fluorescence in situ hybridization data.&rdquo;
<em>Nature Biotechnology</em>, <b>36</b>, 1183&ndash;1190.
doi: <a href="https://doi.org/10.1038/nbt.4260">10.1038/nbt.4260</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(seqfishplus)
    s &lt;- seqfishplus
    res&lt;-smfishHmrf.hmrfem.multi(s$y, s$nei, s$numnei, s$blocks, beta=28, 
    mu=s$mu, sigma=s$sigma, err=1e-7, maxit=50, verbose=TRUE, dampFactor=s$damp, 
    tolerance=1e-5)
</code></pre>

<hr>
<h2 id='smfishHmrf.hmrfem.multi.it'>Perform HMRF for multivariate normal distribution. Accepts R data structures as inputs. Accepts multiple betas.</h2><span id='topic+smfishHmrf.hmrfem.multi.it'></span>

<h3>Description</h3>

<p>This function performs HMRF model (Zhu et al. 2018-Dec-01) on inputs which are directly R data structures. Different from smfishHmrf.hmrfem.multi, this function iterates over multiple betas rather than a single beta. Different from smfishHmrf.hmrfem.multi.it.min, this function accepts R data structures (i.e. parameters y, nei, blocks) as inputs to the function rather than accepting file names. This function will save the results of HMRF to the output directory. It will return void.
</p>
<p>This function exists for legacy and compatibility reason. User should use <strong>smfishHmrf.hmrfem.multi.it.min</strong> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smfishHmrf.hmrfem.multi.it(
  name,
  outdir,
  k,
  y,
  nei,
  beta = 0,
  beta_increment = 1,
  beta_num_iter = 10,
  numnei,
  blocks,
  mu,
  sigma,
  damp
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_name">name</code></td>
<td>
<p>name for this run (eg test)</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_outdir">outdir</code></td>
<td>
<p>output directory</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_k">k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_y">y</code></td>
<td>
<p>gene expression matrix</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_nei">nei</code></td>
<td>
<p>adjacency matrix between cells</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_beta">beta</code></td>
<td>
<p>initial beta</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_beta_increment">beta_increment</code></td>
<td>
<p>beta increment</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_beta_num_iter">beta_num_iter</code></td>
<td>
<p>number of betas to try</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_numnei">numnei</code></td>
<td>
<p>a vector containing number of neighbors per cell</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_blocks">blocks</code></td>
<td>
<p>a list of cell colors for deciding the order of cell update</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_mu">mu</code></td>
<td>
<p>a 2D matrix (i,j) of cluster mean (initialization)</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_sigma">sigma</code></td>
<td>
<p>a 3D matrix (i,j,k) where (i,j) is the covariance of cluster k (initialization)</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it_+3A_damp">damp</code></td>
<td>
<p>a list of dampening factors (length = k)</p>
</td></tr>
</table>


<h3>More information</h3>

<p>Arguments mu and sigma refer to the cluster centroids from running kmeans algorithm.
They serve as initialization of HMRF.
Users should refer to <strong>smfishHmrf.hmrfem.multi.it.min</strong> for more information about function parameters and the requirements.
</p>


<h3>References</h3>

<p>Zhu Q, Shah S, Dries R, Cai L, Yuan G (2018-Dec-01).
&ldquo;Identification of spatially associated subpopulations by combining scRNAseq and sequential fluorescence in situ hybridization data.&rdquo;
<em>Nature Biotechnology</em>, <b>36</b>, 1183&ndash;1190.
doi: <a href="https://doi.org/10.1038/nbt.4260">10.1038/nbt.4260</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y&lt;-as.matrix(read.table(system.file("extdata", "ftest.expression.txt", 
    package="smfishHmrf"), header=FALSE, row.names=1))
nei&lt;-as.matrix(read.table(system.file("extdata", "ftest.adjacency.txt", 
    package="smfishHmrf"), header=FALSE, row.names=1))
colnames(nei)&lt;-NULL; rownames(nei)&lt;-NULL
blocks&lt;-c(t(read.table(system.file("extdata", "ftest.blocks.txt", 
    package="smfishHmrf"), header=FALSE, row.names=1)))
blocks&lt;-lapply(1:max(blocks), function(x) which(blocks == x))
numnei&lt;-apply(nei, 1, function(x) sum(x!=-1))
k&lt;-9
kmeans_results = system.file("extdata", package="smfishHmrf")
kk = smfishHmrf.generate.centroid.use.exist(name="test", input_dir=kmeans_results, k)
numcell&lt;-dim(y)[1]; m&lt;-dim(y)[2]
mu&lt;-t(kk$centers) #should be dimension (m,k)
lclust&lt;-lapply(1:k, function(x) which(kk$cluster == x))
damp&lt;-array(0, c(k)); sigma&lt;-array(0, c(m,m,k))
for(i in 1:k){
    sigma[, , i] &lt;- cov(y[lclust[[i]], ])
    di&lt;-findDampFactor(sigma[,,i], factor=1.05, d_cutoff=1e-5, startValue=0.0001)
    damp[i]&lt;-ifelse(is.null(di), 0, di)
} 
smfishHmrf.hmrfem.multi.it(name="test", outdir=tempdir(), k=k, y=y, nei=nei, 
    beta=28, beta_increment=2, beta_num_iter=1, numnei=numnei, blocks=blocks, 
    mu=mu, sigma=sigma, damp=damp)

## Not run: 
# alternatively, to test a larger set of betas:
smfishHmrf.hmrfem.multi.it(name="test", outdir=tempdir(), k=k, y=y, nei=nei, 
    beta=0, beta_increment=2, beta_num_iter=20, numnei=numnei, blocks=blocks, 
    mu=mu, sigma=sigma, damp=damp)

## End(Not run)


</code></pre>

<hr>
<h2 id='smfishHmrf.hmrfem.multi.it.min'>Perform HMRF on multivariate normal distributions. Accepts file names as inputs. Accepts multiple betas.</h2><span id='topic+smfishHmrf.hmrfem.multi.it.min'></span>

<h3>Description</h3>

<p>This function performs HMRF (Zhu et al. 2018-Dec-01) for multi variate normal distributions. It takes minimum required inputs (inputs being file names). There are a couple of files required:
</p>

<ol>
<li><p> a file containing expression matrix
</p>
</li>
<li><p> a file containing cell neighborhood matrix
</p>
</li>
<li><p> a file containing node (or cell) color. This is used for updating cells during HMRF iterations.
</p>
</li></ol>

<p>HMRF needs users to specify the initializations of parameters (mu and sigma). It is recommended to use the kmeans centroids as initializations (specified by <code>kk</code> parameter). Note: kmeans should be run prior to this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smfishHmrf.hmrfem.multi.it.min(
  mem_file,
  nei_file,
  block_file,
  kk,
  par_k,
  name = "test",
  output_dir = ".",
  tolerance = 1e-05,
  beta = 0,
  beta_increment = 1,
  beta_num_iter = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smfishHmrf.hmrfem.multi.it.min_+3A_mem_file">mem_file</code></td>
<td>
<p>expression file. The expression file should be a space-separated file. The rows are genes. The columns are cells. There is no header row. The first column is a gene index (ranges from 1 to the number of genes). Note the first column is not gene name. See section <strong>Data preprocessing</strong> for which form of expression works best.</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it.min_+3A_nei_file">nei_file</code></td>
<td>
<p>file containing cell neighborhood matrix. This should be a space-separated file. The rows are cells. The columns are neighbors. There is no header row. The first column is the cell index (1 to number of cells). Each row lists the indices of neighbor cells. The dimension of the cell neighborhood matrix is (num_cell, max_num_neighbors). If a cell does not have enough neighbors, the remaining entries of that row is padded with -1. The R package Giotto <a href="http://spatialgiotto.com">http://spatialgiotto.com</a> (Dries et al. 2020) contains a number of functions for generating the cell neighborhood network.</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it.min_+3A_block_file">block_file</code></td>
<td>
<p>file containing cell colors (which determines cell update order). The order of updating the state probabilities of each cell can matter the result. Cells (or nodes) and their immediate neighbors are not updated at the same time. This is akin to the vertex coloring problem. This file contains the color of each cell such that no two neighbor cells have the same color. The file is 2-column, space-separated. Column 1 is cell ID, and column 2 is the cell color (integer starting at 1). The python utility get_vertex_color.py <a href="https://bitbucket.org/qzhudfci/smfishhmrf-py/src/master/get_vertex_color.py">https://bitbucket.org/qzhudfci/smfishhmrf-py/src/master/get_vertex_color.py</a> (requires smfishHmrf-py package <a href="https://pypi.org/project/smfishHmrf/">https://pypi.org/project/smfishHmrf/</a>) can generate this file.</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it.min_+3A_kk">kk</code></td>
<td>
<p>kmeans results (object returned by kmeans). Kmeans (one of functions smfishHmrf.generate.centroid.it or smfishHmrf.generate.centroid) should be run before this function.</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it.min_+3A_par_k">par_k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it.min_+3A_name">name</code></td>
<td>
<p>name for this run (eg test)</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it.min_+3A_output_dir">output_dir</code></td>
<td>
<p>output directory</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it.min_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.it.min_+3A_beta">beta</code>, <code id="smfishHmrf.hmrfem.multi.it.min_+3A_beta_increment">beta_increment</code>, <code id="smfishHmrf.hmrfem.multi.it.min_+3A_beta_num_iter">beta_num_iter</code></td>
<td>
<p>3 values specifying the range of betas to try: the initial beta, the beta increment, and the number of betas. Beta is the smoothness parameter. Example: <code>beta</code>=0, <code>beta_increment</code>=2, <code>beta_num_iter</code>=6 means to try betas: 0, 2, 4, 6, 8, 10. See section <strong>Betas</strong> for more information.</p>
</td></tr>
</table>


<h3>Data preprocessing</h3>

<p>It assumes that the expression values follow a multivariate gaussian distribution. We generally recommend using <strong>log2 transformed counts further normalized by z-scores (in both x- and y- dimensions)</strong>. Double z-scoring this way helps to remove the inherent bias of zscoring just one dimension (as the results might present a bias towards cell counts).
</p>


<h3>Betas</h3>

<p>Beta is the smoothness parameter in HMRF. The higher the beta, the more the HMRF borrows information from the neighbors. This function runs HMRF across a range of betas. To decide which beta range, here are some guideline:
</p>

<ul>
<li><p> if the number of genes is from 10 to 50, the recommended range is 0 to 10 at beta increment of 0.5.
</p>
</li>
<li><p> if the number of genes is below 50, the recommended range is 0 to 15 at beta increment of 1.
</p>
</li>
<li><p> if the number of genes is between 50 to 100, the range is 0 to 50 at beta increment of 2.
</p>
</li>
<li><p> if the number of genes is between 100 and 500, the range is 0 to 100 at beta increment of 5.
</p>
</li></ul>

<p>Within the range of betas, we recommend selecting the best beta by the Bayes information criterion. This requires first performing randomization of spatial positions to generate the null distribution of log-likelihood scores for randomly distributed cells for the same range of betas. Then find the beta where the difference between the observed and the null log-likelihood is maximized.
</p>


<h3>Variations</h3>


<ul>
<li> <p><code>smfishHmrf.hmrfem.multi.it.min</code> (this function): supports multiple betas; supports file names as inputs. Recommended.
</p>
</li>
<li> <p><code>smfishHmrf.hmrfem.multi.it</code>: supports multiple betas; supports R data structures as inputs.
</p>
</li>
<li> <p><code>smfishHmrf.hmrfem.multi</code>: supports a single beta; supports R data structures as inputs.
</p>
</li></ul>



<h3>References</h3>

<p>Zhu Q, Shah S, Dries R, Cai L, Yuan G (2018-Dec-01).
&ldquo;Identification of spatially associated subpopulations by combining scRNAseq and sequential fluorescence in situ hybridization data.&rdquo;
<em>Nature Biotechnology</em>, <b>36</b>, 1183&ndash;1190.
doi: <a href="https://doi.org/10.1038/nbt.4260">10.1038/nbt.4260</a>.
</p>
<p>Eng CL, Lawson M, Zhu Q, Dries R, Koulena N, Takei Y, Yun J, Cronin C, Karp C, Yuan G, Cai L (2019-Apr-01).
&ldquo;Transcriptome-scale super-resolved imaging in tissues by RNA seqFISH+.&rdquo;
<em>Nature</em>, <b>568</b>, 235&ndash;239.
doi: <a href="https://doi.org/10.1038/s41586-019-1049-y">10.1038/s41586-019-1049-y</a>.
</p>
<p>Dries R, Zhu Q, Dong R, Eng CL, Li H, Liu K, Fu Y, Zhao T, Sarkar A, Bao F, George RE, Pierson N, Cai L, Yuan G (2020).
&ldquo;Giotto, a toolbox for integrative analysis and visualization of spatial expression data.&rdquo;
<em>bioRxiv</em>.
doi: <a href="https://doi.org/10.1101/701680">10.1101/701680</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mem_file = system.file("extdata", "ftest.expression.txt", package="smfishHmrf")
nei_file = system.file("extdata", "ftest.adjacency.txt", package="smfishHmrf")
block_file = system.file("extdata", "ftest.blocks.txt", package="smfishHmrf")
par_k = 9
name = "test"
output_dir = tempdir()
    
## Not run: 
kk = smfishHmrf.generate.centroid.it(mem_file, par_k, par_seed=100, 
nstart=100, name=name, output_dir=output_dir)

## End(Not run)

# alternatively, if you already have run kmeans before, you can load it directly
kmeans_results = system.file("extdata", package="smfishHmrf")
kk = smfishHmrf.generate.centroid.use.exist(name=name, input_dir=kmeans_results, par_k)

smfishHmrf.hmrfem.multi.it.min(mem_file, nei_file, block_file, kk, par_k, 
name=name, output_dir=output_dir, tolerance=1e-5, 
beta=28, beta_increment=2, beta_num_iter=1)
    
## Not run: 
# alternatively, to test a larger set of beta's
smfishHmrf.hmrfem.multi.it.min(mem_file, nei_file, block_file, kk, par_k,
name=name, output_dir=output_dir, tolerance=1e-5, 
beta=0, beta_increment=2, beta_num_iter=20)

## End(Not run)
 
</code></pre>

<hr>
<h2 id='smfishHmrf.hmrfem.multi.save'>Save the HMRF result</h2><span id='topic+smfishHmrf.hmrfem.multi.save'></span>

<h3>Description</h3>

<p>This function assumes that HMRF has been run via smfishHmrf.hmrfem.multi, smfishHmrf.hmrfem.multi.it or smfishHmrf.hmrfem.multi.it.min function. It assumes the results have been generated. This function saves the results of each beta to the output directory. It will return void.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smfishHmrf.hmrfem.multi.save(name, outdir, beta, tc.hmrfem, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smfishHmrf.hmrfem.multi.save_+3A_name">name</code></td>
<td>
<p>name for this run (eg test)</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.save_+3A_outdir">outdir</code></td>
<td>
<p>output directory</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.save_+3A_beta">beta</code></td>
<td>
<p>beta to save</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.save_+3A_tc.hmrfem">tc.hmrfem</code></td>
<td>
<p>the result of running of hmrfem on single beta (from smfishHmrf.hmrfem.multi)</p>
</td></tr>
<tr><td><code id="smfishHmrf.hmrfem.multi.save_+3A_k">k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(seqfishplus)
s &lt;- seqfishplus
tc.hmrfem&lt;-smfishHmrf.hmrfem.multi(s$y, s$nei, s$numnei, s$blocks, beta=28,
    mu=s$mu, sigma=s$sigma, err=1e-7, maxit=50, verbose=TRUE, dampFactor=s$damp,
    tolerance=1e-5)
smfishHmrf.hmrfem.multi.save(name="test", outdir=tempdir(), beta=28, tc.hmrfem=tc.hmrfem, k=9)
</code></pre>

<hr>
<h2 id='smfishHmrf.read.expression'>smfishHmrf.read.expression</h2><span id='topic+smfishHmrf.read.expression'></span>

<h3>Description</h3>

<p>Reads expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smfishHmrf.read.expression(expr_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smfishHmrf.read.expression_+3A_expr_file">expr_file</code></td>
<td>
<p>expression matrix file. The expression file should be a space-separated file. The rows are genes. The columns are cells. There is no header row. The first column is a gene index (ranges from 1 to the number of genes). Note the first column is not gene name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with gene expression matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expr_file = system.file("extdata", "ftest.expression.txt", package="smfishHmrf")
y&lt;-smfishHmrf.read.expression(expr_file)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
