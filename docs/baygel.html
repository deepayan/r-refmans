<!DOCTYPE html><html><head><title>Help for package baygel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {baygel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blockBAGENI'><p>Type I naive Bayesian adaptive graphical elastic net block Gibbs sampler for Gaussian graphical models.</p></a></li>
<li><a href='#blockBAGENII'><p>Type II naive Bayesian adaptive graphical elastic net block Gibbs sampler for Gaussian graphical models.</p></a></li>
<li><a href='#blockBAGL'><p>Bayesian adaptive graphical lasso block Gibbs sampler for Gaussian graphical models.</p></a></li>
<li><a href='#blockBAGR'><p>Bayesian adaptive graphical ridge block Gibbs sampler for Gaussian graphical models.</p></a></li>
<li><a href='#blockBGEN'><p>Naive Bayesian graphical elastic net block Gibbs sampler for Gaussian graphical models.</p></a></li>
<li><a href='#blockBGL'><p>Bayesian graphical lasso block Gibbs sampler for Gaussian graphical models.</p></a></li>
<li><a href='#blockBGR'><p>Bayesian graphical ridge block Gibbs sampler for Gaussian graphical models.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Shrinkage Estimators for Precision Matrices in Gaussian
Graphical Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-11</td>
</tr>
<tr>
<td>Description:</td>
<td>This R package offers block Gibbs samplers for the Bayesian (adaptive) graphical lasso, ridge, and naive elastic net priors. These samplers facilitate the simulation of the posterior distribution of precision matrices for Gaussian distributed data and were originally proposed by: Wang (2012) &lt;<a href="https://doi.org/10.1214%2F12-BA729">doi:10.1214/12-BA729</a>&gt;; Smith et al. (2022) &lt;<a href="https://doi.org/10.48550%2FarXiv.2210.16290">doi:10.48550/arXiv.2210.16290</a>&gt; and Smith et al. (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2306.14199">doi:10.48550/arXiv.2306.14199</a>&gt;, respectively.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8), RcppArmadillo (&ge; 0.11.1.1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, pracma</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Jarod-Smithy/baygel">https://github.com/Jarod-Smithy/baygel</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-11 10:22:48 UTC; qxz0gwg</td>
</tr>
<tr>
<td>Author:</td>
<td>Jarod Smith <a href="https://orcid.org/0000-0003-4235-6147"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Mohammad Arashi <a href="https://orcid.org/0000-0002-5881-9241"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Andriette Bekker <a href="https://orcid.org/0000-0003-4793-5674"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jarod Smith &lt;jarodsmith706@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-11 10:43:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='blockBAGENI'>Type I naive Bayesian adaptive graphical elastic net block Gibbs sampler for Gaussian graphical models.</h2><span id='topic+blockBAGENI'></span>

<h3>Description</h3>

<p>Implements the Type I naive Bayesian adaptive graphical elastic net block Gibbs sampler to simulate the
posterior distribution of the precision matrix for Gaussian graphical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockBAGENI(
  X,
  burnin,
  iterations,
  verbose = TRUE,
  r = 0.001,
  s = 0.01,
  a = 0.001,
  b = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockBAGENI_+3A_x">X</code></td>
<td>
<p>A numeric matrix, assumed to be generated from a multivariate Gaussian distribution.</p>
</td></tr>
<tr><td><code id="blockBAGENI_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBAGENI_+3A_iterations">iterations</code></td>
<td>
<p>An integer specifying the length of the Markov chain after the burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBAGENI_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining whether the progress of the MCMC sampler should be displayed.</p>
</td></tr>
<tr><td><code id="blockBAGENI_+3A_r">r</code></td>
<td>
<p>A double specifying the value of the shape parameter for the gamma prior associated with the Bayesian graphical lasso penalty term.</p>
</td></tr>
<tr><td><code id="blockBAGENI_+3A_s">s</code></td>
<td>
<p>A double specifying the value of the scale parameter for the gamma prior associated with the Bayesian graphical lasso penalty term.</p>
</td></tr>
<tr><td><code id="blockBAGENI_+3A_a">a</code></td>
<td>
<p>A double specifying the value of the shape parameter for the inverse gamma prior associated with the Bayesian graphical ridge penalty term.</p>
</td></tr>
<tr><td><code id="blockBAGENI_+3A_b">b</code></td>
<td>
<p>A double specifying the value of the scale parameter for the inverse gamma prior associated with the Bayesian graphical ridge penalty term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing precision 'Omega' and covariance 'Sigma' matrices
from the Markov chains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate true precision matrix:
p             &lt;- 10
n             &lt;- 500
OmegaTrue    &lt;- pracma::Toeplitz(c(0.7^rep(1:p-1)))
SigTrue      &lt;- pracma::inv(OmegaTrue)
# Generate expected value vector:
mu            &lt;- rep(0,p)
# Generate multivariate normal distribution:
set.seed(123)
X             &lt;- MASS::mvrnorm(n, mu = mu, Sigma = SigTrue)
# Generate posterior distribution:
posterior     &lt;- blockBAGENI(X, iterations = 1000, burnin = 500)
# Estimated precision matrix using the mean of the posterior:
OmegaEst      &lt;- apply(simplify2array(posterior$Omega), 1:2, mean)
</code></pre>

<hr>
<h2 id='blockBAGENII'>Type II naive Bayesian adaptive graphical elastic net block Gibbs sampler for Gaussian graphical models.</h2><span id='topic+blockBAGENII'></span>

<h3>Description</h3>

<p>Implements the Type II naive Bayesian adaptive graphical elastic net block Gibbs sampler to simulate the
posterior distribution of the precision matrix for Gaussian graphical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockBAGENII(X, burnin, iterations, verbose = TRUE, s = 0.1, b = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockBAGENII_+3A_x">X</code></td>
<td>
<p>A numeric matrix, assumed to be generated from a multivariate Gaussian distribution.</p>
</td></tr>
<tr><td><code id="blockBAGENII_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBAGENII_+3A_iterations">iterations</code></td>
<td>
<p>An integer specifying the length of the Markov chain after the burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBAGENII_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining whether the progress of the MCMC sampler should be displayed.</p>
</td></tr>
<tr><td><code id="blockBAGENII_+3A_s">s</code></td>
<td>
<p>A double specifying the value of the rate parameter for the exponential prior associated with the Bayesian graphical lasso penalty term.</p>
</td></tr>
<tr><td><code id="blockBAGENII_+3A_b">b</code></td>
<td>
<p>A double specifying the value of the rate parameter for the exponential prior associated with the Bayesian graphical ridge penalty term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing precision 'Omega' and covariance 'Sigma' matrices
from the Markov chains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate true precision matrix:
p             &lt;- 10
n             &lt;- 500
OmegaTrue    &lt;- pracma::Toeplitz(c(0.7^rep(1:p-1)))
SigTrue      &lt;- pracma::inv(OmegaTrue)
# Generate expected value vector:
mu            &lt;- rep(0,p)
# Generate multivariate normal distribution:
set.seed(123)
X             &lt;- MASS::mvrnorm(n, mu = mu, Sigma = SigTrue)
# Generate posterior distribution:
posterior     &lt;- blockBAGENII(X, iterations = 1000, burnin = 500)
# Estimated precision matrix using the mean of the posterior:
OmegaEst      &lt;- apply(simplify2array(posterior$Omega), 1:2, mean)
</code></pre>

<hr>
<h2 id='blockBAGL'>Bayesian adaptive graphical lasso block Gibbs sampler for Gaussian graphical models.</h2><span id='topic+blockBAGL'></span>

<h3>Description</h3>

<p>Implements a Bayesian adaptive graphical lasso block Gibbs sampler to simulate the
posterior distribution of the precision matrix for Gaussian graphical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockBAGL(X, burnin, iterations, verbose = TRUE, r = 0.01, s = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockBAGL_+3A_x">X</code></td>
<td>
<p>A numeric matrix, assumed to be generated from a multivariate Gaussian distribution.</p>
</td></tr>
<tr><td><code id="blockBAGL_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBAGL_+3A_iterations">iterations</code></td>
<td>
<p>An integer specifying the length of the Markov chain after the burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBAGL_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining whether the progress of the MCMC sampler should be displayed.</p>
</td></tr>
<tr><td><code id="blockBAGL_+3A_r">r</code></td>
<td>
<p>A double specifying the value of the shape parameter for the gamma prior.</p>
</td></tr>
<tr><td><code id="blockBAGL_+3A_s">s</code></td>
<td>
<p>A double specifying the value of the scale parameter for the gamma prior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing precision 'Omega' and covariance 'Sigma' matrices
from the Markov chains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate true precision matrix:
p             &lt;- 10
n             &lt;- 500
OmegaTrue    &lt;- pracma::Toeplitz(c(0.7^rep(1:p-1)))
SigTrue      &lt;- pracma::inv(OmegaTrue)
# Generate expected value vector:
mu            &lt;- rep(0,p)
# Generate multivariate normal distribution:
set.seed(123)
X             &lt;- MASS::mvrnorm(n, mu = mu, Sigma = SigTrue)
# Generate posterior distribution:
posterior     &lt;- blockBAGL(X, iterations = 1000, burnin = 500)
# Estimated precision matrix using the mean of the posterior:
OmegaEst      &lt;- apply(simplify2array(posterior$Omega), 1:2, mean)
</code></pre>

<hr>
<h2 id='blockBAGR'>Bayesian adaptive graphical ridge block Gibbs sampler for Gaussian graphical models.</h2><span id='topic+blockBAGR'></span>

<h3>Description</h3>

<p>Implements a Bayesian adaptive graphical ridge block Gibbs sampler to simulate the
posterior distribution of the precision matrix for Gaussian graphical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockBAGR(X, burnin, iterations, verbose = TRUE, a = 1, b = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockBAGR_+3A_x">X</code></td>
<td>
<p>A numeric matrix, assumed to be generated from a multivariate Gaussian distribution.</p>
</td></tr>
<tr><td><code id="blockBAGR_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBAGR_+3A_iterations">iterations</code></td>
<td>
<p>An integer specifying the length of the Markov chain after the burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBAGR_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining whether the progress of the MCMC sampler should be displayed.</p>
</td></tr>
<tr><td><code id="blockBAGR_+3A_a">a</code></td>
<td>
<p>A double specifying the value of the shape parameter for the inverse gamma prior.</p>
</td></tr>
<tr><td><code id="blockBAGR_+3A_b">b</code></td>
<td>
<p>A double specifying the value of the scale parameter for the inverse gamma prior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing precision 'Omega' and covariance 'Sigma' matrices
from the Markov chains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate true precision matrix:
p             &lt;- 10
n             &lt;- 500
OmegaTrue    &lt;- pracma::Toeplitz(c(0.7^rep(1:p-1)))
SigTrue      &lt;- pracma::inv(OmegaTrue)
# Generate expected value vector:
mu            &lt;- rep(0,p)
# Generate multivariate normal distribution:
set.seed(123)
X             &lt;- MASS::mvrnorm(n, mu = mu, Sigma = SigTrue)
# Generate posterior distribution:
posterior     &lt;- blockBAGR(X, iterations = 1000, burnin = 500)
# Estimated precision matrix using the mean of the posterior:
OmegaEst      &lt;- apply(simplify2array(posterior$Omega), 1:2, mean)
</code></pre>

<hr>
<h2 id='blockBGEN'>Naive Bayesian graphical elastic net block Gibbs sampler for Gaussian graphical models.</h2><span id='topic+blockBGEN'></span>

<h3>Description</h3>

<p>Implements the Bayesian graphical elastic net block Gibbs sampler to simulate the
posterior distribution of the precision matrix for Gaussian graphical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockBGEN(X, burnin, iterations, lambda = 1, sig = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockBGEN_+3A_x">X</code></td>
<td>
<p>A numeric matrix, assumed to be generated from a multivariate Gaussian distribution.</p>
</td></tr>
<tr><td><code id="blockBGEN_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBGEN_+3A_iterations">iterations</code></td>
<td>
<p>An integer specifying the length of the Markov chain after the burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBGEN_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value representing the rate parameter for the double
exponential and exponential prior associated with the Bayesian graphical lasso penalty term.</p>
</td></tr>
<tr><td><code id="blockBGEN_+3A_sig">sig</code></td>
<td>
<p>A numeric value representing the standard deviation parameter for the double
Gaussian and truncated Gaussian prior associated with the Bayesian graphical ridge penalty term.</p>
</td></tr>
<tr><td><code id="blockBGEN_+3A_verbose">verbose</code></td>
<td>
<p>A logical determining whether the progress of the MCMC sampler should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing precision 'Omega' and covariance 'Sigma' matrices
from the Markov chains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate true precision matrix:
p             &lt;- 10
n             &lt;- 500
OmegaTrue    &lt;- pracma::Toeplitz(c(0.7^rep(1:p-1)))
SigTrue      &lt;- pracma::inv(OmegaTrue)
# Generate expected value vector:
mu            &lt;- rep(0,p)
# Generate multivariate normal distribution:
set.seed(123)
X             &lt;- MASS::mvrnorm(n, mu = mu, Sigma = SigTrue)
# Generate posterior distribution:
posterior     &lt;- blockBGEN(X, iterations = 1000, burnin = 500, lambda = 1, sig = 1)
# Estimated precision matrix using the mean of the posterior:
OmegaEst      &lt;- apply(simplify2array(posterior$Omega), 1:2, mean)
</code></pre>

<hr>
<h2 id='blockBGL'>Bayesian graphical lasso block Gibbs sampler for Gaussian graphical models.</h2><span id='topic+blockBGL'></span>

<h3>Description</h3>

<p>Implements a Bayesian graphical lasso block Gibbs sampler to simulate the
posterior distribution of the precision matrix for Gaussian graphical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockBGL(X, burnin, iterations, lambda = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockBGL_+3A_x">X</code></td>
<td>
<p>A numeric matrix, assumed to be generated from a multivariate Gaussian distribution.</p>
</td></tr>
<tr><td><code id="blockBGL_+3A_burnin">burnin</code></td>
<td>
<p>An integer representing the number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBGL_+3A_iterations">iterations</code></td>
<td>
<p>An integer representing the length of the Markov chain post burn-in.</p>
</td></tr>
<tr><td><code id="blockBGL_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value representing the rate parameter for the double
exponential and exponential prior.</p>
</td></tr>
<tr><td><code id="blockBGL_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating if the MCMC sampler progress should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing precision 'Omega' and covariance 'Sigma' matrices
from the Markov chains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate true precision matrix:
p             &lt;- 10
n             &lt;- 500
OmegaTrue    &lt;- pracma::Toeplitz(c(0.7^rep(1:p-1)))
SigTrue      &lt;- pracma::inv(OmegaTrue)
# Generate expected value vector:
mu            &lt;- rep(0,p)
# Generate multivariate normal distribution:
set.seed(123)
X             &lt;- MASS::mvrnorm(n, mu = mu, Sigma = SigTrue)
# Generate posterior distribution:
posterior     &lt;- blockBGL(X, iterations = 1000, burnin = 500, lambda = 0.5)
# Estimated precision matrix using the mean of the posterior:
OmegaEst      &lt;- apply(simplify2array(posterior$Omega), 1:2, mean)
</code></pre>

<hr>
<h2 id='blockBGR'>Bayesian graphical ridge block Gibbs sampler for Gaussian graphical models.</h2><span id='topic+blockBGR'></span>

<h3>Description</h3>

<p>Implements a Bayesian graphical ridge block Gibbs sampler to simulate the
posterior distribution of the precision matrix for Gaussian graphical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockBGR(X, burnin, iterations, sig = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockBGR_+3A_x">X</code></td>
<td>
<p>A numeric matrix, assumed to be generated from a multivariate Gaussian distribution.</p>
</td></tr>
<tr><td><code id="blockBGR_+3A_burnin">burnin</code></td>
<td>
<p>An integer representing the number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="blockBGR_+3A_iterations">iterations</code></td>
<td>
<p>An integer representing the length of the Markov chain post burn-in.</p>
</td></tr>
<tr><td><code id="blockBGR_+3A_sig">sig</code></td>
<td>
<p>A numeric value representing the standard deviation parameter for the double
Gaussian and truncated Gaussian prior.</p>
</td></tr>
<tr><td><code id="blockBGR_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating if the MCMC sampler progress should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing precision 'Omega' and covariance 'Sigma' matrices
from the Markov chains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate true precision matrix:
p             &lt;- 10
n             &lt;- 500
OmegaTrue    &lt;- pracma::Toeplitz(c(0.7^rep(1:p-1)))
SigTrue      &lt;- pracma::inv(OmegaTrue)
# Generate expected value vector:
mu            &lt;- rep(0,p)
# Generate multivariate normal distribution:
set.seed(123)
X             &lt;- MASS::mvrnorm(n, mu = mu, Sigma = SigTrue)
# Generate posterior distribution:
posterior     &lt;- blockBGR(X, iterations = 1000, burnin = 500, sig = 0.5)
# Estimated precision matrix using the mean of the posterior:
OmegaEst      &lt;- apply(simplify2array(posterior$Omega), 1:2, mean)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
