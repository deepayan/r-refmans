<!DOCTYPE html><html lang="en"><head><title>Help for package ClueR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ClueR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ClueR-package'>
<p>CLUster Evaluation R package</p></a></li>
<li><a href='#adipocyte'><p>Mouse adipocyte differentiation gene expression (microarray) data</p></a></li>
<li><a href='#clustEnrichment'><p>Cluster enrichment test</p></a></li>
<li><a href='#clustOptimal'><p>Generate optimal clustering</p></a></li>
<li><a href='#enrichmentTest'><p>Fisher's exact test-based enrichment test</p></a></li>
<li><a href='#fuzzPlot'><p>Visualize fuzzy clustering results</p></a></li>
<li><a href='#hES'><p>Human embryonic stem cell phosphoproteomics data</p></a></li>
<li><a href='#Pathways.biocarta'><p>Biocarta pathway annotations</p></a></li>
<li><a href='#Pathways.DAVID'><p>DAVID pathway annotations</p></a></li>
<li><a href='#Pathways.KEGG'><p>KEGG pathway annotations</p></a></li>
<li><a href='#Pathways.reactome'><p>Reactome pathway annotations</p></a></li>
<li><a href='#PhosphoELM.human'><p>Phospho.ELM annotations for human</p></a></li>
<li><a href='#PhosphoELM.mouse'><p>Phospho.ELM annotations for mouse</p></a></li>
<li><a href='#PhosphoSite.human'><p>PhosphoSitePlus annotations for human</p></a></li>
<li><a href='#PhosphoSite.mouse'><p>PhosphoSitePlus annotations for mouse</p></a></li>
<li><a href='#runClue'><p>Run CLUster Evaluation</p></a></li>
<li><a href='#temporalSimu'><p>Temporal data simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cluster Evaluation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Pengyi Yang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pengyi Yang &lt;yangpy7@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>CLUster Evaluation (CLUE) is a computational method for identifying 
              optimal number of clusters in a given time-course dataset clustered by 
              cmeans or kmeans algorithms and subsequently identify key kinases or 
              pathways from each cluster. Its implementation in R is called ClueR. 
              See README on <a href="https://github.com/PYangLab/ClueR">https://github.com/PYangLab/ClueR</a> for more details.
              P Yang et al. (2015) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1004403">doi:10.1371/journal.pcbi.1004403</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>e1071, parallel, stats, graphics, grDevices</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-14 12:08:10 UTC; pyan6380</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-15 09:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='ClueR-package'>
CLUster Evaluation R package
</h2><span id='topic+ClueR-package'></span><span id='topic+CLUE'></span><span id='topic+ClueR'></span>

<h3>Description</h3>

<p>CLUster Evaluation (or &quot;CLUE&quot;) is an R package for detecting kinases or pathways from a given time-series phosphoproteomics or gene expression dataset clustered by cmeans or kmeans algorithms. It firstly identifies the optimal number of clusters in the time-servies dataset; Then, it partition the dataset based on the optimal number of clusters determined in the first step; It finally detects kinases or pathways enriched in each cluster from optimally partitioned dataset.
</p>
<p>The above three steps rely extensively on Fisher's exact test, Fisher's combined statistics, cluster regularisations, and they are performed against a user-specified reference annotation database such phosphoSitePlus in the case of phosphoproteomics data or KEGG in the case of gene expression data. There is a selection of built-in annotation databases for both phosphoproteomics data and gene expression data but users can supply their own annotation database.
</p>
<p>CLUE was initially designed for analysing time-course phosphoproteomics dataset using kinase-substrate annotation as reference (e.g. PhosphoSitePlus). It is now extended to identify key pathways from time-series microarray, RNA-seq or proteomics datasets by searching and testing against gene set annotation databases such as KEGG, GO, or Reactome etc.
</p>
<p>Previously published phosphoproteomics dataset and gene expression dataset are included in the package to demonstrate how to use CLUE package.
</p>
<p>See help from the main function by typing '?runClue' for more details and examples on how to use CLUE.
</p>
<p>You can also install the latest development version from github with:
</p>
<p>devtools::install_github(&quot;PengyiYang/ClueR&quot;)
</p>
<p>Make sure that you have Rtools install in your system for building the package from the source.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> CLUE</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-11-14</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Pengyi Yang
</p>


<h3>References</h3>

<p>Yang P, Zheng X, Jayaswal V, Hu G, Yang JYH, Jothi R (2015) Knowledge-Based Analysis for Detecting Key Signaling Events from Time-Series Phosphoproteomics Data. PLoS Comput Biol 11(8): e1004403.
</p>

<hr>
<h2 id='adipocyte'>Mouse adipocyte differentiation gene expression (microarray) data</h2><span id='topic+adipocyte'></span>

<h3>Description</h3>

<p>The data object contains a time-course gene expression profiling of the mouse adipocytes through differentiation. For details please refer to the article: 
</p>
<p>Ma X, Yang P, Kaplan WH, Lee BH, Wu LE, Yang JY, Yasunaga M, Sato K, Chisholm DJ, James DE. ISL1 regulates peroxisome proliferator-activated receptor gamma activation and early adipogenesis via bone morphogenetic protein 4-dependent and-independent mechanisms. Molecular and Cellular Biology. 2014 Oct 1;34(19):3607-17.
</p>

<hr>
<h2 id='clustEnrichment'>Cluster enrichment test</h2><span id='topic+clustEnrichment'></span>

<h3>Description</h3>

<p>Takes a clustering object generted by cmeans or kmeans algorithm and determine the enrichment of each cluster
and then the overall enrichment of this clustering object based on an annotation file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustEnrichment(
  clustObj,
  annotation,
  effectiveSize,
  pvalueCutoff = 0.05,
  universe = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustEnrichment_+3A_clustobj">clustObj</code></td>
<td>
<p>the clustering object generated by cmeans or kmeans.</p>
</td></tr>
<tr><td><code id="clustEnrichment_+3A_annotation">annotation</code></td>
<td>
<p>a list with names correspond to kinases and elements correspond to substrates belonging to each kinase.</p>
</td></tr>
<tr><td><code id="clustEnrichment_+3A_effectivesize">effectiveSize</code></td>
<td>
<p>the size of kinase-substrate groups to be considered for calculating enrichment. Groups that are too small
or too large will be removed from calculating overall enrichment of the clustering.</p>
</td></tr>
<tr><td><code id="clustEnrichment_+3A_pvaluecutoff">pvalueCutoff</code></td>
<td>
<p>a pvalue cutoff for determining which kinase-substrate groups to be included in calculating overall enrichment of the clustering.</p>
</td></tr>
<tr><td><code id="clustEnrichment_+3A_universe">universe</code></td>
<td>
<p>the universe of genes/proteins/phosphosites etc. that the enrichment is calculated against.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list that contains both the p-value indicating the overall enrichment and a sublist that details the enrichment of each individual cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a time-series data with six distinctive profile groups and each group with
# a size of 500 phosphorylation sites.
simuData &lt;- temporalSimu(seed=1, groupSize=500, sdd=1, numGroups=4)

# create an artificial annotation database. Generate 100 kinase-substrate groups each
# comprising 50 substrates assigned to a kinase. 
# among them, create 5 groups each contains phosphorylation sites defined to have the
# same temporal profile.   
kinaseAnno &lt;- list()
groupSize &lt;- 500
for (i in 1:5) {
 kinaseAnno[[i]] &lt;- paste("p", (groupSize*(i-1)+1):(groupSize*(i-1)+50), sep="_")
}
   
for (i in 6:100) {
 set.seed(i)
 kinaseAnno[[i]] &lt;- paste("p", sample.int(nrow(simuData), size = 50), sep="_")
}
names(kinaseAnno) &lt;- paste("KS", 1:100, sep="_")

# testing enrichment of clustering results by partition the data into six clusters
# using cmeans algorithm.
clustObj &lt;- e1071::cmeans(simuData, centers=6, iter.max=50, m=1.25)
clustEnrichment(clustObj, annotation=kinaseAnno, effectiveSize=c(5, 100), pvalueCutoff=0.05)

</code></pre>

<hr>
<h2 id='clustOptimal'>Generate optimal clustering</h2><span id='topic+clustOptimal'></span>

<h3>Description</h3>

<p>Takes a clue output and generate the optimal clustering of the time-course data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustOptimal(
  clueObj,
  rep = 5,
  user.maxK = NULL,
  effectiveSize = NULL,
  pvalueCutoff = 0.05,
  visualize = TRUE,
  universe = NULL,
  mfrow = c(1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustOptimal_+3A_clueobj">clueObj</code></td>
<td>
<p>the output from runClue.</p>
</td></tr>
<tr><td><code id="clustOptimal_+3A_rep">rep</code></td>
<td>
<p>number of times (default is 5) the clustering is to be repeated to find the best clustering result.</p>
</td></tr>
<tr><td><code id="clustOptimal_+3A_user.maxk">user.maxK</code></td>
<td>
<p>user defined optimal k value for generating optimal clustering. If not provided, the optimal k that is identified by clue will be used.</p>
</td></tr>
<tr><td><code id="clustOptimal_+3A_effectivesize">effectiveSize</code></td>
<td>
<p>the size of kinase-substrate groups to be considered for calculating enrichment. Groups that are too small
or too large will be removed from calculating overall enrichment of the clustering.</p>
</td></tr>
<tr><td><code id="clustOptimal_+3A_pvaluecutoff">pvalueCutoff</code></td>
<td>
<p>a pvalue cutoff for determining which kinase-substrate groups to be included in calculating overall enrichment of the clustering.</p>
</td></tr>
<tr><td><code id="clustOptimal_+3A_visualize">visualize</code></td>
<td>
<p>a boolean parameter indicating whether to visualize the clustering results.</p>
</td></tr>
<tr><td><code id="clustOptimal_+3A_universe">universe</code></td>
<td>
<p>the universe of genes/proteins/phosphosites etc. that the enrichment is calculated against. The default are the row names of the dataset.</p>
</td></tr>
<tr><td><code id="clustOptimal_+3A_mfrow">mfrow</code></td>
<td>
<p>control the subplots in graphic window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list containing optimal clustering object and enriched kinases or gene sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a time-series data with 4 distinctive profile groups and each group with
# a size of 50 phosphorylation sites.
simuData &lt;- temporalSimu(seed=1, groupSize=50, sdd=1, numGroups=4)

# create an artificial annotation database. Generate 20 kinase-substrate groups each
# comprising 10 substrates assigned to a kinase.
# among them, create 4 groups each contains phosphorylation sites defined to have the
# same temporal profile.
kinaseAnno &lt;- list()
groupSize &lt;- 50
for (i in 1:4) {
 kinaseAnno[[i]] &lt;- paste("p", (groupSize*(i-1)+1):(groupSize*(i-1)+10), sep="_")
}

for (i in 5:20) {
 set.seed(i)
 kinaseAnno[[i]] &lt;- paste("p", sample.int(nrow(simuData), size = 10), sep="_")
}
names(kinaseAnno) &lt;- paste("KS", 1:20, sep="_")

# run CLUE with a repeat of 2 times and a range from 2 to 7
set.seed(1)
clueObj &lt;- runClue(Tc=simuData, annotation=kinaseAnno, rep=5, kRange=2:7)

# visualize the evaluation outcome
xl &lt;- "Number of clusters"
yl &lt;- "Enrichment score"
boxplot(clueObj$evlMat, col=rainbow(ncol(clueObj$evlMat)), las=2, xlab=xl, ylab=yl, main="CLUE")
abline(v=(clueObj$maxK-1), col=rgb(1,0,0,.3))

# generate optimal clustering results using the optimal k determined by CLUE
best &lt;- clustOptimal(clueObj, rep=3, mfrow=c(2, 3))

# list enriched clusters
best$enrichList

# obtain the optimal clustering object

  best$clustObj



</code></pre>

<hr>
<h2 id='enrichmentTest'>Fisher's exact test-based enrichment test</h2><span id='topic+enrichmentTest'></span>

<h3>Description</h3>

<p>Takes a vector of names representing phosphorylation sites that are partitioned in the same cluster 
and an kinase-substrate annotation. Test for enrichment of the kinase based on the name vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enrichmentTest(clust, annotation, universe, alter = "greater")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enrichmentTest_+3A_clust">clust</code></td>
<td>
<p>a vector of names representing phosphorylation sites that are partitioned in the same cluster</p>
</td></tr>
<tr><td><code id="enrichmentTest_+3A_annotation">annotation</code></td>
<td>
<p>a list with names correspond to kinases and elements correspond to substrates belong to each kinase</p>
</td></tr>
<tr><td><code id="enrichmentTest_+3A_universe">universe</code></td>
<td>
<p>the universe of names to compare against</p>
</td></tr>
<tr><td><code id="enrichmentTest_+3A_alter">alter</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix that contains enrichment of each kinase based on the input name vector.
</p>

<hr>
<h2 id='fuzzPlot'>Visualize fuzzy clustering results</h2><span id='topic+fuzzPlot'></span>

<h3>Description</h3>

<p>Takes in a time-course matrix and its clustering results as a cmeans clustering object. Produce a plot to visualize the clustering results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzPlot(
  Tc,
  clustObj,
  mfrow = c(1, 1),
  cols,
  min.mem = 0,
  new.window = FALSE,
  llwd = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuzzPlot_+3A_tc">Tc</code></td>
<td>
<p>a numeric matrix to be clustered. The columns correspond to the time-course and the rows correspond to phosphorylation sites.</p>
</td></tr>
<tr><td><code id="fuzzPlot_+3A_clustobj">clustObj</code></td>
<td>
<p>the clustering of Tc generated from cmeans or kmeans clustering.</p>
</td></tr>
<tr><td><code id="fuzzPlot_+3A_mfrow">mfrow</code></td>
<td>
<p>control the subplots in graphic window.</p>
</td></tr>
<tr><td><code id="fuzzPlot_+3A_cols">cols</code></td>
<td>
<p>color palette to be used for plotting. If the color argument remains empty, the default palette is used.</p>
</td></tr>
<tr><td><code id="fuzzPlot_+3A_min.mem">min.mem</code></td>
<td>
<p>phosphorylation sites with membership values below min.mem will not be displayed.</p>
</td></tr>
<tr><td><code id="fuzzPlot_+3A_new.window">new.window</code></td>
<td>
<p>should a new window be opened for graphics.</p>
</td></tr>
<tr><td><code id="fuzzPlot_+3A_llwd">llwd</code></td>
<td>
<p>line width. Default is 3.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load the human ES phosphoprotoemics data (Rigbolt et al. Sci Signal. 4(164):rs3, 2011)
data(hES)
# apply cmeans clustering to partition the data into 11 clusters
clustObj &lt;- e1071::cmeans(hES, centers=11, iter.max=50, m=1.25)
# visualize clustering reuslts
fuzzPlot(hES, clustObj, mfrow = c(3,4))

</code></pre>

<hr>
<h2 id='hES'>Human embryonic stem cell phosphoproteomics data</h2><span id='topic+hES'></span>

<h3>Description</h3>

<p>The data object contains a time-course phosphoprotoemics profiling of the human embryonic stem cells through differentiation. The differentiation
is induced by using PMA and the time points of 30m, 1hr, 6hrs, and 24hrs are measured and the ratio are taken against 0m. For details please refer to
the article: Rigbolt et al. Sci Signal. 4(164):rs3, 2011
</p>

<hr>
<h2 id='Pathways.biocarta'>Biocarta pathway annotations</h2><span id='topic+Pathways.biocarta'></span>

<h3>Description</h3>

<p>The data object contains the annotations from biocarta pathway database.
</p>

<hr>
<h2 id='Pathways.DAVID'>DAVID pathway annotations</h2><span id='topic+Pathways.DAVID'></span>

<h3>Description</h3>

<p>The data object contains the annotations from DAVID database which contains GOBP (GO biological processes) pathways.
</p>

<hr>
<h2 id='Pathways.KEGG'>KEGG pathway annotations</h2><span id='topic+Pathways.KEGG'></span>

<h3>Description</h3>

<p>The data object contains the annotations of KEGG pathways.
</p>

<hr>
<h2 id='Pathways.reactome'>Reactome pathway annotations</h2><span id='topic+Pathways.reactome'></span>

<h3>Description</h3>

<p>The data object contains the annotations of reactome pathways.
</p>

<hr>
<h2 id='PhosphoELM.human'>Phospho.ELM annotations for human</h2><span id='topic+PhosphoELM.human'></span>

<h3>Description</h3>

<p>The data object contains the annotations of kinases and their conrresponding substrates as phosphorylation sites in human. It is extracted from the Phospho.ELM database.</p>

<hr>
<h2 id='PhosphoELM.mouse'>Phospho.ELM annotations for mouse</h2><span id='topic+PhosphoELM.mouse'></span>

<h3>Description</h3>

<p>The data object contains the annotations of kinases and their conrresponding substrates as phosphorylation sites in mouse. It is extracted from the Phospho.ELM database.</p>

<hr>
<h2 id='PhosphoSite.human'>PhosphoSitePlus annotations for human</h2><span id='topic+PhosphoSite.human'></span>

<h3>Description</h3>

<p>The data object contains the annotations of kinases and their conrresponding substrates as phosphorylation sites in human. It is extracted
from the PhosphoSitePlus database. For details of PhosphoSitePlus, please refer to the article: Hornbeck et al. Nucleic Acids Res. 40:D261-70, 2012
</p>

<hr>
<h2 id='PhosphoSite.mouse'>PhosphoSitePlus annotations for mouse</h2><span id='topic+PhosphoSite.mouse'></span>

<h3>Description</h3>

<p>The data object contains the annotations of kinases and their conrresponding substrates as phosphorylation sites in mouse. It is extracted
from the PhosphoSitePlus database. For details of PhosphoSitePlus, please refer to the article: Hornbeck et al. Nucleic Acids Res. 40:D261-70, 2012
</p>

<hr>
<h2 id='runClue'>Run CLUster Evaluation</h2><span id='topic+runClue'></span>

<h3>Description</h3>

<p>Takes in a time-course matrix and test for enrichment of the clustering using cmeans or kmeans clustering algorithm with a reference annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runClue(
  Tc,
  annotation,
  rep = 5,
  kRange = 2:10,
  clustAlg = "cmeans",
  effectiveSize = c(5, 100),
  pvalueCutoff = 0.05,
  alpha = 0.5,
  standardise = TRUE,
  universe = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runClue_+3A_tc">Tc</code></td>
<td>
<p>a numeric matrix to be clustered. The columns correspond to the time-course and the rows correspond to phosphorylation sites.</p>
</td></tr>
<tr><td><code id="runClue_+3A_annotation">annotation</code></td>
<td>
<p>a list with names correspond to kinases and elements correspond to substrates belong to each kinase.</p>
</td></tr>
<tr><td><code id="runClue_+3A_rep">rep</code></td>
<td>
<p>number of times the clustering is to be applied. This is to account for variability in the clustering algorithm. Default is 5.</p>
</td></tr>
<tr><td><code id="runClue_+3A_krange">kRange</code></td>
<td>
<p>the range of k to be tested for clustering. Default is 2:10</p>
</td></tr>
<tr><td><code id="runClue_+3A_clustalg">clustAlg</code></td>
<td>
<p>the clustering algorithm to be used. The default is cmeans clustering.</p>
</td></tr>
<tr><td><code id="runClue_+3A_effectivesize">effectiveSize</code></td>
<td>
<p>the size of annotation groups to be considered for calculating enrichment. Groups that are too small
or too large will be removed from calculating overall enrichment of the clustering.</p>
</td></tr>
<tr><td><code id="runClue_+3A_pvaluecutoff">pvalueCutoff</code></td>
<td>
<p>a pvalue cutoff for determining which kinase-substrate groups to be included in calculating overall enrichment of the clustering.</p>
</td></tr>
<tr><td><code id="runClue_+3A_alpha">alpha</code></td>
<td>
<p>a regularisation factor for penalizing large number of clusters.</p>
</td></tr>
<tr><td><code id="runClue_+3A_standardise">standardise</code></td>
<td>
<p>whether to z-score standardise the input matrix.</p>
</td></tr>
<tr><td><code id="runClue_+3A_universe">universe</code></td>
<td>
<p>the universe of genes/proteins/phosphosites etc. that the enrichment is calculated against. The default are the row names of the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a clue output that contains the input parameters used for evaluation and the evaluation results. Use ls(x) to see details of output. 'x' be the output here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1. Running CLUE with a simulated phosphoproteomics data

## simulate a time-series phosphoproteomics data with 4 clusters and
## each cluster with a size of 100 phosphosites
simuData &lt;- temporalSimu(seed=1, groupSize=100, sdd=1, numGroups=4)

## create an artificial annotation database. Specifically, Generate 50
## kinase-substrate groups each comprising 20 substrates assigned to a kinase. 
## Among them, create 5 groups each contains phosphosites defined 
## to have the same temporal profile.

kinaseAnno &lt;- list()
groupSize &lt;- 100
for (i in 1:5) {
  kinaseAnno[[i]] &lt;- paste("p", (groupSize*(i-1)+1):(groupSize*(i-1)+20), sep="_")
}

for (i in 6:50) {
  set.seed(i)
  kinaseAnno[[i]] &lt;- paste("p", sample.int(nrow(simuData), size = 20), sep="_")
}
names(kinaseAnno) &lt;- paste("KS", 1:50, sep="_")

## run CLUE with a repeat of 3 times and a range from 2 to 8
set.seed(1)
cl &lt;- runClue(Tc=simuData, annotation=kinaseAnno, rep=3, kRange=2:8, 
              standardise = TRUE, universe = NULL)

## visualize the evaluation outcome
boxplot(cl$evlMat, col=rainbow(8), las=2, xlab="# cluster", ylab="Enrichment", main="CLUE")

## generate optimal clustering results using the optimal k determined by CLUE
best &lt;- clustOptimal(cl, rep=3, mfrow=c(2, 3))

## list enriched clusters
best$enrichList

## obtain the optimal clustering object
best$clustObj

## Example 2. Running CLUE with a phosphoproteomics dataset, discover optimal number of clusters, 
## clustering data accordingly, and identify key kinases involved in each cluster.

## load the human ES phosphoprotoemics data (Rigbolt et al. Sci Signal. 4(164):rs3, 2011)
data(hES)
# load the PhosphoSitePlus annotations (Hornbeck et al. Nucleic Acids Res. 40:D261-70, 2012)
# note that one can instead use PhosphoELM database by typing "data(PhosphoELM)".
data(PhosphoSite)

## run CLUE with a repeat of 5 times and a range from 2 to 15
set.seed(1)
cl &lt;- runClue(Tc=hES, annotation=PhosphoSite.human, rep=5, kRange=2:15, 
              standardise = TRUE, universe = NULL)

boxplot(cl$evlMat, col=rainbow(15), las=2, xlab="# cluster", ylab="Enrichment", main="CLUE")

best &lt;- clustOptimal(cl, rep=3, mfrow=c(4, 4))

best$enrichList

## Example 3. Running CLUE with a gene expression dataset, discover optimal number of clusters, 
## clustering data accordingly, and identify key pathway involved in each cluster.

## load mouse adipocyte gene expression data 
# (Ma et al. Molecular and Cellular Biology. 2014, 34(19):3607-17)
data(adipocyte)

## load the KEGG annotations
## note that one can instead use reactome, GOBP, biocarta database
data(Pathways)

## select genes that are differentially expressed during adipocyte differentiation
adipocyte.selected &lt;- adipocyte[adipocyte[,"DE"] == 1,]

## run CLUE with a repeat of 5 times and a range from 10 to 22

set.seed(3)
cl &lt;- runClue(Tc=adipocyte.selected, annotation=Pathways.KEGG, rep=3, kRange=10:20, 
              standardise = TRUE, universe = NULL)

xl &lt;- "Number of clusters"
yl &lt;- "Enrichment score"
boxplot(cl$evlMat, col=rainbow(ncol(cl$evlMat)), las=2, xlab=xl, ylab=yl, main="CLUE")

</code></pre>

<hr>
<h2 id='temporalSimu'>Temporal data simulation</h2><span id='topic+temporalSimu'></span>

<h3>Description</h3>

<p>This function simulates time-series data using 14 pre-defined temporal profile templates. Type 'temporalSimu' to see the details of the templates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temporalSimu(seed = unclass(Sys.time()), groupSize, sdd, numGroups)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="temporalSimu_+3A_seed">seed</code></td>
<td>
<p>to seed the simulation. Default is current system time.</p>
</td></tr>
<tr><td><code id="temporalSimu_+3A_groupsize">groupSize</code></td>
<td>
<p>the number of the temporal profiles to simulate from each template. The total number of profiles will be the number of templates used times the size of each group.</p>
</td></tr>
<tr><td><code id="temporalSimu_+3A_sdd">sdd</code></td>
<td>
<p>the standard deviation to be used to generate randomness for each temporal profile.</p>
</td></tr>
<tr><td><code id="temporalSimu_+3A_numgroups">numGroups</code></td>
<td>
<p>number of templates to be used for generating data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing simulated time-series dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a time-series data with four distinctive profile groups and each group with 
# a size of 500 phosphorylation sites

simulated.temporal &lt;- temporalSimu(seed=1, groupSize=500, sdd=1, numGroups=4)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
