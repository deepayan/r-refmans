<!DOCTYPE html><html><head><title>Help for package spacetime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spacetime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#air'><p>Air quality data, rural background PM10 in Germany, daily averages 1998-2009</p></a></li>
<li><a href='#delta'><p> find default time interval end points when intervals are regular</p></a></li>
<li><a href='#EOF'><p> Compute spatial or temporal empirical orthogonal function (EOF)</p></a></li>
<li><a href='#fires'><p>Northern Los Angeles County Fires</p></a></li>
<li><a href='#mnf'><p>Generic mnf method</p></a></li>
<li><a href='#na.locf'><p> replace NA attribute values; disaggregation time series</p></a></li>
<li><a href='#nbMult'><p> convert a spatial nb object to a matching STF object</p></a></li>
<li><a href='#over-methods'><p> consistent spatio-temporal overlay for objects inheriting from ST</p></a></li>
<li><a href='#read.tgrass'><p> read or write tgrass (time-enabled grass) files</p></a></li>
<li><a href='#ST-class'><p>Class &quot;ST&quot;</p></a></li>
<li><a href='#stbox'><p> obtain ranges of space and time coordinates</p></a></li>
<li><a href='#stConstruct'><p> create ST* objects from long or wide tables</p></a></li>
<li><a href='#STFDF-class'><p>Class &quot;STFDF&quot;</p></a></li>
<li><a href='#STIDF-class'><p>Class &quot;STIDF&quot;</p></a></li>
<li><a href='#stInteraction'><p> subtract marginal (spatial and temporal) means from observations</p></a></li>
<li><a href='#stplot'><p> produce trellis plot for STxDF object</p></a></li>
<li><a href='#STSDF-class'><p>Class &quot;STSDF&quot;</p></a></li>
<li><a href='#STTDF-class'><p>Class &quot;STTDF&quot;</p></a></li>
<li><a href='#timeIsInterval'><p> retrieve, or set, information whether time reflects instance (FALSE) or intervals (TRUE)</p></a></li>
<li><a href='#timeMatch'><p> match two (time) sequences</p></a></li>
<li><a href='#unstack'><p> write STFDF to table forms</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3-1</td>
</tr>
<tr>
<td>Title:</td>
<td>Classes and Methods for Spatio-Temporal Data</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, utils, stats, methods, lattice, sp (&ge; 1.1-0), zoo
(&ge; 1.7-9), xts (&ge; 0.8-8), intervals</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adehabitatLT, cshapes (&ge; 2.0), foreign, gstat (&ge; 1.0-16),
maps, mapdata, plm, raster, RColorBrewer, rmarkdown,
RPostgreSQL, knitr, googleVis, ISOcodes, markdown, sf, sftime</td>
</tr>
<tr>
<td>LazyData:</td>
<td>no</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes and methods for spatio-temporal data, including space-time regular lattices, sparse lattices, irregular data, and trajectories; utility functions for plotting data as map sequences (lattice or animation) or multiple time series; methods for spatial and temporal selection and subsetting, as well as for spatial/temporal/spatio-temporal matching or aggregation, retrieving coordinates, print, summary, etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/edzer/spacetime">https://github.com/edzer/spacetime</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/edzer/spacetime/issues">https://github.com/edzer/spacetime/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>Class-xts.R Class-ST.R Class-STFDF.R Class-STSDF.R
Class-STIDF.R Class-STTDF.R interval.R endtime.R ST-methods.R
STFDF-methods.R STSDF-methods.R STIDF-methods.R STTDF-methods.R
apply.R coerce.R stconstruct.R plot.R stplot.R timematch.R
over.R aggregate.R eof.R mnf.R bind.R na.R raster.R tgrass.R
stinteraction.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-05 15:25:42 UTC; edzer</td>
</tr>
<tr>
<td>Author:</td>
<td>Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Benedikt Graeler [ctb],
  Tom Gottfried [ctb],
  Robert J. Hijmans [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edzer Pebesma &lt;edzer.pebesma@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-05 21:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='air'>Air quality data, rural background PM10 in Germany, daily averages 1998-2009</h2><span id='topic+air'></span><span id='topic+DE_NUTS1'></span><span id='topic+DE'></span><span id='topic+rural'></span><span id='topic+dates'></span><span id='topic+stations'></span>

<h3>Description</h3>

<p>Air quality data obtained from the airBase European air quality
data base.  Daily averages for rural background stations in Germany,
1998-2009. In addition, NUTS1 regions (states, or Bundeslaender) for Germany to
illustrate spatial aggregation over irregular regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(air)
</code></pre>


<h3>Note</h3>

<p> see vignette on overlay and spatio-temporal aggregation in this
package; the vignette on using google charts shows where the
ISO_3166_2_DE table comes from. </p>


<h3>Author(s)</h3>

<p> air quality data compiled for R by Benedict Graeler; NUTS1
level data obtained from https://www.gadm.org/ . </p>


<h3>References</h3>

<p> https://www.eionet.europa.eu/etcs/etc-acm/databases/airbase </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(air)
rural = STFDF(stations, dates, data.frame(PM10 = as.vector(air)))
# how DE was created from DE_NUTS1:
#if (require(rgeos))
#	DE = gUnionCascaded(DE_NUTS1)
#</code></pre>

<hr>
<h2 id='delta'> find default time interval end points when intervals are regular </h2><span id='topic+delta'></span>

<h3>Description</h3>

<p> find default time interval end points when intervals are regular </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
delta(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_+3A_x">x</code></td>
<td>
<p> object of class <code>xts</code>, or of another class that can
be coerced into <code>POSIXct</code></p>
</td></tr></table>
<p>; 
</p>


<h3>Details</h3>

<p>to find the interval size for the last observation (which has no next
observation), <code>x</code> needs to be at least of length 2.
</p>


<h3>Value</h3>

<p>sequence of <code>POSIXct</code> time stamps, indicating the end
of the time interval, given by the next observation in <code>x</code>.
The last interval gets the same width of the one-but-last interval.
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma</p>


<h3>References</h3>

<p> https://www.jstatsoft.org/v51/i07/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>x = as.POSIXct("2000-01-01") + (0:9) * 3600
delta(x)
</code></pre>

<hr>
<h2 id='EOF'> Compute spatial or temporal empirical orthogonal function (EOF) </h2><span id='topic+EOF'></span><span id='topic+eof'></span>

<h3>Description</h3>

<p> Compute spatial or temporal empirical orthogonal function (EOF) </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
eof(x, how = c("spatial", "temporal"), returnEOFs = TRUE, ...)
EOF(x, how = c("spatial", "temporal"), returnPredictions = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EOF_+3A_x">x</code></td>
<td>
<p> object of class <code>STFDF</code></p>
</td></tr>
<tr><td><code id="EOF_+3A_how">how</code></td>
<td>
<p> character; choose <code>"spatial"</code> or <code>"temporal"</code> mode </p>
</td></tr>
<tr><td><code id="EOF_+3A_returneofs">returnEOFs</code></td>
<td>
<p> logical; if TRUE, the eigenvectors (EOFs) are returned 
in the form of a <a href="sp.html#topic+Spatial">Spatial</a> or <a href="xts.html#topic+xts">xts</a> object;
if FALSE, the object returned by <a href="stats.html#topic+prcomp">prcomp</a> is returned, 
which can be printed, or from which a summary can be computed; see examples. </p>
</td></tr>
<tr><td><code id="EOF_+3A_returnpredictions">returnPredictions</code></td>
<td>
<p> logical; if TRUE, the functions are returned (i.e.,
predicted principle components, or PC scores); if FALSE, the object returned
by <a href="stats.html#topic+prcomp">prcomp</a> is returned, which can be printed, or from which a
summary can be computed; see examples (deprecated, see below). </p>
</td></tr>
<tr><td><code id="EOF_+3A_...">...</code></td>
<td>
<p> arguments passed on to function <a href="stats.html#topic+prcomp">prcomp</a>; note that
<code>scale.=TRUE</code> needs to be specified to obtain EOFs based 
on correlation (default: covariance) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>In spatial mode, the appropriate <code>Spatial*</code> object. In temporal
mode, an object of class <code>xts</code>.
</p>


<h3>Note</h3>

<p><code>EOF</code> is deprecated: it mixes up spatial and temporal EOFs,
and returns projections (PC scores) instead of EOFs (eigenvectors); 
to compute EOFs, use <code>eof</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(gstat)) {
data(wind)
library(sp)
wind.loc$y = as.numeric(char2dms(as.character(wind.loc[["Latitude"]])))
wind.loc$x = as.numeric(char2dms(as.character(wind.loc[["Longitude"]])))
coordinates(wind.loc) = ~x+y
proj4string(wind.loc) = "+proj=longlat +datum=WGS84"

# match station order to names in wide table:
stations = 4:15
wind.loc = wind.loc[match(names(wind[stations]), wind.loc$Code),]
row.names(wind.loc) = wind.loc$Station
wind$time = ISOdate(wind$year+1900, wind$month, wind$day, 0)
space = list(values = names(wind)[stations])
wind.st = stConstruct(wind[stations], space, wind$time, SpatialObj = wind.loc)
# select firt 500 time steps, to limit run time:
wind.st = wind.st[,1:500]
wind.eof.1 = eof(wind.st)
wind.eof.2 = eof(wind.st, "temporal")
wind.eof.1.PCs = eof(wind.st, returnEOFs = FALSE)
eof(wind.st, "temporal", returnEOFs = FALSE)
summary(eof(wind.st, returnEOFs = FALSE))
summary(eof(wind.st, "temporal", returnEOFs = FALSE))
plot(eof(wind.st, "temporal", returnEOFs = FALSE))
}
</code></pre>

<hr>
<h2 id='fires'>Northern Los Angeles County Fires</h2><span id='topic+fires'></span>

<h3>Description</h3>

<p>Wildfire occurrences in Northern Los Angeles County, California
between 1976 and 2000.  The spatial units are in scaled feet, taken
from the NAD 83 state-plane coordinate system.  One unit is equivalent
to 100,000 feet or 18.9 miles.  The times for the points were produced
by the <code>date</code> package and represent the number of days since
January 1, 1960.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fires)</code></pre>


<h3>Format</h3>

<p>A data frame with 313 observations with day of occurrence, x and
y coordinates.
</p>


<h3>Author(s)</h3>

<p> Roger Peng, taken from (non-CRAN) package ptproc, 
</p>
<p><a href="https://www.biostat.jhsph.edu/~rpeng/software/index.html">https://www.biostat.jhsph.edu/~rpeng/software/index.html</a>;
</p>
<p>example code by Roger Bivand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fires)
fires$X &lt;- fires$X*100000
fires$Y &lt;- fires$Y*100000
library(sp)
coordinates(fires) &lt;- c("X", "Y")
proj4string(fires) &lt;- CRS("+init=epsg:2229 +ellps=GRS80")
dates &lt;- as.Date("1960-01-01")+(fires$Time-1)
Fires &lt;- STIDF(as(fires, "SpatialPoints"), dates, data.frame(time=fires$Time))
library(mapdata)
if (require(sf)) {
 m &lt;- map("county", "california", xlim=c(-119.1, -117.5), 
 	ylim=c(33.7, 35.0), plot=FALSE, fill=TRUE)
 m.sf &lt;- st_transform(st_as_sfc(m), "EPSG:2229")
 cc &lt;- as(m.sf, "Spatial")
 plot(cc, xlim=c(6300000, 6670000), ylim=c(1740000, 2120000))
 plot(slot(Fires, "sp"), pch=3, add=TRUE)
 stplot(Fires, sp.layout=list("sp.lines", cc))
}
</code></pre>

<hr>
<h2 id='mnf'>Generic mnf method</h2><span id='topic+mnf'></span><span id='topic+mnf.RasterBrick'></span><span id='topic+mnf.RasterStack'></span><span id='topic+mnf.SpatialGridDataFrame'></span><span id='topic+mnf.SpatialPixelsDataFrame'></span><span id='topic+mnf.matrix'></span><span id='topic+mnf.mts'></span><span id='topic+mnf.zoo'></span><span id='topic+mnf.STSDF'></span><span id='topic+mnf.STFDF'></span>

<h3>Description</h3>

<p> Compute mnf from spatial, temporal, or spatio-temporal data </p>


<h3>Usage</h3>

<pre><code class='language-R'>mnf(x, ...)
## S3 method for class 'matrix'
mnf(x, ..., Sigma.Noise, use = "complete.obs")
## S3 method for class 'mts'
mnf(x, ..., use = "complete.obs")
## S3 method for class 'zoo'
mnf(x, ..., use = "complete.obs")
## S3 method for class 'SpatialPixelsDataFrame'
mnf(x, ..., use = "complete.obs")
## S3 method for class 'SpatialGridDataFrame'
mnf(x, ..., Sigma.Noise, use = "complete.obs")
## S3 method for class 'RasterStack'
mnf(x, ..., use = "complete.obs")
## S3 method for class 'RasterBrick'
mnf(x, ..., use = "complete.obs")
## S3 method for class 'STSDF'
mnf(x, ..., use = "complete.obs", mode = "temporal")
## S3 method for class 'STFDF'
mnf(x, ..., use = "complete.obs", mode = "temporal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mnf_+3A_x">x</code></td>
<td>
<p>object for which an mnf method is available</p>
</td></tr>
<tr><td><code id="mnf_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="mnf_+3A_sigma.noise">Sigma.Noise</code></td>
<td>
<p>Noise covariance matrix; when missing, estimated from the data by using the
covariance of lag-one spatial or temporal differences (MAF)</p>
</td></tr>
<tr><td><code id="mnf_+3A_use">use</code></td>
<td>
<p>method to deal with missing values when computing covariances; see <a href="stats.html#topic+cov">cov</a></p>
</td></tr>
<tr><td><code id="mnf_+3A_mode">mode</code></td>
<td>
<p>for <code>ST</code> objects: if <code>"temporal"</code>, compute covariances in time dimension,
if <code>"spatial"</code>, compute them in spatial dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Uses MAF (Min/max Autocorrelation Factors) to estimate the
noise covariance.  This implementation estimates the noise covariance
by <code class="reqn">0.5 \mbox{Cov}(Z(s)-Z(s+\Delta))</code>, so that eigenvalues can be
directly interpreted as approximate estimates of the noice covariance. </p>


<h3>Value</h3>

<p> object of class <code>(c("mnf", "prcomp")</code>; see <a href="stats.html#topic+prcomp">prcomp</a>. Additional elements
are <code>values</code>, containing the eigenvalues.  </p>


<h3>See Also</h3>

<p>https://r-spatial.org/r/2016/03/09/MNF-PCA-EOF.html </p>


<h3>Examples</h3>

<pre><code class='language-R'># temporal data:
set.seed(13531) # make reproducible
s1 = arima.sim(list(ma = rep(1,20)), 500)
s2 = arima.sim(list(ma = rep(1,20)), 500)
s3 = arima.sim(list(ma = rep(1,20)), 500)
s3 = s3 + rnorm(500, sd = 10)
d = cbind(s1,s2,s3)
plot(d)
m = mnf(d)
m
summary(m)
plot(predict(m))

# spatial example:
## Not run: 
library(sp)
grd = SpatialPoints(expand.grid(x=1:100, y=1:100))
gridded(grd) = TRUE
fullgrid(grd) = TRUE
pts = spsample(grd, 50, "random")
pts$z = rnorm(50)
library(gstat)
v = vgm(1, "Sph", 90)
out = krige(z~1, pts, grd, v, nmax = 20, nsim = 4)
out[[3]] = 0.5 * out[[3]] + 0.5 * rnorm(1e4)
out[[4]] = rnorm(1e4)
spplot(out, as.table = TRUE)
m = mnf(out)
m
summary(m)

## End(Not run)
if (require(gstat)) {
 data(wind)
 library(sp)
 wind.loc$y = as.numeric(char2dms(as.character(wind.loc[["Latitude"]])))
 wind.loc$x = as.numeric(char2dms(as.character(wind.loc[["Longitude"]])))
 coordinates(wind.loc) = ~x+y
 proj4string(wind.loc) = "+proj=longlat +datum=WGS84"

 # match station order to names in wide table:
 stations = 4:15
 wind.loc = wind.loc[match(names(wind[stations]), wind.loc$Code),]
 row.names(wind.loc) = wind.loc$Station
 wind$time = ISOdate(wind$year+1900, wind$month, wind$day, 0)
 space = list(values = names(wind)[stations])
 wind.st = stConstruct(wind[stations], space, wind$time, SpatialObj = wind.loc, interval = TRUE)
 m = mnf(wind.st)
 m
 plot(m)
 stplot(predict(m), mode = "tp")
}

</code></pre>

<hr>
<h2 id='na.locf'> replace NA attribute values; disaggregation time series </h2><span id='topic+na.locf'></span><span id='topic+na.approx'></span><span id='topic+na.spline'></span><span id='topic+na.locf.STFDF'></span><span id='topic+na.approx.STFDF'></span><span id='topic+na.spline.STFDF'></span>

<h3>Description</h3>

<p> replace NA attribute values in time series, using last or
next observation, or using (temporal) interpolation, and disaggregation </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'STFDF'
na.locf(object, na.rm = FALSE, ...)
## S3 method for class 'STFDF'
na.approx(object, x = time(object), xout, ..., na.rm = TRUE)
## S3 method for class 'STFDF'
na.spline(object, x = time(object), xout, ..., na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.locf_+3A_object">object</code></td>
<td>
<p> object of class <code>STFDF</code>, with potentially NA values </p>
</td></tr>
<tr><td><code id="na.locf_+3A_na.rm">na.rm</code></td>
<td>
<p> logical; need non-replaced NA values be removed? </p>
</td></tr>
<tr><td><code id="na.locf_+3A_x">x</code></td>
<td>
<p> times at which observations are taken; should not be modified </p>
</td></tr>
<tr><td><code id="na.locf_+3A_xout">xout</code></td>
<td>
<p> if present, new times at which the time series should be
approximated (disaggregated) </p>
</td></tr>
<tr><td><code id="na.locf_+3A_...">...</code></td>
<td>
<p> passed on to underlying zoo functions; see details </p>
</td></tr>
</table>


<h3>Details</h3>

<p>details are found in
<a href="zoo.html#topic+na.locf">na.locf</a>,
<a href="zoo.html#topic+na.approx">na.approx</a>,
<a href="zoo.html#topic+na.spline">na.spline</a>.
</p>


<h3>Value</h3>

<p>object of class <code>STFDF</code>, with <code>NA</code> values replaced.
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma</p>


<h3>References</h3>

<p> https://www.jstatsoft.org/v51/i07/ </p>


<h3>Examples</h3>

<pre><code class='language-R'># toy example:
library(sp)
pts = SpatialPoints(cbind(c(0,1),c(0,1)))
Sys.setenv(TZ="GMT")
tm = seq(as.POSIXct("2012-11-25"), as.POSIXct("2012-11-30"), "1 day")
df = data.frame(a = c(NA,NA,2,3,NA,NA,NA,2,NA,NA,4,NA), b = c(NA,2,3,4,5,1,2,NA,NA,NA,NA,3))
x = STFDF(pts, tm, df)
as(x, "xts")
as(na.locf(x), "xts")
as(na.locf(x, fromLast = TRUE), "xts")
as(na.locf(na.locf(x), fromLast = TRUE), "xts")
# drops first record:
as(na.approx(x[,,1]), "xts")
# keep it:
cbind(as(na.approx(x[,,1], na.rm=FALSE), "xts"),
as(na.approx(x[,,2]), "xts"))
cbind(as(na.spline(x[,,1]), "xts"),
as(na.spline(x[,,2]), "xts"))
#disaggregate:
xout = seq(start(x), end(x), "6 hours")
as(na.approx(x[,,1], xout = xout), "xts")
as(na.spline(x[,,1], xout = xout), "xts")
as(na.spline(x[,,2], xout = xout), "xts")

# larger/real data:
data(air)
rural = STFDF(stations, dates, data.frame(PM10 = as.vector(air)))
# fill NA's with last non-NA
r = na.locf(rural)
# sample (NOT aggregate) to monthly:
m = seq(start(rural), end(rural), "1 month")
stplot(na.approx(rural[1:20,"2003::2005"], xout = m), mode = 'ts')
</code></pre>

<hr>
<h2 id='nbMult'> convert a spatial nb object to a matching STF object </h2><span id='topic+nbMult'></span><span id='topic+nbMult'></span>

<h3>Description</h3>

<p> convert a spatial nb object to a matching STF object </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
nbMult(nb, st, addT = TRUE, addST = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbMult_+3A_nb">nb</code></td>
<td>
<p> object of class nb (see package spdep), which is valid for
the spatial slot of object <code>st</code>: <code>length(nb)</code> should equal
<code>length(st@sp)</code></p>
</td></tr>
<tr><td><code id="nbMult_+3A_st">st</code></td>
<td>
<p> object of class STF </p>
</td></tr>
<tr><td><code id="nbMult_+3A_addt">addT</code></td>
<td>
<p> logical; should temporal neighbours be added? </p>
</td></tr>
<tr><td><code id="nbMult_+3A_addst">addST</code></td>
<td>
<p> logical; should spatio-temporal neighbours be added? </p>
</td></tr>
</table>


<h3>Details</h3>

<p> if both <code>addT</code> and <code>addST</code> are false, only
spatial neighbours are added for each time replicate.
</p>
<p>details are found in 
</p>
<p>Giovana M. de Espindola, Edzer Pebesma, Gilberto
CÃ¢mara, 2011.  Spatio-temporal regression
models for deforestation in the Brazilian Amazon.
STDM 2011, The International Symposium on Spatial-Temporal Analysis
and Data Mining, University College London - 18th-20th July 2011.
</p>


<h3>Value</h3>

<p> object of class <code>nb</code> </p>


<h3>Author(s)</h3>

<p>Edzer Pebesma</p>

<hr>
<h2 id='over-methods'> consistent spatio-temporal overlay for objects inheriting from ST </h2><span id='topic+over'></span><span id='topic+aggregate'></span><span id='topic+over+2Cxts+2Cxts-method'></span><span id='topic+over+2CST+2CSTS-method'></span><span id='topic+over+2CSTF+2CSTF-method'></span><span id='topic+over+2CSTS+2CSTF-method'></span><span id='topic+over+2CSTI+2CSTF-method'></span><span id='topic+over+2CSTF+2CSTS-method'></span><span id='topic+over+2CSTS+2CSTS-method'></span><span id='topic+over+2CSTI+2CSTS-method'></span><span id='topic+over+2CSTF+2CSTI-method'></span><span id='topic+over+2CSTS+2CSTI-method'></span><span id='topic+over+2CSTI+2CSTI-method'></span><span id='topic+over+2CSTF+2CSTFDF-method'></span><span id='topic+over+2CSTS+2CSTFDF-method'></span><span id='topic+over+2CSTI+2CSTFDF-method'></span><span id='topic+over+2CSTF+2CSTSDF-method'></span><span id='topic+over+2CSTS+2CSTSDF-method'></span><span id='topic+over+2CSTI+2CSTSDF-method'></span><span id='topic+over+2CSTF+2CSTIDF-method'></span><span id='topic+over+2CSTS+2CSTIDF-method'></span><span id='topic+over+2CSTI+2CSTIDF-method'></span><span id='topic+aggregate+2CST-method'></span>

<h3>Description</h3>

<p> consistent spatio-temporal overlay for STF, STS and STI
objects, as well as their *DF counterpart: 
retrieves the indexes or attributes from one geometry at the spatio-temporal
points of another </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'STF,STF'
over(x, y, returnList = FALSE, fn = NULL, ...)
## S4 method for signature 'xts,xts'
over(x, y, returnList = FALSE, fn = NULL, ...)
## S4 method for signature 'ST'
aggregate(x, by, FUN, ..., simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="over-methods_+3A_x">x</code></td>
<td>
<p>geometry (S/T locations) of the queries</p>
</td></tr>
<tr><td><code id="over-methods_+3A_y">y</code></td>
<td>
<p>layer from which the geometries or attributes are queried</p>
</td></tr>
<tr><td><code id="over-methods_+3A_returnlist">returnList</code></td>
<td>
<p> logical; determines whether a list is returned, 
or an index vector </p>
</td></tr>
<tr><td><code id="over-methods_+3A_fn">fn</code></td>
<td>
<p>(optional) a function; see value </p>
</td></tr>
<tr><td><code id="over-methods_+3A_by">by</code></td>
<td>
<p> geometry over which attributes in <code>x</code> are aggregated
(this can be a <code>Spatial*</code> geometry, or a <code>ST*</code> geometry), or
temporal aggregation, such as &quot;month&quot;, &quot;10 minutes&quot;, or a function such
as <a href="zoo.html#topic+as.yearmon">as.yearmon</a>; see <a href="zoo.html#topic+aggregate.zoo">aggregate.zoo</a>. In case <code>x</code>
is of class <a href="#topic+STFDF">STFDF</a>, argument <code>by</code> may be &quot;time&quot; or &quot;space&quot;, in
which cases aggregation over all time or all space is carried out.</p>
</td></tr>
<tr><td><code id="over-methods_+3A_fun">FUN</code></td>
<td>
<p>aggregation function</p>
</td></tr>
<tr><td><code id="over-methods_+3A_simplify">simplify</code></td>
<td>
<p>boolean; if TRUE, and space or time dimensions can be
dropped, the simpler (<code>Spatial</code> or <code>xts</code>) object will be returned </p>
</td></tr>
<tr><td><code id="over-methods_+3A_...">...</code></td>
<td>
<p>arguments passed on to function fn or FUN</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>an object of length <code>length(x)</code>, or a data.frame with number
of rows equal to <code>length(x)</code>. If <code>returnList</code> is FALSE,
a vector with indices of <code>y</code> for each geometry (point, grid
cell centre, polygon or lines x time point) in <code>x</code>.  if <code>returnList</code> is
TRUE, a list of length <code>length(x)</code>, with list element <code>i</code>
the vector of indices of the geometries in <code>y</code> that correspond
to the $i$-th geometry in <code>x</code>.
</p>
<p>The <code>aggregate</code> method for <code>ST</code> objects aggregates the attribute values of <code>x</code>
over the geometry (space, time, or space-time) of <code>by</code>, using
aggregation function <code>FUN</code>.
</p>
<p>For the matching of time intervals, see <a href="#topic+timeMatch">timeMatch</a>.
</p>
<p>For setting, or retrieving whether time represents intervals, see
<a href="#topic+timeIsInterval">timeIsInterval</a>.
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;STF&quot;, y = &quot;STF&quot;</dt><dd> </dd>
<dt>x = &quot;xts&quot;, y = &quot;xts&quot;</dt><dd><p> finds the row index of the instance
or interval of time instances of <code>x</code> matching to <code>y</code>. Only if
<code>timeIsInterval(x) == TRUE</code>, intervals are sought. In that case,
time intervals start at the time instance of a record, and end at
the next. The last time interval length is set to the interval length
of the one-but-last (non-zero) interval. In case of a single time
instance for <code>y</code>, its interval is right-open.  </p>
</dd>
</dl>



<h3>Note</h3>

<p>See also <a href="sp.html#topic+over">over</a>; methods intersecting SpatialLines with
anything else, or SpatialPolygons with SpatialPolygons, need rgeos
to be loaded first.
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a></p>


<h3>References</h3>

<p> https://www.jstatsoft.org/article/view/v051i07 </p>


<h3>See Also</h3>

<p><a href="sp.html#topic+over">over</a>; <code>vignette('sto')</code>, <code>vignette('over')</code>, 
<a href="#topic+timeMatch">timeMatch</a>, <a href="#topic+timeIsInterval">timeIsInterval</a></p>

<hr>
<h2 id='read.tgrass'> read or write tgrass (time-enabled grass) files </h2><span id='topic+read.tgrass'></span><span id='topic+write.tgrass'></span>

<h3>Description</h3>

<p> read or write tgrass (time-enabled grass) files </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
read.tgrass(fname, localName = TRUE, useTempDir = TRUE, isGeoTiff = TRUE)
write.tgrass(obj, fname, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.tgrass_+3A_fname">fname</code></td>
<td>
<p> file name to read from, or write to </p>
</td></tr>
<tr><td><code id="read.tgrass_+3A_localname">localName</code></td>
<td>
<p> logical; if TRUE, <code>fname</code> is a local file, else
it is a the full path name to the file </p>
</td></tr>
<tr><td><code id="read.tgrass_+3A_usetempdir">useTempDir</code></td>
<td>
<p> logical: use a temporary directory for extraction?</p>
</td></tr>
<tr><td><code id="read.tgrass_+3A_isgeotiff">isGeoTiff</code></td>
<td>
<p> logical: are the files in the tar.gz file GeoTIFFs?</p>
</td></tr>
<tr><td><code id="read.tgrass_+3A_obj">obj</code></td>
<td>
<p> object to export, of class <code>STFDF</code> or <code>RasterStack</code></p>
</td></tr>
<tr><td><code id="read.tgrass_+3A_...">...</code></td>
<td>
<p> arguments passed on to <a href="raster.html#topic+writeRaster">writeRaster</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p> The tgrass format is a gzip'ed tar file (.tar.gz) that
has geotiff files (with suffix .tif), and three files (list.txt, proj.txt 
and init.txt) describing the file names and time slices,
coordinate reference system, and dimensions </p>


<h3>Value</h3>

<p><code>read.tgrass</code> returns an object of class <code>RasterStack</code>,
<code>writegrass</code> returns nothing</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma; time-enabled grass by Soeren Gebbert </p>


<h3>References</h3>

<p> https://dx.doi.org/10.1016/j.envsoft.2013.11.001 </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(spacetime)
r = read.tgrass("precipitation_1950_2011_yearly.tar.gz", useTempDir = FALSE)
write.tgrass(r, "myfile.tar.gz")

## End(Not run)
</code></pre>

<hr>
<h2 id='ST-class'>Class &quot;ST&quot;</h2><span id='topic+ST-class'></span><span id='topic+xts-class'></span><span id='topic+zoo-class'></span><span id='topic+ST'></span><span id='topic+dim.ST'></span><span id='topic++5B+5B+3C-+2CST+2CANY+2Cmissing-method'></span><span id='topic++5B+5B+2CST+2CANY+2Cmissing-method'></span><span id='topic++24+3C-+2CST-method'></span><span id='topic++24+2CST-method'></span><span id='topic+cbind.ST'></span><span id='topic+is.projected+2CST-method'></span><span id='topic+proj4string+2CST-method'></span><span id='topic+proj4string+3C-+2CST+2CCRS-method'></span><span id='topic+proj4string+3C-+2CST+2Ccharacter-method'></span><span id='topic+geometry+2CST-method'></span>

<h3>Description</h3>

<p> An abstract class from which useful spatio-temporal classes are
derived </p>


<h3>Usage</h3>

<pre><code class='language-R'>ST(sp, time, endTime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ST-class_+3A_sp">sp</code></td>
<td>
<p>an object deriving from class <a href="sp.html#topic+Spatial">Spatial</a>, such as
a <a href="sp.html#topic+SpatialPoints">SpatialPoints</a> or <a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></p>
</td></tr>
<tr><td><code id="ST-class_+3A_time">time</code></td>
<td>
<p>an object of class xts, or a time vector
(currently: Date, POSIXct, timeDate, yearmon and yearqtr; are supported;
see <a href="xts.html#topic+xts">xts</a>); in the latter case, it should be in time order </p>
</td></tr>
<tr><td><code id="ST-class_+3A_endtime">endTime</code></td>
<td>
<p> vector of class <code>POSIXct</code> holding end points of
time intervals </p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects of this class are not meant to be useful; only derived
classes can be meaningful </p>


<h3>Slots</h3>


<dl>
<dt><code>sp</code>:</dt><dd><p>Object deriving from class <code>"Spatial"</code></p>
</dd>
<dt><code>time</code>:</dt><dd><p>Object of class <code>"xts"</code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[[</dt><dd><p><code>signature(obj = "ST")</code>: retrieves the attribute element </p>
</dd>
<dt>$</dt><dd><p><code>signature(obj = "ST")</code>: retrieves the attribute element </p>
</dd>
<dt>[[&lt;-</dt><dd><p><code>signature(obj = "ST")</code>: sets or replaces the attribute element </p>
</dd>
<dt>$&lt;-</dt><dd><p><code>signature(obj = "ST")</code>: sets or replaces the attribute element </p>
</dd>




</dl>



<h3>Note</h3>

<p>argument (and object slot) sp can be pure geometry, or geometry
with attributes. In the latter case, the geometries are kept with
the sp slot, and only replicated (when needed) on coercion to the
long format, with as.data.frame.
</p>
<p>Slot time needs to be of class xts; if a time or date vector is 
passed as argument to SP, it will be converted into an xts object.
</p>
<p>When <code>endTime</code> is missing, an error is thrown.
</p>
<p>ST is meant as a super-class, and is not to be used for representing
data, similar to Spatial in the sp package.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>References</h3>

<p> https://www.jstatsoft.org/v51/i07/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>time = as.Date('2008-01-01')+1:2
library(sp)
sp = SpatialPoints(cbind(c(0,1),c(0,1)))
ST(sp, time, delta(time))
</code></pre>

<hr>
<h2 id='stbox'> obtain ranges of space and time coordinates </h2><span id='topic+stbox'></span><span id='topic+bbox'></span><span id='topic+stbox+2CST-method'></span><span id='topic+bbox+2CST-method'></span>

<h3>Description</h3>

<p> obtain ranges of space and time coordinates </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
stbox(obj)
bbox(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stbox_+3A_obj">obj</code></td>
<td>
<p> object of a class deriving from <code>ST</code> 
</p>
</td></tr>
</table>


<h3>Value</h3>

 <p><code>stbox</code> returns a <code>data.frame</code>, with three columns
representing x-, y- and time-coordinates, and two rows containing min
and max values. <code>bbox</code> gives a matrix with coordinate min/max values,
compatible to <a href="sp.html#topic+bbox">bbox</a></p>


<h3>Methods</h3>


<dl>
<dt>stbox</dt><dd><p><code>signature(x = "ST")</code>: obtain st range from object</p>
</dd>
</dl>


<hr>
<h2 id='stConstruct'> create ST* objects from long or wide tables </h2><span id='topic+stConstruct'></span>

<h3>Description</h3>

<p> create ST* objects from long or wide tables </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
stConstruct(x, space, time, SpatialObj = NULL, TimeObj = NULL, 
	crs = CRS(as.character(NA)), interval, endTime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stConstruct_+3A_x">x</code></td>
<td>
<p> object of class <code>matrix</code> or <code>data.frame</code>,
holding the long, space-wide or time-wide table; see details. </p>
</td></tr>
<tr><td><code id="stConstruct_+3A_space">space</code></td>
<td>
<p> in case <code>x</code> is a long table,
character or integer holding the column index in <code>x</code> where the spatial
coordinates are (if length(space)==2) or where the ID of the spatial
location is (if (length(space)==1). If <code>x</code> is a space-wide table,
a list with each (named) list element a set of columns that together
form a variable </p>
</td></tr>
<tr><td><code id="stConstruct_+3A_time">time</code></td>
<td>
<p> in case <code>x</code> is a long table, character or integer 
indicating the column in <code>x</code> with times; </p>
</td></tr>
<tr><td><code id="stConstruct_+3A_spatialobj">SpatialObj</code></td>
<td>
<p> object of class <a href="sp.html#topic+Spatial-class">Spatial-class</a>, containing the
locations of a time-wide table, or the locations of a long table  </p>
</td></tr>
<tr><td><code id="stConstruct_+3A_timeobj">TimeObj</code></td>
<td>
<p> in case of space-wide table, 
object of class <a href="xts.html#topic+xts">xts</a>, containing the times for each 
of the columns in a list element of <code>space</code>
</p>
</td></tr>
<tr><td><code id="stConstruct_+3A_crs">crs</code></td>
<td>
<p> object of class <a href="sp.html#topic+CRS-class">CRS-class</a>; only used when coordinates
are in <code>x</code> and no CRS can be taken from <code>SpatialObj</code></p>
</td></tr>
<tr><td><code id="stConstruct_+3A_interval">interval</code></td>
<td>
<p> logical; specifies whether time should reflect time
instance (FALSE) or time intervals (TRUE). If omitted, defaults values
depend on the class </p>
</td></tr>
<tr><td><code id="stConstruct_+3A_endtime">endTime</code></td>
<td>
<p> vector of <code>POSIXct</code>, specifying (if present) the end
points of observation time intervals </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples, see below.
</p>
<p>A long table is a data.frame with each row holding a single
observation in space-time, and particular columns in this table
indicate the space (location or location ID) and time.
</p>
<p>A space-wide table is a table in which different columns refer to
different locations, and each row reflects a particular observation
time.
</p>
<p>A time-wide table is a table where different times of a particular
characteristic are represented as different colunns; rows in the
table represent particular locations or location IDs.
</p>


<h3>Value</h3>

<p>Depending on the arguments, an object of class <code>STIDF</code>
or <code>STFDF</code>.
</p>


<h3>References</h3>

<p> https://www.jstatsoft.org/v51/i07/ </p>


<h3>Examples</h3>

<pre><code class='language-R'># stConstruct multivariable, time-wide
if (require(maps) &amp;&amp; require(plm) &amp;&amp; require(sf)) {
 library(sp)

 states.m &lt;- map('state', plot=FALSE, fill=TRUE)
 IDs &lt;- sapply(strsplit(states.m$names, ":"), function(x) x[1])
 sf = st_as_sf(states.m, IDs=IDs)
 row.names(sf) = sf$ID # not needed if sf &gt;= 1.0-13
 states &lt;- as(sf, "Spatial")
 states=geometry(states)

 yrs = 1970:1986
 time = as.POSIXct(paste(yrs, "-01-01", sep=""), tz = "GMT")
 data("Produc")
# deselect District of Columbia, polygon 8, which is not present in Produc:
 Produc.st &lt;- STFDF(states[-8], time, Produc[order(Produc[,2], Produc[,1]),])
 # stplot(Produc.st[,,"unemp"], yrs, col.regions = brewer.pal(9, "YlOrRd"),cuts=9)

 # example 1: st from long table, with states as Spatial object:
 # use Date format for time:
 Produc$time = as.Date(paste(yrs, "01", "01", sep = "-"))
 # take centroids of states:
 xy = coordinates(states[-8])
 Produc$x = xy[,1]
 Produc$y = xy[,2]
 #using stConstruct, use polygon centroids for location:
 x = stConstruct(Produc, c("x", "y"), "time", interval = TRUE)
 class(x)
 stplot(x[,,"unemp"])

 # alternatively, pass states as SpatialObj:
 Produc$state = gsub("TENNESSE", "TENNESSEE", Produc$state)
 Produc$State = gsub("_", " ", tolower(Produc$state))
 x = stConstruct(Produc, "State", "time", states)
 class(x)
 all.equal(x, Produc.st, check.attributes = FALSE)
}

if (require(sf)) {
fname = system.file("shape/nc.shp", package="sf")[1]
nc = as(st_read(fname), "Spatial")
timesList = list(
	BIR=c("BIR74", "BIR79"),  # sets of variables that belong together
	NWBIR=c("NWBIR74", "NWBIR79"), # only separated by space
	SID=c("SID74", "SID79")
)
t = as.Date(c("1974-01-01","1979-01-01"))
nc.st = stConstruct(as(nc, "data.frame"), geometry(nc), timesList,
	TimeObj = t, interval = TRUE)

}
# stConstruct multivariable, space-wide
if (require(gstat)) {
data(wind)
wind.loc$y = as.numeric(char2dms(as.character(wind.loc[["Latitude"]])))
wind.loc$x = as.numeric(char2dms(as.character(wind.loc[["Longitude"]])))
coordinates(wind.loc) = ~x+y
proj4string(wind.loc) = "+proj=longlat +datum=WGS84"

# match station order to names in wide table:
stations = 4:15
wind.loc = wind.loc[match(names(wind[stations]), wind.loc$Code),]
row.names(wind.loc) = wind.loc$Station
# convert to utm zone 29, to be able to do interpolation in
# proper Euclidian (projected) space:

# create time variable
wind$time = ISOdate(wind$year+1900, wind$month, wind$day, 0)

w = STFDF(wind.loc, wind$time, 
	data.frame(values = as.vector(t(wind[stations]))))
space = list(values = names(wind)[stations])
wind.st = stConstruct(wind[stations], space, wind$time, SpatialObj = wind.loc, interval = TRUE)
all.equal(w, wind.st)
class(wind.st)
}
</code></pre>

<hr>
<h2 id='STFDF-class'>Class &quot;STFDF&quot;</h2><span id='topic+STFDF-class'></span><span id='topic+STF-class'></span><span id='topic+STFDF'></span><span id='topic+STF'></span><span id='topic+as.data.frame.STF'></span><span id='topic++5B+2CSTF-method'></span><span id='topic++5B+2CSTFDF-method'></span><span id='topic+coerce+2CSTFDF+2Cxts-method'></span><span id='topic+coerce+2CSTFDF+2CSpatial-method'></span><span id='topic+plot+2CSTF+2Cmissing-method'></span><span id='topic+plot+2CSTFDF+2Cmissing-method'></span><span id='topic+geometry+2CSTFDF-method'></span><span id='topic+na.omit.STFDF'></span><span id='topic+rbind.STFDF'></span><span id='topic+as.zoo'></span><span id='topic+as.zoo.STFDF'></span>

<h3>Description</h3>

<p> A class for spatio-temporal data with full space-time grid; for
n spatial locations and m times, n x m observations are available </p>


<h3>Usage</h3>

<pre><code class='language-R'>  STF(sp, time, endTime = delta(time))
  STFDF(sp, time, data, endTime = delta(time))
  ## S4 method for signature 'STFDF'
x[i, j, ..., drop = is(x, "STFDF")]
  ## S4 method for signature 'STFDF,xts'
coerce(from, to, strict=TRUE)
  ## S4 method for signature 'STFDF,Spatial'
coerce(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STFDF-class_+3A_sp">sp</code></td>
<td>
<p>object of class <a href="sp.html#topic+Spatial">Spatial</a>, having <code>n</code> elements</p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_time">time</code></td>
<td>
<p>object holding time information, of length <code>m</code>;
see <a href="#topic+ST">ST</a> for details</p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_endtime">endTime</code></td>
<td>
<p> vector of class <code>POSIXct</code>, holding end points
of time intervals; by default, time intervals equal the time step
width, see <a href="#topic+delta">delta</a> </p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_data">data</code></td>
<td>
<p>data frame with <code>n*m</code> rows corresponding to the
observations (spatial index moving fastest)</p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_x">x</code></td>
<td>
<p>an object of class STFDF</p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_i">i</code></td>
<td>
<p>selection of spatial entities</p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_j">j</code></td>
<td>
<p>selection of temporal entities (see syntax in package xts) </p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_...">...</code></td>
<td>
<p>selection of attribute(s)</p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_drop">drop</code></td>
<td>
<p>if TRUE and a single spatial entity is selected, an object
of class <a href="xts.html#topic+xts">xts</a> is returned; if TRUE and a single temporal entity is
selected, and object of the appropriate <code>Spatial</code> class is returned;
if FALSE, no coercion to reduced classes takes place</p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_from">from</code></td>
<td>
<p>object of class STFDF</p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_to">to</code></td>
<td>
<p>target class</p>
</td></tr>
<tr><td><code id="STFDF-class_+3A_strict">strict</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>as.data.frame</code> coercion returns the full long table,
with purely spatial attributes and purely time attributes replicated
appropriately. </p>


<h3>Objects from the Class</h3>

<p>Objects of this class represent full space/time data with a full grid 
(or lattice) layout </p>


<h3>Slots</h3>


<dl>
<dt><code>sp</code>:</dt><dd><p>spatial object; see <a href="#topic+ST-class">ST-class</a></p>
</dd>
<dt><code>time</code>:</dt><dd><p>temporal object; see <a href="#topic+ST-class">ST-class</a></p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>data.frame</code>, which holds
the measured values; space index cycling first, time order preserved</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "STFDF")</code>: selects spatial entities,        temporal entities, and attributes </p>
</dd> 
<dt>coerce</dt><dd><p>STFDF,xts</p>
</dd>
<dt>coerce</dt><dd><p>STFDF,Spatial</p>
</dd></dl>
<p>(from) coerces to (wide form) SpatialXxDataFrame,
where SpatialXx is the spatial class of from@sp
</p>
<dl>
<dt>plot</dt><dd><p><code>signature(x = "STF", y = "missing")</code>: plots space-time
layout </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "STFDF", y = "missing")</code>: plots space-time
layout, indicating full missing valued records </p>
</dd>



</dl>



<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>References</h3>

<p> https://www.jstatsoft.org/v51/i07/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>sp = cbind(x = c(0,0,1), y = c(0,1,1))
row.names(sp) = paste("point", 1:nrow(sp), sep="")
library(sp)
sp = SpatialPoints(sp)
time = as.POSIXct("2010-08-05")+3600*(10:13)
m = c(10,20,30) # means for each of the 3 point locations
mydata = rnorm(length(sp)*length(time),mean=rep(m, 4))
IDs = paste("ID",1:length(mydata))
mydata = data.frame(values = signif(mydata,3), ID=IDs)
stfdf = STFDF(sp, time, mydata)
stfdf
stfdf[1:2,]
stfdf[,1:2]
stfdf[,,2]
stfdf[,,"values"]
stfdf[1,]
stfdf[,2]
as(stfdf[,,1], "xts")
as(stfdf[,,2], "xts")
# examples for [[, [[&lt;-, $ and $&lt;- 
stfdf[[1]]
stfdf[["values"]]
stfdf[["newVal"]] &lt;- rnorm(12)
stfdf$ID
stfdf$ID = paste("OldIDs", 1:12, sep="")
stfdf$NewID = paste("NewIDs", 12:1, sep="")
stfdf
x = stfdf[stfdf[1:2,],] 
all.equal(x, stfdf[1:2,]) 
all.equal(stfdf, stfdf[stfdf,]) # converts character to factor...
</code></pre>

<hr>
<h2 id='STIDF-class'>Class &quot;STIDF&quot;</h2><span id='topic+STIDF-class'></span><span id='topic+STI-class'></span><span id='topic+STIDF'></span><span id='topic+STI'></span><span id='topic+as.data.frame.STIDF'></span><span id='topic+as.data.frame.STI'></span><span id='topic++5B+2CSTIDF-method'></span><span id='topic++5B+2CSTI-method'></span><span id='topic+geometry+2CSTIDF-method'></span><span id='topic+geometry+2CSTI-method'></span><span id='topic+coerce+2CSTIDF+2CSTSDF-method'></span><span id='topic+plot+2CSTI+2Cmissing-method'></span><span id='topic+rbind.STIDF'></span>

<h3>Description</h3>

<p> A class for unstructured spatio-temporal data; for
n spatial locations and times, n observations are available </p>


<h3>Usage</h3>

<pre><code class='language-R'>  STI(sp, time, endTime)
  STIDF(sp, time, data, endTime)
  ## S4 method for signature 'STIDF'
x[i, j, ..., drop = FALSE]
  ## S4 method for signature 'STIDF,STSDF'
coerce(from, to, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STIDF-class_+3A_sp">sp</code></td>
<td>
<p>object of class <a href="sp.html#topic+Spatial">Spatial</a></p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_time">time</code></td>
<td>
<p>object holding time information; when STIDF is called,
a non-ordered vector with times, e.g. <a href="base.html#topic+POSIXct">POSIXct</a> will also work,
and rearrange the <code>sp</code> and <code>data</code> slots
according to the ordering of time; for this to work no
ties should exist. </p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_endtime">endTime</code></td>
<td>
<p> vector of class <code>POSIXct</code>, indicating the end
points of time intervals for the observations. By default, for <code>STI</code>
objects <code>time</code> is taken, indicating that time intervals have zero width 
(time instances) </p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_data">data</code></td>
<td>
<p>data frame with appropriate number of rows</p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_x">x</code></td>
<td>
<p>an object of class STFDF</p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_i">i</code></td>
<td>
<p>selection of record index (spatial/temporal/spatio-temporal entities)</p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_j">j</code></td>
<td>
<p> or character string with temporal selection </p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_...">...</code></td>
<td>
<p>first element is taken as column (variable) selector</p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_drop">drop</code></td>
<td>
<p>if TRUE and a single spatial entity is selected, an object
of class <a href="xts.html#topic+xts">xts</a> is returned (NOT yet implemented);
if TRUE and a single temporal entity is
selected, and object of the appropriate <code>Spatial</code> class is returned;
if FALSE, no coercion to reduced classes takes place</p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_from">from</code></td>
<td>
<p>object of class STFDF</p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_to">to</code></td>
<td>
<p>target class</p>
</td></tr>
<tr><td><code id="STIDF-class_+3A_strict">strict</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects of this class carry full space/time grid data </p>


<h3>Slots</h3>


<dl>
<dt><code>sp</code>:</dt><dd><p>Object of class <code>"Spatial"</code></p>
</dd>
<dt><code>time</code>:</dt><dd><p>Object holding time information, see <a href="#topic+ST-class">ST-class</a></p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>data.frame</code>, which holds
the measured values </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "STIDF")</code>: selects spatial-temporal entities, and attributes </p>
</dd> 




</dl>



<h3>Note</h3>

<p> arguments <code>sp</code>, <code>time</code> and <code>data</code> need 
to have the same number of records,
and regardless of the class of time (xts or POSIXct) have to be
in correspoinding order: the triple <code>sp[i]</code>, <code>time[i]</code>
and <code>data[i,]</code> refer to the same observation </p>


<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>References</h3>

<p> https://www.jstatsoft.org/v51/i07/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>sp = cbind(x = c(0,0,1), y = c(0,1,1))
row.names(sp) = paste("point", 1:nrow(sp), sep="")
library(sp)
sp = SpatialPoints(sp)
time = as.POSIXct("2010-08-05")+3600*(10:13)
m = c(10,20,30) # means for each of the 3 point locations
mydata = rnorm(length(sp)*length(time),mean=rep(m, 4))
IDs = paste("ID",1:length(mydata))
mydata = data.frame(values = signif(mydata,3), ID=IDs)
stidf = as(STFDF(sp, time, mydata), "STIDF")
stidf[1:2,]
all.equal(stidf, stidf[stidf,])
</code></pre>

<hr>
<h2 id='stInteraction'> subtract marginal (spatial and temporal) means from observations </h2><span id='topic+stInteraction'></span>

<h3>Description</h3>

<p>subtract marginal (spatial and temporal) means from observations </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
stInteraction(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stInteraction_+3A_x">x</code></td>
<td>
<p> object of class <code>STFDF</code></p>
</td></tr>
<tr><td><code id="stInteraction_+3A_...">...</code></td>
<td>
<p> arguments passed to <a href="Matrix.html#topic+rowMeans">rowMeans</a>, <a href="Matrix.html#topic+colMeans">colMeans</a> and <a href="base.html#topic+mean">mean</a>, such as <code>na.rm=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <a href="#topic+STFDF">STFDF</a> with each attribute replaced by its
residual, computed by <code class="reqn">y_{ij}=x_{ij}-m_{.j}m{i.}/m</code> with <code class="reqn">m</code> the
grand mean, <code class="reqn">m_{.j}</code> the temporal mean, <code class="reqn">m_{i.}</code> the spatial mean
and <code class="reqn">m</code> the grand mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(gstat)) {
library(sp)
data(wind)
wind.loc$y = as.numeric(char2dms(as.character(wind.loc[["Latitude"]])))
wind.loc$x = as.numeric(char2dms(as.character(wind.loc[["Longitude"]])))
coordinates(wind.loc) = ~x+y
proj4string(wind.loc) = "+proj=longlat +datum=WGS84"
# match station order to names in wide table:
stations = 4:15
wind.loc = wind.loc[match(names(wind[stations]), wind.loc$Code),]
row.names(wind.loc) = wind.loc$Station
wind$time = ISOdate(wind$year+1900, wind$month, wind$day, 0)
space = list(values = names(wind)[stations])
wind.st = stConstruct(wind[stations], space, wind$time, SpatialObj = wind.loc)

wind.sti = stInteraction(wind.st)
# temporal means for any station should be zero:
c(mean(wind.sti[3,]),
# spatial mean for each time step should be zero:
mean(wind.sti[,5][[1]]))
}

</code></pre>

<hr>
<h2 id='stplot'> produce trellis plot for STxDF object </h2><span id='topic+stplot'></span><span id='topic+stplot.STFDF'></span><span id='topic+stplot.STIDF'></span><span id='topic+stplot+2CSTFDF-method'></span><span id='topic+stplot+2CSTSDF-method'></span><span id='topic+stplot+2CSTIDF-method'></span><span id='topic+stplot+2CSTI-method'></span><span id='topic+stplot+2CSTT-method'></span><span id='topic+stplot+2CSTTDF-method'></span><span id='topic+stplot+2CRasterStackBrick-method'></span><span id='topic+stack.STFDF'></span><span id='topic+stack.STSDF'></span><span id='topic+stack.STIDF'></span><span id='topic+segPanel'></span><span id='topic+tracksPanel'></span>

<h3>Description</h3>

<p> create trellis plot for ST objects </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
stplot(obj, ...)
stplot.STFDF(obj, names.attr = trimDates(obj), ...,
	as.table = TRUE, at, cuts = 15, scales = list(draw = FALSE), 
	animate = 0, mode = "xy", scaleX = 0, auto.key = list(space = key.space), 
	main, key.space = "right", type = "l", do.repeat = TRUE, range.expand = 0.001)
stplot.STIDF(obj, ..., names.attr = NULL, as.table = TRUE,
	scales = list(draw = FALSE), xlab = NULL, ylab = NULL,
	type = "p", number = 6, tcuts, sp.layout = NULL, xlim =
	bbox(obj)[1, ], ylim = bbox(obj)[2, ])

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stplot_+3A_obj">obj</code></td>
<td>
<p> object of a class deriving from <code>ST</code></p>
</td></tr>
<tr><td><code id="stplot_+3A_names.attr">names.attr</code></td>
<td>
<p> names that will be used in the strip; trimDates(obj)
trims &quot;-01&quot; ending(s) from printed Dates </p>
</td></tr>
<tr><td><code id="stplot_+3A_as.table">as.table</code></td>
<td>
<p> logical; if TRUE, time will increas from top to bottom;
if FALSE, time will increase from bottom to top </p>
</td></tr>
<tr><td><code id="stplot_+3A_at">at</code></td>
<td>
<p> values at which colours will change; see <a href="lattice.html#topic+levelplot">levelplot</a></p>
</td></tr>
<tr><td><code id="stplot_+3A_cuts">cuts</code></td>
<td>
<p> number of levels the range of the attribute would be divided into </p>
</td></tr>
<tr><td><code id="stplot_+3A_animate">animate</code></td>
<td>
<p> numeric; if larger than 0, the number of seconds between
subsequent animated time steps (loop; press ctrl-C or Esc to stop) </p>
</td></tr>
<tr><td><code id="stplot_+3A_mode">mode</code></td>
<td>
<p> plotting mode; if &quot;xy&quot;, maps for time steps are plotted; 
if &quot;xt&quot;, a space-time plot is constructed (see argument <code>scaleX</code>,
but read details below); if &quot;ts&quot;, multiple-locations time series
are plotted in a single plot, or in a separate panel for each
attribute; if &quot;tp&quot; single- or multi-attribute time series are
plotted in multiple panels, one panel per location. </p>
</td></tr>
<tr><td><code id="stplot_+3A_scalex">scaleX</code></td>
<td>
<p> integer: 0, 1 or 2; when <code>mode</code> is &quot;xt&quot;, used to determine
whether the index of the spatial location is shown (0), the x coordinate (1)
or the y coordinate (2). </p>
</td></tr>
<tr><td><code id="stplot_+3A_auto.key">auto.key</code></td>
<td>
<p>see the <code>auto.key</code> argument in <a href="lattice.html#topic+xyplot">xyplot</a></p>
</td></tr>
<tr><td><code id="stplot_+3A_main">main</code></td>
<td>
<p>character; plot title, use <code>NULL</code> to omit title</p>
</td></tr>
<tr><td><code id="stplot_+3A_key.space">key.space</code></td>
<td>
<p>character; see <a href="lattice.html#topic+xyplot">xyplot</a></p>
</td></tr>
<tr><td><code id="stplot_+3A_scales">scales</code></td>
<td>
<p> scales drawing; see <code>scales</code> argument of <a href="lattice.html#topic+xyplot">xyplot</a></p>
</td></tr>
<tr><td><code id="stplot_+3A_xlab">xlab</code></td>
<td>
<p> x-axis label</p>
</td></tr>
<tr><td><code id="stplot_+3A_ylab">ylab</code></td>
<td>
<p> y-axis label </p>
</td></tr>
<tr><td><code id="stplot_+3A_type">type</code></td>
<td>
<p> character; use 'l' for lines, 'p' for symbols,
'b' for both lines and symbols </p>
</td></tr>
<tr><td><code id="stplot_+3A_do.repeat">do.repeat</code></td>
<td>
<p> logical; repeat the animation in an infinite loop? </p>
</td></tr>
<tr><td><code id="stplot_+3A_range.expand">range.expand</code></td>
<td>
<p> numeric; if <code>at</code> is not specified, 
expand the data range with this factor to cover all values </p>
</td></tr>
<tr><td><code id="stplot_+3A_number">number</code></td>
<td>
<p> number of time intervals, equally spaced </p>
</td></tr>
<tr><td><code id="stplot_+3A_tcuts">tcuts</code></td>
<td>
<p>time cuts in units of <code>index(obj)</code>; this overrides <code>number</code></p>
</td></tr>
<tr><td><code id="stplot_+3A_sp.layout">sp.layout</code></td>
<td>
<p>list or NULL; see <a href="sp.html#topic+spplot">spplot</a></p>
</td></tr>
<tr><td><code id="stplot_+3A_...">...</code></td>
<td>
<p> arguments passed on to <a href="sp.html#topic+spplot">spplot</a> in case of 
plotting objects of class <code>STFDF</code> or <code>STIDF</code>,
or to <a href="lattice.html#topic+xyplot">xyplot</a> in case of stplot.STIDF</p>
</td></tr>
<tr><td><code id="stplot_+3A_xlim">xlim</code></td>
<td>
<p>numeric, x range</p>
</td></tr>
<tr><td><code id="stplot_+3A_ylim">ylim</code></td>
<td>
<p>numeric, y range</p>
</td></tr>
</table>


<h3>Value</h3>

<p> In non-animation and &quot;xy&quot; mode, <code>stplot</code> is a wrapper
around <a href="sp.html#topic+spplot">spplot</a>, that automically plots each time stamp in
a panel.  The returned value is is a lattice plot.
</p>
<p>In &quot;xt&quot; mode, a space-time plot with space on the x-axis and time
on the y-axis is plotted. By default, the space ID is plotted on the
x-axis, as space can be anything (points, polygons, grid cells etc).
When <code>scaleX</code> is set to 1 or 2, the x- resp. y-coordinates
of the spatial locations, obtained by <a href="sp.html#topic+coordinates">coordinates</a>, is
used instead. Beware: when the x-coordinate is plotted, and for
each (x,t) element multiple y-coordinates are sent to the plot,
it is not clear which (x,y,t) value becomes the plotted value,
so slicing single y values is adviced &ndash; no checking is done.
The returned value is is a lattice plot.
</p>
<p>In animation mode (<code>animate</code> &gt; 0), single maps are animated
in an endless loop, with <code>animate</code> seconds between each. No
proper value is returned: the loop needs to be interrupted by
the user.
</p>


<h3>Methods</h3>


<dl>
<dt>stplot</dt><dd><p><code>signature(x = "STFDF")</code>: plots object of class <a href="#topic+STFDF">STFDF</a></p>
</dd>
<dt>stplot</dt><dd><p><code>signature(x = "STSDF")</code>: plots object of class <a href="#topic+STSDF">STSDF</a></p>
</dd>
<dt>stplot</dt><dd><p><code>signature(x = "STI")</code>: plots object of class <a href="#topic+STI">STI</a></p>
</dd>
<dt>stplot</dt><dd><p><code>signature(x = "STIDF")</code>: plots object of class <a href="#topic+STIDF">STIDF</a></p>
</dd>
<dt>stplot</dt><dd><p><code>signature(x = "STT")</code>: plots object of class <a href="#topic+STT">STT</a></p>
</dd>
<dt>stplot</dt><dd><p><code>signature(x = "STTDF")</code>: plots object of class <a href="#topic+STTDF">STTDF</a></p>
</dd>
</dl>



<h3>Note</h3>

<p>vignette(&quot;spacetime&quot;) contains several examples</p>


<h3>References</h3>

<p> https://www.jstatsoft.org/v51/i07/ </p>

<hr>
<h2 id='STSDF-class'>Class &quot;STSDF&quot;</h2><span id='topic+STSDF-class'></span><span id='topic+STS-class'></span><span id='topic+STSDF'></span><span id='topic+STS'></span><span id='topic+as.data.frame.STSDF'></span><span id='topic+as.data.frame.STS'></span><span id='topic++5B+2CSTS-method'></span><span id='topic++5B+2CSTSDF-method'></span><span id='topic+coerce+2CSTSDF+2CSTFDF-method'></span><span id='topic+coerce+2CSTSDF+2CSTIDF-method'></span><span id='topic+geometry+2CSTSDF-method'></span><span id='topic+plot+2CSTS+2Cmissing-method'></span><span id='topic+plot+2CSTSDF+2Cmissing-method'></span><span id='topic+rbind.STSDF'></span>

<h3>Description</h3>

<p> A class for spatio-temporal data with partial
space-time grids; for n spatial locations and m times, an index
table is kept for which nodes observations are available </p>


<h3>Usage</h3>

<pre><code class='language-R'>  STS(sp, time, index, endTime = delta(time))
  STSDF(sp, time, data, index, endTime = delta(time))
  ## S4 method for signature 'STSDF'
x[i, j, ..., drop = is(x, "STSDF")]
  ## S4 method for signature 'STSDF,STFDF'
coerce(from, to, strict=TRUE)
  ## S4 method for signature 'STSDF,STIDF'
coerce(from, to, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STSDF-class_+3A_sp">sp</code></td>
<td>
<p>object of class <a href="sp.html#topic+Spatial">Spatial</a></p>
</td></tr>
<tr><td><code id="STSDF-class_+3A_time">time</code></td>
<td>
<p>object holding time information; see <a href="#topic+ST-class">ST-class</a></p>
</td></tr>
<tr><td><code id="STSDF-class_+3A_data">data</code></td>
<td>
<p>data frame with rows corresponding to the observations
(spatial index moving faster than temporal)</p>
</td></tr> 
<tr><td><code id="STSDF-class_+3A_index">index</code></td>
<td>
<p>two-column matrix: rows corresponding to the nodes for
which observations are available, first column giving spatial index,
second column giving temporal index</p>
</td></tr> 
<tr><td><code id="STSDF-class_+3A_endtime">endTime</code></td>
<td>
<p> vector of class <code>POSIXct</code> with end points of time
intervals for the observations </p>
</td></tr>
<tr><td><code id="STSDF-class_+3A_x">x</code></td>
<td>
<p>an object of class STFDF</p>
</td></tr>
<tr><td><code id="STSDF-class_+3A_i">i</code></td>
<td>
<p>selection of spatial entities</p>
</td></tr>
<tr><td><code id="STSDF-class_+3A_j">j</code></td>
<td>
<p>selection of temporal entities (see syntax in package xts) </p>
</td></tr>
<tr><td><code id="STSDF-class_+3A_...">...</code></td>
<td>
<p>selection of attribute(s)</p>
</td></tr>
<tr><td><code id="STSDF-class_+3A_drop">drop</code></td>
<td>
<p>if TRUE and a single spatial entity is selected, an object
of class <a href="xts.html#topic+xts">xts</a> is returned; if TRUE and a single temporal entity is
selected, and object of the appropriate <code>Spatial</code> class is returned;
if FALSE, no coercion to reduced classes takes place</p>
</td></tr>
<tr><td><code id="STSDF-class_+3A_from">from</code></td>
<td>
<p>object of class STFDF</p>
</td></tr>
<tr><td><code id="STSDF-class_+3A_to">to</code></td>
<td>
<p>target class</p>
</td></tr>
<tr><td><code id="STSDF-class_+3A_strict">strict</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects of this class carry sparse space/time grid data </p>


<h3>Slots</h3>


<dl>
<dt><code>sp</code>:</dt><dd><p>Object of class <code>"Spatial"</code></p>
</dd>
<dt><code>time</code>:</dt><dd><p>Object holding time information; see <a href="#topic+ST-class">ST-class</a>
for permitted types </p>
</dd>
<dt><code>index</code>:</dt><dd><p>matrix of dimension n x 2, where n matches the number of rows
in slot data </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>data.frame</code>, which holds
the measured values</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "STSDF")</code>: selects spatial entities,        temporal entities, and attributes </p>
</dd> 
<dt>plot</dt><dd><p><code>signature(x = "STS", y = "missing")</code>: plots
space-time layout </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "STSDF", y = "missing")</code>: plots
space-time layout, indicating records partially NA </p>
</dd>



</dl>



<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>References</h3>

<p> https://www.jstatsoft.org/v51/i07/ </p>


<h3>See Also</h3>

 <p><a href="#topic+delta">delta</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>sp = cbind(x = c(0,0,1), y = c(0,1,1))
row.names(sp) = paste("point", 1:nrow(sp), sep="")
library(sp)
sp = SpatialPoints(sp)
library(xts)
time = xts(1:4, as.POSIXct("2010-08-05")+3600*(10:13))
m = c(10,20,30) # means for each of the 3 point locations
mydata = rnorm(length(sp)*length(time),mean=rep(m, 4))
IDs = paste("ID",1:length(mydata))
mydata = data.frame(values = signif(mydata,3), ID=IDs)
stfdf = STFDF(sp, time, mydata)
stfdf
stsdf = as(stfdf, "STSDF")
stsdf[1:2,]
stsdf[,1:2]
stsdf[,,2]
stsdf[,,"values"]
stsdf[1,]
stsdf[,2]
# examples for [[, [[&lt;-, $ and $&lt;- 
stsdf[[1]]
stsdf[["values"]]
stsdf[["newVal"]] &lt;- rnorm(12)
stsdf$ID
stsdf$ID = paste("OldIDs", 1:12, sep="")
stsdf$NewID = paste("NewIDs", 12:1, sep="")
stsdf
x = stsdf[stsdf,]
x = stsdf[stsdf[1:2,],]
all.equal(x, stsdf[1:2,])
</code></pre>

<hr>
<h2 id='STTDF-class'>Class &quot;STTDF&quot;</h2><span id='topic+STT-class'></span><span id='topic+STTDF-class'></span><span id='topic+STT'></span><span id='topic+STTDF'></span><span id='topic+ltraj-class'></span><span id='topic+coerce+2CSTTDF+2Cltraj-method'></span><span id='topic+coerce+2Cltraj+2CSTTDF-method'></span><span id='topic++5B+2CSTT-method'></span><span id='topic++5B+2CSTTDF-method'></span><span id='topic+geometry+2CSTTDF-method'></span><span id='topic+plot+2CSTT+2Cmissing-method'></span>

<h3>Description</h3>

<p> A class for spatio-temporal trajectory data </p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'STTDF,ltraj'
coerce(from, to, strict=TRUE)
  ## S4 method for signature 'ltraj,STTDF'
coerce(from, to, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STTDF-class_+3A_from">from</code></td>
<td>
<p>from object</p>
</td></tr>
<tr><td><code id="STTDF-class_+3A_to">to</code></td>
<td>
<p>target class</p>
</td></tr>
<tr><td><code id="STTDF-class_+3A_strict">strict</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects of this class carry sparse (irregular) space/time data </p>


<h3>Slots</h3>


<dl>
<dt><code>sp</code>:</dt><dd><p>Object of class <code>"Spatial"</code>, containing the bounding
box of all trajectories</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Object of class <code>"xts"</code>, containing the temporal 
bounding box of all trajectories</p>
</dd>
<dt><code>traj</code>:</dt><dd><p>Object of class <code>list</code>, each element holding
an <a href="#topic+STI">STI</a> object reflecting a single trajectory; </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>data.frame</code>, which holds
the data values for each feature in each trajectory </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "STTDF")</code>: select trajectories, based
on index, or spatial and/or temporal predicates </p>
</dd> 




</dl>



<h3>Note</h3>

<p> The <code>data.frame</code> needs to have a column called
<code>burst</code> which is a factor (or character) and contains the
grouping of observations that come from a continuous sequence of
observations. In addition, a column <code>id</code> is used to identify
individual items. </p>


<h3>Author(s)</h3>

<p> Edzer Pebesma, <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> </p>


<h3>References</h3>

<p> https://www.jstatsoft.org/v51/i07/ </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
m = 3# nr of trajectories
n = 100 # length of each
l = vector("list", m)
t0 = as.POSIXct("2013-05-05",tz="GMT")
set.seed(1331) # fix randomness
for (i in 1:m) {
    x = cumsum(rnorm(n))
    y = cumsum(rnorm(n))
    sp = SpatialPoints(cbind(x,y))
    #t = t0 + (0:(n-1) + (i-1)*n) * 60
    t = t0 + (0:(n-1) + (i-1)*n/2) * 60
    l[[i]] = STI(sp, t)
}
stt= STT(l)
sttdf = STTDF(stt, data.frame(attr = rnorm(n*m), id = paste("ID", rep(1:m, each=n))))
x = as(stt, "STI")
stplot(sttdf, col=1:m, scales=list(draw=TRUE))
stplot(sttdf, by = "id")
stplot(sttdf[1])
stplot(sttdf[1])

# select a trajectory that intersect with a polygon
p = Polygon(cbind(x=c(-20,-15,-15,-20,-20),y=c(10,10,15,15,10)))
pol=SpatialPolygons(list(Polygons(list(p), "ID")))
#if (require(rgeos)) {
#  stplot(sttdf[pol])
#  names(sttdf[pol]@traj)
#  stplot(sttdf[1:2],col=1:2)
#  stplot(sttdf[,t0])
#  stplot(sttdf[,"2013"])
#  stplot(sttdf[pol,"2013"])
#  is.null(sttdf[pol,t0])
#}

</code></pre>

<hr>
<h2 id='timeIsInterval'> retrieve, or set, information whether time reflects instance (FALSE) or intervals (TRUE) </h2><span id='topic+timeIsInterval'></span><span id='topic+timeIsInterval+3C-'></span><span id='topic+timeIsInterval+2CANY-method'></span><span id='topic+timeIsInterval+2CST-method'></span><span id='topic+timeIsInterval+3C-+2CANY+2Clogical-method'></span><span id='topic+timeIsInterval+3C-+2CST+2Clogical-method'></span><span id='topic+timeIsInterval+3C-+2CSTT+2Clogical-method'></span>

<h3>Description</h3>

<p> retrieve, or set, information whether time reflects instance (FALSE) or intervals (TRUE) </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
timeIsInterval(x, ...)
timeIsInterval(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeIsInterval_+3A_x">x</code></td>
<td>
<p> object, of any class </p>
</td></tr>
<tr><td><code id="timeIsInterval_+3A_...">...</code></td>
<td>
<p> ignored </p>
</td></tr>
<tr><td><code id="timeIsInterval_+3A_value">value</code></td>
<td>
<p> logical; sets the timeIsInterval value</p>
</td></tr>
</table>


<h3>Value</h3>

<p> logical; this function sets or retrieves the
attribute <code>timeIsInterval</code> of <code>x</code>, UNLESS <code>x</code>
is of class <code>ST</code>, in which case it sets or retrieves
this attribute for the <code>time</code> slot of the object, i.e.
<code>timeIsInterval(x@time) &lt;- value</code>
</p>


<h3>Note</h3>

<p> From spacetime 0.8-0 on, timeIsInterval is dropped in favour of
a more generic time intervals by specifying <code>endTime</code> of each observation</p>


<h3>See Also</h3>

<p><a href="#topic+over">over</a>, <a href="#topic+timeIsInterval">timeIsInterval</a></p>

<hr>
<h2 id='timeMatch'> match two (time) sequences </h2><span id='topic+timeMatch'></span><span id='topic+timeMatch+2CST+2CST-method'></span><span id='topic+timeMatch+2Cxts+2Cxts-method'></span><span id='topic+timeMatch+2CPOSIXct+2CPOSIXct-method'></span><span id='topic+timeMatch+2CDate+2CDate-method'></span><span id='topic+index'></span><span id='topic+MATCH'></span>

<h3>Description</h3>

<p> match two (time) sequences, where each can
be intervals or instances. </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
timeMatch(x, y, returnList = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeMatch_+3A_x">x</code></td>
<td>
<p> ordered sequence, e.g. of time stamps </p>
</td></tr>
<tr><td><code id="timeMatch_+3A_y">y</code></td>
<td>
<p> ordered sequence, e.g. of time stamps </p>
</td></tr>
<tr><td><code id="timeMatch_+3A_returnlist">returnList</code></td>
<td>
<p> boolean; should a list be returned with all matches (TRUE),
or a vector with single matches (FALSE)? </p>
</td></tr>
<tr><td><code id="timeMatch_+3A_...">...</code></td>
<td>
 <p><code>end.x</code> and <code>end.y</code> can be specified for
<code>xts</code> and <code>POSIXct</code> methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> and <code>y</code> are of class <code>xts</code> or <code>POSIXct</code>,
<code>end.x</code> and <code>end.y</code> need to specify endpoint of intervals.
</p>
<p>In case <code>x</code> and <code>y</code> are both not intervals, matching is
done on equality of values, using <a href="base.html#topic+match">match</a>.
</p>
<p>If <code>x</code> represents intervals, then the first interval is from
<code>x[1]</code> to <code>x[2]</code>, with <code>x[1]</code> included but <code>x[2]</code>
not (left-closed, right-open). In case of zero-width intervals
(e.g. <code>x[1]==x[2]</code>), nothing will match and a warning is raised.
Package <code>intervals</code> is used to check overlap of intervals,
using, <a href="intervals.html#topic+interval_overlap">interval_overlap</a>.
</p>


<h3>Value</h3>

<p>if <code>returnList = FALSE</code>: integer vector of length
<code>length(x)</code> with indexes of <code>y</code> matching to each of
the elements of <code>x</code>, or NA if there is no match. See section
details for definition of match.
</p>
<p>if <code>returnList = TRUE</code>: list of length <code>length(x)</code>,
with each list element an integer vector with all the indexes
of <code>y</code> matching to that element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma</p>


<h3>References</h3>

<p> https://www.jstatsoft.org/v51/i07/ </p>


<h3>See Also</h3>

<p><a href="#topic+over">over</a>, <a href="#topic+timeIsInterval">timeIsInterval</a>, <a href="intervals.html#topic+interval_overlap">interval_overlap</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>t0 = as.POSIXct("1999-10-10")
x = t0 +c(0.5+c(2,2.1,4),5)*3600
y = t0 + 1:5 * 3600
x
y
#timeIsInterval(x) = FALSE
#timeIsInterval(y) = FALSE
timeMatch(x,y, returnList = FALSE)
timeMatch(x,y, returnList = TRUE)
#timeIsInterval(y) = TRUE
timeMatch(x,y, returnList = FALSE, end.y = delta(y))
timeMatch(x,y, returnList = TRUE, end.y = delta(y))
#timeIsInterval(x) = TRUE
timeMatch(x,y, returnList = FALSE, end.x = delta(x), end.y = delta(y))
timeMatch(x,y, returnList = TRUE, end.x = delta(x), end.y = delta(y))
#timeIsInterval(y) = FALSE
timeMatch(x,y, returnList = FALSE, end.x = delta(x))
timeMatch(x,y, returnList = TRUE, end.x = delta(x))

x = as.POSIXct("2000-01-01") + (0:9) * 3600
y = x + 1
y[1] = y[2]
x
y
TI = function(x, ti) { 
	timeIsInterval(x) = ti
	x 
}
#timeMatch(TI(y,FALSE),TI(y,FALSE))
#timeMatch(TI(y,TRUE), TI(y,TRUE))
#
#timeMatch(TI(x,FALSE),TI(y,FALSE))
#timeMatch(TI(x,FALSE),TI(y,TRUE))
#timeMatch(TI(x,TRUE), TI(y,FALSE))
#timeMatch(TI(x,TRUE), TI(y,TRUE))
#
#timeMatch(TI(x,FALSE),TI(y,FALSE), returnList = TRUE)
#timeMatch(TI(x,FALSE),TI(y,TRUE), returnList = TRUE)
#timeMatch(TI(x,TRUE), TI(y,FALSE), returnList = TRUE)
#timeMatch(TI(x,TRUE), TI(y,TRUE), returnList = TRUE)

</code></pre>

<hr>
<h2 id='unstack'> write STFDF to table forms </h2><span id='topic+unstack.STFDF'></span><span id='topic+as.data.frame.STFDF'></span>

<h3>Description</h3>

<p> create table forms of STFDF objects </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'STFDF'
unstack(x, form, which = 1, ...)
## S3 method for class 'STFDF'
as.data.frame(x, row.names, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstack_+3A_x">x</code></td>
<td>
<p> object of class <code>STFDF</code></p>
</td></tr>
<tr><td><code id="unstack_+3A_form">form</code></td>
<td>
<p> formula; can be omitted </p>
</td></tr>
<tr><td><code id="unstack_+3A_which">which</code></td>
<td>
<p> column name or number to have unstacked </p>
</td></tr>
<tr><td><code id="unstack_+3A_row.names">row.names</code></td>
<td>
<p> row.names for the data.frame returned </p>
</td></tr>
<tr><td><code id="unstack_+3A_...">...</code></td>
<td>
<p> arguments passed on to the functions <a href="utils.html#topic+unstack">unstack</a> 
or <a href="base.html#topic+as.data.frame">as.data.frame</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>unstack</code> returns the data in wide format, with each
row representing a spatial entity and each column a time; see
<a href="utils.html#topic+unstack">unstack</a> for details and default behaviour.
</p>
<p><code>as.data.frame</code> returns the data.frame in long format,
where the coordinates of the spatial locations (or line starting
coordinates, or polygon center points) and time stamps are recycled
accordingly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp = cbind(x = c(0,0,1), y = c(0,1,1))
row.names(sp) = paste("point", 1:nrow(sp), sep="")
library(sp)
sp = SpatialPoints(sp)
library(xts)
time = xts(1:4, as.POSIXct("2010-08-05")+3600*(10:13))
m = c(10,20,30) # means for each of the 3 point locations
mydata = rnorm(length(sp)*length(time),mean=rep(m, 4))
IDs = paste("ID",1:length(mydata))
mydata = data.frame(values = signif(mydata,3), ID=IDs)
stfdf = STFDF(sp, time, mydata)
as.data.frame(stfdf, row.names = IDs)
unstack(stfdf)
t(unstack(stfdf))
unstack(stfdf, which = 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
