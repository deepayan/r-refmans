<!DOCTYPE html><html lang="en"><head><title>Help for package clifford</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<script type="text/javascript" src="mathjax-config.js"></script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clifford}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clifford-package'>
<p>Arbitrary Dimensional Clifford Algebras</p></a></li>
<li><a href='#allcliff'><p>Clifford object containing all possible terms</p></a></li>
<li><a href='#antivector'><p>Antivectors or pseudovectors</p></a></li>
<li><a href='#as.vector'><p>Coerce a clifford vector to a numeric vector</p></a></li>
<li><a href='#cartan'><p>Cartan map between clifford algebras</p></a></li>
<li><a href='#clifford'><p>Create, coerce, and test for <code>clifford</code> objects</p></a></li>
<li><a href='#const'><p>The constant term of a Clifford object</p></a></li>
<li><a href='#drop'><p>Drop redundant information</p></a></li>
<li><a href='#even'><p>Even and odd clifford objects</p></a></li>
<li><a href='#Extract.clifford'><p>Extract or Replace Parts of a clifford</p></a></li>
<li><a href='#grade'><p>The grade of a clifford object</p></a></li>
<li><a href='#homog'><p>Homogenous Clifford objects</p></a></li>
<li><a href='#horner'><p>Horner's method</p></a></li>
<li><a href='#involution'><p>Clifford involutions</p></a></li>
<li><a href='#lowlevel'><p>Low-level helper functions for <code>clifford</code> objects</p></a></li>
<li><a href='#magnitude'><p>Magnitude of a clifford object</p></a></li>
<li><a href='#minus'><p>Take the negative of a vector</p></a></li>
<li><a href='#numeric_to_clifford'><p>Coercion from numeric to Clifford form</p></a></li>
<li><a href='#Ops.clifford'><p>Arithmetic Ops Group Methods for <code>clifford</code> objects</p></a></li>
<li><a href='#print'><p>Print clifford objects</p></a></li>
<li><a href='#quaternion'><p>Quaternions using Clifford algebras</p></a></li>
<li><a href='#rcliff'><p>Random clifford objects</p></a></li>
<li><a href='#signature'><p>The signature of the Clifford algebra</p></a></li>
<li><a href='#summary.clifford'><p>Summary methods for clifford objects</p></a></li>
<li><a href='#term'><p>Deal with terms</p></a></li>
<li><a href='#zap'><p>Zap small values in a clifford object</p></a></li>
<li><a href='#zero'><p>The zero Clifford object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Arbitrary Dimensional Clifford Algebras</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of routines for Clifford algebras, using the
   'Map' class of the Standard Template Library.  Canonical
   reference: Hestenes (1987, ISBN 90-277-1673-0, "Clifford algebra
   to geometric calculus").  Special cases including Lorentz transforms,
   quaternion multiplication, and Grassman algebra, are discussed.
   Conformal geometric algebra theory is implemented.  Uses 'disordR'
   discipline.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,rmarkdown,testthat,onion,lorentz</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.5),mathjaxr,disordR (&ge; 0.0-8), magrittr,
methods, partitions (&ge; 1.10-4)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp,BH</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/clifford">https://github.com/RobinHankin/clifford</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/clifford/issues">https://github.com/RobinHankin/clifford/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-13 20:41:19 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-13 22:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='clifford-package'>
Arbitrary Dimensional Clifford Algebras
</h2><span id='topic+clifford-package'></span>

<h3>Description</h3>

<p>A suite of routines for Clifford algebras, using the
   'Map' class of the Standard Template Library.  Canonical
   reference: Hestenes (1987, ISBN 90-277-1673-0, &quot;Clifford algebra
   to geometric calculus&quot;).  Special cases including Lorentz transforms,
   quaternion multiplication, and Grassman algebra, are discussed.
   Conformal geometric algebra theory is implemented.  Uses 'disordR'
   discipline.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> clifford</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Arbitrary Dimensional Clifford Algebras</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> A suite of routines for Clifford algebras, using the
   'Map' class of the Standard Template Library.  Canonical
   reference: Hestenes (1987, ISBN 90-277-1673-0, "Clifford algebra
   to geometric calculus").  Special cases including Lorentz transforms,
   quaternion multiplication, and Grassman algebra, are discussed.
   Conformal geometric algebra theory is implemented.  Uses 'disordR'
   discipline.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr,rmarkdown,testthat,onion,lorentz</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 0.12.5),mathjaxr,disordR (&gt;= 0.0-8), magrittr, methods, partitions (&gt;= 1.10-4)</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp,BH</td>
</tr>
<tr>
 <td style="text-align: left;">
SystemRequirements: </td><td style="text-align: left;"> C++11</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/clifford</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/clifford/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Ops.clifford            Arithmetic Ops Group Methods for 'clifford'
                        objects
[.clifford              Extract or Replace Parts of a clifford
allcliff                Clifford object containing all possible terms
antivector              Antivectors or pseudovectors
as.vector               Coerce a clifford vector to a numeric vector
cartan                  Cartan map between clifford algebras
clifford                Create, coerce, and test for 'clifford' objects
clifford-package        Arbitrary Dimensional Clifford Algebras
const                   The constant term of a Clifford object
drop                    Drop redundant information
even                    Even and odd clifford objects
grade                   The grade of a clifford object
homog                   Homogenous Clifford objects
horner                  Horner's method
involution              Clifford involutions
lowlevel                Low-level helper functions for 'clifford'
                        objects
magnitude               Magnitude of a clifford object
minus                   Take the negative of a vector
numeric_to_clifford     Coercion from numeric to Clifford form
print.clifford          Print clifford objects
quaternion              Quaternions using Clifford algebras
rcliff                  Random clifford objects
signature               The signature of the Clifford algebra
summary.clifford        Summary methods for clifford objects
term                    Deal with terms
zap                     Zap small values in a clifford object
zero                    The zero Clifford object
</pre>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> J. Snygg (2012).  <em>A new approach to differential
geometry using Clifford's geometric Algebra</em>, Birkhauser.  ISBN
978-0-8176-8282-8
</p>
</li>
<li><p> D. Hestenes (1987). <em>Clifford algebra to geometric
calculus</em>,  Kluwer. ISBN 90-277-1673-0
</p>
</li>
<li><p> C. Perwass (2009). <em>Geometric algebra with applications
in engineering</em>, Springer.  ISBN 978-3-540-89068-3
</p>
</li>
<li><p> D. Hildenbrand (2013). <em>Foundations of geometric
algebra computing</em>.  Springer, ISBN 978-3-642-31794-1
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+clifford">clifford</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.1vector(1:4)

as.1vector(1:4) * rcliff()

# Following from Ablamowicz and Fauser (see vignette):
x &lt;- clifford(list(1:3,c(1,5,7,8,10)),c(4,-10)) + 2
y &lt;- clifford(list(c(1,2,3,7),c(1,5,6,8),c(1,4,6,7)),c(4,1,-3)) - 1
x*y # signature irrelevant



</code></pre>

<hr>
<h2 id='allcliff'>Clifford object containing all possible terms</h2><span id='topic+allcliff'></span>

<h3>Description</h3>

<p>The Clifford algebra on basis vectors <code class="reqn">e_1,e_2,\ldots,
  e_n</code> has <code class="reqn">2^n</code> independent multivectors.  Function
<code>allcliff()</code> generates a clifford object with a nonzero
coefficient for each multivector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allcliff(n,grade)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allcliff_+3A_n">n</code></td>
<td>
<p>Integer specifying dimension of underlying vector space</p>
</td></tr>
<tr><td><code id="allcliff_+3A_grade">grade</code></td>
<td>
<p>Grade of multivector to be returned.  If missing,
multivector contains every term of every grade <code class="reqn">\leq n</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>allcliff(6)

a &lt;- allcliff(5)
a[] &lt;- rcliff()*100

</code></pre>

<hr>
<h2 id='antivector'>Antivectors or pseudovectors</h2><span id='topic+antivector'></span><span id='topic+as.antivector'></span><span id='topic+is.antivector'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Antivectors or pseudovectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antivector(v, n = length(v))
as.antivector(v)
is.antivector(C, include.pseudoscalar=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="antivector_+3A_v">v</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="antivector_+3A_n">n</code></td>
<td>
<p>Integer specifying dimensionality of underlying vector space</p>
</td></tr>
<tr><td><code id="antivector_+3A_c">C</code></td>
<td>
<p>Clifford object</p>
</td></tr>
<tr><td><code id="antivector_+3A_include.pseudoscalar">include.pseudoscalar</code></td>
<td>
<p>Boolean: should the pseudoscalar be
considered an antivector?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <dfn>antivector</dfn> is an \(n\)-dimensional Clifford object, all of
whose terms are of grade \(n-1\).  An antivector has \(n\)
degrees of freedom.  Function <code>antivector(v,n)</code> interprets
<code>v[i]</code> as the coefficient of \(e_1e_2\ldots
e_{i-1}e_{i+1}\ldots e_n\).
</p>
<p>Function <code>as.antivector()</code> is a convenience wrapper, coercing its
argument to an antivector of minimal dimension (zero entries are
interpreted consistently).
</p>
<p>The pseudoscalar is a peculiar edge case.  Consider:
</p>
<pre>
  A &lt;- clifford(list(c(1,2,3)))
  B &lt;- A + clifford(list(c(1,2,4)))

&gt; is.antivector(A)
[1] FALSE
&gt; is.antivector(B)
[1] TRUE
&gt; is.antivector(A,include.pseudoscalar=TRUE)
[1] TRUE
&gt; is.antivector(B,include.pseudoscalar=TRUE)
[1] TRUE
</pre>
<p>One could argue that <code>A</code> should be an antivector as it is a term in
<code>B</code>, which is definitely an antivector.  Use
<code>include.pseudoscalar=TRUE</code> to ensure consistency in this case.
</p>
<p>Compare <code>as.1vector()</code>, which returns a clifford object of grade 1.
</p>


<h3>Note</h3>

<p>An antivector is always a blade.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Wikipedia contributors. (2018, July 20). &ldquo;Antivector&rdquo;.  In
<em>Wikipedia, The Free Encyclopedia</em>. Retrieved 19:06, January 27,
2020, from
<a href="https://en.wikipedia.org/w/index.php?title=Antivector&amp;oldid=851094060">https://en.wikipedia.org/w/index.php?title=Antivector&amp;oldid=851094060</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.1vector">as.1vector</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>antivector(1:5)

as.1vector(c(1,1,2)) %X% as.1vector(c(3,2,2))
c(1*2-2*2, 2*3-1*2, 1*2-1*3)  # note sign of e_13

</code></pre>

<hr>
<h2 id='as.vector'>Coerce a clifford vector to a numeric vector</h2><span id='topic+as.vector.clifford'></span><span id='topic+as.vector'></span>

<h3>Description</h3>

<p>Given a clifford object with all terms of grade 1, return the
corresponding numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clifford'
as.vector(x,mode = "any")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.vector_+3A_x">x</code></td>
<td>
<p>Object of class clifford</p>
</td></tr>
<tr><td><code id="as.vector_+3A_mode">mode</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The awkward R idiom of this function is because the terms may be stored
in any order; see the examples
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+numeric_to_clifford">numeric_to_clifford</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- clifford(list(6,2,9),1:3)
as.vector(x)

as.1vector(as.vector(x)) == x  # should be TRUE

</code></pre>

<hr>
<h2 id='cartan'>Cartan map between clifford algebras</h2><span id='topic+cartan'></span><span id='topic+cartan_inverse'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Cartan's map isomorphisms from \(Cl(p,q)\) to
\(Cl(p-4,q+4)\) and \(Cl(p+4,q-4)\)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cartan(C, n = 1)
cartan_inverse(C, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cartan_+3A_c">C</code></td>
<td>
<p>Object of class <code>clifford</code></p>
</td></tr>
<tr><td><code id="cartan_+3A_n">n</code></td>
<td>
<p>Strictly positive integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>clifford</code>.  The default value
<code>n=1</code> maps \(Cl(4,q)\) to \(Cl(0,q+4)\)
(<code>cartan()</code>) and \(Cl(0,q)\) to \(Cl(4,q-4)\).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>E. Hitzer and S. Sangwine 2017.  &ldquo;Multivector and
multivector matrix inverses in real Clifford algebras&rdquo;, <em>Applied
Mathematics and Computation</em>. 311:3755-89
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clifford">clifford</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- rcliff(d=7)   # Cl(4,3)
b &lt;- rcliff(d=7)   # Cl(4,3)
signature(4,3)     # e1^2 = e2^2 = e3^2 = e4^2 = +1; e5^2 = e6^2=e7^2 = -1
ab &lt;- a*b          # multiplication in Cl(4,3)

signature(0,7)   # e1^2 = ... = e7^2 = -1
cartan(a)*cartan(b) == cartan(ab) # multiplication in Cl(0,7); should be TRUE

signature(Inf)  # restore default
</code></pre>

<hr>
<h2 id='clifford'>Create, coerce, and test for <code>clifford</code> objects</h2><span id='topic+clifford'></span><span id='topic+clifford-class'></span><span id='topic+as.clifford'></span><span id='topic+is.clifford'></span><span id='topic+nbits'></span><span id='topic+nterms'></span><span id='topic+dim'></span><span id='topic+dim.clifford'></span><span id='topic+dimension'></span><span id='topic+is_ok_clifford'></span>

<h3>Description</h3>

<p>An object of class <code>clifford</code> is a member of a Clifford algebra.
These objects may be added and multiplied, and have various applications
in physics and mathematics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>clifford(terms, coeffs=1)
is_ok_clifford(terms, coeffs)
as.clifford(x)
is.clifford(x)
nbits(x)
nterms(x)
## S3 method for class 'clifford'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clifford_+3A_terms">terms</code></td>
<td>
<p>A list of integer vectors with strictly increasing
entries corresponding to the basis vectors of the underlying vector
space</p>
</td></tr>
<tr><td><code id="clifford_+3A_coeffs">coeffs</code></td>
<td>
<p>Numeric vector of coefficients</p>
</td></tr>
<tr><td><code id="clifford_+3A_x">x</code></td>
<td>
<p>Object of class <code>clifford</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Function <code>clifford()</code> is the formal creation mechanism
for <code>clifford</code> objects
</p>
</li>
<li><p> Function <code>as.clifford()</code> is much more user-friendly and
attempts to coerce a range of input arguments to clifford form
</p>
</li>
<li><p> Function <code>nbits()</code> returns the number of bits required in
the low-level C routines to store the terms (this is the largest
entry in the list of terms).  For a scalar, this is zero and for the
zero clifford object it (currently) returns zero as well although
a case could be made for <code>NULL</code>
</p>
</li>
<li><p> Function <code>nterms()</code> returns the number of terms in the
expression
</p>
</li>
<li><p> Function <code>is_ok_clifford()</code> is a helper function that checks
for consistency of its arguments
</p>
</li>
<li><p> Function <code>is.term()</code> returns <code>TRUE</code> if all terms of
its argument have the same grade
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Snygg 2012.  &ldquo;A new approach to differential geometry using
Clifford's geometric algebra&rdquo;.  Birkhauser; Springer
Science+Business.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ops.clifford">Ops.clifford</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- clifford(list(1,2,1:4),1:3))   # Formal creation method
(y &lt;- as.1vector(4:2))
(z &lt;- rcliff(include.fewer=TRUE))

terms(x+100)
coeffs(z)

## Clifford objects may be added and multiplied:

x + y
x*y

</code></pre>

<hr>
<h2 id='const'>The constant term of a Clifford object</h2><span id='topic+const'></span><span id='topic+constant'></span><span id='topic+const+3C-'></span><span id='topic+const+3C-.clifford'></span><span id='topic+constant+3C-'></span><span id='topic+constant+3C-.clifford'></span><span id='topic+is.real'></span>

<h3>Description</h3>

<p>Get and set the constant term of a clifford object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>const(C,drop=TRUE)
is.real(C)
## S3 replacement method for class 'clifford'
const(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="const_+3A_c">C</code>, <code id="const_+3A_x">x</code></td>
<td>
<p>Clifford object</p>
</td></tr>
<tr><td><code id="const_+3A_value">value</code></td>
<td>
<p>Replacement value</p>
</td></tr>
<tr><td><code id="const_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return the
constant coerced to numeric, and <code>FALSE</code> meaning to return a
(constant) Clifford object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extractor method for specific terms.  Function <code>const()</code> returns
the constant element of a Clifford object.  Note that <code>const(C)</code>
returns the same as <code>grade(C,0)</code>, but is faster.
</p>
<p>The R idiom in <code>const&lt;-()</code> is slightly awkward:
</p>
<pre>
&gt; body(`const&lt;-.clifford`)
{
  stopifnot(length(value) == 1)
  x &lt;- x - const(x)
  return(x + value)
}
</pre>
<p>The reason that it is not simply <code>return(x-const(x)+value)</code> or
<code>return(x+value-const(x))</code> is to ensure numerical accuracy; see
examples.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+grade">grade</a></code>,
<code><a href="#topic+clifford">clifford</a></code>,
<code><a href="#topic+getcoeffs">getcoeffs</a></code>,
<code><a href="#topic+is.zero">is.zero</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- clifford(list(1,1:2,1:3,3:5),6:9)
X
X &lt;- X + 1e300
X

const(X) # should be 1e300

const(X) &lt;- 0.6
const(X) # should be 0.6, no numerical error

# compare naive approach:

X &lt;- clifford(list(1,1:2,1:3,3:5),6:9)+1e300
X+0.6-const(X)  # constant gets lost in the numerics

X &lt;- clifford(list(1,1:2,1:3,3:5),6:9)+1e-300
X-const(X)+0.6  # answer correct by virtue of left-associativity


x &lt;- 2+rcliff(d=3,g=3)
jj &lt;- x*cliffconj(x)
is.real(jj*rev(jj))   # should be TRUE
</code></pre>

<hr>
<h2 id='drop'>Drop redundant information</h2><span id='topic+drop'></span><span id='topic+drop+2Cclifford-method'></span>

<h3>Description</h3>

<p>Coerce constant Clifford objects to numeric</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_+3A_x">x</code></td>
<td>
<p>Clifford object</p>
</td></tr></table>


<h3>Details</h3>

<p>If its argument is a constant clifford object, coerce to numeric.</p>


<h3>Note</h3>

<p>Many functions in the package take <code>drop</code> as an argument
which, if <code>TRUE</code>, means that the function returns a
<code>drop</code>ped value.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+grade">grade</a></code>,<code><a href="#topic+getcoeffs">getcoeffs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>drop(as.clifford(5))

const(rcliff())
const(rcliff(),drop=FALSE)

</code></pre>

<hr>
<h2 id='even'>Even and odd clifford objects</h2><span id='topic+even'></span><span id='topic+is.even'></span><span id='topic+is.odd'></span><span id='topic+evenpart'></span><span id='topic+oddpart'></span>

<h3>Description</h3>

<p>A clifford object is <em>even</em> if every term has even grade, and
<em>odd</em> if every term has odd grade.
</p>
<p>Functions <code>is.even()</code> and <code>is.odd()</code> test a clifford object
for evenness or oddness.
</p>
<p>Functions <code>evenpart()</code> and <code>oddpart()</code> extract the even 
or odd terms from a clifford object, and we write <code class="reqn">A_+</code> and
<code class="reqn">A_-</code> respectively; we have <code class="reqn">A=A_+ + A_-</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.even(C)
is.odd(C)
evenpart(C)
oddpart(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="even_+3A_c">C</code></td>
<td>
<p>Clifford object</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+grade">grade</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- rcliff()
A == evenpart(A) + oddpart(A) # should be true

</code></pre>

<hr>
<h2 id='Extract.clifford'>Extract or Replace Parts of a clifford</h2><span id='topic++5B.clifford'></span><span id='topic+extract.clifford'></span><span id='topic+warn_on_repeats'></span><span id='topic+extract'></span><span id='topic+replace.clifford'></span><span id='topic+replace'></span><span id='topic++5B+3C-.clifford'></span><span id='topic+coeffs'></span><span id='topic+list_modifier'></span><span id='topic+coeffs+3C-'></span><span id='topic+coeffs+3C-.clifford'></span><span id='topic+getcoeffs'></span>

<h3>Description</h3>

<p>Extract or replace subsets of cliffords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clifford'
C[index, ...]
## S3 replacement method for class 'clifford'
C[index, ...] &lt;- value
coeffs(x)
coeffs(x) &lt;- value
list_modifier(B)
getcoeffs(C, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extract.clifford_+3A_c">C</code>, <code id="Extract.clifford_+3A_x">x</code></td>
<td>
<p>A clifford object</p>
</td></tr>
<tr><td><code id="Extract.clifford_+3A_index">index</code></td>
<td>
<p>elements to extract or replace</p>
</td></tr>
<tr><td><code id="Extract.clifford_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
<tr><td><code id="Extract.clifford_+3A_b">B</code></td>
<td>
<p>A list of integer vectors, terms</p>
</td></tr>
<tr><td><code id="Extract.clifford_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extraction and replacement methods.  The extraction method uses
<code>getcoeffs()</code> and the replacement method uses low-level helper
function <code>c_overwrite()</code>.
</p>
<p>In the extraction function <code>a[index]</code>, if <code>index</code> is a list,
further arguments are ignored; if not, the dots are used.  If
<code>index</code> is a list, its elements are interpreted as integer vectors
indicating which terms to be extracted (even if it is a <code>disord</code>
object).  If <code>index</code> is a <code>disord</code> object, standard
consistency rules are applied.  The extraction methods are designed so
that idiom such as <code>a[coeffs(a)&gt;3]</code> works.
</p>
<p>For replacement methods, the standard use-case is <code>a[i] &lt;- b</code> in
which argument <code>i</code> is a list of integer vectors and <code>b</code> a
length-one numeric vector.  Otherwise, to manipulate parts of a clifford
object, use <code>coeffs(a) &lt;- value</code>; this effectively leverages
<code>disord</code> formalism.  Idiom such as <code>a[coeffs(a)&lt;2] &lt;- 0</code> is
not currently implemented (to do this, use <code>coeffs(a)[coeffs(a)&lt;2]
&lt;- 0</code>).  Replacement using a list-valued index, as in <code>A[i] &lt;-
value</code> uses an ugly hack if <code>value</code> is zero.  Replacement methods
are not yet finalised and not yet fully integrated with the
<code>disordR</code> package.
</p>
<p>Idiom such as <code>a[] &lt;- b</code> follows the <code>spray</code> package.  If
<code>b</code> is a length-one scalar, then <code>coeffs(a) &lt;- b</code> has the same
effect as <code>a[] &lt;- b</code>.
</p>
<p>Functions <code>terms()</code> [see <code>term.Rd</code>] and <code>coeffs()</code>
extract the terms and coefficients from a clifford object.  These
functions return <code>disord</code> objects but the ordering is consistent
between them (an extended discussion of this phenomenon is presented in
the <code>mvp</code> package).
</p>
<p>Function <code>coeffs&lt;-()</code> (idiom <code>coeffs(a) &lt;- b</code>) sets all
coefficients of <code>a</code> to <code>b</code>.  This has the same effect as
<code>a[] &lt;- b</code>.
</p>
<p>Extraction and replacement methods treat <code>0</code> specially, translating
it (via <code>list_modifier()</code>) to <code>numeric(0)</code>.
</p>
<p>Extracting or replacing a list with a repeated elements is usually a Bad
Idea (tm).  However, if option <code>warn_on_repeats</code> is set to
<code>FALSE</code>, no warning will be given (and the coefficient will be the
sum of the coefficients of the term; see the examples).
</p>
<p>Function <code>getcoeffs()</code> is a lower-level helper function that lacks
the succour offered by <code>[.clifford()</code>.  It returns a numeric vector
[not a <code>disord</code> object: the order of the elements is determined by
the order of argument <code>B</code>].  Compare standard extraction, eg
<code>a[index]</code>, which returns a clifford object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ops.clifford">Ops.clifford</a></code>,<code><a href="#topic+clifford">clifford</a></code>,<code><a href="#topic+term">term</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- clifford(list(1,1:2,1:3),1:3)
B &lt;- clifford(list(1:2,1:6),c(44,45))

A[1,c(1,3,4)]

A[2:3, 4] &lt;- 99
A[] &lt;- B

# clifford(list(1,1:2,1:2),1:3)  # would give a warning

options("warn_on_repeats" = FALSE)
clifford(list(1,1:2,1:2),1:3)  # works; 1e1 + 5e_12

options("warn_on_repeats" = TRUE) # return to default behaviour.


</code></pre>

<hr>
<h2 id='grade'>The grade of a clifford object</h2><span id='topic+grade'></span><span id='topic+grade+3C-'></span><span id='topic+grades'></span><span id='topic+gradesplus'></span><span id='topic+gradesminus'></span><span id='topic+gradeszero'></span><span id='topic+gradeplus'></span><span id='topic+grademinus'></span><span id='topic+gradezero'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The <dfn>grade</dfn> of a term is the number of basis vectors in it.</p>


<h3>Usage</h3>

<pre><code class='language-R'>grade(C, n, drop=TRUE)
grade(C,n) &lt;- value
grades(x)
gradesplus(x)
gradesminus(x)
gradeszero(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grade_+3A_c">C</code>, <code id="grade_+3A_x">x</code></td>
<td>
<p>Clifford object</p>
</td></tr>
<tr><td><code id="grade_+3A_n">n</code></td>
<td>
<p>Integer vector specifying grades to extract</p>
</td></tr>
<tr><td><code id="grade_+3A_value">value</code></td>
<td>
<p>Replacement value, a numeric vector</p>
</td></tr>
<tr><td><code id="grade_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to coerce a
constant Clifford object to numeric, and <code>FALSE</code> meaning not
to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <dfn>term</dfn> is a single expression in a Clifford object.  It has a
coefficient and is described by the basis vectors it comprises.  Thus
\(4e_{234}\) is a term but \(e_3 + e_5\) is not.
</p>
<p>The <dfn>grade</dfn> of a term is the number of basis vectors in it.  Thus
the grade of \(e_1\) is 1, and the grade of
\(e_{125}=e_1e_2e_5\) is 3.  The grade operator
\(\left\langle\cdot\right\rangle_r\) is used to extract terms
of a particular grade, with
</p>
\[
  A=\left\langle A\right\rangle_0 + 
    \left\langle A\right\rangle_1 + 
    \left\langle A\right\rangle_2 + \cdots = \sum_r\left\langle A\right\rangle_r
\]
<p>for any Clifford object <i>A</i>.  Thus \(\left\langle
A\right\rangle_r\) is said to be homogenous of grade <i>r</i>.
Hestenes sometimes writes subscripts that specify grades using an
overbar as in \(\left\langle
A\right\rangle_{\overline{r}}\).  It is conventional to denote
the zero-grade object \(\left\langle A\right\rangle_0\) as
simply \(\left\langle A\right\rangle\).
</p>
<p>We have
</p>
\[
\left\langle A+B\right\rangle_r=\left\langle A\right\rangle_r + \left\langle B\right\rangle_r\qquad
\left\langle\lambda A\right\rangle_r=\lambda\left\langle A\right\rangle_r\qquad
\left\langle\left\langle A\right\rangle_r\right\rangle_s=\left\langle A\right\rangle_r\delta_{rs}.
\]
<p>Function <code>grades()</code> returns an (unordered) vector specifying the
grades of the constituent terms.  Function <code>grades&lt;-()</code> allows
idiom such as <code>grade(x,1:2) &lt;- 7</code> to operate as expected [here to
set all coefficients of terms with grades 1 or 2 to value 7].
</p>
<p>Function <code>gradesplus()</code> returns the same but counting only basis
vectors that square to <i>+1</i>, and <code>gradesminus()</code> counts only
basis vectors that square to <i>-1</i>.  Function <code>signature()</code>
controls which basis vectors square to <i>+1</i> and which to <i>-1</i>.
</p>
<p>From Perwass, page 57, given a bilinear form
</p>
\[\left\langle{\mathbf x},{\mathbf x}\right\rangle=x_1^2+x_2^2+\cdots
  +x_p^2-x_{p+1}^2-\cdots -x_{p+q}^2
\]
<p>and a basis blade \(e_\mathbb{A}\) with
\(\mathbb{A}\subseteq\left\lbrace
1,\ldots,p+q\right\rbrace\), then
</p>
\[
  \mathrm{gr}(e_\mathbb{A}) = \left|\left\lbrace a\in\mathbb{A}\colon
  1\leq a\leq p+q\right\rbrace\right|
\]
\[
  \mathrm{gr}_{+}(e_\mathbb{A}) = \left|\left\lbrace a\in\mathbb{A}\colon
  1\leq a\leq p\right\rbrace\right|
\]
\[
  \mathrm{gr}_{-}(e_\mathbb{A}) = \left|\left\lbrace a\in\mathbb{A}\colon
  p < a\leq p+q\right\rbrace\right|
\]
<p>Function <code>gradeszero()</code> counts only the basis vectors squaring to
zero (I have not seen this anywhere else, but it is a logical
suggestion).
</p>
<p>If the signature is zero, then the Clifford algebra reduces to a
Grassman algebra and products match the wedge product of exterior
calculus.  In this case, functions <code>gradesplus()</code> and
<code>gradesminus()</code> return <code>NA</code>.
</p>
<p>Function <code>grade(C,n)</code> returns a clifford object with just the
elements of grade <code>g</code>, where <code>g %in% n</code>.
</p>
<p>The zero grade term, <code>grade(C,0)</code>, is given more naturally by
<code>const(C)</code>.
</p>
<p>Function <code>c_grade()</code> is a helper function that is documented at
<code>Ops.clifford.Rd</code>.
</p>


<h3>Note</h3>

<p>In the C code, &ldquo;term&rdquo; has a slightly different meaning,
referring to the vectors without the associated coefficient.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>C. Perwass 2009. &ldquo;Geometric algebra with applications
in engineering&rdquo;.  Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signature">signature</a></code>, <code><a href="#topic+const">const</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- clifford(sapply(seq_len(7),seq_len),seq_len(7))
a
grades(a)
grade(a,5)


signature(2,2)
x &lt;- rcliff()
drop(gradesplus(x) + gradesminus(x) + gradeszero(x) - grades(x))

a &lt;- rcliff()
a == Reduce(`+`,sapply(unique(grades(a)),function(g){grade(a,g)}))

</code></pre>

<hr>
<h2 id='homog'>Homogenous Clifford objects</h2><span id='topic+homog'></span><span id='topic+is.homog'></span><span id='topic+is.homogenous'></span><span id='topic+homogenous'></span>

<h3>Description</h3>

<p>A clifford object is homogenous if all its terms are the same grade.  A
scalar (including the zero clifford object) is considered to be
homogenous.  This ensures that <code>is.homog(grade(C,n))</code> always
returns <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.homog(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="homog_+3A_c">C</code></td>
<td>
<p>Object of class clifford</p>
</td></tr></table>


<h3>Note</h3>

<p>Nonzero homogenous clifford objects have a multiplicative inverse.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.homog(rcliff())
is.homog(rcliff(include.fewer=FALSE))
</code></pre>

<hr>
<h2 id='horner'>Horner's method</h2><span id='topic+horner'></span>

<h3>Description</h3>

<p>Horner's method for Clifford objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>horner(P,v)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="horner_+3A_p">P</code></td>
<td>
<p>Multivariate polynomial</p>
</td></tr>
<tr><td><code id="horner_+3A_v">v</code></td>
<td>
<p>Numeric vector of coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a polynomial
</p>
<p style="text-align: center;"><code class="reqn">p(x) = a_0 +a_1+a_2x^2+\cdots + a_nx^n</code>
</p>

<p>it is possible to express <code class="reqn">p(x)</code> in the algebraically equivalent
form
</p>
<p style="text-align: center;"><code class="reqn">p(x) = a_0 + x\left(a_1+x\left(a_2+\cdots + x\left(a_{n-1} +xa_n
\right)\cdots\right)\right)</code>
</p>

<p>which is much more efficient for evaluation, as it requires only <code class="reqn">n</code>
multiplications and <code class="reqn">n</code> additions, and this is optimal.  The output
of <code>horner()</code> depends on the <code>signature()</code>.
</p>


<h3>Note</h3>

<p>Horner's method is not as cool for Clifford objects as it is for
(e.g.) multivariate polynomials or <code>freealg</code> objects.  This is
because powers of Clifford objects don't get more complicated as the
power increases.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
horner(1+e(1:3)+e(2:3) , 1:6)

rcliff() |&gt; horner(1:4)

</code></pre>

<hr>
<h2 id='involution'>Clifford involutions</h2><span id='topic+involution'></span><span id='topic+involutions'></span><span id='topic+Conj'></span><span id='topic+Conj.clifford'></span><span id='topic+conjugate'></span><span id='topic+conj'></span><span id='topic+cliffconj'></span><span id='topic+dual'></span><span id='topic+rev'></span><span id='topic+rev.clifford'></span><span id='topic+reverse'></span><span id='topic+gradeinv'></span><span id='topic+neg'></span><span id='topic+tilde'></span><span id='topic+dagger'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>An <dfn>involution</dfn> is a function that is its own inverse, or
equivalently \(f(f(x))=x\).  There are several important
involutions on Clifford objects; these commute past the grade operator
with \(f(\left\langle A\right\rangle_r)=\left\langle
  f(A)\right\rangle_r\) and are linear: \(f(\alpha A+\beta
  B)=\alpha f(A)+\beta f(B)\).
</p>
<p>The <dfn>dual</dfn> is documented here for convenience, even though it is
not an involution (applying the dual <em>four</em> times is the
identity).
</p>

<ul>
<li><p> The <dfn>reverse</dfn> \(A^\sim\) is given by
<code>rev()</code> (both Perwass and Dorst use a tilde, as in
\(\tilde{A}\) or \(A^\sim\).  However, both
Hestenes and Chisholm use a dagger, as in
\(A^\dagger\).  This page uses Perwass's notation).
The <dfn>reverse</dfn> of a term written as a product of basis vectors is
simply the product of the same basis vectors but written in reverse
order.  This changes the sign of the term if the number of basis
vectors is 2 or 3 (modulo 4).  Thus, for example,
\(\left(e_1e_2e_3\right)^\sim=e_3e_2e_1=-e_1e_2e_3\)
and
\(\left(e_1e_2e_3e_4\right)^\sim=e_4e_3e_2e_1=+e_1e_2e_3e_4\).
Formally, if \(X=e_{i_1}\ldots e_{i_k}\), then
\(\tilde{X}=e_{i_k}\ldots e_{i_1}\).
</p>
\[\left\langle
      A^\sim\right\rangle_r=\widetilde{\left\langle
	A\right\rangle_r}=(-1)^{r(r-1)/2}\left\langle A\right\rangle_r
    \]
<p>Perwass shows that \(\left\langle
      AB\right\rangle_r=(-1)^{r(r-1)/2}\left\langle\tilde{B}\tilde{A}\right\rangle_r
      \).
</p>
</li>
<li><p> The <dfn>Conjugate</dfn> \(A^\dagger\) is given by
<code>Conj()</code> (we use Perwass's notation, def 2.9 p59).  This
depends on the signature of the Clifford algebra; see
<code>grade.Rd</code> for notation.  Given a basis blade
\(e_\mathbb{A}\) with \(\mathbb{A}\subseteq\left\lbrace
    1,\ldots,p+q\right\rbrace\), then we have \(e_\mathbb{A}^\dagger = (-1)^m
    {e_\mathbb{A}}^\sim\), where \(m=\mathrm{gr}_{-}(\mathbb{A})\).  Alternatively, we
might say \[\left(\left\langle
    A\right\rangle_r\right)^\dagger=(-1)^m(-1)^{r(r-1)/2}\left\langle
    A\right\rangle_r \] where
\(m=\mathrm{gr}_{-}(\left\langle A\right\rangle_r)\)
[NB I have changed Perwass's notation].
</p>
</li>
<li><p> The <dfn>main (grade) involution</dfn> or <dfn>grade involution</dfn>
\(\widehat{A}\) is given by <code>gradeinv()</code>.  This
changes the sign of any term with odd grade: \[
    \widehat{\left\langle A\right\rangle_r} =(-1)^r\left\langle
    A\right\rangle_r\] (I don't see this in Perwass or Hestenes;
notation follows Hitzer and Sangwine).  It is a special case of
grade negation.
</p>
</li>
<li><p> The <dfn>grade <i>r</i>-negation</dfn>
\(A_{\overline{r}}\) is given by <code>neg()</code>.  This
changes the sign of the grade <i>r</i> component of <i>A</i>.  It is
formally defined as \(A-2\left\langle
    A\right\rangle_r\) but function <code>neg()</code> uses a more
efficient method.  It is possible to negate all terms with specified
grades, so for example we might have \(\left\langle
    A\right\rangle_{\overline{\left\lbrace 1,2,5\right\rbrace}} =
    A-2\left( \left\langle A\right\rangle_1 +\left\langle
    A\right\rangle_2+\left\langle A\right\rangle_5\right)\) and
the R idiom would be <code>neg(A,c(1,2,5))</code>.  Note that Hestenes
uses &ldquo;\(A_{\overline{r}}\)&rdquo; to mean the same as
\(\left\langle A\right\rangle_r\).
</p>
</li>
<li><p> The <dfn>Clifford conjugate</dfn> \(\overline{A}\) is
given by <code>cliffconj()</code>.  It is distinct from conjugation
\(A^\dagger\), and is defined in Hitzer and Sangwine as
</p>
\[\overline{\left\langle A\right\rangle_r} =
      (-1)^{r(r+1)/2}\left\langle A\right\rangle_r.\]
</li>
<li><p> The <dfn>dual</dfn> \(C^*\) of a clifford object \(C\) is
given by <code>dual(C,n)</code>; argument <code>n</code> is the dimension of the
underlying vector space.  Perwass gives
\[C^*=CI^{-1}\]
</p>
<p>where \(I=e_1e_2\ldots e_n\) is the unit pseudoscalar
[note that Hestenes uses \(I\) to mean something different].
The dual is sensitive to the signature of the Clifford algebra
<em>and</em> the dimension of the underlying vector space.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clifford'
rev(x)
## S3 method for class 'clifford'
Conj(z)
cliffconj(z)
neg(C,n)
gradeinv(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="involution_+3A_c">C</code>, <code id="involution_+3A_x">x</code>, <code id="involution_+3A_z">z</code></td>
<td>
<p>Clifford object</p>
</td></tr>
<tr><td><code id="involution_+3A_n">n</code></td>
<td>
<p>Integer vector specifying grades to be negated in <code>neg()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+grade">grade</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rcliff()
x
rev(x)


A &lt;- rblade(g=3)
B &lt;- rblade(g=4)
rev(A %^% B) == rev(B) %^% rev(A)  # should be TRUE
rev(A * B) == rev(B) * rev(A)          # should be TRUE

a &lt;- rcliff()
dual(dual(dual(dual(a,8),8),8),8) == a # should be TRUE

</code></pre>

<hr>
<h2 id='lowlevel'>Low-level helper functions for <code>clifford</code> objects</h2><span id='topic+lowlevel'></span><span id='topic+c_identity'></span><span id='topic+c_add'></span><span id='topic+c_multiply'></span><span id='topic+c_power'></span><span id='topic+c_equal'></span><span id='topic+c_grade'></span><span id='topic+c_getcoeffs'></span><span id='topic+c_innerprod'></span><span id='topic+c_outerprod'></span><span id='topic+c_fatdotprod'></span><span id='topic+c_lefttickprod'></span><span id='topic+c_righttickprod'></span><span id='topic+c_overwrite'></span><span id='topic+c_cartan'></span><span id='topic+c_cartan_inverse'></span>

<h3>Description</h3>

<p>Helper functions for <code>clifford</code> objects, written in <code>C</code> using the
<code>STL</code> map class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_identity(L, p, m)
c_grade(L, c, m, n)
c_add(L1, c1, L2, c2, m)
c_multiply(L1, c1, L2, c2, m, sig)
c_power(L, c, m, p, sig)
c_equal(L1, c1, L2, c2, m)
c_overwrite(L1, c1, L2, c2, m)
c_cartan(L, c, m, n)
c_cartan_inverse(L, c, m, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lowlevel_+3A_l">L</code>, <code id="lowlevel_+3A_l1">L1</code>, <code id="lowlevel_+3A_l2">L2</code></td>
<td>
<p>Lists of terms</p>
</td></tr>
<tr><td><code id="lowlevel_+3A_c1">c1</code>, <code id="lowlevel_+3A_c2">c2</code>, <code id="lowlevel_+3A_c">c</code></td>
<td>
<p>Numeric vectors of coefficients</p>
</td></tr>
<tr><td><code id="lowlevel_+3A_m">m</code></td>
<td>
<p>Maximum entry of terms</p>
</td></tr>
<tr><td><code id="lowlevel_+3A_n">n</code></td>
<td>
<p>Grade to extract</p>
</td></tr>
<tr><td><code id="lowlevel_+3A_p">p</code></td>
<td>
<p>Integer power</p>
</td></tr>
<tr><td><code id="lowlevel_+3A_sig">sig</code></td>
<td>
<p>Two positive integers, \(p\) and \(q\),
representing the number of \(+1\) and \(-1\) terms
on the main diagonal of quadratic form</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions documented here are low-level helper functions that wrap
the <code>C</code> code.  They are called by functions like
<code>clifford_plus_clifford()</code>, which are themselves called by the
binary operators documented at <code>Ops.clifford.Rd</code>.
</p>
<p>Function <code>clifford_inverse()</code> is problematic as nonnull blades
always have an inverse; but function <code>is.blade()</code> is not yet
implemented.  Blades (including null blades) have a pseudoinverse, but
this is not implemented yet either.
</p>


<h3>Value</h3>

<p>The high-level functions documented here return an object of
<code>clifford</code>.  But don't use the low-level functions.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ops.clifford">Ops.clifford</a></code></p>

<hr>
<h2 id='magnitude'>Magnitude of a clifford object</h2><span id='topic+magnitude'></span><span id='topic+mod'></span><span id='topic+Mod'></span><span id='topic+Mod.clifford'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Following Perwass, the magnitude of a multivector is defined as
</p>
\[\left|\left|A\right|\right| = \sqrt{A\ast A}\]
<p>Where \(A\ast A\) denotes the Euclidean scalar product
<code>eucprod()</code>.  Recall that the Euclidean scalar product is never
negative (the function body is <code>sqrt(abs(eucprod(z)))</code>; the
<code>abs()</code> is needed to avoid numerical roundoff errors in
<code>eucprod()</code> giving a negative value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clifford'
Mod(z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magnitude_+3A_z">z</code></td>
<td>
<p>Clifford objects</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If you want the square, 
\(\left|\left|A\right|\right|^2\) and not
\(\left|\left|A\right|\right|\), it is faster and more accurate
to use <code>eucprod(A)</code>, because this avoids a needless square root.
</p>
<p>There is a nice example of scalar product at <code>rcliff.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ops.clifford">Ops.clifford</a></code>,
<code><a href="#topic+Conj">Conj</a></code>,
<code><a href="#topic+rcliff">rcliff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

Mod(rcliff())


# Perwass, p68, asserts that if A is a k-blade, then (in his notation)
# AA == A*A.

# In package idiom, A*A == A %star% A:

A &lt;- rcliff()          
Mod(A*A - A %star% A)  # meh

A &lt;- rblade()
Mod(A*A - A %star% A)  # should be small



</code></pre>

<hr>
<h2 id='minus'>Take the negative of a vector</h2><span id='topic+minus'></span><span id='topic+is.minus'></span>

<h3>Description</h3>

<p>Very simple function that takes the negative of a vector, here so that
idiom such as
</p>
<p><code>coeffs(z)[gradesminus(z)%%2 != 0] %&lt;&gt;% minus</code>
</p>
<p>works as intended (this taken from <code>Conj.clifford()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minus(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minus_+3A_x">x</code></td>
<td>
<p>Any vector or disord object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or disord</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>

<hr>
<h2 id='numeric_to_clifford'>Coercion from numeric to Clifford form</h2><span id='topic+numeric_to_clifford'></span><span id='topic+as.cliffvector'></span><span id='topic+as.1vector'></span><span id='topic+is.1vector'></span><span id='topic+is.scalar'></span><span id='topic+as.scalar'></span><span id='topic+scalar'></span><span id='topic+basis'></span><span id='topic+e'></span><span id='topic+pseudoscalar'></span><span id='topic+as.pseudoscalar'></span><span id='topic+is.pseudoscalar'></span>

<h3>Description</h3>

<p>Given a numeric value or vector, return a Clifford algebra element</p>


<h3>Usage</h3>

<pre><code class='language-R'>numeric_to_clifford(x)
as.1vector(x)
is.1vector(x)
scalar(x=1)
as.scalar(x=1)
is.scalar(C)
basis(n,x=1)
e(n,x=1)
pseudoscalar(n,x=1)
as.pseudoscalar(n,x=1)
is.pseudoscalar(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numeric_to_clifford_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="numeric_to_clifford_+3A_n">n</code></td>
<td>
<p>Integer specifying dimensionality of underlying vector space</p>
</td></tr> 
<tr><td><code id="numeric_to_clifford_+3A_c">C</code></td>
<td>
<p>Object possibly of class Clifford</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>as.scalar()</code> takes a length-one numeric vector and
returns a Clifford scalar of that value (to extract the scalar
component of a multivector, use <code>const()</code>).
</p>
<p>Function <code>is.scalar()</code> is a synonym for <code>is.real()</code> which is
documented at <code>const.Rd</code>.
</p>
<p>Function <code>as.1vector()</code> takes a numeric vector and returns the
linear sum of length-one blades with coefficients given by <code>x</code>;
function <code>is.1vector()</code> returns <code>TRUE</code> if every term is of
grade 1.
</p>
<p>Function <code>pseudoscalar(n)</code> returns a pseudoscalar of
dimensionality <code>n</code> and function <code>is.pseudoscalar()</code> checks
for a Clifford object being a pseudoscalar.
</p>
<p>Function <code>numeric_to_vector()</code> dispatches to either
<code>as.scalar()</code> for length-one vectors or <code>as.1vector()</code>
if the length is greater than one.
</p>
<p>Function <code>basis()</code> returns a wedge product of basis vectors;
function <code>e()</code> is a synonym.  There is special dispensation for
zero, so <code>e(0)</code> returns the Clifford scalar 1.
</p>
<p>Function <code>antivector()</code> should arguably be described here but is
actually documented at <code>antivector.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+getcoeffs">getcoeffs</a></code>,<code><a href="#topic+antivector">antivector</a></code>,<code><a href="#topic+const">const</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.scalar(6)
as.1vector(1:8)

e(5:8)

Reduce(`+`,sapply(seq_len(7),function(n){e(seq_len(n))},simplify=FALSE))

pseudoscalar(6)

pseudoscalar(7,5) == 5*pseudoscalar(7)  # should be true


</code></pre>

<hr>
<h2 id='Ops.clifford'>Arithmetic Ops Group Methods for <code>clifford</code> objects</h2><span id='topic++25.+25'></span><span id='topic++25dot+25'></span><span id='topic++25+5E+25'></span><span id='topic++25X+25'></span><span id='topic++25star+25'></span><span id='topic++25+20+25'></span><span id='topic++25euc+25'></span><span id='topic++25o+25'></span><span id='topic++25_+7C+25'></span><span id='topic++25+7C_+25'></span><span id='topic++25.+25.clifford'></span><span id='topic++25+5E+25.clifford'></span><span id='topic++25X+25.clifford'></span><span id='topic++25star+25.clifford'></span><span id='topic++25+20+25.clifford'></span><span id='topic++25euc+25.clifford'></span><span id='topic++25o+25.clifford'></span><span id='topic++25_+7C+25.clifford'></span><span id='topic++25+7C_+25.clifford'></span><span id='topic+Ops.clifford'></span><span id='topic+Ops'></span><span id='topic+clifford_negative'></span><span id='topic+clifford_times_clifford'></span><span id='topic+geoprod'></span><span id='topic+geometric_prod'></span><span id='topic+geometric_product'></span><span id='topic+clifford_times_scalar'></span><span id='topic+clifford_plus_clifford'></span><span id='topic+clifford_plus_numeric'></span><span id='topic+clifford_plus_scalar'></span><span id='topic+clifford_star_clifford'></span><span id='topic+star'></span><span id='topic+clifford_cross_clifford'></span><span id='topic+cross'></span><span id='topic+clifford_fatdot_clifford'></span><span id='topic+fatdot'></span><span id='topic+clifford_lefttick_clifford'></span><span id='topic+lefttick'></span><span id='topic+left_contraction'></span><span id='topic+clifford_righttick_clifford'></span><span id='topic+righttick'></span><span id='topic+right+20contraction'></span><span id='topic+clifford_power_scalar'></span><span id='topic+clifford_eq_clifford'></span><span id='topic+clifford_inverse'></span><span id='topic+dot'></span><span id='topic+wedge'></span><span id='topic+clifford_dot_clifford'></span><span id='topic+cliffdotprod'></span><span id='topic+clifford_wedge_clifford'></span><span id='topic+maxyterm'></span><span id='topic+scalprod'></span><span id='topic+scalar_product'></span><span id='topic+eucprod'></span><span id='topic+euclid+5C_product'></span><span id='topic+euclidean+5C_product'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Allows arithmetic operators to be used for
multivariate polynomials  such as addition, multiplication,
integer powers, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clifford'
Ops(e1, e2)
clifford_negative(C)
geoprod(C1,C2)
clifford_times_scalar(C,x)
clifford_plus_clifford(C1,C2)
clifford_eq_clifford(C1,C2)
clifford_inverse(C)
cliffdotprod(C1,C2)
fatdot(C1,C2)
lefttick(C1,C2)
righttick(C1,C2)
wedge(C1,C2)
scalprod(C1,C2=rev(C1),drop=TRUE)
eucprod(C1,C2=C1,drop=TRUE)
maxyterm(C1,C2=as.clifford(0))
C1 %.% C2
C1 %dot% C2
C1 %^% C2
C1 %X% C2
C1 %star% C2
C1 % % C2
C1 %euc% C2
C1 %o% C2
C1 %_|% C2
C1 %|_% C2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ops.clifford_+3A_e1">e1</code>, <code id="Ops.clifford_+3A_e2">e2</code>, <code id="Ops.clifford_+3A_c">C</code>, <code id="Ops.clifford_+3A_c1">C1</code>, <code id="Ops.clifford_+3A_c2">C2</code></td>
<td>
<p>Objects of class <code>clifford</code> or coerced if
needed</p>
</td></tr>
<tr><td><code id="Ops.clifford_+3A_x">x</code></td>
<td>
<p>Scalar, length one numeric vector</p>
</td></tr>
<tr><td><code id="Ops.clifford_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return the
constant coerced to numeric, and <code>FALSE</code> meaning to return a
(constant) Clifford object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Ops.clifford()</code> passes unary and binary arithmetic
operators &ldquo;<code>+</code>&rdquo;, &ldquo;<code>-</code>&rdquo;, &ldquo;<code>*</code>&rdquo;,
&ldquo;<code>/</code>&rdquo; and &ldquo;<code>^</code>&rdquo; to the appropriate specialist
function.  Function <code>maxyterm()</code> returns the maximum index in the
terms of its arguments.
</p>
<p>The package has several binary operators:
</p>

<table>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
    Geometric product </td><td style="text-align: left;"> <code>A*B = geoprod(A,B)</code> </td><td style="text-align: left;">
    \(\displaystyle AB=\sum_{r,s}\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Inner product</td><td style="text-align: left;"> <code>A %.% B = cliffdotprod(A,B)</code></td><td style="text-align: left;">
    \(\displaystyle A\cdot B=\sum_{r\neq 0\atop s\ne
    0}^{\vphantom{s\neq 0}}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_{\left|s-r\right|}\)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Outer product</td><td style="text-align: left;"><code>A %^% B = wedge(A,B)</code></td><td style="text-align: left;">
    \(\displaystyle A\wedge B=\sum_{r,s}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_{s+r}\)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Fat dot product</td><td style="text-align: left;"><code>A %o% B = fatdot(A,B)</code></td><td style="text-align: left;">
    \(\displaystyle A\bullet B=\sum_{r,s}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_{\left|s-r\right|}\)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Left contraction</td><td style="text-align: left;"><code>A %_|% B = lefttick(A,B)</code></td><td style="text-align: left;">
    \(\displaystyle A\rfloor B=\sum_{r,s}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_{s-r}\)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Right contraction</td><td style="text-align: left;"><code>A %|_% B = righttick(A,B)</code></td><td style="text-align: left;">
    \(\displaystyle A\lfloor B=\sum_{r,s}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_{r-s}\)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Cross product</td><td style="text-align: left;"><code>A %X% B = cross(A,B)</code></td><td style="text-align: left;">
    \(\displaystyle A\times
    B=\frac{1}{2_{\vphantom{j}}}\left(AB-BA\right)\)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Scalar product</td><td style="text-align: left;"><code>A %star% B = star(A,B)</code></td><td style="text-align: left;">
    \(\displaystyle A\ast B=\sum_{r,s}\left\langle\left\langle A\right\rangle_r\left\langle
      B\right\rangle_s\right\rangle_0\)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Euclidean product</td><td style="text-align: left;"><code>A %euc% B = eucprod(A,B)</code></td><td style="text-align: left;">
    \(\displaystyle A\star B= A\ast B^\dagger\)</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>In R idiom, the geometric product <code>geoprod(.,.)</code> has to be
indicated with a &ldquo;<code>*</code>&rdquo; (as in <code>A*B</code>) and so the
binary operator must be <code>%*%</code>: we need a different idiom for
scalar product, which is why <code>%star%</code> is used.
</p>
<p>Because geometric product is often denoted by juxtaposition, package
idiom includes <code>a % % b</code> for geometric product.
</p>
<p>Binary operator <code>%dot%</code> is a synonym for <code>%.%</code>, which
causes problems for rmarkdown.
</p>
<p>Function <code>clifford_inverse()</code> returns an inverse for nonnull
Clifford objects \(Cl(p,q)\) for \(p+q\leq 5\), and
a few other special cases.  The functionality is problematic as
nonnull blades always have an inverse; but function <code>is.blade()</code>
is not yet implemented.  Blades (including null blades) have a
pseudoinverse, but this is not implemented yet either.
</p>
<p>The <dfn>scalar product</dfn> of two clifford objects is defined as the
zero-grade component of their geometric product:
</p>
\[
    A\ast B=\left\langle AB\right\rangle_0\qquad{\mbox{NB: notation used by both Perwass and Hestenes}}
  \]
<p>In package idiom the scalar product is given by <code>A %star% B</code> or
<code>scalprod(A,B)</code>.  Hestenes and Perwass both use an asterisk for
scalar product as in &ldquo;\(A*B\)&rdquo;, but in package idiom, the
asterisk is reserved for geometric product.
</p>
<p><strong>Note: in the package, <code>A*B</code> is the geometric product</strong>.
</p>
<p>The <dfn>Euclidean product</dfn> (or <dfn>Euclidean scalar product</dfn>) of two
clifford objects is defined as 
</p>
\[
    A\star B=
    A\ast B^\dagger=
    \left\langle AB^\dagger\right\rangle_0\qquad{\mbox{Perwass}}
  \]
<p>where \(B^\dagger\) denotes Conjugate [as in <code>Conj(a)</code>].  In
package idiom the Euclidean scalar product is given by
<code>eucprod(A,B)</code> or <code>A %euc% B</code>, both of which return
<code>A * Conj(B)</code>.
</p>
<p>Note that the scalar product \(A\ast A\) can be positive or
negative [that is, <code>A %star% A</code> may be any sign], but the
Euclidean product is guaranteed to be non-negative [that is, <code>A
  %euc% A</code> is always positive or zero].
</p>
<p>Dorst defines the left and right contraction (Chisholm calls these the
left and right inner product) as \(A\rfloor B\) and
\(A\lfloor B\).  See the vignette for more details.
</p>
<p>Division, as in idiom <code>x/y</code>, is defined as
<code>x*clifford_inverse(y)</code>.  Function <code>clifford_inverse()</code> uses
the method set out by Hitzer and Sangwine but is limited to
\(p+q\leq 5\).
</p>
<p>Many of the functions documented here use low-level helper functions
that wrap C code.  For example, <code>fatdot()</code> uses
<code>c_fatdotprod()</code>.  These are documented at <code>lowlevel.Rd</code>.
</p>


<h3>Value</h3>

<p>The high-level functions documented here return a <code>clifford</code>
object.  The low-level functions are not really intended for the
end-user.
</p>


<h3>Note</h3>

<p>In the <span class="pkg">clifford</span> package the caret &ldquo;<code>^</code>&rdquo; is reserved
for multiplicative powers, as in <code>A^3=A*A*A</code>.  All the different
Clifford products have binary operators for convenience including the
wedge product <code>%^%</code>.  Compare the <span class="pkg">stokes</span> package, where
multiplicative powers do not really make sense and <code>A^B</code> is
interpreted as a wedge product of differential forms \(A\) and
\(B\).  In <span class="pkg">stokes</span>, the wedge product is the <em>sine qua
non</em> for the whole package and needs a terse idiomatic representation
(although there <code>A%^%B</code> returns the wedge product too).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>E. Hitzer and S. Sangwine 2017.  &ldquo;Multivector and multivector
matrix inverses in real Clifford algebras&rdquo;.  <em>Applied Mathematics
and Computation</em> 311:375-389
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
u &lt;- rcliff(5)
v &lt;- rcliff(5)
w &lt;- rcliff(5)

u
v
u*v

u+(v+w) == (u+v)+w            # should be TRUE by associativity of "+"
u*(v*w) == (u*v)*w            # should be TRUE by associativity of "*"
u*(v+w) == u*v + u*w          # should be TRUE by distributivity

# Now if x,y are _vectors_ we have:

x &lt;- as.1vector(sample(5))
y &lt;- as.1vector(sample(5))
x*y == x%.%y + x%^%y
x %^% y == x %^% (y + 3*x)  
x %^% y == (x*y-x*y)/2        # should be TRUE 

#  above are TRUE for x,y vectors (but not for multivectors, in general)


## Inner product "%.%" is not associative:
x &lt;- rcliff(5,g=2)
y &lt;- rcliff(5,g=2)
z &lt;- rcliff(5,g=2)
x %.% (y %.% z) == (x %.% y) %.% z

## Other products should work as expected:

x %|_% y   ## left contraction
x %_|% y   ## right contraction
x %o% y    ## fat dot product


</code></pre>

<hr>
<h2 id='print'>Print clifford objects</h2><span id='topic+print.clifford'></span><span id='topic+as.character'></span><span id='topic+as.character.clifford'></span><span id='topic+catterm'></span><span id='topic+basissep'></span>

<h3>Description</h3>

<p>Print methods for Clifford algebra</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clifford'
print(x,...)
## S3 method for class 'clifford'
as.character(x,...)
catterm(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Object of class <code>clifford</code> in the print method</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
<tr><td><code id="print_+3A_a">a</code></td>
<td>
<p>Integer vector representing a term</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The print method does not change the internal representation of a
<code>clifford</code> object, which is a two-element list, the first of which
is a list of integer vectors representing terms, and the second is a
numeric vector of coefficients.
</p>
<p>The print method is sensitive to the value of option <code>separate</code>.
If <code>FALSE</code> (the default), the method prints in a compact form, as
in <code>e_134</code>.  The indices of the basis vectors are separated with
option <code>basissep</code> which is usually <code>NULL</code> but if <code class="reqn">n&gt;9</code>,
then setting <code>options("basissep" = ",")</code> might look good as it will
print <code>e_10,11,12</code> instead of <code>e_101112</code>.  If <code>separate</code>
is <code>TRUE</code>, the method prints the basis vectors separately, as in
<code>e1 e3 e4</code>.
</p>
<p>Function <code>as.character.clifford()</code> is also sensitive to these
options.  The print method has special dispensation for length-zero
clifford objects.  Function <code>catterm()</code> is a low-level helper
function.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+clifford">clifford</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- rcliff(d=15,g=9)
a   # incomprehensible

options("separate" = TRUE)
a    # marginally better


options("separate" = FALSE)
options(basissep=",")
a    #  clearer; YMMV

options(basissep = NULL)  # restore default



</code></pre>

<hr>
<h2 id='quaternion'>Quaternions using Clifford algebras</h2><span id='topic+quaternion'></span><span id='topic+quaternion_to_clifford'></span><span id='topic+clifford_to_quaternion'></span>

<h3>Description</h3>

<p>Converting quaternions to and from Clifford objects is not part of the
package but functionality and a short discussion is included in
<code>inst/quaternion_clifford.Rmd</code>.
</p>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Given a quaternion \(a+bi+cj+dk\), one may identify
\(i\) with \(-e_{12}\), \(j\) with
\(-e_{13}\), and \(k\) with \(-e_{23}\)
(the constant term is of course \(e_0\)).
</p>


<h3>Note</h3>

<p>A different mapping, from the quaternions to \(Cl(0,2)\) is
given at <code>signature.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+signature">signature</a></code></p>

<hr>
<h2 id='rcliff'>Random clifford objects</h2><span id='topic+rcliff'></span><span id='topic+rblade'></span>

<h3>Description</h3>

<p>Random Clifford algebra elements, intended as quick
&ldquo;get you going&rdquo; examples of <code>clifford</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcliff(n=9, d=6, g=4, include.fewer=TRUE)
rblade(d=7, g=3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcliff_+3A_n">n</code></td>
<td>
<p>Number of terms</p>
</td></tr>
<tr><td><code id="rcliff_+3A_d">d</code></td>
<td>
<p>Dimensionality of underlying vector space</p>
</td></tr>
<tr><td><code id="rcliff_+3A_g">g</code></td>
<td>
<p>Maximum grade of any term</p>
</td></tr>
<tr><td><code id="rcliff_+3A_include.fewer">include.fewer</code></td>
<td>
<p>Boolean, with <code>FALSE</code> meaning to
return a clifford object comprising only terms of grade <code>g</code>,
and default <code>TRUE</code> meaning to include terms with
grades less than <code>g</code> (including a term of grade zero, that
is, a scalar)</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Function <code>rcliff()</code> gives a quick nontrivial Clifford object,
typically with terms having a range of grades (see &lsquo;<span class="file">grade.Rd</span>&rsquo;);
argument <code>include.fewer=FALSE</code> ensures that all terms are of the
same grade.
</p>
<p>Function <code>rblade()</code> gives a Clifford object that is a
<em>blade</em> (see &lsquo;<span class="file">term.Rd</span>&rsquo;).  It returns the wedge product of a
number of 1-vectors, for example
\(\left(e_1+2e_2\right)\wedge\left(e_1+3e_5\right)\).
</p>
<p>Perwass gives the following lemma:
</p>
<p>Given blades \(A_{\langle r\rangle}, B_{\langle s\rangle},
    C_{\langle t\rangle}\), then
</p>
\[
    \langle
    A_{\langle r\rangle}
    B_{\langle s\rangle}
    C_{\langle t\rangle}
    \rangle_0
    =
    \langle
    C_{\langle t\rangle}
    A_{\langle r\rangle}
    B_{\langle s\rangle}
    \rangle_0
  \]
<p>In the proof he notes in an intermediate step that 
</p>
\[
    \langle
    A_{\langle r\rangle}
    B_{\langle s\rangle}
    \rangle_t * 
    C_{\langle t\rangle}
    =
    C_{\langle t\rangle} * 
    \langle
    A_{\langle r\rangle}
    B_{\langle s\rangle}
    \rangle_t
    = 
    \langle
    C_{\langle t\rangle}
    A_{\langle r\rangle}
    B_{\langle s\rangle}
    \rangle_0.
  \]
<p>Package idiom is shown in the examples.
</p>


<h3>Note</h3>

<p>If the grade exceeds the dimensionality, \(g>d\), then
the result is arguably zero; <code>rcliff()</code> returns an error.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+term">term</a></code>,<code><a href="#topic+grade">grade</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rcliff()
rcliff(d=3,g=2)
rcliff(3,10,7)
rcliff(3,10,7,include=TRUE)

x1 &lt;- rcliff()
x2 &lt;- rcliff()
x3 &lt;- rcliff()

x1*(x2*x3) == (x1*x2)*x3  # should be TRUE


rblade()

# We can invert blades easily:
a &lt;- rblade()
ainv &lt;- rev(a)/scalprod(a)

zap(a*ainv)  # 1 (to numerical precision)
zap(ainv*a)  # 1 (to numerical precision)

# Perwass 2009, lemma 3.9:


A &lt;- rblade(d=9,g=4)  
B &lt;- rblade(d=9,g=5)  
C &lt;- rblade(d=9,g=6)  

grade(A*B*C,0)-grade(C*A*B,0)   # zero to numerical precision



# Intermediate step

x1 &lt;- grade(A*B,3) %star% C
x2 &lt;- C %star% grade(A*B,3)
x3 &lt;- grade(C*A*B,0)

max(x1,x2,x3) - min(x1,x2,x3)   # zero to numerical precision

</code></pre>

<hr>
<h2 id='signature'>The signature of the Clifford algebra</h2><span id='topic+signature'></span><span id='topic+sig'></span><span id='topic+is_ok_sig'></span><span id='topic+showsig'></span><span id='topic+print.sigobj'></span><span id='topic+mymax'></span>

<h3>Description</h3>

<p>Getting and setting the signature of the Clifford algebra</p>


<h3>Usage</h3>

<pre><code class='language-R'>signature(p,q=0)
is_ok_sig(s)
showsig(s)
## S3 method for class 'sigobj'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signature_+3A_s">s</code>, <code id="signature_+3A_p">p</code>, <code id="signature_+3A_q">q</code></td>
<td>
<p>Integers, specifying number of positive elements on the
diagonal of the quadratic form, with <code>s=c(p,q)</code></p>
</td></tr>
<tr><td><code id="signature_+3A_x">x</code></td>
<td>
<p>Object of class <code>sigobj</code></p>
</td></tr>
<tr><td><code id="signature_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The signature functionality is modelled on <code>lorentz::sol()</code> which
gets and sets the speed of light.
</p>
<p>Clifford algebras require a bilinear form on \(\mathbb{R}^n\)
\(\left\langle\cdot,\cdot\right\rangle\), usually written
</p>
\[\left\langle{\mathbf x},{\mathbf x}\right\rangle=x_1^2+x_2^2+\cdots
  +x_p^2-x_{p+1}^2-\cdots -x_{p+q}^2
\]
<p>where \(p+q=n\).  With this quadratic form the vector space
is denoted \(\mathbb{R}^{p,q}\) and we say that
\((p,q)\) is the <dfn>signature</dfn> of the bilinear form
\(\left\langle\cdot,\cdot\right\rangle\).  This gives rise to
the Clifford algebra \(C_{p,q}\).
</p>
<p>If the signature is \((p,q)\), then we have
</p>
\[
  e_i e_i =   +1\, (\mbox{if } 1\leq i\leq p), 
              -1\, (\mbox{if } p+1\leq i\leq p+q),
               0\, (\mbox{if } i>p+q).
  \]
<p>Note that \((p,0)\) corresponds to a positive-semidefinite
quadratic form in which \(e_ie_i=+1\) for all \(i\leq
p\) and \(e_ie_i=0\) for all \(i > p\).
Similarly, \((0,q)\) corresponds to a negative-semidefinite
quadratic form in which \(e_ie_i=-1\) for all \(i\leq
q\) and \(e_ie_i=0\) for all \(i > q\).
</p>
<p>Package idiom for a strictly positive-definite quadratic form would be
to specify infinite \(p\) [in which case \(q\) is irrelevant]
and for a strictly negative-definite quadratic form we would need
\(p=0,q=\infty\).
</p>
<p>If we specify \(e_ie_i=0\) for all \(i\), then the
operation reduces to the wedge product of a Grassman algebra.  Package
idiom for this is to set \(p=q=0\), but this is not recommended:
use the <span class="pkg">stokes</span> package for Grassman algebras, which is much more
efficient and uses nicer idiom.
</p>
<p>Function <code>signature(p,q)</code> returns the signature silently; but
setting option <code>show_signature</code> to <code>TRUE</code> makes
<code>signature()</code> have the side-effect of calling <code>showsig()</code>,
which changes the default prompt to display the signature, much like
<code>showSOL</code> in the <code>lorentz</code> package.  There is special
dispensation for &ldquo;infinite&rdquo; \(p\) or \(q\).
</p>
<p>Calling <code>signature()</code> [that is, with no arguments] returns an
object of class <code>sigobj</code> with elements corresponding to <code class="reqn">p</code> and
<code class="reqn">q</code>.  The <code>sigobj</code> class ensures that a near-infinite integer
such as <code>.Machine$integer.max</code> will be printed as
&ldquo;<code>Inf</code>&rdquo; rather than, for example,
&ldquo;<code>2147483647</code>&rdquo;.
</p>
<p>Function <code>is_ok_sig()</code> is a helper function that checks for a
proper signature.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>

signature()

e(1)^2
e(2)^2

signature(1)
e(1)^2
e(2)^2   # note sign

signature(3,4)
sapply(1:10,function(i){drop(e(i)^2)})


signature(Inf)   # restore default




# Nice mapping from Cl(0,2) to the quaternions (loading clifford and
# onion simultaneously is discouraged):

# library("onion")
# signature(0,2)
# Q1 &lt;- rquat(1)
# Q2 &lt;- rquat(1)
# f &lt;- function(H){Re(H)+i(H)*e(1)+j(H)*e(2)+k(H)*e(1:2)}
# f(Q1)*f(Q2) - f(Q1*Q2) # zero to numerical precision
# signature(Inf)

</code></pre>

<hr>
<h2 id='summary.clifford'>Summary methods for clifford objects</h2><span id='topic+summary.clifford'></span><span id='topic+print.summary.clifford'></span><span id='topic+first_n_last'></span>

<h3>Description</h3>

<p>Summary method for clifford objects, and a print method for summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clifford'
summary(object, ...)
## S3 method for class 'summary.clifford'
print(x, ...)
first_n_last(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.clifford_+3A_object">object</code>, <code id="summary.clifford_+3A_x">x</code></td>
<td>
<p>Object of class clifford</p>
</td></tr>
<tr><td><code id="summary.clifford_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summary of a clifford object.   Note carefully that the
&ldquo;typical terms&rdquo; are implementation specific.  Function
<code>first_n_last()</code> is a helper function.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(rcliff())
</code></pre>

<hr>
<h2 id='term'>Deal with terms</h2><span id='topic+term'></span><span id='topic+terms'></span><span id='topic+is.term'></span><span id='topic+blade'></span><span id='topic+is.blade'></span><span id='topic+is.basisblade'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>By <dfn>basis vector</dfn>, I mean one of the basis vectors of the underlying
vector space \(R^n\), that is, an element of the set
\(\left\lbrace e_1,\ldots,e_n\right\rbrace\).  A
<dfn>term</dfn> is a wedge product of basis vectors (or a geometric product
of linearly independent basis vectors), something like
\(e_{12}\) or \(e_{12569}\).  Sometimes I use the
word &ldquo;term&rdquo; to mean a wedge product of basis vectors together
with its associated coefficient: so \(7e_{12}\) would be
described as a term.
</p>
<p>From Perwass: a <dfn>blade</dfn> is the outer product of a number of
1-vectors (or, equivalently, the wedge product of linearly independent
1-vectors).  Thus \(e_{12}=e_1\wedge e_2\) and
\(e_{12} + e_{13}=e_1\wedge(e_2+e_3)\) are
blades, but \(e_{12} + e_{34}\) is not.
</p>
<p>Function <code>rblade()</code>, documented at &lsquo;<span class="file">rcliff.Rd</span>&rsquo;, returns a
random blade.
</p>
<p>Function <code>is.blade()</code> is not currently implemented: there is no
easy way to detect whether a Clifford object is a product of 1-vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terms(x)
is.blade(x)
is.basisblade(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="term_+3A_x">x</code></td>
<td>
<p>Object of class <code>clifford</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Functions <code>terms()</code> and <code>coeffs()</code> are the
extraction methods.  These are unordered vectors but the ordering is
consistent between them (an extended discussion of this phenomenon
is presented in the <code>mvp</code> package).
</p>
</li>
<li><p> Function <code>term()</code> returns a clifford object that comprises
a single term with unit coefficient.
</p>
</li>
<li><p> Function <code>is.basisterm()</code> returns <code>TRUE</code> if its
argument has only a single term, or is a nonzero scalar; the zero
clifford object is not considered to be a basis term.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>C. Perwass. &ldquo;Geometric algebra with applications in
engineering&rdquo;.   Springer, 2009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clifford">clifford</a></code>,<code><a href="#topic+rblade">rblade</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rcliff()
terms(x)

is.basisblade(x)


a &lt;- as.1vector(1:3)
b &lt;- as.1vector(c(0,0,0,12,13))

a %^% b # a blade

</code></pre>

<hr>
<h2 id='zap'>Zap small values in a clifford object</h2><span id='topic+zap'></span><span id='topic+zapsmall'></span><span id='topic+zaptiny'></span><span id='topic+zap.clifford'></span>

<h3>Description</h3>

<p>Generic version of <code>zapsmall()</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>zap(x, drop=TRUE, digits = getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zap_+3A_x">x</code></td>
<td>
<p>Clifford object</p>
</td></tr>
<tr><td><code id="zap_+3A_drop">drop</code></td>
<td>
<p>Boolean with default <code>TRUE</code> meaning to 
coerce the output to numeric with <code>drop()</code></p>
</td></tr>
<tr><td><code id="zap_+3A_digits">digits</code></td>
<td>
<p>number of digits to retain</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a clifford object, coefficients close to zero are
&lsquo;zapped&rsquo;, i.e., replaced by &lsquo;0&rsquo; in much the same way as
<code>base::zapsmall()</code>.
</p>
<p>The function should be called <code>zapsmall()</code>, and dispatch to the
appropriate base function, but I could not figure out how to do this
with S3 (the docs were singularly unhelpful) and gave up. 
</p>
<p>Note, this function actually changes the numeric value, it is not just
a print method.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- clifford(sapply(1:10,seq_len),90^-(1:10))
zap(a)
options(digits=3)
zap(a)


a-zap(a)   # nonzero

B &lt;- rblade(g=3)
mB &lt;- B*rev(B)
zap(mB)
drop(mB)
</code></pre>

<hr>
<h2 id='zero'>The zero Clifford object</h2><span id='topic+zero'></span><span id='topic+is.zero'></span>

<h3>Description</h3>

<p>Dealing with the zero Clifford object presents particular challenges.
Some of the methods need special dispensation for the zero object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.zero(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zero_+3A_c">C</code></td>
<td>
<p>Clifford object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create the zero object <em>ab initio</em>, use
</p>
<p><code>clifford(list(),numeric(0))</code>
</p>
<p>although note that <code>scalar(0)</code> will work too.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalar">scalar</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
is.zero(rcliff())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
