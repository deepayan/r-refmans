<!DOCTYPE html><html><head><title>Help for package flashier</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flashier}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fitted.flash'><p>Fitted method for flash objects</p></a></li>
<li><a href='#fitted.flash_fit'><p>Fitted method for flash fit objects</p></a></li>
<li><a href='#flash'><p>Empirical Bayes matrix factorization</p></a></li>
<li><a href='#flash_add_intercept'><p>Add &quot;intercept&quot; to a flash object</p></a></li>
<li><a href='#flash_backfit'><p>Backfit a flash object</p></a></li>
<li><a href='#flash_clear_timeout'><p>Set timeout</p></a></li>
<li><a href='#flash_conv_crit_elbo_diff'><p>Calculate the difference in ELBO</p></a></li>
<li><a href='#flash_conv_crit_max_chg'><p>Calculate the maximum absolute difference in scaled loadings and factors</p></a></li>
<li><a href='#flash_conv_crit_max_chg_F'><p>Calculate the maximum absolute difference in scaled factors</p></a></li>
<li><a href='#flash_conv_crit_max_chg_L'><p>Calculate the maximum absolute difference in scaled loadings</p></a></li>
<li><a href='#flash_ebnm'><p>Construct an EBNM function</p></a></li>
<li><a href='#flash_factors_fix'><p>Fix flash factors</p></a></li>
<li><a href='#flash_factors_init'><p>Initialize flash factors at specified values</p></a></li>
<li><a href='#flash_factors_remove'><p>Remove factors from a flash object</p></a></li>
<li><a href='#flash_factors_reorder'><p>Reorder factors in a flash object</p></a></li>
<li><a href='#flash_factors_set_to_zero'><p>Set flash factors to zero</p></a></li>
<li><a href='#flash_factors_unfix'><p>Unfix flash factors</p></a></li>
<li><a href='#flash_fit'><p>Extract a flash_fit object</p></a></li>
<li><a href='#flash_greedy'><p>Greedily add factors to a flash object</p></a></li>
<li><a href='#flash_greedy_init_default'><p>Initialize a flash factor</p></a></li>
<li><a href='#flash_greedy_init_irlba'><p>Initialize a flash factor using IRLBA</p></a></li>
<li><a href='#flash_greedy_init_softImpute'><p>Initialize a flash factor using softImpute</p></a></li>
<li><a href='#flash_init'><p>Initialize flash object</p></a></li>
<li><a href='#flash_nullcheck'><p>Nullcheck flash factors</p></a></li>
<li><a href='#flash_set_conv_crit'><p>Set convergence criterion and tolerance parameter</p></a></li>
<li><a href='#flash_set_timeout'><p>Set timeout</p></a></li>
<li><a href='#flash_set_verbose'><p>Set verbose output</p></a></li>
<li><a href='#flash_verbose_elbo'><p>Display the current ELBO</p></a></li>
<li><a href='#flash_verbose_elbo_diff'><p>Display the difference in ELBO</p></a></li>
<li><a href='#flash_verbose_max_chg'><p>Display the maximum difference in scaled loadings and factors</p></a></li>
<li><a href='#flash_verbose_max_chg_F'><p>Display the maximum difference in scaled factors</p></a></li>
<li><a href='#flash_verbose_max_chg_L'><p>Display the maximum difference in scaled loadings</p></a></li>
<li><a href='#gtex'><p>GTEx data</p></a></li>
<li><a href='#gtex_colors'><p>Colors for plotting GTEx data</p></a></li>
<li><a href='#ldf'><p>LDF method for flash and flash fit objects</p></a></li>
<li><a href='#plot.flash'><p>Plot method for flash objects</p></a></li>
<li><a href='#residuals.flash'><p>Residuals method for flash objects</p></a></li>
<li><a href='#residuals.flash_fit'><p>Residuals method for flash fit objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Empirical Bayes Matrix Factorization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/willwerscheid/flashier">https://github.com/willwerscheid/flashier</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/willwerscheid/flashier/issues">https://github.com/willwerscheid/flashier/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for matrix factorization based on Wang and Stephens (2021) 
    <a href="https://jmlr.org/papers/v22/20-589.html">https://jmlr.org/papers/v22/20-589.html</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4), ebnm (&ge; 0.1-21), magrittr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, parallel, dplyr, stringr, tibble, tidyr, softImpute,
irlba, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ashr, cowplot, testthat, knitr, rmarkdown, RcppML, rsvd</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-16 16:37:23 UTC; jwillwer</td>
</tr>
<tr>
<td>Author:</td>
<td>Jason Willwerscheid [aut, cre],
  Peter Carbonetto [aut],
  Wei Wang [aut],
  Matthew Stephens [aut],
  Eric Weine [ctb],
  Gao Wang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jason Willwerscheid &lt;jwillwer@providence.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-17 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fitted.flash'>Fitted method for flash objects</h2><span id='topic+fitted.flash'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+flash">flash</a></code> object, returns the &quot;fitted values&quot;
<code class="reqn">E(LF') = E(L) E(F)'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flash'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.flash_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>flash</code>.</p>
</td></tr>
<tr><td><code id="fitted.flash_+3A_...">...</code></td>
<td>
<p>Additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of &quot;fitted values.&quot;
</p>

<hr>
<h2 id='fitted.flash_fit'>Fitted method for flash fit objects</h2><span id='topic+fitted.flash_fit'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+flash_fit">flash_fit</a></code> object, returns the &quot;fitted values&quot;
<code class="reqn">E(LF') = E(L) E(F)'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flash_fit'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.flash_fit_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>flash_fit</code>.</p>
</td></tr>
<tr><td><code id="fitted.flash_fit_+3A_...">...</code></td>
<td>
<p>Additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of &quot;fitted values.&quot;
</p>

<hr>
<h2 id='flash'>Empirical Bayes matrix factorization</h2><span id='topic+flash'></span>

<h3>Description</h3>

<p>Fits an empirical Bayes matrix factorization (see <strong>Details</strong> for a
description of the model). The resulting fit is referred to as a &quot;flash&quot;
object (short for Factors and Loadings using Adaptive SHrinkage). Two
interfaces are provided. The <code>flash</code> function provides a simple
interface that allows a flash object to be fit in a single pass, while
<code>flash_xxx</code> functions are pipeable functions that allow for more
complex flash objects to be fit incrementally (available functions are
listed below under <strong>See Also</strong>). See the vignettes and
<strong>Examples</strong> for usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash(
  data,
  S = NULL,
  ebnm_fn = ebnm_point_normal,
  var_type = 0L,
  greedy_Kmax = 50L,
  backfit = FALSE,
  nullcheck = TRUE,
  verbose = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_+3A_data">data</code></td>
<td>
<p>The observations. Usually a matrix, but can also be a sparse
matrix of class <code><a href="Matrix.html#topic+Matrix">Matrix</a></code> or a low-rank matrix
representation as returned by, for example, <code><a href="base.html#topic+svd">svd</a></code>,
<code><a href="irlba.html#topic+irlba">irlba</a></code>, <code><a href="rsvd.html#topic+rsvd">rsvd</a></code>, or
<code><a href="softImpute.html#topic+softImpute">softImpute</a></code> (in general, any list that
includes fields <code>u</code>, <code>d</code>, and <code>v</code> will be interpreted
as a low-rank matrix representation).</p>
</td></tr>
<tr><td><code id="flash_+3A_s">S</code></td>
<td>
<p>The standard errors. Can be <code>NULL</code> (in which case all residual
variance will be estimated) or a matrix, vector, or scalar. <code>S</code>
should be a scalar if standard errors are identical across observations. It
should be a vector if standard errors either vary across columns but are
constant within any given row, or vary across rows but are constant within
any given column (<code>flash</code> will use the length of the vector
to determine whether the supplied values correspond to rows or columns; if the
data matrix is square, then the sense must be specified using parameter
<code>S_dim</code> in function <code><a href="#topic+flash_init">flash_init</a></code>).</p>
</td></tr>
<tr><td><code id="flash_+3A_ebnm_fn">ebnm_fn</code></td>
<td>
<p>The function or functions used to solve the empirical Bayes
normal means (EBNM) subproblems. Most importantly, these functions specify
the families of distributions <code class="reqn">G_\ell^{(k)}</code> and <code class="reqn">G_f^{(k)}</code> to which the
priors on loadings and factors <code class="reqn">g_\ell^{(k)}</code> and <code class="reqn">g_f^{(k)}</code> are
assumed to belong. If the same function is to be used for both loadings
<code class="reqn">L</code> and factors <code class="reqn">F</code>, then <code>ebnm_fn</code> can be a single function.
If one function is to be used for loadings and a second for factors,
then <code>ebnm_fn</code> should be a list of length two, with the first
element giving the function for loadings and the second the function
for factors. If different functions are to be used for different values of
<code class="reqn">k</code>, then factor/loadings pairs must be added successively using
multiple calls to either <code><a href="#topic+flash_greedy">flash_greedy</a></code> or
<code><a href="#topic+flash_factors_init">flash_factors_init</a></code>.
</p>
<p>Any EBNM function provided by package <code><a href="ebnm.html#topic+ebnm">ebnm</a></code> can be
used as input. Non-default arguments to parameters can be supplied using
the helper function <code><a href="#topic+flash_ebnm">flash_ebnm</a></code>. Custom EBNM functions can
also be used: for details, see <code><a href="#topic+flash_ebnm">flash_ebnm</a></code>.</p>
</td></tr>
<tr><td><code id="flash_+3A_var_type">var_type</code></td>
<td>
<p>Describes the structure of the estimated residual variance.
Can be <code>NULL</code>, <code>0</code>, <code>1</code>, <code>2</code>, or <code>c(1, 2)</code>. If
<code>NULL</code>, then <code>S</code> accounts for all residual variance. If
<code>var_type = 0</code>, then the estimated residual variance (which is added
to any variance given by <code>S</code>) is assumed to be constant
across all observations. Setting <code>var_type = 1</code> estimates a single
variance parameter for each row; <code>var_type = 2</code> estimates one
parameter for each column; and <code>var_type = c(1, 2)</code> optimizes over
all rank-one matrices (that is, it assumes that the residual variance
parameter <code class="reqn">s_{ij}</code> can be written <code class="reqn">s_{ij} = a_i b_j</code>, where the
<code class="reqn">n</code>-vector <code class="reqn">a</code> and the <code class="reqn">p</code>-vector <code class="reqn">b</code> are to be
estimated).
</p>
<p>Note that if any portion of the residual variance is to be estimated, then
it is usually faster to set <code>S = NULL</code> and to let <code>flash</code>
estimate all of the residual variance. Further, <code>var_type = c(1, 2)</code>
is typically much slower than other options, so it should be used with
care.</p>
</td></tr>
<tr><td><code id="flash_+3A_greedy_kmax">greedy_Kmax</code></td>
<td>
<p>The maximum number of factors to be added. This will not
necessarily be the total number of factors added by <code>flash</code>, since
factors are only added as long as they increase the variational lower
bound on the log likelihood for the model.</p>
</td></tr>
<tr><td><code id="flash_+3A_backfit">backfit</code></td>
<td>
<p>A &quot;greedy&quot; fit is performed by adding up to
<code>greedy_Kmax</code> factors, optimizing each newly added factor in one go
without returning to optimize previously added factors. When
<code>backfit = TRUE</code>, <code>flash</code> will additionally perform a final
&quot;backfit&quot; where all factors are cyclically updated until convergence.
The backfitting procedure typically takes much longer than the greedy
algorithm, but it also usually improves the final fit to a significant
degree.</p>
</td></tr>
<tr><td><code id="flash_+3A_nullcheck">nullcheck</code></td>
<td>
<p>If <code>nullcheck = TRUE</code>, then <code>flash</code> will check
that each factor in the final flash object improves the overall fit. Any
factor that fails the check will be removed.</p>
</td></tr>
<tr><td><code id="flash_+3A_verbose">verbose</code></td>
<td>
<p>When and how to display progress updates. Set to
<code>0</code> for none, <code>1</code> for updates after a factor is added or a
backfit is completed, <code>2</code> for additional notifications about the
variational lower bound, and <code>3</code> for updates after every iteration.
It is also possible to output a single tab-delimited table of values
using function <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> with <code>verbose = -1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">Y</code> is an <code class="reqn">n \times p</code> data matrix, then the rank-one
empirical Bayes matrix factorization model is:
</p>
<p style="text-align: center;"><code class="reqn">Y = \ell f' + E,</code>
</p>
<p> where <code class="reqn">\ell</code> is an
<code class="reqn">n</code>-vector of <strong>loadings</strong>, <code class="reqn">f</code> is a
<code class="reqn">p</code>-vector of <strong>factors</strong>, and <code class="reqn">E</code> is an
<code class="reqn">n \times p</code> matrix of <strong>residuals</strong> (or &quot;errors&quot;).
Additionally:
</p>
<p style="text-align: center;"><code class="reqn">e_{ij} \sim N(0, s_{ij}^2): i = 1, ..., n; j = 1, ..., p</code>
</p>

<p style="text-align: center;"><code class="reqn">\ell \sim g_\ell \in G_\ell</code>
</p>

<p style="text-align: center;"><code class="reqn">f \sim g_f \in G_f.</code>
</p>

<p>The residual variance parameters <code class="reqn">s_{ij}^2</code> are constrained to have
a simple structure and are fit via maximum likelihood. (For example, one
might assume that all standard errors are identical: <code class="reqn">s_{ij}^2 = s^2</code>
for some <code class="reqn">s^2</code> and for all <code class="reqn">i</code>, <code class="reqn">j</code>).
The functions <code class="reqn">g_\ell</code> and <code class="reqn">g_f</code> are assumed to belong to
some families of priors <code class="reqn">G_\ell</code> and <code class="reqn">G_f</code> that are
specified in advance, and are estimated via variational approximation.
</p>
<p>The general rank-<code class="reqn">K</code> empirical Bayes matrix factorization model is:
</p>
<p style="text-align: center;"><code class="reqn">Y = LF' + E</code>
</p>
<p> or
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} = \sum_k \ell_{ik} f_{jk} + e_{ij}: i = 1, ..., n; j = 1, ..., p,</code>
</p>

<p>where <code class="reqn">L</code> is now a matrix of loadings and <code class="reqn">F</code> is a matrix of
factors.
</p>
<p>Separate priors <code class="reqn">g_\ell^{(k)}</code> and <code class="reqn">g_f^{(k)}</code> are estimated via
empirical Bayes, and different prior families may be used for different
values of <code class="reqn">k</code>. In general, then:
</p>
<p style="text-align: center;"><code class="reqn">e_{ij} \sim N(0, s_{ij}^2): i = 1, ..., n; j = 1, ..., p</code>
</p>

<p style="text-align: center;"><code class="reqn">\ell_{ik} \sim g_\ell^{(k)} \in G_\ell^{(k)}: i = 1, ..., n; k = 1, ..., K</code>
</p>

<p style="text-align: center;"><code class="reqn">f_{ik} \sim g_f^{(k)} \in G_f^{(k)}: j = 1, ..., p; k = 1, ..., K.</code>
</p>

<p>Typically, <code class="reqn">G_\ell^{(k)}</code> and <code class="reqn">G_f^{(k)}</code> will be closed under
scaling, in which case <code class="reqn">\ell_k</code> and <code class="reqn">f_k</code> are only identifiable
up to a <strong>scaling factor</strong> <code class="reqn">d_k</code>. In other words, we can write:
</p>
<p style="text-align: center;"><code class="reqn">Y = LDF' + E,</code>
</p>

<p>where <code class="reqn">D</code> is a diagonal matrix with diagonal entries <code class="reqn">d_1, ..., d_K</code>.
The model can then be made identifiable by constraining the scale of
<code class="reqn">\ell_k</code> and <code class="reqn">f_k</code> for <code class="reqn">k = 1, ..., K</code>.
</p>


<h3>Value</h3>

<p>A <code>flash</code> object. Contains elements:
</p>

<dl>
<dt><code>n_factors</code></dt><dd><p>The total number of factor/loadings pairs <code class="reqn">K</code>
in the fitted model.</p>
</dd>
<dt><code>pve</code></dt><dd><p>The proportion of variance explained by each
factor/loadings pair. Since factors and loadings are not required to be
orthogonal, this should be interpreted loosely: for example, the total
proportion of variance explained could be larger than 1.</p>
</dd>
<dt><code>elbo</code></dt><dd><p>The variational lower bound achieved by the
fitted model.</p>
</dd>
<dt><code>residuals_sd</code></dt><dd><p>Estimated residual standard deviations (these
include any variance component given as an argument to <code>S</code>).</p>
</dd>
<dt><code>L_pm, L_psd, L_lfsr</code></dt><dd><p>Posterior means,
standard deviations, and local false sign rates for loadings <code class="reqn">L</code>.</p>
</dd>
<dt><code>F_pm, F_psd, F_lfsr</code></dt><dd><p>Posterior means,
standard deviations, and local false sign rates for factors <code class="reqn">F</code>.</p>
</dd>
<dt><code>L_ghat</code></dt><dd><p>The fitted priors on loadings
<code class="reqn">\hat{g}_\ell^{(k)}</code>.</p>
</dd>
<dt><code>F_ghat</code></dt><dd><p>The fitted priors on factors
<code class="reqn">\hat{g}_f^{(k)}</code>.</p>
</dd>
<dt><code>sampler</code></dt><dd><p>A function that takes a single argument
<code>nsamp</code> and returns <code>nsamp</code> samples from the posterior
distributions for factors <code class="reqn">F</code> and loadings <code class="reqn">L</code>.</p>
</dd>
<dt><code>flash_fit</code></dt><dd><p>A <code><a href="#topic+flash_fit">flash_fit</a></code> object. Used by
<code>flash</code> when fitting is not performed all at once, but
incrementally via calls to various <code>flash_xxx</code> functions.</p>
</dd>
</dl>

<p>The following methods are available:
</p>

<dl>
<dt><code><a href="#topic+fitted.flash">fitted.flash</a></code></dt><dd><p>Returns the &quot;fitted values&quot;
<code class="reqn">E(LF') = E(L) E(F)'</code>.</p>
</dd>
<dt><code><a href="#topic+residuals.flash">residuals.flash</a></code></dt><dd><p>Returns the expected residuals
<code class="reqn">Y - E(LF') = Y - E(L) E(F)'</code>.</p>
</dd>
<dt><code><a href="#topic+ldf.flash">ldf.flash</a></code></dt><dd><p>Returns an <code class="reqn">LDF</code> decomposition (see
<strong>Details</strong> above), with columns of <code class="reqn">L</code> and <code class="reqn">F</code> scaled
as specified by the user.</p>
</dd>
</dl>



<h3>References</h3>

<p>Wei Wang and Matthew Stephens (2021).
&quot;Empirical Bayes matrix factorization.&quot; <em>Journal of Machine Learning
Research</em> 22, 1&ndash;40.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_init">flash_init</a></code>, <code><a href="#topic+flash_greedy">flash_greedy</a></code>,
<code><a href="#topic+flash_backfit">flash_backfit</a></code>, and <code><a href="#topic+flash_nullcheck">flash_nullcheck</a></code>. For more
advanced functionality, see <code><a href="#topic+flash_factors_init">flash_factors_init</a></code>,
<code><a href="#topic+flash_factors_fix">flash_factors_fix</a></code>, <code><a href="#topic+flash_factors_set_to_zero">flash_factors_set_to_zero</a></code>,
<code><a href="#topic+flash_factors_remove">flash_factors_remove</a></code>, <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code>, and
<code><a href="#topic+flash_set_conv_crit">flash_set_conv_crit</a></code>.
For extracting useful data from <code>flash</code> objects, see
<code><a href="#topic+fitted.flash">fitted.flash</a></code>, <code><a href="#topic+residuals.flash">residuals.flash</a></code>, and
<code><a href="#topic+ldf.flash">ldf.flash</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtex)

# Fit up to 3 factors and backfit.
fl &lt;- flash(gtex, greedy_Kmax = 3L, backfit = TRUE)

# This is equivalent to the series of calls:
fl &lt;- flash_init(gtex) %&gt;%
  flash_greedy(Kmax = 3L) %&gt;%
  flash_backfit() %&gt;%
  flash_nullcheck()

# Fit a unimodal distribution with mean zero to each set of loadings
#   and a scale mixture of normals with mean zero to each factor.
fl &lt;- flash(gtex,
            ebnm_fn = c(ebnm_unimodal,
                        ebnm_normal_scale_mixture),
            greedy_Kmax = 3)

# Fit point-laplace priors using a non-default optimization method.
fl &lt;- flash(gtex,
            ebnm_fn = flash_ebnm(prior_family = "point_laplace",
                                 optmethod = "trust"),
            greedy_Kmax = 3)

# Fit a "Kronecker" (rank-one) variance structure (this can be slow).
fl &lt;- flash(gtex, var_type = c(1, 2), greedy_Kmax = 3L)

</code></pre>

<hr>
<h2 id='flash_add_intercept'>Add &quot;intercept&quot; to a flash object</h2><span id='topic+flash_add_intercept'></span>

<h3>Description</h3>

<p>Adds an all-ones vector as a fixed set of loadings (if <code>rowwise = TRUE</code>)
or fixed factor (if <code>rowwise = FALSE</code>). Assuming (without loss of
generality) that the fixed factor/loadings is indexed as <code class="reqn">k = 1</code>,
a fixed set of loadings gives:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_{i \cdot} \approx \mathbf{f}_1 + \sum_{k = 2}^K \ell_{i k}
  \mathbf{f}_k,</code>
</p>

<p>so that the (estimated) factor <code class="reqn">\mathbf{f}_1 \in \mathbf{R}^p</code> is shared
by all row-wise observations <code class="reqn">\mathbf{y}_{i \cdot} \in \mathbf{R}^p</code>.
A fixed factor gives:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_{\cdot j} \approx \boldsymbol{\ell}_1 + \sum_{k = 2}^K f_{j k}
  \boldsymbol{\ell}_k,</code>
</p>

<p>so that the (estimated) set of loadings <code class="reqn">\ell_1 \in \mathbf{R}^n</code> is
shared by all column-wise observations <code class="reqn">y_{\cdot j} \in \mathbf{R}^n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_add_intercept(flash, rowwise = TRUE, ebnm_fn = ebnm_point_normal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_add_intercept_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object to which an &quot;intercept&quot;
is to be added.</p>
</td></tr>
<tr><td><code id="flash_add_intercept_+3A_rowwise">rowwise</code></td>
<td>
<p>Should the all-ones vector be added as a fixed set of loadings
(&quot;row-wise&quot;) or a fixed factor (&quot;column-wise&quot;)? See above for details.</p>
</td></tr>
<tr><td><code id="flash_add_intercept_+3A_ebnm_fn">ebnm_fn</code></td>
<td>
<p>As with other factor/loadings pairs, a prior is put on the
estimated factor (if <code>rowwise = TRUE</code>) or set of loadings (if
<code>rowwise = FALSE</code>). Parameter <code>ebnm_fn</code> specifies the function
used to estimate that prior; see <code><a href="#topic+flash">flash</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated factor (if <code>rowwise = TRUE</code>) or set of loadings
(if <code>rowwise = FALSE</code>) is initialized at the column-
or row-wise means of the data (or, if factor/loadings pairs have previously
been added, at the column- or row-wise means of the matrix of residuals)
and then backfit via function <code><a href="#topic+flash_backfit">flash_backfit</a></code>.
</p>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with an
&quot;intercept&quot; added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following are equivalent:
init &lt;- list(matrix(rowMeans(gtex), ncol = 1),
             matrix(1, nrow = ncol(gtex)))
fl &lt;- flash_init(gtex) %&gt;%
  flash_factors_init(init) %&gt;%
  flash_factors_fix(kset = 1, which_dim = "factors") %&gt;%
  flash_backfit(kset = 1)

fl &lt;- flash_init(gtex) %&gt;%
  flash_add_intercept(rowwise = FALSE)

</code></pre>

<hr>
<h2 id='flash_backfit'>Backfit a flash object</h2><span id='topic+flash_backfit'></span>

<h3>Description</h3>

<p>Backfits existing flash factor/loadings pairs. Whereas a &quot;greedy&quot; fit optimizes
each newly added factor/loadings pair in one go without returning to optimize
previously added pairs, a &quot;backfit&quot; updates all existing pairs in a cyclical
fashion. See <code><a href="#topic+flash">flash</a></code> for examples of usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_backfit(
  flash,
  kset = NULL,
  extrapolate = TRUE,
  warmstart = TRUE,
  maxiter = 500,
  tol = NULL,
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_backfit_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_backfit_+3A_kset">kset</code></td>
<td>
<p>A vector of integers specifying which factors to backfit.
If <code>kset = NULL</code>, then all existing factors will be backfitted.</p>
</td></tr>
<tr><td><code id="flash_backfit_+3A_extrapolate">extrapolate</code></td>
<td>
<p>Whether to use an extrapolation technique
inspired by Ang and Gillis (2019) to accelerate the fitting process.
Control parameters are handled via global options and can be set by
calling <code>options("extrapolate.control") &lt;- control.param</code>.</p>
</td></tr>
<tr><td><code id="flash_backfit_+3A_warmstart">warmstart</code></td>
<td>
<p>Whether to use &quot;warmstarts&quot; when solving the EBNM
subproblems by initializing solutions at the previous value of the fitted
prior <code class="reqn">\hat{g}</code>. An important side effect of warmstarts for
<code>ashr</code>-like prior families is to fix the grid at its initial setting.
Fixing the grid can lead to poor fits if there
are large changes in the scale of the estimated prior over the
course of the fitting process. However, allowing the grid to
vary can occasionally result in decreases in ELBO.</p>
</td></tr>
<tr><td><code id="flash_backfit_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of backfitting iterations. An &quot;iteration&quot;
is defined such that all factors in <code>kset</code> get updated at each
iteration.</p>
</td></tr>
<tr><td><code id="flash_backfit_+3A_tol">tol</code></td>
<td>
<p>The convergence tolerance parameter. After each update, the fit
is compared to the fit from before the update using a convergence
criterion function (by default, the difference in ELBO, but the criterion
can be changed via <code><a href="#topic+flash_set_conv_crit">flash_set_conv_crit</a></code>).
The backfit is considered to have &quot;converged&quot; when the value of the
convergence criterion function over successive updates to
<em>all</em> factor/loadings pairs is less than or equal to <code>tol</code>. If,
for example, factor/loadings pairs <code class="reqn">1, \ldots, K</code> are being
sequentially backfitted, then fits are compared before and
after the update to factor/loadings 1, before and after the update to
factor/loadings 2, and so on through factor/loadings <code class="reqn">K</code>,
and backfitting only terminates when the convergence criterion function
returns a value less
than or equal to <code>tol</code> for all <code class="reqn">K</code> updates. Note that
specifying <code>tol</code> here will override any value set by
<code>flash_set_conv_crit</code>; to use the &quot;global&quot; tolerance parameter,
<code>tol</code> must be left unspecified (<code>NULL</code>).
If <code>tol = NULL</code> and a global tolerance
parameter has not been set, then the default
tolerance used is <code class="reqn">np\sqrt{\epsilon}</code>, where <code class="reqn">n</code> is the
number of rows in the dataset, <code class="reqn">p</code> is the number of columns, and
<code class="reqn">\epsilon</code> is equal to <code><a href="base.html#topic+.Machine">.Machine</a>$double.eps</code>.</p>
</td></tr>
<tr><td><code id="flash_backfit_+3A_verbose">verbose</code></td>
<td>
<p>When and how to display progress updates. Set to
<code>0</code> for none, <code>1</code> for updates after a factor is added or a
backfit is completed, <code>2</code> for additional notifications about the
variational lower bound, and <code>3</code> for updates after every iteration.
It is also possible to output a single tab-delimited table of values
using function <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> with <code>verbose = -1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, backfitted
as specified.
</p>

<hr>
<h2 id='flash_clear_timeout'>Set timeout</h2><span id='topic+flash_clear_timeout'></span>

<h3>Description</h3>

<p>Used in a <code><a href="#topic+flash">flash</a></code> pipeline to clear timeout conditions set using
<code><a href="#topic+flash_set_timeout">flash_set_timeout</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_clear_timeout(flash)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_clear_timeout_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with
timeout settings cleared.
</p>

<hr>
<h2 id='flash_conv_crit_elbo_diff'>Calculate the difference in ELBO</h2><span id='topic+flash_conv_crit_elbo_diff'></span>

<h3>Description</h3>

<p>The default objective function used to determine convergence when fitting
a <code><a href="#topic+flash">flash</a></code> object. Calculates the difference in the
variational lower bound (&quot;ELBO&quot;) from one iteration to the next.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_conv_crit_elbo_diff(curr, prev, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_conv_crit_elbo_diff_+3A_curr">curr</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration.</p>
</td></tr>
<tr><td><code id="flash_conv_crit_elbo_diff_+3A_prev">prev</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the previous iteration.</p>
</td></tr>
<tr><td><code id="flash_conv_crit_elbo_diff_+3A_k">k</code></td>
<td>
<p>Only used during sequential backfits (that is, calls to
<code><a href="#topic+flash_backfit">flash_backfit</a></code> where <code>extrapolate = FALSE</code>). It then
takes the index of the factor/loadings pair currently being optimized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an example of a function that may be passed to
parameter <code>fn</code> in function <code><a href="#topic+flash_set_conv_crit">flash_set_conv_crit</a></code> to set
the convergence criterion for a flash pipeline. See
<code><a href="#topic+flash_set_conv_crit">flash_set_conv_crit</a></code> for details and examples.
</p>


<h3>Value</h3>

<p>A scalar, which is compared against the tolerance parameter
<code>tol</code> to determine whether a fit has converged.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_conv_crit_max_chg">flash_conv_crit_max_chg</a></code>
<code><a href="#topic+flash_conv_crit_max_chg_L">flash_conv_crit_max_chg_L</a></code>,
<code><a href="#topic+flash_conv_crit_max_chg_F">flash_conv_crit_max_chg_F</a></code>
</p>

<hr>
<h2 id='flash_conv_crit_max_chg'>Calculate the maximum absolute difference in scaled loadings and factors</h2><span id='topic+flash_conv_crit_max_chg'></span>

<h3>Description</h3>

<p>An alternative objective function that can be used to determine
convergence when fitting a <code><a href="#topic+flash">flash</a></code> object. Calculates the
maximum (absolute) change over all (posterior expected values for)
loadings <code class="reqn">\ell_{ik}</code> and factors <code class="reqn">f_{jk}</code>. At each iteration, the
loadings vectors <code class="reqn">\ell_{\cdot 1}, \ldots, \ell_{\cdot K}</code> and factors
<code class="reqn">f_{\cdot 1}, \ldots, f_{\cdot K}</code> are <code class="reqn">L^2</code>-normalized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_conv_crit_max_chg(curr, prev, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_conv_crit_max_chg_+3A_curr">curr</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration.</p>
</td></tr>
<tr><td><code id="flash_conv_crit_max_chg_+3A_prev">prev</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the previous iteration.</p>
</td></tr>
<tr><td><code id="flash_conv_crit_max_chg_+3A_k">k</code></td>
<td>
<p>Only used during sequential backfits (that is, calls to
<code><a href="#topic+flash_backfit">flash_backfit</a></code> where <code>extrapolate = FALSE</code>). It then
takes the index of the factor/loadings pair currently being optimized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, which is compared against the tolerance parameter
<code>tol</code> to determine whether a fit has converged.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_conv_crit_elbo_diff">flash_conv_crit_elbo_diff</a></code>,
<code><a href="#topic+flash_conv_crit_max_chg_L">flash_conv_crit_max_chg_L</a></code>
<code><a href="#topic+flash_conv_crit_max_chg_F">flash_conv_crit_max_chg_F</a></code>
</p>

<hr>
<h2 id='flash_conv_crit_max_chg_F'>Calculate the maximum absolute difference in scaled factors</h2><span id='topic+flash_conv_crit_max_chg_F'></span>

<h3>Description</h3>

<p>An alternative objective function that can be used to determine
convergence when fitting a <code><a href="#topic+flash">flash</a></code> object. Calculates the
maximum (absolute) change over all (posterior expected values for)
factors <code class="reqn">f_{jk}</code>. At each iteration, the factors
<code class="reqn">f_{\cdot 1}, \ldots, f_{\cdot K}</code> are <code class="reqn">L^2</code>-normalized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_conv_crit_max_chg_F(curr, prev, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_conv_crit_max_chg_F_+3A_curr">curr</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration.</p>
</td></tr>
<tr><td><code id="flash_conv_crit_max_chg_F_+3A_prev">prev</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the previous iteration.</p>
</td></tr>
<tr><td><code id="flash_conv_crit_max_chg_F_+3A_k">k</code></td>
<td>
<p>Only used during sequential backfits (that is, calls to
<code><a href="#topic+flash_backfit">flash_backfit</a></code> where <code>extrapolate = FALSE</code>). It then
takes the index of the factor/loadings pair currently being optimized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, which is compared against the tolerance parameter
<code>tol</code> to determine whether a fit has converged.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_conv_crit_elbo_diff">flash_conv_crit_elbo_diff</a></code>,
<code><a href="#topic+flash_conv_crit_max_chg">flash_conv_crit_max_chg</a></code>
<code><a href="#topic+flash_conv_crit_max_chg_L">flash_conv_crit_max_chg_L</a></code>
</p>

<hr>
<h2 id='flash_conv_crit_max_chg_L'>Calculate the maximum absolute difference in scaled loadings</h2><span id='topic+flash_conv_crit_max_chg_L'></span>

<h3>Description</h3>

<p>An alternative objective function that can be used to determine
convergence when fitting a <code><a href="#topic+flash">flash</a></code> object. Calculates the
maximum (absolute) change over all (posterior expected values for)
loadings <code class="reqn">\ell_{ik}</code>. At each iteration, the loadings vectors
<code class="reqn">\ell_{\cdot 1}, \ldots, \ell_{\cdot K}</code> are <code class="reqn">L^2</code>-normalized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_conv_crit_max_chg_L(curr, prev, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_conv_crit_max_chg_L_+3A_curr">curr</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration.</p>
</td></tr>
<tr><td><code id="flash_conv_crit_max_chg_L_+3A_prev">prev</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the previous iteration.</p>
</td></tr>
<tr><td><code id="flash_conv_crit_max_chg_L_+3A_k">k</code></td>
<td>
<p>Only used during sequential backfits (that is, calls to
<code><a href="#topic+flash_backfit">flash_backfit</a></code> where <code>extrapolate = FALSE</code>). It then
takes the index of the factor/loadings pair currently being optimized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, which is compared against the tolerance parameter
<code>tol</code> to determine whether a fit has converged.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_conv_crit_elbo_diff">flash_conv_crit_elbo_diff</a></code>,
<code><a href="#topic+flash_conv_crit_max_chg">flash_conv_crit_max_chg</a></code>
<code><a href="#topic+flash_conv_crit_max_chg_F">flash_conv_crit_max_chg_F</a></code>
</p>

<hr>
<h2 id='flash_ebnm'>Construct an EBNM function</h2><span id='topic+flash_ebnm'></span>

<h3>Description</h3>

<p><code>flash_ebnm</code> is a helper function that provides readable syntax for
constructing <code><a href="ebnm.html#topic+ebnm">ebnm</a></code> functions that can serve as
arguments to parameter <code>ebnm_fn</code> in functions <code><a href="#topic+flash">flash</a></code>,
<code><a href="#topic+flash_greedy">flash_greedy</a></code>, and <code><a href="#topic+flash_factors_init">flash_factors_init</a></code> (see
<strong>Examples</strong> below). It is also possible to write a custom function
from scratch: see <strong>Details</strong> below for a simple example. A more
involved example can be found in the &quot;Advanced flashier&quot; vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_ebnm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_ebnm_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to function <code><a href="ebnm.html#topic+ebnm">ebnm</a></code>
in package <code>ebnm</code>. An argument to <code>prior_family</code> should be
provided unless the default family of point-normal priors is desired.
Arguments to parameters <code>x</code>, <code>s</code>, or <code>output</code> must not be
included. Finally, if <code>g_init</code> is included, then <code>fix_g = TRUE</code>
must be as well. To fix a prior grid, use parameter <code>scale</code> rather
than <code>g_init</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As input to parameter <code>ebnm_fn</code> in functions <code><a href="#topic+flash">flash</a></code>,
<code><a href="#topic+flash_greedy">flash_greedy</a></code>, and <code><a href="#topic+flash_factors_init">flash_factors_init</a></code>,
it should suffice for many purposes to
provide functions from package <code>ebnm</code> as is (for example, one might
set <code>ebnm_fn = ebnm_point_laplace</code>). To use non-default
arguments, function <code>flash_ebnm</code> may be used (see <strong>Examples</strong>).
Custom functions may also be written. In general, any function that is
used as an argument to <code>ebnm_fn</code> must accept parameters:
</p>

<dl>
<dt><code>x</code></dt><dd><p>A vector of observations.</p>
</dd>
<dt><code>s</code></dt><dd><p>A vector of standard errors, or a scalar if all standard
errors are equal.</p>
</dd>
<dt><code>g_init</code></dt><dd><p>The prior <code class="reqn">g</code>. Usually, this is left unspecified
(<code>NULL</code>) and estimated from the data. If it is supplied and
<code>fix_g = TRUE</code>, then the prior is fixed at <code>g_init</code>; if
<code>fix_g = FALSE</code>, then <code>g_init</code> gives the
initial value of <code class="reqn">g</code> used during optimization.
</p>
<p>In <code>flashier</code>,
<code class="reqn">g</code> is fixed during the wrap-up phase when estimating local false
sign rates and constructing a sampler; and <code>g_init</code> is used
with <code>fix_g = FALSE</code> to &quot;warmstart&quot; backfits
(see <code><a href="#topic+flash_backfit">flash_backfit</a></code>). If none of these features (local
false sign rates, samplers, or warmstarts) are needed,
then both <code>g_init</code> and <code>fix_g</code> can be ignored (the EBNM
function must still accept them as parameters, but it need not do
anything with their arguments).</p>
</dd>
<dt><code>fix_g</code></dt><dd><p>If <code>TRUE</code>, the prior is fixed at <code>g_init</code>
instead of estimated. See the description of <code>g_init</code> above.</p>
</dd>
<dt><code>output</code></dt><dd><p>A character vector indicating which values are to be
returned. Custom EBNM functions can safely ignore this parameter (again,
they must accept it as a parameter, but they do not need to do anything
with its argument).</p>
</dd>
</dl>

<p>The return object must be a list that includes fields:
</p>

<dl>
<dt><code>posterior</code></dt><dd><p>A data frame that includes columns <code>mean</code>
and <code>second_moment</code> (the first and second moments for each
posterior distribution
<code class="reqn">p(\theta_i \mid s_i, \hat{g}), i = 1, ..., n</code>). Optionally,
a column <code>lfsr</code> giving local false sign rates may also be
included.</p>
</dd>
<dt><code>fitted_g</code></dt><dd><p>The estimated prior <code class="reqn">\hat{g}</code>. Within
<code>flashier</code>, <code>fitted_g</code> is only ever used as an argument to
<code>g_init</code> in subsequent calls to the same EBNM function, so the
manner in which it is represented is unimportant.</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>The optimal log likelihood
<code class="reqn">L(\hat{g}) := \sum_i \log p(x_i \mid \hat{g}, s_i)</code>.</p>
</dd>
<dt><code>posterior_sampler</code></dt><dd><p>An optional field containing a function
that samples from the posterior distributions of the &quot;means&quot;
<code class="reqn">\theta_i</code>. If included, the function should take a single parameter
<code>nsamp</code> and return a matrix where rows correspond to samples and
columns correspond to observations (that is, there should be
<code>nsamp</code> rows and <code class="reqn">n</code> columns).</p>
</dd>
</dl>



<h3>Value</h3>

<p>A function that can be passed as argument to parameter
<code>ebnm_fn</code> in functions <code><a href="#topic+flash">flash</a></code>,
<code><a href="#topic+flash_greedy">flash_greedy</a></code>, and <code><a href="#topic+flash_factors_init">flash_factors_init</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="ebnm.html#topic+ebnm">ebnm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A custom EBNM function might be written as follows:
my_ebnm_fn &lt;- function(x, s, g_init, fix_g, output) {
  ebnm_res &lt;- ebnm_point_laplace(
    x = x,
    s = s,
    g_init = g_init,
    fix_g = fix_g,
    output = output,
    control = list(iterlim = 10)
  )
  return(ebnm_res)
}

# The following are equivalent:
fl1 &lt;- flash(
  gtex,
  ebnm_fn = my_ebnm_fn,
  greedy_Kmax = 2
)
fl2 &lt;- flash(
  gtex,
  ebnm_fn = flash_ebnm(
    prior_family = "point_laplace",
    control = list(iterlim = 10)
  ),
  greedy_Kmax = 2
)

</code></pre>

<hr>
<h2 id='flash_factors_fix'>Fix flash factors</h2><span id='topic+flash_factors_fix'></span>

<h3>Description</h3>

<p>Fixes loadings <code class="reqn">\ell_{\cdot k}</code> or factors <code class="reqn">f_{\cdot k}</code>
for one or more factor/loadings pairs, so that their values are not
updated during subsequent backfits. For a given pair, either the loadings
or factor can be fixed, but not both, and either all entries or a subset
can be fixed. To unfix, use function <code><a href="#topic+flash_factors_unfix">flash_factors_unfix</a></code>. See
<code><a href="#topic+flash_factors_init">flash_factors_init</a></code> for an example of usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_factors_fix(
  flash,
  kset,
  which_dim = c("factors", "loadings"),
  fixed_idx = NULL,
  use_fixed_in_ebnm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_factors_fix_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_factors_fix_+3A_kset">kset</code></td>
<td>
<p>A vector of integers indexing the factor/loadings pairs whose
loadings or factors are to be fixed.</p>
</td></tr>
<tr><td><code id="flash_factors_fix_+3A_which_dim">which_dim</code></td>
<td>
<p>Whether to fix factors or loadings.</p>
</td></tr>
<tr><td><code id="flash_factors_fix_+3A_fixed_idx">fixed_idx</code></td>
<td>
<p>If <code>fixed_idx = NULL</code>, then all loadings or factor
values will be fixed. If only a subset are to be fixed,
then <code>fixed_idx</code> should be an appropriately-sized vector or
matrix of values that can be coerced to logical. For example, if
a subset of loadings for two factor/loadings pairs are to be fixed, then
<code>fixed_idx</code> should be a length-<code class="reqn">n</code> vector or an <code class="reqn">n</code> by 2
matrix (where <code class="reqn">n</code> is the number of rows in the data matrix).</p>
</td></tr>
<tr><td><code id="flash_factors_fix_+3A_use_fixed_in_ebnm">use_fixed_in_ebnm</code></td>
<td>
<p>By default, fixed elements are ignored when
solving the EBNM subproblem in order to estimate the prior <code class="reqn">\hat{g}</code>.
This behavior can be changed by setting <code>use_fixed_in_ebnm = TRUE</code>.
This is a global setting which applies to all factor/loadings pairs;
behavior cannot vary from one factor/loadings pair to another.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with
factors or loadings fixed as specified.
</p>

<hr>
<h2 id='flash_factors_init'>Initialize flash factors at specified values</h2><span id='topic+flash_factors_init'></span>

<h3>Description</h3>

<p>Initializes factor/loadings pairs at values specified by <code>init</code>. This
function has two primary uses: 1. One can initialize multiple
factor/loadings pairs at once using an SVD-like function and then optimize
them via function <code><a href="#topic+flash_backfit">flash_backfit</a></code>. Sometimes this results in
a better fit than adding them one at a time via
<code><a href="#topic+flash_greedy">flash_greedy</a></code>. 2. One can initialize factor/loadings pairs
and then fix the factor (or loadings) via function
<code><a href="#topic+flash_factors_fix">flash_factors_fix</a></code> to incorporate &quot;known&quot; factors into a
<code><a href="#topic+flash">flash</a></code> object. See below for examples of both use cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_factors_init(flash, init, ebnm_fn = ebnm_point_normal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_factors_init_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object to which factors are
to be added.</p>
</td></tr>
<tr><td><code id="flash_factors_init_+3A_init">init</code></td>
<td>
<p>An SVD-like object (specifically, a list containing fields
<code>u</code>, <code>d</code>, and <code>v</code>), a <code>flash</code> or <code>flash_fit</code>
object, or a list of matrices specifying the values at which factors
and loadings are to be initialized (for a data
matrix of size <code class="reqn">n \times p</code>, this should be a list of length two,
with the first element a matrix of size <code class="reqn">n \times k</code> and the second
a matrix of size <code class="reqn">p \times k</code>). If a flash fit is supplied, then it
will be used to initialize both the first and second moments of
posteriors on loadings and factors. Otherwise, the supplied values will
be used to initialize posterior means, with posterior second moments
initialized as the squared values of the first moments. Missing entries
are not allowed.</p>
</td></tr>
<tr><td><code id="flash_factors_init_+3A_ebnm_fn">ebnm_fn</code></td>
<td>
<p>The function or functions used to solve the empirical Bayes
normal means (EBNM) subproblems. Most importantly, these functions specify
the families of distributions <code class="reqn">G_\ell^{(k)}</code> and <code class="reqn">G_f^{(k)}</code> to which the
priors on loadings and factors <code class="reqn">g_\ell^{(k)}</code> and <code class="reqn">g_f^{(k)}</code> are
assumed to belong. If the same function is to be used for both loadings
<code class="reqn">L</code> and factors <code class="reqn">F</code>, then <code>ebnm_fn</code> can be a single function.
If one function is to be used for loadings and a second for factors,
then <code>ebnm_fn</code> should be a list of length two, with the first
element giving the function for loadings and the second the function
for factors. If different functions are to be used for different values of
<code class="reqn">k</code>, then factor/loadings pairs must be added successively using
multiple calls to either <code><a href="#topic+flash_greedy">flash_greedy</a></code> or
<code><a href="#topic+flash_factors_init">flash_factors_init</a></code>.
</p>
<p>Any EBNM function provided by package <code><a href="ebnm.html#topic+ebnm">ebnm</a></code> can be
used as input. Non-default arguments to parameters can be supplied using
the helper function <code><a href="#topic+flash_ebnm">flash_ebnm</a></code>. Custom EBNM functions can
also be used: for details, see <code><a href="#topic+flash_ebnm">flash_ebnm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with
factors and loadings initialized as specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Initialize several factors at once and backfit.
fl &lt;- flash_init(gtex) %&gt;%
  flash_factors_init(init = svd(gtex, nu = 5, nv = 5)) %&gt;%
  flash_backfit()

# Add fixed loadings with \ell_i identically equal to one. This can be
#   interpreted as giving a "mean" factor that accounts for different
#   row-wise means.
ones &lt;- matrix(1, nrow = nrow(gtex), ncol = 1)
# Initialize the factor at the least squares solution.
ls_soln &lt;- t(solve(crossprod(ones), crossprod(ones, gtex)))
fl &lt;- flash_init(gtex) %&gt;%
  flash_factors_init(init = list(ones, ls_soln)) %&gt;%
  flash_factors_fix(kset = 1, which_dim = "loadings") %&gt;%
  flash_backfit() %&gt;%
  flash_greedy(Kmax = 5L)

</code></pre>

<hr>
<h2 id='flash_factors_remove'>Remove factors from a flash object</h2><span id='topic+flash_factors_remove'></span>

<h3>Description</h3>

<p>Sets factor/loadings pairs to zero and then removes them from the
<code><a href="#topic+flash">flash</a></code> object. Note that this will change the indices of
existing pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_factors_remove(flash, kset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_factors_remove_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_factors_remove_+3A_kset">kset</code></td>
<td>
<p>A vector of integers specifying which factor/loadings pairs to
remove.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with the
factors specified by <code>kset</code> removed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_factors_set_to_zero">flash_factors_set_to_zero</a></code>
</p>

<hr>
<h2 id='flash_factors_reorder'>Reorder factors in a flash object</h2><span id='topic+flash_factors_reorder'></span>

<h3>Description</h3>

<p>Reorders the factor/loadings pairs in a <code><a href="#topic+flash">flash</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_factors_reorder(flash, kset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_factors_reorder_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_factors_reorder_+3A_kset">kset</code></td>
<td>
<p>A vector of integers specifying the new order of the
factor/loadings pairs. All existing factors must be included in
<code>kset</code>; to drop factors, use <code><a href="#topic+flash_factors_remove">flash_factors_remove</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with the
factors reordered according to argument <code>kset</code>.
</p>

<hr>
<h2 id='flash_factors_set_to_zero'>Set flash factors to zero</h2><span id='topic+flash_factors_set_to_zero'></span>

<h3>Description</h3>

<p>Sets factor/loadings pairs to zero but does not remove them from the
<code><a href="#topic+flash">flash</a></code> object (so as to keep the indices of existing pairs
the same).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_factors_set_to_zero(flash, kset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_factors_set_to_zero_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_factors_set_to_zero_+3A_kset">kset</code></td>
<td>
<p>A vector of integers specifying which factor/loadings pairs to
set to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with the
factors specified by <code>kset</code> set to zero.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_factors_remove">flash_factors_remove</a></code>
</p>

<hr>
<h2 id='flash_factors_unfix'>Unfix flash factors</h2><span id='topic+flash_factors_unfix'></span>

<h3>Description</h3>

<p>If loadings <code class="reqn">\ell_{\cdot k}</code> or factors <code class="reqn">f_{\cdot k}</code> for one or
more factor/loadings pairs have been &quot;fixed&quot; using function
<code><a href="#topic+flash_factors_fix">flash_factors_fix</a></code>, then they can be unfixed using
function <code>flash_factors_unfix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_factors_unfix(flash, kset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_factors_unfix_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_factors_unfix_+3A_kset">kset</code></td>
<td>
<p>A vector of integers indexing the factor/loadings pairs whose
values are to be unfixed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with
values for the factor/loadings pairs specified by <code>kset</code> unfixed.
</p>

<hr>
<h2 id='flash_fit'>Extract a flash_fit object</h2><span id='topic+flash_fit'></span><span id='topic+flash_fit_get_pm'></span><span id='topic+flash_fit_get_p2m'></span><span id='topic+flash_fit_get_est_tau'></span><span id='topic+flash_fit_get_fixed_tau'></span><span id='topic+flash_fit_get_tau'></span><span id='topic+flash_fit_get_elbo'></span><span id='topic+flash_fit_get_KL'></span><span id='topic+flash_fit_get_g'></span>

<h3>Description</h3>

<p><code>flash_fit</code> objects are the &quot;internal&quot; objects used by <code>flash</code>
functions to fit an EBMF model. Whereas <code>flash</code> objects
(the end results of the fitting process) include user-friendly fields and
methods, <code>flash_fit</code> objects were not designed for public
consumption and can be unwieldy. Nonetheless, some advanced
<code>flash</code> functionality requires the wielding of
<code>flash_fit</code> objects. In particular, initialization, convergence,
and &quot;verbose&quot; display functions all take one or more <code>flash_fit</code>
objects as input (see parameter <code>init_fn</code> in function
<code><a href="#topic+flash_greedy">flash_greedy</a></code>; parameter <code>fn</code> in
<code><a href="#topic+flash_set_conv_crit">flash_set_conv_crit</a></code>;
and parameter <code>fns</code> in <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code>).
For users who would like to write custom functions, the accessor functions
and methods enumerated below may prove useful. See
<code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> for an example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_fit(flash)

flash_fit_get_pm(f, n)

flash_fit_get_p2m(f, n)

flash_fit_get_est_tau(f)

flash_fit_get_fixed_tau(f)

flash_fit_get_tau(f)

flash_fit_get_elbo(f)

flash_fit_get_KL(f, n)

flash_fit_get_g(f, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_fit_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> object.</p>
</td></tr>
<tr><td><code id="flash_fit_+3A_f">f</code></td>
<td>
<p>A <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_fit_+3A_n">n</code></td>
<td>
<p>Set <code>n = 1</code> to access loadings <code class="reqn">L</code> and <code>n = 2</code> to
access factors <code class="reqn">F</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following S3 methods are available for <code>flash_fit</code> objects at all
times except while optimizing new factor/loadings pairs as part of a
&quot;greedy&quot; fit:
</p>

<dl>
<dt><code><a href="#topic+fitted.flash_fit">fitted.flash_fit</a></code></dt><dd><p>Returns the &quot;fitted values&quot;
<code class="reqn">E(LF') = E(L) E(F)'</code>.</p>
</dd>
<dt><code><a href="#topic+residuals.flash_fit">residuals.flash_fit</a></code></dt><dd><p>Returns the expected residuals
<code class="reqn">Y - E(LF') = Y - E(L) E(F)'</code>.</p>
</dd>
<dt><code><a href="#topic+ldf.flash_fit">ldf.flash_fit</a></code></dt><dd><p>Returns an <code class="reqn">LDF</code> decomposition,
with columns of <code class="reqn">L</code> and <code class="reqn">F</code> scaled as specified by the user.</p>
</dd>
</dl>



<h3>Value</h3>

<p>See function descriptions below.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>flash_fit_get_pm()</code>: The posterior means for the loadings matrix <code class="reqn">L</code>
(when parameter <code>n</code> is equal to <code>1</code>) or factor matrix <code class="reqn">F</code>
(when <code>n = 2</code>). While optimizing new factor/loadings pairs as part of
a &quot;greedy&quot; fit, only the posterior means for the new loadings
<code class="reqn">\ell_{\cdot k}</code> or factor <code class="reqn">f_{\cdot k}</code> will be returned.
</p>
</li>
<li> <p><code>flash_fit_get_p2m()</code>: The posterior second moments for the loadings matrix
<code class="reqn">L</code> (when parameter <code>n</code> is equal to <code>1</code>) or factor matrix
<code class="reqn">F</code> (when <code>n = 2</code>). While optimizing new factor/loadings pairs,
only the posterior second moments for the new loadings <code class="reqn">\ell_{\cdot k}</code>
or factor <code class="reqn">f_{\cdot k}</code> will be returned.
</p>
</li>
<li> <p><code>flash_fit_get_est_tau()</code>: Equal to <code class="reqn">1 / \sigma^2</code>, where <code class="reqn">\sigma^2</code>
is the estimated portion of the residual variance (total, by row, or
by column, depending on the variance type).
</p>
</li>
<li> <p><code>flash_fit_get_fixed_tau()</code>: Equal to <code class="reqn">1 / s^2</code>, where <code class="reqn">s^2</code> is the
fixed portion of the residual variance (total, by row, or by column).
</p>
</li>
<li> <p><code>flash_fit_get_tau()</code>: The overall precision <code class="reqn">1 / (\sigma^2 + s^2)</code>.
</p>
</li>
<li> <p><code>flash_fit_get_elbo()</code>: The variational lower bound (ELBO).
</p>
</li>
<li> <p><code>flash_fit_get_KL()</code>: A vector containing the KL-divergence portions of
the ELBO, with one value for each factor (when <code>n = 2</code>) or set of
loadings (when <code>n = 1</code>). While optimizing new factor/loadings pairs,
only the KL-divergence for the new factor or loadings will be returned.
</p>
</li>
<li> <p><code>flash_fit_get_g()</code>: A list containing estimated priors on loadings
<code class="reqn">\hat{g}_\ell</code> (when <code>n = 1</code>) or factors <code class="reqn">\hat{g}_f</code> (when
<code>n = 2</code>). While optimizing new factor/loadings pairs, only the
estimated prior on the new factor or loadings will be returned.
</p>
</li></ul>

<hr>
<h2 id='flash_greedy'>Greedily add factors to a flash object</h2><span id='topic+flash_greedy'></span>

<h3>Description</h3>

<p>Adds factor/loadings pairs to a flash object in a &quot;greedy&quot; manner. Up to
<code>Kmax</code> pairs are added one at a time. At each step, <code>flash_greedy</code>
attempts to find an optimal additional (rank-one) factor given all
previously added factors. The additional factor is retained if it
increases the variational lower bound (ELBO); otherwise, fitting terminates.
See <code><a href="#topic+flash">flash</a></code> for examples of usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_greedy(
  flash,
  Kmax = 1,
  ebnm_fn = ebnm_point_normal,
  init_fn = NULL,
  extrapolate = FALSE,
  warmstart = FALSE,
  maxiter = 500,
  tol = NULL,
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_greedy_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object to which factors are
to be added.</p>
</td></tr>
<tr><td><code id="flash_greedy_+3A_kmax">Kmax</code></td>
<td>
<p>The maximum number of factors to be added. This will not
necessarily be the total number of factors added by
<code>flash_greedy</code>, since factors are only added as long as they
increase the ELBO.</p>
</td></tr>
<tr><td><code id="flash_greedy_+3A_ebnm_fn">ebnm_fn</code></td>
<td>
<p>The function or functions used to solve the empirical Bayes
normal means (EBNM) subproblems. Most importantly, these functions specify
the families of distributions <code class="reqn">G_\ell^{(k)}</code> and <code class="reqn">G_f^{(k)}</code> to which the
priors on loadings and factors <code class="reqn">g_\ell^{(k)}</code> and <code class="reqn">g_f^{(k)}</code> are
assumed to belong. If the same function is to be used for both loadings
<code class="reqn">L</code> and factors <code class="reqn">F</code>, then <code>ebnm_fn</code> can be a single function.
If one function is to be used for loadings and a second for factors,
then <code>ebnm_fn</code> should be a list of length two, with the first
element giving the function for loadings and the second the function
for factors. If different functions are to be used for different values of
<code class="reqn">k</code>, then factor/loadings pairs must be added successively using
multiple calls to either <code><a href="#topic+flash_greedy">flash_greedy</a></code> or
<code><a href="#topic+flash_factors_init">flash_factors_init</a></code>.
</p>
<p>Any EBNM function provided by package <code><a href="ebnm.html#topic+ebnm">ebnm</a></code> can be
used as input. Non-default arguments to parameters can be supplied using
the helper function <code><a href="#topic+flash_ebnm">flash_ebnm</a></code>. Custom EBNM functions can
also be used: for details, see <code><a href="#topic+flash_ebnm">flash_ebnm</a></code>.</p>
</td></tr>
<tr><td><code id="flash_greedy_+3A_init_fn">init_fn</code></td>
<td>
<p>The function used to initialize factor/loadings pairs. Functions
<code><a href="#topic+flash_greedy_init_default">flash_greedy_init_default</a></code>, <code><a href="#topic+flash_greedy_init_softImpute">flash_greedy_init_softImpute</a></code>, and
<code><a href="#topic+flash_greedy_init_irlba">flash_greedy_init_irlba</a></code> have been supplied; note, in particular, that
<code><a href="#topic+flash_greedy_init_softImpute">flash_greedy_init_softImpute</a></code> can yield better results than the
default initialization function when there is missing data. Custom
initialization functions may also be used. If <code>init_fn = NULL</code> then
<code><a href="#topic+flash_greedy_init_default">flash_greedy_init_default</a></code> will be used, with an attempt made to set
argument <code>sign_constraints</code> appropriately via test calls to
the EBNM function(s) specified by parameter <code>ebnm_fn</code>. If factors or loadings
are constrained in some other fashion (e.g., bounded support), then the
initialization function should be modified to account for the constraints
&mdash; otherwise, the greedy algorithm can stop adding factor/loadings pairs
too early. Custom initialization functions should accept a single
parameter referring to a <code><a href="#topic+flash_fit">flash_fit</a></code> object and should output
a list consisting of two vectors, which will be used as initial values for
the new loadings <code class="reqn">\ell_{\cdot k}</code> and the new factor <code class="reqn">f_{\cdot k}</code>. Typically,
a custom initialization function will extract the matrix of residuals from
the <code>flash_fit</code> object using method <code>residuals.flash_fit</code> and
then return a (possibly constrained) rank-one approximation to the matrix
of residuals. See <strong>Examples</strong> below.</p>
</td></tr>
<tr><td><code id="flash_greedy_+3A_extrapolate">extrapolate</code></td>
<td>
<p>Whether to use an extrapolation technique
inspired by Ang and Gillis (2019) to accelerate the fitting process.
Control parameters are handled via global options and can be set by
calling <code>options("extrapolate.control") &lt;- control.param</code>.</p>
</td></tr>
<tr><td><code id="flash_greedy_+3A_warmstart">warmstart</code></td>
<td>
<p>Whether to use &quot;warmstarts&quot; when solving the EBNM
subproblems by initializing solutions at the previous value of the fitted
prior <code class="reqn">\hat{g}</code>. An important side effect of warmstarts for
<code>ashr</code>-like prior families is to fix the grid at its initial setting.
Fixing the grid can lead to poor fits if there
are large changes in the scale of the estimated prior over the
course of the fitting process. However, allowing the grid to
vary can occasionally result in decreases in ELBO.</p>
</td></tr>
<tr><td><code id="flash_greedy_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations when optimizing a greedily
added factor/loadings pair.</p>
</td></tr>
<tr><td><code id="flash_greedy_+3A_tol">tol</code></td>
<td>
<p>The convergence tolerance parameter. At each iteration, the fit
is compared to the fit from the previous iteration using a convergence
criterion function (by default, the difference in ELBO, but the criterion
can be changed via <code><a href="#topic+flash_set_conv_crit">flash_set_conv_crit</a></code>). When
the value returned by this function is less than or equal to <code>tol</code>,
the newly added factor/loadings pair is considered to have &quot;converged,&quot;
so that <code>flash_greedy</code> moves on and attempts to add another new
factor (or, if the maximum number of factors <code>Kmax</code> has been reached,
the process terminates). Note that
specifying <code>tol</code> here will override any value set by
<code>flash_set_conv_crit</code>; to use the &quot;global&quot; tolerance parameter,
<code>tol</code> must be left unspecified (<code>NULL</code>).
If <code>tol = NULL</code> and a global tolerance
parameter has not been set, then the default
tolerance used is <code class="reqn">np\sqrt{\epsilon}</code>, where <code class="reqn">n</code> is the
number of rows in the dataset, <code class="reqn">p</code> is the number of columns, and
<code class="reqn">\epsilon</code> is equal to <code><a href="base.html#topic+.Machine">.Machine</a>$double.eps</code>.</p>
</td></tr>
<tr><td><code id="flash_greedy_+3A_verbose">verbose</code></td>
<td>
<p>When and how to display progress updates. Set to
<code>0</code> for none, <code>1</code> for updates after a factor is added or a
backfit is completed, <code>2</code> for additional notifications about the
variational lower bound, and <code>3</code> for updates after every iteration.
It is also possible to output a single tab-delimited table of values
using function <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> with <code>verbose = -1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with up
to <code>Kmax</code> new factor/loadings pairs &quot;greedily&quot; added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_greedy_init_default">flash_greedy_init_default</a></code>,
<code><a href="#topic+flash_greedy_init_softImpute">flash_greedy_init_softImpute</a></code>,
<code><a href="#topic+flash_greedy_init_irlba">flash_greedy_init_irlba</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following are examples of advanced usage. See ?flash for basic usage.

# Increase the maximum number of iterations in the default initialization
#   method.
my_init_fn &lt;- function(f) flash_greedy_init_default(f, maxiter = 500)
fl &lt;- flash_init(gtex) %&gt;%
  flash_greedy(init_fn = my_init_fn)

# Use a custom initialization function that wraps function nmf from
#   package RcppML.
nmf_init_fn &lt;- function(f) {
  nmf_res &lt;- RcppML::nmf(resid(f), k = 1, verbose = FALSE)
  return(list(as.vector(nmf_res$w), as.vector(nmf_res$h)))
}
fl.nmf &lt;- flash_init(gtex) %&gt;%
  flash_greedy(ebnm_fn = ebnm_unimodal_nonnegative,
               init_fn = nmf_init_fn)

</code></pre>

<hr>
<h2 id='flash_greedy_init_default'>Initialize a flash factor</h2><span id='topic+flash_greedy_init_default'></span>

<h3>Description</h3>

<p>The default method for initializing the loadings <code class="reqn">\ell_{\cdot k}</code> and
factor values <code class="reqn">f_{\cdot k}</code> of a new (&quot;greedy&quot;) flash factor. It is
essentially an implementation of the power method, but unlike many existing
implementations, it can handle missing data and sign constraints. For details,
see Chapter 2.2.3 in the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_greedy_init_default(
  flash,
  sign_constraints = NULL,
  tol = NULL,
  maxiter = 100,
  seed = 666
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_greedy_init_default_+3A_flash">flash</code></td>
<td>
<p>A <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_greedy_init_default_+3A_sign_constraints">sign_constraints</code></td>
<td>
<p>This parameter can be used to constrain the sign of
the initial factor and loadings. It should be a vector of length two with
entries equal to -1, 0, or 1. The first entry constrains the sign of the
loadings <code class="reqn">\ell_{\cdot k}</code>, with -1 yielding nonpositive loadings, +1
yielding nonnegative loadings, and 0 indicating that loadings should not be
constrained. The second entry of <code>sign_constraints</code> similarly
constrains the sign of factor values <code class="reqn">f_{\cdot k}</code>. If
<code>sign_constraints = NULL</code>, then no constraints will be applied.</p>
</td></tr>
<tr><td><code id="flash_greedy_init_default_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance parameter. When the maximum (absolute)
change over all values <code class="reqn">\ell_{ik}</code> and <code class="reqn">f_{jk}</code> is less than or
equal to <code>tol</code>, initialization terminates. At each iteration, the
factor and loadings are <code class="reqn">L^2</code>-normalized. The default tolerance
parameter is <code class="reqn">\min(1 / n, 1 / p)</code>, where <code class="reqn">n</code> is
the number of rows in the data matrix and <code class="reqn">p</code> is the number of columns.</p>
</td></tr>
<tr><td><code id="flash_greedy_init_default_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of power iterations.</p>
</td></tr>
<tr><td><code id="flash_greedy_init_default_+3A_seed">seed</code></td>
<td>
<p>Since initialization is random, a default seed is set for
reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length two consisting of, respectively, the vector of
initial values for loadings <code class="reqn">\ell_{\cdot k}</code> and the vector of initial
factor values <code class="reqn">f_{\cdot k}</code>.
</p>


<h3>References</h3>

<p>Jason Willwerscheid (2021), <em>Empirical Bayes Matrix Factorization:
Methods and Applications</em>. Ph.D. thesis, University of Chicago.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_greedy">flash_greedy</a></code>,
<code><a href="#topic+flash_greedy_init_softImpute">flash_greedy_init_softImpute</a></code>,
<code><a href="#topic+flash_greedy_init_irlba">flash_greedy_init_irlba</a></code>
</p>

<hr>
<h2 id='flash_greedy_init_irlba'>Initialize a flash factor using IRLBA</h2><span id='topic+flash_greedy_init_irlba'></span>

<h3>Description</h3>

<p>Initializes a new (&quot;greedy&quot;) flash factor using <code><a href="irlba.html#topic+irlba">irlba</a></code>. This
can be somewhat faster than <code><a href="#topic+flash_greedy_init_default">flash_greedy_init_default</a></code> for large,
dense data matrices. For sparse matrices of class <code>Matrix</code>, the
default initialization should generally be preferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_greedy_init_irlba(flash, seed = 666, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_greedy_init_irlba_+3A_flash">flash</code></td>
<td>
<p>A <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_greedy_init_irlba_+3A_seed">seed</code></td>
<td>
<p>Since initialization is random, a default seed is set for
reproducibility.</p>
</td></tr>
<tr><td><code id="flash_greedy_init_irlba_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="irlba.html#topic+irlba">irlba</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length two consisting of, respectively, the vector of
initial values for loadings <code class="reqn">\ell_{\cdot k}</code> and the vector of initial
factor values <code class="reqn">f_{\cdot k}</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_greedy">flash_greedy</a></code>,
<code><a href="#topic+flash_greedy_init_default">flash_greedy_init_default</a></code>,
<code><a href="#topic+flash_greedy_init_softImpute">flash_greedy_init_softImpute</a></code>
</p>

<hr>
<h2 id='flash_greedy_init_softImpute'>Initialize a flash factor using softImpute</h2><span id='topic+flash_greedy_init_softImpute'></span>

<h3>Description</h3>

<p>Initializes a new (&quot;greedy&quot;) flash factor using <code><a href="softImpute.html#topic+softImpute">softImpute</a></code>.
When there is missing data, this can yield better results than
<code><a href="#topic+flash_greedy_init_default">flash_greedy_init_default</a></code> without sacrificing much (if any) speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_greedy_init_softImpute(flash, seed = 666, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_greedy_init_softImpute_+3A_flash">flash</code></td>
<td>
<p>A <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_greedy_init_softImpute_+3A_seed">seed</code></td>
<td>
<p>Since initialization is random, a default seed is set for
reproducibility.</p>
</td></tr>
<tr><td><code id="flash_greedy_init_softImpute_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to
<code><a href="softImpute.html#topic+softImpute">softImpute</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length two consisting of, respectively, the vector of
initial values for loadings <code class="reqn">\ell_{\cdot k}</code> and the vector of initial
factor values <code class="reqn">f_{\cdot k}</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_greedy">flash_greedy</a></code>,
<code><a href="#topic+flash_greedy_init_default">flash_greedy_init_default</a></code>,
<code><a href="#topic+flash_greedy_init_irlba">flash_greedy_init_irlba</a></code>
</p>

<hr>
<h2 id='flash_init'>Initialize flash object</h2><span id='topic+flash_init'></span>

<h3>Description</h3>

<p>Sets up a <code><a href="#topic+flash">flash</a></code> object with no factors. Since all other
<code>flash_xxx</code> functions take a <code>flash</code> or <code>flash_fit</code> object
as their first argument, calling <code>flash_init</code> should be the first step
in any <code>flash</code> pipeline. See <code><a href="#topic+flash">flash</a></code> for examples of usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_init(data, S = NULL, var_type = 0L, S_dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_init_+3A_data">data</code></td>
<td>
<p>The observations. Usually a matrix, but can also be a sparse
matrix of class <code><a href="Matrix.html#topic+Matrix">Matrix</a></code> or a low-rank matrix
representation as returned by, for example, <code><a href="base.html#topic+svd">svd</a></code>,
<code><a href="irlba.html#topic+irlba">irlba</a></code>, <code><a href="rsvd.html#topic+rsvd">rsvd</a></code>, or
<code><a href="softImpute.html#topic+softImpute">softImpute</a></code> (in general, any list that
includes fields <code>u</code>, <code>d</code>, and <code>v</code> will be interpreted
as a low-rank matrix representation).</p>
</td></tr>
<tr><td><code id="flash_init_+3A_s">S</code></td>
<td>
<p>The standard errors. Can be <code>NULL</code> (in which case all residual
variance will be estimated) or a matrix, vector, or scalar. <code>S</code>
should be a scalar if standard errors are identical across observations. It
should be a vector if standard errors either vary across columns but are
constant within any given row, or vary across rows but are constant within
any given column (<code>flash</code> will use the length of the vector
to determine whether the supplied values correspond to rows or columns; if the
data matrix is square, then the sense must be specified using parameter
<code>S_dim</code> in function <code><a href="#topic+flash_init">flash_init</a></code>).</p>
</td></tr>
<tr><td><code id="flash_init_+3A_var_type">var_type</code></td>
<td>
<p>Describes the structure of the estimated residual variance.
Can be <code>NULL</code>, <code>0</code>, <code>1</code>, <code>2</code>, or <code>c(1, 2)</code>. If
<code>NULL</code>, then <code>S</code> accounts for all residual variance. If
<code>var_type = 0</code>, then the estimated residual variance (which is added
to any variance given by <code>S</code>) is assumed to be constant
across all observations. Setting <code>var_type = 1</code> estimates a single
variance parameter for each row; <code>var_type = 2</code> estimates one
parameter for each column; and <code>var_type = c(1, 2)</code> optimizes over
all rank-one matrices (that is, it assumes that the residual variance
parameter <code class="reqn">s_{ij}</code> can be written <code class="reqn">s_{ij} = a_i b_j</code>, where the
<code class="reqn">n</code>-vector <code class="reqn">a</code> and the <code class="reqn">p</code>-vector <code class="reqn">b</code> are to be
estimated).
</p>
<p>Note that if any portion of the residual variance is to be estimated, then
it is usually faster to set <code>S = NULL</code> and to let <code>flash</code>
estimate all of the residual variance. Further, <code>var_type = c(1, 2)</code>
is typically much slower than other options, so it should be used with
care.</p>
</td></tr>
<tr><td><code id="flash_init_+3A_s_dim">S_dim</code></td>
<td>
<p>If the argument to <code>S</code> is a vector and the data matrix is
square, then <code>S_dim</code> must specify whether <code>S</code> encodes row-wise or
column-wise standard errors. More precisely,
if <code>S_dim = 1</code>, then <code>S</code> will be interpreted as giving
standard errors that vary across rows but are constant within any particular
row; if <code>S_dim = 2</code>, then it will be interpreted as giving
standard errors that vary across columns but are constant within any
particular column. If <code>S</code> is a matrix or scalar, or if the data
matrix is not square, then <code>S_dim</code> should be left unspecified
(<code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An initialized <code><a href="#topic+flash">flash</a></code> object (with no factors).
</p>

<hr>
<h2 id='flash_nullcheck'>Nullcheck flash factors</h2><span id='topic+flash_nullcheck'></span>

<h3>Description</h3>

<p>Sets factor/loadings pairs to zero if doing so improves the variational
lower bound (ELBO). See <code><a href="#topic+flash">flash</a></code> for examples of usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_nullcheck(flash, kset = NULL, remove = TRUE, tol = NULL, verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_nullcheck_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_nullcheck_+3A_kset">kset</code></td>
<td>
<p>A vector of integers specifying which factors to nullcheck.
If <code>kset = NULL</code>, then all existing factors will be checked.</p>
</td></tr>
<tr><td><code id="flash_nullcheck_+3A_remove">remove</code></td>
<td>
<p>Whether to remove factors that have been set to zero from the
<code>flash</code> object. Note that this might change the indices of existing
factors.</p>
</td></tr>
<tr><td><code id="flash_nullcheck_+3A_tol">tol</code></td>
<td>
<p>The &quot;tolerance&quot; parameter: if a factor does not improve the ELBO
by at least <code>tol</code>, then it will be set to zero. Note that
<code>flash_nullcheck</code> does not respect &quot;global&quot; tolerance parameters set
by <code><a href="#topic+flash_set_conv_crit">flash_set_conv_crit</a></code> (which only affects the convergence
tolerance for greedy fits and backfits). The default tolerance is
<code class="reqn">np\sqrt{\epsilon}</code>, where <code class="reqn">n</code> is the
number of rows in the dataset, <code class="reqn">p</code> is the number of columns, and
<code class="reqn">\epsilon</code> is equal to <code><a href="base.html#topic+.Machine">.Machine</a>$double.eps</code>.</p>
</td></tr>
<tr><td><code id="flash_nullcheck_+3A_verbose">verbose</code></td>
<td>
<p>When and how to display progress updates. For nullchecks,
updates are only displayed when <code>verbose</code> &gt; 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with
factors that do not improve the ELBO by at least <code>tol</code> either set
to zero or removed (depending on the argument to parameter <code>remove</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_factors_remove">flash_factors_remove</a></code>,
<code><a href="#topic+flash_factors_set_to_zero">flash_factors_set_to_zero</a></code>
</p>

<hr>
<h2 id='flash_set_conv_crit'>Set convergence criterion and tolerance parameter</h2><span id='topic+flash_set_conv_crit'></span>

<h3>Description</h3>

<p>Used in a <code><a href="#topic+flash">flash</a></code> pipeline to set the criterion for
determining whether a greedy fit or backfit has &quot;converged.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_set_conv_crit(flash, fn = NULL, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_set_conv_crit_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_set_conv_crit_+3A_fn">fn</code></td>
<td>
<p>The convergence criterion function (see Details below). If
<code>NULL</code>, then only the tolerance parameter is updated (thus a
convergence criterion can be set at the beginning of a <code>flash</code> pipeline,
allowing the tolerance parameter to be updated at will without needing to
re-specify the convergence criterion each time). The default convergence
criterion, which is set when the <code>flash</code> object is initialized, is
<code><a href="#topic+flash_conv_crit_elbo_diff">flash_conv_crit_elbo_diff</a></code>, which calculates the
difference in the variational lower bound or &quot;ELBO&quot; from one iteration to
the next.</p>
</td></tr>
<tr><td><code id="flash_set_conv_crit_+3A_tol">tol</code></td>
<td>
<p>The tolerance parameter (see Details below). The default, which is
set when the <code>flash</code> object is initialized (see
<code><a href="#topic+flash_init">flash_init</a></code>), is <code class="reqn">np\sqrt{\epsilon}</code>, where <code class="reqn">n</code> is the
number of rows in the dataset, <code class="reqn">p</code> is the number of columns, and
<code class="reqn">\epsilon</code> is equal to <code><a href="base.html#topic+.Machine">.Machine</a>$double.eps</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>flash_set_conv_crit</code> can be used to customize
the convergence criterion for a <code>flash</code> object. This criterion
determines when to stop optimizing a newly added factor
(see <code><a href="#topic+flash_greedy">flash_greedy</a></code>) and when to stop backfitting
(<code><a href="#topic+flash_backfit">flash_backfit</a></code>). Note that, because most alternative
convergence criteria do not make sense in the context of a nullcheck, it
does not set the &quot;convergence&quot; criterion for <code><a href="#topic+flash_nullcheck">flash_nullcheck</a></code>
(for example, <code><a href="#topic+flash_conv_crit_max_chg_L">flash_conv_crit_max_chg_L</a></code> would simply return
the maximum <code class="reqn">L^2</code>-normalized loading for each set of loadings
<code class="reqn">\ell_{\cdot k}</code>).
</p>
<p>The criterion is defined by the function supplied as argument to <code>fn</code>,
which must accept exactly three parameters,
<code>curr</code>, <code>prev</code>, and <code>k</code>. <code>curr</code> refers to the
<code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration; <code>prev</code>,
to the <code>flash_fit</code> object from the previous iteration;
and, if the iteration is a sequential backfitting iteration (that is, a
<code><a href="#topic+flash_backfit">flash_backfit</a></code> iteration with argument
<code>extrapolate = FALSE</code>), <code>k</code> identifies the factor/loadings pair
that is currently being updated (in all other cases, <code>k</code> is
<code>NULL</code>). The function must output a numeric value; if the value is
less than or equal to <code>tol</code>, then the fit is considered to have
&quot;converged.&quot; The meaning of &quot;convergence&quot; here varies according to the
operation being performed.
In the greedy algorithm, <code>fn</code> simply compares the fit from
one iteration to the next. During a backfit, it similarly compares fits from
one iteration to the next, but it only considers the fit to have
converged when the value of <code>fn</code> over successive updates to
<em>all</em> factor/loadings pairs is less than or equal to <code>tol</code>. If,
for example, factor/loadings pairs <code class="reqn">1, \ldots, K</code> are being
sequentially backfitted, then fits are compared before and
after the update to factor/loadings 1, before and after the update to
factor/loadings 2, and so on through factor/loadings <code class="reqn">K</code>,
and backfitting only terminates when <code>fn</code> returns a value less
than or equal to <code>tol</code> for all <code class="reqn">K</code> updates.
</p>
<p>Package <code>flashier</code> provides a number of functions that may be supplied
as convergence criteria: see
<code><a href="#topic+flash_conv_crit_elbo_diff">flash_conv_crit_elbo_diff</a></code> (the default criterion),
<code><a href="#topic+flash_conv_crit_max_chg">flash_conv_crit_max_chg</a></code>,
<code><a href="#topic+flash_conv_crit_max_chg_L">flash_conv_crit_max_chg_L</a></code>, and
<code><a href="#topic+flash_conv_crit_max_chg_F">flash_conv_crit_max_chg_F</a></code>. Custom functions may also be
defined. Typically, they will compare the fit in <code>curr</code> (the current
iteration) to the fit in <code>prev</code> (the previous iteration).
To facilitate working with <code>flash_fit</code> objects, package
<code>flashier</code> provides a number of accessors, which are enumerated in
the documentation for object <code><a href="#topic+flash_fit">flash_fit</a></code>. Custom functions
should return a numeric value that can be compared against <code>tol</code>; see
<strong>Examples</strong> below.
</p>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with the
new convergence criterion reflected in updates to the &quot;internal&quot;
<code>flash_fit</code> object. These settings will persist across
all subsequent calls to <code>flash_xxx</code> functions in the same
<code>flash</code> pipeline (unless, of course, <code>flash_set_conv_crit</code> is
again called within the same pipeline).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fl &lt;- flash_init(gtex) %&gt;%
  flash_set_conv_crit(flash_conv_crit_max_chg, tol = 1e-3) %&gt;%
  flash_set_verbose(
    verbose = 3,
    fns = flash_verbose_max_chg,
    colnames = "Max Chg",
    colwidths = 20
  ) %&gt;%
  flash_greedy(Kmax = 3)

</code></pre>

<hr>
<h2 id='flash_set_timeout'>Set timeout</h2><span id='topic+flash_set_timeout'></span>

<h3>Description</h3>

<p>Used in a <code><a href="#topic+flash">flash</a></code> pipeline to set a maximum amount of fitting
time. Note that timeout conditions are only checked during greedy fits
and backfits, so that the total amount of fitting time can exceed the time
set by <code>flash_set_timeout</code> (especially if, for example, there is a
nullcheck involving many factor/loading pairs). Also note that timeout
conditions must be cleared using function <code><a href="#topic+flash_clear_timeout">flash_clear_timeout</a></code>
before any re-fitting is attempted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_set_timeout(
  flash,
  tim,
  units = c("hours", "secs", "mins", "days", "weeks")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_set_timeout_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_set_timeout_+3A_tim">tim</code></td>
<td>
<p>A numeric value giving the maximum amount of fitting time, with
the units of time specified by parameter <code>units</code>.</p>
</td></tr>
<tr><td><code id="flash_set_timeout_+3A_units">units</code></td>
<td>
<p>The units of time according to which parameter <code>tim</code> is to
be interpreted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with the
timeout settings reflected in updates to the &quot;internal&quot; <code>flash_fit</code>
object. These settings will persist across all subsequent calls to
<code>flash_xxx</code> functions until they are modified either by
<code><a href="#topic+flash_clear_timeout">flash_clear_timeout</a></code> or by another call to
<code>flash_set_timeout</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fl &lt;- flash_init(gtex) %&gt;%
  flash_set_timeout(1, "secs") %&gt;%
  flash_greedy(Kmax = 30) %&gt;%
  flash_backfit() %&gt;%
  flash_nullcheck() %&gt;%
  flash_clear_timeout() # Always clear timeout at the end of a pipeline.

</code></pre>

<hr>
<h2 id='flash_set_verbose'>Set verbose output</h2><span id='topic+flash_set_verbose'></span>

<h3>Description</h3>

<p>Used in a <code><a href="#topic+flash">flash</a></code> pipeline to set the output that will be printed
after each greedy or backfitting iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_set_verbose(
  flash,
  verbose = 1L,
  fns = NULL,
  colnames = NULL,
  colwidths = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_set_verbose_+3A_flash">flash</code></td>
<td>
<p>A <code>flash</code> or <code>flash_fit</code> object.</p>
</td></tr>
<tr><td><code id="flash_set_verbose_+3A_verbose">verbose</code></td>
<td>
<p>When and how to display progress updates. Set to <code>0</code>
for no updates; <code>1</code> for updates after a &quot;greedy&quot; factor is added or
a backfit is completed; <code>2</code> for additional notifications about the
variational lower bound (ELBO); and <code>3</code> for updates after every
iteration. By default, per-iteration update information includes the
change in ELBO and the maximum (absolute) change over all L2-normalized
loadings <code class="reqn">\ell_1, \ldots, \ell_K</code> and factors <code class="reqn">f_1, \ldots, f_K</code>.
Update information is customizable via parameters <code>fns</code>,
<code>colnames</code>, and <code>colwidths</code>.
</p>
<p>A single tab-delimited table of values may also be output using
option <code>verbose = -1</code>. This format is especially convenient for
downstream analysis of the fitting history. For example, it may be used
to plot the value of the ELBO after each iteration (see the &quot;Advanced
Flashier&quot; vignette for an illustration).</p>
</td></tr>
<tr><td><code id="flash_set_verbose_+3A_fns">fns</code></td>
<td>
<p>A vector of functions. Used to calculate values to display
after each greedy/backfit iteration when <code>verbose</code> is either -1 or 3
(see Details below). Ignored for other values of <code>verbose</code> (0, 1, or 2).</p>
</td></tr>
<tr><td><code id="flash_set_verbose_+3A_colnames">colnames</code></td>
<td>
<p>A vector of column names, one for each function in
<code>fns</code>.</p>
</td></tr>
<tr><td><code id="flash_set_verbose_+3A_colwidths">colwidths</code></td>
<td>
<p>A vector of column widths, one for each function in
<code>fns</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>flash_set_verbose</code> can be used to customize
the output that is printed to console while fitting a <code>flash</code> object.
After each greedy or backfitting iteration (see, respectively,
<code><a href="#topic+flash_greedy">flash_greedy</a></code> and <code><a href="#topic+flash_backfit">flash_backfit</a></code>), each
function in argument <code>fns</code> is successively evaluated and the
result is printed to console in a table with column names defined by
argument <code>colnames</code> and column widths defined by argument
<code>colwidths</code>.
</p>
<p>Each function in <code>fns</code> must accept exactly three parameters,
<code>curr</code>, <code>prev</code>, and <code>k</code>: <code>curr</code> refers to the
<code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration; <code>prev</code>,
to the <code>flash_fit</code> object from the previous iteration;
and, if the iteration is a sequential backfitting iteration (that is, a
<code><a href="#topic+flash_backfit">flash_backfit</a></code> iteration with argument
<code>extrapolate = FALSE</code>), <code>k</code> identifies the factor/loadings pair
that is currently being updated (in all other cases, <code>k</code> is
<code>NULL</code>). Package <code>flashier</code> provides a number of functions that
may be used to customize output: see
<code><a href="#topic+flash_verbose_elbo">flash_verbose_elbo</a></code>,
<code><a href="#topic+flash_verbose_elbo_diff">flash_verbose_elbo_diff</a></code>,
<code><a href="#topic+flash_verbose_max_chg">flash_verbose_max_chg</a></code>,
<code><a href="#topic+flash_verbose_max_chg_L">flash_verbose_max_chg_L</a></code>, and
<code><a href="#topic+flash_verbose_max_chg_F">flash_verbose_max_chg_F</a></code>. Custom functions may also be
defined. They might inspect the current <code>flash_fit</code> object
via argument <code>curr</code>; compare the fit in <code>curr</code> to the fit from the
previous iteration (provided by argument <code>prev</code>); or
ignore both <code>flash_fit</code> objects entirely (for example, to
track progress over time, one might simply call <code><a href="base.html#topic+Sys.time">Sys.time</a></code>).
To facilitate working with <code>flash_fit</code> objects, package
<code>flashier</code> provides a number of accessors, which are enumerated in
the documentation for object <code><a href="#topic+flash_fit">flash_fit</a></code>. Custom functions
should return a character string that contains the output exactly as it is
to displayed; see <strong>Examples</strong> below.
</p>


<h3>Value</h3>

<p>The <code><a href="#topic+flash">flash</a></code> object from argument <code>flash</code>, with the
new verbose settings reflected in updates to the &quot;internal&quot;
<code>flash_fit</code> object. These settings will persist across
all subsequent calls to <code>flash_xxx</code> functions until they are modified
by another call to <code>flash_set_verbose</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Suppress all verbose output.
fl &lt;- flash_init(gtex) %&gt;%
  flash_set_verbose(0) %&gt;%
  flash_greedy(Kmax = 5)

# Set custom verbose output.
sparsity_F &lt;- function(curr, prev, k) {
  g_F &lt;- flash_fit_get_g(curr, n = 2)
  g_F_pi0 &lt;- g_F$pi[1] # Mixture weight of the "null" component.
  return(g_F_pi0)
}
verbose_fns &lt;- c(flash_verbose_elbo, flash_verbose_max_chg_F, sparsity_F)
colnames &lt;- c("ELBO", "Max Chg (Tiss)", "Sparsity (Tiss)")
colwidths &lt;- c(12, 18, 18)
fl &lt;- flash_init(gtex) %&gt;%
  flash_set_verbose(
    verbose = 3,
    fns = verbose_fns,
    colnames = colnames,
    colwidths = colwidths
  ) %&gt;%
  flash_greedy(Kmax = 3)

# Output can be changed as needed.
fl &lt;- flash_init(gtex) %&gt;%
  flash_set_verbose(verbose = 1) %&gt;%
  flash_greedy(Kmax = 5L) %&gt;%
  flash_backfit(verbose = 3) %&gt;%
  flash_greedy(Kmax = 1L)

</code></pre>

<hr>
<h2 id='flash_verbose_elbo'>Display the current ELBO</h2><span id='topic+flash_verbose_elbo'></span>

<h3>Description</h3>

<p>Displays the value of the variational lower bound (ELBO) at the current
iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_verbose_elbo(curr, prev, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_verbose_elbo_+3A_curr">curr</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration.</p>
</td></tr>
<tr><td><code id="flash_verbose_elbo_+3A_prev">prev</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the previous iteration.</p>
</td></tr>
<tr><td><code id="flash_verbose_elbo_+3A_k">k</code></td>
<td>
<p>Only used during sequential backfits (that is, calls to
<code><a href="#topic+flash_backfit">flash_backfit</a></code> where <code>extrapolate = FALSE</code>). It then
takes the index of the factor/loadings pair currently being optimized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an example of a function that may be passed to
parameter <code>fns</code> in function <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> to
customize the output that is printed after each greedy or backfitting
iteration. See <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> for details and examples.
</p>


<h3>Value</h3>

<p>A character string, suitable for printing progress updates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_verbose_elbo_diff">flash_verbose_elbo_diff</a></code>,
<code><a href="#topic+flash_verbose_max_chg">flash_verbose_max_chg</a></code>,
<code><a href="#topic+flash_verbose_max_chg_L">flash_verbose_max_chg_L</a></code>,
<code><a href="#topic+flash_verbose_max_chg_F">flash_verbose_max_chg_F</a></code>
</p>

<hr>
<h2 id='flash_verbose_elbo_diff'>Display the difference in ELBO</h2><span id='topic+flash_verbose_elbo_diff'></span>

<h3>Description</h3>

<p>Displays the difference in the variational lower bound (ELBO) from one
iteration to the next.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_verbose_elbo_diff(curr, prev, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_verbose_elbo_diff_+3A_curr">curr</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration.</p>
</td></tr>
<tr><td><code id="flash_verbose_elbo_diff_+3A_prev">prev</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the previous iteration.</p>
</td></tr>
<tr><td><code id="flash_verbose_elbo_diff_+3A_k">k</code></td>
<td>
<p>Only used during sequential backfits (that is, calls to
<code><a href="#topic+flash_backfit">flash_backfit</a></code> where <code>extrapolate = FALSE</code>). It then
takes the index of the factor/loadings pair currently being optimized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an example of a function that may be passed to
parameter <code>fns</code> in function <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> to
customize the output that is printed after each greedy or backfitting
iteration. See <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> for details and examples.
</p>


<h3>Value</h3>

<p>A character string, suitable for printing progress updates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_verbose_elbo">flash_verbose_elbo</a></code>, <code><a href="#topic+flash_verbose_max_chg">flash_verbose_max_chg</a></code>,
<code><a href="#topic+flash_verbose_max_chg_L">flash_verbose_max_chg_L</a></code>, <code><a href="#topic+flash_verbose_max_chg_F">flash_verbose_max_chg_F</a></code>
</p>

<hr>
<h2 id='flash_verbose_max_chg'>Display the maximum difference in scaled loadings and factors</h2><span id='topic+flash_verbose_max_chg'></span>

<h3>Description</h3>

<p>Displays the maximum (absolute) change over all (posterior expected values for)
loadings <code class="reqn">\ell_{ik}</code> and factors <code class="reqn">f_{jk}</code>. At each iteration, the
loadings vectors <code class="reqn">\ell_{\cdot 1}, \ldots, \ell_{\cdot K}</code> and factors
<code class="reqn">f_{\cdot 1}, \ldots, f_{\cdot K}</code> are <code class="reqn">L^2</code>-normalized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_verbose_max_chg(curr, prev, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_verbose_max_chg_+3A_curr">curr</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration.</p>
</td></tr>
<tr><td><code id="flash_verbose_max_chg_+3A_prev">prev</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the previous iteration.</p>
</td></tr>
<tr><td><code id="flash_verbose_max_chg_+3A_k">k</code></td>
<td>
<p>Only used during sequential backfits (that is, calls to
<code><a href="#topic+flash_backfit">flash_backfit</a></code> where <code>extrapolate = FALSE</code>). It then
takes the index of the factor/loadings pair currently being optimized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an example of a function that may be passed to
parameter <code>fns</code> in function <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> to
customize the output that is printed after each greedy or backfitting
iteration. See <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> for details and examples.
</p>


<h3>Value</h3>

<p>A character string, suitable for printing progress updates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_verbose_elbo">flash_verbose_elbo</a></code>, <code><a href="#topic+flash_verbose_elbo_diff">flash_verbose_elbo_diff</a></code>,
<code><a href="#topic+flash_verbose_max_chg_L">flash_verbose_max_chg_L</a></code>, <code><a href="#topic+flash_verbose_max_chg_F">flash_verbose_max_chg_F</a></code>
</p>

<hr>
<h2 id='flash_verbose_max_chg_F'>Display the maximum difference in scaled factors</h2><span id='topic+flash_verbose_max_chg_F'></span>

<h3>Description</h3>

<p>Displays the maximum (absolute) change over all (posterior expected values for)
factors <code class="reqn">f_{jk}</code>. At each iteration, the factors
<code class="reqn">f_{\cdot 1}, \ldots, f_{\cdot K}</code> are <code class="reqn">L^2</code>-normalized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_verbose_max_chg_F(curr, prev, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_verbose_max_chg_F_+3A_curr">curr</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration.</p>
</td></tr>
<tr><td><code id="flash_verbose_max_chg_F_+3A_prev">prev</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the previous iteration.</p>
</td></tr>
<tr><td><code id="flash_verbose_max_chg_F_+3A_k">k</code></td>
<td>
<p>Only used during sequential backfits (that is, calls to
<code><a href="#topic+flash_backfit">flash_backfit</a></code> where <code>extrapolate = FALSE</code>). It then
takes the index of the factor/loadings pair currently being optimized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an example of a function that may be passed to
parameter <code>fns</code> in function <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> to
customize the output that is printed after each greedy or backfitting
iteration. See <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> for details and examples.
</p>


<h3>Value</h3>

<p>A character string, suitable for printing progress updates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_verbose_elbo">flash_verbose_elbo</a></code>, <code><a href="#topic+flash_verbose_elbo_diff">flash_verbose_elbo_diff</a></code>,
<code><a href="#topic+flash_verbose_max_chg">flash_verbose_max_chg</a></code>, <code><a href="#topic+flash_verbose_max_chg_L">flash_verbose_max_chg_L</a></code>
</p>

<hr>
<h2 id='flash_verbose_max_chg_L'>Display the maximum difference in scaled loadings</h2><span id='topic+flash_verbose_max_chg_L'></span>

<h3>Description</h3>

<p>Displays the maximum (absolute) change over all (posterior expected values for)
loadings <code class="reqn">\ell_{ik}</code>. At each iteration, the loadings vectors
<code class="reqn">\ell_{\cdot 1}, \ldots, \ell_{\cdot K}</code> are <code class="reqn">L^2</code>-normalized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flash_verbose_max_chg_L(curr, prev, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flash_verbose_max_chg_L_+3A_curr">curr</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the current iteration.</p>
</td></tr>
<tr><td><code id="flash_verbose_max_chg_L_+3A_prev">prev</code></td>
<td>
<p>The <code><a href="#topic+flash_fit">flash_fit</a></code> object from the previous iteration.</p>
</td></tr>
<tr><td><code id="flash_verbose_max_chg_L_+3A_k">k</code></td>
<td>
<p>Only used during sequential backfits (that is, calls to
<code><a href="#topic+flash_backfit">flash_backfit</a></code> where <code>extrapolate = FALSE</code>). It then
takes the index of the factor/loadings pair currently being optimized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an example of a function that may be passed to
parameter <code>fns</code> in function <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> to
customize the output that is printed after each greedy or backfitting
iteration. See <code><a href="#topic+flash_set_verbose">flash_set_verbose</a></code> for details and examples.
</p>


<h3>Value</h3>

<p>A character string, suitable for printing progress updates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flash_verbose_elbo">flash_verbose_elbo</a></code>, <code><a href="#topic+flash_verbose_elbo_diff">flash_verbose_elbo_diff</a></code>,
<code><a href="#topic+flash_verbose_max_chg">flash_verbose_max_chg</a></code>, <code><a href="#topic+flash_verbose_max_chg_F">flash_verbose_max_chg_F</a></code>
</p>

<hr>
<h2 id='gtex'>GTEx data</h2><span id='topic+gtex'></span>

<h3>Description</h3>

<p>Derived from data made available by the Genotype Tissue
Expression (GTEx) project (Lonsdale et al. 2013),
which provides <code class="reqn">z</code>-scores for assessing the significance of effects of
genetic variants (single nucleotide polymorphisms, or SNPs) on gene
expression across 44 human tissues. To reduce the data to a more manageable
size, Urbut et al. (2019) chose the &quot;top&quot; SNP for
each gene &mdash; that is, the SNP associated with the largest (absolute)
<code class="reqn">z</code>-score over all 44 tissues. This yields a <code class="reqn">16,069 \times 44</code> matrix
of <code class="reqn">z</code>-scores, with rows corresponding to SNP-gene pairs and columns
corresponding to tissues. The dataset included here
is further subsampled down to 1000 rows.
</p>


<h3>Format</h3>

<p><code>gtex</code> is a matrix with 1000 rows and 44 columns, with rows
corresponding to SNP-gene pairs and columns corresponding to tissues.
</p>


<h3>Source</h3>

<p>&lt;https://github.com/stephenslab/gtexresults/blob/master/data/MatrixEQTLSumStats.Portable.Z.rds&gt;
</p>


<h3>References</h3>

<p>Lonsdale et al. (2013).
&quot;The Genotype-Tissue Expression (GTEx) project.&quot; <em>Nature Genetics</em>
45(6), 580&ndash;585.
</p>
<p>Urbut, Wang, Carbonetto, and Stephens (2019).
&quot;Flexible statistical methods for estimating and testing effects in
genomic studies with multiple conditions.&quot; <em>Nature Genetics</em>
51(1), 187&ndash;195.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtex)
summary(gtex)

</code></pre>

<hr>
<h2 id='gtex_colors'>Colors for plotting GTEx data</h2><span id='topic+gtex_colors'></span>

<h3>Description</h3>

<p>A custom palette used by Wang and Stephens (2021) to plot an
empirical Bayes matrix factorization of data from the GTEx project
(of which the <code><a href="#topic+gtex">gtex</a></code> data in package <strong>flashier</strong> is a
subsample).
The palette is designed to link similar tissues together visually. For
example, brain tissues all have the same color (yellow); arterial tissues
are shades of pink or red; etc.
</p>


<h3>Format</h3>

<p><code>gtex_colors</code> is a named vector of length 44, with names corresponding
to tissues (columns) in the <code><a href="#topic+gtex">gtex</a></code> dataset and values
giving hexadecimal color codes.
</p>


<h3>Source</h3>

<p>&lt;https://github.com/stephenslab/gtexresults/blob/master/data/GTExColors.txt&gt;
</p>


<h3>References</h3>

<p>Wei Wang and Matthew Stephens (2021).
&quot;Empirical Bayes matrix factorization.&quot; <em>Journal of Machine Learning
Research</em> 22, 1&ndash;40.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fl &lt;- flash(gtex, greedy_Kmax = 4)
plot(fl, incl_scree = FALSE, pm_colors = gtex_colors)
</code></pre>

<hr>
<h2 id='ldf'>LDF method for flash and flash fit objects</h2><span id='topic+ldf'></span><span id='topic+ldf.flash'></span><span id='topic+ldf.flash_fit'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+flash">flash</a></code> or <code><a href="#topic+flash_fit">flash_fit</a></code> object, returns the LDF
decomposition <code class="reqn">Y \approx LDF'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldf(object, type)

## S3 method for class 'flash'
ldf(object, type = "f")

## S3 method for class 'flash_fit'
ldf(object, type = "f")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldf_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>flash</code> or
<code>flash_fit</code>.</p>
</td></tr>
<tr><td><code id="ldf_+3A_type">type</code></td>
<td>
<p>Takes identical arguments to function <code><a href="base.html#topic+norm">norm</a></code>. Use
<code>"f"</code> or <code>"2"</code> for the 2-norm (Euclidean norm); <code>"o"</code> or
<code>"1"</code> for the 1-norm (taxicab norm); and <code>"i"</code> or <code>"m"</code> for
the infinity norm (maximum norm).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the prior families <code class="reqn">G_\ell^{(k)}</code> and <code class="reqn">G_f^{(k)}</code> are closed
under scaling (as is typically the case), then the EBMF model (as
described in the documention to function <code><a href="#topic+flash">flash</a></code>) is only
identifiable up to scaling by a diagonal matrix <code class="reqn">D</code>:
</p>
<p style="text-align: center;"><code class="reqn">Y = LDF' + E.</code>
</p>

<p>Method <code>ldf</code> scales columns <code class="reqn">\ell_k</code> and <code class="reqn">f_k</code>
so that, depending on the argument to parameter <code>type</code>, their
1-norms, 2-norms, or infinity norms are equal to 1.
</p>


<h3>Value</h3>

<p>A list with fields <code>L</code>, <code>D</code>, and <code>F</code>, each of which
corresponds to one of the matrices in the decomposition <code class="reqn">Y \approx LDF'</code>
(with the columns of <code class="reqn">L</code> and <code class="reqn">F</code> scaled according to
argument <code>type</code>). Note that <code>D</code> is returned as a vector rather
than a matrix (the vector of diagonal entries in <code class="reqn">D</code>). Thus, &quot;fitted
values&quot; <code class="reqn">LDF'</code> can be recovered as <code>L %*% diag(D) %*% t(F)</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ldf(flash)</code>: LDF decomposition for <code><a href="#topic+flash">flash</a></code> objects
</p>
</li>
<li> <p><code>ldf(flash_fit)</code>: LDF decomposition for <code><a href="#topic+flash_fit">flash_fit</a></code> objects
</p>
</li></ul>

<hr>
<h2 id='plot.flash'>Plot method for flash objects</h2><span id='topic+plot.flash'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+flash">flash</a></code> object, produces up to two figures: one showing
the proportion of variance explained per factor/loadings pair, and one that
plots posterior means for either factors or loadings (depending on the
argument to parameter <code>pm_which</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flash'
plot(
  x,
  include_scree = TRUE,
  include_pm = TRUE,
  order_by_pve = TRUE,
  kset = NULL,
  pm_which = c("factors", "loadings"),
  pm_subset = NULL,
  pm_groups = NULL,
  pm_colors = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.flash_+3A_x">x</code></td>
<td>
<p>An object inheriting from class <code>flash</code>.</p>
</td></tr>
<tr><td><code id="plot.flash_+3A_include_scree">include_scree</code></td>
<td>
<p>Whether to include a figure (&quot;scree plot&quot;) showing the
proportion of variance explained by each factor/loadings pair.</p>
</td></tr>
<tr><td><code id="plot.flash_+3A_include_pm">include_pm</code></td>
<td>
<p>Whether to include a figure showing the posterior means for
either loadings <code class="reqn">L</code> or factors <code class="reqn">F</code> (depending on the argument to
parameter <code>pm_which</code>). One plot panel is produced for each
factor/loadings pair <code class="reqn">k</code>. If argument <code>pm_groups</code>
is left unspecified, then bar plots will be produced, with each bar
corresponding to a single value <code class="reqn">\ell_{ik}</code> or <code class="reqn">f_{jk}</code>.
Otherwise, overlapping histograms will be
produced, with each histogram corresponding to one of the groups
specified by <code>pm_groups</code>.</p>
</td></tr>
<tr><td><code id="plot.flash_+3A_order_by_pve">order_by_pve</code></td>
<td>
<p>If <code>TRUE</code>, then the factor/loadings pairs will be
re-ordered according to proportion of variance explained (from
highest to lowest).</p>
</td></tr>
<tr><td><code id="plot.flash_+3A_kset">kset</code></td>
<td>
<p>A vector of integers specifying the factor/loadings pairs to be
plotted. If <code>kset = NULL</code>, then all will be plotted.</p>
</td></tr>
<tr><td><code id="plot.flash_+3A_pm_which">pm_which</code></td>
<td>
<p>Whether to plot loadings <code class="reqn">L</code> or factors <code class="reqn">F</code> in the
plots of posterior means.
This parameter is ignored when <code>include_pm = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.flash_+3A_pm_subset">pm_subset</code></td>
<td>
<p>A vector of row indices <code class="reqn">i</code> or column indices
<code class="reqn">j</code> (depending on the argument to <code>pm_which</code>)
specifying which values <code class="reqn">\ell_{i \cdot}</code> or <code class="reqn">f_{j \cdot}</code> are
to be shown in the plots of posterior means. If the dataset has row or
column names, then names rather than indices may be specified. If
<code>pm_subset = NULL</code>, then all values will be plotted.
This parameter is ignored when <code>include_pm = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.flash_+3A_pm_groups">pm_groups</code></td>
<td>
<p>A vector specifying the group to which each row of the data
<code class="reqn">y_{i \cdot}</code> or column <code class="reqn">y_{\cdot j}</code> belongs
(groups may be numeric indices or strings). If <code>pm_groups = NULL</code>,
then a bar plot of the ungrouped data is produced (see <code>include_pm</code>
above). Otherwise, a group must be provided for each plotted row <code class="reqn">i</code> or
column <code class="reqn">j</code>, so that
the length of <code>pm_groups</code> is exactly equal to the number of rows or
columns in the full dataset or, if <code>pm_subset</code> is specified, in the
subsetted dataset. When <code>pm_groups</code> is not <code>NULL</code>, a set of
overlapping histograms is produced for each factor/loadings pair, with
one histogram per group (again see <code>include_pm</code>).
This parameter is ignored when <code>include_pm = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.flash_+3A_pm_colors">pm_colors</code></td>
<td>
<p>A vector specifying a color for each bar (if
<code>pm_groups = NULL</code>) or histogram (if <code>pm_groups</code> is not
<code>NULL</code>). Passed directly to parameter <code>values</code> in <strong>ggplot2</strong>
function <code><a href="ggplot2.html#topic+scale_color_manual">scale_color_manual</a></code>.
This parameter is ignored when <code>include_pm = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.flash_+3A_...">...</code></td>
<td>
<p>Additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If arguments <code>include_scree</code> and <code>include_pm</code> specify that
only one figure be produced, then <code>plot.flash()</code> returns a
<code>ggplot2</code> object. If both figures are to be produced, then
<code>plot.flash()</code> prints both plots but does not return a value.
</p>

<hr>
<h2 id='residuals.flash'>Residuals method for flash objects</h2><span id='topic+residuals.flash'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+flash">flash</a></code> object, returns the expected residuals
<code class="reqn">Y - E(LF') = Y - E(L) E(F)'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flash'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.flash_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>flash</code>.</p>
</td></tr>
<tr><td><code id="residuals.flash_+3A_...">...</code></td>
<td>
<p>Additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of expected residuals.
</p>

<hr>
<h2 id='residuals.flash_fit'>Residuals method for flash fit objects</h2><span id='topic+residuals.flash_fit'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+flash_fit">flash_fit</a></code> object, returns the expected residuals
<code class="reqn">Y - E(LF') = Y - E(L) E(F)'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flash_fit'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.flash_fit_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>flash_fit</code>.</p>
</td></tr>
<tr><td><code id="residuals.flash_fit_+3A_...">...</code></td>
<td>
<p>Additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of expected residuals.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
