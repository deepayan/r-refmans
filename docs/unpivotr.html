<!DOCTYPE html><html lang="en"><head><title>Help for package unpivotr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {unpivotr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#unpivotr-package'><p>Un-pivot complex and irregular data layouts.</p></a></li>
<li><a href='#as_cells'><p>Tokenize data frames into a tidy 'melted' structure</p></a></li>
<li><a href='#behead'><p>Strip a level of headers from a pivot table</p></a></li>
<li><a href='#direction'><p>Directions from data cells to headers</p></a></li>
<li><a href='#enhead'><p>Join data cells to headers</p></a></li>
<li><a href='#isolate_sentinels'><p>Move sentinel values into a separate column leaving NA behind</p></a></li>
<li><a href='#justify'><p>Align one set of cells with another set</p></a></li>
<li><a href='#merge_cells'><p>Merge cell values into a single cell by rows or columns</p></a></li>
<li><a href='#pack'><p>Pack cell values from separate columns per data type into one list-column</p></a></li>
<li><a href='#partition'><p>Divide a grid of cells into partitions containing individual tables</p></a></li>
<li><a href='#purpose'><p>Sense-of-purpose in the 2014 New Zealand General Social Survey</p></a></li>
<li><a href='#rectify'><p>Display cells as though in a spreadsheet</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#spatter'><p>Spread key-value pairs of mixed types across multiple columns</p></a></li>
<li><a href='#tidy_table'><p>Tokenize data frames into a tidy 'melted' structure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Unpivot Complex and Irregular Data Layouts</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for converting data from complex or irregular layouts to a
    columnar structure.  For example, tables with multilevel column or row
    headers, or spreadsheets.  Header and data cells are selected by their
    contents and position, as well as formatting and comments where available,
    and are associated with one other by their proximity in given directions.
    Functions for data frames and HTML tables are provided.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, rlang, magrittr, dplyr, forcats, purrr, tidyr,
pillar, tibble (&ge; 2.1.1), cellranger, xml2, tidyselect</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nacnudus/unpivotr">https://github.com/nacnudus/unpivotr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nacnudus/unpivotr/issues">https://github.com/nacnudus/unpivotr/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, readr, tidyxl, readxl, stringr, htmltools,
rvest, selectr, DT, testthat, covr, here</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-30 21:13:09 UTC; nacnudus</td>
</tr>
<tr>
<td>Author:</td>
<td>Duncan Garmonsway [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Duncan Garmonsway &lt;nacnudus@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-30 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='unpivotr-package'>Un-pivot complex and irregular data layouts.</h2><span id='topic+unpivotr'></span><span id='topic+unpivotr-package'></span>

<h3>Description</h3>

<p>'Unpivotr' provides tools for converting data from complex or irregular
layouts to a columnar structure.  For example, tables with multi-level column
or row headers, or spreadsheets of several tables, nested HTML tables, and
data that uses several different sentinel values.
</p>


<h3>Details</h3>

<p>The best way to learn unpivotr is the free online book <a href="https://nacnudus.github.io/spreadsheet-munging-strategies/">Spreadsheet Munging Strategies</a>.
</p>
<p>Header and data cells can selected by their contents, position, data type and
formatting, and can be associated with one other by their relative positions.
</p>
<p>The input data must be a data frame with the columns 'row' and 'col' to
describe the position of a 'cell' of data.  For cells that are to be
interpreted as data, further columns containing the 'value' of the cell are,
of course, necessary for there to be any point in using this package, though
they are not actually required for any of the given functions.
</p>
<p>Data frames and HTML tables can be converted into a format meeting these
requirements by using the <code><a href="#topic+as_cells">as_cells()</a></code> function.  Excel (.xlsx)
files can be imported directly into the required format with the 'tidyxl'
package, available at <a href="https://github.com/nacnudus/tidyxl">https://github.com/nacnudus/tidyxl</a>, which has the
advantage that it retains cell formatting and comments.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Duncan Garmonsway <a href="mailto:nacnudus@gmail.com">nacnudus@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/nacnudus/unpivotr">https://github.com/nacnudus/unpivotr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nacnudus/unpivotr/issues">https://github.com/nacnudus/unpivotr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_cells'>Tokenize data frames into a tidy 'melted' structure</h2><span id='topic+as_cells'></span>

<h3>Description</h3>

<p>Data frames represent data in a tabular structure.  <code><a href="#topic+as_cells">as_cells()</a></code>
takes the row and column position of each 'cell', and returns that
information in a new data frame, alongside the content and type of each cell.
</p>
<p>This makes it easier to deal with complex or non-tabular data (e.g. pivot
tables) that have been imported into R as data frames.  Once they have been
'melted' by <code><a href="#topic+as_cells">as_cells()</a></code>, you can use functions like <code><a href="#topic+behead">behead()</a></code> and
<code><a href="#topic+spatter">spatter()</a></code> to reshape them into conventional, tidy, unpivoted structures.
</p>
<p>For HTML tables, the content of each cell is returned as a standalone HTML
string that can be further parsed with tools such as the rvest package.  This
is particularly useful when an HTML cell itself contains an HTML table, or
contains both text and a URL.  If the HTML itself is poorly formatted, try
passing it through the
<a href="https://CRAN.R-project.org/package=htmltidy">htmltidy</a> package first.
</p>
<p>This is an S3 generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_cells(x, row_names = FALSE, col_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_cells_+3A_x">x</code></td>
<td>
<p>A data.frame or an HTML document</p>
</td></tr>
<tr><td><code id="as_cells_+3A_row_names">row_names</code></td>
<td>
<p>Whether to treat the row names as cells, Default: FALSE</p>
</td></tr>
<tr><td><code id="as_cells_+3A_col_names">col_names</code></td>
<td>
<p>Whether to treat the column names  as cells, Default: FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For certain non-rectangular data formats, it can be useful to parse
the data into a melted format where each row represents a single
token.
</p>


<h3>Value</h3>

<p>A data.frame with the following columns:
</p>

<ul>
<li> <p><code>row</code> and <code>col</code> (integer) giving the original position of the 'cells'
</p>
</li>
<li><p> any relevant columns for cell values in their original types: <code>chr</code>,
<code>cplx</code>, <code>cplx</code>, <code>dbl</code>, <code>fct</code>, <code>int</code>, <code>lgl</code>, <code>list</code>, and <code>ord</code>
</p>
</li>
<li> <p><code>data_type</code> to specify for each cell which of the above columns (<code>chr</code>
etc.) the value is in.
</p>
</li></ul>

<p>The columns <code>fct</code> and <code>ord</code> are, like <code>list</code>, list-columns (each element is
independent) to avoid factor levels clashing.  For HTML tables, the column
<code>html</code> gives the HTML string of the original cell.
</p>
<p>Row and column names, when present and required by <code>row_names = TRUE</code> or
<code>col_names = TRUE</code>, are treated as though they were cells in the table, and
they appear in the <code>chr</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(a = c(10, 20),
                b = c("foo", "bar"),
                stringsAsFactors = FALSE)
x
as_cells(x)
as_cells(x, row_names = TRUE)
as_cells(x, col_names = TRUE)

# 'list' columns are undisturbed
y &lt;- data.frame(a = c("a", "b"), stringsAsFactors = FALSE)
y$b &lt;- list(1:2, 3:4)
y
as_cells(y)

# Factors are preserved by being wrapped in lists so that their levels don't
# conflict.  Blanks are NULLs.
z &lt;- data.frame(x = factor(c("a", "b")),
                y = factor(c("c", "d"), ordered = TRUE))
as_cells(z)
as_cells(z)$fct
as_cells(z)$ord

# HTML tables can be extracted from the output of xml2::read_html().  These
# are returned as a list of tables, similar to rvest::html_table().  The
# value of each cell is its standalone HTML string, which can contain
# anything -- even another table.

colspan &lt;- system.file("extdata", "colspan.html", package = "unpivotr")
rowspan &lt;- system.file("extdata", "rowspan.html", package = "unpivotr")
nested &lt;- system.file("extdata", "nested.html", package = "unpivotr")

## Not run: 
browseURL(colspan)
browseURL(rowspan)
browseURL(nestedspan)

## End(Not run)

as_cells(xml2::read_html(colspan))
as_cells(xml2::read_html(rowspan))
as_cells(xml2::read_html(nested))
</code></pre>

<hr>
<h2 id='behead'>Strip a level of headers from a pivot table</h2><span id='topic+behead'></span><span id='topic+behead_if'></span>

<h3>Description</h3>

<p><code><a href="#topic+behead">behead()</a></code> takes one level of headers from a pivot table and
makes it part of the data.  Think of it like <code><a href="tidyr.html#topic+gather">tidyr::gather()</a></code>, except that
it works when there is more than one row of headers (or more than one column
of row-headers), and it only works on tables that have first come through
<code><a href="#topic+as_cells">as_cells()</a></code> or <code><a href="tidyxl.html#topic+xlsx_cells">tidyxl::xlsx_cells()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>behead(
  cells,
  direction,
  name,
  values = NULL,
  types = data_type,
  formatters = list(),
  drop_na = TRUE
)

behead_if(
  cells,
  ...,
  direction,
  name,
  values = NULL,
  types = data_type,
  formatters = list(),
  drop_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="behead_+3A_cells">cells</code></td>
<td>
<p>Data frame. The cells of a pivot table, usually the output of
<code><a href="#topic+as_cells">as_cells()</a></code> or <code><a href="tidyxl.html#topic+xlsx_cells">tidyxl::xlsx_cells()</a></code>, or of a subsequent operation on
those outputs.</p>
</td></tr>
<tr><td><code id="behead_+3A_direction">direction</code></td>
<td>
<p>The direction between a data cell and its header, one of
<code>"up"</code>, <code>"right"</code>, <code>"down"</code>, <code>"left"</code>, <code>"up-left"</code>, <code>"up-right"</code>,
<code>"right-up"</code>, <code>"right-down"</code>, <code>"down-right"</code>, <code>"down-left"</code>, <code>"left-down"</code>,
<code>"left-up"</code>.  See <code>?direction</code>.  <code>"up-ish"</code>, <code>"down-ish"</code>, <code>"left-ish"</code> and
<code>"right-ish"</code> aren't available because they require certain ambiguities that
are better handled by using <code><a href="#topic+enhead">enhead()</a></code> directly rather than via <code><a href="#topic+behead">behead()</a></code>.</p>
</td></tr>
<tr><td><code id="behead_+3A_name">name</code></td>
<td>
<p>A name to give the new column that will be created, e.g.
<code>"location"</code> if the headers are locations.  Quoted (<code>"location"</code>, not
<code>location</code>) because it doesn't refer to an actual object.</p>
</td></tr>
<tr><td><code id="behead_+3A_values">values</code></td>
<td>
<p>Optional. The column of <code>cells</code> to use as the values of each
header.  Given as a bare variable name.  If omitted (the default), the
<code>types</code> argument will be used instead.</p>
</td></tr>
<tr><td><code id="behead_+3A_types">types</code></td>
<td>
<p>The name of the column that names the data type of each cell.
Usually called <code>data_types</code> (the default), this is a character column that
names the other columns in <code>cells</code> that contain the values of each cell.
E.g.  a cell with a character value will have <code>"character"</code> in this column.
Unquoted(<code>data_types</code>, not <code>"data_types"</code>) because it refers to an actual
object.</p>
</td></tr>
<tr><td><code id="behead_+3A_formatters">formatters</code></td>
<td>
<p>A named list of functions for formatting each data type in
a set of headers of mixed data types, e.g. when some headers are dates and
others are characters.  These can be given as <code>character = toupper</code> or
<code>character = ~ toupper(.x)</code>, similar to <a href="purrr.html#topic+map">purrr::map</a>.</p>
</td></tr>
<tr><td><code id="behead_+3A_drop_na">drop_na</code></td>
<td>
<p>logical Whether to filter out headers that have <code>NA</code> in the
<code>value</code> column.  Default: <code>TRUE</code>.  This can happen with the output of
<code>tidyxl::xlsx_cells()</code>, when an empty cell exists because it has formatting
applied to it, but should be ignored.</p>
</td></tr>
<tr><td><code id="behead_+3A_...">...</code></td>
<td>
<p>Passed to <a href="dplyr.html#topic+filter">dplyr::filter</a>. logical predicates defined in terms of
the variables in <code>.data</code>.  Multiple conditions are combined with <code>&amp;</code>. Only
rows where the condition evaluates to <code>TRUE</code> are kept.
</p>
<p>The arguments in <code>...</code> are automatically <a href="rlang.html#topic+defusing-advanced">quoted</a> and
<a href="rlang.html#topic+eval_tidy">evaluated</a> in the context of the data frame. They
support <a href="rlang.html#topic+topic-inject">unquoting</a> and splicing. See the dplyr
<code>vignette("programming")</code> for an introduction to these concepts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple table with a row of headers
(x &lt;- data.frame(a = 1:2, b = 3:4))

# Make a tidy representation of each cell
(cells &lt;- as_cells(x, col_names = TRUE))

# Strip the cells in row 1 (the original headers) and use them as data
behead(cells, "N", foo)

# More complex example: pivot table with several layers of headers
(x &lt;- purpose$`up-left left-up`)

# Make a tidy representation
cells &lt;- as_cells(x)
head(cells)
tail(cells)

# Strip the headers and make them into data
tidy &lt;-
  cells %&gt;%
  behead("up-left", Sex) %&gt;%
  behead("up", `Sense of purpose`) %&gt;%
  behead("left-up", `Highest qualification`) %&gt;%
  behead("left", `Age group (Life-stages)`) %&gt;%
  dplyr::mutate(count = as.integer(chr)) %&gt;%
  dplyr::select(-row, -col, -data_type, -chr)
head(tidy)

# Check against the provided 'tidy' version of the data.
dplyr::anti_join(tidy, purpose$Tidy)

# The provided 'tidy' data is missing a row for Male 15-24-year-olds with a
# postgraduate qualification and a sense of purpose between 0 and 6.  That
# seems to have been an oversight by Statistics New Zealand.

cells &lt;- tibble::tribble(
       ~X1, ~adult, ~juvenile,
    "LION",    855,       677,
    "male",    496,       322,
  "female",    359,       355,
   "TIGER",    690,       324,
    "male",    381,       222,
  "female",    309,       102
  )
cells &lt;- as_cells(cells, col_names = TRUE)

cells %&gt;%
  behead_if(chr == toupper(chr), direction = "left-up", name = "species") %&gt;%
  behead("left", "sex") %&gt;%
  behead("up", "age") %&gt;%
  dplyr::select(species, sex, age, population = dbl)
</code></pre>

<hr>
<h2 id='direction'>Directions from data cells to headers</h2><span id='topic+direction'></span>

<h3>Description</h3>

<p>How to use functions with a <code>direction</code> parameter.
</p>
<p>Data cells relate to header cells by their proximity in a given direction.
The point of view is always <em>from</em> the data cell <em>to</em> the header.  For
example, the direction <code>"up"</code> means &quot;from each data cell go directly up to a
cell at the edge of the table, which is the header cell.&quot;
</p>
<p>Scroll down to the &quot;Tables&quot; section for a visual explanation.
</p>
<p>Legacy directions <code>"N"</code>, <code style="white-space: pre;">&#8288;"NNW", &#8288;</code>&quot;W&quot;<code style="white-space: pre;">&#8288;, &#8288;</code>&quot;WNW&quot;', etc. are still supported.
Scroll down to the &quot;Legacy directions&quot; section for how they map to the new
directions.
</p>

<ul>
<li> <p><code>"up"</code> means from each data cell go directly up to a cell at the edge of
the the table, which is the header cell.
</p>
</li>
<li> <p><code>"up-left"</code> means from each data cell go directly up to a cell at the edge
of the the table, then if the cell is blank go left until a cell that has a
value, which is the header cell.
</p>
</li>
<li> <p><code>"up-right"</code> means from each data cell go directly up to a cell at the edge
of the the table, then if the cell is blank go right until a cell that has a
value, which is the header cell.
</p>
</li>
<li> <p><code>"left"</code> means from each data cell go directly left to a cell at the edge
of the the table, which is the header cell.
</p>
</li>
<li> <p><code>"left-up"</code> means from each data cell go directly left to a cell at the
edge of the the table, then if the cell is blank go up until a cell that has
a value, which is the header cell.
</p>
</li>
<li> <p><code>"left-down"</code> means from each data cell go directly left to a cell at the
edge of the the table, then if the cell is blank go down until a cell that
has a value, which is the header cell.
</p>
</li>
<li> <p><code>"right"</code> means from each data cell go directly right to a cell at the edge
of the the table, which is the header cell.
</p>
</li>
<li> <p><code>"right-up"</code> means from each data cell go directly right to a cell at the
edge of the the table, then if the cell is blank go up until a cell that has
a value, which is the header cell.
</p>
</li>
<li> <p><code>"right-down"</code> means from each data cell go directly right to a cell at the
edge of the the table, then if the cell is blank go down until a cell that
has a value, which is the header cell.
</p>
</li>
<li> <p><code>"down"</code> means from each data cell go directly down to a cell at the edge
of the the table, which is the header cell.
</p>
</li>
<li> <p><code>"down-left"</code> means from each data cell go directly down to a cell at the
edge of the the table, then if the cell is blank go left until a cell that
has a value, which is the header cell.
</p>
</li>
<li> <p><code>"down-right"</code> means from each data cell go directly down to a cell at the
edge of the the table, then if the cell is blank go right until a cell that
has a value, which is the header cell.
</p>
</li></ul>



<h3>-ish</h3>

<p>The difference between <code>"up"</code> and <code>"up-ish"</code> (and similar pairs of directions)
is that <code>"up"</code> finds headers directly above the data cell, whereas <code>"up-ish"</code>
matches the nearest header, whether above-left, above-right or directly above
the data cell.  This is useful for matching headers that are not aligned to
the edge of the data cells that they refer to.  There can be a tie in the
directions <code>"up-ish"</code>, <code>"down-ish"</code>, <code>"left-ish"</code> and <code>"right-ish"</code> , causing
<code>NA</code>s to be returned in the place of header values.  Avoid ties by using
<code><a href="#topic+justify">justify()</a></code> first to align header cells to the corner of the data cells they
describe.
</p>

<ul>
<li> <p><code>"up-ish"</code> means the closest cell at the top edge of the table without
crossing a border defined by the <code>border</code> parameter.
</p>
</li>
<li> <p><code>"left-ish"</code> means the closest cell at the left-hand edge of the table
without crossing a border defined by the <code>border</code> parameter.
</p>
</li>
<li> <p><code>"right-ish"</code> means the closest cell at the right-hand edge of the table
without crossing a border defined by the <code>border</code> parameter.
</p>
</li>
<li> <p><code>"down-ish"</code> means the closest cell at the bottom edge of the table without
crossing a border defined by the <code>border</code> parameter.
</p>
</li></ul>



<h3>Tables</h3>

<div class="sourceCode"><pre>+----------------+-------------+-------------+
|                | up-left     | up-left     |
+                +-------------+-------------+
|                | up   | up   | up   | up   |
+----------------+------+------+------+------+
| left-up | left | data | data | data | data |
+         +------+------+------+------+------+
|         | left | data | data | data | data |
+---------+------+------+------+------+------+
| left-up | left | data | data | data | data |
+         +------+------+------+------+------+
|         | left | data | data | data | data |
+---------+------+------+------+------+------+
</pre></div>
<div class="sourceCode"><pre>+-------------+-------------+------------------+
| up-right    | up-right    |                  |
+-------------+-------------+                  +
| up   | up   | up   | up   |                  |
+------+------+------+------+------------------+
| data | data | data | data | right | right-up |
+------+------+------+------+-------+          +
| data | data | data | data | right |          |
+------+------+------+------+-------+----------+
| data | data | data | data | right | right-up |
+------+------+------+------+-------+          +
| data | data | data | data | right |          |
+------+------+------+------+-------+----------+
</pre></div>
<div class="sourceCode"><pre>+-----------+------+------+------+------+------+
|           | left | data | data | data | data |
+           +------+------+------+------+------+
| left-down | left | data | data | data | data |
+-----------+------+------+------+------+------+
|           | left | data | data | data | data |
+           +------+------+------+------+------+
| left-down | left | data | data | data | data |
+-----------+------+------+------+------+------+
|                  | down | down | down | down |
+                  +------+------+------+------+
|                  | down-left   | down-left   |
+-----------+------+-------------+-------------+
</pre></div>
<div class="sourceCode"><pre>'+------+------+------+------+-------+------------+
| data | data | data | data | right |            |
+------+------+------+------+-------+            +
| data | data | data | data | right | right-down |
+------+------+------+------+-------+------------+
| data | data | data | data | right |            |
+------+------+------+------+-------+            +
| data | data | data | data | right | right-down |
+------+------+------+------+-------+------------+
| down | down | down | down |                    |
+------+------+------+------+                    +
|  down-right |  down-right |                    |
+-------------+-------------+--------------------+
</pre></div>
<div class="sourceCode"><pre>+-----------------+----------------------+-----------------------------+
|                 |        up-ish        |               up-ish        |
+                 +----------------------+-----------------------------+
|                 | up   | up     | up   | up   | up   | up     | up   |
+-----------------+------+--------+------+------+------+--------+------+
|          | left | data | data   | data | data | data | data   | data |
+          +------+------+--------+------+------+------+--------+------+
| left-ish | left | data | data   | data | data | data | data   | data |
+          +------+------+--------+------+------+------+--------+------+
|          | left | data | data   | data | data | data | data   | data |
+----------+------+------+--------+------+------+------+--------+------+
|          | left | data | data   | data | data | data | data   | data |
+          +------+------+--------+------+------+------+--------+------+
|          | left | data | data   | data | data | data | data   | data |
+          +------+------+--------+------+------+------+--------+------+
| left-ish | left | data | data   | data | data | data | data   | data |
+          +------+------+--------+------+------+------+--------+------+
|          | left | data | data   | data | data | data | data   | data |
+----------+------+------+--------+------+------+------+-----  -+------+
</pre></div>
<div class="sourceCode"><pre>+------+----------+------+------+------+----------+------+-------+-----------+
| data | data     | data | data | data | data     | data | right |           |
+------+----------+------+------+------+----------+------+-------+           +
| data | data     | data | data | data | data     | data | right | right-ish |
+------+----------+------+------+------+----------+------+-------+           +
| data | data     | data | data | data | data     | data | right |           |
+------+----------+------+------+------+----------+------+-------+-----------+
| data | data     | data | data | data | data     | data | right |           |
+------+----------+------+------+------+----------+------+-------+           +
| data | data     | data | data | data | data     | data | right |           |
+------+----------+------+------+------+----------+------+-------+           +
| data | data     | data | data | data | data     | data | right | right-ish |
+------+----------+------+------+------+----------+------+-------+           +
| data | data     | data | data | data | data     | data | right |           |
+------+----------+------+------+------+----------+------+-------+-----------+
| down | down     | down | down | down | down     | down |                   |
+------+----------+------+------+------+----------+------+                   +
|        down-ish        |               down-ish        |                   |
+------------------------+-------------------------------+-------------------+
</pre></div>


<h3>Legacy directions</h3>

<p>Older versions of unpivotr used different names for the directions, based on
the points of the compass.  These are still supported but are discouraged.
</p>
<div class="sourceCode"><pre>| old direction | new direction |
|---------------|---------------|
| N             | up            |
| NNW           | up-left       |
| NNE           | up-right      |
| W             | left          |
| WNW           | left-up       |
| WSW           | left-down     |
| E             | right         |
| ENE           | right-up      |
| ESE           | right-down    |
| S             | down          |
| SSW           | down-left     |
| SSE           | down-right    |
</pre></div>

<hr>
<h2 id='enhead'>Join data cells to headers</h2><span id='topic+enhead'></span>

<h3>Description</h3>

<p>Data cells in a table are associated with header cells by proximity.
<code><a href="#topic+enhead">enhead()</a></code> joins a data frame of data cells to a data frame of header cells,
choosing the nearest header cells in the given direction.  See <code>?direction</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enhead(data_cells, header_cells, direction, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enhead_+3A_data_cells">data_cells</code></td>
<td>
<p>Data frame of data cells with at least the columns 'row'
and 'column', which are <code>numeric</code> or <code>integer</code>.</p>
</td></tr>
<tr><td><code id="enhead_+3A_header_cells">header_cells</code></td>
<td>
<p>Data frame of header cells with at least the columns
'row' and 'column', which are numeric/integer vectors.</p>
</td></tr>
<tr><td><code id="enhead_+3A_direction">direction</code></td>
<td>
<p>The direction between a data cell and its header, one of
<code>"up"</code>, <code>"right"</code>, <code>"down"</code>, <code>"left"</code>, <code>"up-left"</code>, <code>"up-right"</code>,
<code>"right-up"</code>, <code>"right-down"</code>, <code>"down-right"</code>, <code>"down-left"</code>, <code>"left-down"</code>,
<code>"left-up"</code>, <code>"up-ish"</code>, <code>"down-ish"</code>, <code>"left-ish"</code> and <code>"right-ish"</code>. See
<code>?direction</code>.</p>
</td></tr>
<tr><td><code id="enhead_+3A_drop">drop</code></td>
<td>
<p>Logical vector length 1. Whether data cells that can't be
associated with a header should be dropped.  Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
# Load some pivoted data
(x &lt;- purpose$`up-left left-up`)
# Make a tidy representation
cells &lt;- as_cells(x)
cells &lt;- cells[!is.na(cells$chr), ]
head(cells)
# Select the cells containing the values
data_cells &lt;-
  filter(cells, row &gt;= 3, col &gt;= 3) %&gt;%
  transmute(row, col, count = as.integer(chr))
head(data_cells)
# Select the headers
qualification &lt;-
  filter(cells, col == 1) %&gt;%
  select(row, col, qualification = chr)
age &lt;-
  filter(cells, col == 2) %&gt;%
  select(row, col, age = chr)
gender &lt;-
  filter(cells, row == 1) %&gt;%
  select(row, col, gender = chr)
satisfaction &lt;-
  filter(cells, row == 2) %&gt;%
  select(row, col, satisfaction = chr)
# From each data cell, search for the nearest one of each of the headers
data_cells %&gt;%
  enhead(gender, "up-left") %&gt;%
  enhead(satisfaction, "up") %&gt;%
  enhead(qualification, "left-up") %&gt;%
  enhead(age, "left") %&gt;%
  select(-row, -col)

# The `drop` argument controls what happens when for some cells there is no
# header in the given direction. When `drop = TRUE` (the default), cells that
# can't be joined to a header are dropped.  Otherwise they are kept.
enhead(data_cells, gender, "up")
enhead(data_cells, gender, "up", drop = FALSE)
</code></pre>

<hr>
<h2 id='isolate_sentinels'>Move sentinel values into a separate column leaving NA behind</h2><span id='topic+isolate_sentinels'></span>

<h3>Description</h3>

<p>A sentinel value, takes the place of a value that isn't
available for some reason.  <code><a href="#topic+isolate_sentinels">isolate_sentinels()</a></code> removes these values from a
column of data into a separate column, and optionally converts the data left
behind into an appropriate data type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isolate_sentinels(.data, col, sentinels, into = "sentinel")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isolate_sentinels_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="isolate_sentinels_+3A_col">col</code></td>
<td>
<p>The name of the column of data containing sentinel values.</p>
</td></tr>
<tr><td><code id="isolate_sentinels_+3A_sentinels">sentinels</code></td>
<td>
<p>A vector of sentinel values to be removed.</p>
</td></tr>
<tr><td><code id="isolate_sentinels_+3A_into">into</code></td>
<td>
<p>A name to give the new column of sentinel values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(name = c("Matilda", "Nicholas", "Olivia", "Paul"),
                score = c(10, "confidential", "N/A", 12),
                stringsAsFactors = FALSE)
x
isolate_sentinels(x, score, c("confidential", "N/A"))
isolate_sentinels(x, score, c("confidential", "N/A"), "flag")
</code></pre>

<hr>
<h2 id='justify'>Align one set of cells with another set</h2><span id='topic+justify'></span>

<h3>Description</h3>

<p>If the header cells of a table aren't aligned to the left, right, top or
bottom of the data cells that they describe, then use <code><a href="#topic+justify">justify()</a></code> to re-align
them, using a second set of cells as a guide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>justify(header_cells, corner_cells)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="justify_+3A_header_cells">header_cells</code></td>
<td>
<p>Data frame of data cells with at least the columns 'row'
and 'column', which are <code>numeric</code> or <code>integer</code>.</p>
</td></tr>
<tr><td><code id="justify_+3A_corner_cells">corner_cells</code></td>
<td>
<p>Data frame of header cells with at least the columns
'row' and 'column', which are numeric/integer vectors.  The same length as
<code>header_cells</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>header_cells &lt;- tibble::tibble(row = c(1L, 1L, 1L, 1L),
                               col = c(3L, 5L, 8L, 10L),
                               value = LETTERS[1:4])
corner_cells &lt;- tibble::tibble(row = c(2L, 2L, 2L, 2L),
                               col = c(1L, 4L, 6L, 9L))
justify(header_cells, corner_cells)
</code></pre>

<hr>
<h2 id='merge_cells'>Merge cell values into a single cell by rows or columns</h2><span id='topic+merge_cells'></span><span id='topic+merge_rows'></span><span id='topic+merge_cols'></span>

<h3>Description</h3>

<p>When a single column header is split across cells, merge the
cells with <code><a href="#topic+merge_rows">merge_rows()</a></code> or <code><a href="#topic+merge_cols">merge_cols()</a></code>.  E.g. if a column header &quot;Mean
GDP&quot; is split over two cells, where the top cell has the value &quot;Mean&quot; and the
bottom cell has the value &quot;GDP&quot;, then <code><a href="#topic+merge_rows">merge_rows()</a></code> will combine them into a
single cell with the value &quot;Mean GDP&quot;.
</p>
<p><code><a href="#topic+merge_rows">merge_rows()</a></code> keeps the top cell, and <code><a href="#topic+merge_cols">merge_cols()</a></code> keeps the left-most
cell.  When there are several columns of headers, <code><a href="#topic+merge_rows">merge_rows()</a></code> aligns the
output cells so that they are all in the same row, and similarly
<code><a href="#topic+merge_cols">merge_cols()</a></code> aligns to the same column.
</p>
<p>These functions apply only to cells with character values because it doesn't
make sense to concatenate non-character values.  Convert cell values to
characters first if you need to merge non-character cells.
</p>
<p>Columns other than the one that is concatenated will take the value of the
top or left-most cell.  For example, if <code>cells</code> has the columns <code>data_type</code>
and <code>is_blank</code>, and the top or left-most cell has the values <code>blank</code> or
<code>TRUE</code> in those columns, then the resulting merged cell will also have the
values <code>blank</code> or <code>TRUE</code> in those columns, even if the concatenated value is
no longer blank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_rows(cells, rows, values, collapse = " ")

merge_cols(cells, cols, values, collapse = " ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_cells_+3A_cells">cells</code></td>
<td>
<p>Data frame. The cells of a pivot table, usually the output of
<code><a href="#topic+as_cells">as_cells()</a></code> or <code><a href="tidyxl.html#topic+xlsx_cells">tidyxl::xlsx_cells()</a></code>, or of a subsequent operation on
those outputs.</p>
</td></tr>
<tr><td><code id="merge_cells_+3A_rows">rows</code></td>
<td>
<p>The numbers of the rows to be merged.</p>
</td></tr>
<tr><td><code id="merge_cells_+3A_values">values</code></td>
<td>
<p>The column of <code>cells</code> to use as the values of each cell to be
merged.  Given as a bare variable name.</p>
</td></tr>
<tr><td><code id="merge_cells_+3A_collapse">collapse</code></td>
<td>
<p>A character string to separate the values of each cell.</p>
</td></tr>
<tr><td><code id="merge_cells_+3A_cols">cols</code></td>
<td>
<p>The numbers of the columns to be merged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- tibble::tribble(
~row, ~col, ~data_type,     ~chr,
   1,    1,      "chr",   "Katy",
   2,    1,      "chr",  "Perry",
   3,    1,      "chr",      "a",
   4,    1,      "chr",      "b",
   5,    1,      "chr",      "c",
   2,    2,      "chr",  "Adele",
   3,    2,      "chr",      "d",
   4,    2,      "chr",      "e",
   5,    2,      "chr",      "f",
   1,    3,      "chr", "Ariana",
   2,    3,      "chr", "Grande",
   3,    3,      "chr",      "g",
   4,    3,      "chr",      "h",
   5,    3,      "chr",      "i"
)
rectify(x)
y &lt;- merge_rows(x, 1:2, chr)
rectify(y)
z &lt;- merge_cols(x, 1:2, chr)
rectify(z)
</code></pre>

<hr>
<h2 id='pack'>Pack cell values from separate columns per data type into one list-column</h2><span id='topic+pack'></span><span id='topic+unpack'></span>

<h3>Description</h3>

<p>Pack cell values from separate columns per data type into one list-column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pack(
  cells,
  types = data_type,
  name = "value",
  drop_types = TRUE,
  drop_type_cols = TRUE
)

unpack(cells, values = value, name = "data_type", drop_packed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pack_+3A_cells">cells</code></td>
<td>
<p>A data frame of cells, one row per cell.  For <code><a href="#topic+pack">pack()</a></code> it must
have a column that names, for each cell/row, which of the other columns the
value is in.  For <code><a href="#topic+unpack">unpack()</a></code> it must have a list-column of cell values, where
each element is named according to the data type of the value.</p>
</td></tr>
<tr><td><code id="pack_+3A_types">types</code></td>
<td>
<p>For <code><a href="#topic+pack">pack()</a></code>, the name of the column that that names, for each
cell/row, which of the other columns the value is in.</p>
</td></tr>
<tr><td><code id="pack_+3A_name">name</code></td>
<td>
<p>A string. For <code><a href="#topic+pack">pack()</a></code>, the name to give the new list-column of
values.  For <code><a href="#topic+unpack">unpack()</a></code>, the name to give the new column that will name, for
each cell, which of the other columns the value is in.</p>
</td></tr>
<tr><td><code id="pack_+3A_drop_types">drop_types</code></td>
<td>
<p>For <code><a href="#topic+pack">pack()</a></code>, whether to drop the column named by <code>types</code>.</p>
</td></tr>
<tr><td><code id="pack_+3A_drop_type_cols">drop_type_cols</code></td>
<td>
<p>For <code><a href="#topic+pack">pack()</a></code>, whether to drop the original columns of
cell values.</p>
</td></tr>
<tr><td><code id="pack_+3A_values">values</code></td>
<td>
<p>For <code><a href="#topic+unpack">unpack()</a></code>, the name of the list-column of cell values.</p>
</td></tr>
<tr><td><code id="pack_+3A_drop_packed">drop_packed</code></td>
<td>
<p>For <code><a href="#topic+unpack">unpack()</a></code>, whether to drop the column named by
<code>values</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When cells are represented by rows of a data frame, the values of the cells
will be in different columns according to their data type.  For example, the
value of a cell containing text will be in a column called <code>chr</code> (or
<code>character</code> if it came via tidyxl).  A column called <code>data_type</code> names, for
each cell, which column its value is in.
</p>
<p><code><a href="#topic+pack">pack()</a></code> rearranges the cell values in a different way, so that they are all
in one column, by
</p>

<ol>
<li><p> taking each cell value, from whichever column.
</p>
</li>
<li><p> making it an element of a list.
</p>
</li>
<li><p> naming each element according to the column it came from.
</p>
</li>
<li><p> making the list into a new list-column of the original data frame.
</p>
</li></ol>

<p>By default, the original columns are dropped, and so is the <code>data_type</code>
column.
</p>
<p><code><a href="#topic+unpack">unpack()</a></code> is the complement.
</p>
<p>This can be useful for dropping all columns of <code>cells</code> except the ones that
contain data.  For example, <code><a href="tidyxl.html#topic+xlsx_cells">tidyxl::xlsx_cells()</a></code> returns a very wide data
frame, and to make it narrow you might do:
</p>
<div class="sourceCode"><pre>select(cells, row, col, character, numeric, date)
</pre></div>
<p>But what if you don't know in advance that the data types you need are
<code>character</code>, <code>numeric</code> and <code>date</code>?  You might also need <code>logical</code> and
<code>error</code>.
</p>
<p>Instead, <code><a href="#topic+pack">pack()</a></code> all the data types into a single column, select it, and
then unpack.
</p>
<div class="sourceCode"><pre>pack(cells) %&gt;%
  select(row, col, value) %&gt;%
  unpack()
</pre></div>


<h3>Functions</h3>


<ul>
<li> <p><code>unpack()</code>: Unpack cell values from one list-column into separate columns per data type
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># A normal data frame
w &lt;- data.frame(foo = 1:2,
                bar = c("a", "b"),
                stringsAsFactors = FALSE)
w

# The same data, represented by one row per cell, with integer values in the
# `int` column and character values in the `chr` column.
x &lt;- as_cells(w)
x

# pack() and unpack() are complements
pack(x)
unpack(pack(x))

# Drop non-data columns from a wide data frame of cells from tidyxl
if (require(tidyxl)) {
  cells &lt;- tidyxl::xlsx_cells(system.file("extdata", "purpose.xlsx", package = "unpivotr"))
  cells

  pack(cells) %&gt;%
    dplyr::select(row, col, value) %&gt;%
    unpack()
}
</code></pre>

<hr>
<h2 id='partition'>Divide a grid of cells into partitions containing individual tables</h2><span id='topic+partition'></span><span id='topic+partition_dim'></span>

<h3>Description</h3>

<p>Given the positions of corner cells that mark individual tables in a single
spreadsheet, <code>partion()</code> works out which table cells belong to which corner
cells.  The individual tables can then be worked on independently.
</p>
<p><code>partition()</code> partitions along both dimensions (rows and columns) at once.
<code>partition_dim()</code> partitions along one dimension at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(cells, corners, align = "top_left", nest = TRUE, strict = TRUE)

partition_dim(positions, cutpoints, bound = "upper")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partition_+3A_cells">cells</code></td>
<td>
<p>Data frame or tbl, the cells to be partitioned, from
<code><a href="#topic+as_cells">as_cells()</a></code> or <code><a href="tidyxl.html#topic+xlsx_cells">tidyxl::xlsx_cells()</a></code>.</p>
</td></tr>
<tr><td><code id="partition_+3A_corners">corners</code></td>
<td>
<p>usually a subset of <code>cells</code>, being the corners of individual
tables.  Can also be cells that aren't among <code>cells</code>, in which case see the
<code>strict</code> argument.</p>
</td></tr>
<tr><td><code id="partition_+3A_align">align</code></td>
<td>
<p>Character, the position of the corner cells relative to their
tables, one of <code>"top_left"</code> (default), <code>"top_right"</code>, <code>"bottom_left"</code>,
<code>"bottom_right"</code>.</p>
</td></tr>
<tr><td><code id="partition_+3A_nest">nest</code></td>
<td>
<p>Logical, whether to nest the partitions in a list-column of data
frames.</p>
</td></tr>
<tr><td><code id="partition_+3A_strict">strict</code></td>
<td>
<p>Logical, whether to omit partitions that don't contain a corner
cell.</p>
</td></tr>
<tr><td><code id="partition_+3A_positions">positions</code></td>
<td>
<p>Integer vector, the positions of cells (either the row
position or the column position), which are to be grouped between
cutpoints.</p>
</td></tr>
<tr><td><code id="partition_+3A_cutpoints">cutpoints</code></td>
<td>
<p>Integer vector. The <code>positions</code> will be separated into
groups either side of each cutpoint.</p>
</td></tr>
<tr><td><code id="partition_+3A_bound">bound</code></td>
<td>
<p>One of <code>"upper"</code> or <code>"lower"</code>, controls whether cells that lie
on a cutpoint are should be grouped with cells below or above the cutpoint.
For example, if column 5 is a cutpoint, and a cell is in column 5,
<code>"lower"</code> would group it with cells in columns 1 to 4, whereas <code>"upper"</code>
would group it with cells in columns 6 to 10.  This is so that you can use
cells at the bottom or the right-hand side of a table as the cutpoints
(either of which would be 'upper' bounds because row and column numbers
count from 1 in the top-left row and column).  When <code>"upper"</code>, any
<code>cell_positions</code> above the first cutpoint will be in group 0; when
<code>"lower"</code>, any <code>cell_positions</code> below the final cutpoint will be 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>partition_dim()</code> returns an integer vector, numbering the groups of
cells.  Group 0 represents the cells above the first cutpoint (when <code>bound = "upper"</code>), or below the first cutpoint (when <code>bound = "lower"</code>).  The
other groups are numbered from 1, where group 1 is adjacent to group 0.
</p>
<p><code>partition_dim()</code> returns an integer vector, numbering the groups of cells.
Group 0 represents the cells above the first cutpoint (when <code>bound = "upper"</code>), or below the first cutpoint (when <code>bound = "lower"</code>).  The other
groups are numbered from 1, where group 1 is adjacent to group 0.  Divide a
grid of cells into chunks along both dimensions
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>partition_dim()</code>: Divide a grid of cells into chunks along one dimension
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># The `purpose` dataset, represented in four summary tables
multiples &lt;- purpose$small_multiples
rectify(multiples, character, numeric)

# The same thing in its raw 'melted' form that can be filtered
multiples

# First, find the cells that mark a corner of each table
corners &lt;-
  dplyr::filter(multiples,
                !is.na(character),
                !(character %in% c("Sex", "Value", "Female", "Male")))

# Then find out which cells fall into which partition
partition(multiples, corners)

# You can also use bottom-left corners (or top-right or bottom-right)
bl_corners &lt;- dplyr::filter(multiples, character == "Male")
partition(multiples, bl_corners, align = "bottom_left")

# To complete the grid even when not all corners are supplied, use `strict`
bl_corners &lt;- bl_corners[-1, ]
partition(multiples, bl_corners, align = "bottom_left")
partition(multiples, bl_corners, align = "bottom_left", strict = FALSE)
# Given a set of cells in rows 1 to 10, partition them at the 3rd, 5th and 7th
# rows.
partition_dim(1:10, c(3, 5, 7))

# Given a set of cells in columns 1 to 10, partition them at the 3rd, 5th and
# 7th column.  This example is exactly the same as the previous one, to show
# that the function works the same way on columns as rows.
partition_dim(1:10, c(3, 5, 7))

# Given a set of cells in rows 1 to 10, partition them at the 3rd, 5th and
# 7th rows, aligned to the bottom of the group.
partition_dim(1:10, c(3, 5, 7), bound = "lower")

# Non-integer row/column numbers and cutpoints can be used, even though they
# make no sense in the context of partioning grids of cells.  They are
# rounded towards zero first.
partition_dim(1:10 - .5, c(3, 5, 7))
partition_dim(1:10, c(3, 5, 7) + 1.5)
</code></pre>

<hr>
<h2 id='purpose'>Sense-of-purpose in the 2014 New Zealand General Social Survey</h2><span id='topic+purpose'></span>

<h3>Description</h3>

<p>A dataset containing the self-rated sense-of-purpose of respondents to the
2014 New Zealand General Social Survey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purpose
</code></pre>


<h3>Format</h3>

<p>A list of eight data frames.  The first data frame, <code>Tidy</code>, contains
the raw data in a standard tabular format:
</p>

<ul>
<li> <p><code>Sex</code> Character, two levels
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Age group (Life-stages)&#8288;</code> Character, age-range in years, four levels
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Highest qualification&#8288;</code> Character, five levels
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Sense of purpose&#8288;</code> Character, score-range, two levels and NA
</p>
</li>
<li> <p><code>Value</code> Numeric, number of respondents (weighted? rounded?), has NAs
</p>
</li>
<li> <p><code>Flags</code> Character, metadata flags, two levels and NA
</p>
</li></ul>

<p>The next six data frames are pivot tables of the first data frame.  The
data frames are named by the compass directions that are suggested for
unpivoting them.
</p>
<p>The final data frame is a 'tidy' representation of small-multiple pivot
tables.
</p>


<h3>Details</h3>

<p>The description provided by Statistics New Zealand is below.
</p>
<p>&quot;The 2014 New Zealand General Social Survey (NZGSS) is the fourth of the
survey series. We run the NZGSS every two years and interview around 8,500
people about a range of social and economic outcomes.
</p>
<p>It provides new and redeveloped data about different aspects of people's
lives and their well-being. In particular, the survey provides a view of how
well-being outcomes are distributed across different groups within the New
Zealand population.
</p>
<p>Symbols used in this table:
</p>

<ul>
<li> <p><code>S</code> Data has been suppressed.
</p>
</li>
<li> <p><code>*</code> Relative sampling error of 50 percent or more. Numbers may not add to
the total because 'Don't know' and 'Refused' have been excluded.
</p>
</li></ul>

<p>Data quality:
These statistics have been produced in accordance with the Official
Statistics System principles and protocols for quality. They conform to the
Statistics NZ Methodological Standard for Reporting of Data Quality.&quot;
</p>


<h3>Source</h3>

<p>The data is 'Sense of purpose by highest qualification, age group, and sex,
2014' from the Statistics New Zealand portal NZ.Stat, retrieved on
2016-08-19.  It was found in the section 'People and communities',
'Self-rated well-being (NZGSS)'.  The data was exported in the Excel (.xlsx)
file format and is available at 'extdata/purpose.xlsx' in the package
directory.
</p>

<hr>
<h2 id='rectify'>Display cells as though in a spreadsheet</h2><span id='topic+rectify'></span><span id='topic+print.cell_grid'></span>

<h3>Description</h3>

<p>Takes the 'melted' output of <code>as_cells()</code> or
<code>tidyxl::xlsx_cells()</code> (each row represents one cell) and projects the cells
into their original positions.  By default this prints to the
terminal/console, but with <code>display = "browser"</code> or <code>display = "rstudio"</code> it
will be displayed in the browser or the RStudio viewer pane.
</p>
<p>This is for viewing only; the output is not designed to be used in other
functions.
</p>
<p>Example: The following cells
</p>
<div class="sourceCode"><pre>row col value
  1   1   "a"
  1   2   "b"
  2   1   "c"
  2   2   "d"
</pre></div>
<p>Would be presented as
</p>
<div class="sourceCode"><pre>row/col 1(A) 2(B)
      1 "a"  "b"
      2 "c"  "d"
</pre></div>
<p>The letters in the column names are for comparing this view with a
spreadsheet application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectify(cells, values = NULL, types = data_type, formatters = list())

## S3 method for class 'cell_grid'
print(x, display = "terminal", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rectify_+3A_cells">cells</code></td>
<td>
<p>Data frame or tbl, the cells to be displayed.</p>
</td></tr>
<tr><td><code id="rectify_+3A_values">values</code></td>
<td>
<p>Optional. The column of <code>cells</code> to use as the values of each
cell.  Given as a bare variable name.  If omitted (the default), the <code>types</code>
argument will be used instead.</p>
</td></tr>
<tr><td><code id="rectify_+3A_types">types</code></td>
<td>
<p>The column of <code>cells</code> that names, for each cell, which column to
use for the value of the cell.  E.g.  a cell with a character value will have
<code>"character"</code> in this column.</p>
</td></tr>
<tr><td><code id="rectify_+3A_formatters">formatters</code></td>
<td>
<p>A named list of functions to format cell values for
display, named according to the column that the cell value is in.</p>
</td></tr>
<tr><td><code id="rectify_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+rectify">rectify()</a></code></p>
</td></tr>
<tr><td><code id="rectify_+3A_display">display</code></td>
<td>
<p>One of <code>"terminal"</code> (default), <code>"browser"</code>, <code>"rstudio"</code>.  To
display in the browser you must have the <code>DT</code> package installed.</p>
</td></tr>
<tr><td><code id="rectify_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="base.html#topic+print">print()</a></code></p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>print(cell_grid)</code>: S3 method for class <code>cell_grid</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(name = c("Matilda", "Nicholas"),
                score = c(14L, 10L),
                stringsAsFactors = FALSE)

# This is the original form of the table, which is easy to read.
x

# This is the 'tidy' arrangement that is difficult for humans to read (but
# easy for computers)
y &lt;- as_cells(x, col_names = TRUE)
y

# rectify() projects the cells as a spreadsheet again, for humans to read.
rectify(y)

# You can choose to use a particular column of the data
rectify(y, values = chr)
rectify(y, values = int)

# You can also show which row or which column each cell came from, which
# helps with understanding what this function does.
rectify(y, values = row)
rectify(y, values = col)

# Empty rows and columns up to the first occupied cell are dropped, but the
# row and column names reflect the original row and column numbers.
y$row &lt;- y$row + 5
y$col &lt;- y$col + 5
rectify(y)

# Supply named functions to format cell values for display.
rectify(y, formatters = list(chr = toupper, int = ~ . * 10))
#
# Print in the browser or in the RStudio viewer pane
## Not run: 
  z &lt;- rectify(y)
  print(z, "browser")
  print(z, "rstudio")

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='spatter'>Spread key-value pairs of mixed types across multiple columns</h2><span id='topic+spatter'></span>

<h3>Description</h3>

<p><code><a href="#topic+spatter">spatter()</a></code> is like <code><a href="tidyr.html#topic+spread">tidyr::spread()</a></code> but for when different columns have
different data types.  It works on data that has come via <code><a href="#topic+as_cells">as_cells()</a></code> or
<code><a href="tidyxl.html#topic+xlsx_cells">tidyxl::xlsx_cells()</a></code>, where each row represents one cell of a table, and
the value of the cell is represented in a different column, depending on the
data type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatter(cells, key, values = NULL, types = data_type, formatters = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatter_+3A_cells">cells</code></td>
<td>
<p>A data frame where each row represents a cell, with columns
<code>row</code> and <code>col</code>, usually a column <code>data_type</code>, and additional columns of
cell values.</p>
</td></tr>
<tr><td><code id="spatter_+3A_key">key</code></td>
<td>
<p>The name of the column whose values will become column names</p>
</td></tr>
<tr><td><code id="spatter_+3A_values">values</code></td>
<td>
<p>Optional. The column of <code>cells</code> to use as the value of each
cell.  Given as a bare variable name.  If omitted (the default), the <code>type</code>
argument will be used instead.</p>
</td></tr>
<tr><td><code id="spatter_+3A_types">types</code></td>
<td>
<p>Optional. The column that names, for each row of <code>cells</code>, which
column contains the cell value.  Defaults to <code>data_type</code>.</p>
</td></tr>
<tr><td><code id="spatter_+3A_formatters">formatters</code></td>
<td>
<p>A named list of functions for formatting particular data
types, named by the data type (the name of the column of <code>cells</code> that
contains the cell value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A tidy representation of cells of mixed data types
x &lt;- data.frame(stringsAsFactors = FALSE,
        row = c(1L, 1L, 2L, 2L, 3L, 3L, 4L, 4L),
        col = c(1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L),
  data_type = c("character", "character", "character", "numeric", "character",
                "numeric", "character", "numeric"),
  character = c("Name", "Age", "Matilda", NA, "Nicholas", NA, "Olivia", NA),
    numeric = c(NA, NA, NA, 1, NA, 3, NA, 5))
x

# How it would look in a spreadsheet
rectify(x)

# How it looks after treating the cells in row 1 as headers
y &lt;- behead(x, "N", header)
y$col &lt;- NULL # Drop the 'col' column
y

# At this point you might want to do tidyr::spread(), but it won't work because
# you want to use both the `character` and `numeric` columns as the values.
tidyr::spread(y, header, numeric)
tidyr::spread(y, header, character)
spatter(y, header)

# The difference between spatter() and tidyr::spread() is that spatter()
# needs to know which data-type to use for each cell beneath the headers.  By
# default, it looks at the `data_type` column to decide, but you can change
# that with the `types` argument.
y %&gt;%
  dplyr::select(-data_type, -numeric) %&gt;%
  dplyr::mutate(data_type_2 = "character") %&gt;%
  spatter(header, types = data_type_2)

# Alternatively you can name one specific column to use for the cell values.
y %&gt;%
  dplyr::mutate(foo = letters[1:6]) %&gt;%
  dplyr::select(header, row, foo) %&gt;%
  spatter(header, values = foo)

# The column used for the values is consumed before the spread occurs. If
# it's necessary for demarking the rows, then make a copy of it first,
# otherwise you'll get an error like "Duplicate identifiers for rows ..."
y %&gt;%
  dplyr::mutate(row2 = row) %&gt;%
  dplyr::select(row, header, row2) %&gt;%
  spatter(header, values = row2)

# Like tidyr::spread(), you need to discard extraneous columns beforehand.
# Otherwise you can get more rows out than you want.
y$extra &lt;- 11:16
spatter(y, header)

# pack() is an easy way to keep just the columns you need, without knowing
# in advance which data-type columns you need.  This examples adds a new
# column, which is then removed by the pack-unpack sequence without having to
# mention it by name.
x$extra &lt;- 11:18
x %&gt;%
  pack() %&gt;%
  dplyr::select(row, col, value) %&gt;%
  unpack()

# spatter() automatically converts data types so that they can coexist in the
# same column.  Ordered factors in particular will always be coerced to
# unordered factors.

# You can control data type conversion by supplying custom functions, named
# by the data type of the cells they are to convert (look at the `data_type`
# column).  If your custom functions aren't sufficient to avoid the need for
# coercion, then they will be overridden.
spatter(y, header,
        formatters = list(character = ~ toupper(.), numeric = as.complex))
</code></pre>

<hr>
<h2 id='tidy_table'>Tokenize data frames into a tidy 'melted' structure</h2><span id='topic+tidy_table'></span>

<h3>Description</h3>

<p><code><a href="#topic+tidy_table">tidy_table()</a></code> will be deprecated.  Use <code><a href="#topic+as_cells">as_cells()</a></code> instead.
</p>
<p>For certain non-rectangular data formats, it can be useful to parse
the data into a melted format where each row represents a single
token.
</p>
<p>Data frames represent data in a tabular structure.  <code>tidy_table</code> takes the
row and column position of each 'cell', and returns that information in a new
data frame, alongside the content and type of each cell.
</p>
<p>This makes it easier to deal with complex or non-tabular data (e.g. pivot
tables) that have been imported into R as data frames.  Once they have been
'melted' by <code><a href="#topic+tidy_table">tidy_table()</a></code>, you can use functions like <code><a href="#topic+behead">behead()</a></code> and
<code><a href="#topic+spatter">spatter()</a></code> to reshape them into conventional, tidy, unpivoted structures.
</p>
<p>For HTML tables, the content of each cell is returned as a standalone HTML
string that can be further parsed with tools such as the rvest package.  This
is particularly useful when an HTML cell itself contains an HTML table, or
contains both text and a URL.  If the HTML itself is poorly formatted, try
passing it through the
<a href="https://CRAN.R-project.org/package=htmltidy">htmltidy</a> package first.
</p>
<p>This is an S3 generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_table(x, row_names = FALSE, col_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_table_+3A_x">x</code></td>
<td>
<p>A data.frame or an HTML document</p>
</td></tr>
<tr><td><code id="tidy_table_+3A_row_names">row_names</code></td>
<td>
<p>Whether to treat the row names as cells, Default: FALSE</p>
</td></tr>
<tr><td><code id="tidy_table_+3A_col_names">col_names</code></td>
<td>
<p>Whether to treat the column names  as cells, Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the following columns:
</p>

<ul>
<li> <p><code>row</code> and <code>col</code> (integer) giving the original position of the 'cells'
</p>
</li>
<li><p> any relevant columns for cell values in their original types: <code>chr</code>,
<code>cpl</code>, <code>dbl</code>, <code>fct</code>, <code>int</code>, <code>lgl</code>, <code>list</code>, and <code>ord</code>
</p>
</li>
<li> <p><code>data_type</code> to specify for each cell which of the above columns (<code>chr</code>
etc.) the value is in.
</p>
</li></ul>

<p>The columns <code>fct</code> and <code>ord</code> are, like <code>list</code>, list-columns (each element is
independent) to avoid factor levels clashing.  For HTML tables, the column
<code>html</code> gives the HTML string of the original cell.
</p>
<p>Row and column names, when present and required by <code>row_names = TRUE</code> or
<code>col_names = TRUE</code>, are treated as though they were cells in the table, and
they appear in the <code>chr</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(a = c(10, 20),
                b = c("foo", "bar"),
                stringsAsFactors = FALSE)
x
tidy_table(x)
tidy_table(x, row_names = TRUE)
tidy_table(x, col_names = TRUE)

# 'list' columns are undisturbed
y &lt;- data.frame(a = c("a", "b"), stringsAsFactors = FALSE)
y$b &lt;- list(1:2, 3:4)
y
tidy_table(y)

# Factors are preserved by being wrapped in lists so that their levels don't
# conflict.  Blanks are NULLs.
z &lt;- data.frame(x = factor(c("a", "b")),
                y = factor(c("c", "d"), ordered = TRUE))
tidy_table(z)
tidy_table(z)$fct
tidy_table(z)$ord

# HTML tables can be extracted from the output of xml2::read_html().  These
# are returned as a list of tables, similar to rvest::html_table().  The
# value of each cell is its standalone HTML string, which can contain
# anything -- even another table.

colspan &lt;- system.file("extdata", "colspan.html", package = "unpivotr")
rowspan &lt;- system.file("extdata", "rowspan.html", package = "unpivotr")
nested &lt;- system.file("extdata", "nested.html", package = "unpivotr")

## Not run: 
browseURL(colspan)
browseURL(rowspan)
browseURL(nestedspan)

## End(Not run)

tidy_table(xml2::read_html(colspan))
tidy_table(xml2::read_html(rowspan))
tidy_table(xml2::read_html(nested))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
