<!DOCTYPE html><html lang="en"><head><title>Help for package PopulateR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PopulateR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ABMToCova'><p>Creates the four data frames of weighted contact pairs for use in Covasim</p></a></li>
<li><a href='#addemp'><p>Add employers to people in employment</p></a></li>
<li><a href='#addind'><p>Add a variable indicating whether the person is in education, or has left education</p></a></li>
<li><a href='#addnetwork'><p>Create a social network for people in a population</p></a></li>
<li><a href='#addschool'><p>Match school children to schools</p></a></li>
<li><a href='#AdultsNoID'><p>Non-partnered synthetic people</p></a></li>
<li><a href='#agedis'><p>Add a sex/age structure to a data frame of grouped ages</p></a></li>
<li><a href='#AllEmployers'><p>Employers and employees, by industry</p></a></li>
<li><a href='#BadRels'><p>Synthetic people restricted to an age range</p></a></li>
<li><a href='#createemp'><p>Create employers, each with employee counts</p></a></li>
<li><a href='#diffsample'><p>Sample from groups, when the sample size for each group is different</p></a></li>
<li><a href='#EmployerSet'><p>Synthetic employers and their employee counts</p></a></li>
<li><a href='#fastmatch'><p>Create couples using a weighted age group structure</p></a></li>
<li><a href='#fixhours'><p>Reallocates working hours between people in education and people not in education</p></a></li>
<li><a href='#fixrelations'><p>Provide an age structure to relationship status, estimated from age groups</p></a></li>
<li><a href='#GroupInfo'><p>The proportion of people in a relationship, by age band within sex</p></a></li>
<li><a href='#InitialDataframe'><p>People in age groups, in the Timaru District</p></a></li>
<li><a href='#interdiff'><p>Interpolate ages from age group medians</p></a></li>
<li><a href='#IntoSchools'><p>Four person households, with a school status for each person</p></a></li>
<li><a href='#LeftSchool'><p>School leavers</p></a></li>
<li><a href='#NetworkMatrix'><p>The number of contacts for 5000 person</p></a></li>
<li><a href='#other'><p>Match people into new households</p></a></li>
<li><a href='#otherNum'><p>Match people into existing households</p></a></li>
<li><a href='#pairbeta4'><p>Pair two people, using a four-parameter beta distribution, into households</p></a></li>
<li><a href='#pairbeta4Num'><p>Pair two people, using a four-parameter beta distribution, households already exist</p></a></li>
<li><a href='#pairmult'><p>Create many-to-one pairs of people and place them into households</p></a></li>
<li><a href='#pairmultNum'><p>Create many-to-one pairs, when there are existing households</p></a></li>
<li><a href='#pairnorm'><p>Pair two people, using either a normal or skew-normal distribution, into households</p></a></li>
<li><a href='#pairnormNum'><p>Pair two people, using either a normal or skew-normal distribution, households already exist</p></a></li>
<li><a href='#Ppl4networks'><p>Synthetic people living in the Timaru District</p></a></li>
<li><a href='#RegionalStructure'><p>Sex/Age pyramid for teenagers in the Canterbury Region</p></a></li>
<li><a href='#SchoolsToUse'><p>Schools and their roll counts</p></a></li>
<li><a href='#SingleAges'><p>Sex/Age pyramid data for Timaru District</p></a></li>
<li><a href='#Township'><p>Simulated township</p></a></li>
<li><a href='#WorkingAdolescents'><p>Adolescents with a school status and employment hours</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Create Data Frames for the Micro-Simulation of Human Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michelle Gosse &lt;michelle.a.gosse@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for constructing detailed synthetic human populations
     from frequency tables. Add ages based on age groups and sex, create households, add 
     students to education facilities, create employers, add employers to employees, and 
     create interpersonal networks.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brainGraph (&ge; 3.1.0), data.table (&ge; 1.16.2), dplyr (&ge;
1.1.4), igraph (&ge; 2.1.1), magrittr (&ge; 2.0.3), PearsonDS (&ge;
1.3.1), plyr (&ge; 1.8.9), rlang (&ge; 1.1.4), sn (&ge; 2.1.1), tidyr
(&ge; 1.3.1), tidyselect (&ge; 1.2.1), withr (&ge; 3.0.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/programgirl/PopulateR">https://github.com/programgirl/PopulateR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/programgirl/PopulateR/issues">https://github.com/programgirl/PopulateR/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-26 08:07:08 UTC; michelle</td>
</tr>
<tr>
<td>Author:</td>
<td>Michelle Gosse [aut, cre, cph],
  Jonathan Marshall [aut],
  Mark Bebbington [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-29 18:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ABMToCova'>Creates the four data frames of weighted contact pairs for use in Covasim</h2><span id='topic+ABMToCova'></span>

<h3>Description</h3>

<p>Creates the household, school, workplace, and contacts layers, from ABMPop, for use with the Python package Covasim. A 1xn data frame of ages is also created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ABMToCova(
  ABMPop,
  ABMID,
  ABMAge,
  place1,
  place2,
  ECE = TRUE,
  PSchool = TRUE,
  SSchool = TRUE,
  contacts = NULL,
  excludeDF = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ABMToCova_+3A_abmpop">ABMPop</code></td>
<td>
<p>The agent-based modelling data frame.</p>
</td></tr>
<tr><td><code id="ABMToCova_+3A_abmid">ABMID</code></td>
<td>
<p>The variable containing the unique identifier for each person, in the ABMPop data frame.</p>
</td></tr>
<tr><td><code id="ABMToCova_+3A_abmage">ABMAge</code></td>
<td>
<p>The variable containing the ages, in the in the ABMPop data frame.</p>
</td></tr>
<tr><td><code id="ABMToCova_+3A_place1">place1</code></td>
<td>
<p>The variable containing the Household ID.</p>
</td></tr>
<tr><td><code id="ABMToCova_+3A_place2">place2</code></td>
<td>
<p>The variable containing the school and workplace IDs.</p>
</td></tr>
<tr><td><code id="ABMToCova_+3A_ece">ECE</code></td>
<td>
<p>Are ECE centres open? Default is TRUE, change to FALSE if ECEs are to close.</p>
</td></tr>
<tr><td><code id="ABMToCova_+3A_pschool">PSchool</code></td>
<td>
<p>Are primary schools open? Default is TRUE, change to FALSE if primary schools are to close.</p>
</td></tr>
<tr><td><code id="ABMToCova_+3A_sschool">SSchool</code></td>
<td>
<p>Are secondary schools open? Default is TRUE, change to FALSE if secondary schools are to close.</p>
</td></tr>
<tr><td><code id="ABMToCova_+3A_contacts">contacts</code></td>
<td>
<p>A data frame consisting of existing contact pairs. The first two variables define the two people in the pair.</p>
</td></tr>
<tr><td><code id="ABMToCova_+3A_excludedf">excludeDF</code></td>
<td>
<p>A data frame of industries to exclude. This must be the relevant IndNum variable in the ABMPop data frame. If this data frame is not included, all industries will be represented in the output data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three restrictions for use. First, the place2 codes for preschool, primary school, and secondary school must be set to &quot;P801000&quot;, &quot;P802100&quot;, and &quot;P802200&quot;, respectively. Second, at least one school type must be &quot;TRUE&quot; as Covasim requires a school layer. Third, the place2 value for people who are not in school, and not in a workplace, must be &quot;Not employed&quot;.
</p>


<h3>Value</h3>

<p>A data frame of the household, school, workplace, contact layers, and people's ages, for use in Covasim.
</p>

<hr>
<h2 id='addemp'>Add employers to people in employment</h2><span id='topic+addemp'></span>

<h3>Description</h3>

<p>Creates a data frame of people and matching employers, if employed. Two data frames are required: one for the people and one for the employers. For people not in employment, a user-supplied missing value is used instead of the employer information.
A numeric or ordered factor for working hours is required. The minimum value for being in employment must be specified. Anyone coded under this value will be treated as unemployed. Thus, pre-cleaning the people data frame is not required.
The employer data frame can be either a summary in the form of the number of employees by employer. The other option is that each row represents a vacancy for an employee. Thus, an employer with 5 employees may be represented as either: a single row with an employee count of 5, or 5 rows with an employee count of 1 in each row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addemp(
  employers,
  empid,
  empcount,
  people,
  pplid,
  wrkhrs,
  hoursmin,
  missval = NA,
  userseed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addemp_+3A_employers">employers</code></td>
<td>
<p>The data frame containing employer data.</p>
</td></tr>
<tr><td><code id="addemp_+3A_empid">empid</code></td>
<td>
<p>The variable containing the unique identifier for each employer.</p>
</td></tr>
<tr><td><code id="addemp_+3A_empcount">empcount</code></td>
<td>
<p>The variable containing the count of employees for each employer.</p>
</td></tr>
<tr><td><code id="addemp_+3A_people">people</code></td>
<td>
<p>The data frame containing the people that require employers.</p>
</td></tr>
<tr><td><code id="addemp_+3A_pplid">pplid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the people data frame.</p>
</td></tr>
<tr><td><code id="addemp_+3A_wrkhrs">wrkhrs</code></td>
<td>
<p>The variable containing the hours worked by each person. Must be an ordered factor or numeric. If the variable is an ordered factor, the levels/values must be ascending for hours worked. This is output as an ordered factor.</p>
</td></tr>
<tr><td><code id="addemp_+3A_hoursmin">hoursmin</code></td>
<td>
<p>The wrkhrs value representing the minimum number of hours worked (numeric) or lowest factor level/number. Any wrkhrs value lower than this number/level will be treated as unemployed.</p>
</td></tr>
<tr><td><code id="addemp_+3A_missval">missval</code></td>
<td>
<p>The value that will be used to replace any NA results in the output data frame. If not supplied, NA will be used for all employer-related variables for the non-working people.</p>
</td></tr>
<tr><td><code id="addemp_+3A_userseed">userseed</code></td>
<td>
<p>The user-defined seed for reproducibility. If left blank the normal set.seed() function will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of the people, with an employer ID attached to each person. Unemployed people will have an employer ID of NA, or the value specified by missval. All columns in the employers data frame, except for the employee counts, are included in the output data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("dplyr")

EmployedPeople &lt;- addemp(EmployerSet, empid = "Company", empcount = "NumEmployees", Township,
                          pplid = "ID", wrkhrs = "HoursWorked", hoursmin = 2, missval = "NA",
                          userseed = 4)
</code></pre>

<hr>
<h2 id='addind'>Add a variable indicating whether the person is in education, or has left education</h2><span id='topic+addind'></span>

<h3>Description</h3>

<p>Creates a data frame with a variable indicating whether the person is a student, or is not in education. This is an factor with two levels. Pre-cleaning so that only people inside the student age range is not required.
Three data frames are required. The first is the data frame that contains the people (&quot;people&quot;) to whom the indicator will be applied. The other two data frames are counts: school leaver counts (&quot;leavers&quot;), and the sex/age pyramid counts (&quot;pyramid&quot;) that apply to the school leaver counts. As cumulative proportions of school leavers are calculated, the leavers data frames must contain multiple years of data. For example, if the minimum school leaving age is 17 and the maximum age is 18, then there must be two years of data in the leavers data frame. The pyramid data frame contains the sex/age counts for the relevant year. For example, if the people data frame is based on 2021 data frame, then the pyramid data frame should be the counts for 2021, and the value for pplyear would be 2021.
The variables specifying sex can be numeric, character, or factor. The sole requirement is that the same code is used in all three data frames. For example, if &quot;F&quot; and &quot;M&quot; are used in the adolescents data frame to denote sex, then &quot;F&quot; and &quot;M&quot; are the codes required in both the leavers and pyramid data frames. Any number of values can be used, so long as they are unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addind(
  people,
  pplid,
  pplsx,
  pplage,
  pplyear,
  minedage = NULL,
  maxedage = NULL,
  leavers,
  lvrsx,
  lvrage,
  lvryear,
  lvrcount,
  pyramid,
  pyrsx,
  pyrage,
  pyrcount,
  stvarname = "Status",
  verbose = FALSE,
  userseed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addind_+3A_people">people</code></td>
<td>
<p>A data frame containing individual people.</p>
</td></tr>
<tr><td><code id="addind_+3A_pplid">pplid</code></td>
<td>
<p>The variable containing the unique identifier for each person, in the people data frame</p>
</td></tr>
<tr><td><code id="addind_+3A_pplsx">pplsx</code></td>
<td>
<p>The variable containing the codes for sex, in the people data frame.</p>
</td></tr>
<tr><td><code id="addind_+3A_pplage">pplage</code></td>
<td>
<p>The variable containing the ages, in the people data frame.</p>
</td></tr>
<tr><td><code id="addind_+3A_pplyear">pplyear</code></td>
<td>
<p>The year associated with the people data frame.</p>
</td></tr>
<tr><td><code id="addind_+3A_minedage">minedage</code></td>
<td>
<p>The minimum age that a person, normally a child, can enter education.</p>
</td></tr>
<tr><td><code id="addind_+3A_maxedage">maxedage</code></td>
<td>
<p>The maximum age that a person, normally an adolescent, can leave education.</p>
</td></tr>
<tr><td><code id="addind_+3A_leavers">leavers</code></td>
<td>
<p>A data frame containing the counts, by sex, age, and year, of the people who have left education.</p>
</td></tr>
<tr><td><code id="addind_+3A_lvrsx">lvrsx</code></td>
<td>
<p>The variable containing the codes for sex, in the leavers data.</p>
</td></tr>
<tr><td><code id="addind_+3A_lvrage">lvrage</code></td>
<td>
<p>The variable containing the codes for sex, in the leavers data.</p>
</td></tr>
<tr><td><code id="addind_+3A_lvryear">lvryear</code></td>
<td>
<p>The variable containing the year for the lvrcount.</p>
</td></tr>
<tr><td><code id="addind_+3A_lvrcount">lvrcount</code></td>
<td>
<p>The variable containing the counts for each sex/age combination in the leavers data.</p>
</td></tr>
<tr><td><code id="addind_+3A_pyramid">pyramid</code></td>
<td>
<p>A data frame containing the sex/age pyramid to be used.</p>
</td></tr>
<tr><td><code id="addind_+3A_pyrsx">pyrsx</code></td>
<td>
<p>The variable containing the codes for sex, in the pyramid data.</p>
</td></tr>
<tr><td><code id="addind_+3A_pyrage">pyrage</code></td>
<td>
<p>The variable containing the ages, in the pyramid data.</p>
</td></tr>
<tr><td><code id="addind_+3A_pyrcount">pyrcount</code></td>
<td>
<p>The variable containing the counts for each sex/age combination, in the pyramid data</p>
</td></tr>
<tr><td><code id="addind_+3A_stvarname">stvarname</code></td>
<td>
<p>The name of the variable to contain the education status. The output is &quot;Y&quot; for those still in education and &quot;N&quot; for those not in education.</p>
</td></tr>
<tr><td><code id="addind_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, the proportion of students who have left school by age and sex will be printed to the console. Default is FALSE</p>
</td></tr>
<tr><td><code id="addind_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The proportion of people, by age and sex, who have left school is printed to the console.
</p>


<h3>Value</h3>

<p>A data frame of an observations, with an added column that contains the education status of each person.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WithInd &lt;- addind(Township, pplid = "ID", pplsx = "Sex", pplage = "Age", pplyear = 2018,
                  minedage = 5, maxedage = 18, LeftSchool, lvrsx = "Sex", lvrage = "Age",
                  lvryear = "YearLeft", lvrcount = "Total", RegionalStructure,
                  pyrsx = "Sex", pyrage = "Age", pyrcount = "Value", stvarname = "Status",
                  verbose = TRUE, userseed = 4)
</code></pre>

<hr>
<h2 id='addnetwork'>Create a social network for people in a population</h2><span id='topic+addnetwork'></span>

<h3>Description</h3>

<p>Creates social networks between people, based on age differences. A data frame of people with ages is required. These are the people who will have social relationships between each other. A a 1x n matrix of counts must also be supplied, where n is the number of rows in the people data frame. As person-to-person pairs are constructed, the sum of the matrix counts must be even. If it is not, the function will randomly select one person's social network size from the matrix and add 1 to it. If this correction happens, an explanation, including the index position of the count, will be printed to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addnetwork(
  people,
  pplid,
  pplage,
  netmax,
  sdused = 0,
  probsame = 0.5,
  userseed = NULL,
  numiters = 1e+06,
  usematrix = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addnetwork_+3A_people">people</code></td>
<td>
<p>A data frame containing people to be matched to each other using social networks.</p>
</td></tr>
<tr><td><code id="addnetwork_+3A_pplid">pplid</code></td>
<td>
<p>The variable for each person's unique ID.</p>
</td></tr>
<tr><td><code id="addnetwork_+3A_pplage">pplage</code></td>
<td>
<p>The variable for each person's age.</p>
</td></tr>
<tr><td><code id="addnetwork_+3A_netmax">netmax</code></td>
<td>
<p>A data frame containing the 1-dimensional matrix of network sizes. Must contain only integers and be the same length as the people data frame.</p>
</td></tr>
<tr><td><code id="addnetwork_+3A_sdused">sdused</code></td>
<td>
<p>The standard deviation for the age differences between two people.</p>
</td></tr>
<tr><td><code id="addnetwork_+3A_probsame">probsame</code></td>
<td>
<p>The probability that a friend of a friend is also a friend. For example, if A and B and friends, and B and C are friends, this is the probability that C is also a friend of A.</p>
</td></tr>
<tr><td><code id="addnetwork_+3A_userseed">userseed</code></td>
<td>
<p>The user-defined seed for reproducibility. If left blank, the normal set.seed() function will be used.</p>
</td></tr>
<tr><td><code id="addnetwork_+3A_numiters">numiters</code></td>
<td>
<p>The maximum number of iterations used to construct the coupled data frame. This has a default value of 100, and is the stopping rule if the algorithm does not converge.</p>
</td></tr>
<tr><td><code id="addnetwork_+3A_usematrix">usematrix</code></td>
<td>
<p>If an adjacency matrix is output instead of an igraph object. Default is FALSE so an igraph object is output. If TRUE is used, the n x n dgCMatrix is output.</p>
</td></tr>
<tr><td><code id="addnetwork_+3A_verbose">verbose</code></td>
<td>
<p>Whether a notification is printed to the console if the number of contacts must be increased by one. Notification is that it has occurred, where the value has been increased, and the original and new number of contacts. The default is FALSE, so no information will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A normal distribution is used, using the age differences between the pairs. This is centred on 0, i.e. the people in the pair are the same age. If people B and C are in person A's network, the value of probsame is used to determine the likelihood that people B and C know each other. The larger this probability, the more likely that people in one person's network know each other, compared to random construction of a network between them.
</p>
<p>The two options for output are a dgCMatrix or an igraph. The dgCMatrix is output as n x n. For a large data frame of people, this will be a large and sparse matrix, which may not be completed due to RAM limitations. The igraph output only contains the pairs, and should be a smaller object compared to the dgCMatrix.
</p>


<h3>Value</h3>

<p>Either an igraph of social networks, or a dgCMatrix of n x n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("dplyr")

# smaller sample for visualisation
set.seed(2) # small datasets can cause problems if a random seed is used for sampling
 SmallDemo &lt;- Township %&gt;%
  filter(between(Age, 20, 29)) %&gt;%
  slice_sample(n = 20)
  Smallnetwork &lt;- rpois(n = nrow(SmallDemo), lambda = 1.5)
  NetworkSmallN &lt;- addnetwork(SmallDemo, "ID", "Age", Smallnetwork, sdused=2,
                              probsame = .5, userseed=4, numiters = 10)
 # plot(NetworkSmallN)
</code></pre>

<hr>
<h2 id='addschool'>Match school children to schools</h2><span id='topic+addschool'></span>

<h3>Description</h3>

<p>Creates a data frame of people and matching schools. By default, all similarly-aged students in the same household will be matched to the same school. If one student is matched to a same-sex school, then all similarly aged students will also be matched to a same-sex school. This includes opposite-sex children, with boys attending a same-sex boys school, and girls attending a same-sex girls school.
Two data frames are required: one for the people (&quot;people) and one for the schools (&quot;schools&quot;).
In the &quot;people&quot; data frame, a numeric or ordered factor for school status is required. The smallest value/level will be treated as the code for non-students. If one value is used, everyone in the data frame will be allocated a school. Thus, pre-cleaning a data frame is not required.
The &quot;schools&quot; data frame must be a summary in the form of roll counts by age within school. Each row is one age only. For example, if a school has children aged 5 to 9 years, there should be 5 rows. Any combination of co-educational and single-sex schools can be used,  and the relevant value must be on each row of the schools&quot; data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addschool(
  people,
  pplid,
  pplage,
  pplsx,
  pplst = NULL,
  hhid = NULL,
  schools,
  schid,
  schage,
  schroll,
  schtype,
  schmiss = 0,
  sameprob = 1,
  userseed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addschool_+3A_people">people</code></td>
<td>
<p>A data frame containing individual people.</p>
</td></tr>
<tr><td><code id="addschool_+3A_pplid">pplid</code></td>
<td>
<p>The variable containing the unique identifier for each person, in the people data frame.</p>
</td></tr>
<tr><td><code id="addschool_+3A_pplage">pplage</code></td>
<td>
<p>The variable containing the ages, in the people data frame.</p>
</td></tr>
<tr><td><code id="addschool_+3A_pplsx">pplsx</code></td>
<td>
<p>The variable containing the codes for sex, in the people data frame.</p>
</td></tr>
<tr><td><code id="addschool_+3A_pplst">pplst</code></td>
<td>
<p>The school status variable in the people data frame. Only two numeric values/factor levels can be used. The smallest number/level is the code for people not in school.</p>
</td></tr>
<tr><td><code id="addschool_+3A_hhid">hhid</code></td>
<td>
<p>The household identifier variable, in the people data frame.</p>
</td></tr>
<tr><td><code id="addschool_+3A_schools">schools</code></td>
<td>
<p>A data frame containing the schools.</p>
</td></tr>
<tr><td><code id="addschool_+3A_schid">schid</code></td>
<td>
<p>The variable containing the unique identifier for each school, in the schools data frame.</p>
</td></tr>
<tr><td><code id="addschool_+3A_schage">schage</code></td>
<td>
<p>The variable containing the ages, in the schools data frame.</p>
</td></tr>
<tr><td><code id="addschool_+3A_schroll">schroll</code></td>
<td>
<p>The variable containing the number of places available for people at that school age, within the school.</p>
</td></tr>
<tr><td><code id="addschool_+3A_schtype">schtype</code></td>
<td>
<p>The variable that indicates whether the school is co-educational or single-sex. The expected value for a co-educational school is &quot;C&quot;. The codes for female and male must be the same as in the people data frame.</p>
</td></tr>
<tr><td><code id="addschool_+3A_schmiss">schmiss</code></td>
<td>
<p>The school identifier value that will be given to those people not in school. If left blank, the default value is 0. If the school IDs are numeric in the schools data frame, a numeric missing value must be supplied.</p>
</td></tr>
<tr><td><code id="addschool_+3A_sameprob">sameprob</code></td>
<td>
<p>The probability that students from the same household will be at the same school, given age (and sex if there are same-sex schools). Results depend on the number of students in each household, and student ages, combined with the sizes of the school rolls. Value must be between 0 and 1. The default value is 1.</p>
</td></tr>
<tr><td><code id="addschool_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not,the normal set.seed() function will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two data frames, as a list. $Population contains the synthetic population with the schools added. $Schools contains the remaining roll counts for the schools.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# children in the same household will be added to the same school, if possible with a .8 probability
SchoolsAdded &lt;- addschool(IntoSchools, pplid = "ID", pplage = "Age", pplsx = "SexCode",
                          pplst = "SchoolStatus", hhid = "HouseholdID", SchoolsToUse,
                          schid = "School.Name", schage = "AgeInRoll", schroll = "RollCount",
                          schtype = "Gender", schmiss = 0, sameprob = .8, userseed = 4)

Population &lt;- SchoolsAdded$Population
Schools &lt;- SchoolsAdded$Schools
</code></pre>

<hr>
<h2 id='AdultsNoID'>Non-partnered synthetic people</h2><span id='topic+AdultsNoID'></span>

<h3>Description</h3>

<p>A subset of people from the Township data frame, aged 20 years and older with a relationship status of &quot;NonPartnered&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdultsNoID
</code></pre>


<h3>Format</h3>

<p>A data frame of 2,213 rows and 5 variables:
</p>

<dl>
<dt>Sex</dt><dd><p>SEither Male or Female</p>
</dd>
<dt>Relationship</dt><dd><p>Relationship status of the person</p>
</dd>
<dt>ID</dt><dd><p>The unique identifier for the person</p>
</dd>
<dt>Age</dt><dd><p>The age of the person</p>
</dd>
<dt>HoursWorked</dt><dd><p>The number of hours worked in employment, per week</p>
</dd>
</dl>


<hr>
<h2 id='agedis'>Add a sex/age structure to a data frame of grouped ages</h2><span id='topic+agedis'></span>

<h3>Description</h3>

<p>Adds an age variable to a data frame that contains age groups, based on age group within sex.
Two data frames are required: the data frame that contains individuals with age bands (&quot;individuals&quot;), and a data frame used as the basis for constructing a sex/age pyramid (&quot;pyramid&quot;).
The individuals data frame requires two columns relating to the age groups. One is the minimum age in the age group. The second is the maximum age in the age group. For example, the age group 0 - 4 years would have 0 as the minimum age value and 4 as the maximum age value. Each person in the individuals data frame must have both the minimum and maximum age variables populated.
The pyramid data frame must contain counts by sex/age in the population of interest.
The variables specifying sex can be numeric, character, or factor. The sole requirement is that the codes must match.  For example, if &quot;F&quot; and &quot;M&quot; are used in the individuals data frame to denote sex, then &quot;F&quot; and &quot;M&quot; are the codes required in the pyramid data frame. Any number of sex code values can be used, so long as they are unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agedis(
  individuals,
  indsx,
  minage,
  maxage,
  pyramid,
  pyrsx,
  pyrage,
  pyrcount,
  agevarname,
  userseed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agedis_+3A_individuals">individuals</code></td>
<td>
<p>A data frame containing observations with grouped ages. These are the observations to which the sex/age pyramid is applied.</p>
</td></tr>
<tr><td><code id="agedis_+3A_indsx">indsx</code></td>
<td>
<p>The variable containing the codes for sex, in the individuals data frame.</p>
</td></tr>
<tr><td><code id="agedis_+3A_minage">minage</code></td>
<td>
<p>The variable containing the minimum age for the age group, in the individuals data frame.</p>
</td></tr>
<tr><td><code id="agedis_+3A_maxage">maxage</code></td>
<td>
<p>The variable containing the maximum age for the age group, in the individuals data frame.</p>
</td></tr>
<tr><td><code id="agedis_+3A_pyramid">pyramid</code></td>
<td>
<p>A data frame containing the sex/age pyramid to be used.</p>
</td></tr>
<tr><td><code id="agedis_+3A_pyrsx">pyrsx</code></td>
<td>
<p>The variable containing the codes for sex, in the pyramid data frame.</p>
</td></tr>
<tr><td><code id="agedis_+3A_pyrage">pyrage</code></td>
<td>
<p>The variable containing the ages, in the pyramid data frame.</p>
</td></tr>
<tr><td><code id="agedis_+3A_pyrcount">pyrcount</code></td>
<td>
<p>The variable containing the counts for each sex/age combination, in the pyramid data frame.</p>
</td></tr>
<tr><td><code id="agedis_+3A_agevarname">agevarname</code></td>
<td>
<p>The name to use for the constructed age variable in the output data frame. For each row, this will contain one integer.</p>
</td></tr>
<tr><td><code id="agedis_+3A_userseed">userseed</code></td>
<td>
<p>The user-defined seed for reproducibility. If left blank the normal set.seed() function will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of an observations, with an added column that contains the age.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("dplyr")

ReducedDF &lt;- InitialDataframe %&gt;%
  slice_sample(n=200, replace = FALSE)
DisaggregateAge &lt;- agedis(ReducedDF, indsx = "Sex", minage = "LowerAge", maxage = "UpperAge",
                          pyramid = SingleAges, pyrsx = "Sex", pyrage = "Age", pyrcount = "Value",
                          agevarname = "TheAge", userseed = 4)
</code></pre>

<hr>
<h2 id='AllEmployers'>Employers and employees, by industry</h2><span id='topic+AllEmployers'></span>

<h3>Description</h3>

<p>The number of businesses and employees by industry, Timaru District, for 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AllEmployers
</code></pre>


<h3>Format</h3>

<p>A data frame of 183 rows and 7 variables:
</p>

<dl>
<dt>ANZSIC06</dt><dd><p>The code and associated name for each industry</p>
</dd>
<dt>BusinessCount</dt><dd><p>The random-rounded count of employers in the industry</p>
</dd>
<dt>EmployeeCount</dt><dd><p>The random-rounded count of employees in the industry</p>
</dd>
<dt>minCo</dt><dd><p>The minimum number of employers in the industry</p>
</dd>
<dt>maxCo</dt><dd><p>The maximum number of employers in the industry</p>
</dd>
<dt>minStaff</dt><dd><p>The minimum number of people employed in the industry</p>
</dd>
<dt>maxStaff</dt><dd><p>The maximum number of people employed in the industry</p>
</dd>
</dl>



<h3>Source</h3>

<p>Statistics New Zealand. Statistics New Zealand data are licensed by Stats NZ for reuse under the Creative Commons Attribution 4.0 International licence. The data has been modified by adding in four additional variables, representing the estimated minimum and maximum counts of businesses and employees.
</p>

<hr>
<h2 id='BadRels'>Synthetic people restricted to an age range</h2><span id='topic+BadRels'></span>

<h3>Description</h3>

<p>A subset of people from the Township data frame, aged between 20 and 91 years. Age bands, and the associated minimum and maximum ages, have been added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BadRels
</code></pre>


<h3>Format</h3>

<p>A data frame of 7,568 rows and 8 variables:
</p>

<dl>
<dt>Sex</dt><dd><p>Either Male or Female</p>
</dd>
<dt>Relationship</dt><dd><p>Relationship status of the person</p>
</dd>
<dt>ID</dt><dd><p>The unique identifier for the person</p>
</dd>
<dt>Age</dt><dd><p>The age of the person</p>
</dd>
<dt>HoursWorked</dt><dd><p>The number of hours worked in employment, per week</p>
</dd>
<dt>AgeBand</dt><dd><p>The ten-year age band for the age</p>
</dd>
<dt>MinAge</dt><dd><p>The minimum age in the age band</p>
</dd>
<dt>MaxAge</dt><dd><p>The maximum age in the age band</p>
</dd>
</dl>


<hr>
<h2 id='createemp'>Create employers, each with employee counts</h2><span id='topic+createemp'></span>

<h3>Description</h3>

<p>Constructs individual employers from aggregate counts, such as number of employers per employer type. Employer type is often industry, such as &quot;Sheep, Beef Cattle and Grain Farming&quot;. Within each employer type, the number of employers is extracted. The number of employees is then randomly assigned to each of those employers, using the total employee count for that industry. A randomisation method is used to ensure that the company counts can be quite dissimilar across the employers within a type. However, this is constructed by the ratio of employers to employees. If the number of employers is similar to the number of employees, the number of employees will tend to be 1 for each employer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createemp(
  employers,
  industry,
  indsmin,
  indsmax,
  pplmin,
  pplmax,
  stffname = NULL,
  cpyname = NULL,
  userseed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createemp_+3A_employers">employers</code></td>
<td>
<p>A data frame containing aggregate data on employers.</p>
</td></tr>
<tr><td><code id="createemp_+3A_industry">industry</code></td>
<td>
<p>The variable containing the types of employers. This can be an industry code.</p>
</td></tr>
<tr><td><code id="createemp_+3A_indsmin">indsmin</code></td>
<td>
<p>The variable containing the minimum number of employees in each industry.</p>
</td></tr>
<tr><td><code id="createemp_+3A_indsmax">indsmax</code></td>
<td>
<p>The variable containing the maximum number of employees in each industry.</p>
</td></tr>
<tr><td><code id="createemp_+3A_pplmin">pplmin</code></td>
<td>
<p>The variable containing the minimum number of staff in each industry.</p>
</td></tr>
<tr><td><code id="createemp_+3A_pplmax">pplmax</code></td>
<td>
<p>The variable containing the maximum number of staff in each industry.</p>
</td></tr>
<tr><td><code id="createemp_+3A_stffname">stffname</code></td>
<td>
<p>The variable name to use for the staff counts for each employer.</p>
</td></tr>
<tr><td><code id="createemp_+3A_cpyname">cpyname</code></td>
<td>
<p>The variable name to use for the companies.</p>
</td></tr>
<tr><td><code id="createemp_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>#'A data frames of synthetic companies, with the number of employees and a mock company name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("dplyr")

TownshipEmployment &lt;- createemp(AllEmployers, industry = "ANZSIC06", indsmin = "minCo",
                                indsmax = "maxCo", pplmin = "minStaff", pplmax = "maxStaff",
                                stffname="NumEmployees", cpyname="Company", userseed = 4)
</code></pre>

<hr>
<h2 id='diffsample'>Sample from groups, when the sample size for each group is different</h2><span id='topic+diffsample'></span>

<h3>Description</h3>

<p>Produces samples by group, enabling different sample sizes to be specified for each group. Sampling without replacement is used. While the function example is based on sampling by age, in practice sampling can be performed using any variable of choice. Only one grouping variable is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffsample(people, pplage, sampledf, smplage, smplcounts, userseed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffsample_+3A_people">people</code></td>
<td>
<p>A data frame containing individual people.</p>
</td></tr>
<tr><td><code id="diffsample_+3A_pplage">pplage</code></td>
<td>
<p>The variable containing the ages, in the people data frame.</p>
</td></tr>
<tr><td><code id="diffsample_+3A_sampledf">sampledf</code></td>
<td>
<p>A data frame containing ages and sample size counts.</p>
</td></tr>
<tr><td><code id="diffsample_+3A_smplage">smplage</code></td>
<td>
<p>The variable containing the ages, in the sampledf data frame.</p>
</td></tr>
<tr><td><code id="diffsample_+3A_smplcounts">smplcounts</code></td>
<td>
<p>The variable containing the sample size counts, in the sampledf data frame.</p>
</td></tr>
<tr><td><code id="diffsample_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of people sampled according to the age sample sizes required.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SampleNeeded &lt;- data.frame(Age = c(16, 17, 18),
                           NumNeeded = c(5, 10, 15))
SampledAdolescents &lt;- diffsample(WorkingAdolescents, pplage = "Age", sampledf = SampleNeeded,
                                 smplage = "Age", smplcounts = "NumNeeded", userseed = 4)

table(SampledAdolescents$Age)

</code></pre>

<hr>
<h2 id='EmployerSet'>Synthetic employers and their employee counts</h2><span id='topic+EmployerSet'></span>

<h3>Description</h3>

<p>Synthetic employers and their associated number of employees, randomly constructed using the &quot;AllEmployers&quot; data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EmployerSet
</code></pre>


<h3>Format</h3>

<p>A data frame of 225 rows and 3 variables:
</p>

<dl>
<dt>ANZSIC06</dt><dd><p>The code and associated name for the industry associated with the employer</p>
</dd>
<dt>NumEmployees</dt><dd><p>The count of employees for the employer</p>
</dd>
<dt>Company</dt><dd><p>The name of the employer</p>
</dd>
</dl>


<hr>
<h2 id='fastmatch'>Create couples using a weighted age group structure</h2><span id='topic+fastmatch'></span>

<h3>Description</h3>

<p>Creates couples when the only information is the proportions of people in couples, by age group. If there is an age range that should be up-sampled compared to other ages, this can be specified using the uwProp, uwLA, and uwUA variables. If uwProp is not provided, a simple random sampling without replacement is used. The number of couples that are output is determined by probSS. At least one same-sex couple will be output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastmatch(
  people,
  pplage,
  probSS = NULL,
  uwProp = NULL,
  uwLA = NULL,
  uwUA = NULL,
  HHStartNum = NULL,
  HHNumVar = NULL,
  userseed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastmatch_+3A_people">people</code></td>
<td>
<p>A data frame containing individual people.</p>
</td></tr>
<tr><td><code id="fastmatch_+3A_pplage">pplage</code></td>
<td>
<p>The variable containing the ages.</p>
</td></tr>
<tr><td><code id="fastmatch_+3A_probss">probSS</code></td>
<td>
<p>The probability of a person being in a same-sex couple.</p>
</td></tr>
<tr><td><code id="fastmatch_+3A_uwprop">uwProp</code></td>
<td>
<p>The proportion of individuals who are to be over-sampled. By default, no age group is up-sampled, and people are selected based on simple random sampling, without replacement.</p>
</td></tr>
<tr><td><code id="fastmatch_+3A_uwla">uwLA</code></td>
<td>
<p>The youngest age for the over-sampling. Required if uwProp value is provided.</p>
</td></tr>
<tr><td><code id="fastmatch_+3A_uwua">uwUA</code></td>
<td>
<p>The oldest age for the over-sampling. Required if uwProp value is provided.</p>
</td></tr>
<tr><td><code id="fastmatch_+3A_hhstartnum">HHStartNum</code></td>
<td>
<p>The starting value for HHNumVar Must be numeric.</p>
</td></tr>
<tr><td><code id="fastmatch_+3A_hhnumvar">HHNumVar</code></td>
<td>
<p>The name for the household variable.</p>
</td></tr>
<tr><td><code id="fastmatch_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of an even number of observations for allocation into same-sex couples. If HHStartNum is specified, household allocation will be performed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

PersonDataframe &lt;- data.frame(cbind(PersonID = c(1:1000),
                                    PersonAge = c(round(runif(200, min=18, max=23),0),
                                    round(runif(300, min=24, max=50),0),
                                    round(runif(500, min=51, max=90),0))))

# unweighted example, probability of being in a same-sex couple is 0.03
Unweighted &lt;- fastmatch(PersonDataframe, pplage = "PersonAge", probSS = 0.03, HHStartNum = 1,
                        HHNumVar = "Household", userseed = 4)
NumUnweighted &lt;- Unweighted %&gt;%
  filter(between(PersonAge, 25, 54))
# prop is
nrow(NumUnweighted)/nrow(Unweighted)

# weighted example, same probability, 66% of people in a same-sex relationship are aged between 25
# and 54
Weighted &lt;- fastmatch(PersonDataframe, pplage = "PersonAge", probSS = 0.03, uwProp = .66,
                      uwLA = 25, uwUA = 54, HHStartNum = 1, HHNumVar = "Household", userseed = 4)
NumWeighted &lt;- Weighted %&gt;%
  filter(between(PersonAge, 25, 54))
# prop is
nrow(NumWeighted)/nrow(Weighted)
</code></pre>

<hr>
<h2 id='fixhours'>Reallocates working hours between people in education and people not in education</h2><span id='topic+fixhours'></span>

<h3>Description</h3>

<p>Reallocates working hours so that people in education work fewer hours than people not in education. Pre-cleaning so that only people inside the student age range is not required. The hours of work are reallocated so that shorter hours worked are prioritised to those in education. The variables provided in the grpdef vector define the marginal totals that must be retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixhours(people, pplid, pplstat, pplhours, hoursmax, grpdef, userseed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixhours_+3A_people">people</code></td>
<td>
<p>A data frame containing individual people.</p>
</td></tr>
<tr><td><code id="fixhours_+3A_pplid">pplid</code></td>
<td>
<p>The variable containing the unique identifier for each person, in the people data frame.</p>
</td></tr>
<tr><td><code id="fixhours_+3A_pplstat">pplstat</code></td>
<td>
<p>The variable containing the indicator of whether a person is in education, in the people data frame. This must consist of only two values, and can be either an ordered factor or numeric. If this is a factor, factor level 2 must be for those in education. If it is a numeric variable, the lowest number must be for those in education.</p>
</td></tr>
<tr><td><code id="fixhours_+3A_pplhours">pplhours</code></td>
<td>
<p>The variable containing the hours worked by each adolescent. Must be a factor or numeric. If this is a factor, it is assumed to be ordered. The levels/values must be ascending for hours worked.</p>
</td></tr>
<tr><td><code id="fixhours_+3A_hoursmax">hoursmax</code></td>
<td>
<p>The maximum hours worked by people in education. Must be the relevant factor level/number from pplhours.</p>
</td></tr>
<tr><td><code id="fixhours_+3A_grpdef">grpdef</code></td>
<td>
<p>The vector containing any grouping variable to be used. If this is used, the changes to the working hours will be performed using grouped data. Marginal totals for the cross-tabulations of the grouping variables are retained.</p>
</td></tr>
<tr><td><code id="fixhours_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data of observations, with working hours reallocated so that people's working hours are compatible with their education status.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# table of hours by schoolstatus
table(WorkingAdolescents$HoursWorked, WorkingAdolescents$SchoolStatus)

# one grouping variable
Group1 &lt;- "Age"
OneGroup &lt;- fixhours(WorkingAdolescents, pplid = "ID", pplstat = "SchoolStatus",
                     pplhours = "HoursWorked", hoursmax = 3, grpdef = Group1, userseed = 4)
table(OneGroup$HoursWorked, OneGroup$SchoolStatus)

# two grouping variables
Group2 &lt;- c("Age", "Sex")
TwoGroups &lt;- fixhours(WorkingAdolescents, pplid = "ID", pplstat = "SchoolStatus",
                      pplhours = "HoursWorked", hoursmax = 3, grpdef = Group2, userseed = 4)
table(TwoGroups$HoursWorked, TwoGroups$SchoolStatus)
</code></pre>

<hr>
<h2 id='fixrelations'>Provide an age structure to relationship status, estimated from age groups</h2><span id='topic+fixrelations'></span>

<h3>Description</h3>

<p>Redistributes a user-defined relationship status value between ages, using age groups and other variables (if specified). Within the group definition provided, the marginal totals of the relationship status values are retained.
The data frame can include groups where all people have the same relationship status. In this situation, there is no need to restrict the data frame to only those whose relationship status must be redistributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixrelations(
  people,
  pplid,
  pplage,
  pplstat,
  stfixval,
  props,
  propcol,
  grpdef,
  matchdef,
  userseed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixrelations_+3A_people">people</code></td>
<td>
<p>A data frame containing individual people.</p>
</td></tr>
<tr><td><code id="fixrelations_+3A_pplid">pplid</code></td>
<td>
<p>The variable containing the unique identifier for each person.</p>
</td></tr>
<tr><td><code id="fixrelations_+3A_pplage">pplage</code></td>
<td>
<p>The variable containing the ages.</p>
</td></tr>
<tr><td><code id="fixrelations_+3A_pplstat">pplstat</code></td>
<td>
<p>The relationship status variable in the people data frame.</p>
</td></tr>
<tr><td><code id="fixrelations_+3A_stfixval">stfixval</code></td>
<td>
<p>The value of the relationship status, in the people data frame, that will be adjusted for age. If there are only two relationship status values, the choice does not matter. But if there are three or more values, this is the one value that will be age-corrected.</p>
</td></tr>
<tr><td><code id="fixrelations_+3A_props">props</code></td>
<td>
<p>The data frame containing the proportions of people with the stfixval value, by the grpdef.</p>
</td></tr>
<tr><td><code id="fixrelations_+3A_propcol">propcol</code></td>
<td>
<p>The variable in the props data frame that contains the proportions for the relationship status value of interest.</p>
</td></tr>
<tr><td><code id="fixrelations_+3A_grpdef">grpdef</code></td>
<td>
<p>A vector containing the combination of grouping variables, in the people dataframe, that defines the marginal totals for relationship status counts. This can be one variable or a string of multiple variables. Include the age-group variable, but not the age variable.</p>
</td></tr>
<tr><td><code id="fixrelations_+3A_matchdef">matchdef</code></td>
<td>
<p>A vector containing the same variables as grpdef, except the age variable is substituted for the age-group variable.</p>
</td></tr>
<tr><td><code id="fixrelations_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of observations, with one relationship status redistributed so that an age, rather than age group, structure is created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
thegroups &lt;- as.vector("Sex")
GroupInfo &lt;- rbind(GroupInfo, list("Male", "Under 20 Years", 19, 19, "Partnered", 0, 19),
                   list("Female", "Under 20 Years", 19, 19, "Partnered", 0, 19))
RelProps &lt;- interdiff(GroupInfo, pplage = "MidPoints", pplprop = "RelProps", endmin = "MinAge",
                      endmax = "MaxAge", grpdef = thegroups)
# add in the age groups
RelProps &lt;- RelProps %&gt;%
  mutate(AgeBand = ifelse(Age==19, "Under 20 Years",
                   ifelse(between(Age, 20, 29), "20-29 Years",
                   ifelse(between(Age, 30, 39), "30-39 Years",
                   ifelse(between(Age, 40, 49), "40-49 Years",
                   ifelse(between(Age, 50, 59), "50-59 Years",
                   ifelse(between(Age, 60, 69), "60-69 Years",
                   ifelse(between(Age, 70, 79), "70-79 Years", "80-90 Years"))))))))

# perform separately by sex
thejoindef &lt;- c("Age", "Sex")
thegroups &lt;- c("Sex", "AgeBand")
FinalRels &lt;- fixrelations(BadRels, pplid = "ID", pplage = "Age", pplstat = "Relationship",
                          stfixval = "Partnered", props = RelProps, propcol = "Fits",
                          grpdef = thegroups, matchdef = thejoindef, userseed = 4)
</code></pre>

<hr>
<h2 id='GroupInfo'>The proportion of people in a relationship, by age band within sex</h2><span id='topic+GroupInfo'></span>

<h3>Description</h3>

<p>The estimated proportion of people in a relationship, by age band within sex, for people aged between 20 and 90 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupInfo
</code></pre>


<h3>Format</h3>

<p>A data frame of 14 rows and 7 variables:
</p>

<dl>
<dt>Sex</dt><dd><p>Either Male or Female</p>
</dd>
<dt>AgeBand</dt><dd><p>The 10-year age band</p>
</dd>
<dt>MinAge</dt><dd><p>The minimum age of the age band</p>
</dd>
<dt>MaxAge</dt><dd><p>The maximum age of the age band</p>
</dd>
<dt>Relationship</dt><dd><p>All people are Partnered</p>
</dd>
<dt>RelProps</dt><dd><p>The proportion of people who have a relationship status of &quot;Partnered&quot;</p>
</dd>
<dt>MidPoints</dt><dd><p>The median age in the age band</p>
</dd>
</dl>


<hr>
<h2 id='InitialDataframe'>People in age groups, in the Timaru District</h2><span id='topic+InitialDataframe'></span>

<h3>Description</h3>

<p>A data frame of 46,293 synthetic people. Age groups are present, but not ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InitialDataframe
</code></pre>


<h3>Format</h3>

<p>A data frame with 46,293 rows and 6 variables:
</p>

<dl>
<dt>Sex</dt><dd><p>Either Male or Female</p>
</dd>
<dt>Age.group</dt><dd><p>Age group in five-year age bands</p>
</dd>
<dt>Relationship</dt><dd><p>Relationship status of the person</p>
</dd>
<dt>LowerAge</dt><dd><p>The youngest age in the Age.group</p>
</dd>
<dt>UpperAge</dt><dd><p>The oldest age in the Age.group</p>
</dd>
<dt>ID</dt><dd><p>The unique identifier for the person</p>
</dd>
</dl>



<h3>Source</h3>

<p>Timaru District 2018 census data (tablecodes 8277 and 8395), sourced from Statistics New Zealand. Statistics New Zealand data are licensed by Stats NZ for reuse under the Creative Commons Attribution 4.0 International licence.
</p>

<hr>
<h2 id='interdiff'>Interpolate ages from age group medians</h2><span id='topic+interdiff'></span>

<h3>Description</h3>

<p>The node ages for each age group are defined by the user, along with the age group values. The ages are then imputed from these nodes.
Zero values at both extremes must be included. For example, for the age group 20-24 years, the pplprop value is for pplage. if the first non-zero relationship probability is for the age group 20-24 years, and the previous age group is 15-19 years, pplprop==0 for pplage==19.
For each age group, there must be a minimum and maximum age specified. This provides the interpolation range for each age group. For the anchoring 0 values, the minimum and maximum ages are the same. In this example, for pplage==19, endmin==19, and endmax==19.
If there is no zero for older ages, as the final node value occurs inside the age group, the function assumes that the last node-to-node should be used to extrapolate for the ages older than the oldest node value. For example, if the last node value is for 90 years of age, but the oldest age is 95 years, the function will assume the same slope for ages 91 through 95 years.
The function can perform a separate interpolation for groups, for example, a separate interpolation can be performed for each sex. The function is flexible for the number of variables that can be used to define groups. If only one interpolation is required, the same grpdef value should be used for each row in the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interdiff(nodes, pplage, pplprop, endmin, endmax, grpdef)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interdiff_+3A_nodes">nodes</code></td>
<td>
<p>A data frame containing all grouping variables, the node ages for each group, and the associated node values.</p>
</td></tr>
<tr><td><code id="interdiff_+3A_pplage">pplage</code></td>
<td>
<p>The variable containing the node ages.</p>
</td></tr>
<tr><td><code id="interdiff_+3A_pplprop">pplprop</code></td>
<td>
<p>The variable containing the node values.</p>
</td></tr>
<tr><td><code id="interdiff_+3A_endmin">endmin</code></td>
<td>
<p>The variable that contains the minimum age for each group.</p>
</td></tr>
<tr><td><code id="interdiff_+3A_endmax">endmax</code></td>
<td>
<p>The variable that contains the maximum age for each group.</p>
</td></tr>
<tr><td><code id="interdiff_+3A_grpdef">grpdef</code></td>
<td>
<p>A character vector containing the names of the grouping variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While the function is designed to interpolate proportions, in practice it can interpolate any values. The limitation is that the function performs no rounding. Integer node values may produce non-integer estimates.
</p>


<h3>Value</h3>

<p>A data frame containing the fitted values, by age within group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("dplyr")

# create the expected proportion of people in relationships, by age within sex
thegroups &lt;- as.vector("Sex")
RelProps &lt;- interdiff(GroupInfo, pplage = "MidPoints", pplprop = "RelProps", endmin = "MinAge",
                      endmax = "MaxAge", grpdef = thegroups)
</code></pre>

<hr>
<h2 id='IntoSchools'>Four person households, with a school status for each person</h2><span id='topic+IntoSchools'></span>

<h3>Description</h3>

<p>Four-person households, consisting of one parent and three children, with a combination of people in school and not in school. Ages 15 through 18 contain a mixture of people in school and those who have left school. This has been constructed from the Township data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntoSchools
</code></pre>


<h3>Format</h3>

<p>A data frame of 980 rows and 8 variables:
</p>

<dl>
<dt>Sex</dt><dd><p>Either Male or Female</p>
</dd>
<dt>Relationship</dt><dd><p>Relationship status of the person</p>
</dd>
<dt>ID</dt><dd><p>The unique identifier for the person</p>
</dd>
<dt>Age</dt><dd><p>The age of the person</p>
</dd>
<dt>HoursWorked</dt><dd><p>The number of hours worked in employment, per week</p>
</dd>
<dt>SchoolStatus</dt><dd><p>The indicator of whether the person is in school (Y) or not (N)</p>
</dd>
<dt>HouseholdID</dt><dd><p>The household identifier for the person</p>
</dd>
<dt>SexCode</dt><dd><p>Either (F)emale or (M)ale</p>
</dd>
</dl>


<hr>
<h2 id='LeftSchool'>School leavers</h2><span id='topic+LeftSchool'></span>

<h3>Description</h3>

<p>School leavers in the Canterbury Region, counts by age and sex, for the period 2009 to 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LeftSchool
</code></pre>


<h3>Format</h3>

<p>A data frame with 120 rows and 4 variables:
</p>

<dl>
<dt>YearLeft</dt><dd><p>The year for the school leaver count</p>
</dd>
<dt>Sex</dt><dd><p>The sex for the school leaver count</p>
</dd>
<dt>Age</dt><dd><p>The age for the school leaver count</p>
</dd>
<dt>Total</dt><dd><p>The count of adolescents who left school in that year, of that age and sex</p>
</dd>
</dl>



<h3>Source</h3>

<p>Ministry of Education. The Ministry of Education's data are licensed by the Ministry of Education for reuse under the Creative Commons Attribution 4.0 International licence.
</p>

<hr>
<h2 id='NetworkMatrix'>The number of contacts for 5000 person</h2><span id='topic+NetworkMatrix'></span>

<h3>Description</h3>

<p>A matrix of 1,000 integers constricted using a Poisson distribution. Each value is the number of contacts for a person.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkMatrix
</code></pre>


<h3>Format</h3>

<p>A list of 1,000 integers
</p>

<hr>
<h2 id='other'>Match people into new households</h2><span id='topic+other'></span>

<h3>Description</h3>

<p>This function creates a data frame of household inhabitants, with the specified number of inhabitants.
One data frame, containing the people to match, is required. The use of an age distribution for the matching ensures that an age structure is present in the households. A less correlated age structure can be produced by entering a larger standard deviation.
The output data frame of matches will only contain households of the required size. If the number of rows in the people data frame is not divisible by household size, the overcount will be output to a separate data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>other(
  people,
  pplid,
  pplage,
  numppl = NULL,
  sdused,
  HHStartNum,
  HHNumVar,
  userseed = NULL,
  ptostop = NULL,
  numiters = 1e+06,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="other_+3A_people">people</code></td>
<td>
<p>A data frame containing the people to be matched into households.</p>
</td></tr>
<tr><td><code id="other_+3A_pplid">pplid</code></td>
<td>
<p>The variable containing the unique ID for each person.</p>
</td></tr>
<tr><td><code id="other_+3A_pplage">pplage</code></td>
<td>
<p>The age variable.</p>
</td></tr>
<tr><td><code id="other_+3A_numppl">numppl</code></td>
<td>
<p>The number of people in the households.</p>
</td></tr>
<tr><td><code id="other_+3A_sdused">sdused</code></td>
<td>
<p>The standard deviation of the normal distribution for the distribution of ages in a household.</p>
</td></tr>
<tr><td><code id="other_+3A_hhstartnum">HHStartNum</code></td>
<td>
<p>The starting value for HHNumVar. Must be numeric.</p>
</td></tr>
<tr><td><code id="other_+3A_hhnumvar">HHNumVar</code></td>
<td>
<p>The name for the household variable.</p>
</td></tr>
<tr><td><code id="other_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
<tr><td><code id="other_+3A_ptostop">ptostop</code></td>
<td>
<p>The critical p-value stopping rule for the function. If this value is not set, the critical p-value of .01 is used.</p>
</td></tr>
<tr><td><code id="other_+3A_numiters">numiters</code></td>
<td>
<p>The maximum number of iterations used to construct the output data frame ($Matched) containing the household inhabitants. The default value is 1000000, and is the stopping rule if the algorithm does not converge.</p>
</td></tr>
<tr><td><code id="other_+3A_verbose">verbose</code></td>
<td>
<p>Whether the number of iterations used, the critical chi-squared value, and the final chi-squared value are printed to the console. The information will be printed for each set of pairs. For example, if there are three people in each household, the information will be printed twice. The default is FALSE, so no information will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two data frames $Matched contains the data frame of households containing matched people. All households will be of the specified size. $Unmatched, if populated, contains the people that were not allocated to households. If the number of rows in the people data frame is divisible by the household size required, $Unmatched will be an empty data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# creating three-person households toy example with few iterations
NewHouseholds &lt;- other(AdultsNoID, pplid = "ID", pplage = "Age", numppl = 3, sdused = 3,
                       HHStartNum = 1, HHNumVar = "Household", userseed=4, ptostop = .05,
                       numiters = 500, verbose = TRUE)

PeopleInHouseholds &lt;- NewHouseholds$Matched
PeopleNot &lt;- NewHouseholds$Unmatched      # 2213 not divisible by 3
</code></pre>

<hr>
<h2 id='otherNum'>Match people into existing households</h2><span id='topic+otherNum'></span>

<h3>Description</h3>

<p>Creates a data frame of household inhabitants, with the specified number of inhabitants.
Two data frames are required. The 'existing' data frame contains the people already in households. The 'additions' data frame contains the people. The use of an age distribution for the matching ensures that an age structure is present in the households. A less correlated age structure can be produced by entering a larger standard deviation.
The output data frame of matches will only contain households of the required size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otherNum(
  existing,
  exsid,
  exsage,
  HHNumVar = NULL,
  additions,
  addid,
  addage,
  numadd = NULL,
  sdused = NULL,
  userseed = NULL,
  attempts = 10,
  numiters = 10000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="otherNum_+3A_existing">existing</code></td>
<td>
<p>A data frame containing the people already in households.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_exsid">exsid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the existing data frame.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_exsage">exsage</code></td>
<td>
<p>The age variable, in the existing data frame.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_hhnumvar">HHNumVar</code></td>
<td>
<p>The household identifier variable. This must exist in only one data frame.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_additions">additions</code></td>
<td>
<p>A data frame containing the people to be added to the existing households.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_addid">addid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the additions data frame.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_addage">addage</code></td>
<td>
<p>The age variable, in the additions data frame.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_numadd">numadd</code></td>
<td>
<p>The number of people to be added to the household.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_sdused">sdused</code></td>
<td>
<p>The standard deviation of the normal distribution for the distribution of ages in a household.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_userseed">userseed</code></td>
<td>
<p>The user-defined seed for reproducibility. If left blank the normal set.seed() function will be used.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_attempts">attempts</code></td>
<td>
<p>The number of times the function will randomly change two matches to improve the fit.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_numiters">numiters</code></td>
<td>
<p>The maximum number of iterations used to construct the household data frame. This has a default value of 10000, and is the stopping rule if the algorithm does not converge.</p>
</td></tr>
<tr><td><code id="otherNum_+3A_verbose">verbose</code></td>
<td>
<p>Whether the number of iterations used, the critical chi-squared value, and the final chi-squared value are printed to the console. The information will be printed for each set of pairs. For example, if there are two people being added to each household, the information will be printed twice. The default is FALSE, so no information will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three data frames $Matched contains the data frame of households containing matched people. All households will be of the specified size. $Existing, if populated, contains the excess people in the existing data frame, who could not be allocated additional people. $Additions, if populated, contains the excess people in the additions data frame who could not be allocated to an existing household.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("dplyr")

AdultsID &lt;- IntoSchools %&gt;%
filter(Age &gt; 20) %&gt;%
select(-c(SchoolStatus, SexCode))
set.seed(2)
NoHousehold &lt;- Township %&gt;%
  filter(Age &gt; 20, Relationship == "NonPartnered", !(ID %in% c(AdultsID$ID))) %&gt;%
  slice_sample(n = 1500)

# toy example with few iterations
OldHouseholds &lt;- otherNum(AdultsID, exsid = "ID", exsage = "Age", HHNumVar = "HouseholdID",
                          NoHousehold, addid = "ID", addage = "Age", numadd = 2, sdused = 3,
                          userseed=4, attempts= 10, numiters = 80)
CompletedHouseholds &lt;- OldHouseholds$Matched # will match even if critical p-value not met
IncompleteHouseholds &lt;- OldHouseholds$Existing # no-one available to match in
UnmatchedOthers &lt;- OldHouseholds$Additions # all people not in households were matched
</code></pre>

<hr>
<h2 id='pairbeta4'>Pair two people, using a four-parameter beta distribution, into households</h2><span id='topic+pairbeta4'></span>

<h3>Description</h3>

<p>Creates a data frame of paired people, based on a distribution of age differences. The function uses a four-parameter beta distribution to create the pairs.
Two data frames are required. One person from each data frame will be matched, based on the age difference distribution specified. If the data frames are different sizes, the &quot;smalldf&quot; data frame must be the smaller of the two. In this situation, a random subsample of the &quot;largedf&quot; data frame will be used.
Both data frames must be restricted to only those people that will be paired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairbeta4(
  smalldf,
  smlid,
  smlage,
  largedf,
  lrgid,
  lrgage,
  shapeA = NULL,
  shapeB = NULL,
  locationP = NULL,
  scaleP = NULL,
  HHStartNum,
  HHNumVar,
  userseed = NULL,
  ptostop = NULL,
  attempts = 10,
  numiters = 1e+06,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairbeta4_+3A_smalldf">smalldf</code></td>
<td>
<p>The data frame containing one set of people to be paired. If the two data frames contain different numbers of people, this must be the data frame containing the smallest number.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_smlid">smlid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the smalldf data frame.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_smlage">smlage</code></td>
<td>
<p>The age variable, in the smalldf data frame.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_largedf">largedf</code></td>
<td>
<p>A data frame containing the second set of people to be paired. If the two data frames contain different numbers of people, this must be the data frame containing the largest number.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_lrgid">lrgid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the largedf data frame.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_lrgage">lrgage</code></td>
<td>
<p>The age variable, in the largedf data frame.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_shapea">shapeA</code></td>
<td>
<p>This is the first shape parameter of the four-parameter beta distribution If this value is negative, smalldf has the oldest ages. If this value is positive, smalldf has the youngest ages.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_shapeb">shapeB</code></td>
<td>
<p>This is the second shape parameter of the four-parameter beta distribution This value must be positive.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_locationp">locationP</code></td>
<td>
<p>The location parameter of the four-parameter beta distribution.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_scalep">scaleP</code></td>
<td>
<p>The scale parameter of the four-parameter beta distribution.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_hhstartnum">HHStartNum</code></td>
<td>
<p>The starting value for HHNumVar. Must be numeric.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_hhnumvar">HHNumVar</code></td>
<td>
<p>The column name for the household variable.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_ptostop">ptostop</code></td>
<td>
<p>The critical p-value stopping rule for the function. If this value is not set, the critical p-value of .01 is used.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_attempts">attempts</code></td>
<td>
<p>The maximum number of times largedf will be sampled to draw an age match from the correct distribution, for each observation in the smalldf. The default number of attempts is 10.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_numiters">numiters</code></td>
<td>
<p>The maximum number of iterations used to construct the output data frame ($Matched) containing the pairs. The default value is 1000000, and is the stopping rule if the algorithm does not converge.</p>
</td></tr>
<tr><td><code id="pairbeta4_+3A_verbose">verbose</code></td>
<td>
<p>Whether the number of iterations used, the critical chi-squared value, and the final chi-squared value are printed to the console. The default value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three data frames. $Matched contains the data frame of pairs. $Smaller contains the unmatched observations from smalldf. $Larger contains the unmatched observations from largedf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# the children data frame is smaller
set.seed(1)
# sample a combination of females and males to be parents
Parents &lt;- Township %&gt;%
  filter(Relationship == "Partnered", Age &gt; 18) %&gt;%
  slice_sample(n = 500)
  Children &lt;- Township %&gt;%
    filter(Relationship == "NonPartnered", Age &lt; 20) %&gt;%
    slice_sample(n = 200)

ChildAllMatched &lt;- pairbeta4(Children, smlid = "ID", smlage = "Age", Parents, lrgid = "ID",
                             lrgage = "Age", shapeA = 2.2, shapeB = 3.7, locationP = 16.5,
                             scaleP = 40.1, HHStartNum = 1, HHNumVar = "Household",
                             userseed=4, ptostop = .01, attempts = 2, numiters = 8)

MatchedPairs &lt;- ChildAllMatched$Matched
UnmatchedChildren &lt;- ChildAllMatched$Smaller
UnmatchedAdults &lt;- ChildAllMatched$Larger

# children data frame is larger, the locationP and scaleP values are negative

Parents2 &lt;- Township %&gt;%
 filter(Relationship == "Partnered", Age &gt; 18) %&gt;%
 slice_sample(n = 100)
Children2 &lt;- Township %&gt;%
 filter(Relationship == "NonPartnered", Age &lt; 20) %&gt;%
 slice_sample(n = 500)

 ChildMatched &lt;- pairbeta4(Parents2, smlid = "ID", smlage = "Age", Children2, lrgid = "ID",
                           lrgage = "Age", shapeA = 2.2, shapeB = 3.7, locationP = -16.5,
                           scaleP = -40.1, HHStartNum = 1, HHNumVar = "Household",
                           userseed=4, ptostop = .05, attempts = 2, numiters = 8)

MatchedPairs2 &lt;- ChildMatched$Matched
UnmatchedChildren2 &lt;- ChildMatched$Smaller
UnmatchedAdults2 &lt;- ChildMatched$Larger
</code></pre>

<hr>
<h2 id='pairbeta4Num'>Pair two people, using a four-parameter beta distribution, households already exist</h2><span id='topic+pairbeta4Num'></span>

<h3>Description</h3>

<p>This function creates a data frame of pairs, based on a distribution of age differences. The function will use either a skew normal or normal distribution, depending on whether a skew (&quot;locationP&quot;) parameter is provided. The default value for the skew is 0, and using the default will cause a normal distribution to be used.
Two data frames are required. One person from each data frame will be matched, based on the age difference distribution specified. If the data frames are different sizes, the smalldf data frame must be the smaller of the two. In this situation, a random subsample of the largedf data frame will be used.
The household identifier variable can exist in either data frame. The function will apply the relevant household identifier once each pair is constructed.
Both data frames must be restricted to only those people that are successfully paired.
At least 30 matched pairs are required for the function to run. This is to reduce the proportion of empty cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairbeta4Num(
  smalldf,
  smlid,
  smlage,
  largedf,
  lrgid,
  lrgage,
  shapeA = NULL,
  shapeB = NULL,
  locationP = NULL,
  scaleP = NULL,
  HHNumVar,
  userseed = NULL,
  attempts = 10,
  numiters = 1e+06,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairbeta4Num_+3A_smalldf">smalldf</code></td>
<td>
<p>The data frame containing one set of people to be paired. If the two data frames contain different numbers of people, this must be the data frame containing the smallest number.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_smlid">smlid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the smalldf data frame.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_smlage">smlage</code></td>
<td>
<p>The age variable, in the smalldf data frame.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_largedf">largedf</code></td>
<td>
<p>A data frame containing the second set of people to be paired. If the two data frames contain different numbers of people, this must be the data frame containing the largest number.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_lrgid">lrgid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the largedf data frame.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_lrgage">lrgage</code></td>
<td>
<p>The age variable, in the largedf data frame.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_shapea">shapeA</code></td>
<td>
<p>This is the first shape parameter of the four-parameter beta distribution If this value is negative, smalldf has the oldest ages. If this value is positive, smalldf has the youngest ages.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_shapeb">shapeB</code></td>
<td>
<p>This is the second shape parameter of the four-parameter beta distribution This value must be positive.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_locationp">locationP</code></td>
<td>
<p>The location parameter of the four-parameter beta distribution</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_scalep">scaleP</code></td>
<td>
<p>The scale parameter of the four-parameter beta distribution</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_hhnumvar">HHNumVar</code></td>
<td>
<p>The household identifier variable. This must exist in only one data frame.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_attempts">attempts</code></td>
<td>
<p>The maximum number of times largedf will be sampled to draw an age match from the correct distribution, for each observation in the smalldf. The default number of attempts is 10.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_numiters">numiters</code></td>
<td>
<p>The maximum number of iterations used to construct the output data frame ($Matched) containing the pairs. The default value is 1000000, and is the stopping rule if the algorithm does not converge.</p>
</td></tr>
<tr><td><code id="pairbeta4Num_+3A_verbose">verbose</code></td>
<td>
<p>Whether the number of iterations used, the critical chi-squared value, and the final chi-squared value are printed to the console. The default value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three data frames $Matched contains the data frame of pairs. $Smaller contains the unmatched observations from smalldf. $Larger contains the unmatched observations from largedf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# demonstrate matched dataframe sizes first
set.seed(1)
# sample a combination of females and males to be parents
Parents &lt;- Township %&gt;%
  filter(Relationship == "Partnered", Age &gt; 18) %&gt;%
  slice_sample(n = 500) %&gt;%
  mutate(Household = row_number())
Children &lt;- Township %&gt;%
  filter(Relationship == "NonPartnered", Age &lt; 20) %&gt;%
  slice_sample(n = 200)

# match the children to the parents, toy example with few iterations
ChildAllMatched &lt;- pairbeta4Num(Children, smlid = "ID", smlage = "Age", Parents, lrgid = "ID",
                                lrgage = "Age", shapeA = 2.2, shapeB = 3.7, locationP = 16.5,
                                scaleP = 40.1, HHNumVar = "Household", userseed=4, attempts = 8,
                                numiters = 90)

MatchedPairs &lt;- ChildAllMatched$Matched
UnmatchedChildren &lt;- ChildAllMatched$Smaller # all children matched
UnmatchedAdults &lt;- ChildAllMatched$Larger

# # children data frame is larger, the locationP and scaleP values are negative
#
# Parents2 &lt;- Township %&gt;%
#   filter(Relationship == "Partnered", Age &gt; 18) %&gt;%
#  slice_sample(n = 200) %&gt;%
#   mutate(Household = row_number())
# Children2 &lt;- Township %&gt;%
#   filter(Relationship == "NonPartnered", Age &lt; 20) %&gt;%
#   slice_sample(n = 500)
#
# ChildMatched &lt;- pairbeta4Num(Parents2, smlid = "ID", smlage = "Age", Children2, lrgid = "ID",
#                              lrgage = "Age", shapeA = 2.2, shapeB = 3.7, locationP = -16.5,
#                              scaleP = -40.1, HHNumVar = "Household", userseed=4,
#                              attempts = 10, numiters = 80)
#
# MatchedPairs2 &lt;- ChildMatched$Matched
# UnmatchedChildren2 &lt;- ChildMatched$Smaller
# UnmatchedAdults2 &lt;- ChildMatched$Larger
</code></pre>

<hr>
<h2 id='pairmult'>Create many-to-one pairs of people and place them into households</h2><span id='topic+pairmult'></span>

<h3>Description</h3>

<p>Creates a data frame of many-to-one pairs, based on a distribution of age differences. Designed to match multiple children to the same parent, the function can be used for any situation where a many-to-one match is required based on a range of age differences. For clarity and brevity, the terms &quot;children&quot; and &quot;parents&quot; will be used.
Two data frames are required: the first contains the people representing the many (e.g children). The second contains the people that will be paired with multiple others (e.g. the parents of two or more children).
The minimum and maximum ages of parents must be specified. This ensures that there are no parents who were too young (e.g. 11 years) or too old (e.g. 70 years) at the time the child was born. The presence of too young and too old parents is tested throughout this function. Thus, pre-cleaning the parents data frame is not required.
Both data frames must be restricted to only those people that will be paired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairmult(
  children,
  chlid,
  chlage,
  numchild = 2,
  twinprob = 0,
  parents,
  parid,
  parage,
  minparage = NULL,
  maxparage = NULL,
  HHStartNum = NULL,
  HHNumVar = NULL,
  userseed = NULL,
  maxdiff = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairmult_+3A_children">children</code></td>
<td>
<p>The data frame containing the children to be paired with a parent/guardian.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_chlid">chlid</code></td>
<td>
<p>The variable containing the unique ID for each person,in the children data frame.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_chlage">chlage</code></td>
<td>
<p>The age variable, in the children data frame.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_numchild">numchild</code></td>
<td>
<p>The number of children that are required in each household.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_twinprob">twinprob</code></td>
<td>
<p>The probability that a person is a twin.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_parents">parents</code></td>
<td>
<p>The data frame containing the potential parents.(This data frame must contain at least the same number of observations as the children data frame.)</p>
</td></tr>
<tr><td><code id="pairmult_+3A_parid">parid</code></td>
<td>
<p>The variable containing the unique ID for each person,in the parents data frame.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_parage">parage</code></td>
<td>
<p>The age variable, in the parent data frame.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_minparage">minparage</code></td>
<td>
<p>The youngest age at which a person becomes a parent. The default value is NULL, which will cause the function to stop.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_maxparage">maxparage</code></td>
<td>
<p>The oldest age at which a person becomes a parent. The default value is NULL, which will cause the function to stop.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_hhstartnum">HHStartNum</code></td>
<td>
<p>The starting value for HHNumVar. Must be numeric.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_hhnumvar">HHNumVar</code></td>
<td>
<p>The name for the household variable.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
<tr><td><code id="pairmult_+3A_maxdiff">maxdiff</code></td>
<td>
<p>The maximum age difference for the children in a household ages. This is applied to the first child randomly selected for the household, so overall age differences may be 2* maxdiff. Default value is no constraints on child age differences in the household.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three  data frames. $Matched contains the data frame of child-parent matches. $Adults contains any unmatched observations from the parents data frame. $Children contains any unmatched observations from the children data frame. $Adults and/or $Children may be empty data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

set.seed(1)
Parents &lt;- Township %&gt;%
  filter(Relationship == "Partnered", Age &gt; 18) %&gt;%
  slice_sample(n = 500)
Children &lt;- Township %&gt;%
  filter(Relationship == "NonPartnered", Age &lt; 20) %&gt;%
  slice_sample(n = 400)

# example with assigning two children to a parent
# the same number of children is assigned to all parents
# adding two children to each parent
ChildMatched &lt;- pairmult(Children, chlid = "ID", chlage = "Age", numchild = 2, twinprob = 0.03,
                         Parents, parid = "ID", parage = "Age", minparage = 18, maxparage = 54,
                         HHStartNum = 1, HHNumVar = "Household", userseed=4, maxdiff = 3)
MatchedFamilies &lt;- ChildMatched$Matched

</code></pre>

<hr>
<h2 id='pairmultNum'>Create many-to-one pairs, when there are existing households</h2><span id='topic+pairmultNum'></span>

<h3>Description</h3>

<p>Creates a data frame of many-to-one pairs, based on a distribution of age differences. Designed to match multiple children to the same parent, the function can be used for any situation where a many-to-one match is required based on a range of age differences. For clarity and brevity, the terms &quot;children&quot; and &quot;parents&quot; will be used.
Two data frames are required: one for children and one for potential parents. The data frame of potential parents must contain household identifiers
The minimum and maximum ages of parents must be specified. This ensures that there are no parents who were too young (e.g. 11 years) or too old (e.g. 70 years) at the time the child was born. The presence of too young and too old parents is tested throughout this function. Thus, pre-cleaning the parents data frame is not required.
Both data frames must be restricted to only those people that will be paired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairmultNum(
  children,
  chlid,
  chlage,
  numchild = 2,
  twinprob = 0,
  parents,
  parid,
  parage,
  minparage = NULL,
  maxparage = NULL,
  HHNumVar = NULL,
  userseed = NULL,
  maxdiff = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairmultNum_+3A_children">children</code></td>
<td>
<p>The data frame containing the children to be paired with a parent/guardian.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_chlid">chlid</code></td>
<td>
<p>The variable containing the unique ID for each person,in the children data frame.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_chlage">chlage</code></td>
<td>
<p>The age variable, in the children data frame.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_numchild">numchild</code></td>
<td>
<p>The number of children that are required in each household.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_twinprob">twinprob</code></td>
<td>
<p>The probability that a person is a twin.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_parents">parents</code></td>
<td>
<p>The data frame containing the potential parents.(This data frame must contain at least the same number of observations as the children data frame.)</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_parid">parid</code></td>
<td>
<p>The variable containing the unique ID for each person,in the parents data frame.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_parage">parage</code></td>
<td>
<p>The age variable, in the parent data frame.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_minparage">minparage</code></td>
<td>
<p>The youngest age at which a person becomes a parent. The default value is NULL, which will cause the function to stop.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_maxparage">maxparage</code></td>
<td>
<p>The oldest age at which a person becomes a parent. The default value is NULL, which will cause the function to stop.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_hhnumvar">HHNumVar</code></td>
<td>
<p>The name of the household identifier variable in the parents data frame.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
<tr><td><code id="pairmultNum_+3A_maxdiff">maxdiff</code></td>
<td>
<p>The maximum age difference for the children in a household ages. This is applied to the first child randomly selected for the household, so overall age differences may be 2* maxdiff. Default value is no constraints on child age differences in the household.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three  data frames. $Matched contains the data frame of child-parent matches. $Adults contains any unmatched observations from the parents data frame. $Children contains any unmatched observations from the children data frame. $Adults and/or $Children may be empty data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

set.seed(1)
Parents &lt;- Township %&gt;%
  filter(Relationship == "Partnered", Age &gt; 18) %&gt;%
  slice_sample(n = 500) %&gt;%
  mutate(Household = row_number())
Children &lt;- Township %&gt;%
  filter(Relationship == "NonPartnered", Age &lt; 20) %&gt;%
  slice_sample(n = 400)

# example with assigning two children to a parent
# the same number of children is assigned to all parents
# adding two children to each parent

ChildMatched &lt;- pairmultNum(Children, chlid = "ID", chlage = "Age", numchild = 2, twinprob = 0.03,
                            Parents, parid = "ID", parage = "Age", minparage = 18, maxparage = 54,
                            HHNumVar = "Household", userseed =4, maxdiff = 3)
MatchedFamilies &lt;- ChildMatched$Matched
UnmatchedChildren &lt;- ChildMatched$Children
UnmatchedAdults &lt;- ChildMatched$Adults
</code></pre>

<hr>
<h2 id='pairnorm'>Pair two people, using either a normal or skew-normal distribution, into households</h2><span id='topic+pairnorm'></span>

<h3>Description</h3>

<p>Creates a data frame of couples, based on a distribution of age differences. The function will use either a skew normal or normal distribution, depending on whether a skew (&quot;alphaused&quot;) parameter is provided. The default value for the skew is 0, and using the default will cause a normal distribution to be used.
Two data frames are required. One person from each data frame will be matched, based on the age difference distribution specified. If the data frames are different sizes, the smalldf data frame must be the smaller of the two. In this situation, a random subsample of the largedf data frame will be used.
Both data frames must be restricted to only those people that will have a couples match performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairnorm(
  smalldf,
  smlid,
  smlage,
  largedf,
  lrgid,
  lrgage,
  directxi = NULL,
  directomega = NULL,
  alphaused = 0,
  HHStartNum,
  HHNumVar,
  userseed = NULL,
  ptostop = NULL,
  numiters = 1e+06,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairnorm_+3A_smalldf">smalldf</code></td>
<td>
<p>A data frame containing one set of people to be paired. If the two data frames contain different numbers of people, this must be the data frame containing the smallest number.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_smlid">smlid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the smalldf data frame.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_smlage">smlage</code></td>
<td>
<p>The age variable, in the smalldf data frame.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_largedf">largedf</code></td>
<td>
<p>A data frame containing the second set of people to be paired. If the two data frames contain different numbers of people, this must be the data frame containing the largest number.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_lrgid">lrgid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the largedf data frame.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_lrgage">lrgage</code></td>
<td>
<p>The age variable, in the largedf data frame.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_directxi">directxi</code></td>
<td>
<p>If a skew-normal distribution is used, this is the location value. If the default alphaused value of 0 is used, this defaults to the mean value for the normal distribution.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_directomega">directomega</code></td>
<td>
<p>If a skew-normal distribution is used, this is the scale value. If the default alphaused value of 0 is used, this defaults to the standard deviation value for the normal distribution.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_alphaused">alphaused</code></td>
<td>
<p>The skew. If a normal distribution is to be used, this can be omitted as the default value is 0 (no skew).</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_hhstartnum">HHStartNum</code></td>
<td>
<p>The starting value for HHNumVar Must be numeric.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_hhnumvar">HHNumVar</code></td>
<td>
<p>The name for the household variable.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_ptostop">ptostop</code></td>
<td>
<p>The critical p-value stopping rule for the function. If this value is not set, the critical p-value of .01 is used.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_numiters">numiters</code></td>
<td>
<p>The maximum number of iterations used to construct the output data frame ($Matched) containing the couples. The default value is 1000000, and is the stopping rule if the algorithm does not converge.</p>
</td></tr>
<tr><td><code id="pairnorm_+3A_verbose">verbose</code></td>
<td>
<p>Whether the distribution used, number of iterations used, the critical chi-squared value, and the final chi-squared value are printed to the console. The default value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two data frames. $Matched contains the data frame of pairs. $Unmatched contains the unmatched observations from largedf. If there are no unmatched people, $Unmatched will be an empty data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# matched dataframe sizes first, using a normal distribution
# females younger by a mean of -2 and a standard deviation of 3
set.seed(1)
PartneredFemales1 &lt;- Township %&gt;%
  filter(Sex == "Female", Relationship == "Partnered") %&gt;%
  slice_sample(n=120, replace = FALSE)
PartneredMales1 &lt;- Township %&gt;%
 filter(Sex == "Male", Relationship == "Partnered") %&gt;%
 slice_sample(n = nrow(PartneredFemales1), replace = FALSE)

# partners females and males, using a normal distribution, with the females
# being younger by a mean of -2 and a standard deviation of 3
OppSexCouples1 &lt;- pairnorm(PartneredFemales1, smlid = "ID", smlage = "Age", PartneredMales1,
                           lrgid = "ID", lrgage = "Age", directxi = -2, directomega = 3,
                           HHStartNum = 1, HHNumVar = "HouseholdID", userseed = 4, ptostop=.3)
Couples1 &lt;- OppSexCouples1$Matched

# different size dataframes
# there are more partnered males than partnered females
# so all partnered males will have a matched female partner
# but not all females will be matched
# being the smallest data frame, the female one must be the first
#
# PartneredFemales2 &lt;- Township %&gt;%
#   filter(Sex == "Female", Relationship == "Partnered") %&gt;%
#   slice_sample(n=120, replace = FALSE)
# PartneredMales2 &lt;- Township %&gt;%
#   filter(Sex == "Male", Relationship == "Partnered") %&gt;%
#   slice_sample(n=140, replace = FALSE)
#
# OppSexCouples2 &lt;- pairnorm(PartneredFemales2, smlid = "ID", smlage = "Age", PartneredMales2,
#                            lrgid = "ID", lrgage = "Age", directxi = -2, directomega = 3,
#                            HHStartNum = 1, HHNumVar="HouseholdID", userseed = 4, ptostop=.3)
# Couples2 &lt;- OppSexCouples2$Matched
</code></pre>

<hr>
<h2 id='pairnormNum'>Pair two people, using either a normal or skew-normal distribution, households already exist</h2><span id='topic+pairnormNum'></span>

<h3>Description</h3>

<p>Creates a data frame of pairs, based on a distribution of age differences. The function will use either a skew normal or normal distribution, depending on whether a skew (&quot;locationP&quot;) parameter is provided. The default value for the skew is 0, and using the default will cause a normal distribution to be used.
Two data frames are required. One person from each data frame will be matched, based on the age difference distribution specified. If the data frames are different sizes, the smalldf data frame must be the smaller of the two. In this situation, a random subsample of the largedf data frame will be used.
The household identifier variable can exist in either data frame. The function will apply the relevant household identifier once each pair is constructed.
Both data frames must be restricted to only those people that are successfully paired.
At least 30 matched pairs are required for the function to run. This is to reduce the proportion of empty cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairnormNum(
  smalldf,
  smlid,
  smlage,
  largedf,
  lrgid,
  lrgage,
  directxi = NULL,
  directomega = NULL,
  alphaused = 0,
  HHNumVar,
  userseed = NULL,
  attempts = 10,
  numiters = 1e+06,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairnormNum_+3A_smalldf">smalldf</code></td>
<td>
<p>The data frame containing one set of people to be paired. If the two data frames contain different numbers of people, this must be the data frame containing the smallest number.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_smlid">smlid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the smalldf data frame.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_smlage">smlage</code></td>
<td>
<p>The age variable, in the smalldf data frame.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_largedf">largedf</code></td>
<td>
<p>A data frame containing the second set of people to be paired. If the two data frames contain different numbers of people, this must be the data frame containing the largest number.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_lrgid">lrgid</code></td>
<td>
<p>The variable containing the unique ID for each person, in the largedf data frame.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_lrgage">lrgage</code></td>
<td>
<p>The age variable, in the largedf data frame.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_directxi">directxi</code></td>
<td>
<p>If a skew-normal distribution is used, this is the location value. If the default alphaused value of 0 is used, this defaults to the mean value for the normal distribution. Use a positive value if the older ages are in smldf.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_directomega">directomega</code></td>
<td>
<p>If a skew-normal distribution is used, this is the scale value. If the default alphaused value of 0 is used, this defaults to the standard deviation value for the normal distribution.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_alphaused">alphaused</code></td>
<td>
<p>The skew. If a normal distribution is to be used, this can be omitted as the default value is 0 (no skew).</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_hhnumvar">HHNumVar</code></td>
<td>
<p>The household identifier variable. This must exist in only one data frame.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_userseed">userseed</code></td>
<td>
<p>If specified, this will set the seed to the number provided. If not, the normal set.seed() function will be used.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_attempts">attempts</code></td>
<td>
<p>The maximum number of times largedf will be sampled to draw an age match from the correct distribution, for each observation in the smalldf. The default number of attempts is 10.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_numiters">numiters</code></td>
<td>
<p>The maximum number of iterations used to construct the output data frame ($Matched) containing the pairs. The default value is 1000000, and is the stopping rule if the algorithm does not converge.</p>
</td></tr>
<tr><td><code id="pairnormNum_+3A_verbose">verbose</code></td>
<td>
<p>Whether the distribution used, number of iterations used, the critical chi-squared value, and the final chi-squared value are printed to the console. The default value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three data frames $Matched contains the data frame of pairs. $Smaller contains the unmatched observations from smalldf. $Larger contains the unmatched observations from largedf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# parents are older than the children using a normal distribution of mean = 30,
# standard deviation of 5
set.seed(1)
Parents &lt;- Township %&gt;%
  filter(between(Age, 24, 60)) %&gt;%
  slice_sample(n=120, replace = FALSE) %&gt;%
  mutate(HouseholdID = row_number())
Children &lt;- Township %&gt;%
  filter(Age &lt; 20) %&gt;%
  slice_sample(n = nrow(Parents), replace = FALSE)

PrntChld &lt;- pairnormNum(Parents, smlid = "ID", smlage = "Age", Children, lrgid = "ID",
                        lrgage = "Age", directxi = 30, directomega = 5, HHNumVar = "HouseholdID",
                        userseed = 4, attempts=10, numiters = 80)
Matched &lt;- PrntChld$Matched  # all matched but not the specified distribution
UnmatchedAdults &lt;- PrntChld$Smaller
UnmatchedChildren &lt;- PrntChld$Larger
</code></pre>

<hr>
<h2 id='Ppl4networks'>Synthetic people living in the Timaru District</h2><span id='topic+Ppl4networks'></span>

<h3>Description</h3>

<p>1000 synthetic people, to match the number of people in the NetworkMatrix data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ppl4networks
</code></pre>


<h3>Format</h3>

<p>A data frame with 1,000 rows and 5 variables:
</p>

<dl>
<dt>Sex</dt><dd><p>Either Male or Female</p>
</dd>
<dt>Relationship</dt><dd><p>Relationship status of the person</p>
</dd>
<dt>ID</dt><dd><p>The unique identifier for the person</p>
</dd>
<dt>Age</dt><dd><p>The age of the person</p>
</dd>
<dt>HoursWorked</dt><dd><p>The number of hours worked in employment, per week</p>
</dd>
</dl>



<h3>Source</h3>

<p>Timaru District 2018 census data (tablecodes 8277, 8395, and 8460), sourced from Statistics New Zealand. Statistics New Zealand data are licensed by Stats NZ for reuse under the Creative Commons Attribution 4.0 International licence.
</p>

<hr>
<h2 id='RegionalStructure'>Sex/Age pyramid for teenagers in the Canterbury Region</h2><span id='topic+RegionalStructure'></span>

<h3>Description</h3>

<p>The number of people, by age and sex, living in the Canterbury region, restricted to ages 13 to 19 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegionalStructure
</code></pre>


<h3>Format</h3>

<p>A data frame with 14 observations and 4 variables:
</p>

<dl>
<dt>Sex</dt><dd><p>The sex relating to the count</p>
</dd>
<dt>Age.group</dt><dd><p>String variable of age plus the text &quot; years&quot;</p>
</dd>
<dt>Value</dt><dd><p>The count of adolescents</p>
</dd>
<dt>Age</dt><dd><p>The age relating to that count</p>
</dd>
</dl>



<h3>Source</h3>

<p>Canterbury region 2018 census data (tablecode 8277), sourced from Statistics New Zealand. Statistics New Zealand data are licensed by Stats NZ for reuse under the Creative Commons Attribution 4.0 International licence.
</p>

<hr>
<h2 id='SchoolsToUse'>Schools and their roll counts</h2><span id='topic+SchoolsToUse'></span>

<h3>Description</h3>

<p>Nineteen schools in the Canterbury region, with their 2018 roll counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SchoolsToUse
</code></pre>


<h3>Format</h3>

<p>A data frame with 266 rows and 5 variables:
</p>

<dl>
<dt>School.ID</dt><dd><p>The numeric ID for the school</p>
</dd>
<dt>School.Name</dt><dd><p>The name for the school</p>
</dd>
<dt>Gender</dt><dd><p>Indicator of whether the school is (C)o-ed, (F)emale-only, or (M)ale-only</p>
</dd>
<dt>AgeInRoll</dt><dd><p>The age of possible students</p>
</dd>
<dt>RollCount</dt><dd><p>The number of students. The value is 0 if no students that age attend.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Ministry of Education. The Ministry of Education's data are licensed by the Ministry of Education for reuse under the Creative Commons Attribution 4.0 International licence.
</p>

<hr>
<h2 id='SingleAges'>Sex/Age pyramid data for Timaru District</h2><span id='topic+SingleAges'></span>

<h3>Description</h3>

<p>The number of people, by age and sex, living in the Timaru District.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleAges
</code></pre>


<h3>Format</h3>

<p>A data frame with 190 rows and 4 variables:
</p>

<dl>
<dt>Age.group</dt><dd><p>Age group, in five-year age bands</p>
</dd>
<dt>Sex</dt><dd><p>Either Male or Female</p>
</dd>
<dt>Value</dt><dd><p>The number of people that age and sex</p>
</dd>
<dt>Age</dt><dd><p>Age at last birthday</p>
</dd>
</dl>



<h3>Source</h3>

<p>Timaru District 2018 census data (tablecode 8277), sourced from Statistics New Zealand. Statistics New Zealand data are licensed by Stats NZ for reuse under the Creative Commons Attribution 4.0 International licence.
</p>

<hr>
<h2 id='Township'>Simulated township</h2><span id='topic+Township'></span>

<h3>Description</h3>

<p>10,000 simulated people.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Township
</code></pre>


<h3>Format</h3>

<p>A data frame with 10,000 rows and 5 variables
</p>

<dl>
<dt>Sex</dt><dd><p>Sex of the person</p>
</dd>
<dt>Relationship</dt><dd><p>Relationship status of the person</p>
</dd>
<dt>ID</dt><dd><p>The unique identifier for the person</p>
</dd>
<dt>Age</dt><dd><p>The age of the person</p>
</dd>
<dt>HoursWorked</dt><dd><p>The number of hours worked in employment, per week</p>
</dd>
</dl>



<h3>Source</h3>

<p>Timaru District 2018 census data, using tablecodes 8277, 8395, and 8460, sourced from Statistics New Zealand. Statistics New Zealand data are licensed by Stats NZ for reuse under the Creative Commons Attribution 4.0 International licence.
</p>

<hr>
<h2 id='WorkingAdolescents'>Adolescents with a school status and employment hours</h2><span id='topic+WorkingAdolescents'></span>

<h3>Description</h3>

<p>A set of synthetic adolescents aged between 15 and 18.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WorkingAdolescents
</code></pre>


<h3>Format</h3>

<p>A data frame of 478 observations and 6 variables:
</p>

<dl>
<dt>Sex</dt><dd><p>Either Male or Female</p>
</dd>
<dt>Relationship</dt><dd><p>Relationship status of the person</p>
</dd>
<dt>ID</dt><dd><p>The unique identifier for the person</p>
</dd>
<dt>Age</dt><dd><p>Age of the person</p>
</dd>
<dt>HoursWorked</dt><dd><p>The number of hours worked in employment, per week</p>
</dd>
<dt>SchoolStatus</dt><dd><p>The indicator of whether the person is in school (Y) or not (N)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Timaru District 2018 census data (tablecodes 8277, 8395, and 8460). School status was added using school leavers data produced by the Ministry of Education. Statistics New Zealand and the Ministry of Education's data are licensed, separately, for reuse under the Creative Commons Attribution 4.0 International licence.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
