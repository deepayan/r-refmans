<!DOCTYPE html><html><head><title>Help for package PAGFL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PAGFL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pagfl'><p>Pairwise Adaptive Group Fused Lasso</p></a></li>
<li><a href='#sim_DGP'><p>Simulate a Panel With a Latent Group Structure</p></a></li>
<li><a href='#sim_tv_DGP'><p>Simulate a Time-varying Panel With a Latent Group Structure</p></a></li>
<li><a href='#tv_pagfl'><p>Time-varying Pairwise Adaptive Group Fused Lasso</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Joint Estimation of Latent Groups and Group-Specific
Coefficients in Panel Data Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Haimerl &lt;p.haimerl@student.maastrichtuniversity.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Latent group structures are a common challenge in panel data analysis. Disregarding group-level heterogeneity can introduce bias. Conversely, estimating individual coefficients for each cross-sectional unit is inefficient and may lead to high uncertainty.
    This package addresses the issue of unobservable group structures by implementing the pairwise adaptive group fused Lasso (PAGFL) by Mehrabani (2023) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2022.12.002">doi:10.1016/j.jeconom.2022.12.002</a>&gt;. PAGFL identifies latent group structures and group-specific coefficients in a single step.    
    On top of that, we extend the PAGFL to time-varying coefficient functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, lifecycle, ggplot2, RcppParallel</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Paul-Haimerl/PAGFL/issues">https://github.com/Paul-Haimerl/PAGFL/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Paul-Haimerl/PAGFL">https://github.com/Paul-Haimerl/PAGFL</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-08 18:38:01 UTC; PaulAdmin</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Haimerl <a href="https://orcid.org/0000-0003-3198-8317"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Stephan Smeekes <a href="https://orcid.org/0000-0002-0157-639X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ines Wilms <a href="https://orcid.org/0000-0003-3269-4601"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Ali Mehrabani <a href="https://orcid.org/0000-0002-1848-5582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-08 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pagfl'>Pairwise Adaptive Group Fused Lasso</h2><span id='topic+pagfl'></span><span id='topic+PAGFL'></span><span id='topic+print.pagfl'></span><span id='topic+formula.pagfl'></span><span id='topic+df.residual.pagfl'></span><span id='topic+summary.pagfl'></span><span id='topic+coef.pagfl'></span><span id='topic+residuals.pagfl'></span><span id='topic+fitted.pagfl'></span>

<h3>Description</h3>

<p>The pairwise adaptive group fused lasso (<em>PAGFL</em>) by Mehrabani (2023) jointly estimates the latent group structure and group-specific slope parameters in a panel data model.
It can handle static and dynamic panels, either with or without endogenous regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pagfl(
  formula,
  data,
  index = NULL,
  n_periods = NULL,
  lambda,
  method = "PLS",
  Z = NULL,
  min_group_frac = 0.05,
  bias_correc = FALSE,
  kappa = 2,
  max_iter = 5000,
  tol_convergence = 1e-08,
  tol_group = 0.001,
  rho = 0.07 * log(N * n_periods)/sqrt(N * n_periods),
  varrho = max(sqrt(5 * N * n_periods * p)/log(N * n_periods * p) - 7, 1),
  verbose = TRUE,
  parallel = TRUE,
  ...
)

## S3 method for class 'pagfl'
print(x, ...)

## S3 method for class 'pagfl'
formula(x, ...)

## S3 method for class 'pagfl'
df.residual(object, ...)

## S3 method for class 'pagfl'
summary(object, ...)

## S3 method for class 'pagfl'
coef(object, ...)

## S3 method for class 'pagfl'
residuals(object, ...)

## S3 method for class 'pagfl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagfl_+3A_formula">formula</code></td>
<td>
<p>a formula object describing the model to be estimated.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> holding a panel data set. If no <code>index</code> variables are provided, the panel must be balanced and ordered in the long format <code class="reqn">\bold{Y}=(Y_1^\prime, \dots, Y_N^\prime)^\prime</code>, <code class="reqn">Y_i = (Y_{i1}, \dots, Y_{iT})^\prime</code> with <code class="reqn">Y_{it} = (y_{it}, x_{it}^\prime)^\prime</code>. Conversely, if <code>data</code> is not ordered or not balanced, <code>data</code> must include two index variables, declaring the cross-sectional unit <code class="reqn">i</code> and the time period <code class="reqn">t</code> for each observation.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_index">index</code></td>
<td>
<p>a character vector holding two strings specifying the variable names that identify the cross-sectional unit and time period for each observation. The first string denotes the individual unit, while the second string represents the time period. In case of a balanced panel data set that is ordered in the long format, <code>index</code> can be left empty if the the number of time periods <code>n_periods</code> is supplied.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_n_periods">n_periods</code></td>
<td>
<p>the number of observed time periods <code class="reqn">T</code>. If an <code>index</code> character vector is passed, this argument can be left empty.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_lambda">lambda</code></td>
<td>
<p>the tuning parameter. <code class="reqn">\lambda</code> governs the strength of the penalty term. Either a single <code class="reqn">\lambda</code> or a vector of candidate values can be passed. If a vector is supplied, a BIC-type IC automatically selects the best fitting parameter value.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_method">method</code></td>
<td>
<p>the estimation method. Options are
</p>

<dl>
<dt><code>"PLS"</code></dt><dd><p>for using the penalized least squares (<em>PLS</em>) algorithm. We recommend <em>PLS</em> in case of (weakly) exogenous regressors (Mehrabani, 2023, sec. 2.2).</p>
</dd>
<dt><code>"PGMM"</code></dt><dd><p>for using the penalized Generalized Method of Moments (<em>PGMM</em>). <em>PGMM</em> is required when instrumenting endogenous regressors, in which case A matrix <code class="reqn">Z</code> containing the necessary exogenous instruments must be supplied (Mehrabani, 2023, sec. 2.3).</p>
</dd>
</dl>
<p> Default is <code>"PLS"</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_z">Z</code></td>
<td>
<p>a <code class="reqn">NT \times q</code> <code>matrix</code> or <code>data.frame</code> of exogenous instruments, where <code class="reqn">q \geq p</code>, <code class="reqn">\bold{Z}=(z_1, \dots, z_N)^\prime</code>, <code class="reqn">z_i = (z_{i1}, \dots, z_{iT})^\prime</code> and <code class="reqn">z_{it}</code> is a <code class="reqn">q \times 1</code> vector. <code class="reqn">\bold{Z}</code> is only required when <code>method = "PGMM"</code> is selected. When using <code>"PLS"</code>, either pass <code>NULL</code> or <code class="reqn">\bold{Z}</code> is disregarded. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_min_group_frac">min_group_frac</code></td>
<td>
<p>the minimum group size as a fraction of the total number of individuals <code class="reqn">N</code>. In case a group falls short of this threshold, a hierarchical classifier allocates its members to the remaining groups. Default is 0.05.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_bias_correc">bias_correc</code></td>
<td>
<p>logical. If <code>TRUE</code>, a Split-panel Jackknife bias correction following Dhaene and Jochmans (2015) is applied to the slope parameters. We recommend using the correction when facing a dynamic panel. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_kappa">kappa</code></td>
<td>
<p>the a non-negative weight placed on the adaptive penalty weights. Default is 2.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations for the <em>ADMM</em> estimation algorithm. Default is 5000.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_tol_convergence">tol_convergence</code></td>
<td>
<p>the tolerance limit for the stopping criterion of the iterative <em>ADMM</em> estimation algorithm. Default is <code class="reqn">1 * 10^{-8}</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_tol_group">tol_group</code></td>
<td>
<p>the tolerance limit for within-group differences. Two individuals <code class="reqn">i</code>, <code class="reqn">j</code> are assigned to the same group if the Frobenius norm of their coefficient vector difference is below this threshold. Default is 0.001.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_rho">rho</code></td>
<td>
<p>the tuning parameter balancing the fitness and penalty terms in the IC that determines the penalty parameter <code class="reqn">\lambda</code>. If left unspecified, the heuristic <code class="reqn">\rho = 0.07 \frac{\log(NT)}{\sqrt{NT}}</code> of Mehrabani (2023, sec. 6) is used. We recommend the default.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_varrho">varrho</code></td>
<td>
<p>the non-negative Lagrangian <em>ADMM</em> penalty parameter. For <em>PLS</em>, the <code class="reqn">\varrho</code> value is trivial. However, for <em>PGMM</em>, small values lead to slow convergence. If left unspecified, the default heuristic <code class="reqn">\varrho = \max(\frac{\sqrt{5NTp}}{\log(NTp)}-7, 1</code>) is used.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, helpful warning messages are shown. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_parallel">parallel</code></td>
<td>
<p>logical. If <code>TRUE</code>, certain operations are parallelized across multiple cores.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_...">...</code></td>
<td>
<p>ellipsis</p>
</td></tr>
<tr><td><code id="pagfl_+3A_x">x</code></td>
<td>
<p>of class <code>pagfl</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_object">object</code></td>
<td>
<p>of class <code>pagfl</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the grouped panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta^\prime_{i} x_{it} + \epsilon_{it}, \quad i = 1, \dots, N, \; t = 1, \dots, T,</code>
</p>

<p>where <code class="reqn">y_{it}</code> is the scalar dependent variable, <code class="reqn">\gamma_i</code> is an individual fixed effect, <code class="reqn">x_{it}</code> is a <code class="reqn">p \times 1</code> vector of explanatory variables, and <code class="reqn">\epsilon_{it}</code> is a zero mean error.
The coefficient vector <code class="reqn">\beta_i</code> is subject to the latent group pattern
</p>
<p style="text-align: center;"><code class="reqn">\beta_i = \sum_{k = 1}^K \alpha_k \bold{1} \{i \in G_k \},</code>
</p>

<p>with <code class="reqn">\cup_{k = 1}^K G_k = \{1, \dots, N\}</code>, <code class="reqn">G_k \cap G_j = \emptyset</code> and <code class="reqn">\| \alpha_k \| \neq \| \alpha_j \|</code> for any <code class="reqn">k \neq M</code>.
</p>
<p>The <em>PLS</em> method jointly estimates the latent group structure and group-specific coefficient by minimizing the following criterion:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{T} \sum^N_{i=1} \sum^{T}_{t=1}(\tilde{y}_{it} - \beta^\prime_i \tilde{x}_{it})^2 + \frac{\lambda}{N} \sum_{1 \leq i} \sum_{i&lt;j \leq N} \dot{w}_{ij} \| \beta_i - \beta_j \|,</code>
</p>

<p>where <code class="reqn">\tilde{y}_{it}</code> is the demeaned scalar dependent variable, <code class="reqn">\tilde{x}_{it}</code> denotes a <code class="reqn">p \times 1</code> vector of demeaned weakly exogenous explanatory variables, <code class="reqn">\lambda</code> is the penalty tuning parameter and <code class="reqn">\dot{w}_{ij}</code> reflects adaptive penalty weights (see Mehrabani, 2023, eq. 2.6). <code class="reqn">\| \cdot \|</code> denotes the Frobenius norm.
The adaptive weights <code class="reqn">\dot{w}_{ij}</code> are obtained by a preliminary individual least squares estimation.
The solution <code class="reqn">\hat{\bold{\beta}}</code> is computed via an iterative alternating direction method of multipliers (<em>ADMM</em>) algorithm (see Mehrabani, 2023, sec. 5.1).
</p>
<p><em>PGMM</em> employs a set of instruments <code class="reqn">\bold{Z}</code> to control for endogenous regressors. Using <em>PGMM</em>, <code class="reqn">\bold{\beta} = (\beta_1^\prime, \dots, \beta_N^\prime)^\prime</code> is estimated by minimizing:
</p>
<p style="text-align: center;"><code class="reqn">\sum^N_{i = 1} \left[ \frac{1}{N} \sum_{t=1}^T z_{it} (\Delta y_{it} - \beta^\prime_i \Delta x_{it}) \right]^\prime W_i \left[\frac{1}{T} \sum_{t=1}^T z_{it}(\Delta y_{it} - \beta^\prime_i \Delta x_{it}) \right] + \frac{\lambda}{N} \sum_{1 \leq i} \sum_{i&lt;j \leq N} \ddot{w}_{ij} \| \beta_i - \beta_j \|.</code>
</p>

<p><code class="reqn">\ddot{w}_{ij}</code> are obtained by an initial <em>GMM</em> estimation. <code class="reqn">\Delta</code> gives the first differences operator <code class="reqn">\Delta y_{it} = y_{it} - y_{i t-1}</code>. <code class="reqn">W_i</code> represents a data-driven <code class="reqn">q \times q</code> weight matrix. I refer to Mehrabani (2023, eq. 2.10) for more details.
<code class="reqn">\bold{\beta}</code> is again estimated employing an efficient <em>ADMM</em> algorithm (Mehrabani, 2023, sec. 5.2).
</p>
<p>Two individuals are assigned to the same group if <code class="reqn">\| \hat{\beta}_i - \hat{\beta}_j \| \leq \epsilon_{\text{tol}}</code>, where <code class="reqn">\epsilon_{\text{tol}}</code> is given by <code>tol_group</code>. Subsequently, the number of groups follows as the number of distinct elements in <code class="reqn">\hat{\bold{\beta}}</code>. Given an estimated group structure, it is straightforward to obtain post-Lasso estimates using least squares.
</p>
<p>We suggest identifying a suitable <code class="reqn">\lambda</code> parameter by passing a logarithmically spaced grid of candidate values with a lower limit of 0 and an upper limit that leads to a fully homogeneous panel. A BIC-type information criterion then selects the best fitting <code class="reqn">\lambda</code> value.
</p>


<h3>Value</h3>

<p>An object of class <code>pagfl</code> holding
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>a <code>data.frame</code> containing the dependent and explanatory variables as well as cross-sectional and time indices,</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">K \times p</code> matrix of the post-Lasso group-specific parameter estimates,</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a <code>list</code> containing (i) the total number of groups <code class="reqn">\hat{K}</code> and (ii) a vector of estimated group memberships <code class="reqn">(\hat{g}_1, \dots, \hat{g}_N)</code>, where <code class="reqn">\hat{g}_i = k</code> if <code class="reqn">i</code> is assigned to group <code class="reqn">k</code>,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of residuals of the demeaned model,</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of fitted values of the demeaned model,</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>a <code>list</code> of additional arguments,</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>a <code>list</code> containing (i) the value of the IC, (ii) the employed tuning parameter <code class="reqn">\lambda</code>, and (iii) the mean squared error,</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a <code>list</code> containing (i) a logical variable indicating if convergence was achieved and (ii) the number of executed <em>ADMM</em> algorithm iterations,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>A <code>pagfl</code> object has <code>print</code>, <code>summary</code>, <code>fitted</code>, <code>residuals</code>, <code>formula</code>, <code>df.residual</code>, and <code>coef</code> S3 methods.
</p>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>References</h3>

<p>Dhaene, G., &amp; Jochmans, K. (2015). Split-panel jackknife estimation of fixed-effect models. <em>The Review of Economic Studies</em>, 82(3), 991-1030. <a href="https://doi.org/10.1093/restud/rdv007">doi:10.1093/restud/rdv007</a>.
</p>
<p>Mehrabani, A. (2023). Estimation and identification of latent group structures in panel data. <em>Journal of Econometrics</em>, 235(2), 1464-1482. <a href="https://doi.org/10.1016/j.jeconom.2022.12.002">doi:10.1016/j.jeconom.2022.12.002</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a panel with a group structure
sim &lt;- sim_DGP(N = 20, n_periods = 80, p = 2, n_groups = 3)
y &lt;- sim$y
X &lt;- sim$X
df &lt;- cbind(y = c(y), X)

# Run the PAGFL procedure
estim &lt;- pagfl(y ~ ., data = df, n_periods = 80, lambda = 0.5, method = "PLS")
summary(estim)

# Lets pass a panel data set with explicit cross-sectional and time indicators
i_index &lt;- rep(1:20, each = 80)
t_index &lt;- rep(1:80, 20)
df &lt;- data.frame(y = c(y), X, i_index = i_index, t_index = t_index)
estim &lt;- pagfl(
  y ~ ., data = df, index = c("i_index", "t_index"),
  lambda = 0.5, method = "PLS"
)
summary(estim)
</code></pre>

<hr>
<h2 id='sim_DGP'>Simulate a Panel With a Latent Group Structure</h2><span id='topic+sim_DGP'></span>

<h3>Description</h3>

<p>Construct a static or dynamic, exogenous or endogenous panel data set subject to a latent group structure with optional <code class="reqn">AR(1)</code> or <code class="reqn">GARCH(1,1)</code> innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_DGP(
  N = 50,
  n_periods = 40,
  p = 2,
  n_groups = 3,
  group_proportions = NULL,
  error_spec = "iid",
  dynamic = FALSE,
  dyn_panel = lifecycle::deprecated(),
  q = NULL,
  alpha_0 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_DGP_+3A_n">N</code></td>
<td>
<p>the number of cross-sectional units. Default is 50.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_n_periods">n_periods</code></td>
<td>
<p>the number of simulated time periods <code class="reqn">T</code>. Default is 40.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_p">p</code></td>
<td>
<p>the number of explanatory variables. Default is 2.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_n_groups">n_groups</code></td>
<td>
<p>the number of latent groups <code class="reqn">K</code>. Default is 3.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_group_proportions">group_proportions</code></td>
<td>
<p>a numeric vector of length <code>n_groups</code> indicating the fraction of <code class="reqn">N</code> each group will contain. If <code>NULL</code>, all groups are of size <code class="reqn">N / K</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_error_spec">error_spec</code></td>
<td>
<p>options include
</p>

<dl>
<dt><code>"iid"</code></dt><dd><p>for <code class="reqn">iid</code> errors.</p>
</dd>
<dt><code>"AR"</code></dt><dd><p>for an <code class="reqn">AR(1)</code> error process with an autoregressive coefficient of 0.5.</p>
</dd>
<dt><code>"GARCH"</code></dt><dd><p>for a <code class="reqn">GARCH(1,1)</code> error process with a 0.05 constant, a 0.05 ARCH and a 0.9 GARCH coefficient.</p>
</dd>
</dl>

<p>Default is <code>"iid"</code>.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_dynamic">dynamic</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the panel includes one stationary autoregressive lag of <code class="reqn">y_{it}</code> as a regressor (see sec. Details for more information on the <code class="reqn">AR</code> coefficient). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_dyn_panel">dyn_panel</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> deprecated and replaced by <code>dynamic</code>.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_q">q</code></td>
<td>
<p>the number of exogenous instruments when a panel with endogenous regressors is to be simulated. If panel data set with exogenous regressors is supposed to be generated, pass <code>NULL</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_alpha_0">alpha_0</code></td>
<td>
<p>an optional pre-specified <code class="reqn">K \times p</code> coefficient matrix. If <code>dynamic = TRUE</code>, the first column represents the stationary <code class="reqn">AR</code> coefficient. If <code>NULL</code>, the coefficients are drawn randomly (see sec. Details). Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scalar dependent variable <code class="reqn">y_{it}</code> is generated according to the following grouped panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta_i^\prime x_{it} + u_{it}, \quad i = \{1, \dots, N\}, \quad t = \{1, \dots, T\}.</code>
</p>

<p><code class="reqn">\gamma_i</code> represents individual fixed effects and <code class="reqn">x_{it}</code> a <code class="reqn">p \times 1</code> vector of regressors.
The individual slope coefficient vectors <code class="reqn">\beta_i</code> are subject to a latent group structure </p>
<p style="text-align: center;"><code class="reqn">\beta_i = \sum_{k = 1}^K \alpha_k \bold{1} \{i \in G_k\},</code>
</p>
<p> where <code class="reqn">K =</code> <code>n_groups</code>.
As a consequence, the group-level coefficients <code class="reqn">\bold{\alpha} = (\alpha^\prime_1, \dots, \alpha^\prime_K)^\prime</code> follow the partition <code class="reqn">\bold{G}</code> of <code class="reqn">N</code> cross-sectional units <code class="reqn">\bold{G} = (G_1, \dots, G_K)</code> such that <code class="reqn">\cup_{k=1}^K = \{1,\dots,N\}</code> and <code class="reqn">G_k \cap G_l = \emptyset, \; \alpha_k \neq \alpha_l</code> for any two groups <code class="reqn">k \neq l</code> (Mehrabani, 2023, sec. 2.1).
</p>
<p>If a panel data set with exogenous regressors is generated (set <code>q = NULL</code>), the <code class="reqn">p</code> predictors are simulated as:
</p>
<p style="text-align: center;"><code class="reqn">x_{it,j} = 0.2 \gamma_i + e_{it,j}, \quad \gamma_i,e_{it,j} \sim i.i.d. N(0, 1), \quad j = \{1, \dots, p\},</code>
</p>

<p>where <code class="reqn">e_{it,j}</code> denotes a series of innovations. <code class="reqn">\gamma_i</code> and <code class="reqn">e_i</code> are independent of each other.
</p>
<p>In case <code>alpha_0 = NULL</code>, the group-level slope parameters <code class="reqn">\alpha_{k}</code> are drawn from <code class="reqn">\sim U[-2, 2]</code>.
</p>
<p>If a dynamic panel is specified (<code>dynamic = TRUE</code>), the <code class="reqn">AR</code> coefficients <code class="reqn">\beta^{\text{AR}}_i</code> are drawn from a uniform distribution with support <code class="reqn">(-1, 1)</code> and <code class="reqn">x_{it,j} = e_{it,j}</code>.
The individual fixed effects enter the dependent variable via <code class="reqn">(1 - \beta^{\text{AR}}_i) \gamma_i</code> to account for the autoregressive dependency.
I refer to Mehrabani (2023, sec 6) for details.
</p>
<p>When specifying an endogenous panel (set <code>q</code> to <code class="reqn">q \geq p</code>), the <code class="reqn">e_{it,j}</code> correlate with the cross-sectional innovations <code class="reqn">u_{it}</code> by a magnitude of 0.5 to produce endogenous regressors with <code class="reqn">\text{E}(u|X) \neq 0</code>. However, the endogenous regressors can be accounted for by exploiting the <code class="reqn">q</code> instruments in <code class="reqn">\bold{Z}</code>, for which <code class="reqn">\text{E}(u|Z) = 0</code> holds.
The instruments and the first stage coefficients are generated in the same fashion as <code class="reqn">\bold{X}</code> and <code class="reqn">\bold{\alpha}</code> when <code>q = NULL</code>.
</p>
<p>The function nests, among other, the DGPs employed in the simulation study of Mehrabani (2023, sec. 6).
</p>


<h3>Value</h3>

<p>A list holding
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>the <code class="reqn">K \times p</code> matrix of group-specific slope parameters. In case of <code>dynamic = TRUE</code>, the first column holds the <code class="reqn">AR</code> coefficient.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a vector indicating the group memberships <code class="reqn">(g_1, \dots, g_N)</code>, where <code class="reqn">g_i = k</code> if <code class="reqn">i \in</code> group <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code class="reqn">NT \times 1</code> vector of the dependent variable, with <code class="reqn">\bold{y}=(y_1, \dots, y_N)^\prime</code>, <code class="reqn">y_i = (y_{i1}, \dots, y_{iT})^\prime</code> and the scalar <code class="reqn">y_{it}</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">NT \times p</code> matrix of explanatory variables, with <code class="reqn">\bold{X}=(x_1, \dots, x_N)^\prime</code>, <code class="reqn">x_i = (x_{i1}, \dots, x_{iT})^\prime</code> and the <code class="reqn">p \times 1</code> vector <code class="reqn">x_{it}</code>.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>a <code class="reqn">NT \times q</code> matrix of instruments , where <code class="reqn">q \geq p</code>, <code class="reqn">\bold{Z}=(z_1, \dots, z_N)^\prime</code>, <code class="reqn">z_i = (z_{i1}, \dots, z_{iT})^\prime</code> and <code class="reqn">z_{it}</code> is a <code class="reqn">q \times 1</code> vector. In case a panel with exogenous regressors is generated (<code>q = NULL</code>), <code class="reqn">\bold{Z}</code> equals <code>NULL</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a <code class="reqn">NT \times (p + 1)</code> data.frame of the outcome and the explanatory variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>References</h3>

<p>Mehrabani, A. (2023). Estimation and identification of latent group structures in panel data. <em>Journal of Econometrics</em>, 235(2), 1464-1482. <a href="https://doi.org/10.1016/j.jeconom.2022.12.002">doi:10.1016/j.jeconom.2022.12.002</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate DGP 1 from Mehrabani (2023, sec. 6)
alpha_0_DGP1 &lt;- matrix(c(0.4, 1, 1.6, 1.6, 1, 0.4), ncol = 2)
DGP1 &lt;- sim_DGP(
  N = 50, n_periods = 20, p = 2, n_groups = 3,
  group_proportions = c(.4, .3, .3), alpha_0 = alpha_0_DGP1
)
</code></pre>

<hr>
<h2 id='sim_tv_DGP'>Simulate a Time-varying Panel With a Latent Group Structure</h2><span id='topic+sim_tv_DGP'></span>

<h3>Description</h3>

<p>Construct a time-varying panel data set subject to a latent group structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_tv_DGP(
  N = 50,
  n_periods = 40,
  intercept = TRUE,
  p = 1,
  n_groups = 3,
  d = 3,
  dynamic = FALSE,
  group_proportions = NULL,
  error_spec = "iid",
  locations = NULL,
  scales = NULL,
  polynomial_coef = NULL,
  sd_error = 1,
  DGP = lifecycle::deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_tv_DGP_+3A_n">N</code></td>
<td>
<p>the number of cross-sectional units. Default is 50.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_n_periods">n_periods</code></td>
<td>
<p>the number of simulated time periods <code class="reqn">T</code>. Default is 40.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_intercept">intercept</code></td>
<td>
<p>logical. If <code>TRUE</code>, a time-varying intercept is generated.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_p">p</code></td>
<td>
<p>the number of simulated explanatory variables</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_n_groups">n_groups</code></td>
<td>
<p>the number of latent groups <code class="reqn">K</code>. Default is 3.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_d">d</code></td>
<td>
<p>the polynomial degree used to construct the time-varying coefficients.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_dynamic">dynamic</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the panel includes one stationary autoregressive lag of <code class="reqn">y_{it}</code> as a regressor. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_group_proportions">group_proportions</code></td>
<td>
<p>a numeric vector of length <code>n_groups</code> indicating the fraction of <code class="reqn">N</code> each group will contain. If <code>NULL</code>, all groups are of size <code class="reqn">N / K</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_error_spec">error_spec</code></td>
<td>
<p>options include
</p>

<dl>
<dt><code>"iid"</code></dt><dd><p>for <code class="reqn">iid</code> errors.</p>
</dd>
<dt><code>"AR"</code></dt><dd><p>for an <code class="reqn">AR(1)</code> error process with an autoregressive coefficient of 0.5.</p>
</dd>
</dl>

<p>Default is <code>"iid"</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_locations">locations</code></td>
<td>
<p>a <code class="reqn">p \times K</code> matrix of location parameters of a logistic distribution function used to construct the time-varying coefficients. If left empty, the location parameters are drawn randomly. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_scales">scales</code></td>
<td>
<p>a <code class="reqn">p \times K</code> matrix of scale parameters of a logistic distribution function used to construct the time-varying coefficients. If left empty, the location parameters are drawn randomly. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_polynomial_coef">polynomial_coef</code></td>
<td>
<p>a <code class="reqn">p \times d \times K</code> array of coefficients for a the polynomials used to construct the time-varying coefficients. If left empty, the location parameters are drawn randomly. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_sd_error">sd_error</code></td>
<td>
<p>standard deviation of the cross-sectional errors. Default is 1.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_dgp">DGP</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> the data generating process. Options are
</p>

<dl>
<dt>1</dt><dd><p>generates a trend only.</p>
</dd>
<dt>2</dt><dd><p>simulates a trend and an additional exogenous explanatory variable.</p>
</dd>
<dt>1</dt><dd><p>draws a dynamic panel data model with one <code class="reqn">AR</code> lag.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The scalar dependent variable <code class="reqn">y_{it}</code> is driven by the following panel data model:
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta^\prime_{it} x_{it} + u_{it}, \quad i = 1, \dots, N, \; t = 1, \dots, T,</code>
</p>

<p>where <code class="reqn">y_{it}</code> is the scalar dependent variable, <code class="reqn">\gamma_i</code> is an individual fixed effect and <code class="reqn">x_{it}</code> is a <code class="reqn">p \times 1</code> vector of explanatory variables. The errors <code class="reqn">u_{it}</code> feature a <code class="reqn">iid</code> standard normal distribution.
The coefficient vector <code class="reqn">\beta_i = \{\beta_{i1}^\prime, \dots, \beta_{iT}^\prime \}^\prime</code> is subject to the group pattern
</p>
<p style="text-align: center;"><code class="reqn">\beta_i \left( \frac{t}{T} \right) = \sum_{k = 1}^K \alpha_k \left( \frac{t}{T} \right) \bold{1} \{i \in G_k \},</code>
</p>

<p>with <code class="reqn">K =</code><code>n_groups</code>, <code class="reqn">\cup_{k = 1}^K G_k = \{1, \dots, N\}</code>, <code class="reqn">G_k \cap G_j = \emptyset</code> and <code class="reqn">\| \alpha_k \| \neq \| \alpha_j \|</code> for any <code class="reqn">k \neq j</code>.
</p>
<p>The scalar dependent variable <code class="reqn">y_{it}</code> is generated according to the following grouped time-varying panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta_i^\prime (t/T) x_{it} + u_{it}, \quad i = \{1, \dots, N\}, \quad t = \{1, \dots, T\}.</code>
</p>

<p><code class="reqn">\gamma_i</code> represents individual fixed effects and <code class="reqn">x_{it}</code> a <code class="reqn">p \times 1</code> vector of regressors.
The individual functional slope coefficient vectors <code class="reqn">\beta_i (t/T)</code> are subject to a latent group structure <code class="reqn">\beta_i (t/T) = \sum_{k = 1}^K \alpha_k (t/T) \bold{1} \{i \in G_k\}</code>.
As a consequence, the group-level coefficients <code class="reqn">\bold{\alpha} (t/T) = (\alpha^\prime_1 (t/T), \dots, \alpha^\prime_K (t/T))^\prime</code> follow the partition <code class="reqn">\bold{G}</code> of <code class="reqn">N</code> cross-sectional units <code class="reqn">\bold{G} = (G_1, \dots, G_K)</code> such that <code class="reqn">\cup_{k=1}^K = \{1,\dots,N\}</code> and <code class="reqn">G_k \cap G_l = \emptyset, \; \alpha_k \neq \alpha_l</code> for any two groups <code class="reqn">k \neq l</code>.
</p>
<p>The predictors are simulated as:
</p>
<p style="text-align: center;"><code class="reqn">x_{it,j} = 0.2 \gamma_i + e_{it,j}, \quad \gamma_i,e_{it,j} \sim i.i.d. N(0, 1), \quad j = \{1, \dots, p\},</code>
</p>

<p>where <code class="reqn">e_{it,j}</code> denotes a series of innovations. <code class="reqn">\gamma_i</code> and <code class="reqn">e_i</code> are independent of each other.
</p>
<p>In case <code>locations = NULL</code>, the location parameters are drawn from <code class="reqn">\sim U[0.3, 0.9]</code>.
In case <code>scales = NULL</code>, the scale parameters are drawn from <code class="reqn">\sim U[0.01, 0.09]</code>.
In case <code>polynomial_coef = NULL</code>, the polynomial coefficients are drawn from <code class="reqn">\sim U[-20, 20]</code> and normalized so that all coefficients of one polynomial sum up to 1.
The final coefficient function follows as <code class="reqn">\alpha_k (t/T) = 3 * F(t/T, location, scale) + \sum_{j=1}^d a_j (t/T)^j</code>, where <code class="reqn">F(\cdot, location, scale)</code> denotes a cumulative logistic distribution function and <code class="reqn">a_j</code> reflects a polynomial coefficient.
</p>


<h3>Value</h3>

<p>A list holding
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>a <code class="reqn">T \times p \times K</code> array of group-specific time-varying parameters</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a <code class="reqn">T \times p \times N</code> array of individual time-varying parameters</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a vector indicating the group memberships <code class="reqn">(g_1, \dots, g_N)</code>, where <code class="reqn">g_i = k</code> if <code class="reqn">i \in</code> group <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code class="reqn">NT \times 1</code> vector of the dependent variable, with <code class="reqn">\bold{y}=(y_1, \dots, y_N)^\prime</code>, <code class="reqn">y_i = (y_{i1}, \dots, y_{iT})^\prime</code> and the scalar <code class="reqn">y_{it}</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">NT \times p</code> matrix of explanatory variables, with <code class="reqn">\bold{X}=(x_1, \dots, x_N)^\prime</code>, <code class="reqn">x_i = (x_{i1}, \dots, x_{iT})^\prime</code> and the <code class="reqn">p \times 1</code> vector <code class="reqn">x_{it}</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a <code class="reqn">NT \times (p + 1)</code> data.frame of the outcome and the explanatory variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a time-varying panel subject to a time trend and a latent group structure
sim &lt;- sim_tv_DGP(N = 20, n_periods = 50, intercept = TRUE, p = 1)
y &lt;- sim$y

</code></pre>

<hr>
<h2 id='tv_pagfl'>Time-varying Pairwise Adaptive Group Fused Lasso</h2><span id='topic+tv_pagfl'></span><span id='topic+summary.tvpagfl'></span><span id='topic+formula.tvpagfl'></span><span id='topic+df.residual.tvpagfl'></span><span id='topic+print.tvpagfl'></span><span id='topic+coef.tvpagfl'></span><span id='topic+residuals.tvpagfl'></span><span id='topic+fitted.tvpagfl'></span>

<h3>Description</h3>

<p>The time-varying pairwise adaptive group fused lasso (time-varying <em>PAGFL</em>) jointly estimates the latent group structure and group-specific time-varying functional coefficients in a panel data model.
The time-varying coefficients are modeled as polynomial B-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv_pagfl(
  formula,
  data,
  index = NULL,
  n_periods = NULL,
  lambda,
  d = 3,
  M = floor(length(y)^(1/7) - log(p)),
  min_group_frac = 0.05,
  const_coef = NULL,
  kappa = 2,
  max_iter = 20000,
  tol_convergence = 1e-10,
  tol_group = 0.001,
  rho = 0.07 * log(N * n_periods)/sqrt(N * n_periods),
  varrho = 1,
  verbose = TRUE,
  parallel = TRUE,
  ...
)

## S3 method for class 'tvpagfl'
summary(object, ...)

## S3 method for class 'tvpagfl'
formula(x, ...)

## S3 method for class 'tvpagfl'
df.residual(object, ...)

## S3 method for class 'tvpagfl'
print(x, ...)

## S3 method for class 'tvpagfl'
coef(object, ...)

## S3 method for class 'tvpagfl'
residuals(object, ...)

## S3 method for class 'tvpagfl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv_pagfl_+3A_formula">formula</code></td>
<td>
<p>a formula object describing the model to be estimated.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> holding a panel data set. If no <code>index</code> variables are provided, the panel must be balanced and ordered in the long format <code class="reqn">\bold{Y}=(Y_1^\prime, \dots, Y_N^\prime)^\prime</code>, <code class="reqn">Y_i = (Y_{i1}, \dots, Y_{iT})^\prime</code> with <code class="reqn">Y_{it} = (y_{it}, x_{it}^\prime)^\prime</code>. Conversely, if <code>data</code> is not ordered or not balanced, <code>data</code> must include two index variables, declaring the cross-sectional unit <code class="reqn">i</code> and the time period <code class="reqn">t</code> for each observation.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_index">index</code></td>
<td>
<p>a character vector holding two strings specifying the variable names that identify the cross-sectional unit and the time period for each observation. The first string denotes the individual unit, while the second string represents the time period. In case of a balanced panel data set that is ordered in the long format, <code>index</code> can be left empty if the the number of time periods <code>n_periods</code> is supplied. Default is <code>Null</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_n_periods">n_periods</code></td>
<td>
<p>the number of observed time periods <code class="reqn">T</code>. If an <code>index</code> character vector is passed, this argument can be left empty. Default is <code>Null</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_lambda">lambda</code></td>
<td>
<p>the tuning parameter. <code class="reqn">\lambda</code> governs the strength of the penalty term. Either a single <code class="reqn">\lambda</code> or a vector of candidate values can be passed. If a vector is supplied, a BIC-type IC automatically selects the best fitting parameter value.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_d">d</code></td>
<td>
<p>the polynomial degree of the B-splines. Default is 3.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_m">M</code></td>
<td>
<p>the number of interior knots of the B-splines. If left unspecified, the default heuristic <code class="reqn">M = \text{floor}((NT)^{\frac{1}{7}} - \log(p))</code> is used. Note that <code class="reqn">M</code> does not include the boundary knots.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_min_group_frac">min_group_frac</code></td>
<td>
<p>the minimum group size as a fraction of the total number of individuals <code class="reqn">N</code>. In case a group falls short of this threshold, a hierarchical classifier allocates its members to the remaining groups. Default is 0.05.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_const_coef">const_coef</code></td>
<td>
<p>a character vector containing the variable names of explanatory variables that are estimated with time-constant coefficients. All of concerning regressors must be named variables in <code>data</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_kappa">kappa</code></td>
<td>
<p>the a non-negative weight placed on the adaptive penalty weights. Default is 2.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations for the <em>ADMM</em> estimation algorithm. Default is 20,000.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_tol_convergence">tol_convergence</code></td>
<td>
<p>the tolerance limit for the stopping criterion of the iterative <em>ADMM</em> estimation algorithm. Default is <code class="reqn">1 * 10^{-10}</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_tol_group">tol_group</code></td>
<td>
<p>the tolerance limit for within-group differences. Two individuals are assigned to the same group if the Frobenius norm of their coefficient vector difference is below this threshold. Default is 0.001.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_rho">rho</code></td>
<td>
<p>the tuning parameter balancing the fitness and penalty terms in the IC that determines the penalty parameter <code class="reqn">\lambda</code>. If left unspecified, the heuristic <code class="reqn">\rho = 0.07 \frac{\log(NT)}{\sqrt{NT}}</code> of Mehrabani (2023, sec. 6) is used. We recommend the default.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_varrho">varrho</code></td>
<td>
<p>the non-negative Lagrangian <em>ADMM</em> penalty parameter. For the employed penalized sieve estimation <em>PSE</em>, the <code class="reqn">\varrho</code> value is trivial. We recommend the default 1.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, helpful warning messages are shown. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_parallel">parallel</code></td>
<td>
<p>logical. If <code>TRUE</code>, certain operations are parallelized across multiple cores.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_...">...</code></td>
<td>
<p>ellipsis</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_object">object</code></td>
<td>
<p>of class <code>tvpagfl</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_x">x</code></td>
<td>
<p>of class <code>tvpagfl</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the grouped time-varying panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta^\prime_{i} (t/T) x_{it} + \epsilon_{it}, \quad i = 1, \dots, N, \; t = 1, \dots, T,</code>
</p>

<p>where <code class="reqn">y_{it}</code> is the scalar dependent variable, <code class="reqn">\gamma_i</code> is an individual fixed effect, <code class="reqn">x_{it}</code> is a <code class="reqn">p \times 1</code> vector of explanatory variables, and <code class="reqn">\epsilon_{it}</code> is a zero mean error.
The coefficient vector <code class="reqn">\beta_{i} (t/T)</code> is subject to the group pattern
</p>
<p style="text-align: center;"><code class="reqn">\beta_i \left(\frac{t}{T} \right) = \sum_{k = 1}^K \alpha_k \left( \frac{t}{T} \right) \bold{1} \{i \in G_k \},</code>
</p>

<p>with <code class="reqn">\cup_{k = 1}^K G_k = \{1, \dots, N\}</code>, <code class="reqn">G_k \cap G_j = \emptyset</code> and <code class="reqn">\| \alpha_k \| \neq \| \alpha_j \|</code> for any <code class="reqn">k \neq M</code>.
<code class="reqn">\beta_i (t/T)</code>, and <code class="reqn">\alpha_k (t/T)</code> are estimated as polynomial B-splines using penalized sieve-technique. Let <code class="reqn">\bold{B}(v)</code> denote a <code class="reqn">M + d +1</code> vector basis functions, where <code class="reqn">d</code> denotes the polynomial degree and <code class="reqn">M</code> the number of interior knots.
Then, <code class="reqn">\beta_{i}(t/T)</code> and <code class="reqn">\alpha_{i}(t/T)</code> are approximated as <code class="reqn">\beta_{i} (t/T) = \pi_i^\prime \bold{B}(t/T)</code> and <code class="reqn">\alpha_{i}(t/T) = \xi_i^\prime \bold{B}(t/T)</code>, respectively. <code class="reqn">\pi_i</code> and <code class="reqn">\xi_i</code> are <code class="reqn">(M + d + 1) \times p</code> coefficient matrices which weigh the individual basis functions.
The explanatory variables are projected onto the spline basis system, which results in the <code class="reqn">(M + d + 1)*p \times 1</code> vector <code class="reqn">z_{it} = x_{it} \otimes \bold{B}(v)</code>. Subsequently, the DGP can be reformulated as
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + z_{it}^\prime \text{vec}(\pi_{i}) + u_{it},</code>
</p>

<p>where <code class="reqn">u_{it} = \epsilon_{it} + \eta_{it}</code> and <code class="reqn">\eta_{it}</code> contains the sieve approximation error. I refer to Su et al. (2019, sec. 2) for more details on the sieve technique.
</p>
<p>Inspired by Su et al. (2019) and Mehrabani (2023), the time-varying PAGFL estimates the functional coefficients and the group structure by minimizing the criterion:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{NT} \sum^N_{i=1} \sum^{T}_{t=1}(\tilde{y}_{it} - \tilde{z}_{it}^\prime \text{vec}(\pi_{i}))^2 + \frac{\lambda}{N} \sum_{1 \leq i} \sum_{i&lt;j \leq N} \dot{w}_{ij} \| \text{vec}( \pi_i - \pi_j) \|,</code>
</p>

<p>where <code class="reqn">\tilde{y}_{it}</code> is the demeaned dependent variable, and <code class="reqn">\tilde{z}_{it}</code> is likewise demeaned to concentrate out the individual fixed effects <code class="reqn">\gamma_i</code>. <code class="reqn">\lambda</code> is the penalty tuning parameter and <code class="reqn">\dot{w}_{ij}</code> denotes adaptive penalty weights which are obtained by a preliminary non-penalized estimation. <code class="reqn">\| \cdot \|</code> represents the Frobenius norm.
The solution <code class="reqn">\hat{\bold{\beta}}</code> is computed via the iterative alternating direction method of multipliers (<em>ADMM</em>) algorithm proposed in Mehrabani (2023, sec. 5.1), adapted to accommodate the B-spline coefficient functions.
</p>
<p>Two individuals are assigned to the same group if <code class="reqn">\| \text{vec} (\hat{\pi}_i - \hat{\pi}_j) \| \leq \epsilon_{\text{tol}}</code>, where <code class="reqn">\epsilon_{\text{tol}}</code> is given by <code>tol_group</code>. Subsequently, the number of groups follows as the number of distinct elements in <code class="reqn">\hat{\bold{\beta}}</code>. Given an estimated group structure, it is straightforward to obtain post-Lasso estimates using least squares.
</p>
<p>We suggest identifying a suitable <code class="reqn">\lambda</code> parameter by passing a logarithmically spaced grid of candidate values with a lower limit of 0 and an upper limit that leads to a fully homogeneous panel. A BIC-type information criterion then selects the best fitting <code class="reqn">\lambda</code> value.
</p>
<p>In case of an unbalanced panel data set, the earliest and latest available observations out of the entire panel are employed as the start and end-points of the interval on which the time-varying coefficients are defined.
</p>


<h3>Value</h3>

<p>An object of class <code>tvpagfl</code> holding
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>a <code>data.frame</code> containing the dependent and explanatory variables as well as individual and time indices,</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code>list</code> holding (i) a <code class="reqn">T \times p^{(1)} \times \hat{K}</code> array of the post-Lasso group-specific functional coefficients and (ii) a <code class="reqn">K \times p^{(2)}</code> matrix of time-constant post-Lasso estimates. Let <code class="reqn">p^{(1)}</code> denote the number of time-varying coefficients and <code class="reqn">p^{(2)}</code> the number of time constant parameters,</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a <code>list</code> containing (i) the total number of groups <code class="reqn">\hat{K}</code> and (ii) a vector of estimated group memberships <code class="reqn">(\hat{g}_1, \dots, \hat{g}_N)</code>, where <code class="reqn">\hat{g}_i = k</code> if <code class="reqn">i</code> is assigned to group <code class="reqn">k</code>,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of residuals of the demeaned model,</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of fitted values of the demeaned model,</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>a <code>list</code> of additional arguments,</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>a <code>list</code> containing (i) the value of the IC, (ii) the employed tuning parameter <code class="reqn">\lambda</code>, and (iii) the mean squared error,</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a <code>list</code> containing (i) a logical variable if convergence was achieved and (ii) the number of executed <em>ADMM</em> algorithm iterations,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>An object of class <code>tvpagfl</code> has <code>print</code>, <code>summary</code>, <code>fitted</code>, <code>residuals</code>, <code>formula</code>, <code>df.residual</code> and <code>coef</code> S3 methods.
</p>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>References</h3>

<p>Dhaene, G., &amp; Jochmans, K. (2015). Split-panel jackknife estimation of fixed-effect models. <em>The Review of Economic Studies</em>, 82(3), 991-1030. <a href="https://doi.org/10.1093/restud/rdv007">doi:10.1093/restud/rdv007</a>.
</p>
<p>Mehrabani, A. (2023). Estimation and identification of latent group structures in panel data. <em>Journal of Econometrics</em>, 235(2), 1464-1482. <a href="https://doi.org/10.1016/j.jeconom.2022.12.002">doi:10.1016/j.jeconom.2022.12.002</a>.
</p>
<p>Su, L., Wang, X., &amp; Jin, S. (2019). Sieve estimation of time-varying panel data models with latent structures. <em>Journal of Business &amp; Economic Statistics</em>, 37(2), 334-349. <a href="https://doi.org/10.1080/07350015.2017.1340299">doi:10.1080/07350015.2017.1340299</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a time-varying panel with a trend and a group pattern
set.seed(1)
sim &lt;- sim_tv_DGP(N = 5, n_periods = 20, intercept = TRUE, p = 1)
df &lt;- data.frame(y = c(sim$y))

# Run the time-varying PAGFL with only an intercept
estim &lt;- tv_pagfl(y ~ 1, data = df, n_periods = 20, lambda = 13, max_iter = 100, parallel = FALSE)
summary(estim)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
