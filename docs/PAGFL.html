<!DOCTYPE html><html lang="en"><head><title>Help for package PAGFL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PAGFL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grouped_plm'><p>Grouped Panel Data Model</p></a></li>
<li><a href='#grouped_tv_plm'><p>Grouped Time-varying Panel Data Model</p></a></li>
<li><a href='#pagfl'><p>Pairwise Adaptive Group Fused Lasso</p></a></li>
<li><a href='#sim_DGP'><p>Simulate a Panel With a Group Structure in the Slope Coefficients</p></a></li>
<li><a href='#sim_tv_DGP'><p>Simulate a Time-varying Panel With a Group Structure in the Slope Coefficients</p></a></li>
<li><a href='#tv_pagfl'><p>Time-varying Pairwise Adaptive Group Fused Lasso</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Joint Estimation of Latent Groups and Group-Specific
Coefficients in Panel Data Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Haimerl &lt;paul.haimerl@econ.au.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Latent group structures are a common challenge in panel data analysis. Disregarding group-level heterogeneity can introduce bias. Conversely, estimating individual coefficients for each cross-sectional unit is inefficient and may lead to high uncertainty.
    This package addresses the issue of unobservable group structures by implementing the pairwise adaptive group fused Lasso (PAGFL) by Mehrabani (2023) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2022.12.002">doi:10.1016/j.jeconom.2022.12.002</a>&gt;. PAGFL identifies latent group structures and group-specific coefficients in a single step.    
    On top of that, we extend the PAGFL to time-varying coefficient functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel, RcppThread</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, lifecycle, ggplot2, RcppParallel</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Paul-Haimerl/PAGFL/issues">https://github.com/Paul-Haimerl/PAGFL/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Paul-Haimerl/PAGFL">https://github.com/Paul-Haimerl/PAGFL</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-20 12:53:09 UTC; au772358</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Haimerl <a href="https://orcid.org/0000-0003-3198-8317"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Stephan Smeekes <a href="https://orcid.org/0000-0002-0157-639X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ines Wilms <a href="https://orcid.org/0000-0003-3269-4601"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Ali Mehrabani <a href="https://orcid.org/0000-0002-1848-5582"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-20 13:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='grouped_plm'>Grouped Panel Data Model</h2><span id='topic+grouped_plm'></span><span id='topic+print.gplm'></span><span id='topic+formula.gplm'></span><span id='topic+df.residual.gplm'></span><span id='topic+summary.gplm'></span><span id='topic+coef.gplm'></span><span id='topic+residuals.gplm'></span><span id='topic+fitted.gplm'></span>

<h3>Description</h3>

<p>Estimate a grouped panel data model given an observed group structure. Slope parameters are homogeneous within groups but heterogeneous across groups.
This function supports both static and dynamic panel data models, with or without endogenous regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped_plm(
  formula,
  data,
  groups,
  index = NULL,
  n_periods = NULL,
  method = "PLS",
  Z = NULL,
  bias_correc = FALSE,
  rho = 0.07 * log(N * n_periods)/sqrt(N * n_periods),
  verbose = TRUE,
  parallel = TRUE,
  ...
)

## S3 method for class 'gplm'
print(x, ...)

## S3 method for class 'gplm'
formula(x, ...)

## S3 method for class 'gplm'
df.residual(object, ...)

## S3 method for class 'gplm'
summary(object, ...)

## S3 method for class 'gplm'
coef(object, ...)

## S3 method for class 'gplm'
residuals(object, ...)

## S3 method for class 'gplm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grouped_plm_+3A_formula">formula</code></td>
<td>
<p>a formula object describing the model to be estimated.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> holding a panel data set. If no <code>index</code> variables are provided, the panel must be balanced and ordered in the long format <code class="reqn">\bold{Y}=(Y_1^\prime, \dots, Y_N^\prime)^\prime</code>, <code class="reqn">Y_i = (Y_{i1}, \dots, Y_{iT})^\prime</code> with <code class="reqn">Y_{it} = (y_{it}, x_{it}^\prime)^\prime</code>. Conversely, if <code>data</code> is not ordered or not balanced, <code>data</code> must include two index variables that declare the cross-sectional unit <code class="reqn">i</code> and the time period <code class="reqn">t</code> of each observation.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_groups">groups</code></td>
<td>
<p>a numerical or character vector of length <code class="reqn">N</code> that indicates the group membership of each cross-sectional unit <code class="reqn">i</code>.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_index">index</code></td>
<td>
<p>a character vector holding two strings. The first string denotes the name of the index variable identifying the cross-sectional unit <code class="reqn">i</code> and the second string represents the name of the variable declaring the time period <code class="reqn">t</code>. The data is automatically sorted according to the variables in <code>index</code>, which may produce errors when the time index is a character variable. In case of a balanced panel data set that is ordered in the long format, <code>index</code> can be left empty if the the number of time periods <code>n_periods</code> is supplied.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_n_periods">n_periods</code></td>
<td>
<p>the number of observed time periods <code class="reqn">T</code>. If an <code>index</code> is passed, this argument can be left empty.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_method">method</code></td>
<td>
<p>the estimation method. Options are
</p>

<dl>
<dt><code>"PLS"</code></dt><dd><p>for using the penalized least squares (<em>PLS</em>) algorithm. We recommend <em>PLS</em> in case of (weakly) exogenous regressors (Mehrabani, 2023, sec. 2.2).</p>
</dd>
<dt><code>"PGMM"</code></dt><dd><p>for using the penalized Generalized Method of Moments (<em>PGMM</em>). <em>PGMM</em> is required when instrumenting endogenous regressors, in which case a matrix <code class="reqn">\bold{Z}</code> containing the necessary exogenous instruments must be supplied (Mehrabani, 2023, sec. 2.3).</p>
</dd>
</dl>
<p> Default is <code>"PLS"</code>.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_z">Z</code></td>
<td>
<p>a <code class="reqn">NT \times q</code> <code>matrix</code> or <code>data.frame</code> of exogenous instruments, where <code class="reqn">q \geq p</code>, <code class="reqn">\bold{Z}=(z_1, \dots, z_N)^\prime</code>, <code class="reqn">z_i = (z_{i1}, \dots, z_{iT})^\prime</code> and <code class="reqn">z_{it}</code> is a <code class="reqn">q \times 1</code> vector. <code>Z</code> is only required when <code>method = "PGMM"</code> is selected. When using <code>"PLS"</code>, the argument can be left empty or it is disregarded. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_bias_correc">bias_correc</code></td>
<td>
<p>logical. If <code>TRUE</code>, a Split-panel Jackknife bias correction following Dhaene and Jochmans (2015) is applied to the slope parameters. We recommend using the correction when working with dynamic panels. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_rho">rho</code></td>
<td>
<p>a tuning parameter balancing the fitness and penalty terms in the IC. If left unspecified, the heuristic <code class="reqn">\rho = 0.07 \frac{\log(NT)}{\sqrt{NT}}</code> of Mehrabani (2023, sec. 6) is used. We recommend the default.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, helpful warning messages are shown. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_parallel">parallel</code></td>
<td>
<p>logical. If <code>TRUE</code>, certain operations are parallelized across multiple cores. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_...">...</code></td>
<td>
<p>ellipsis</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_x">x</code></td>
<td>
<p>of class <code>gplm</code>.</p>
</td></tr>
<tr><td><code id="grouped_plm_+3A_object">object</code></td>
<td>
<p>of class <code>gplm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the grouped panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta^\prime_{i} x_{it} + \epsilon_{it}, \quad i = 1, \dots, N, \; t = 1, \dots, T,</code>
</p>

<p>where <code class="reqn">y_{it}</code> is the scalar dependent variable, <code class="reqn">\gamma_i</code> is an individual fixed effect, <code class="reqn">x_{it}</code> is a <code class="reqn">p \times 1</code> vector of explanatory variables, and <code class="reqn">\epsilon_{it}</code> is a zero mean error.
The coefficient vector <code class="reqn">\beta_i</code> is subject to the observed group pattern
</p>
<p style="text-align: center;"><code class="reqn">\beta_i = \sum_{k = 1}^K \alpha_k \bold{1} \{i \in G_k \},</code>
</p>

<p>with <code class="reqn">\cup_{k = 1}^K G_k = \{1, \dots, N\}</code>, <code class="reqn">G_k \cap G_j = \emptyset</code> and <code class="reqn">\| \alpha_k - \alpha_j \| \neq 0</code> for any <code class="reqn">k \neq j</code>, <code class="reqn">k = 1, \dots, K</code>.
</p>
<p>Using <em>PLS</em>, the group-specific coefficients for group <code class="reqn">k</code> are obtained via <em>OLS</em>
</p>
<p style="text-align: center;"><code class="reqn">\hat{\alpha}_k = \left( \sum_{i \in G_k} \sum_{t = 1}^T \tilde{x}_{it} \tilde{x}_{it}^\prime \right)^{-1} \sum_{i \in G_k} \sum_{t = 1}^T \tilde{x}_{it} \tilde{y}_{it},</code>
</p>

<p>where <code class="reqn">\tilde{a}_{it} = a_{it} - T^{-1} \sum_{t=1}^T a_{it}</code>, <code class="reqn">a = \{y, x\}</code> to concentrate out the individual fixed effects <code class="reqn">\gamma_i</code> (within-transformation).
</p>
<p>In case of <em>PGMM</em>, the slope coefficients are derived as
</p>
<p style="text-align: center;"><code class="reqn">
\hat{\alpha}_k = \left( \left[ \sum_{i \in G_k} T^{-1} \sum_{t = 1}^T z_{it} \Delta x_{it} \right]^\prime W_k \left[ \sum_{i \in G_k} T^{-1} \sum_{t = 1}^T z_{it} \Delta x_{it} \right] \right)^{-1}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\quad \quad \left[ \sum_{i \in G_k} T^{-1} \sum_{t = 1}^T z_{it} \Delta x_{it} \right]^\prime W_k \left[ \sum_{i \in G_k} T^{-1} \sum_{t = 1}^T z_{it} \Delta y_{it} \right],
</code>
</p>

<p>where <code class="reqn">W_k</code> is a <code class="reqn">q \times q</code> p.d. symmetric weight matrix and <code class="reqn">\Delta</code> denotes the first difference operator <code class="reqn">\Delta x_{it} = x_{it} - x_{it-1}</code> (first-difference transformation).
</p>


<h3>Value</h3>

<p>An object of class <code>gplm</code> holding
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>a <code>data.frame</code> containing the dependent and explanatory variables as well as cross-sectional and time indices,</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">K \times p</code> matrix of the group-specific parameter estimates,</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a <code>list</code> containing (i) the total number of groups <code class="reqn">K</code> and (ii) a vector of group memberships <code class="reqn">g_1, \dots, g_N)</code>, where <code class="reqn">g_i = k</code> if <code class="reqn">i</code> is assigned to group <code class="reqn">k</code>,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of residuals of the demeaned model,</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of fitted values of the demeaned model,</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>a <code>list</code> of additional arguments,</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>a <code>list</code> containing (i) the value of the IC and (ii) the <em>MSE</em>,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>A <code>gplm</code> object has <code>print</code>, <code>summary</code>, <code>fitted</code>, <code>residuals</code>, <code>formula</code>, <code>df.residual</code>, and <code>coef</code> S3 methods.
</p>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>References</h3>

<p>Dhaene, G., &amp; Jochmans, K. (2015). Split-panel jackknife estimation of fixed-effect models. <em>The Review of Economic Studies</em>, 82(3), 991-1030. <a href="https://doi.org/10.1093/restud/rdv007">doi:10.1093/restud/rdv007</a>.
Mehrabani, A. (2023). Estimation and identification of latent group structures in panel data. <em>Journal of Econometrics</em>, 235(2), 1464-1482. <a href="https://doi.org/10.1016/j.jeconom.2022.12.002">doi:10.1016/j.jeconom.2022.12.002</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a panel with a group structure
set.seed(1)
sim &lt;- sim_DGP(N = 20, n_periods = 80, p = 2, n_groups = 3)
y &lt;- sim$y
X &lt;- sim$X
groups &lt;- sim$groups
df &lt;- cbind(y = c(y), X)

# Estimate the grouped panel data model
estim &lt;- grouped_plm(y ~ ., data = df, groups = groups, n_periods = 80, method = "PLS")
summary(estim)

# Lets pass a panel data set with explicit cross-sectional and time indicators
i_index &lt;- rep(1:20, each = 80)
t_index &lt;- rep(1:80, 20)
df &lt;- data.frame(y = c(y), X, i_index = i_index, t_index = t_index)
estim &lt;- grouped_plm(
  y ~ .,
  data = df, index = c("i_index", "t_index"), groups = groups, method = "PLS"
)
summary(estim)
</code></pre>

<hr>
<h2 id='grouped_tv_plm'>Grouped Time-varying Panel Data Model</h2><span id='topic+grouped_tv_plm'></span><span id='topic+summary.tv_gplm'></span><span id='topic+formula.tv_gplm'></span><span id='topic+df.residual.tv_gplm'></span><span id='topic+print.tv_gplm'></span><span id='topic+coef.tv_gplm'></span><span id='topic+residuals.tv_gplm'></span><span id='topic+fitted.tv_gplm'></span>

<h3>Description</h3>

<p>Estimate a grouped time-varying panel data model given an observed group structure. Coefficient functions are homogeneous within groups but heterogeneous across groups.
The time-varying coefficients are modeled as polynomial B-splines. The function supports both static and dynamic panel data models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped_tv_plm(
  formula,
  data,
  groups,
  index = NULL,
  n_periods = NULL,
  d = 3,
  M = floor(length(y)^(1/7) - log(p)),
  const_coef = NULL,
  rho = 0.04 * log(N * n_periods)/sqrt(N * n_periods),
  verbose = TRUE,
  parallel = TRUE,
  ...
)

## S3 method for class 'tv_gplm'
summary(object, ...)

## S3 method for class 'tv_gplm'
formula(x, ...)

## S3 method for class 'tv_gplm'
df.residual(object, ...)

## S3 method for class 'tv_gplm'
print(x, ...)

## S3 method for class 'tv_gplm'
coef(object, ...)

## S3 method for class 'tv_gplm'
residuals(object, ...)

## S3 method for class 'tv_gplm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grouped_tv_plm_+3A_formula">formula</code></td>
<td>
<p>a formula object describing the model to be estimated.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> holding a panel data set. If no <code>index</code> variables are provided, the panel must be balanced and ordered in the long format <code class="reqn">\bold{Y}=(Y_1^\prime, \dots, Y_N^\prime)^\prime</code>, <code class="reqn">Y_i = (Y_{i1}, \dots, Y_{iT})^\prime</code> with <code class="reqn">Y_{it} = (y_{it}, x_{it}^\prime)^\prime</code>. Conversely, if <code>data</code> is not ordered or not balanced, <code>data</code> must include two index variables that declare the cross-sectional unit <code class="reqn">i</code> and the time period <code class="reqn">t</code> of each observation.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_groups">groups</code></td>
<td>
<p>a numerical or character vector of length <code class="reqn">N</code> that indicates the group membership of each cross-sectional unit <code class="reqn">i</code>.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_index">index</code></td>
<td>
<p>a character vector holding two strings. The first string denotes the name of the index variable identifying the cross-sectional unit <code class="reqn">i</code>, and the second string represents the name of the variable declaring the time period <code class="reqn">t</code>. The data is automatically sorted according to the variables in <code>index</code>, which may produce errors when the time index is a character variable. In case of a balanced panel data set that is ordered in the long format, <code>index</code> can be left empty if the the number of time periods <code>n_periods</code> is supplied.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_n_periods">n_periods</code></td>
<td>
<p>the number of observed time periods <code class="reqn">T</code>. If an <code>index</code> character vector is passed, this argument can be left empty. Default is <code>Null</code>.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_d">d</code></td>
<td>
<p>the polynomial degree of the B-splines. Default is 3.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_m">M</code></td>
<td>
<p>the number of interior knots of the B-splines. If left unspecified, the default heuristic <code class="reqn">M = \text{floor}((NT)^{\frac{1}{7}} - \log(p))</code> is used. Note that <code class="reqn">M</code> does not include the boundary knots and the entire sequence of knots is of length <code class="reqn">M + d + 1</code>.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_const_coef">const_coef</code></td>
<td>
<p>a character vector containing the variable names of explanatory variables that enter with time-constant coefficients.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_rho">rho</code></td>
<td>
<p>the tuning parameter balancing the fitness and penalty terms in the IC. If left unspecified, the heuristic <code class="reqn">\rho = 0.07 \frac{\log(NT)}{\sqrt{NT}}</code> of Mehrabani (2023, sec. 6) is used. We recommend the default.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, helpful warning messages are shown. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_parallel">parallel</code></td>
<td>
<p>logical. If <code>TRUE</code>, certain operations are parallelized across multiple cores. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_...">...</code></td>
<td>
<p>ellipsis</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_object">object</code></td>
<td>
<p>of class <code>tv_gplm</code>.</p>
</td></tr>
<tr><td><code id="grouped_tv_plm_+3A_x">x</code></td>
<td>
<p>of class <code>tv_gplm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the grouped time-varying panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta^\prime_{i} (t/T) x_{it} + \epsilon_{it}, \quad i = 1, \dots, N, \; t = 1, \dots, T,</code>
</p>

<p>where <code class="reqn">y_{it}</code> is the scalar dependent variable, <code class="reqn">\gamma_i</code> is an individual fixed effect, <code class="reqn">x_{it}</code> is a <code class="reqn">p \times 1</code> vector of explanatory variables, and <code class="reqn">\epsilon_{it}</code> is a zero mean error.
The coefficient vector <code class="reqn">\beta_{i} (t/T)</code> is subject to the observed group pattern
</p>
<p style="text-align: center;"><code class="reqn">\beta_i \left(\frac{t}{T} \right) = \sum_{k = 1}^K \alpha_k \left( \frac{t}{T} \right) \bold{1} \{i \in G_k \},</code>
</p>

<p>with <code class="reqn">\cup_{k = 1}^K G_k = \{1, \dots, N\}</code>, <code class="reqn">G_k \cap G_j = \emptyset</code> and <code class="reqn">\| \alpha_k - \alpha_j \| \neq 0</code> for any <code class="reqn">k \neq j</code>, <code class="reqn">k = 1, \dots, K</code>.
</p>
<p><code class="reqn">\alpha_k (t/T)</code> and, in turn, <code class="reqn">\beta_i (t/T)</code> is estimated as polynomial B-splines using the penalized sieve-technique. To this end, let <code class="reqn">B(v)</code> denote a <code class="reqn">M + d +1</code> vector of polynomial spline basis functions, where <code class="reqn">d</code> represents the polynomial degree and <code class="reqn">M</code> gives the number of interior knots of the B-spline.
<code class="reqn">\alpha_{k}(t/T)</code> is approximated by forming a linear combination of the basis functions <code class="reqn">\alpha_{k}(t/T) \approx \xi_k^\prime B(t/T)</code>, where <code class="reqn">\xi_k</code> is a <code class="reqn">(M + d + 1) \times p</code> coefficient matrix.
</p>
<p>The explanatory variables are projected onto the spline basis system, which results in the <code class="reqn">(M + d + 1)p \times 1</code> vector <code class="reqn">z_{it} = x_{it} \otimes B(v)</code>. Subsequently, the DGP can be reformulated as
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + z_{it}^\prime \text{vec}(\pi_{i}) + u_{it},</code>
</p>

<p>where <code class="reqn">\pi_i = \xi_k</code> if <code class="reqn">i \in G_k</code>, <code class="reqn">u_{it} = \epsilon_{it} + \eta_{it}</code>, and <code class="reqn">\eta_{it}</code> reflects a sieve approximation error. We refer to Su et al. (2019, sec. 2) for more details on the sieve technique.
</p>
<p>Finally, <code class="reqn">\hat{\alpha}_{k}(t/T)</code> is obtained as <code class="reqn">\hat{\alpha}_{k}(t/T) = \hat{\xi}_k^\prime B(t/T)</code>, where the vector of control points <code class="reqn">\xi_k</code> is estimated using <em>OLS</em>
</p>
<p style="text-align: center;"><code class="reqn">\hat{\xi}_k = \left( \sum_{i \in G_k} \sum_{t = 1}^T \tilde{z}_{it} \tilde{z}_{it}^\prime \right)^{-1} \sum_{i \in G_k} \sum_{t = 1}^T \tilde{z}_{it} \tilde{y}_{it},</code>
</p>

<p>and <code class="reqn">\tilde{a}_{it} = a_{it} - T^{-1} \sum_{t = 1}^T a_{it}</code>, <code class="reqn">a = \{y, z\}</code> to concentrate out the fixed effect <code class="reqn">\gamma_i</code> (within-transformation).
</p>
<p>In case of an unbalanced panel data set, the earliest and latest available observations per group define the start and end-points of the interval on which the group-specific time-varying coefficients are defined.
</p>


<h3>Value</h3>

<p>An object of class <code>tv_gplm</code> holding
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>a <code>data.frame</code> containing the dependent and explanatory variables as well as cross-sectional and time indices,</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>let <code class="reqn">p^{(1)}</code> denote the number of time-varying and <code class="reqn">p^{(2)}</code> the number of time constant coefficients. A <code>list</code> holding (i) a <code class="reqn">T \times p^{(1)} \times K</code> array of the group-specific functional coefficients and (ii) a <code class="reqn">K \times p^{(2)}</code> matrix of time-constant estimates.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a <code>list</code> containing (i) the total number of groups <code class="reqn">K</code> and (ii) a vector of group memberships <code class="reqn">(\hat{g}_1, \dots, \hat{g}_N)</code>, where <code class="reqn">\hat{g}_i = k</code> if <code class="reqn">i</code> is part of group <code class="reqn">k</code>,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of residuals of the demeaned model,</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of fitted values of the demeaned model,</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>a <code>list</code> of additional arguments,</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>a <code>list</code> containing (i) the value of the IC and (ii) the <em>MSE</em>,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>An object of class <code>tv_gplm</code> has <code>print</code>, <code>summary</code>, <code>fitted</code>, <code>residuals</code>, <code>formula</code>, <code>df.residual</code> and <code>coef</code> S3 methods.
</p>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>References</h3>

<p>Su, L., Wang, X., &amp; Jin, S. (2019). Sieve estimation of time-varying panel data models with latent structures. <em>Journal of Business &amp; Economic Statistics</em>, 37(2), 334-349. <a href="https://doi.org/10.1080/07350015.2017.1340299">doi:10.1080/07350015.2017.1340299</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a time-varying panel with a trend and a group pattern
set.seed(1)
sim &lt;- sim_tv_DGP(N = 10, n_periods = 50, intercept = TRUE, p = 2)
df &lt;- data.frame(y = c(sim$y), X = sim$X)
groups &lt;- sim$groups

# Estimate the time-varying grouped panel data model
estim &lt;- grouped_tv_plm(y ~ ., data = df, n_periods = 50, groups = groups)
summary(estim)

</code></pre>

<hr>
<h2 id='pagfl'>Pairwise Adaptive Group Fused Lasso</h2><span id='topic+pagfl'></span><span id='topic+PAGFL'></span><span id='topic+print.pagfl'></span><span id='topic+formula.pagfl'></span><span id='topic+df.residual.pagfl'></span><span id='topic+summary.pagfl'></span><span id='topic+coef.pagfl'></span><span id='topic+residuals.pagfl'></span><span id='topic+fitted.pagfl'></span>

<h3>Description</h3>

<p>Estimate panel data models with a latent group structure using the pairwise adaptive group fused Lasso (<em>PAGFL</em>) by Mehrabani (2023). The <em>PAGFL</em> jointly identifies the group structure and group-specific slope parameters.
The function supports both static and dynamic panels, with or without endogenous regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pagfl(
  formula,
  data,
  index = NULL,
  n_periods = NULL,
  lambda,
  method = "PLS",
  Z = NULL,
  min_group_frac = 0.05,
  bias_correc = FALSE,
  kappa = 2,
  max_iter = 5000,
  tol_convergence = 1e-08,
  tol_group = 0.001,
  rho = 0.07 * log(N * n_periods)/sqrt(N * n_periods),
  varrho = max(sqrt(5 * N * n_periods * p)/log(N * n_periods * p) - 7, 1),
  verbose = TRUE,
  parallel = TRUE,
  ...
)

## S3 method for class 'pagfl'
print(x, ...)

## S3 method for class 'pagfl'
formula(x, ...)

## S3 method for class 'pagfl'
df.residual(object, ...)

## S3 method for class 'pagfl'
summary(object, ...)

## S3 method for class 'pagfl'
coef(object, ...)

## S3 method for class 'pagfl'
residuals(object, ...)

## S3 method for class 'pagfl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pagfl_+3A_formula">formula</code></td>
<td>
<p>a formula object describing the model to be estimated.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> holding a panel data set. If no <code>index</code> variables are provided, the panel must be balanced and ordered in the long format <code class="reqn">\bold{Y}=(Y_1^\prime, \dots, Y_N^\prime)^\prime</code>, <code class="reqn">Y_i = (Y_{i1}, \dots, Y_{iT})^\prime</code> with <code class="reqn">Y_{it} = (y_{it}, x_{it}^\prime)^\prime</code>. Conversely, if <code>data</code> is not ordered or not balanced, <code>data</code> must include two index variables that declare the cross-sectional unit <code class="reqn">i</code> and the time period <code class="reqn">t</code> of each observation.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_index">index</code></td>
<td>
<p>a character vector holding two strings. The first string denotes the name of the index variable identifying the cross-sectional unit <code class="reqn">i</code> and the second string represents the name of the variable declaring the time period <code class="reqn">t</code>. The data is automatically sorted according to the variables in <code>index</code>, which may produce errors when the time index is a character variable. In case of a balanced panel data set that is ordered in the long format, <code>index</code> can be left empty if the the number of time periods <code>n_periods</code> is supplied.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_n_periods">n_periods</code></td>
<td>
<p>the number of observed time periods <code class="reqn">T</code>. If an <code>index</code> character vector is passed, this argument can be left empty.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_lambda">lambda</code></td>
<td>
<p>the tuning parameter determining the strength of the penalty term. Either a single <code class="reqn">\lambda</code> or a vector of candidate values can be passed. If a vector is supplied, a BIC-type IC automatically selects the best fitting <code class="reqn">\lambda</code> value.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_method">method</code></td>
<td>
<p>the estimation method. Options are
</p>

<dl>
<dt><code>"PLS"</code></dt><dd><p>for using the penalized least squares (<em>PLS</em>) algorithm. We recommend <em>PLS</em> in case of (weakly) exogenous regressors (Mehrabani, 2023, sec. 2.2).</p>
</dd>
<dt><code>"PGMM"</code></dt><dd><p>for using the penalized Generalized Method of Moments (<em>PGMM</em>). <em>PGMM</em> is required when instrumenting endogenous regressors, in which case a matrix <code class="reqn">\bold{Z}</code> containing the necessary exogenous instruments must be supplied (Mehrabani, 2023, sec. 2.3).</p>
</dd>
</dl>
<p> Default is <code>"PLS"</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_z">Z</code></td>
<td>
<p>a <code class="reqn">NT \times q</code> <code>matrix</code> or <code>data.frame</code> of exogenous instruments, where <code class="reqn">q \geq p</code>, <code class="reqn">\bold{Z}=(z_1, \dots, z_N)^\prime</code>, <code class="reqn">z_i = (z_{i1}, \dots, z_{iT})^\prime</code> and <code class="reqn">z_{it}</code> is a <code class="reqn">q \times 1</code> vector. <code>Z</code> is only required when <code>method = "PGMM"</code> is selected. When using <code>"PLS"</code>, either pass <code>NULL</code> or <code>Z</code> is disregarded. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_min_group_frac">min_group_frac</code></td>
<td>
<p>the minimum group cardinality as a fraction of the total number of individuals <code class="reqn">N</code>. In case a group falls short of this threshold, each of its members is allocated to one of the remaining groups according to the <em>MSE</em>. Default is 0.05.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_bias_correc">bias_correc</code></td>
<td>
<p>logical. If <code>TRUE</code>, a Split-panel Jackknife bias correction following Dhaene and Jochmans (2015) is applied to the slope parameters. We recommend using the correction when working with dynamic panels. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_kappa">kappa</code></td>
<td>
<p>the a non-negative weight used to obtain the adaptive penalty weights. Default is 2.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations for the <em>ADMM</em> estimation algorithm. Default is <code class="reqn">1*10^4</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_tol_convergence">tol_convergence</code></td>
<td>
<p>the tolerance limit for the stopping criterion of the iterative <em>ADMM</em> estimation algorithm. Default is <code class="reqn">1*10^{-8}</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_tol_group">tol_group</code></td>
<td>
<p>the tolerance limit for within-group differences. Two individuals <code class="reqn">i</code>, <code class="reqn">j</code> are assigned to the same group if the Frobenius norm of their coefficient vector difference is below this threshold. Default is <code class="reqn">1*10^{-3}</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_rho">rho</code></td>
<td>
<p>the tuning parameter balancing the fitness and penalty terms in the IC that determines the penalty parameter <code class="reqn">\lambda</code>. If left unspecified, the heuristic <code class="reqn">\rho = 0.07 \frac{\log(NT)}{\sqrt{NT}}</code> of Mehrabani (2023, sec. 6) is used. We recommend the default.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_varrho">varrho</code></td>
<td>
<p>the non-negative Lagrangian <em>ADMM</em> penalty parameter. For <em>PLS</em>, the <code class="reqn">\varrho</code> value is trivial. However, for <em>PGMM</em>, small values lead to slow convergence. If left unspecified, the default heuristic <code class="reqn">\varrho = \max(\frac{\sqrt{5NTp}}{\log(NTp)}-7, 1</code>) is used.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, helpful warning messages are shown. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_parallel">parallel</code></td>
<td>
<p>logical. If <code>TRUE</code>, certain operations are parallelized across multiple cores. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_...">...</code></td>
<td>
<p>ellipsis</p>
</td></tr>
<tr><td><code id="pagfl_+3A_x">x</code></td>
<td>
<p>of class <code>pagfl</code>.</p>
</td></tr>
<tr><td><code id="pagfl_+3A_object">object</code></td>
<td>
<p>of class <code>pagfl</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the grouped panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta^\prime_{i} x_{it} + \epsilon_{it}, \quad i = 1, \dots, N, \; t = 1, \dots, T,</code>
</p>

<p>where <code class="reqn">y_{it}</code> is the scalar dependent variable, <code class="reqn">\gamma_i</code> is an individual fixed effect, <code class="reqn">x_{it}</code> is a <code class="reqn">p \times 1</code> vector of weakly exogenous explanatory variables, and <code class="reqn">\epsilon_{it}</code> is a zero mean error.
The coefficient vector <code class="reqn">\beta_i</code> is subject to the latent group pattern
</p>
<p style="text-align: center;"><code class="reqn">\beta_i = \sum_{k = 1}^K \alpha_k \bold{1} \{i \in G_k \},</code>
</p>

<p>with <code class="reqn">\cup_{k = 1}^K G_k = \{1, \dots, N\}</code>, <code class="reqn">G_k \cap G_j = \emptyset</code> and <code class="reqn">\| \alpha_k - \alpha_j \| \neq 0</code> for any <code class="reqn">k \neq j</code>, <code class="reqn">k = 1, \dots, K</code>.
</p>
<p>The <em>PLS</em> method jointly estimates the latent group structure and group-specific coefficients by minimizing the criterion
</p>
<p style="text-align: center;"><code class="reqn">Q_{NT} (\bold{\beta}, \lambda) = \frac{1}{T} \sum^N_{i=1} \sum^{T}_{t=1}(\tilde{y}_{it} - \beta^\prime_i \tilde{x}_{it})^2 + \frac{\lambda}{N} \sum_{i = 1}^{N - 1} \sum_{j&gt;i}^N \dot{\omega}_{ij} \| \beta_i - \beta_j \|</code>
</p>

<p>with respect to <code class="reqn">\bold{\beta} = (\beta_1^\prime, \dots, \beta_N^\prime)^\prime</code>. <code class="reqn">\tilde{a}_{it} = a_{it} - T^{-1} \sum_{t = 1}^T a_{it}</code>, <code class="reqn">a = \{y,x\}</code> to concentrate out the individual fixed effects <code class="reqn">\gamma_i</code>. <code class="reqn">\lambda</code> is the penalty tuning parameter and <code class="reqn">\dot{\omega}_{ij}</code> reflects adaptive penalty weights (see Mehrabani, 2023, eq. 2.6). <code class="reqn">\| \cdot \|</code> denotes the Frobenius norm.
The adaptive weights <code class="reqn">\dot{w}_{ij}</code> are obtained by a preliminary individual least squares estimation.
The criterion function is minimized via an iterative alternating direction method of multipliers (<em>ADMM</em>) algorithm (see Mehrabani, 2023, sec. 5.1).
</p>
<p><em>PGMM</em> employs a set of instruments <code class="reqn">\bold{Z}</code> to control for endogenous regressors. Using <em>PGMM</em>, <code class="reqn">\bold{\beta}</code> is estimated by minimizing
</p>
<p style="text-align: center;"><code class="reqn">
Q_{NT}(\bold{\beta}, \lambda) = \sum^N_{i = 1} \left[ \frac{1}{N} \sum_{t=1}^T z_{it} (\Delta y_{it} - \beta^\prime_i \Delta x_{it}) \right]^\prime W_i \left[\frac{1}{T} \sum_{t=1}^T z_{it}(\Delta y_{it} - \beta^\prime_i \Delta x_{it}) \right]
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\quad + \frac{\lambda}{N} \sum_{i = 1}^{N - 1} \sum_{j &gt; i}^N \ddot{\omega}_{ij} \| \beta_i - \beta_j \|.
</code>
</p>

<p><code class="reqn">\ddot{\omega}_{ij}</code> are obtained by an initial <em>GMM</em> estimation. <code class="reqn">\Delta</code> gives the first differences operator <code class="reqn">\Delta y_{it} = y_{it} - y_{i t-1}</code>. <code class="reqn">W_i</code> represents a data-driven <code class="reqn">q \times q</code> weight matrix. I refer to Mehrabani (2023, eq. 2.10) for more details.
Again, the criterion function is minimized using an efficient <em>ADMM</em> algorithm (Mehrabani, 2023, sec. 5.2).
</p>
<p>Two individuals are assigned to the same group if <code class="reqn">\| \hat{\beta}_i - \hat{\beta}_j \| \leq \epsilon_{\text{tol}}</code>, where <code class="reqn">\epsilon_{\text{tol}}</code> is determined by <code>tol_group</code>. Subsequently, the number of groups follows as the number of distinct elements in <code class="reqn">\hat{\bold{\beta}}</code>. Given an estimated group structure, it is straightforward to obtain post-Lasso estimates using group-wise least squares or <em>GMM</em> (see <code><a href="#topic+grouped_plm">grouped_plm</a></code>).
</p>
<p>We recommend identifying a suitable <code class="reqn">\lambda</code> parameter by passing a logarithmically spaced grid of candidate values with a lower limit close to 0 and an upper limit that leads to a fully homogeneous panel. A BIC-type information criterion then selects the best fitting <code class="reqn">\lambda</code> value.
</p>


<h3>Value</h3>

<p>An object of class <code>pagfl</code> holding
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>a <code>data.frame</code> containing the dependent and explanatory variables as well as cross-sectional and time indices,</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">\hat{K} \times p</code> matrix of the post-Lasso group-specific parameter estimates,</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a <code>list</code> containing (i) the total number of groups <code class="reqn">\hat{K}</code> and (ii) a vector of estimated group memberships <code class="reqn">(\hat{g}_1, \dots, \hat{g}_N)</code>, where <code class="reqn">\hat{g}_i = k</code> if <code class="reqn">i</code> is assigned to group <code class="reqn">k</code>,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of residuals of the demeaned model,</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of fitted values of the demeaned model,</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>a <code>list</code> of additional arguments,</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>a <code>list</code> containing (i) the value of the IC, (ii) the employed tuning parameter <code class="reqn">\lambda</code>, and (iii) the <em>MSE</em>,</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a <code>list</code> containing (i) a logical variable indicating if convergence was achieved and (ii) the number of executed <em>ADMM</em> algorithm iterations,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>A <code>pagfl</code> object has <code>print</code>, <code>summary</code>, <code>fitted</code>, <code>residuals</code>, <code>formula</code>, <code>df.residual</code>, and <code>coef</code> S3 methods.
</p>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>References</h3>

<p>Dhaene, G., &amp; Jochmans, K. (2015). Split-panel jackknife estimation of fixed-effect models. <em>The Review of Economic Studies</em>, 82(3), 991-1030. <a href="https://doi.org/10.1093/restud/rdv007">doi:10.1093/restud/rdv007</a>.
Mehrabani, A. (2023). Estimation and identification of latent group structures in panel data. <em>Journal of Econometrics</em>, 235(2), 1464-1482. <a href="https://doi.org/10.1016/j.jeconom.2022.12.002">doi:10.1016/j.jeconom.2022.12.002</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a panel with a group structure
set.seed(1)
sim &lt;- sim_DGP(N = 20, n_periods = 80, p = 2, n_groups = 3)
y &lt;- sim$y
X &lt;- sim$X
df &lt;- cbind(y = c(y), X)

# Run the PAGFL procedure
estim &lt;- pagfl(y ~ ., data = df, n_periods = 80, lambda = 0.5, method = "PLS")
summary(estim)

# Lets pass a panel data set with explicit cross-sectional and time indicators
i_index &lt;- rep(1:20, each = 80)
t_index &lt;- rep(1:80, 20)
df &lt;- data.frame(y = c(y), X, i_index = i_index, t_index = t_index)
estim &lt;- pagfl(
  y ~ .,
  data = df, index = c("i_index", "t_index"), lambda = 0.5, method = "PLS"
)
summary(estim)
</code></pre>

<hr>
<h2 id='sim_DGP'>Simulate a Panel With a Group Structure in the Slope Coefficients</h2><span id='topic+sim_DGP'></span>

<h3>Description</h3>

<p>Construct a static or dynamic, exogenous or endogenous panel data set subject to a group structure in the slope coefficients with optional <code class="reqn">AR(1)</code> or <code class="reqn">GARCH(1,1)</code> innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_DGP(
  N = 50,
  n_periods = 40,
  p = 2,
  n_groups = 3,
  group_proportions = NULL,
  error_spec = "iid",
  dynamic = FALSE,
  dyn_panel = lifecycle::deprecated(),
  q = NULL,
  alpha_0 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_DGP_+3A_n">N</code></td>
<td>
<p>the number of cross-sectional units. Default is 50.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_n_periods">n_periods</code></td>
<td>
<p>the number of simulated time periods <code class="reqn">T</code>. Default is 40.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_p">p</code></td>
<td>
<p>the number of explanatory variables. Default is 2.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_n_groups">n_groups</code></td>
<td>
<p>the number of groups <code class="reqn">K</code>. Default is 3.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_group_proportions">group_proportions</code></td>
<td>
<p>a numeric vector of length <code>n_groups</code> indicating size of each group as a fraction of <code class="reqn">N</code>. If <code>NULL</code>, all groups are of size <code class="reqn">N / K</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_error_spec">error_spec</code></td>
<td>
<p>options include
</p>

<dl>
<dt><code>"iid"</code></dt><dd><p>for <code class="reqn">iid</code> errors.</p>
</dd>
<dt><code>"AR"</code></dt><dd><p>for an <code class="reqn">AR(1)</code> error process with an autoregressive coefficient of 0.5.</p>
</dd>
<dt><code>"GARCH"</code></dt><dd><p>for a <code class="reqn">GARCH(1,1)</code> error process with a 0.05 constant, a 0.05 ARCH and a 0.9 GARCH coefficient.</p>
</dd>
</dl>

<p>Default is <code>"iid"</code>.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_dynamic">dynamic</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the panel includes one stationary autoregressive lag of <code class="reqn">y_{it}</code> as an explanatory variable (see sec. Details for more information on the <code class="reqn">AR</code> coefficient). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_dyn_panel">dyn_panel</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> deprecated and replaced by <code>dynamic</code>.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_q">q</code></td>
<td>
<p>the number of exogenous instruments when a panel with endogenous regressors is to be simulated. If panel data set with exogenous regressors is supposed to be generated, pass <code>NULL</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_DGP_+3A_alpha_0">alpha_0</code></td>
<td>
<p>a <code class="reqn">K \times p</code> matrix of group-specific coefficients. If <code>dynamic = TRUE</code>, the first column represents the stationary <code class="reqn">AR</code> coefficient. If <code>NULL</code>, the coefficients are drawn randomly (see sec. Details). Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scalar dependent variable <code class="reqn">y_{it}</code> is generated according to the following grouped panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta_i^\prime x_{it} + u_{it}, \quad i = \{1, \dots, N\}, \quad t = \{1, \dots, T\}.</code>
</p>

<p><code class="reqn">\gamma_i</code> represents individual fixed effects and <code class="reqn">x_{it}</code> a <code class="reqn">p \times 1</code> vector of regressors.
The individual slope coefficient vectors <code class="reqn">\beta_i</code> are subject to a group structure
</p>
<p style="text-align: center;"><code class="reqn">\beta_i = \sum_{k = 1}^K \alpha_k \bold{1} \{i \in G_k\},</code>
</p>

<p>with <code class="reqn">\cup_{k = 1}^K G_k = \{1, \dots, N\}</code>, <code class="reqn">G_k \cap G_j = \emptyset</code> and <code class="reqn">\| \alpha_k - \alpha_j \| \neq 0</code> for any <code class="reqn">k \neq j</code>, <code class="reqn">k = 1, \dots, K</code>. The total number of groups <code class="reqn">K</code> is determined by <code>n_groups</code>.
</p>
<p>If a panel data set with exogenous regressors is generated (set <code>q = NULL</code>), the explanatory variables are simulated according to
</p>
<p style="text-align: center;"><code class="reqn">x_{it,j} = 0.2 \gamma_i + e_{it,j}, \quad \gamma_i,e_{it,j} \sim i.i.d. N(0, 1), \quad j = \{1, \dots, p\},</code>
</p>

<p>where <code class="reqn">e_{it,j}</code> denotes a series of innovations. <code class="reqn">\gamma_i</code> and <code class="reqn">e_i</code> are independent of each other.
</p>
<p>In case <code>alpha_0 = NULL</code>, the group-level slope parameters <code class="reqn">\alpha_{k}</code> are drawn from <code class="reqn">\sim U[-2, 2]</code>.
</p>
<p>If a dynamic panel is specified (<code>dynamic = TRUE</code>), the <code class="reqn">AR</code> coefficients <code class="reqn">\beta^{\text{AR}}_i</code> are drawn from a uniform distribution with support <code class="reqn">(-1, 1)</code> and <code class="reqn">x_{it,j} = e_{it,j}</code>.
Moreover, the individual fixed effects enter the dependent variable via <code class="reqn">(1 - \beta^{\text{AR}}_i) \gamma_i</code> to account for the autoregressive dependency.
We refer to Mehrabani (2023, sec 6) for details.
</p>
<p>When specifying an endogenous panel (set <code>q</code> to <code class="reqn">q \geq p</code>), the <code class="reqn">e_{it,j}</code> correlate with the cross-sectional innovations <code class="reqn">u_{it}</code> by a magnitude of 0.5 to produce endogenous regressors (<code class="reqn">\text{E}(u|X) \neq 0</code>). However, the endogenous regressors can be accounted for by exploiting the <code class="reqn">q</code> instruments in <code class="reqn">\bold{Z}</code>, for which <code class="reqn">\text{E}(u|Z) = 0</code> holds.
The instruments and the first stage coefficients are generated in the same fashion as <code class="reqn">\bold{X}</code> and <code class="reqn">\bold{\alpha}</code> when <code>q = NULL</code>.
</p>
<p>The function nests, among other, the DGPs employed in the simulation study of Mehrabani (2023, sec. 6).
</p>


<h3>Value</h3>

<p>A list holding
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>the <code class="reqn">K \times p</code> matrix of group-specific slope parameters. If <code>dynamic = TRUE</code>, the first column holds the <code class="reqn">AR</code> coefficient.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a vector indicating the group memberships <code class="reqn">(g_1, \dots, g_N)</code>, where <code class="reqn">g_i = k</code> if <code class="reqn">i \in</code> group <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code class="reqn">NT \times 1</code> vector of the dependent variable, with <code class="reqn">\bold{y}=(y_1, \dots, y_N)^\prime</code>, <code class="reqn">y_i = (y_{i1}, \dots, y_{iT})^\prime</code> and the scalar <code class="reqn">y_{it}</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">NT \times p</code> matrix of explanatory variables, with <code class="reqn">\bold{X}=(x_1, \dots, x_N)^\prime</code>, <code class="reqn">x_i = (x_{i1}, \dots, x_{iT})^\prime</code> and the <code class="reqn">p \times 1</code> vector <code class="reqn">x_{it}</code>.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>a <code class="reqn">NT \times q</code> matrix of instruments , where <code class="reqn">q \geq p</code>, <code class="reqn">\bold{Z}=(z_1, \dots, z_N)^\prime</code>, <code class="reqn">z_i = (z_{i1}, \dots, z_{iT})^\prime</code> and <code class="reqn">z_{it}</code> is a <code class="reqn">q \times 1</code> vector. In case a panel with exogenous regressors is generated (<code>q = NULL</code>), <code class="reqn">\bold{Z}</code> equals <code>NULL</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a <code class="reqn">NT \times (p + 1)</code> data.frame of the outcome and the explanatory variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>References</h3>

<p>Mehrabani, A. (2023). Estimation and identification of latent group structures in panel data. <em>Journal of Econometrics</em>, 235(2), 1464-1482. <a href="https://doi.org/10.1016/j.jeconom.2022.12.002">doi:10.1016/j.jeconom.2022.12.002</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate DGP 1 from Mehrabani (2023, sec. 6)
set.seed(1)
alpha_0_DGP1 &lt;- matrix(c(0.4, 1, 1.6, 1.6, 1, 0.4), ncol = 2)
DGP1 &lt;- sim_DGP(
  N = 50, n_periods = 20, p = 2, n_groups = 3,
  group_proportions = c(.4, .3, .3), alpha_0 = alpha_0_DGP1
)
</code></pre>

<hr>
<h2 id='sim_tv_DGP'>Simulate a Time-varying Panel With a Group Structure in the Slope Coefficients</h2><span id='topic+sim_tv_DGP'></span>

<h3>Description</h3>

<p>Construct a time-varying panel data set subject to a group structure in the slope coefficients with optional <code class="reqn">AR(1)</code> innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_tv_DGP(
  N = 50,
  n_periods = 40,
  intercept = TRUE,
  p = 1,
  n_groups = 3,
  d = 3,
  dynamic = FALSE,
  group_proportions = NULL,
  error_spec = "iid",
  locations = NULL,
  scales = NULL,
  polynomial_coef = NULL,
  sd_error = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_tv_DGP_+3A_n">N</code></td>
<td>
<p>the number of cross-sectional units. Default is 50.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_n_periods">n_periods</code></td>
<td>
<p>the number of simulated time periods <code class="reqn">T</code>. Default is 40.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_intercept">intercept</code></td>
<td>
<p>logical. If <code>TRUE</code>, a time-varying intercept is generated.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_p">p</code></td>
<td>
<p>the number of simulated explanatory variables</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_n_groups">n_groups</code></td>
<td>
<p>the number of groups <code class="reqn">K</code>. Default is 3.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_d">d</code></td>
<td>
<p>the polynomial degree used to construct the time-varying coefficients.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_dynamic">dynamic</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the panel includes one stationary autoregressive lag of <code class="reqn">y_{it}</code> as a regressor. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_group_proportions">group_proportions</code></td>
<td>
<p>a numeric vector of length <code>n_groups</code> indicating size of each group as a fraction of <code class="reqn">N</code>. If <code>NULL</code>, all groups are of size <code class="reqn">N / K</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_error_spec">error_spec</code></td>
<td>
<p>options include
</p>

<dl>
<dt><code>"iid"</code></dt><dd><p>for <code class="reqn">iid</code> errors.</p>
</dd>
<dt><code>"AR"</code></dt><dd><p>for an <code class="reqn">AR(1)</code> error process with an autoregressive coefficient of 0.5.</p>
</dd>
</dl>

<p>Default is <code>"iid"</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_locations">locations</code></td>
<td>
<p>a <code class="reqn">p \times K</code> matrix of location parameters of a logistic distribution function used to construct the time-varying coefficients. If left empty, the location parameters are drawn randomly. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_scales">scales</code></td>
<td>
<p>a <code class="reqn">p \times K</code> matrix of scale parameters of a logistic distribution function used to construct the time-varying coefficients. If left empty, the location parameters are drawn randomly. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_polynomial_coef">polynomial_coef</code></td>
<td>
<p>a <code class="reqn">p \times d \times K</code> array of coefficients for a the polynomials used to construct the time-varying coefficients. If left empty, the location parameters are drawn randomly. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_tv_DGP_+3A_sd_error">sd_error</code></td>
<td>
<p>standard deviation of the cross-sectional errors. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scalar dependent variable <code class="reqn">y_{it}</code> is generated according to the following time-varying grouped panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta^\prime_{it} x_{it} + u_{it}, \quad i = 1, \dots, N, \; t = 1, \dots, T,</code>
</p>

<p>where <code class="reqn">\gamma_i</code> is an individual fixed effect and <code class="reqn">x_{it}</code> is a <code class="reqn">p \times 1</code> vector of explanatory variables.
The coefficient vector <code class="reqn">\beta_i = \{\beta_{i1}^\prime, \dots, \beta_{iT}^\prime \}^\prime</code> is subject to the group pattern
</p>
<p style="text-align: center;"><code class="reqn">\beta_i \left( \frac{t}{T} \right) = \sum_{k = 1}^K \alpha_k \left( \frac{t}{T} \right) \bold{1} \{i \in G_k \},</code>
</p>

<p>with <code class="reqn">\cup_{k = 1}^K G_k = \{1, \dots, N\}</code>, <code class="reqn">G_k \cap G_j = \emptyset</code> and <code class="reqn">\sup_{v \in [0,1]} \left( \| \alpha_k(v) - \alpha_j(v) \| \right) \neq 0</code> for any <code class="reqn">k \neq j</code>, <code class="reqn">k = 1, \dots, K</code>. The total number of groups <code class="reqn">K</code> is determined by <code>n_groups</code>.
</p>
<p>The predictors are simulated as:
</p>
<p style="text-align: center;"><code class="reqn">x_{it,j} = 0.2 \gamma_i + e_{it,j}, \quad \gamma_i,e_{it,j} \sim i.i.d. N(0, 1), \quad j = \{1, \dots, p\},</code>
</p>

<p>where <code class="reqn">e_{it,j}</code> denotes a series of innovations. <code class="reqn">\gamma_i</code> and <code class="reqn">e_i</code> are independent of each other.
</p>
<p>The errors <code class="reqn">u_{it}</code> feature a <code class="reqn">iid</code> standard normal distribution.
</p>
<p>In case <code>locations = NULL</code>, the location parameters are drawn from <code class="reqn">\sim U[0.3, 0.9]</code>.
In case <code>scales = NULL</code>, the scale parameters are drawn from <code class="reqn">\sim U[0.01, 0.09]</code>.
In case <code>polynomial_coef = NULL</code>, the polynomial coefficients are drawn from <code class="reqn">\sim U[-20, 20]</code> and normalized so that all coefficients of one polynomial sum up to 1.
The final coefficient function follows as <code class="reqn">\alpha_k (t/T) = 3 * F(t/T, location, scale) + \sum_{j=1}^d a_j (t/T)^j</code>, where <code class="reqn">F(\cdot, location, scale)</code> denotes a cumulative logistic distribution function and <code class="reqn">a_j</code> reflects a polynomial coefficient.
</p>


<h3>Value</h3>

<p>A list holding
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>a <code class="reqn">T \times p \times K</code> array of group-specific time-varying parameters</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a <code class="reqn">T \times p \times N</code> array of individual time-varying parameters</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a vector indicating the group memberships <code class="reqn">(g_1, \dots, g_N)</code>, where <code class="reqn">g_i = k</code> if <code class="reqn">i \in</code> group <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a <code class="reqn">NT \times 1</code> vector of the dependent variable, with <code class="reqn">\bold{y}=(y_1, \dots, y_N)^\prime</code>, <code class="reqn">y_i = (y_{i1}, \dots, y_{iT})^\prime</code> and the scalar <code class="reqn">y_{it}</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a <code class="reqn">NT \times p</code> matrix of explanatory variables, with <code class="reqn">\bold{X}=(x_1, \dots, x_N)^\prime</code>, <code class="reqn">x_i = (x_{i1}, \dots, x_{iT})^\prime</code> and the <code class="reqn">p \times 1</code> vector <code class="reqn">x_{it}</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a <code class="reqn">NT \times (p + 1)</code> data.frame of the outcome and the explanatory variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a time-varying panel subject to a time trend and a group structure
set.seed(1)
sim &lt;- sim_tv_DGP(N = 20, n_periods = 50, p = 1)
y &lt;- sim$y
X &lt;- sim$X

</code></pre>

<hr>
<h2 id='tv_pagfl'>Time-varying Pairwise Adaptive Group Fused Lasso</h2><span id='topic+tv_pagfl'></span><span id='topic+summary.tvpagfl'></span><span id='topic+formula.tvpagfl'></span><span id='topic+df.residual.tvpagfl'></span><span id='topic+print.tvpagfl'></span><span id='topic+coef.tvpagfl'></span><span id='topic+residuals.tvpagfl'></span><span id='topic+fitted.tvpagfl'></span>

<h3>Description</h3>

<p>Estimate a time-varying panel data model with a latent group structure using the pairwise adaptive group fused lasso (<em>time-varying PAGFL</em>). The <em>time-varying PAGFL</em> jointly identifies the latent group structure and group-specific time-varying functional coefficients.
The time-varying coefficients are modeled as polynomial B-splines. The function supports both static and dynamic panel data models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv_pagfl(
  formula,
  data,
  index = NULL,
  n_periods = NULL,
  lambda,
  d = 3,
  M = floor(length(y)^(1/7) - log(p)),
  min_group_frac = 0.05,
  const_coef = NULL,
  kappa = 2,
  max_iter = 50000,
  tol_convergence = 1e-10,
  tol_group = 0.001,
  rho = 0.04 * log(N * n_periods)/sqrt(N * n_periods),
  varrho = 1,
  verbose = TRUE,
  parallel = TRUE,
  ...
)

## S3 method for class 'tvpagfl'
summary(object, ...)

## S3 method for class 'tvpagfl'
formula(x, ...)

## S3 method for class 'tvpagfl'
df.residual(object, ...)

## S3 method for class 'tvpagfl'
print(x, ...)

## S3 method for class 'tvpagfl'
coef(object, ...)

## S3 method for class 'tvpagfl'
residuals(object, ...)

## S3 method for class 'tvpagfl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tv_pagfl_+3A_formula">formula</code></td>
<td>
<p>a formula object describing the model to be estimated.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> holding a panel data set. If no <code>index</code> variables are provided, the panel must be balanced and ordered in the long format <code class="reqn">\bold{Y}=(Y_1^\prime, \dots, Y_N^\prime)^\prime</code>, <code class="reqn">Y_i = (Y_{i1}, \dots, Y_{iT})^\prime</code> with <code class="reqn">Y_{it} = (y_{it}, x_{it}^\prime)^\prime</code>. Conversely, if <code>data</code> is not ordered or not balanced, <code>data</code> must include two index variables that declare the cross-sectional unit <code class="reqn">i</code> and the time period <code class="reqn">t</code> of each observation.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_index">index</code></td>
<td>
<p>a character vector holding two strings. The first string denotes the name of the index variable identifying the cross-sectional unit <code class="reqn">i</code> and the second string represents the name of the variable declaring the time period <code class="reqn">t</code>. The data is automatically sorted according to the variables in <code>index</code>, which may produce errors when the time index is a character variable. In case of a balanced panel data set that is ordered in the long format, <code>index</code> can be left empty if the the number of time periods <code>n_periods</code> is supplied.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_n_periods">n_periods</code></td>
<td>
<p>the number of observed time periods <code class="reqn">T</code>. If an <code>index</code> character vector is passed, this argument can be left empty. Default is <code>Null</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_lambda">lambda</code></td>
<td>
<p>the tuning parameter determining the strength of the penalty term. Either a single <code class="reqn">\lambda</code> or a vector of candidate values can be passed. If a vector is supplied, a BIC-type IC automatically selects the best fitting <code class="reqn">\lambda</code> value.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_d">d</code></td>
<td>
<p>the polynomial degree of the B-splines. Default is 3.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_m">M</code></td>
<td>
<p>the number of interior knots of the B-splines. If left unspecified, the default heuristic <code class="reqn">M = \text{floor}((NT)^{\frac{1}{7}} - \log(p))</code> is used. Note that <code class="reqn">M</code> does not include the boundary knots and the entire sequence of knots is of length <code class="reqn">M + d + 1</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_min_group_frac">min_group_frac</code></td>
<td>
<p>the minimum group cardinality as a fraction of the total number of individuals <code class="reqn">N</code>. In case a group falls short of this threshold, each of its members is allocated to one of the remaining groups according to the <em>MSE</em>. Default is 0.05.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_const_coef">const_coef</code></td>
<td>
<p>a character vector containing the variable names of explanatory variables that enter with time-constant coefficients.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_kappa">kappa</code></td>
<td>
<p>the a non-negative weight used to obtain the adaptive penalty weights. Default is 2.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations for the <em>ADMM</em> estimation algorithm. Default is <code class="reqn">5*10^4</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_tol_convergence">tol_convergence</code></td>
<td>
<p>the tolerance limit for the stopping criterion of the iterative <em>ADMM</em> estimation algorithm. Default is <code class="reqn">1*10^{-10}</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_tol_group">tol_group</code></td>
<td>
<p>the tolerance limit for within-group differences. Two individuals are assigned to the same group if the Frobenius norm of their coefficient vector difference is below this threshold. Default is <code class="reqn">1*10^{-3}</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_rho">rho</code></td>
<td>
<p>the tuning parameter balancing the fitness and penalty terms in the IC that determines the penalty parameter <code class="reqn">\lambda</code>. If left unspecified, the heuristic <code class="reqn">\rho = 0.07 \frac{\log(NT)}{\sqrt{NT}}</code> of Mehrabani (2023, sec. 6) is used. We recommend the default.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_varrho">varrho</code></td>
<td>
<p>the non-negative Lagrangian <em>ADMM</em> penalty parameter. For the employed penalized sieve estimation <em>PSE</em>, the <code class="reqn">\varrho</code> value is trivial. We recommend the default 1.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, helpful warning messages are shown. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_parallel">parallel</code></td>
<td>
<p>logical. If <code>TRUE</code>, certain operations are parallelized across multiple cores. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_...">...</code></td>
<td>
<p>ellipsis</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_object">object</code></td>
<td>
<p>of class <code>tvpagfl</code>.</p>
</td></tr>
<tr><td><code id="tv_pagfl_+3A_x">x</code></td>
<td>
<p>of class <code>tvpagfl</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the grouped time-varying panel data model
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + \beta^\prime_{i} (t/T) x_{it} + \epsilon_{it}, \quad i = 1, \dots, N, \; t = 1, \dots, T,</code>
</p>

<p>where <code class="reqn">y_{it}</code> is the scalar dependent variable, <code class="reqn">\gamma_i</code> is an individual fixed effect, <code class="reqn">x_{it}</code> is a <code class="reqn">p \times 1</code> vector of explanatory variables, and <code class="reqn">\epsilon_{it}</code> is a zero mean error.
The coefficient vector <code class="reqn">\beta_{i} (t/T)</code> is subject to the latent group pattern
</p>
<p style="text-align: center;"><code class="reqn">\beta_i \left(\frac{t}{T} \right) = \sum_{k = 1}^K \alpha_k \left( \frac{t}{T} \right) \bold{1} \{i \in G_k \},</code>
</p>

<p>with <code class="reqn">\cup_{k = 1}^K G_k = \{1, \dots, N\}</code>, <code class="reqn">G_k \cap G_j = \emptyset</code> and <code class="reqn">\| \alpha_k - \alpha_j \| \neq 0</code> for any <code class="reqn">k \neq j</code>, <code class="reqn">k = 1, \dots, K</code>.
</p>
<p>The time-varying coefficient functions are estimated as polynomial B-splines using the penalized sieve-technique. To this end, let <code class="reqn">B(v)</code> denote a <code class="reqn">M + d +1</code> vector basis functions, where <code class="reqn">d</code> denotes the polynomial degree and <code class="reqn">M</code> the number of interior knots.
Then, <code class="reqn">\beta_{i}(t/T)</code> and <code class="reqn">\alpha_{k}(t/T)</code> are approximated by forming linear combinations of the basis functions <code class="reqn">\beta_{i} (t/T) \approx \pi_i^\prime B(t/T)</code> and <code class="reqn">\alpha_{i}(t/T) \approx \xi_k^\prime B(t/T)</code>, where <code class="reqn">\pi_i</code> and <code class="reqn">\xi_i</code> are <code class="reqn">(M + d + 1) \times p</code> coefficient matrices.
</p>
<p>The explanatory variables are projected onto the spline basis system, which results in the <code class="reqn">(M + d + 1)p \times 1</code> vector <code class="reqn">z_{it} = x_{it} \otimes B(v)</code>. Subsequently, the DGP can be reformulated as
</p>
<p style="text-align: center;"><code class="reqn">y_{it} = \gamma_i + z_{it}^\prime \text{vec}(\pi_{i}) + u_{it},</code>
</p>

<p>where <code class="reqn">u_{it} = \epsilon_{it} + \eta_{it}</code> and <code class="reqn">\eta_{it}</code> reflects a sieve approximation error. We refer to Su et al. (2019, sec. 2) for more details on the sieve technique.
</p>
<p>Inspired by Su et al. (2019) and Mehrabani (2023), the time-varying PAGFL jointly estimates the functional coefficients and the group structure by minimizing the criterion
</p>
<p style="text-align: center;"><code class="reqn">Q_{NT} (\bold{\pi}, \lambda) = \frac{1}{NT} \sum^N_{i=1} \sum^{T}_{t=1}(\tilde{y}_{it} - \tilde{z}_{it}^\prime \text{vec}(\pi_{i}))^2 + \frac{\lambda}{N} \sum_{i = 1}^{N - 1} \sum_{j &gt; i}^N \dot{\omega}_{ij} \| \pi_i - \pi_j \|</code>
</p>

<p>with respect to <code class="reqn">\bold{\pi} = (\text{vec}(\pi_i)^\prime, \dots, \text{vec}(\pi_N)^\prime)^\prime</code>. <code class="reqn">\tilde{a}_{it} = a_{it} - T^{-1} \sum^{T}_{t=1} a_{it}</code>, <code class="reqn">a = \{y, z\}</code> to concentrate out the individual fixed effects <code class="reqn">\gamma_i</code>. <code class="reqn">\lambda</code> is the penalty tuning parameter and <code class="reqn">\dot{w}_{ij}</code> denotes adaptive penalty weights which are obtained by a preliminary non-penalized estimation. <code class="reqn">\| \cdot \|</code> represents the Frobenius norm.
The solution criterion function is minimized via the iterative alternating direction method of multipliers (<em>ADMM</em>) algorithm proposed by Mehrabani (2023, sec. 5.1).
</p>
<p>Two individuals are assigned to the same group if <code class="reqn">\| \text{vec} (\hat{\pi}_i - \hat{\pi}_j) \| \leq \epsilon_{\text{tol}}</code>, where <code class="reqn">\epsilon_{\text{tol}}</code> is determined by <code>tol_group</code>. Subsequently, the number of groups follows as the number of distinct elements in <code class="reqn">\hat{\bold{\pi}}</code>. Given an estimated group structure, it is straightforward to obtain post-Lasso estimates <code class="reqn">\hat{\bold{\xi}}</code> using group-wise least squares (see <code><a href="#topic+grouped_tv_plm">grouped_tv_plm</a></code>).
</p>
<p>We recommend identifying a suitable <code class="reqn">\lambda</code> parameter by passing a logarithmically spaced grid of candidate values with a lower limit close to 0 and an upper limit that leads to a fully homogeneous panel. A BIC-type information criterion then selects the best fitting <code class="reqn">\lambda</code> value.
</p>
<p>In case of an unbalanced panel data set, the earliest and latest available observations per group define the start and end-points of the interval on which the group-specific time-varying coefficients are defined.
</p>


<h3>Value</h3>

<p>An object of class <code>tvpagfl</code> holding
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>a <code>data.frame</code> containing the dependent and explanatory variables as well as cross-sectional and time indices,</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>let <code class="reqn">p^{(1)}</code> denote the number of time-varying coefficients and <code class="reqn">p^{(2)}</code> the number of time constant parameters. A <code>list</code> holding (i) a <code class="reqn">T \times p^{(1)} \times \hat{K}</code> array of the post-Lasso group-specific functional coefficients and (ii) a <code class="reqn">K \times p^{(2)}</code> matrix of time-constant post-Lasso estimates.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a <code>list</code> containing (i) the total number of groups <code class="reqn">\hat{K}</code> and (ii) a vector of estimated group memberships <code class="reqn">(\hat{g}_1, \dots, \hat{g}_N)</code>, where <code class="reqn">\hat{g}_i = k</code> if <code class="reqn">i</code> is assigned to group <code class="reqn">k</code>,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of residuals of the demeaned model,</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of fitted values of the demeaned model,</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>a <code>list</code> of additional arguments,</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>a <code>list</code> containing (i) the value of the IC, (ii) the employed tuning parameter <code class="reqn">\lambda</code>, and (iii) the <em>MSE</em>,</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a <code>list</code> containing (i) a logical variable if convergence was achieved and (ii) the number of executed <em>ADMM</em> algorithm iterations,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>An object of class <code>tvpagfl</code> has <code>print</code>, <code>summary</code>, <code>fitted</code>, <code>residuals</code>, <code>formula</code>, <code>df.residual</code> and <code>coef</code> S3 methods.
</p>


<h3>Author(s)</h3>

<p>Paul Haimerl
</p>


<h3>References</h3>

<p>Mehrabani, A. (2023). Estimation and identification of latent group structures in panel data. <em>Journal of Econometrics</em>, 235(2), 1464-1482. <a href="https://doi.org/10.1016/j.jeconom.2022.12.002">doi:10.1016/j.jeconom.2022.12.002</a>.
</p>
<p>Su, L., Wang, X., &amp; Jin, S. (2019). Sieve estimation of time-varying panel data models with latent structures. <em>Journal of Business &amp; Economic Statistics</em>, 37(2), 334-349. <a href="https://doi.org/10.1080/07350015.2017.1340299">doi:10.1080/07350015.2017.1340299</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a time-varying panel with a trend and a group pattern
set.seed(1)
sim &lt;- sim_tv_DGP(N = 10, n_periods = 50, intercept = TRUE, p = 1)
df &lt;- data.frame(y = c(sim$y))

# Run the time-varying PAGFL
estim &lt;- tv_pagfl(y ~ ., data = df, n_periods = 50, lambda = 10, parallel = FALSE)
summary(estim)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
