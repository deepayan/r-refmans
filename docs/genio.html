<!DOCTYPE html><html><head><title>Help for package genio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {genio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#genio'><p>genio (GENetics I/O): A package for reading and writing genetics data</p></a></li>
<li><a href='#count_lines'><p>Count the number of lines of a file</p></a></li>
<li><a href='#delete_files_grm'><p>Delete all GCTA binary GRM files</p></a></li>
<li><a href='#delete_files_phen'><p>Delete PHEN files</p></a></li>
<li><a href='#delete_files_plink'><p>Delete all Plink binary files</p></a></li>
<li><a href='#geno_to_char'><p>Convert a genotype matrix from numeric to character codes</p></a></li>
<li><a href='#ind_to_fam'><p>Convert an Eigenstrat IND tibble into a Plink FAM tibble</p></a></li>
<li><a href='#make_bim'><p>Create a Plink BIM tibble</p></a></li>
<li><a href='#make_fam'><p>Create a Plink FAM tibble</p></a></li>
<li><a href='#read_bed'><p>Read a genotype matrix in Plink BED format</p></a></li>
<li><a href='#read_bim'><p>Read Plink *.bim files</p></a></li>
<li><a href='#read_eigenvec'><p>Read Plink eigenvec file</p></a></li>
<li><a href='#read_fam'><p>Read Plink *.fam files</p></a></li>
<li><a href='#read_grm'><p>Read GCTA GRM and related plink2 binary files</p></a></li>
<li><a href='#read_ind'><p>Read Eigenstrat *.ind files</p></a></li>
<li><a href='#read_matrix'><p>Read a numerical matrix file into an R matrix</p></a></li>
<li><a href='#read_phen'><p>Read *.phen files</p></a></li>
<li><a href='#read_plink'><p>Read genotype and sample data in a Plink BED/BIM/FAM file set.</p></a></li>
<li><a href='#read_snp'><p>Read Eigenstrat *.snp files</p></a></li>
<li><a href='#require_files_grm'><p>Require that GCTA binary GRM files are present</p></a></li>
<li><a href='#require_files_phen'><p>Require that PHEN file is present</p></a></li>
<li><a href='#require_files_plink'><p>Require that Plink binary files are present</p></a></li>
<li><a href='#sex_to_char'><p>Convert integer sex codes to character codes</p></a></li>
<li><a href='#sex_to_int'><p>Convert character sex codes to integer codes</p></a></li>
<li><a href='#tidy_kinship'><p>Create a tidy version of a kinship matrix</p></a></li>
<li><a href='#write_bed'><p>Write a genotype matrix into Plink BED format</p></a></li>
<li><a href='#write_bim'><p>Write Plink *.bim files</p></a></li>
<li><a href='#write_eigenvec'><p>Write eigenvectors table into a Plink-format file</p></a></li>
<li><a href='#write_fam'><p>Write Plink *.fam files</p></a></li>
<li><a href='#write_grm'><p>Write GCTA GRM and related plink2 binary files</p></a></li>
<li><a href='#write_ind'><p>Write Eigenstrat *.ind files</p></a></li>
<li><a href='#write_matrix'><p>Write a matrix to a file without row or column names</p></a></li>
<li><a href='#write_phen'><p>Write *.phen files</p></a></li>
<li><a href='#write_plink'><p>Write genotype and sample data into a Plink BED/BIM/FAM file set.</p></a></li>
<li><a href='#write_snp'><p>Write Eigenstrat *.snp files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Genetics Input/Output Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements readers and writers for file formats associated with genetics data.  Reading and writing Plink BED/BIM/FAM and GCTA binary GRM formats is fully supported, including a lightning-fast BED reader and writer implementations.  Other functions are 'readr' wrappers that are more constrained, user-friendly, and efficient for these particular applications; handles Plink and Eigenstrat tables (FAM, BIM, IND, and SNP files).  There are also make functions for FAM and BIM tables with default values to go with simulated genotype data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>readr (&ge; 2.0.0), tibble, dplyr, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, BEDMatrix, snpStats, lobstr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/OchoaLab/genio">https://github.com/OchoaLab/genio</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OchoaLab/genio/issues">https://github.com/OchoaLab/genio/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-06 16:24:30 UTC; viiia</td>
</tr>
<tr>
<td>Author:</td>
<td>Alejandro Ochoa <a href="https://orcid.org/0000-0003-4928-3403"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alejandro Ochoa &lt;alejandro.ochoa@duke.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-06 23:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='genio'>genio (GENetics I/O): A package for reading and writing genetics data</h2><span id='topic+genio'></span><span id='topic+genio-package'></span>

<h3>Description</h3>

<p>This package fully supports reading and writing Plink BED/BIM/FAM and GCTA GRM files, as illustrated below.
These functions make it easy to create dummy annotation tables to go with simulated genotype data too.
Lastly, there is functionality to read and write Eigenstrat tables.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alejandro Ochoa <a href="mailto:alejandro.ochoa@duke.edu">alejandro.ochoa@duke.edu</a> (<a href="https://orcid.org/0000-0003-4928-3403">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/OchoaLab/genio">https://github.com/OchoaLab/genio</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/OchoaLab/genio/issues">https://github.com/OchoaLab/genio/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># read existing BED/BIM/FAM files

# first get path to BED file
file &lt;- system.file( "extdata", 'sample.bed', package = "genio", mustWork = TRUE )

# read genotypes and annotation tables
plink_data &lt;- read_plink( file )
# genotypes
X &lt;- plink_data$X
# locus annotations
bim &lt;- plink_data$bim
# individual annotations
fam &lt;- plink_data$fam

# the same works without .bed extension
file &lt;- sub( '\\.bed$', '', file ) # remove extension
plink_data &lt;- read_plink( file )

# write data into new BED/BIM/FAM files
file_out &lt;- tempfile( 'delete-me-example' )
write_plink( file_out, X, bim, fam )

# delete example files when done
delete_files_plink( file_out )

# read sample GRM files
file &lt;- system.file( "extdata", 'sample.grm.bin', package = "genio", mustWork = TRUE )
file &lt;- sub( '\\.grm\\.bin$', '', file ) # remove extension from this path on purpose
obj &lt;- read_grm( file )
# the kinship matrix
kinship &lt;- obj$kinship
# the pair sample sizes matrix
M &lt;- obj$M
# the fam and ID tibble
fam &lt;- obj$fam

# write data into new GRM files
write_grm( file_out, kinship, M = M, fam = fam )

# delete example files when done
delete_files_grm( file_out )

# other functions not shown here allow reading and writing individual files,
# creating dummy tables to go with simulated genotypes,
# requiring the existence of these files,
# and reading and writing of Eigenstrat tables too.

</code></pre>

<hr>
<h2 id='count_lines'>Count the number of lines of a file</h2><span id='topic+count_lines'></span>

<h3>Description</h3>

<p>This function returns the number of lines in a file.
It is intended to result in fast retrieval of numbers of individuals (from FAM or equivalent files) or loci (BIM or equivalent files) when the input files are extremely large and no other information is required from these files.
This code uses C++ to quickly counts lines (like linux's <code>wc -l</code> but this one is cross-platform).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_lines(file, ext = NA, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_lines_+3A_file">file</code></td>
<td>
<p>The input file path to read (a string).</p>
</td></tr>
<tr><td><code id="count_lines_+3A_ext">ext</code></td>
<td>
<p>An optional extension.
If <code>NA</code> (default), <code>file</code> is expected to exist as-is.
Otherwise, if <code>file</code> doesn't exist and the extension was missing, then this extension is added.</p>
</td></tr>
<tr><td><code id="count_lines_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), writes a message reporting the file whose lines are being counted (after adding extensions if it was needed).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: this function does not work correctly with compressed files (they are not uncompressed prior to counting newlines).
</p>


<h3>Value</h3>

<p>The number of lines in the file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># count number of individuals from an existing plink *.fam file
file &lt;- system.file("extdata", 'sample.fam', package = "genio", mustWork = TRUE)
n_ind &lt;- count_lines(file)
n_ind

# count number of loci from an existing plink *.bim file
file &lt;- system.file("extdata", 'sample.bim', package = "genio", mustWork = TRUE)
m_loci &lt;- count_lines(file)
m_loci

</code></pre>

<hr>
<h2 id='delete_files_grm'>Delete all GCTA binary GRM files</h2><span id='topic+delete_files_grm'></span>

<h3>Description</h3>

<p>This function deletes each of the GCTA binary GRM files (<code>grm.bin</code>, <code>grm.N.bin</code>, and <code>grm.id</code> extensions) given the shared base file path, warning if any of the files did not exist or if any were not successfully deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_files_grm(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_files_grm_+3A_file">file</code></td>
<td>
<p>The shared file path (excluding extensions: <code>grm.bin</code>, <code>grm.N.bin</code>, or <code>grm.id</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># if you want to delete "data.grm.bin", "data.grm.N.bin" and "data.grm.id", run like this:
# delete_files_grm("data")

# The following example is more awkward
# because (only for these examples) the package must create *temporary* files to actually delete

# create dummy GRM files
file &lt;- tempfile('delete-me-test') # no extension
# add each extension and create empty files
file.create( paste0(file, '.grm.bin') )
file.create( paste0(file, '.grm.N.bin') )
file.create( paste0(file, '.grm.id') )

# delete the GRM files we just created
delete_files_grm(file)

</code></pre>

<hr>
<h2 id='delete_files_phen'>Delete PHEN files</h2><span id='topic+delete_files_phen'></span>

<h3>Description</h3>

<p>This function deletes a PHEN files given the base file path (without extension), warning if the file did not exist or if it was not successfully deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_files_phen(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_files_phen_+3A_file">file</code></td>
<td>
<p>The base file path (excluding <code>phen</code> extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># if you want to delete "data.phen", run like this:
# delete_files_phen("data")

# The following example is more awkward
# because (only for these examples) the package must create a *temporary* file to actually delete

# create dummy PHEN files
file &lt;- tempfile('delete-me-test') # no extension
# add extension and create an empty file
file.create( paste0(file, '.phen') )

# delete the PHEN file we just created
delete_files_phen(file)

</code></pre>

<hr>
<h2 id='delete_files_plink'>Delete all Plink binary files</h2><span id='topic+delete_files_plink'></span>

<h3>Description</h3>

<p>This function deletes each of the Plink binary files (<code>bed</code>, <code>bim</code>, <code>fam</code> extensions) given the shared base file path, warning if any of the files did not exist or if any were not successfully deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_files_plink(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_files_plink_+3A_file">file</code></td>
<td>
<p>The shared file path (excluding extensions: <code>bed</code>, <code>bim</code>, <code>fam</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># if you want to delete "data.bed", "data.bim" and "data.fam", run like this:
# delete_files_plink("data")

# The following example is more awkward
# because (only for these examples) the package must create *temporary* files to actually delete

# create dummy BED/BIM/FAM files
file &lt;- tempfile('delete-me-test') # no extension
# add each extension and create empty files
file.create( paste0(file, '.bed') )
file.create( paste0(file, '.bim') )
file.create( paste0(file, '.fam') )

# delete the BED/BIM/FAM files we just created
delete_files_plink(file)

</code></pre>

<hr>
<h2 id='geno_to_char'>Convert a genotype matrix from numeric to character codes</h2><span id='topic+geno_to_char'></span>

<h3>Description</h3>

<p>Given the genotype matrix <code>X</code> and <code>bim</code> table (as they are parsed by <code><a href="#topic+read_plink">read_plink()</a></code>, this outputs a matrix of the same dimensions as <code>X</code> but with the numeric codes (all values in 0, 1, 2) translated to human-readable character codes (such as 'A/A', 'A/G', 'G/G', depending on which are the two alleles at the locus as given in the <code>bim</code> table, see return value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_to_char(X, bim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geno_to_char_+3A_x">X</code></td>
<td>
<p>The genotype matrix.
It must have values only in 0, 1, 2, and <code>NA</code>.</p>
</td></tr>
<tr><td><code id="geno_to_char_+3A_bim">bim</code></td>
<td>
<p>The variant table.
It is required to have the same number of rows as <code>X</code>, and to have at least two named columns <code>alt</code> and <code>ref</code> (alleles 1 and 2 in a plink BIM table).
These alleles can be arbitrary strings (i.e. not just SNPs but also indels, any single or multicharacter code, or even blank strings) except the forward slash character (&quot;/&quot;) is not allowed anywhere in these strings (function stops if a slash is present), since in the output it is the delimiter string.
<code>ref</code> and <code>alt</code> alleles must be different at each locus.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The genotype matrix reencoded as strings.
At one locus, if the two alleles (alt and ref) are 'A' and 'B', then the genotypes in the input are encoded as characters as: 0 -&gt; 'A/A', 1 -&gt; 'B/A', and 2 -&gt; 'B/B'.
Thus, the numeric encoding counts the reference allele dosage.
<code>NA</code> values in input <code>X</code> remain <code>NA</code> in the output.
If the input genotype matrix had row and column names, these are inherited by the output matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_plink">read_plink()</a></code>,
<code><a href="#topic+read_bed">read_bed()</a></code>,
<code><a href="#topic+read_bim">read_bim()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a numeric/dosage genotype matrix with two loci (rows)
# and three individuals (columns)
X &lt;- rbind( 0:2, c(0, NA, 2) )
# corresponding variant table (minimal case with just two required columns)
library(tibble)
bim &lt;- tibble( alt = c('C', 'GT'), ref = c('A', 'G') )

# genotype matrix translated as characters
X_char &lt;- geno_to_char( X, bim )
X_char

</code></pre>

<hr>
<h2 id='ind_to_fam'>Convert an Eigenstrat IND tibble into a Plink FAM tibble</h2><span id='topic+ind_to_fam'></span>

<h3>Description</h3>

<p>This function takes an existing IND tibble and creates a FAM tibble with the same information and dummy values for missing data.
In particular, the output FAM tibble will contain these columns with these contents
(IND only contain <code>id</code>, <code>sex</code>, and <code>label</code>, so there is no loss of information):
</p>

<ul>
<li> <p><code>fam</code>: IND <code>label</code>
</p>
</li>
<li> <p><code>id</code>: IND <code>id</code>
</p>
</li>
<li> <p><code>pat</code>: <code>0</code> (missing paternal ID)
</p>
</li>
<li> <p><code>mat</code>: <code>0</code> (missing maternal ID)
</p>
</li>
<li> <p><code>sex</code>: IND <code>sex</code> converted to Plink integer codes via <code><a href="#topic+sex_to_int">sex_to_int()</a></code>
</p>
</li>
<li> <p><code>peno</code>: <code>0</code> (missing phenotype)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ind_to_fam(ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind_to_fam_+3A_ind">ind</code></td>
<td>
<p>The input Eigenstrat IND tibble to convert.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Plink FAM tibble.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sex_to_int">sex_to_int()</a></code>
</p>
<p>Eigenstrat IND format reference:
<a href="https://github.com/DReichLab/EIG/tree/master/CONVERTF">https://github.com/DReichLab/EIG/tree/master/CONVERTF</a>
</p>
<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a sample IND tibble
library(tibble)
ind &lt;- tibble(
  id = 1:3,
  sex = c('U', 'M', 'F'),
  label = c(1, 1, 2)
)
# convert to FAM
fam &lt;- ind_to_fam(ind)
# inspect:
fam

</code></pre>

<hr>
<h2 id='make_bim'>Create a Plink BIM tibble</h2><span id='topic+make_bim'></span>

<h3>Description</h3>

<p>This function simplifies the creation of Plink BIM-formatted tibbles, which autocompletes missing information if a partial tibble is provided, or generates a completely made up tibble if the number of individuals is provided.
The default values are most useful for simulated genotypes, where IDs can be made up but must be unique, and there are no chromosomes, positions, or particular reference or alternative alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_bim(tib, n = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_bim_+3A_tib">tib</code></td>
<td>
<p>The input tibble (optional).
Missing columns will be autocompleted with reasonable values that are accepted by Plink and other external software.
If missing, all will be autocompleted, but <code>n</code> is required.</p>
</td></tr>
<tr><td><code id="make_bim_+3A_n">n</code></td>
<td>
<p>The desired number of loci (rows).
Required if <code>tib</code> is missing; otherwise it is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Autocompleted column values:
</p>

<ul>
<li> <p><code>chr</code>: <code>1</code> (all data is on a single chromosome)
</p>
</li>
<li> <p><code>id</code>: <code>1:n</code>
</p>
</li>
<li> <p><code>posg</code>: <code>0</code> (missing)
</p>
</li>
<li> <p><code>pos</code>: <code>1:n</code>
</p>
</li>
<li> <p><code>ref</code>: <code>1</code>
</p>
</li>
<li> <p><code>alt</code>: <code>2</code>
</p>
</li></ul>

<p>Note that <code>n</code> is either given directly or obtained from the input tibble.
</p>


<h3>Value</h3>

<p>The input tibble with autocompleted columns and columns in default order, or the made up tibble if only the number of individuals was provided.
The output begins with the standard columns in standard order: chr, id, posg, pos, ref, alt.
Additional columns in the input tibble are preserved but placed after the standard columns.
</p>


<h3>See Also</h3>

<p>Plink BIM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#bim">https://www.cog-genomics.org/plink/1.9/formats#bim</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a synthetic tibble for 10 loci
# (most common use case)
bim &lt;- make_bim(n = 10)

# manually create a partial tibble with only chromosomes defined
library(tibble)
bim &lt;- tibble(chr = 0:2)
# autocomplete the rest of the columns
bim &lt;- make_bim(bim)

</code></pre>

<hr>
<h2 id='make_fam'>Create a Plink FAM tibble</h2><span id='topic+make_fam'></span>

<h3>Description</h3>

<p>This function simplifies the creation of Plink FAM-formatted tibbles, which autocompletes missing information if a partial tibble is provided, or generates a completely made up tibble if the number of individuals is provided.
The default values are most useful for simulated genotypes, where IDs can be made up but must be unique, and there are no parents, families, gender, or phenotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_fam(tib, n = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_fam_+3A_tib">tib</code></td>
<td>
<p>The input tibble (optional).
Missing columns will be autocompleted with reasonable values that are accepted by Plink and other external software.
If missing, all will be autocompleted, but <code>n</code> is required.</p>
</td></tr>
<tr><td><code id="make_fam_+3A_n">n</code></td>
<td>
<p>The desired number of individuals (rows).
Required if <code>tib</code> is missing; otherwise it is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Autocompleted column values:
</p>

<ul>
<li> <p><code>fam</code>: <code>1:n</code>
</p>
</li>
<li> <p><code>id</code>: <code>1:n</code>
</p>
</li>
<li> <p><code>pat</code>: <code>0</code> (missing)
</p>
</li>
<li> <p><code>mat</code>: <code>0</code> (missing)
</p>
</li>
<li> <p><code>sex</code>: <code>0</code> (missing)
</p>
</li>
<li> <p><code>pheno</code>: <code>0</code> (missing)
</p>
</li></ul>

<p>Note that <code>n</code> is either given directly or obtained from the input tibble.
</p>


<h3>Value</h3>

<p>The input tibble with autocompleted columns and columns in default order, or the made up tibble if only the number of individuals was provided.
The output begins with the standard columns in standard order: <code>fam</code>, <code>id</code>, <code>pat</code>, <code>mat</code>, <code>sex</code>, <code>pheno</code>.
Additional columns in the input tibble are preserved but placed after the standard columns.
</p>


<h3>See Also</h3>

<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a synthetic tibble for 10 individuals
# (most common use case)
fam &lt;- make_fam(n = 10)

# manually create a partial tibble with only phenotypes defined
library(tibble)
fam &lt;- tibble(pheno = 0:2)
# autocomplete the rest of the columns
fam &lt;- make_fam(fam)

</code></pre>

<hr>
<h2 id='read_bed'>Read a genotype matrix in Plink BED format</h2><span id='topic+read_bed'></span>

<h3>Description</h3>

<p>This function reads genotypes encoded in a Plink-formatted BED (binary) file, returning them in a standard R matrix containing genotypes encoded numerically as dosages (values in <code>c( 0, 1, 2, NA )</code>).
Each genotype per locus (<code>m</code> loci) and individual (<code>n</code> total) counts the number of reference alleles, or <code>NA</code> for missing data.
No *.fam or *.bim files are read by this basic function.
Since BED does not encode the data dimensions internally, these values must be provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_bed(
  file,
  names_loci = NULL,
  names_ind = NULL,
  m_loci = NA,
  n_ind = NA,
  ext = "bed",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_bed_+3A_file">file</code></td>
<td>
<p>Input file path.
*.bed extension may be omitted (will be added automatically if <code>file</code> doesn't exist but <code>file</code>.bed does).
See <code>ext</code> option below.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_names_loci">names_loci</code></td>
<td>
<p>Vector of loci names, to become the row names of the genotype matrix.
If provided, its length sets <code>m_loci</code> below.
If <code>NULL</code>, the returned genotype matrix will not have row names, and <code>m_loci</code> must be provided.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_names_ind">names_ind</code></td>
<td>
<p>Vector of individual names, to become the column names of the genotype matrix.
If provided, its length sets <code>n_ind</code> below.
If <code>NULL</code>, the returned genotype matrix will not have column names, and <code>n_ind</code> must be provided.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_m_loci">m_loci</code></td>
<td>
<p>Number of loci in the input genotype table.
Required if <code>names_loci = NULL</code>, as its value is not deducible from the BED file itself.
Ignored if <code>names_loci</code> is provided.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_n_ind">n_ind</code></td>
<td>
<p>Number of individuals in the input genotype table.
Required if <code>names_ind = NULL</code>, as its value is not deducible from the BED file itself.
Ignored if <code>names_ind</code> is provided.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_ext">ext</code></td>
<td>
<p>The desired file extension (default &quot;bed&quot;).
Ignored if <code>file</code> points to an existing file.
Set to <code>NA</code> to force <code>file</code> to exist as-is.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) function reports the path of the file being read (after autocompleting the extension).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code enforces several checks to validate data given the requested dimensions.
Errors are thrown if file terminates too early or does not terminate after genotype matrix is filled.
In addition, as each locus is encoded in an integer number of bytes, and each byte contains up to four individuals, bytes with fewer than four are padded.
To agree with other software (plink2, BEDMatrix), byte padding values are ignored (may take on any value without causing errors).
</p>
<p>This function only supports locus-major BED files, which are the standard for modern data.
Format is validated via the BED file's magic numbers (first three bytes of file).
Older BED files can be converted using Plink.
</p>


<h3>Value</h3>

<p>The <code>m</code>-by-<code>n</code> genotype matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_plink">read_plink()</a></code> for reading a set of BED/BIM/FAM files.
</p>
<p><code><a href="#topic+geno_to_char">geno_to_char()</a></code> for translating numerical genotypes into more human-readable character encodings.
</p>
<p>Plink BED format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#bed">https://www.cog-genomics.org/plink/1.9/formats#bed</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first obtain data dimensions from BIM and FAM files
# all file paths
file_bed &lt;- system.file("extdata", 'sample.bed', package = "genio", mustWork = TRUE)
file_bim &lt;- system.file("extdata", 'sample.bim', package = "genio", mustWork = TRUE)
file_fam &lt;- system.file("extdata", 'sample.fam', package = "genio", mustWork = TRUE)
# read annotation tables
bim &lt;- read_bim(file_bim)
fam &lt;- read_fam(file_fam)

# read an existing Plink *.bim file
# pass locus and individual IDs as vectors, setting data dimensions too
X &lt;- read_bed(file_bed, bim$id, fam$id)
X

# can specify without extension
file_bed &lt;- sub('\\.bed$', '', file_bed) # remove extension from this path on purpose
file_bed # verify .bed is missing
X &lt;- read_bed(file_bed, bim$id, fam$id) # loads too!
X

</code></pre>

<hr>
<h2 id='read_bim'>Read Plink *.bim files</h2><span id='topic+read_bim'></span>

<h3>Description</h3>

<p>This function reads a standard Plink *.bim file into a tibble with named columns.
It uses <code><a href="readr.html#topic+read_table">readr::read_table()</a></code> to do it efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_bim(file, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_bim_+3A_file">file</code></td>
<td>
<p>Input file (whatever is accepted by <code><a href="readr.html#topic+read_table">readr::read_table()</a></code>).
If file as given does not exist and is missing the expected *.bim extension, the function adds the .bim extension and uses that path if that file exists.
Additionally, the .gz extension is added automatically if the file (after *.bim extension is added as needed) is still not found and did not already contain the .gz extension and adding it points to an existing file.</p>
</td></tr>
<tr><td><code id="read_bim_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) function reports the path of the file being loaded (after autocompleting the extensions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns: <code>chr</code>, <code>id</code>, <code>posg</code>, <code>pos</code>, <code>alt</code>, <code>ref</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_plink">read_plink()</a></code> for reading a set of BED/BIM/FAM files.
</p>
<p>Plink BIM format references:
<a href="https://www.cog-genomics.org/plink/1.9/formats#bim">https://www.cog-genomics.org/plink/1.9/formats#bim</a>
<a href="https://www.cog-genomics.org/plink/2.0/formats#bim">https://www.cog-genomics.org/plink/2.0/formats#bim</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to read "data.bim", run like this:
# bim &lt;- read_bim("data")
# this also works
# bim &lt;- read_bim("data.bim")

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# read an existing Plink *.bim file
file &lt;- system.file("extdata", 'sample.bim', package = "genio", mustWork = TRUE)
bim &lt;- read_bim(file)
bim

# can specify without extension
file &lt;- sub('\\.bim$', '', file) # remove extension from this path on purpose
file # verify .bim is missing
bim &lt;- read_bim(file) # loads too!
bim

</code></pre>

<hr>
<h2 id='read_eigenvec'>Read Plink eigenvec file</h2><span id='topic+read_eigenvec'></span>

<h3>Description</h3>

<p>This function reads a Plink eigenvec file, parsing columns strictly.
First two must be 'fam' and 'id', which are strings, and all remaining columns (eigenvectors) must be numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_eigenvec(
  file,
  ext = "eigenvec",
  plink2 = FALSE,
  comment = if (plink2) "" else "#",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_eigenvec_+3A_file">file</code></td>
<td>
<p>The input file path, potentially excluding extension.</p>
</td></tr>
<tr><td><code id="read_eigenvec_+3A_ext">ext</code></td>
<td>
<p>File extension (default &quot;eigenvec&quot;) can be changed if desired.
Set to <code>NA</code> to force <code>file</code> to exist as-is.</p>
</td></tr>
<tr><td><code id="read_eigenvec_+3A_plink2">plink2</code></td>
<td>
<p>If <code>TRUE</code>, the header is parsed and preserved in the returned data.
The first two columns must be FID and IID, which are mandatory.</p>
</td></tr>
<tr><td><code id="read_eigenvec_+3A_comment">comment</code></td>
<td>
<p>A string used to identify comments.
Any text after the comment characters will be silently ignored.
Passed to <code><a href="readr.html#topic+read_table">readr::read_table()</a></code>.
'#' (default when <code>plink2 = FALSE</code>) works for Plink 2 eigenvec files, which have a header lines that starts with this character (the header is therefore ignored).
However, <code>plink2 = TRUE</code> forces the header to be parsed instead.</p>
</td></tr>
<tr><td><code id="read_eigenvec_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) function reports the path of the file being written (after autocompleting the extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<ul>
<li> <p><code>eigenvec</code>: A numeric R matrix containing the parsed eigenvectors.
If <code>plink2 = TRUE</code>, the original column names will be preserved in this matrix.
</p>
</li>
<li> <p><code>fam</code>: A tibble with two columns, <code>fam</code> and <code>id</code>, which are the first two columns of the parsed file.
These column names are always the same even if <code>plink2 = TRUE</code> (i.e. they won't be <code>FID</code> or <code>IID</code>).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+write_eigenvec">write_eigenvec()</a></code> for writing an eigenvec file.
</p>
<p>Plink 1 eigenvec format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#eigenvec">https://www.cog-genomics.org/plink/1.9/formats#eigenvec</a>
</p>
<p>Plink 2 eigenvec format reference:
<a href="https://www.cog-genomics.org/plink/2.0/formats#eigenvec">https://www.cog-genomics.org/plink/2.0/formats#eigenvec</a>
</p>
<p>GCTA eigenvec format reference:
<a href="https://cnsgenomics.com/software/gcta/#PCA">https://cnsgenomics.com/software/gcta/#PCA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to read "data.eigenvec", run like this:
# data &lt;- read_eigenvec("data")
# this also works
# data &lt;- read_eigenvec("data.eigenvec")
#
# either way you get a list with these two items:
# numeric eigenvector matrix
# data$eigenvec
# fam/id tibble
# data$fam

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# read an existing *.eigenvec file created by GCTA
file &lt;- system.file("extdata", 'sample-gcta.eigenvec', package = "genio", mustWork = TRUE)
data &lt;- read_eigenvec(file)
# numeric eigenvector matrix
data$eigenvec
# fam/id tibble
data$fam

# can specify without extension
file &lt;- sub('\\.eigenvec$', '', file) # remove extension from this path on purpose
file # verify .eigenvec is missing
data &lt;- read_eigenvec(file) # load it anyway!
data$eigenvec

# read an existing *.eigenvec file created by Plink 2
file &lt;- system.file("extdata", 'sample-plink2.eigenvec', package = "genio", mustWork = TRUE)
# this version ignores header
data &lt;- read_eigenvec(file)
# numeric eigenvector matrix
data$eigenvec
# fam/id tibble
data$fam

# this version uses header
data &lt;- read_eigenvec(file, plink2 = TRUE)
# numeric eigenvector matrix
data$eigenvec
# fam/id tibble
data$fam

</code></pre>

<hr>
<h2 id='read_fam'>Read Plink *.fam files</h2><span id='topic+read_fam'></span>

<h3>Description</h3>

<p>This function reads a standard Plink *.fam file into a tibble with named columns.
It uses <code><a href="readr.html#topic+read_table">readr::read_table()</a></code> to do it efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fam(file, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fam_+3A_file">file</code></td>
<td>
<p>Input file (whatever is accepted by <code><a href="readr.html#topic+read_table">readr::read_table()</a></code>).
If file as given does not exist and is missing the expected *.fam extension, the function adds the .fam extension and uses that path if that file exists.
Additionally, the .gz extension is added automatically if the file (after *.fam extension is added as needed) is still not found and did not already contain the .gz extension and adding it points to an existing file.</p>
</td></tr>
<tr><td><code id="read_fam_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) function reports the path of the file being loaded (after autocompleting the extensions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns: <code>fam</code>, <code>id</code>, <code>pat</code>, <code>mat</code>, <code>sex</code>, <code>pheno</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_plink">read_plink()</a></code> for reading a set of BED/BIM/FAM files.
</p>
<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to read "data.fam", run like this:
# fam &lt;- read_fam("data")
# this also works
# fam &lt;- read_fam("data.fam")

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# read an existing Plink *.fam file
file &lt;- system.file("extdata", 'sample.fam', package = "genio", mustWork = TRUE)
fam &lt;- read_fam(file)
fam

# can specify without extension
file &lt;- sub('\\.fam$', '', file) # remove extension from this path on purpose
file # verify .fam is missing
fam &lt;- read_fam(file) # load it anyway!
fam

</code></pre>

<hr>
<h2 id='read_grm'>Read GCTA GRM and related plink2 binary files</h2><span id='topic+read_grm'></span>

<h3>Description</h3>

<p>This function reads a GCTA Genetic Relatedness Matrix (GRM, i.e. kinship) set of files in their binary format, returning the kinship matrix and, if available, the corresponding matrix of pair sample sizes (non-trivial under missingness) and individuals table.
Setting some options allows reading plink2 binary kinship formats such as &quot;king&quot; (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_grm(
  name,
  n_ind = NA,
  verbose = TRUE,
  ext = "grm",
  shape = c("triangle", "strict_triangle", "square"),
  size_bytes = 4,
  comment = "#"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_grm_+3A_name">name</code></td>
<td>
<p>The base name of the input files.
Files with that base, plus shared extension (default &quot;grm&quot;, see <code>ext</code> below), plus extensions <code>.bin</code>, <code>.N.bin</code>, and <code>.id</code> are read if they exist.
Only <code style="white-space: pre;">&#8288;.&lt;ext&gt;.bin&#8288;</code> is absolutely required; <code style="white-space: pre;">&#8288;.&lt;ext&gt;.id&#8288;</code> can be substituted by the number of individuals (see below); <code style="white-space: pre;">&#8288;.&lt;ext&gt;.N.bin&#8288;</code> is entirely optional.</p>
</td></tr>
<tr><td><code id="read_grm_+3A_n_ind">n_ind</code></td>
<td>
<p>The number of individuals, required if the file with the extension <code style="white-space: pre;">&#8288;.&lt;ext&gt;.id&#8288;</code> is missing.
If the file with the <code style="white-space: pre;">&#8288;.&lt;ext&gt;.id&#8288;</code> extension is present, then this <code>n_ind</code> is ignored.</p>
</td></tr>
<tr><td><code id="read_grm_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the files being loaded.</p>
</td></tr>
<tr><td><code id="read_grm_+3A_ext">ext</code></td>
<td>
<p>Shared extension for all three inputs (see <code>name</code> above; default &quot;grm&quot;).
Another useful value is &quot;king&quot; for KING-robust estimates produced by plink2.
If <code>NA</code>, no extension is added.
If given <code>ext</code> is also present at the end of <code>name</code>, then it is not added again.</p>
</td></tr>
<tr><td><code id="read_grm_+3A_shape">shape</code></td>
<td>
<p>The shape of the information to read (may be abbreviated).
Default &quot;triangle&quot; assumes there are <code>n*(n+1)/2</code> values to read corresponding to the upper triangle including the diagonal (required for GCTA GRM).
&quot;strict_triangle&quot; assumes there are <code>n*(n-1)/2</code> values to read corresponding to the upper triangle <em>excluding</em> the diagonal (best for plink2 KING-robust).
Lastly, &quot;square&quot; assumes there are <code>n*n</code> values to read corresponding to the entire square matrix, ignoring symmetry.</p>
</td></tr>
<tr><td><code id="read_grm_+3A_size_bytes">size_bytes</code></td>
<td>
<p>The number of bytes per number encoded.
Default 4 corresponds to GCTA GRM and plink2 &quot;bin4&quot;, whereas plink2 &quot;bin&quot; requires a value of 8.</p>
</td></tr>
<tr><td><code id="read_grm_+3A_comment">comment</code></td>
<td>
<p>Character to start comments in <code style="white-space: pre;">&#8288;&lt;ext&gt;.id&#8288;</code> file only.
Default &quot;#&quot; helps plink2 <code>.id</code> files (which have a header that starts with &quot;#&quot;, which is therefore ignored) be read just like plink1 and GCTA files (which do not have a header).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with named elements:
</p>

<ul>
<li> <p><code>kinship</code>: The symmetric <code>n</code>-times-<code>n</code> kinship matrix (GRM).  Has IDs as row and column names if the file with extension <code style="white-space: pre;">&#8288;.&lt;ext&gt;.id&#8288;</code> exists.  If <code>shape='strict_triangle'</code>, diagonal will have missing values.
</p>
</li>
<li> <p><code>M</code>: The symmetric <code>n</code>-times-<code>n</code> matrix of pair sample sizes (number of non-missing loci pairs), if the file with extension <code style="white-space: pre;">&#8288;.&lt;ext&gt;.N.bin&#8288;</code> exists.  Has IDs as row and column names if the file with extension <code style="white-space: pre;">&#8288;.&lt;ext&gt;.id&#8288;</code> was available.  If <code>shape='strict_triangle'</code>, diagonal will have missing values.
</p>
</li>
<li> <p><code>fam</code>: A tibble with two columns: <code>fam</code> and <code>id</code>, same as in Plink FAM files.  Returned if the file with extension <code style="white-space: pre;">&#8288;.&lt;ext&gt;.id&#8288;</code> exists.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+write_grm">write_grm()</a></code>
</p>
<p>Greatly adapted from sample code from GCTA:
<a href="https://cnsgenomics.com/software/gcta/#MakingaGRM">https://cnsgenomics.com/software/gcta/#MakingaGRM</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to read "data.grm.bin" and etc, run like this:
# obj &lt;- read_grm("data")
# obj$kinship # the kinship matrix
# obj$M       # the pair sample sizes matrix
# obj$fam     # the fam and ID tibble

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# read an existing set of GRM files
file &lt;- system.file("extdata", 'sample.grm.bin', package = "genio", mustWork = TRUE)
file &lt;- sub('\\.grm\\.bin$', '', file) # remove extension from this path on purpose
obj &lt;- read_grm(file)
obj$kinship # the kinship matrix
obj$M       # the pair sample sizes matrix
obj$fam     # the fam and ID tibble

# Read sample plink2 KING-robust files (several variants).
# Read both base.king.bin and base.king.id files.
# All generated with "plink2 &lt;input&gt; --make-king &lt;options&gt; --out base"
# (replace "base" with actual base name) with these options:
# #1) "triangle bin"
# data &lt;- read_grm( 'base', ext = 'king', shape = 'strict', size_bytes = 8 )
# #2) "triangle bin4"
# data &lt;- read_grm( 'base', ext = 'king', shape = 'strict' )
# #3) "square bin"
# data &lt;- read_grm( 'base', ext = 'king', shape = 'square', size_bytes = 8 )
# #4) "square bin4"
# data &lt;- read_grm( 'base', ext = 'king', shape = 'square' )

</code></pre>

<hr>
<h2 id='read_ind'>Read Eigenstrat *.ind files</h2><span id='topic+read_ind'></span>

<h3>Description</h3>

<p>This function reads a standard Eigenstrat *.ind file into a tibble.
It uses <code><a href="readr.html#topic+read_table">readr::read_table()</a></code> to do it efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ind(file, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ind_+3A_file">file</code></td>
<td>
<p>Input file (whatever is accepted by <code><a href="readr.html#topic+read_table">readr::read_table()</a></code>).
If file as given does not exist and is missing the expected *.ind extension, the function adds the .ind extension and uses that path if that file exists.
Additionally, the .gz extension is added automatically if the file (after *.ind extension is added as needed) is still not found and did not already contain the .gz extension and adding it points to an existing file.</p>
</td></tr>
<tr><td><code id="read_ind_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being loaded (after autocompleting the extensions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns: <code>id</code>, <code>sex</code>, <code>label</code>.
</p>


<h3>See Also</h3>

<p>Eigenstrat IND format reference:
<a href="https://github.com/DReichLab/EIG/tree/master/CONVERTF">https://github.com/DReichLab/EIG/tree/master/CONVERTF</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to read "data.ind", run like this:
# ind &lt;- read_ind("data")
# this also works
# ind &lt;- read_ind("data.ind")

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# read an existing Eigenstrat *.ind file
file &lt;- system.file("extdata", 'sample.ind', package = "genio", mustWork = TRUE)
ind &lt;- read_ind(file)
ind

# can specify without extension
file &lt;- sub('\\.ind$', '', file) # remove extension from this path on purpose
file # verify .ind is missing
ind &lt;- read_ind(file) # load it anyway!
ind

</code></pre>

<hr>
<h2 id='read_matrix'>Read a numerical matrix file into an R matrix</h2><span id='topic+read_matrix'></span>

<h3>Description</h3>

<p>Reads a matrix file under strict assumptions that it is entirely numeric and there are no row or column names present in this file.
It uses <code><a href="readr.html#topic+read_table">readr::read_table()</a></code> to do it efficiently.
Intended for outputs such as those of admixture inference approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_matrix(file, ext = "txt", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_matrix_+3A_file">file</code></td>
<td>
<p>Input file (whatever is accepted by <code><a href="readr.html#topic+read_table">readr::read_table()</a></code>).
If file as given does not exist and is missing the expected extension (see <code>ext</code> below), the function adds the extension and uses that path if that file exists.
Additionally, the .gz extension is added automatically if the file (after the extension is added as needed) is still not found and did not already contain the .gz extension and adding it points to an existing file.</p>
</td></tr>
<tr><td><code id="read_matrix_+3A_ext">ext</code></td>
<td>
<p>The desired file extension.
Ignored if <code>file</code> points to an existing file.
Set to <code>NA</code> to force <code>file</code> to exist as-is.</p>
</td></tr>
<tr><td><code id="read_matrix_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) function reports the path of the file being loaded (after autocompleting the extensions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix without row or column names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write_matrix">write_matrix()</a></code>, the inverse function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to read "data.txt", run like this:
# mat &lt;- read_matrix("data")
# this also works
# mat &lt;- read_matrix("data.txt")

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# read an existing matrix *.txt file
file &lt;- system.file("extdata", 'sample-Q3.txt', package = "genio", mustWork = TRUE)
mat &lt;- read_matrix(file)
mat

# can specify without extension
file &lt;- sub('\\.txt$', '', file) # remove extension from this path on purpose
file # verify .txt is missing
mat &lt;- read_matrix(file) # load it anyway!
mat

</code></pre>

<hr>
<h2 id='read_phen'>Read *.phen files</h2><span id='topic+read_phen'></span>

<h3>Description</h3>

<p>This function reads a standard *.phen file into a tibble.
It uses <code><a href="readr.html#topic+read_table">readr::read_table()</a></code> to do it efficiently.
GCTA and EMMAX use this format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_phen(file, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_phen_+3A_file">file</code></td>
<td>
<p>Input file (whatever is accepted by <code><a href="readr.html#topic+read_table">readr::read_table()</a></code>).
If file as given does not exist and is missing the expected *.phen extension, the function adds the .phen extension and uses that path if that file exists.
Additionally, the .gz extension is added automatically if the file (after *.phen extension is added as needed) is still not found and did not already contain the .gz extension and adding it points to an existing file.</p>
</td></tr>
<tr><td><code id="read_phen_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being loaded (after autocompleting the extensions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns: <code>fam</code>, <code>id</code>, <code>pheno</code>.
</p>


<h3>See Also</h3>

<p>GCTA PHEN format reference:
<a href="https://cnsgenomics.com/software/gcta/#GREMLanalysis">https://cnsgenomics.com/software/gcta/#GREMLanalysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to read "data.phen", run like this:
# phen &lt;- read_phen("data")
# this also works
# phen &lt;- read_phen("data.phen")

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# read an existing plink *.phen file
file &lt;- system.file("extdata", 'sample.phen', package = "genio", mustWork = TRUE)
phen &lt;- read_phen(file)
phen

# can specify without extension
file &lt;- sub('\\.phen$', '', file) # remove extension from this path on purpose
file # verify .phen is missing
phen &lt;- read_phen(file) # load it anyway!
phen

</code></pre>

<hr>
<h2 id='read_plink'>Read genotype and sample data in a Plink BED/BIM/FAM file set.</h2><span id='topic+read_plink'></span>

<h3>Description</h3>

<p>This function reads a genotype matrix (<code>X</code>, encoded as reference allele dosages) and its associated locus (<code>bim</code>) and individual (<code>fam</code>) data tables in the three Plink files in BED, BIM, and FAM formats, respectively.
All inputs must exist or an error is thrown.
This function is a wrapper around the more basic functions
<code><a href="#topic+read_bed">read_bed()</a></code>,
<code><a href="#topic+read_bim">read_bim()</a></code>,
<code><a href="#topic+read_fam">read_fam()</a></code>,
which simplifies data parsing and additionally better guarantees data integrity.
Below suppose there are <code>m</code> loci and <code>n</code> individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_plink(file, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_plink_+3A_file">file</code></td>
<td>
<p>Input file path, without extensions (each of .bed, .bim, .fam extensions will be added automatically as needed).
Alternatively, input file path may have .bed extension (but not .bim, .fam, or other extensions).</p>
</td></tr>
<tr><td><code id="read_plink_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the paths of the files being read (after autocompleting the extensions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with items in this order: <code>X</code> (genotype matrix, see description in return value of <code><a href="#topic+read_bed">read_bed()</a></code>), <code>bim</code> (tibble, see <code><a href="#topic+read_bim">read_bim()</a></code>), <code>fam</code> (tibble, see <code><a href="#topic+read_fam">read_fam()</a></code>).
<code>X</code> has row and column names corresponding to the <code>id</code> values of the <code>bim</code> and <code>fam</code> tibbles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_bed">read_bed()</a></code>,
<code><a href="#topic+read_bim">read_bim()</a></code>, and
<code><a href="#topic+read_fam">read_fam()</a></code>
for individual parsers of each input table, including a description of each object returned.
</p>
<p><code><a href="#topic+geno_to_char">geno_to_char()</a></code> for translating numerical genotypes into more human-readable character encodings.
</p>
<p>Plink BED/BIM/FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats">https://www.cog-genomics.org/plink/1.9/formats</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to read "data.bed" etc, run like this:
# obj &lt;- read_plink("data")
# this also works
# obj &lt;- read_plink("data.bed")
#
# you get a list with these three items:
# genotypes
# obj$X
# locus annotations
# obj$bim
# individual annotations
# obj$fam

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# first get path to BED file
file &lt;- system.file("extdata", 'sample.bed', package = "genio", mustWork = TRUE)

# read genotypes and annotation tables
plink_data &lt;- read_plink(file)
# genotypes
plink_data$X
# locus annotations
plink_data$bim
# individual annotations
plink_data$fam

# the same works without .bed extension
file &lt;- sub('\\.bed$', '', file) # remove extension
# it works!
plink_data &lt;- read_plink(file)

</code></pre>

<hr>
<h2 id='read_snp'>Read Eigenstrat *.snp files</h2><span id='topic+read_snp'></span>

<h3>Description</h3>

<p>This function reads a standard Eigenstrat *.snp file into a tibble.
It uses <code><a href="readr.html#topic+read_table">readr::read_table()</a></code> to do it efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_snp(file, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_snp_+3A_file">file</code></td>
<td>
<p>Input file (whatever is accepted by <code><a href="readr.html#topic+read_table">readr::read_table()</a></code>).
If file as given does not exist and is missing the expected *.snp extension, the function adds the .snp extension and uses that path if that file exists.
Additionally, the .gz extension is added automatically if the file (after *.snp extension is added as needed) is still not found and did not already contain the .gz extension and adding it points to an existing file.</p>
</td></tr>
<tr><td><code id="read_snp_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being loaded (after autocompleting the extensions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns: <code>id</code>, <code>chr</code>, <code>posg</code>, <code>pos</code>, <code>ref</code>, <code>alt</code>
</p>


<h3>See Also</h3>

<p>Eigenstrat SNP format reference:
<a href="https://github.com/DReichLab/EIG/tree/master/CONVERTF">https://github.com/DReichLab/EIG/tree/master/CONVERTF</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to read "data.snp", run like this:
# snp &lt;- read_snp("data")
# this also works
# snp &lt;- read_snp("data.snp")

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# read an existing Eigenstrat *.snp file
file &lt;- system.file("extdata", 'sample.snp', package = "genio", mustWork = TRUE)
snp &lt;- read_snp(file)
snp

# can specify without extension
file &lt;- sub('\\.snp$', '', file) # remove extension from this path on purpose
file # verify .snp is missing
snp &lt;- read_snp(file) # load it anyway!
snp

</code></pre>

<hr>
<h2 id='require_files_grm'>Require that GCTA binary GRM files are present</h2><span id='topic+require_files_grm'></span>

<h3>Description</h3>

<p>This function checks that each of the GCTA binary GRM files (<code>grm.bin</code>, <code>grm.N.bin</code>, and <code>grm.id</code> extensions) are present, given the shared base file path, stopping with an informative message if any of the files is missing.
This function aids troubleshooting, as various downstream external software report missing files differently and sometimes using confusing or obscure messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>require_files_grm(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="require_files_grm_+3A_file">file</code></td>
<td>
<p>The shared file path (excluding extensions: <code>grm.bin</code>, <code>grm.N.bin</code>, or <code>grm.id</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to require all of "data.grm.bin", "data.grm.N.bin", and "data.grm.id", run like this:
# (stops if any of the three files is missing)
# require_files_grm("data")

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# check that the samples we want exist
# start with bed file
file &lt;- system.file("extdata", 'sample.grm.bin', package = "genio", mustWork = TRUE)
# remove extension
file &lt;- sub('\\.grm\\.bin$', '', file)
# since all sample.grm.{bin,N.bin,id} files exist, this will not stop with error messages:
require_files_grm(file)

</code></pre>

<hr>
<h2 id='require_files_phen'>Require that PHEN file is present</h2><span id='topic+require_files_phen'></span>

<h3>Description</h3>

<p>This function checks that the PHEN file is present, given the base file path, stopping with an informative message if the file is missing.
This function aids troubleshooting, as various downstream external software report missing files differently and sometimes using confusing or obscure messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>require_files_phen(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="require_files_phen_+3A_file">file</code></td>
<td>
<p>The base file path (excluding <code>phen</code> extensions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to require "data.phen", run like this:
# (stops if file is missing)
# require_files_phen("data")

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# check that the samples we want exist
# get path to an existing phen file
file &lt;- system.file("extdata", 'sample.phen', package = "genio", mustWork = TRUE)
# remove extension
file &lt;- sub('\\.phen$', '', file)
# since sample.phen file exist, this will not stop with error messages:
require_files_phen(file)

</code></pre>

<hr>
<h2 id='require_files_plink'>Require that Plink binary files are present</h2><span id='topic+require_files_plink'></span>

<h3>Description</h3>

<p>This function checks that each of the Plink binary files (BED/BIM/FAM extensions) are present, given the shared base file path, stopping with an informative message if any of the files is missing.
This function aids troubleshooting, as various downstream external software report missing files differently and sometimes using confusing or obscure messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>require_files_plink(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="require_files_plink_+3A_file">file</code></td>
<td>
<p>The shared file path (excluding extensions <code>bed</code>, <code>bim</code>, <code>fam</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to require all of "data.bed", "data.bim", and "data.fam", run like this:
# (stops if any of the three files is missing)
# require_files_plink("data")

# The following example is more awkward
# because package sample data has to be specified in this weird way:

# check that the samples we want exist
# start with bed file
file &lt;- system.file("extdata", 'sample.bed', package = "genio", mustWork = TRUE)
# remove extension
file &lt;- sub('\\.bed$', '', file)
# since all sample.{bed,bim,fam} files exist, this will not stop with error messages:
require_files_plink(file)

</code></pre>

<hr>
<h2 id='sex_to_char'>Convert integer sex codes to character codes</h2><span id='topic+sex_to_char'></span>

<h3>Description</h3>

<p>This function accepts the integer sex codes accepted by Plink and turns them into the character codes accepted by Eigenstrat.
Only upper-case characters are returned.
Cases outside the table below are mapped to <code>U</code> (unknown) with a warning.
The correspondence is:
</p>

<ul>
<li> <p><code>0</code>: <code>U</code> (unknown)
</p>
</li>
<li> <p><code>1</code>: <code>M</code> (male)
</p>
</li>
<li> <p><code>2</code>: <code>F</code> (female)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sex_to_char(sex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sex_to_char_+3A_sex">sex</code></td>
<td>
<p>Integer vector of sex codes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted character vector of sex codes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sex_to_int">sex_to_int()</a></code>
</p>
<p>Eigenstrat IND format reference:
<a href="https://github.com/DReichLab/EIG/tree/master/CONVERTF">https://github.com/DReichLab/EIG/tree/master/CONVERTF</a>
</p>
<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># verify the mapping above
sex_int &lt;- 0:2
sex_char &lt;- c('U', 'M', 'F') # expected values
stopifnot(
  all(
    sex_to_char( sex_int ) == sex_char
  )
)

</code></pre>

<hr>
<h2 id='sex_to_int'>Convert character sex codes to integer codes</h2><span id='topic+sex_to_int'></span>

<h3>Description</h3>

<p>This function accepts the character sex codes accepted by Eigenstrat and turns them into the integer codes accepted by Plink.
Matching is case insensitive.
Cases outside the table below are mapped to <code>0</code> (unknown) with a warning.
The correspondence is:
</p>

<ul>
<li> <p><code>U</code>: <code>0</code> (unknown)
</p>
</li>
<li> <p><code>M</code>: <code>1</code> (male)
</p>
</li>
<li> <p><code>F</code>: <code>2</code> (female)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sex_to_int(sex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sex_to_int_+3A_sex">sex</code></td>
<td>
<p>Character vector of sex codes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted numeric vector of sex codes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sex_to_char">sex_to_char()</a></code>
</p>
<p>Eigenstrat IND format reference:
<a href="https://github.com/DReichLab/EIG/tree/master/CONVERTF">https://github.com/DReichLab/EIG/tree/master/CONVERTF</a>
</p>
<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># verify the mapping above
sex_char &lt;- c('U', 'm', 'f') # mixed case works!
sex_int &lt;- 0:2 # expected values
stopifnot(
  all(
    sex_to_int( sex_char ) == sex_int
  )
)

</code></pre>

<hr>
<h2 id='tidy_kinship'>Create a tidy version of a kinship matrix</h2><span id='topic+tidy_kinship'></span>

<h3>Description</h3>

<p>A square symmetric kinship matrix is transformed into a tibble, with a row per unique element in the kinship matrix, and three columns: ID of row, ID of column, and the kinship value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kinship(kinship, sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_kinship_+3A_kinship">kinship</code></td>
<td>
<p>The <code>n</code>-by-<code>n</code> symmetric kinship matrix</p>
</td></tr>
<tr><td><code id="tidy_kinship_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code> (default), rows are sorted ascending by kinship value.
Otherwise, order is moving along the upper triangle row-by-row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with <code>n * ( n + 1 ) / 2</code> rows (the upper triangle, including the diagonal), and 3 columns with names: <code>id1</code>, <code>id2</code>, <code>kinship</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a symmetric matrix
kinship &lt;- matrix(
    c(
        0.5, 0.1, 0.0,
        0.1, 0.5, 0.2,
        0.0, 0.2, 0.6
    ),
    nrow = 3
)
# add names (best for tidy version)
colnames(kinship) &lt;- paste0('pop', 1:3)
rownames(kinship) &lt;- paste0('pop', 1:3)
# this returns tidy version
kinship_tidy &lt;- tidy_kinship( kinship )
# test colnames
stopifnot( colnames( kinship_tidy ) == c('id1', 'id2', 'kinship') )
# test row number
stopifnot( nrow( kinship_tidy ) == 6 )
# inspect it
kinship_tidy

</code></pre>

<hr>
<h2 id='write_bed'>Write a genotype matrix into Plink BED format</h2><span id='topic+write_bed'></span>

<h3>Description</h3>

<p>This function accepts a standard R matrix containing genotypes (values in <code>c( 0, 1, 2, NA )</code>) and writes it into a Plink-formatted BED (binary) file.
Each genotype per locus (<code>m</code> loci) and individual (<code>n</code> total) counts the number of alternative alleles or <code>NA</code> for missing data.
No *.fam or *.bim files are created by this basic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_bed(file, X, verbose = TRUE, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_bed_+3A_file">file</code></td>
<td>
<p>Output file path.  .bed extension may be omitted (will be added automatically if it is missing).</p>
</td></tr>
<tr><td><code id="write_bed_+3A_x">X</code></td>
<td>
<p>The <code>m</code>-by-<code>n</code> genotype matrix.
Row and column names, if present, are ignored.</p>
</td></tr>
<tr><td><code id="write_bed_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being written (after autocompleting the extension).</p>
</td></tr>
<tr><td><code id="write_bed_+3A_append">append</code></td>
<td>
<p>If <code>TRUE</code>, appends variants onto the file. (Default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genotypes with values outside of [0, 2] cause an error, in which case the partial output is deleted.
However, beware that decimals get truncated internally, so values that truncate to 0, 1, or 2 will not raise errors.
The BED format does not accept fractional dosages, so such data will not be written as expected.
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write_plink">write_plink()</a></code> for writing a set of BED/BIM/FAM files.
</p>
<p>Plink BED format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#bed">https://www.cog-genomics.org/plink/1.9/formats#bed</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to write an existing matrix `X` into file "data.bed", run like this:
# write_bed("data", X)
# this also works
# write_bed("data.bed", X)

# The following example is more detailed but also more awkward
# because (only for these examples) the package must create the file in a *temporary* location

file_out &lt;- tempfile('delete-me-example', fileext = '.bed') # will also work without extension
# create 10 random genotypes
X &lt;- rbinom(10, 2, 0.5)
# replace 3 random genotypes with missing values
X[sample(10, 3)] &lt;- NA
# turn into 5x2 matrix
X &lt;- matrix(X, nrow = 5, ncol = 2)
# write this data to file in BED format
# (only *.bed gets created, no *.fam or *.bim in this call)
write_bed(file_out, X)
# delete output when done
file.remove(file_out)

</code></pre>

<hr>
<h2 id='write_bim'>Write Plink *.bim files</h2><span id='topic+write_bim'></span>

<h3>Description</h3>

<p>This function writes a tibble with the right columns into a standard Plink *.bim file.
It uses <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> to do it efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_bim(file, tib, verbose = TRUE, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_bim_+3A_file">file</code></td>
<td>
<p>Output file (whatever is accepted by <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code>).
If file is missing the expected *.bim extension, the function adds it.</p>
</td></tr>
<tr><td><code id="write_bim_+3A_tib">tib</code></td>
<td>
<p>The tibble or data.frame to write.
It must contain these columns: <code>chr</code>, <code>id</code>, <code>posg</code>, <code>pos</code>, <code>alt</code>, <code>ref</code>.
Throws an error if any of these columns are missing.
Additional columns are ignored.
Columns are automatically reordered in output as expected in format.</p>
</td></tr>
<tr><td><code id="write_bim_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being written (after autocompleting the extension).</p>
</td></tr>
<tr><td><code id="write_bim_+3A_append">append</code></td>
<td>
<p>If <code>TRUE</code>, appends rows onto the file. (Default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output <code>tib</code> invisibly (what <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> returns).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write_plink">write_plink()</a></code> for writing a set of BED/BIM/FAM files.
</p>
<p>Plink BIM format references:
<a href="https://www.cog-genomics.org/plink/1.9/formats#bim">https://www.cog-genomics.org/plink/1.9/formats#bim</a>
<a href="https://www.cog-genomics.org/plink/2.0/formats#bim">https://www.cog-genomics.org/plink/2.0/formats#bim</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to write an existing table `bim` into file "data.bim", run like this:
# write_bim("data", bim)
# this also works
# write_bim("data.bim", bim)

# The following example is more detailed but also more awkward
# because (only for these examples) the package must create the file in a *temporary* location

# create a dummy tibble with the right columns
library(tibble)
tib &lt;- tibble(
    chr = 1:3,
    id = 1:3,
    posg = 0,
    pos = 1:3,
    alt = 'B',
    ref = 'A'
)
# a dummy file
file_out &lt;- tempfile('delete-me-example', fileext = '.bim') # will also work without extension
# write the table out in *.bim format (no header, columns in right order)
write_bim(file_out, tib)

# example cleanup
file.remove(file_out)

</code></pre>

<hr>
<h2 id='write_eigenvec'>Write eigenvectors table into a Plink-format file</h2><span id='topic+write_eigenvec'></span>

<h3>Description</h3>

<p>This function writes eigenvectors in Plink 1 (same as GCTA) format (table with no header, with first two columns being <code>fam</code> and <code>id</code>), which is a subset of Plink 2 format (which optionally allows column names and does not require fam column).
Main expected case is <code>eigenvec</code> passed as a numeric matrix and <code>fam</code> provided to complete first two missing columns.
However, input <code>eigenvec</code> may also be a data.frame already containing the <code>fam</code> and <code>id</code> columns, and other reasonable intermediate cases are also handled.
If both <code>eigenvec</code> and <code>fam</code> are provided and contain overlapping columns, those in <code>eigenvec</code> get overwritten with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_eigenvec(
  file,
  eigenvec,
  fam = NULL,
  ext = "eigenvec",
  plink2 = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_eigenvec_+3A_file">file</code></td>
<td>
<p>The output file name (possibly without extension)</p>
</td></tr>
<tr><td><code id="write_eigenvec_+3A_eigenvec">eigenvec</code></td>
<td>
<p>A matrix or tibble containing the eigenvectors to include in the file.
Column names other than <code>fam</code> and <code>id</code> can be anything and are all treated as eigenvectors (not written to file).</p>
</td></tr>
<tr><td><code id="write_eigenvec_+3A_fam">fam</code></td>
<td>
<p>An optional <code>fam</code> table, which is used to add the <code>fam</code> and <code>id</code> columns to <code>eigenvec</code> (which overwrite columns of the same name in <code>eigenvec</code> if present, after a warning is produced).
Individuals in <code>fam</code> and <code>eigenvec</code> are assumed to be the same and in the same order.</p>
</td></tr>
<tr><td><code id="write_eigenvec_+3A_ext">ext</code></td>
<td>
<p>Output file extension.
Since the general &quot;covariates&quot; file format in GCTA and Plink are the same as this, this function may be used to write more general covariates files if desired, in which case users may wish to change this extension for clarity.</p>
</td></tr>
<tr><td><code id="write_eigenvec_+3A_plink2">plink2</code></td>
<td>
<p>If <code>TRUE</code>, prints a header in the style of plink2 (starts with hash, <code>fam</code> -&gt; <code>FID</code>, <code>id</code> -&gt; <code>IID</code>, and the default PCs are named <code>PC1</code>, <code>PC2</code>, etc.
Returned data.frame will also have these names.</p>
</td></tr>
<tr><td><code id="write_eigenvec_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being written (after autocompleting the extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the final <code>eigenvec</code> data.frame or tibble written to file, starting with columns <code>fam</code> and <code>id</code> (merged from the <code>fam</code> input, if it was passed) followed by the rest of columns in the input <code>eigenvec</code>.
Column names are instead <code style="white-space: pre;">&#8288;#FID&#8288;</code>, <code>IID</code>, etc if <code>plink2 = TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_eigenvec">read_eigenvec()</a></code> for reading an eigenvec file.
</p>
<p>Plink 1 eigenvec format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#eigenvec">https://www.cog-genomics.org/plink/1.9/formats#eigenvec</a>
</p>
<p>Plink 2 eigenvec format reference:
<a href="https://www.cog-genomics.org/plink/2.0/formats#eigenvec">https://www.cog-genomics.org/plink/2.0/formats#eigenvec</a>
</p>
<p>GCTA eigenvec format reference:
<a href="https://cnsgenomics.com/software/gcta/#PCA">https://cnsgenomics.com/software/gcta/#PCA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to write an existing matrix `eigenvec` and optional `fam` tibble into file "data.eigenvec",
# run like this:
# write_eigenvec("data", eigenvec, fam = fam)
# this also works
# write_eigenvec("data.eigenvec", eigenvec, fam = fam)

# The following example is more detailed but also more awkward
# because (only for these examples) the package must create the file in a *temporary* location

# create dummy eigenvectors matrix, in this case from a small identity matrix
# number of individuals
n &lt;- 10
eigenvec &lt;- eigen( diag( n ) )$vectors
# subset columns to use top 3 eigenvectors only
eigenvec &lt;- eigenvec[ , 1:3 ]
# dummy fam data
library(tibble)
fam &lt;- tibble( fam = 1:n, id = 1:n )

# write this data to .eigenvec file
# output path without extension
file &lt;- tempfile('delete-me-example')
eigenvec_final &lt;- write_eigenvec( file, eigenvec, fam = fam )
# inspect the tibble that was written to file (returned invisibly)
eigenvec_final

# remove temporary file (add extension before deletion)
file.remove( paste0( file, '.eigenvec' ) )

</code></pre>

<hr>
<h2 id='write_fam'>Write Plink *.fam files</h2><span id='topic+write_fam'></span>

<h3>Description</h3>

<p>This function writes a tibble with the right columns into a standard Plink *.fam file.
It uses <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> to do it efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_fam(file, tib, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_fam_+3A_file">file</code></td>
<td>
<p>Output file (whatever is accepted by <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code>).
If file is missing the expected *.fam extension, the function adds it.</p>
</td></tr>
<tr><td><code id="write_fam_+3A_tib">tib</code></td>
<td>
<p>The tibble or data.frame to write.
It must contain these columns: <code>fam</code>, <code>id</code>, <code>pat</code>, <code>mat</code>, <code>sex</code>, <code>pheno</code>.
Throws an error if any of these columns are missing.
Additional columns are ignored.
Columns are automatically reordered in output as expected in format.</p>
</td></tr>
<tr><td><code id="write_fam_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being written (after autocompleting the extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output <code>tib</code> invisibly (what <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> returns).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write_plink">write_plink()</a></code> for writing a set of BED/BIM/FAM files.
</p>
<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to write an existing table `fam` into file "data.fam", run like this:
# write_fam("data", fam)
# this also works
# write_fam("data.fam", fam)

# The following example is more detailed but also more awkward
# because (only for these examples) the package must create the file in a *temporary* location

# create a dummy tibble with the right columns
library(tibble)
tib &lt;- tibble(
    fam = 1:3,
    id = 1:3,
    pat = 0,
    mat = 0,
    sex = 1,
    pheno = 1
)
# a dummy file
file_out &lt;- tempfile('delete-me-example', fileext = '.fam') # will also work without extension
# write the table out in *.fam format (no header, columns in right order)
write_fam(file_out, tib)
# delete output when done
file.remove(file_out)

</code></pre>

<hr>
<h2 id='write_grm'>Write GCTA GRM and related plink2 binary files</h2><span id='topic+write_grm'></span>

<h3>Description</h3>

<p>This function writes a GCTA Genetic Relatedness Matrix (GRM, i.e. kinship) set of files in their binary format, given a kinship matrix and, if available, the corresponding matrix of pair sample sizes (non-trivial under missingness) and individuals table.
Setting some options allows writing plink2 binary kinship formats such as &quot;king&quot; (follow examples in <code><a href="#topic+read_grm">read_grm()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_grm(
  name,
  kinship,
  M = NULL,
  fam = NULL,
  verbose = TRUE,
  ext = "grm",
  shape = c("triangle", "strict_triangle", "square"),
  size_bytes = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_grm_+3A_name">name</code></td>
<td>
<p>The base name of the output files.
Files with that base, plus shared extension (default &quot;grm&quot;, see <code>ext</code> below), plus extensions <code>.bin</code>, <code>.N.bin</code>, and <code>.id</code> may be created depending on the data provided.</p>
</td></tr>
<tr><td><code id="write_grm_+3A_kinship">kinship</code></td>
<td>
<p>The symmetric <code>n</code>-times-<code>n</code> kinship matrix to write into file with extension <code style="white-space: pre;">&#8288;.&lt;ext&gt;.bin&#8288;</code>.</p>
</td></tr>
<tr><td><code id="write_grm_+3A_m">M</code></td>
<td>
<p>The optional symmetric <code>n</code>-times-<code>n</code> matrix of pair sample sizes to write into file with extension <code style="white-space: pre;">&#8288;.&lt;ext&gt;.N.bin&#8288;</code>.</p>
</td></tr>
<tr><td><code id="write_grm_+3A_fam">fam</code></td>
<td>
<p>The optional data.frame or tibble with individual annotations (columns with names <code>fam</code> and <code>id</code>, subset of columns of Plink FAM) to write into file with extension <code style="white-space: pre;">&#8288;.&lt;ext&gt;.id&#8288;</code>.
If <code>fam</code> is <code>NULL</code> but <code>kinship</code> has non-<code>NULL</code> column or row names, these are used as the second (<code>id</code>) value in the output table (the first (<code>fam</code>) column is set to the missing value in this case).</p>
</td></tr>
<tr><td><code id="write_grm_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the files being written.</p>
</td></tr>
<tr><td><code id="write_grm_+3A_ext">ext</code></td>
<td>
<p>Shared extension for all three outputs (see <code>name</code> above; default &quot;grm&quot;).
Another useful value is &quot;king&quot;, to match the KING-robust format produced by plink2.
If <code>NA</code>, no extension is added.
If given <code>ext</code> is also present at the end of <code>name</code>, then it is not added again.</p>
</td></tr>
<tr><td><code id="write_grm_+3A_shape">shape</code></td>
<td>
<p>The shape of the information to write (may be abbreviated).
Default &quot;triangle&quot; assumes there are <code>n*(n+1)/2</code> values to write corresponding to the upper triangle including the diagonal (required for GCTA GRM).
&quot;strict_triangle&quot; assumes there are <code>n*(n-1)/2</code> values to write corresponding to the upper triangle <em>excluding</em> the diagonal (best for plink2 KING-robust).
Lastly, &quot;square&quot; assumes there are <code>n*n</code> values to write corresponding to the entire square matrix, ignoring symmetry.</p>
</td></tr>
<tr><td><code id="write_grm_+3A_size_bytes">size_bytes</code></td>
<td>
<p>The number of bytes per number encoded.
Default 4 corresponds to GCTA GRM and plink2 &quot;bin4&quot;, whereas plink2 &quot;bin&quot; requires a value of 8.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read_grm">read_grm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to write existing data `kinship`, `M`, and `fam` into files "data.grm.bin" etc, run like this:
# write_grm("data", kinship, M = M, fam = fam )

# The following example is more detailed but also more awkward
# because (only for these examples) the package must create the file in a *temporary* location

# create dummy data to write
# kinship for 3 individuals
kinship &lt;- matrix(
    c(
        0.6, 0.2, 0.0,
        0.2, 0.5, 0.1,
        0.0, 0.1, 0.5
    ),
    nrow = 3
)
# pair sample sizes matrix
M &lt;- matrix(
    c(
        10, 9, 8,
         9, 9, 7,
         8, 7, 8
    ),
    nrow = 3
)
# individual annotations table
library(tibble)
fam &lt;- tibble(
    fam = 1:3,
    id = 1:3
)
# dummy files to write and delete
name &lt;- tempfile('delete-me-example') # no extension
# write the data now!
write_grm( name, kinship, M = M, fam = fam )
# delete outputs when done
delete_files_grm( name )

</code></pre>

<hr>
<h2 id='write_ind'>Write Eigenstrat *.ind files</h2><span id='topic+write_ind'></span>

<h3>Description</h3>

<p>This function writes a tibble with the right columns into a standard Eigenstrat *.ind file.
It uses <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> to do it efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_ind(file, tib, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_ind_+3A_file">file</code></td>
<td>
<p>Output file (whatever is accepted by <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code>).
If file is missing the expected *.ind extension, the function adds it.</p>
</td></tr>
<tr><td><code id="write_ind_+3A_tib">tib</code></td>
<td>
<p>The tibble or data.frame to write.
It must contain these columns: <code>id</code>, <code>sex</code>, <code>label</code>.
Throws an error if any of these columns are missing.
Additional columns are ignored.
Columns are automatically reordered in output as expected in format.</p>
</td></tr>
<tr><td><code id="write_ind_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being written (after autocompleting the extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output <code>tib</code> invisibly (what <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> returns).
</p>


<h3>See Also</h3>

<p>Eigenstrat IND format reference:
<a href="https://github.com/DReichLab/EIG/tree/master/CONVERTF">https://github.com/DReichLab/EIG/tree/master/CONVERTF</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to write an existing table `ind` into file "data.ind", run like this:
# write_ind("data", ind)
# this also works
# write_ind("data.ind", ind)

# The following example is more detailed but also more awkward
# because (only for these examples) the package must create the file in a *temporary* location

# create a dummy tibble with the right columns
library(tibble)
tib &lt;- tibble(
    id = 1:3,
    sex = 1,
    label = 1
)
# a dummy file
file_out &lt;- tempfile('delete-me-example', fileext = '.ind') # will also work without extension
# write the table out in *.ind format (no header, columns in right order)
write_ind(file_out, tib)
# delete output when done
file.remove(file_out)

</code></pre>

<hr>
<h2 id='write_matrix'>Write a matrix to a file without row or column names</h2><span id='topic+write_matrix'></span>

<h3>Description</h3>

<p>The inverse function of <code><a href="#topic+read_matrix">read_matrix()</a></code>, this writes what is intended to be a numeric matrix to a tab-delimited file without row or column names present.
It uses <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> to do it efficiently.
Intended for outputs such as those of admixture inference approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_matrix(file, x, ext = "txt", verbose = TRUE, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_matrix_+3A_file">file</code></td>
<td>
<p>Output file (whatever is accepted by <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code>).
If file is missing the expected extension (see below), the function adds it.</p>
</td></tr>
<tr><td><code id="write_matrix_+3A_x">x</code></td>
<td>
<p>The matrix to write.
Unlike <code><a href="#topic+read_matrix">read_matrix()</a></code>, this is not in fact required to be a matrix or be strictly numeric; anything that coerces to tibble or data.frame is acceptable.</p>
</td></tr>
<tr><td><code id="write_matrix_+3A_ext">ext</code></td>
<td>
<p>The desired file extension.
If <code>NA</code>, no extension is added.
Works if <code>file</code> already contains desired extension.</p>
</td></tr>
<tr><td><code id="write_matrix_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being written (after autocompleting the extension).</p>
</td></tr>
<tr><td><code id="write_matrix_+3A_append">append</code></td>
<td>
<p>If <code>TRUE</code>, appends rows onto the file. (Default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output <code>x</code>, coerced into data.frame, invisibly (what <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> returns).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_matrix">read_matrix()</a></code>, the inverse function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to write an existing matrix `x` into file "data.txt", run like this:
# write_matrix( "data", x )
# this also works
# write_matrix( "data.txt", x )

# The following example is more detailed but also more awkward
# because (only for these examples) the package must create the file in a *temporary* location

# create a dummy matrix with the right columns
x &lt;- rbind( 1:3, (0:2)/10, -1:1 )
# a dummy file
file_out &lt;- tempfile('delete-me-example', fileext = '.txt') # will also work without extension
# write the matrix without header
write_matrix( file_out, x )
# delete output when done
file.remove( file_out )

</code></pre>

<hr>
<h2 id='write_phen'>Write *.phen files</h2><span id='topic+write_phen'></span>

<h3>Description</h3>

<p>This function writes a tibble with the right columns into a standard *.phen file.
It uses <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> to do it efficiently.
GCTA and EMMAX use this format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_phen(file, tib, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_phen_+3A_file">file</code></td>
<td>
<p>Output file (whatever is accepted by <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code>).
If file is missing the expected *.phen extension, the function adds it.</p>
</td></tr>
<tr><td><code id="write_phen_+3A_tib">tib</code></td>
<td>
<p>The tibble or data.frame to write.
It must contain these columns: <code>fam</code>, <code>id</code>, <code>pheno</code>.
Throws an error if any of these columns are missing.
Additional columns are ignored.
Columns are automatically reordered in output as expected in format.</p>
</td></tr>
<tr><td><code id="write_phen_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being written (after autocompleting the extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output <code>tib</code> invisibly (what <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> returns).
</p>


<h3>See Also</h3>

<p>GCTA PHEN format reference:
<a href="https://cnsgenomics.com/software/gcta/#GREMLanalysis">https://cnsgenomics.com/software/gcta/#GREMLanalysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to write an existing table `phen` into file "data.phen", run like this:
# write_phen("data", phen)
# this also works
# write_phen("data.phen", phen)

# The following example is more detailed but also more awkward
# because (only for these examples) the package must create the file in a *temporary* location

# create a dummy tibble with the right columns
library(tibble)
tib &lt;- tibble(
    fam = 1:3,
    id = 1:3,
    pheno = 1
)
# a dummy file
file_out &lt;- tempfile('delete-me-example', fileext = '.phen') # will also work without extension
# write the table out in *.phen format (no header, columns in right order)
write_phen(file_out, tib)
# delete output when done
file.remove(file_out)

</code></pre>

<hr>
<h2 id='write_plink'>Write genotype and sample data into a Plink BED/BIM/FAM file set.</h2><span id='topic+write_plink'></span>

<h3>Description</h3>

<p>This function writes a genotype matrix (<code>X</code>) and its associated locus (<code>bim</code>) and individual (<code>fam</code>) data tables into three Plink files in BED, BIM, and FAM formats, respectively.
This function is a wrapper around the more basic functions
<code><a href="#topic+write_bed">write_bed()</a></code>,
<code><a href="#topic+write_bim">write_bim()</a></code>,
<code><a href="#topic+write_fam">write_fam()</a></code>,
but additionally tests that the data dimensions agree (or stops with an error).
Also checks that the genotype row and column names agree with the bim and fam tables if they are all present.
In addition, if <code>bim = NULL</code> or <code>fam = NULL</code>, these are auto-generated using
<code><a href="#topic+make_bim">make_bim()</a></code> and
<code><a href="#topic+make_fam">make_fam()</a></code>,
which is useful behavior for simulated data.
Lastly, the phenotype can be provided as a separate argument and incorporated automatically if <code>fam = NULL</code> (a common scenario for simulated genotypes and traits).
Below suppose there are <code>m</code> loci and <code>n</code> individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_plink(
  file,
  X,
  bim = NULL,
  fam = NULL,
  pheno = NULL,
  verbose = TRUE,
  append = FALSE,
  write_phen = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_plink_+3A_file">file</code></td>
<td>
<p>Output file path, without extensions (each of .bed, .bim, .fam extensions will be added automatically as needed).</p>
</td></tr>
<tr><td><code id="write_plink_+3A_x">X</code></td>
<td>
<p>The <code>m</code>-by-<code>n</code> genotype matrix.</p>
</td></tr>
<tr><td><code id="write_plink_+3A_bim">bim</code></td>
<td>
<p>The tibble or data.frame containing locus information.
It must contain <code>m</code> rows and these columns: <code>chr</code>, <code>id</code>, <code>posg</code>, <code>pos</code>, <code>ref</code>, <code>alt</code>.
If <code>NULL</code> (default), it will be quietly auto-generated.</p>
</td></tr>
<tr><td><code id="write_plink_+3A_fam">fam</code></td>
<td>
<p>The tibble or data.frame containing individual information.
It must contain <code>n</code> rows and these columns: <code>fam</code>, <code>id</code>, <code>pat</code>, <code>mat</code>, <code>sex</code>, <code>pheno</code>.
If <code>NULL</code> (default), it will be quietly auto-generated.</p>
</td></tr>
<tr><td><code id="write_plink_+3A_pheno">pheno</code></td>
<td>
<p>The phenotype to write into the FAM file assuming <code>fam = NULL</code>.
This must be a length-<code>n</code> vector.
This will be ignored (with a warning) if <code>fam</code> is provided.</p>
</td></tr>
<tr><td><code id="write_plink_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) function reports the paths of the files being written (after autocompleting the extensions).</p>
</td></tr>
<tr><td><code id="write_plink_+3A_append">append</code></td>
<td>
<p>If <code>TRUE</code>, appends loci onto the BED and BIM files (default <code>FALSE</code>).
In this mode, all individuals must be present in each write (only loci are appended); the FAM file is not overwritten if present, but is required at every write for internal validations.
If the FAM file already exists, it is not checked to agree with the FAM table provided.
PHEN file is always unchanged and ignored if <code>append = TRUE</code>.</p>
</td></tr>
<tr><td><code id="write_plink_+3A_write_phen">write_phen</code></td>
<td>
<p>If <code>TRUE</code> and <code>append = FALSE</code>, writes a .phen file too from the <code>fam</code> data provided or auto-generated (using <code><a href="#topic+write_phen">write_phen()</a></code>).
Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, a named list with items in this order: <code>X</code> (genotype matrix), <code>bim</code> (tibble), <code>fam</code> (tibble).
This is most useful when either BIM or FAM tables were auto-generated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write_bed">write_bed()</a></code>,
<code><a href="#topic+write_bim">write_bim()</a></code>,
<code><a href="#topic+write_fam">write_fam()</a></code>,
<code><a href="#topic+make_bim">make_bim()</a></code>,
<code><a href="#topic+make_fam">make_fam()</a></code>.
</p>
<p>Plink BED/BIM/FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats">https://www.cog-genomics.org/plink/1.9/formats</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to write existing data `X`, `bim`, `fam` into files "data.bed", "data.bim", and "data.fam",
# run like this:
# write_plink("data", X, bim = bim, fam = fam)

# The following example is more detailed but also more awkward
# because (only for these examples) the package must create the file in a *temporary* location

# here is an example for a simulation

# create 10 random genotypes
X &lt;- rbinom(10, 2, 0.5)
# replace 3 random genotypes with missing values
X[sample(10, 3)] &lt;- NA
# turn into 5x2 matrix
X &lt;- matrix(X, nrow = 5, ncol = 2)

# simulate a trait for two individuals
pheno &lt;- rnorm(2)

# write this data to BED/BIM/FAM files
# output path without extension
file_out &lt;- tempfile('delete-me-example')
# here all of the BIM and FAM columns except `pheno` are autogenerated
write_plink(file_out, X, pheno = pheno)

# delete all three outputs when done
delete_files_plink( file_out )

</code></pre>

<hr>
<h2 id='write_snp'>Write Eigenstrat *.snp files</h2><span id='topic+write_snp'></span>

<h3>Description</h3>

<p>This function writes a tibble with the right columns into a standard Eigenstrat *.snp file.
It uses <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> to do it efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_snp(file, tib, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_snp_+3A_file">file</code></td>
<td>
<p>Output file (whatever is accepted by <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code>).
If file is missing the expected *.snp extension, the function adds it.</p>
</td></tr>
<tr><td><code id="write_snp_+3A_tib">tib</code></td>
<td>
<p>The tibble or data.frame to write.
It must contain these columns: <code>id</code>, <code>chr</code>, <code>posg</code>, <code>pos</code>, <code>ref</code>, <code>alt</code>.
Throws an error if any of these columns are missing.
Additional columns are ignored.
Columns are automatically reordered in output as expected in format.</p>
</td></tr>
<tr><td><code id="write_snp_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), function reports the path of the file being written (after autocompleting the extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output <code>tib</code> invisibly (what <code><a href="readr.html#topic+write_delim">readr::write_tsv()</a></code> returns).
</p>


<h3>See Also</h3>

<p>Eigenstrat SNP format reference:
<a href="https://github.com/DReichLab/EIG/tree/master/CONVERTF">https://github.com/DReichLab/EIG/tree/master/CONVERTF</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to write an existing table `snp` into file "data.snp", run like this:
# write_snp("data", snp)
# this also works
# write_snp("data.snp", snp)

# The following example is more detailed but also more awkward
# because (only for these examples) the package must create the file in a *temporary* location

# create a dummy tibble with the right columns
library(tibble)
tib &lt;- tibble(
    id = 1:3,
    chr = 1:3,
    posg = 0,
    pos = 1:3,
    ref = 'A',
    alt = 'B'
)
# a dummy file
file_out &lt;- tempfile('delete-me-example', fileext = '.snp') # will also work without extension
# write the table out in *.snp format (no header, columns in right order)
write_snp(file_out, tib)
# delete output when done
file.remove(file_out)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
