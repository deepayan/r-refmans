<!DOCTYPE html><html><head><title>Help for package valaddin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {valaddin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#valaddin-package'><p>valaddin: Functional Input Validation</p></a></li>
<li><a href='#checklist'><p>Is a formula a check formula?</p></a></li>
<li><a href='#components'><p>Decompose a firmly applied function</p></a></li>
<li><a href='#firmly'><p>Apply a function firmly</p></a></li>
<li><a href='#input-validators'><p>Generate input-validation checks</p></a></li>
<li><a href='#misc-checkers'><p>Miscellaneous checkers</p></a></li>
<li><a href='#scalar-checkers'><p>Scalar checkers</p></a></li>
<li><a href='#type-checkers'><p>Type checkers</p></a></li>
<li><a href='#validate'><p>Validate objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functional Input Validation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of basic tools to transform functions into functions with
    input validation checks, in a manner suitable for both programmatic and
    interactive use.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lazyeval (&ge; 0.2.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magrittr, testthat, stringr, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egnha/valaddin">https://github.com/egnha/valaddin</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/egnha/valaddin/issues">https://github.com/egnha/valaddin/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'utils.R' 'pipe.R' 'rawrd.R' 'formulas.R' 'checklist.R'
'components.R' 'call.R' 'firmly.R' 'validate.R' 'scope.R'
'checkers.R' 'valaddin-package.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-25 16:57:43 UTC; eha</td>
</tr>
<tr>
<td>Author:</td>
<td>Eugene Ha [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eugene Ha &lt;eha@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-25 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='valaddin-package'>valaddin: Functional Input Validation</h2><span id='topic+valaddin'></span><span id='topic+valaddin-package'></span>

<h3>Description</h3>

<p><em>valaddin</em> provides a functional operator, <code><a href="#topic+firmly">firmly</a></code>, that
enhances functions with input validation. You supply a function <code>f</code>
along with input validation requirements, and <code>firmly</code> returns a
function that applies <code>f</code> &ldquo;firmly&rdquo;: before a call to <code>f</code> is
attempted, its inputs are checked, and if any check fails, an error halts
further execution with a message tabulating every failing check. Because
<code>firmly</code> implements input validation by operating on whole functions
rather than values, it is suitable for both programming and interactive use.
<br /><br />
Using <code>firmly</code> to add input validation to your functions improves the
legibility, reusability, and reliability of your code:
</p>

<ul>
<li><p> Emphasize the core logic of your functions by excising validation
boilerplate.
</p>
</li>
<li><p> Reduce duplication by reusing common checks across functions with
common input requirements.
</p>
</li>
<li><p> Make function outputs more predictable by constraining their inputs.
</p>
</li>
<li><p> Vary the strictness of a function according to need and circumstance.
</p>
</li></ul>



<h3>Details</h3>

<p>For an example-oriented overview of valaddin, see
<code>vignette("valaddin")</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eugene Ha <a href="mailto:eha@posteo.de">eha@posteo.de</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/egnha/valaddin">https://github.com/egnha/valaddin</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/egnha/valaddin/issues">https://github.com/egnha/valaddin/issues</a>
</p>
</li></ul>


<hr>
<h2 id='checklist'>Is a formula a check formula?</h2><span id='topic+checklist'></span><span id='topic+is_check_formula'></span><span id='topic+is_checklist'></span>

<h3>Description</h3>

<p><code>is_check_formula(x)</code> checks whether <code>x</code> is a check formula, while
<code>is_checklist(x)</code> checks whether <code>x</code> is a <em>checklist</em>, i.e., a
list of check formulae. (Neither function verifies logical consistency of the
implied checks.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_check_formula(x)

is_checklist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checklist_+3A_x">x</code></td>
<td>
<p>Object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_check_formula</code>, resp. <code>is_checklist</code>, returns
<code>TRUE</code> or <code>FALSE</code>, according to whether <code>x</code> is or is not a
check formula, resp. checklist.
</p>


<h3>See Also</h3>

<p><a href="#topic+firmly">firmly</a> (on the specification and use of check formulae)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_check_formula(list(~x, ~y) ~ is.numeric)  # [1] TRUE
is_check_formula("Not positive" ~ {. &gt; 0})   # [1] TRUE

is_checklist(list(list(~x, ~y) ~ is.numeric, "Not positive" ~ {. &gt; 0}))
# [1] TRUE

# Invalid checklists
is_checklist("Not positive" ~ {. &gt; 0})            # [1] FALSE (not a list)
is_checklist(list(is.numeric ~ list(~ x)))        # [1] FALSE (backwards)
is_checklist(list(list(log ~ x) ~ is.character))  # [1] FALSE (invalid check item)

</code></pre>

<hr>
<h2 id='components'>Decompose a firmly applied function</h2><span id='topic+components'></span><span id='topic+firm_core'></span><span id='topic+firm_checks'></span><span id='topic+firm_error'></span><span id='topic+firm_args'></span>

<h3>Description</h3>

<p>Decompose a firmly applied function (i.e., a function created by
<code><a href="#topic+firmly">firmly</a></code>):
</p>

<ul>
<li> <p><code>firm_core</code> extracts the underlying &ldquo;core&rdquo;
function—the function that is called when all arguments are valid.
</p>
</li>
<li> <p><code>firm_checks</code> extracts the checks.
</p>
</li>
<li> <p><code>firm_error</code> extracts the subclass of the error condition that
is signaled when an input validation error occurs.
</p>
</li>
<li> <p><code>firm_args</code> extracts the names of arguments whose presence is to
be checked, i.e., those specified by the <code>.warn_missing</code> switch of
<code><a href="#topic+firmly">firmly</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>firm_core(x)

firm_checks(x)

firm_error(x)

firm_args(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="components_+3A_x">x</code></td>
<td>
<p>Object to decompose.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a firmly applied function:
</p>

<ul>
<li> <p><code>firm_core</code> returns a function.
</p>
</li>
<li> <p><code>firm_checks</code> returns a data frame with components <code>expr</code>
(language), <code>env</code> (environment), <code>string</code> (character),
<code>msg</code> (character).
</p>
</li>
<li> <p><code>firm_error</code> returns a character vector.
</p>
</li>
<li> <p><code>firm_args</code> returns a character vector.
</p>
</li></ul>

<p>In the absence of the component to be extracted, these functions return
<code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+firmly">firmly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x, y, ...) NULL
f_fm &lt;- firmly(f, ~is.numeric, list(~x, ~y - x) ~ {. &gt; 0})

identical(firm_core(f_fm), f)                  # [1] TRUE
firm_checks(f_fm)                              # 4 x 4 data frame
firm_error(f_fm)                               # [1] "simpleError"
firm_args(f_fm)                                # NULL
firm_args(firmly(f_fm, .warn_missing = "y"))   # [1] "y"

</code></pre>

<hr>
<h2 id='firmly'>Apply a function firmly</h2><span id='topic+firmly'></span><span id='topic++25checkin+25'></span><span id='topic+loosely'></span><span id='topic+is_firm'></span>

<h3>Description</h3>

<p><code>firmly</code> transforms a function into a function with input validation
checks. <code>loosely</code> undoes the application of <code>firmly</code>, by returning
the original function (without checks). <code>is_firm</code> is a predicate
function that checks whether an object is a firmly applied function, i.e.,
a function created by <code>firmly</code>.
<br /><br />
Use <code>%checkin%</code> to apply <code>firmly</code> as an operator. Since this
allows you to keep checks and arguments adjacent, it is the preferred way to
use <code>firmly</code> in scripts and packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firmly(.f, ..., .checklist = list(), .warn_missing = character(),
       .error_class = character())

.checks %checkin% .f

loosely(.f, .keep_check = FALSE, .keep_warning = FALSE)

is_firm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firmly_+3A_.f">.f</code></td>
<td>
<p>Interpreted function, i.e., closure.</p>
</td></tr>
<tr><td><code id="firmly_+3A_...">...</code></td>
<td>
<p>Input-validation check formula(e).</p>
</td></tr>
<tr><td><code id="firmly_+3A_.checklist">.checklist</code></td>
<td>
<p>List of check formulae. (These are combined with check
formulae provided via <code>...</code>.)</p>
</td></tr>
<tr><td><code id="firmly_+3A_.warn_missing">.warn_missing</code></td>
<td>
<p>Arguments of <code>.f</code> whose absence should raise a
warning (character).</p>
</td></tr>
<tr><td><code id="firmly_+3A_.error_class">.error_class</code></td>
<td>
<p>Subclass of the error condition to be raised when an
input validation error occurs (character).</p>
</td></tr>
<tr><td><code id="firmly_+3A_.checks">.checks</code></td>
<td>
<p>List of check formulae, optionally containing character
vectors named <code>.warn_missing</code>, <code>.error_class</code>, corresponding to
the similarly named arguments.</p>
</td></tr>
<tr><td><code id="firmly_+3A_.keep_check">.keep_check</code>, <code id="firmly_+3A_.keep_warning">.keep_warning</code></td>
<td>
<p>Should existing checks, resp.
missing-argument warnings, be kept?</p>
</td></tr>
<tr><td><code id="firmly_+3A_x">x</code></td>
<td>
<p>Object to test.</p>
</td></tr>
</table>


<h3>Check Formulae</h3>

<p>An <strong>input validation check</strong> is specified by a <strong>check
formula</strong>, a special <a href="stats.html#topic+formula">formula</a> of the form
</p>
<pre>&lt;scope&gt; ~ &lt;predicate&gt;</pre>
<p>where the right-hand side expresses <em>what</em> to check, and the left-hand
side expresses <em>where</em> to check it.
</p>
<p>The right-hand side <code>&lt;predicate&gt;</code> is a <strong>predicate</strong> function,
i.e, a one-argument function that returns either <code>TRUE</code> or
<code>FALSE</code>. It is the condition to check/enforce. The left-hand side
<code>&lt;scope&gt;</code> is an expression specifying what the condition is to be
applied to: whether the condition is to be applied to all
(non-<code>...</code>) arguments of <code>.f</code> (the case of &ldquo;global
scope&rdquo;), or whether the condition is to be selectively applied to certain
expressions of the arguments (the case of &ldquo;local scope&rdquo;).
</p>
<p>According to <strong>scope</strong>, there are two classes of check formulae:
</p>

<ul>
<li> <p><strong>Check formulae of global scope</strong>
</p>
<pre>&lt;string&gt; ~ &lt;predicate&gt;</pre>
<pre>~&lt;predicate&gt;</pre>
<div class="sourceCode"><pre>\item \strong{Check formulae of local scope}
  \preformatted{list(&lt;check_item&gt;, &lt;check_item&gt;, ...) ~ &lt;predicate&gt;}
</pre></div>
</li></ul>



<h4>Check Formulae of Global Scope</h4>

<p>A <strong>global check formula</strong> is a succinct way of asserting that the
function <code>&lt;predicate&gt;</code> returns <code>TRUE</code> when called on each
(non-<code>...</code>) argument of <code>.f</code>. Each argument for which
<code>&lt;predicate&gt;</code> <em>fails</em>—returns <code>FALSE</code> or is itself not
evaluable—produces an error message, which is auto-generated unless a
custom error message is supplied by specifying the string
<code>&lt;string&gt;</code>.
</p>
<div class="sourceCode"><pre>\subsection{Example}{
  The condition that all (non-\code{\dots}) arguments of a function must
  be numerical can be enforced by the check formula
  \preformatted{~is.numeric}
  or
  \preformatted{"Not numeric" ~ is.numeric}
  if the custom error message \code{"Not numeric"} is to be used (in lieu
  of an auto-generated error message).
}
</pre></div>



<h4>Check Formulae of Local Scope</h4>

<p>A <strong>local check formula</strong> imposes argument-specific conditions. Each
<strong>check item</strong> <code>&lt;check_item&gt;</code> is a formula of the form <code>~
    &lt;expression&gt;</code> (one-sided) or <code>&lt;string&gt; ~ &lt;expression&gt;</code>; it imposes
the condition that the function <code>&lt;predicate&gt;</code> is <code>TRUE</code> for the
expression <code>&lt;expression&gt;</code>. As for global check formulae, each check
item for which <code>&lt;predicate&gt;</code> fails produces an error message, which
is auto-generated unless a custom error message is supplied by a string
as part of the left-hand side of the check item (formula).
</p>
<div class="sourceCode"><pre>\subsection{Example}{
  The condition that \code{x} and \code{y} must differ for the function
  \code{function(x, y) {1 / (x - y)}} can be enforced by the local
  check formula
  \preformatted{list(~x - y) ~ function(.) abs(.) &gt; 0}
  or
  \preformatted{list("x, y must differ" ~ x - y) ~ function(.) abs(.) &gt; 0}
  if the custom error message \code{"x, y must differ"} is to be used (in
  lieu of an auto-generated error message).
}
</pre></div>



<h4>Anonymous Predicate Functions</h4>

<p>Following the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a>
package, an anonymous (predicate) function of a single argument <code>.</code>
can be concisely expressed by enclosing the body of such a function
within curly braces <code>{ }</code>.
</p>
<div class="sourceCode"><pre>\subsection{Example}{
  The (onsided, global) check formula
  \preformatted{~{. &gt; 0}}
  is equivalent to the check formula \code{~function(.) {. &gt; 0}}
}
</pre></div>



<h3>Value</h3>



<h4><code>firmly</code></h4>

<p><code>firmly</code> does nothing when there is nothing to do: <code>.f</code> is
returned, unaltered, when both <code>.checklist</code> and <code>.warn_missing</code>
are empty, or when <code>.f</code> has no named argument and
<code>.warn_missing</code> is empty.
</p>
<div class="sourceCode"><pre>Otherwise, \code{firmly} again returns a function that behaves
\emph{identically} to \code{.f}, but also performs input validation:
before a call to \code{.f} is attempted, its inputs are checked, and if
any check fails, an error halts further execution with a message
tabulating every failing check. (If all checks pass, the call to
\code{.f} respects lazy evaluation, as usual.)

\subsection{Subclass of the input-validation error object}{
  The subclass of the error object is \code{.error_class}, unless
  \code{.error_class} is \code{character()}. In the latter case, the
  subclass of the error object is that of the existing error object, if
  \code{.f} is itself a firmly applied function, or it is
  \code{"simpleError"}, otherwise.
}

\subsection{Formal Arguments and Attributes}{
  \code{firmly} preserves the attributes and formal arguments of
  \code{.f} (except that the \code{"class"} attribute gains the component
  \code{"firm_closure"}, unless it already contains it).
}
</pre></div>



<h4><code>%checkin%</code></h4>

<p><code>%checkin%</code> applies the check formula(e) in the list <code>.checks</code>
to <code>.f</code>, using <code>firmly</code>. The <code>.warn_missing</code> and
<code>.error_class</code> arguments of <code>firmly</code> may be specified as named
components of <code>.checks</code>.
</p>



<h4><code>loosely</code></h4>

<p><code>loosely</code> returns <code>.f</code>, unaltered, when <code>.f</code> is not a
firmly applied function, or both <code>.keep_check</code> and
<code>.keep_warning</code> are <code>TRUE</code>.
</p>
<div class="sourceCode"><pre>Otherwise, \code{loosely} returns the underlying (original) function,
stripped of any input validation checks imposed by \code{firmly}, unless
one of the flags \code{.keep_check}, \code{.keep_warning} is switched on:
if \code{.keep_check}, resp. \code{.keep_warning}, is \code{TRUE},
\code{loosely} retains any existing checks, resp. missing-argument
warnings, of \code{.f}.
</pre></div>



<h4><code>is_firm</code></h4>

<p><code>is_firm</code> returns <code>TRUE</code> if <code>x</code> is a firmly applied
function (i.e., has class <code>"firm_closure"</code>), and <code>FALSE</code>,
otherwise.
</p>



<h3>See Also</h3>

<p><code>firmly</code> is enhanced by a number of helper functions:
</p>

<ul>
<li><p> To verify that a check formula is syntactically correct, use the
predicates <code><a href="#topic+is_check_formula">is_check_formula</a></code>, <code><a href="#topic+is_checklist">is_checklist</a></code>.
</p>
</li>
<li><p> To make custom check-formula generators, use
<code><a href="#topic+localize">localize</a></code>.
</p>
</li>
<li><p> Pre-made check-formula generators are provided to facilitate
argument checks for <a href="#topic+type-checkers">types</a>,
<a href="#topic+scalar-checkers">scalar objects</a>, and
<a href="#topic+misc-checkers">other</a> common data structures and input
assumptions. These functions are prefixed by <code>vld_</code>, for
convenient browsing and look-up in editors and IDE's that support name
completion.
</p>
</li>
<li><p> To access the components of a firmly applied function, use
<code><a href="#topic+firm_core">firm_core</a></code>, <code><a href="#topic+firm_checks">firm_checks</a></code>,
<code><a href="#topic+firm_error">firm_error</a></code>, <code><a href="#topic+firm_args">firm_args</a></code>, (or simply
<code><a href="base.html#topic+print">print</a></code> the function to display its components).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

dlog &lt;- function(x, h) (log(x + h) - log(x)) / h

# Require all arguments to be numeric (auto-generated error message)
dlog_fm &lt;- firmly(dlog, ~is.numeric)
dlog_fm(1, .1)    # [1] 0.9531018
dlog_fm("1", .1)  # Error: "FALSE: is.numeric(x)"

# Require all arguments to be numeric (custom error message)
dlog_fm &lt;- firmly(dlog, "Not numeric" ~ is.numeric)
dlog_fm("1", .1)  # Error: "Not numeric: `x`"

# Alternatively, "globalize" a localized checker (see ?localize, ?globalize)
dlog_fm &lt;- firmly(dlog, globalize(vld_numeric))
dlog_fm("1", .1)  # Error: "Not double/integer: `x`"

# Predicate functions can be specified anonymously or by name
dlog_fm &lt;- firmly(dlog, list(~x, ~x + h, ~abs(h)) ~ function(x) x &gt; 0)
dlog_fm &lt;- firmly(dlog, list(~x, ~x + h, ~abs(h)) ~ {. &gt; 0})
is_positive &lt;- function(x) x &gt; 0
dlog_fm &lt;- firmly(dlog, list(~x, ~x + h, ~abs(h)) ~ is_positive)
dlog_fm(1, 0)  # Error: "FALSE: is_positive(abs(h))"

# Describe checks individually using custom error messages
dlog_fm &lt;-
  firmly(dlog,
         list("x not positive" ~ x, ~x + h, "Division by 0 (=h)" ~ abs(h)) ~
           is_positive)
dlog_fm(-1, 0)
# Errors: "x not positive", "FALSE: is_positive(x + h)", "Division by 0 (=h)"

# Specify checks more succinctly by using a (localized) custom checker
req_positive &lt;- localize("Not positive" ~ is_positive)
dlog_fm &lt;- firmly(dlog, req_positive(~x, ~x + h, ~abs(h)))
dlog_fm(1, 0)  # Error: "Not positive: abs(h)"

# Combine multiple checks
dlog_fm &lt;- firmly(dlog,
                  "Not numeric" ~ is.numeric,
                  list(~x, ~x + h, "Division by 0" ~ abs(h)) ~ {. &gt; 0})
dlog_fm("1", 0)  # Errors: "Not numeric: `x`", check-eval error, "Division by 0"

# Any check can be expressed using isTRUE
err_msg &lt;- "x, h differ in length"
dlog_fm &lt;- firmly(dlog, list(err_msg ~ length(x) - length(h)) ~ {. == 0L})
dlog_fm(1:2, 0:2)  # Error: "x, h differ in length"
dlog_fm &lt;- firmly(dlog, list(err_msg ~ length(x) == length(h)) ~ isTRUE)
dlog_fm(1:2, 0:2)  # Error: "x, h differ in length"

# More succinctly, use vld_true
dlog_fm &lt;- firmly(dlog, vld_true(~length(x) == length(h), ~all(abs(h) &gt; 0)))
dlog_fm(1:2, 0:2)
# Errors: "Not TRUE: length(x) == length(h)", "Not TRUE: all(abs(h) &gt; 0)"

dlog_fm(1:2, 1:2)  # [1] 0.6931472 0.3465736

# loosely recovers the underlying function
identical(loosely(dlog_fm), dlog)  # [1] TRUE

# Use .warn_missing when you want to ensure an argument is explicitly given
# (see vignette("valaddin") for an elaboration of this particular example)
as_POSIXct &lt;- firmly(as.POSIXct, .warn_missing = "tz")
Sys.setenv(TZ = "EST")
as_POSIXct("2017-01-01 03:14:16")  # [1] "2017-01-01 03:14:16 EST"
                                   # Warning: "Argument(s) expected ... `tz`"
as_POSIXct("2017-01-01 03:14:16", tz = "UTC")  # [1] "2017-01-01 03:14:16 UTC"
loosely(as_POSIXct)("2017-01-01 03:14:16")     # [1] "2017-01-01 03:14:16 EST"

# Use firmly to constrain undesirable behavior, e.g., long-running computations
fib &lt;- function(n) {
  if (n &lt;= 1L) return(1L)
  Recall(n - 1) + Recall(n - 2)
}
fib &lt;- firmly(fib, list("`n` capped at 30" ~ ceiling(n)) ~ {. &lt;= 30L})
fib(21)  # [1] 17711 (NB: Validation done only once, not for every recursive call)
fib(31)  # Error: `n` capped at 30

# Apply fib unrestricted
loosely(fib)(31)  # [1] 2178309 (may take several seconds to finish)

# firmly won't force an argument that's not involved in checks
g &lt;- firmly(function(x, y) "Pass", list(~x) ~ is.character)
g(c("a", "b"), stop("Not signaled"))  # [1] "Pass"

# In scripts and packages, it is recommended to use the operator %checkin%
vec_add &lt;- list(
  ~is.numeric,
  list(~length(x) == length(y)) ~ isTRUE,
  .error_class = "inputError"
) %checkin%
  function(x, y) {
    x + y
  }

# Or call firmly with .f explicitly assigned to the function
vec_add2 &lt;- firmly(
  ~is.numeric,
  list(~length(x) == length(y)) ~ isTRUE,
  .f = function(x, y) {
    x + y
  },
  .error_class = "inputError"
)

all.equal(vec_add, vec_add2)  # [1] TRUE

## End(Not run)

</code></pre>

<hr>
<h2 id='input-validators'>Generate input-validation checks</h2><span id='topic+input-validators'></span><span id='topic+localize'></span><span id='topic+globalize'></span>

<h3>Description</h3>

<p><code>localize</code> derives a function that <em>generates</em> check formulae of
local scope from a check formula of global scope. <code>globalize</code> takes such
a check-formula generator and returns the underlying global check formula.
These operations are mutually invertible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localize(chk)

globalize(chkr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="input-validators_+3A_chk">chk</code></td>
<td>
<p>Check formula of global scope <em>with</em> custom error message,
i.e., a formula of the form <code>&lt;string&gt; ~ &lt;predicate&gt;</code>.</p>
</td></tr>
<tr><td><code id="input-validators_+3A_chkr">chkr</code></td>
<td>
<p>Function of class <code>"check_maker"</code>, i.e., a function created
by <code>localize</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>localize</code> returns a function of class <code>"check_maker"</code> and
call signature <code>function(...)</code>:
</p>

<ul>
<li><p> The <code>...</code> are <strong>check items</strong> (see <em>Check Formulae
of Local Scope</em> in the documentation page <a href="#topic+firmly">firmly</a>).
</p>
</li>
<li><p> The return value is the check formula of local scope whose scope is
comprised of these check items, and whose predicate function is that of
<code>chk</code> (i.e., the right-hand side of <code>chk</code>). Unless a check
item has its own error message, the error message is derived from that
of <code>chk</code> (i.e., the left-hand side of <code>chk</code>).
</p>
</li></ul>

<p><code>globalize</code> returns the global-scope check formula from which
the function <code>chkr</code> is derived.
</p>


<h3>See Also</h3>

<p>The notion of &ldquo;scope&rdquo; is explained in the <em>Check
Formulae</em> section of <a href="#topic+firmly">firmly</a>.
</p>
<p>Ready-made checkers for <a href="#topic+type-checkers">types</a>,
<a href="#topic+scalar-checkers">scalar objects</a>, and
<a href="#topic+misc-checkers">miscellaneous predicates</a> are provided as a
convenience, and as a model for creating families of check makers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chk_pos_gbl &lt;- "Not positive" ~ {. &gt; 0}
chk_pos_lcl &lt;- localize(chk_pos_gbl)
chk_pos_lcl(~x, "y not greater than x" ~ x - y)
# list("Not positive: x" ~ x, "y not greater than x" ~ x - y) ~ {. &gt; 0}

# localize and globalize are mutual inverses
identical(globalize(localize(chk_pos_gbl)), chk_pos_gbl)  # [1] TRUE
all.equal(localize(globalize(chk_pos_lcl)), chk_pos_lcl)  # [1] TRUE

## Not run: 

pass &lt;- function(x, y) "Pass"

# Impose local positivity checks
f &lt;- firmly(pass, chk_pos_lcl(~x, "y not greater than x" ~ x - y))
f(2, 1)  # [1] "Pass"
f(2, 2)  # Error: "y not greater than x"
f(0, 1)  # Errors: "Not positive: x", "y not greater than x"

# Or just check positivity of x
g &lt;- firmly(pass, chk_pos_lcl(~x))
g(1, 0)  # [1] "Pass"
g(0, 0)  # Error: "Not positive: x"

# In contrast, chk_pos_gbl checks positivity for all arguments
h &lt;- firmly(pass, chk_pos_gbl)
h(2, 2)  # [1] "Pass"
h(1, 0)  # Error: "Not positive: `y`"
h(0, 0)  # Errors: "Not positive: `x`", "Not positive: `y`"

# Alternatively, globalize the localized checker
h2 &lt;- firmly(pass, globalize(chk_pos_lcl))
all.equal(h, h2)  # [1] TRUE

# Use localize to make parameterized checkers
chk_lte &lt;- function(n, ...) {
  err_msg &lt;- paste("Not &lt;=", as.character(n))
  localize(err_msg ~ {. &lt;= n})(...)
}
fib &lt;- function(n) {
  if (n &lt;= 1L) return(1L)
  Recall(n - 1) + Recall(n - 2)
}
capped_fib &lt;- firmly(fib, chk_lte(30, ~ ceiling(n)))
capped_fib(19)  # [1] 6765
capped_fib(31)  # Error: "Not &lt;= 30: ceiling(n)"

## End(Not run)

</code></pre>

<hr>
<h2 id='misc-checkers'>Miscellaneous checkers</h2><span id='topic+misc-checkers'></span><span id='topic+vld_all'></span><span id='topic+vld_any'></span><span id='topic+vld_array'></span><span id='topic+vld_atomic'></span><span id='topic+vld_call'></span><span id='topic+vld_closure'></span><span id='topic+vld_data_frame'></span><span id='topic+vld_empty'></span><span id='topic+vld_environment'></span><span id='topic+vld_expression'></span><span id='topic+vld_factor'></span><span id='topic+vld_false'></span><span id='topic+vld_formula'></span><span id='topic+vld_function'></span><span id='topic+vld_language'></span><span id='topic+vld_list'></span><span id='topic+vld_matrix'></span><span id='topic+vld_na'></span><span id='topic+vld_name'></span><span id='topic+vld_nan'></span><span id='topic+vld_null'></span><span id='topic+vld_numeric'></span><span id='topic+vld_ordered'></span><span id='topic+vld_pairlist'></span><span id='topic+vld_primitive'></span><span id='topic+vld_recursive'></span><span id='topic+vld_symbol'></span><span id='topic+vld_table'></span><span id='topic+vld_true'></span><span id='topic+vld_unsorted'></span><span id='topic+vld_vector'></span>

<h3>Description</h3>

<p>These functions make check formulae of local scope based on the
correspondingly named <span class="pkg">base</span> R predicates <code>is.*</code> (e.g.,
<code>vld_data_frame</code> corresponds to the predicate
<code><a href="base.html#topic+is.data.frame">is.data.frame</a></code>), with the following exceptions:
</p>

<ul>
<li> <p><code>vld_empty</code> is based on the predicate <code>length(.) == 0</code>
</p>
</li>
<li> <p><code>vld_formula</code> is based on the predicate
<code>typeof(.) == "language" &amp;&amp; inherits(., "formula")</code>
</p>
</li>
<li> <p><code>vld_closure</code> is based on the predicate <code>typeof(.) == "closure"</code>
</p>
</li>
<li> <p><code>vld_true</code> and <code>vld_false</code> are based on the predicates
<code>identical(., TRUE)</code> and <code>identical(., FALSE)</code>, resp.
</p>
</li></ul>

<p>The checkers <code>vld_true</code> and <code>vld_false</code> are all-purpose checkers to
specify <em>arbitrary</em> input validation checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vld_all(...)

vld_any(...)

vld_array(...)

vld_atomic(...)

vld_call(...)

vld_closure(...)

vld_data_frame(...)

vld_empty(...)

vld_environment(...)

vld_expression(...)

vld_factor(...)

vld_false(...)

vld_formula(...)

vld_function(...)

vld_language(...)

vld_list(...)

vld_matrix(...)

vld_na(...)

vld_name(...)

vld_nan(...)

vld_null(...)

vld_numeric(...)

vld_ordered(...)

vld_pairlist(...)

vld_primitive(...)

vld_recursive(...)

vld_symbol(...)

vld_table(...)

vld_true(...)

vld_unsorted(...)

vld_vector(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="misc-checkers_+3A_...">...</code></td>
<td>
<p>Check items, i.e., formulae that are one-sided or have a string
as left-hand side (see <em>Check Formulae of Local Scope</em> in the
documentation page <a href="#topic+firmly">firmly</a>). These are the expressions to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each function <code>vld_*</code> is a function of class
<code>"check_maker"</code>, generated by <code><a href="#topic+localize">localize</a></code>.
</p>


<h3>Value</h3>

<p>Check formula of local scope.
</p>


<h3>See Also</h3>

<p>Corresponding predicates: <code><a href="base.html#topic+all">all</a></code>, <code><a href="base.html#topic+any">any</a></code>, <code><a href="base.html#topic+is.array">is.array</a></code>, <code><a href="base.html#topic+is.atomic">is.atomic</a></code>, <code><a href="base.html#topic+is.call">is.call</a></code>, <code><a href="base.html#topic+is.data.frame">is.data.frame</a></code>, <code><a href="base.html#topic+is.environment">is.environment</a></code>, <code><a href="base.html#topic+is.expression">is.expression</a></code>, <code><a href="base.html#topic+is.factor">is.factor</a></code>, <code><a href="base.html#topic+is.function">is.function</a></code>, <code><a href="base.html#topic+is.language">is.language</a></code>, <code><a href="base.html#topic+is.list">is.list</a></code>, <code><a href="base.html#topic+is.matrix">is.matrix</a></code>, <code><a href="base.html#topic+is.na">is.na</a></code>, <code><a href="base.html#topic+is.name">is.name</a></code>, <code><a href="base.html#topic+is.nan">is.nan</a></code>, <code><a href="base.html#topic+is.null">is.null</a></code>, <code><a href="base.html#topic+is.numeric">is.numeric</a></code>, <code><a href="base.html#topic+is.ordered">is.ordered</a></code>, <code><a href="base.html#topic+is.pairlist">is.pairlist</a></code>, <code><a href="base.html#topic+is.primitive">is.primitive</a></code>, <code><a href="base.html#topic+is.recursive">is.recursive</a></code>, <code><a href="base.html#topic+is.symbol">is.symbol</a></code>, <code><a href="base.html#topic+is.table">is.table</a></code>, <code><a href="base.html#topic+is.unsorted">is.unsorted</a></code>, <code><a href="base.html#topic+is.vector">is.vector</a></code>
</p>
<p><code><a href="#topic+globalize">globalize</a></code> recovers the underlying check formula of global scope.
</p>
<p>The notions of &ldquo;scope&rdquo; and &ldquo;check item&rdquo; are explained in the <em>Check Formulae</em> section of <a href="#topic+firmly">firmly</a>.
</p>
<p>Other checkers: <a href="#topic+type-checkers">type-checkers</a>, <a href="#topic+scalar-checkers">scalar-checkers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

f &lt;- function(x, y) "Pass"

# Impose the condition that x is a formula
g &lt;- firmly(f, vld_formula(~x))
g(z ~ a + b, 0)  # [1] "Pass"
g(0, 0)          # Error: "Not formula: x"

# Impose the condition that x and y are disjoint (assuming they are vectors)
h &lt;- firmly(f, vld_empty(~intersect(x, y)))
h(letters[1:3], letters[4:5])  # [1] "Pass"
h(letters[1:3], letters[3:5])  # Error: "Not empty: intersect(x, y)"

# Use a custom error message
h &lt;- firmly(f, vld_empty("x, y must be disjoint" ~ intersect(x, y)))
h(letters[1:3], letters[3:5])  # Error: "x, y must be disjoint"

# vld_true can be used to implement any kind of input validation
ifelse_f &lt;- firmly(ifelse, vld_true(~typeof(yes) == typeof(no)))
(w &lt;- {set.seed(1); rnorm(5)})
# [1] -0.6264538  0.1836433 -0.8356286  1.5952808  0.3295078
ifelse_f(w &gt; 0, 0, "1")  # Error: "Not TRUE: typeof(yes) == typeof(no)"
ifelse_f(w &gt; 0, 0, 1)    # [1] 1 0 1 0 0

## End(Not run)

</code></pre>

<hr>
<h2 id='scalar-checkers'>Scalar checkers</h2><span id='topic+scalar-checkers'></span><span id='topic+vld_boolean'></span><span id='topic+vld_number'></span><span id='topic+vld_scalar_atomic'></span><span id='topic+vld_scalar_character'></span><span id='topic+vld_scalar_complex'></span><span id='topic+vld_scalar_double'></span><span id='topic+vld_scalar_integer'></span><span id='topic+vld_scalar_list'></span><span id='topic+vld_scalar_logical'></span><span id='topic+vld_scalar_numeric'></span><span id='topic+vld_scalar_raw'></span><span id='topic+vld_scalar_vector'></span><span id='topic+vld_singleton'></span><span id='topic+vld_string'></span>

<h3>Description</h3>

<p>These functions make check formulae of local scope based on the
correspondingly named scalar type predicate from <span class="pkg">base</span> R. For example,
<code>vld_scalar_logical</code> creates check formulae (of local scope) for the
predicate <code>is.logical(.) &amp;&amp; length(.) == 1</code>. The function <code>vld_singleton</code> is
based on the predicate <code>length(.) == 1</code>.
</p>
<p>The functions <code>vld_boolean</code>, <code>vld_number</code>, <code>vld_string</code> are aliases for
<code>vld_scalar_logical</code>, <code>vld_scalar_numeric</code>, <code>vld_scalar_character</code>, resp.
(with appropriately modified error messages).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vld_boolean(...)

vld_number(...)

vld_scalar_atomic(...)

vld_scalar_character(...)

vld_scalar_complex(...)

vld_scalar_double(...)

vld_scalar_integer(...)

vld_scalar_list(...)

vld_scalar_logical(...)

vld_scalar_numeric(...)

vld_scalar_raw(...)

vld_scalar_vector(...)

vld_singleton(...)

vld_string(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalar-checkers_+3A_...">...</code></td>
<td>
<p>Check items, i.e., formulae that are one-sided or have a string
as left-hand side (see <em>Check Formulae of Local Scope</em> in the
documentation page <a href="#topic+firmly">firmly</a>). These are the expressions to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each function <code>vld_*</code> is a function of class
<code>"check_maker"</code>, generated by <code><a href="#topic+localize">localize</a></code>.
</p>


<h3>Value</h3>

<p>Check formula of local scope.
</p>


<h3>See Also</h3>

<p>Corresponding predicates: <code><a href="base.html#topic+is.atomic">is.atomic</a></code>, <code><a href="base.html#topic+is.character">is.character</a></code>, <code><a href="base.html#topic+is.complex">is.complex</a></code>, <code><a href="base.html#topic+is.double">is.double</a></code>, <code><a href="base.html#topic+is.integer">is.integer</a></code>, <code><a href="base.html#topic+is.list">is.list</a></code>, <code><a href="base.html#topic+is.logical">is.logical</a></code>, <code><a href="base.html#topic+is.numeric">is.numeric</a></code>, <code><a href="base.html#topic+is.raw">is.raw</a></code>, <code><a href="base.html#topic+is.vector">is.vector</a></code>
</p>
<p><code><a href="#topic+globalize">globalize</a></code> recovers the underlying check formula of global scope.
</p>
<p>The notions of &ldquo;scope&rdquo; and &ldquo;check item&rdquo; are explained in the <em>Check Formulae</em> section of <a href="#topic+firmly">firmly</a>.
</p>
<p>Other checkers: <a href="#topic+type-checkers">type-checkers</a>, <a href="#topic+misc-checkers">misc-checkers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

f &lt;- function(x, y) "Pass"

# Impose a check on x: ensure it's boolean (i.e., a scalar logical vector)
f_firm &lt;- firmly(f, vld_boolean(~x))
f_firm(TRUE, 0)           # [1] "Pass"
f_firm(c(TRUE, TRUE), 0)  # Error: "Not boolean: x"

# Use a custom error message
f_firm &lt;- firmly(f, vld_boolean("x is not TRUE/FALSE/NA" ~ x))
f_firm(c(TRUE, TRUE), 0)  # Error: "x is not TRUE/FALSE/NA"

# To impose the same check on all arguments, apply globalize
f_firmer &lt;- firmly(f, globalize(vld_boolean))
f_firmer(TRUE, FALSE)    # [1] "Pass"
f_firmer(TRUE, 0)        # Error: "Not boolean: `y`"
f_firmer(logical(0), 0)  # Errors: "Not boolean: `x`", "Not boolean: `y`"

## End(Not run)
</code></pre>

<hr>
<h2 id='type-checkers'>Type checkers</h2><span id='topic+type-checkers'></span><span id='topic+vld_character'></span><span id='topic+vld_complex'></span><span id='topic+vld_double'></span><span id='topic+vld_integer'></span><span id='topic+vld_logical'></span><span id='topic+vld_raw'></span>

<h3>Description</h3>

<p>These functions make check formulae of local scope based on the
correspondingly named (atomic) type predicate from <span class="pkg">base</span> R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vld_character(...)

vld_complex(...)

vld_double(...)

vld_integer(...)

vld_logical(...)

vld_raw(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type-checkers_+3A_...">...</code></td>
<td>
<p>Check items, i.e., formulae that are one-sided or have a string
as left-hand side (see <em>Check Formulae of Local Scope</em> in the
documentation page <a href="#topic+firmly">firmly</a>). These are the expressions to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each function <code>vld_*</code> is a function of class
<code>"check_maker"</code>, generated by <code><a href="#topic+localize">localize</a></code>.
</p>


<h3>Value</h3>

<p>Check formula of local scope.
</p>


<h3>See Also</h3>

<p>Corresponding predicates: <code><a href="base.html#topic+is.character">is.character</a></code>, <code><a href="base.html#topic+is.complex">is.complex</a></code>, <code><a href="base.html#topic+is.double">is.double</a></code>, <code><a href="base.html#topic+is.integer">is.integer</a></code>, <code><a href="base.html#topic+is.logical">is.logical</a></code>, <code><a href="base.html#topic+is.raw">is.raw</a></code>
</p>
<p><code><a href="#topic+globalize">globalize</a></code> recovers the underlying check formula of global scope.
</p>
<p>The notions of &ldquo;scope&rdquo; and &ldquo;check item&rdquo; are explained in the <em>Check Formulae</em> section of <a href="#topic+firmly">firmly</a>.
</p>
<p>Other checkers: <a href="#topic+scalar-checkers">scalar-checkers</a>, <a href="#topic+misc-checkers">misc-checkers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

f &lt;- function(x, y) "Pass"

# Impose a check on x: ensure it's of type "logical"
f_firm &lt;- firmly(f, vld_logical(~x))
f_firm(TRUE, 0)  # [1] "Pass"
f_firm(1, 0)     # Error: "Not logical: x"

# Use a custom error message
f_firm &lt;- firmly(f, vld_logical("x should be a logical vector" ~ x))
f_firm(1, 0)     # Error: "x should be a logical vector"

# To impose the same check on all arguments, apply globalize()
f_firmer &lt;- firmly(f, globalize(vld_logical))
f_firmer(TRUE, FALSE)  # [1] "Pass"
f_firmer(TRUE, 0)      # Error: "Not logical: `y`"
f_firmer(1, 0)         # Errors: "Not logical: `x`", "Not logical: `y`"

## End(Not run)
</code></pre>

<hr>
<h2 id='validate'>Validate objects</h2><span id='topic+validate'></span><span id='topic++25checkout+25'></span>

<h3>Description</h3>

<p>Validate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(., ..., .checklist = list(), .error_class = "validationError")

.f %checkout% .checks
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_+3A_.">.</code></td>
<td>
<p>Object to validate.</p>
</td></tr>
<tr><td><code id="validate_+3A_...">...</code></td>
<td>
<p>Input-validation check formula(e).</p>
</td></tr>
<tr><td><code id="validate_+3A_.checklist">.checklist</code></td>
<td>
<p>List of check formulae. (These are combined with check
formulae provided via <code>...</code>.)</p>
</td></tr>
<tr><td><code id="validate_+3A_.error_class">.error_class</code></td>
<td>
<p>Subclass of the error condition to be raised when an
input validation error occurs (character).</p>
</td></tr>
<tr><td><code id="validate_+3A_.f">.f</code></td>
<td>
<p>Interpreted function, i.e., closure.</p>
</td></tr>
<tr><td><code id="validate_+3A_.checks">.checks</code></td>
<td>
<p>List of check formulae, optionally containing a character
vector named <code>.error_class</code>, corresponding to the similarly named
argument.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(magrittr)

# Valid assertions: data frame returned (invisibly)
mtcars %&gt;%
  validate(
    vld_all(~sapply(., is.numeric)),
    ~{nrow(.) &gt; 10},
    vld_all(~c("mpg", "cyl") %in% names(.))
  )

# Invalid assertions: error raised
mtcars %&gt;%
  validate(
    vld_all(~sapply(., is.numeric)),
    ~{nrow(.) &gt; 1000},
    vld_all(~c("mpg", "cylinders") %in% names(.))
  )

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
