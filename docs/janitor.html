<!DOCTYPE html><html lang="en"><head><title>Help for package janitor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {janitor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_totals_col'><p>Append a totals column to a data.frame.</p></a></li>
<li><a href='#add_totals_row'><p>Append a totals row to a data.frame.</p></a></li>
<li><a href='#adorn_crosstab'><p>Add presentation formatting to a crosstabulation table.</p></a></li>
<li><a href='#adorn_ns'><p>Add underlying Ns to a tabyl displaying percentages.</p></a></li>
<li><a href='#adorn_pct_formatting'><p>Format a data.frame of decimals as percentages.</p></a></li>
<li><a href='#adorn_percentages'><p>Convert a data.frame of counts to percentages.</p></a></li>
<li><a href='#adorn_rounding'><p>Round the numeric columns in a data.frame.</p></a></li>
<li><a href='#adorn_title'><p>Add column name to the top of a two-way tabyl.</p></a></li>
<li><a href='#adorn_totals'><p>Append a totals row and/or column to a data.frame.</p></a></li>
<li><a href='#as_tabyl'><p>Add <code>tabyl</code> attributes to a data.frame.</p></a></li>
<li><a href='#chisq.test'><p>Apply stats::chisq.test to a two-way tabyl</p></a></li>
<li><a href='#clean_names'><p>Cleans names of an object (usually a data.frame).</p></a></li>
<li><a href='#compare_df_cols'><p>Generate a comparison of data.frames (or similar objects) that indicates if</p>
they will successfully bind together by rows.</a></li>
<li><a href='#compare_df_cols_same'><p>Do the the data.frames have the same columns &amp; types?</p></a></li>
<li><a href='#convert_to_date'><p>Convert many date and datetime formats as may be received from Microsoft</p>
Excel</a></li>
<li><a href='#convert_to_NA'><p>Convert string values to true <code>NA</code> values.</p></a></li>
<li><a href='#crosstab'><p>Generate a crosstabulation of two vectors.</p></a></li>
<li><a href='#describe_class'><p>Describe the class(es) of an object</p></a></li>
<li><a href='#excel_numeric_to_date'><p>Convert dates encoded as serial numbers to Date class.</p></a></li>
<li><a href='#find_header'><p>Find the header row in a data.frame</p></a></li>
<li><a href='#fisher.test'><p>Apply stats::fisher.test to a two-way tabyl</p></a></li>
<li><a href='#get_dupes'><p>Get rows of a <code>data.frame</code> with identical values for the specified variables.</p></a></li>
<li><a href='#get_one_to_one'><p>Find the list of columns that have a 1:1 mapping to each other</p></a></li>
<li><a href='#janitor'><p>janitor</p></a></li>
<li><a href='#janitor_deprecated'><p>Deprecated Functions in Package janitor</p></a></li>
<li><a href='#make_clean_names'><p>Cleans a vector of text, typically containing the names of an object.</p></a></li>
<li><a href='#mu_to_u'><p>Constant to help map from mu to u</p></a></li>
<li><a href='#remove_constant'><p>Remove constant columns from a data.frame or matrix.</p></a></li>
<li><a href='#remove_empty'><p>Remove empty rows and/or columns from a data.frame or matrix.</p></a></li>
<li><a href='#remove_empty_cols'><p>Removes empty columns from a data.frame.</p></a></li>
<li><a href='#remove_empty_rows'><p>Removes empty rows from a data.frame.</p></a></li>
<li><a href='#round_half_up'><p>Round a numeric vector; halves will be rounded up, ala Microsoft Excel.</p></a></li>
<li><a href='#round_to_fraction'><p>Round to the nearest fraction of a specified denominator.</p></a></li>
<li><a href='#row_to_names'><p>Elevate a row to be the column names of a data.frame.</p></a></li>
<li><a href='#sas_numeric_to_date'><p>Convert a SAS date, time or date/time to an R object</p></a></li>
<li><a href='#signif_half_up'><p>Round a numeric vector to the specified number of significant digits; halves will be rounded up.</p></a></li>
<li><a href='#single_value'><p>Ensure that a vector has only a single value throughout.</p></a></li>
<li><a href='#tabyl'><p>Generate a frequency table (1-, 2-, or 3-way).</p></a></li>
<li><a href='#top_levels'><p>Generate a frequency table of a factor grouped into top-n, bottom-n, and all other levels.</p></a></li>
<li><a href='#untabyl'><p>Remove <code>tabyl</code> attributes from a data.frame.</p></a></li>
<li><a href='#use_first_valid_of'><p>Returns first non-NA value from a set of vectors.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simple Tools for Examining and Cleaning Dirty Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The main janitor functions can: perfectly format data.frame column
    names; provide quick counts of variable combinations (i.e., frequency
    tables and crosstabs); and explore duplicate records. Other janitor functions
    nicely format the tabulation results. These tabulate-and-report functions
    approximate popular features of SPSS and Microsoft Excel. This package
    follows the principles of the "tidyverse" and works well with the pipe function
    %&gt;%. janitor was built with beginning-to-intermediate R users in mind and is
    optimized for user-friendliness.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sfirke/janitor">https://github.com/sfirke/janitor</a>,
<a href="https://sfirke.github.io/janitor/">https://sfirke.github.io/janitor/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sfirke/janitor/issues">https://github.com/sfirke/janitor/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.0), hms, lifecycle, lubridate, magrittr, purrr,
rlang, stringi, stringr, snakecase (&ge; 0.9.2), tidyselect (&ge;
1.0.0), tidyr (&ge; 0.7.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dbplyr, knitr, rmarkdown, RSQLite, sf, testthat (&ge; 3.0.0),
tibble, tidygraph</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-22 15:53:13 UTC; sam</td>
</tr>
<tr>
<td>Author:</td>
<td>Sam Firke [aut, cre],
  Bill Denney [ctb],
  Chris Haid [ctb],
  Ryan Knight [ctb],
  Malte Grosser [ctb],
  Jonathan Zadra [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sam Firke &lt;samuel.firke@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-22 16:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Exported from the magrittr package.  To learn more, run <code>?magrittr::`%&gt;%`</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;%
  tabyl(carb, cyl) %&gt;%
  adorn_totals()
</code></pre>

<hr>
<h2 id='add_totals_col'>Append a totals column to a data.frame.</h2><span id='topic+add_totals_col'></span>

<h3>Description</h3>

<p>This function is deprecated, use <code>adorn_totals</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_totals_col(dat, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_totals_col_+3A_dat">dat</code></td>
<td>
<p>an input data.frame with at least one numeric column.</p>
</td></tr>
<tr><td><code id="add_totals_col_+3A_na.rm">na.rm</code></td>
<td>
<p>should missing values (including NaN) be omitted from the calculations?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with a totals column containing row-wise sums.
</p>

<hr>
<h2 id='add_totals_row'>Append a totals row to a data.frame.</h2><span id='topic+add_totals_row'></span>

<h3>Description</h3>

<p>This function is deprecated, use <code>adorn_totals</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_totals_row(dat, fill = "-", na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_totals_row_+3A_dat">dat</code></td>
<td>
<p>an input data.frame with at least one numeric column.</p>
</td></tr>
<tr><td><code id="add_totals_row_+3A_fill">fill</code></td>
<td>
<p>if there are more than one non-numeric columns, what string should fill the bottom row of those columns?</p>
</td></tr>
<tr><td><code id="add_totals_row_+3A_na.rm">na.rm</code></td>
<td>
<p>should missing values (including NaN) be omitted from the calculations?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with a totals row, consisting of &quot;Total&quot; in the first column and column sums in the others.
</p>

<hr>
<h2 id='adorn_crosstab'>Add presentation formatting to a crosstabulation table.</h2><span id='topic+adorn_crosstab'></span>

<h3>Description</h3>

<p>This function is deprecated, use the <code>adorn_</code> family of functions instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adorn_crosstab(
  dat,
  denom = "row",
  show_n = TRUE,
  digits = 1,
  show_totals = FALSE,
  rounding = "half to even"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adorn_crosstab_+3A_dat">dat</code></td>
<td>
<p>a data.frame with row names in the first column and numeric values in all other columns.  Usually the piped-in result of a call to  <code>crosstab</code> that included the argument <code>percent = "none"</code>.</p>
</td></tr>
<tr><td><code id="adorn_crosstab_+3A_denom">denom</code></td>
<td>
<p>the denominator to use for calculating percentages.  One of &quot;row&quot;, &quot;col&quot;, or &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="adorn_crosstab_+3A_show_n">show_n</code></td>
<td>
<p>should counts be displayed alongside the percentages?</p>
</td></tr>
<tr><td><code id="adorn_crosstab_+3A_digits">digits</code></td>
<td>
<p>how many digits should be displayed after the decimal point?</p>
</td></tr>
<tr><td><code id="adorn_crosstab_+3A_show_totals">show_totals</code></td>
<td>
<p>display a totals summary? Will be a row, column, or both depending on the value of <code>denom</code>.</p>
</td></tr>
<tr><td><code id="adorn_crosstab_+3A_rounding">rounding</code></td>
<td>
<p>method to use for truncating percentages - either &quot;half to even&quot;, the base R default method, or &quot;half up&quot;, where 14.5 rounds up to 15.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame.
</p>

<hr>
<h2 id='adorn_ns'>Add underlying Ns to a tabyl displaying percentages.</h2><span id='topic+adorn_ns'></span>

<h3>Description</h3>

<p>This function adds back the underlying Ns to a <code>tabyl</code> whose percentages were calculated using <code>adorn_percentages()</code>, to display the Ns and percentages together.  You can also call it on a non-tabyl data.frame to which you wish to append Ns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adorn_ns(
  dat,
  position = "rear",
  ns = attr(dat, "core"),
  format_func = function(x) {
     format(x, big.mark = ",")
 },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adorn_ns_+3A_dat">dat</code></td>
<td>
<p>a data.frame of class <code>tabyl</code> that has had <code>adorn_percentages</code> and/or <code>adorn_pct_formatting</code> called on it.  If given a list of data.frames, this function will apply itself to each data.frame in the list (designed for 3-way <code>tabyl</code> lists).</p>
</td></tr>
<tr><td><code id="adorn_ns_+3A_position">position</code></td>
<td>
<p>should the N go in the front, or in the rear, of the percentage?</p>
</td></tr>
<tr><td><code id="adorn_ns_+3A_ns">ns</code></td>
<td>
<p>the Ns to append.  The default is the &quot;core&quot; attribute of the input tabyl <code>dat</code>, where the original Ns of a two-way <code>tabyl</code> are stored.  However, if your Ns are stored somewhere else, or you need to customize them beyond what can be done with 'format_func', you can supply them here.</p>
</td></tr>
<tr><td><code id="adorn_ns_+3A_format_func">format_func</code></td>
<td>
<p>a formatting function to run on the Ns.  Consider defining with <code>base::format()</code>.</p>
</td></tr>
<tr><td><code id="adorn_ns_+3A_...">...</code></td>
<td>
<p>columns to adorn.  This takes a tidyselect specification.  By default, all columns are adorned except for the first column and columns not of class <code>numeric</code>, but this allows you to manually specify which columns should be adorned, for use on a data.frame that does not result from a call to <code>tabyl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with Ns appended
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mtcars %&gt;%
  tabyl(am, cyl) %&gt;%
  adorn_percentages("col") %&gt;%
  adorn_pct_formatting() %&gt;%
  adorn_ns(position = "front")
  
# Format the Ns with a custom format_func:
set.seed(1)
bigger_dat &lt;- data.frame(sex = rep(c("m", "f"), 3000),
                         age = round(runif(3000, 1, 102), 0))
bigger_dat$age_group = cut(bigger_dat$age, quantile(bigger_dat$age, c(0, 1/3, 2/3, 1)))

bigger_dat %&gt;%
  tabyl(age_group, sex, show_missing_levels = FALSE) %&gt;%
  adorn_totals(c("row", "col")) %&gt;%
  adorn_percentages("col") %&gt;%
  adorn_pct_formatting(digits = 1) %&gt;% 
  adorn_ns(format_func = function(x) format(x, big.mark = ".", decimal.mark = ","))
# Control the columns to be adorned with the ... variable selection argument
# If using only the ... argument, you can use empty commas as shorthand 
# to supply the default values to the preceding arguments:

cases &lt;- data.frame(
  region = c("East", "West"),
  year = 2015,
  recovered = c(125, 87),
  died = c(13, 12)
)

cases %&gt;%
 adorn_percentages("col",,recovered:died) %&gt;%
 adorn_pct_formatting(,,,,,recovered:died) %&gt;%
 adorn_ns(,,,recovered:died)
  
</code></pre>

<hr>
<h2 id='adorn_pct_formatting'>Format a data.frame of decimals as percentages.</h2><span id='topic+adorn_pct_formatting'></span>

<h3>Description</h3>

<p>Numeric columns get multiplied by 100 and formatted as percentages according to user specifications.  This function defaults to excluding the first column of the input data.frame, assuming that it contains a descriptive variable, but this can be overridden by specifying the columns to adorn in the <code>...</code> argument.  Non-numeric columns are always excluded.
</p>
<p>The decimal separator character is the result of <code>getOption("OutDec")</code>, which is based on the user's locale.  If the default behavior is undesirable,
change this value ahead of calling the function, either by changing locale or with <code>options(OutDec = ",")</code>.  This aligns the decimal separator character with that used in <code>base::print()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adorn_pct_formatting(
  dat,
  digits = 1,
  rounding = "half to even",
  affix_sign = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adorn_pct_formatting_+3A_dat">dat</code></td>
<td>
<p>a data.frame with decimal values, typically the result of a call to <code>adorn_percentages</code> on a <code>tabyl</code>.  If given a list of data.frames, this function will apply itself to each data.frame in the list (designed for 3-way <code>tabyl</code> lists).</p>
</td></tr>
<tr><td><code id="adorn_pct_formatting_+3A_digits">digits</code></td>
<td>
<p>how many digits should be displayed after the decimal point?</p>
</td></tr>
<tr><td><code id="adorn_pct_formatting_+3A_rounding">rounding</code></td>
<td>
<p>method to use for rounding - either &quot;half to even&quot;, the base R default method, or &quot;half up&quot;, where 14.5 rounds up to 15.</p>
</td></tr>
<tr><td><code id="adorn_pct_formatting_+3A_affix_sign">affix_sign</code></td>
<td>
<p>should the % sign be affixed to the end?</p>
</td></tr>
<tr><td><code id="adorn_pct_formatting_+3A_...">...</code></td>
<td>
<p>columns to adorn.  This takes a tidyselect specification.  By default, all numeric columns (besides the initial column, if numeric) are adorned, but this allows you to manually specify which columns should be adorned, for use on a data.frame that does not result from a call to <code>tabyl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with formatted percentages
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mtcars %&gt;%
  tabyl(am, cyl) %&gt;%
  adorn_percentages("col") %&gt;%
  adorn_pct_formatting()
  
# Control the columns to be adorned with the ... variable selection argument
# If using only the ... argument, you can use empty commas as shorthand 
# to supply the default values to the preceding arguments:

cases &lt;- data.frame(
  region = c("East", "West"),
  year = 2015,
  recovered = c(125, 87),
  died = c(13, 12)
)

cases %&gt;%
 adorn_percentages("col",,recovered:died) %&gt;%
 adorn_pct_formatting(,,,recovered:died)

</code></pre>

<hr>
<h2 id='adorn_percentages'>Convert a data.frame of counts to percentages.</h2><span id='topic+adorn_percentages'></span>

<h3>Description</h3>

<p>This function defaults to excluding the first column of the input data.frame, assuming that it contains a descriptive variable, but this can be overridden by specifying the columns to adorn in the <code>...</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adorn_percentages(dat, denominator = "row", na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adorn_percentages_+3A_dat">dat</code></td>
<td>
<p>a <code>tabyl</code> or other data.frame with a tabyl-like layout.  If given a list of data.frames, this function will apply itself to each data.frame in the list (designed for 3-way <code>tabyl</code> lists).</p>
</td></tr>
<tr><td><code id="adorn_percentages_+3A_denominator">denominator</code></td>
<td>
<p>the direction to use for calculating percentages.  One of &quot;row&quot;, &quot;col&quot;, or &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="adorn_percentages_+3A_na.rm">na.rm</code></td>
<td>
<p>should missing values (including NaN) be omitted from the calculations?</p>
</td></tr>
<tr><td><code id="adorn_percentages_+3A_...">...</code></td>
<td>
<p>columns to adorn.  This takes a tidyselect specification.  By default, all numeric columns (besides the initial column, if numeric) are adorned, but this allows you to manually specify which columns should be adorned, for use on a data.frame that does not result from a call to <code>tabyl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame of percentages, expressed as numeric values between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mtcars %&gt;%
  tabyl(am, cyl) %&gt;%
  adorn_percentages("col")

# calculates correctly even with totals column and/or row:
mtcars %&gt;%
  tabyl(am, cyl) %&gt;%
  adorn_totals("row") %&gt;%
  adorn_percentages()
  
# Control the columns to be adorned with the ... variable selection argument
# If using only the ... argument, you can use empty commas as shorthand 
# to supply the default values to the preceding arguments:

cases &lt;- data.frame(
  region = c("East", "West"),
  year = 2015,
  recovered = c(125, 87),
  died = c(13, 12)
)

cases %&gt;%
 adorn_percentages(,,recovered:died)
</code></pre>

<hr>
<h2 id='adorn_rounding'>Round the numeric columns in a data.frame.</h2><span id='topic+adorn_rounding'></span>

<h3>Description</h3>

<p>Can run on any data.frame with at least one numeric column.  This function defaults to excluding the first column of the input data.frame, assuming that it contains a descriptive variable, but this can be overridden by specifying the columns to round in the <code>...</code> argument.
</p>
<p>If you're formatting percentages, e.g., the result of <code>adorn_percentages()</code>, use <code>adorn_pct_formatting()</code> instead.  This is a more flexible variant for ad-hoc usage.  Compared to <code>adorn_pct_formatting()</code>, it does not multiply by 100 or pad the numbers with spaces for alignment in the results data.frame.   This function retains the class of numeric input columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adorn_rounding(dat, digits = 1, rounding = "half to even", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adorn_rounding_+3A_dat">dat</code></td>
<td>
<p>a <code>tabyl</code> or other data.frame with similar layout.  If given a list of data.frames, this function will apply itself to each data.frame in the list (designed for 3-way <code>tabyl</code> lists).</p>
</td></tr>
<tr><td><code id="adorn_rounding_+3A_digits">digits</code></td>
<td>
<p>how many digits should be displayed after the decimal point?</p>
</td></tr>
<tr><td><code id="adorn_rounding_+3A_rounding">rounding</code></td>
<td>
<p>method to use for rounding - either &quot;half to even&quot;, the base R default method, or &quot;half up&quot;, where 14.5 rounds up to 15.</p>
</td></tr>
<tr><td><code id="adorn_rounding_+3A_...">...</code></td>
<td>
<p>columns to adorn.  This takes a tidyselect specification.  By default, all numeric columns (besides the initial column, if numeric) are adorned, but this allows you to manually specify which columns should be adorned, for use on a data.frame that does not result from a call to <code>tabyl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the data.frame with rounded numeric columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mtcars %&gt;%
  tabyl(am, cyl) %&gt;%
  adorn_percentages() %&gt;%
  adorn_rounding(digits = 2, rounding = "half up")

# tolerates non-numeric columns:
library(dplyr)
mtcars %&gt;%
  tabyl(am, cyl) %&gt;%
  adorn_percentages("all") %&gt;%
  mutate(dummy = "a") %&gt;%
  adorn_rounding()
  
# Control the columns to be adorned with the ... variable selection argument
# If using only the ... argument, you can use empty commas as shorthand 
# to supply the default values to the preceding arguments:
cases &lt;- data.frame(
  region = c("East", "West"),
  year = 2015,
  recovered = c(125, 87),
  died = c(13, 12)
)

cases %&gt;%
  adorn_percentages(,,ends_with("ed")) %&gt;%
  adorn_rounding(,,one_of(c("recovered", "died")))
</code></pre>

<hr>
<h2 id='adorn_title'>Add column name to the top of a two-way tabyl.</h2><span id='topic+adorn_title'></span>

<h3>Description</h3>

<p>This function adds the column variable name to the top of a <code>tabyl</code> for a complete display of information.  This makes the tabyl prettier, but renders the data.frame less useful for further manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adorn_title(dat, placement = "top", row_name, col_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adorn_title_+3A_dat">dat</code></td>
<td>
<p>a data.frame of class <code>tabyl</code> or other data.frame with a tabyl-like layout.  If given a list of data.frames, this function will apply itself to each data.frame in the list (designed for 3-way <code>tabyl</code> lists).</p>
</td></tr>
<tr><td><code id="adorn_title_+3A_placement">placement</code></td>
<td>
<p>whether the column name should be added to the top of the tabyl in an otherwise-empty row <code>"top"</code> or appended to the already-present row name variable (<code>"combined"</code>).  The formatting in the <code>"top"</code> option has the look of base R's <code>table()</code>; it also wipes out the other column names, making it hard to further use the data.frame besides formatting it for reporting.  The <code>"combined"</code> option is more conservative in this regard.</p>
</td></tr>
<tr><td><code id="adorn_title_+3A_row_name">row_name</code></td>
<td>
<p>(optional) default behavior is to pull the row name from the attributes of the input <code>tabyl</code> object.  If you wish to override that text, or if your input is not a <code>tabyl</code>, supply a string here.</p>
</td></tr>
<tr><td><code id="adorn_title_+3A_col_name">col_name</code></td>
<td>
<p>(optional) default behavior is to pull the column_name from the attributes of the input <code>tabyl</code> object.  If you wish to override that text, or if your input is not a <code>tabyl</code>, supply a string here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input tabyl, augmented with the column title.  Non-tabyl inputs that are of class <code>tbl_df</code> are downgraded to basic data.frames so that the title row prints correctly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mtcars %&gt;%
  tabyl(am, cyl) %&gt;%
  adorn_title(placement = "top")

# Adding a title to a non-tabyl
library(tidyr); library(dplyr)
mtcars %&gt;%
  group_by(gear, am) %&gt;%
  summarise(avg_mpg = mean(mpg), .groups = "drop") %&gt;%
  spread(gear, avg_mpg) %&gt;%
  adorn_rounding() %&gt;%
  adorn_title("top", row_name = "Gears", col_name = "Cylinders")
</code></pre>

<hr>
<h2 id='adorn_totals'>Append a totals row and/or column to a data.frame.</h2><span id='topic+adorn_totals'></span>

<h3>Description</h3>

<p>This function defaults to excluding the first column of the input data.frame, assuming that it contains a descriptive variable, but this can be overridden by specifying the columns to be totaled in the <code>...</code> argument.  Non-numeric columns are converted to character class and have a user-specified fill character inserted in the totals row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adorn_totals(dat, where = "row", fill = "-", na.rm = TRUE, name = "Total", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adorn_totals_+3A_dat">dat</code></td>
<td>
<p>an input data.frame with at least one numeric column.  If given a list of data.frames, this function will apply itself to each data.frame in the list (designed for 3-way <code>tabyl</code> lists).</p>
</td></tr>
<tr><td><code id="adorn_totals_+3A_where">where</code></td>
<td>
<p>one of &quot;row&quot;, &quot;col&quot;, or <code>c("row", "col")</code></p>
</td></tr>
<tr><td><code id="adorn_totals_+3A_fill">fill</code></td>
<td>
<p>if there are non-numeric columns, what should fill the bottom row of those columns? If a string, relevant columns will be coerced to character. If 'NA' then column types are preserved.</p>
</td></tr>
<tr><td><code id="adorn_totals_+3A_na.rm">na.rm</code></td>
<td>
<p>should missing values (including NaN) be omitted from the calculations?</p>
</td></tr>
<tr><td><code id="adorn_totals_+3A_name">name</code></td>
<td>
<p>name of the totals row and/or column.  If both are created, and <code>name</code> is a single string, that name is applied to both. If both are created and <code>name</code> is a vector of length 2, the first element of the vector will be used as the row name (in column 1), and the second element will be used as the totals column name. Defaults to &quot;Total&quot;.</p>
</td></tr>
<tr><td><code id="adorn_totals_+3A_...">...</code></td>
<td>
<p>columns to total.  This takes a tidyselect specification.  By default, all numeric columns (besides the initial column, if numeric) are included in the totals, but this allows you to manually specify which columns should be included, for use on a data.frame that does not result from a call to <code>tabyl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame augmented with a totals row, column, or both.  The data.frame is now also of class <code>tabyl</code> and stores information about the attached totals and underlying data in the tabyl attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;%
  tabyl(am, cyl) %&gt;%
  adorn_totals()
</code></pre>

<hr>
<h2 id='as_tabyl'>Add <code>tabyl</code> attributes to a data.frame.</h2><span id='topic+as_tabyl'></span>

<h3>Description</h3>

<p>A <code>tabyl</code> is a data.frame containing counts of a variable or co-occurrences of two variables (a.k.a., a contingency table or crosstab).  This specialized kind of data.frame has attributes that enable <code>adorn_</code> functions to be called for precise formatting and presentation of results.  E.g., display results as a mix of percentages, Ns, add totals rows or columns, rounding options, in the style of Microsoft Excel PivotTable.
</p>
<p>A <code>tabyl</code> can be the result of a call to <code>janitor::tabyl()</code>, in which case these attributes are added automatically.  This function adds <code>tabyl</code> class attributes to a data.frame that isn't the result of a call to <code>tabyl</code> but meets the requirements of a two-way tabyl:
1) First column contains values of variable 1
2) Column names 2:n are the values of variable 2
3) Numeric values in columns 2:n are counts of the co-occurrences of the two variables.*
</p>
<p>* = this is the ideal form of a tabyl, but janitor's <code>adorn_</code> functions tolerate and ignore non-numeric columns in positions 2:n.
</p>
<p>For instance, the result of <code>dplyr::count()</code> followed by <code>tidyr::spread()</code> can be treated as a <code>tabyl</code>.
</p>
<p>The result of calling <code>tabyl()</code> on a single variable is a special class of one-way tabyl; this function only pertains to the two-way tabyl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tabyl(dat, axes = 2, row_var_name = NULL, col_var_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_tabyl_+3A_dat">dat</code></td>
<td>
<p>a data.frame with variable values in the first column and numeric values in all other columns.</p>
</td></tr>
<tr><td><code id="as_tabyl_+3A_axes">axes</code></td>
<td>
<p>is this a two_way tabyl or a one_way tabyl?  If this function is being called by a user, this should probably be &quot;2&quot;.  One-way tabyls are created by <code>tabyl</code> but are a special case.</p>
</td></tr>
<tr><td><code id="as_tabyl_+3A_row_var_name">row_var_name</code></td>
<td>
<p>(optional) the name of the variable in the row dimension; used by <code>adorn_title()</code>.</p>
</td></tr>
<tr><td><code id="as_tabyl_+3A_col_var_name">col_var_name</code></td>
<td>
<p>(optional) the name of the variable in the column dimension; used by <code>adorn_title()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the same data.frame, but with the additional class of &quot;tabyl&quot; and the attribute &quot;core&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_tabyl(mtcars)

</code></pre>

<hr>
<h2 id='chisq.test'>Apply stats::chisq.test to a two-way tabyl</h2><span id='topic+chisq.test'></span><span id='topic+chisq.test.default'></span><span id='topic+chisq.test.tabyl'></span>

<h3>Description</h3>

<p>This generic function overrides stats::chisq.test. If the passed table 
is a two-way tabyl, it runs it through janitor::chisq.test.tabyl, otherwise
it just calls stats::chisq.test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisq.test(x, ...)

## Default S3 method:
chisq.test(x, y = NULL, ...)

## S3 method for class 'tabyl'
chisq.test(x, tabyl_results = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chisq.test_+3A_x">x</code></td>
<td>
<p>a two-way tabyl, a numeric vector or a factor</p>
</td></tr>
<tr><td><code id="chisq.test_+3A_...">...</code></td>
<td>
<p>other parameters passed to stats::chisq.test</p>
</td></tr>
<tr><td><code id="chisq.test_+3A_y">y</code></td>
<td>
<p>if x is a vector, must be another vector or factor of the same length</p>
</td></tr>
<tr><td><code id="chisq.test_+3A_tabyl_results">tabyl_results</code></td>
<td>
<p>if TRUE and x is a tabyl object, also return 'observed', 'expected', 'residuals' and 'stdres' as tabyl</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is the same as the one of stats::chisq.test. If 'tabyl_results' 
is TRUE, the returned tables 'observed', 'expected', 'residuals' and 'stdres' 
are converted to tabyls.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- tabyl(mtcars, gear, cyl)
chisq.test(tab)
chisq.test(tab)$residuals

</code></pre>

<hr>
<h2 id='clean_names'>Cleans names of an object (usually a data.frame).</h2><span id='topic+clean_names'></span><span id='topic+clean_names.default'></span><span id='topic+clean_names.sf'></span><span id='topic+clean_names.tbl_graph'></span><span id='topic+clean_names.tbl_lazy'></span>

<h3>Description</h3>

<p>Resulting names are unique and consist only of the <code>_</code> character, numbers, and letters.
Capitalization preferences can be specified using the <code>case</code> parameter.
</p>
<p>Accented characters are transliterated to ASCII.  For example, an &quot;o&quot; with a
German umlaut over it becomes &quot;o&quot;, and the Spanish character &quot;enye&quot; becomes
&quot;n&quot;.
</p>
<p>This function takes and returns a data.frame, for ease of piping with
<code>`%&gt;%`</code>. For the underlying function that works on a character vector
of names, see <code><a href="#topic+make_clean_names">make_clean_names</a></code>.  <code>clean_names</code> 
relies on the versatile function <code><a href="snakecase.html#topic+to_any_case">to_any_case</a></code>, which 
accepts many arguments.  See that function's documentation for ideas on getting 
the most out of <code>clean_names</code>.  A few examples are included below.
</p>
<p>A common issue is that the micro/mu symbol is replaced by &quot;m&quot; instead of &quot;u&quot;.
The replacement with &quot;m&quot; is more correct when doing Greek-to-ASCII
transliteration but less correct when doing scientific data-to-ASCII
transliteration.  A warning will be generated if the &quot;m&quot; replacement occurs.
To replace with &quot;u&quot;, please add the argument <code>replace=janitor:::mu_to_u</code>
which is a character vector mapping all known mu or micro Unicode code points
(characters) to &quot;u&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_names(dat, ...)

## Default S3 method:
clean_names(dat, ...)

## S3 method for class 'sf'
clean_names(dat, ...)

## S3 method for class 'tbl_graph'
clean_names(dat, ...)

## S3 method for class 'tbl_lazy'
clean_names(dat, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_names_+3A_dat">dat</code></td>
<td>
<p>the input data.frame.</p>
</td></tr>
<tr><td><code id="clean_names_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+make_clean_names">make_clean_names</a></code>
</p>

<dl>
<dt><code>case</code></dt><dd><p>The desired target case (default is <code>"snake"</code>) will be
passed to <code>snakecase::to_any_case()</code> with the exception of &quot;old_janitor&quot;,
which exists only to support legacy code (it preserves the behavior of
<code>clean_names()</code> prior to addition of the &quot;case&quot; argument (janitor
versions &lt;= 0.3.1).  &quot;old_janitor&quot; is not intended for new code. See
<code><a href="snakecase.html#topic+to_any_case">to_any_case</a></code> for a wide variety of supported cases,
including &quot;sentence&quot; and &quot;title&quot; case.</p>
</dd>
<dt><code>replace</code></dt><dd><p>A named character vector where the name is replaced by the
value.</p>
</dd>
<dt><code>ascii</code></dt><dd><p>Convert the names to ASCII (<code>TRUE</code>, default) or not
(<code>FALSE</code>).</p>
</dd>
<dt><code>use_make_names</code></dt><dd><p>Should <code>make.names()</code> be applied to ensure that the
output is usable as a name without quoting?  (Avoiding <code>make.names()</code>
ensures that the output is locale-independent but quoting may be required.)</p>
</dd>
<dt><code>allow_dupes</code></dt><dd><p>Allow duplicates in the returned names (<code>TRUE</code>) or not
(<code>FALSE</code>, the default).</p>
</dd>
<dt><code>sep_in</code></dt><dd><p>(short for separator input) if character, is interpreted as a
regular expression (wrapped internally into <code>stringr::regex()</code>). 
The default value is a regular expression that matches any sequence of
non-alphanumeric values. All matches will be replaced by underscores 
(additionally to <code>"_"</code> and <code>" "</code>, for which this is always true, even
if <code>NULL</code> is supplied). These underscores are used internally to split
the strings into substrings and specify the word boundaries.</p>
</dd>
<dt><code>parsing_option</code></dt><dd><p>An integer that will determine the parsing_option.
</p>

<ul>
<li><p>1: <code>"RRRStudio" -&gt; "RRR_Studio"</code>
</p>
</li>
<li><p>2: <code>"RRRStudio" -&gt; "RRRS_tudio"</code>
</p>
</li>
<li><p>3: <code>"RRRStudio" -&gt; "RRRSStudio"</code>. This will become for example <code>"Rrrstudio"</code> when we convert to lower camel case.
</p>
</li>
<li><p>-1, -2, -3: These <code>parsing_options</code>'s will suppress the conversion after non-alphanumeric values.
</p>
</li>
<li><p>0: no parsing
</p>
</li></ul>
</dd>
<dt><code>transliterations</code></dt><dd><p>A character vector (if not <code>NULL</code>). The entries of this argument
need to be elements of <code>stringi::stri_trans_list()</code> (like &quot;Latin-ASCII&quot;, which is often useful) or names of lookup tables (currently only &quot;german&quot; is supported). In the order of the entries the letters of the input
string will be transliterated via <code>stringi::stri_trans_general()</code> or replaced via the 
matches of the lookup table. When named character elements are supplied as part of 'transliterations', anything that matches the names is replaced by the corresponding value.
You should use this feature with care in case of <code>case = "parsed"</code>, <code>case = "internal_parsing"</code> and 
<code>case = "none"</code>, since for upper case letters, which have transliterations/replacements
of length 2, the second letter will be transliterated to lowercase, for example Oe, Ae, Ss, which
might not always be what is intended. In this case you can make usage of the option to supply named elements and specify the transliterations yourself.</p>
</dd>
<dt><code>numerals</code></dt><dd><p>A character specifying the alignment of numerals (<code>"middle"</code>, <code>left</code>, <code>right</code>, <code>asis</code> or <code>tight</code>). I.e. <code>numerals = "left"</code> ensures that no output separator is in front of a digit.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clean_names()</code> is intended to be used on <code>data.frames</code>
and <code>data.frame</code>-like objects. For this reason there are methods to
support using <code>clean_names()</code> on <code>sf</code> and <code>tbl_graph</code> (from
<code>tidygraph</code>) objects as well as on database connections through
<code>dbplyr</code>. For cleaning other named objects like named lists 
and vectors, use <code>make_clean_names()</code>.
</p>


<h3>Value</h3>

<p>Returns the data.frame with clean names.
</p>


<h3>See Also</h3>

<p>Other Set names: 
<code><a href="#topic+find_header">find_header</a>()</code>,
<code><a href="#topic+mu_to_u">mu_to_u</a></code>,
<code><a href="#topic+row_to_names">row_to_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- Simple Usage ---
x &lt;- data.frame(caseID = 1, DOB = 2, Other = 3)
clean_names(x)

# or pipe in the input data.frame:
x %&gt;%
  clean_names()

# if you prefer camelCase variable names:
x %&gt;%
  clean_names(., "lower_camel")

# (not run) run clean_names after reading in a spreadsheet:
# library(readxl)
# read_excel("messy_excel_file.xlsx") %&gt;%
#   clean_names()

# --- Taking advantage of the underlying snakecase::to_any_case arguments ---

# Restore column names to Title Case, e.g., for plotting
mtcars %&gt;%
  clean_names(case = "title")
  
# Tell clean_names to leave certain abbreviations untouched:
x %&gt;%
  clean_names(case = "upper_camel", abbreviations = c("ID", "DOB")) 
  
</code></pre>

<hr>
<h2 id='compare_df_cols'>Generate a comparison of data.frames (or similar objects) that indicates if
they will successfully bind together by rows.</h2><span id='topic+compare_df_cols'></span>

<h3>Description</h3>

<p>Generate a comparison of data.frames (or similar objects) that indicates if
they will successfully bind together by rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_df_cols(
  ...,
  return = c("all", "match", "mismatch"),
  bind_method = c("bind_rows", "rbind"),
  strict_description = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_df_cols_+3A_...">...</code></td>
<td>
<p>A combination of data.frames, tibbles, and lists of
data.frames/tibbles.  The values may optionally be named arguments; if
named, the output column will be the name; if not named, the output column
will be the data.frame name (see examples section).</p>
</td></tr>
<tr><td><code id="compare_df_cols_+3A_return">return</code></td>
<td>
<p>Should a summary of &quot;all&quot; columns be returned, only return
&quot;match&quot;ing columns, or only &quot;mismatch&quot;ing columns?</p>
</td></tr>
<tr><td><code id="compare_df_cols_+3A_bind_method">bind_method</code></td>
<td>
<p>What method of binding should be used to determine
matches? With &quot;bind_rows&quot;, columns missing from a data.frame would be
considered a match (as in <code>dplyr::bind_rows()</code>; with &quot;rbind&quot;, columns
missing from a data.frame would be considered a mismatch (as in
<code>base::rbind()</code>.</p>
</td></tr>
<tr><td><code id="compare_df_cols_+3A_strict_description">strict_description</code></td>
<td>
<p>Passed to <code>describe_class</code>.  Also, see the
Details section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to the returned &quot;column_name&quot; column, no input data.frame may be
named &quot;column_name&quot;.
</p>
<p>The <code>strict_description</code> argument is most typically used to understand
if factor levels match or are bindable.  Factors are typically bindable,
but the behavior of what happens when they bind differs based on the
binding method (&quot;bind_rows&quot; or &quot;rbind&quot;).  Even when
<code>strict_description</code> is <code>FALSE</code>, data.frames may still bind
because some classes (like factors and characters) can bind even if they
appear to differ.
</p>


<h3>Value</h3>

<p>A data.frame with a column named &quot;column_name&quot; with a value named
after the input data.frames' column names, and then one column per
data.frame (named after the input data.frame).  If more than one input has
the same column name, the column naming will have suffixes defined by
sequential use of <code>base::merge()</code> and may differ from expected naming.
The rows within the data.frame-named columns are descriptions of the
classes of the data within the columns (generated by
<code>describe_class</code>).
</p>


<h3>See Also</h3>

<p>Other Data frame type comparison: 
<code><a href="#topic+compare_df_cols_same">compare_df_cols_same</a>()</code>,
<code><a href="#topic+describe_class">describe_class</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compare_df_cols(data.frame(A=1), data.frame(B=2))
# user-defined names
compare_df_cols(dfA=data.frame(A=1), dfB=data.frame(B=2))
# a combination of list and data.frame input
compare_df_cols(listA=list(dfA=data.frame(A=1), dfB=data.frame(B=2)), data.frame(A=3))
</code></pre>

<hr>
<h2 id='compare_df_cols_same'>Do the the data.frames have the same columns &amp; types?</h2><span id='topic+compare_df_cols_same'></span>

<h3>Description</h3>

<p>Check whether a set of data.frames are row-bindable.  Calls
<code>compare_df_cols()</code>and returns TRUE if there are no mis-matching rows.  '
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_df_cols_same(
  ...,
  bind_method = c("bind_rows", "rbind"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_df_cols_same_+3A_...">...</code></td>
<td>
<p>A combination of data.frames, tibbles, and lists of
data.frames/tibbles.  The values may optionally be named arguments; if
named, the output column will be the name; if not named, the output column
will be the data.frame name (see examples section).</p>
</td></tr>
<tr><td><code id="compare_df_cols_same_+3A_bind_method">bind_method</code></td>
<td>
<p>What method of binding should be used to determine
matches? With &quot;bind_rows&quot;, columns missing from a data.frame would be
considered a match (as in <code>dplyr::bind_rows()</code>; with &quot;rbind&quot;, columns
missing from a data.frame would be considered a mismatch (as in
<code>base::rbind()</code>.</p>
</td></tr>
<tr><td><code id="compare_df_cols_same_+3A_verbose">verbose</code></td>
<td>
<p>Print the mismatching columns if binding will fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if row binding will succeed or <code>FALSE</code> if it will
fail.
</p>


<h3>See Also</h3>

<p>Other Data frame type comparison: 
<code><a href="#topic+compare_df_cols">compare_df_cols</a>()</code>,
<code><a href="#topic+describe_class">describe_class</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compare_df_cols_same(data.frame(A=1), data.frame(A=2))
compare_df_cols_same(data.frame(A=1), data.frame(B=2))
compare_df_cols_same(data.frame(A=1), data.frame(B=2), verbose=FALSE)
compare_df_cols_same(data.frame(A=1), data.frame(B=2), bind_method="rbind")
</code></pre>

<hr>
<h2 id='convert_to_date'>Convert many date and datetime formats as may be received from Microsoft
Excel</h2><span id='topic+convert_to_date'></span><span id='topic+convert_to_datetime'></span>

<h3>Description</h3>

<p>Convert many date and datetime formats as may be received from Microsoft
Excel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_date(
  x,
  ...,
  character_fun = lubridate::ymd,
  string_conversion_failure = c("error", "warning")
)

convert_to_datetime(
  x,
  ...,
  tz = "UTC",
  character_fun = lubridate::ymd_hms,
  string_conversion_failure = c("error", "warning")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_date_+3A_x">x</code></td>
<td>
<p>The object to convert</p>
</td></tr>
<tr><td><code id="convert_to_date_+3A_...">...</code></td>
<td>
<p>Passed to further methods.  Eventually may be passed to
'excel_numeric_to_date()', 'base::as.POSIXct()', or 'base::as.Date()'.</p>
</td></tr>
<tr><td><code id="convert_to_date_+3A_character_fun">character_fun</code></td>
<td>
<p>A function to convert non-numeric-looking, non-NA values
in 'x' to POSIXct objects.</p>
</td></tr>
<tr><td><code id="convert_to_date_+3A_string_conversion_failure">string_conversion_failure</code></td>
<td>
<p>If a character value fails to parse into the
desired class and instead returns 'NA', should the function return the
result with a warning or throw an error?</p>
</td></tr>
<tr><td><code id="convert_to_date_+3A_tz">tz</code></td>
<td>
<p>The timezone for POSIXct output, unless an object is POSIXt
already.  Ignored for Date output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Character conversion checks if it matches something that looks like
a Microsoft Excel numeric date, converts those to numeric, and then runs
convert_to_datetime_helper() on those numbers.  Then, character to Date or
POSIXct conversion occurs via 'character_fun(x, ...)' or
'character_fun(x, tz=tz, ...)', respectively.
</p>


<h3>Value</h3>

<p>POSIXct objects for 'convert_to_datetime()' or Date objects for
'convert_to_date()'.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>convert_to_datetime()</code>: Convert to a date-time (POSIXct)
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Date-time cleaning: 
<code><a href="#topic+excel_numeric_to_date">excel_numeric_to_date</a>()</code>,
<code><a href="#topic+sas_numeric_to_date">sas_numeric_to_date</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convert_to_date("2009-07-06")
convert_to_date(40000)
convert_to_date("40000.1")
# Mixed date source data can be provided.
convert_to_date(c("2020-02-29", "40000.1"))
convert_to_datetime(
  c("2009-07-06", "40000.1", "40000", NA),
  character_fun=lubridate::ymd_h, truncated=1, tz="UTC"
)
</code></pre>

<hr>
<h2 id='convert_to_NA'>Convert string values to true <code>NA</code> values.</h2><span id='topic+convert_to_NA'></span>

<h3>Description</h3>

<p>Converts instances of user-specified strings into <code>NA</code>.  Can operate on either a single vector or an entire data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_NA(dat, strings)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_NA_+3A_dat">dat</code></td>
<td>
<p>vector or data.frame to operate on.</p>
</td></tr>
<tr><td><code id="convert_to_NA_+3A_strings">strings</code></td>
<td>
<p>character vector of strings to convert.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a cleaned object.  Can be a vector, data.frame, or <code>tibble::tbl_df</code> depending on the provided input.
</p>


<h3>Warning</h3>

<p>Deprecated, do not use in new code. Use <code>dplyr::na_if()</code> instead.
</p>


<h3>See Also</h3>

<p>janitor_deprecated
</p>

<hr>
<h2 id='crosstab'>Generate a crosstabulation of two vectors.</h2><span id='topic+crosstab'></span>

<h3>Description</h3>

<p>This function is deprecated, use <code>tabyl(dat, var1, var2)</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosstab(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crosstab_+3A_...">...</code></td>
<td>
<p>arguments</p>
</td></tr>
</table>

<hr>
<h2 id='describe_class'>Describe the class(es) of an object</h2><span id='topic+describe_class'></span><span id='topic+describe_class.factor'></span><span id='topic+describe_class.default'></span>

<h3>Description</h3>

<p>Describe the class(es) of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe_class(x, strict_description = TRUE)

## S3 method for class 'factor'
describe_class(x, strict_description = TRUE)

## Default S3 method:
describe_class(x, strict_description = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="describe_class_+3A_x">x</code></td>
<td>
<p>The object to describe</p>
</td></tr>
<tr><td><code id="describe_class_+3A_strict_description">strict_description</code></td>
<td>
<p>Should differing factor levels be treated 
as differences for the purposes of identifying mismatches? 
<code>strict_description = `TRUE`</code> is stricter and factors with different 
levels will be treated as different classes.  <code>FALSE</code> is more 
lenient: for class comparison purposes, the variable is just a &quot;factor&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For package developers, an S3 generic method can be written for
<code>describe_class()</code> for custom classes that may need more definition
than the default method.  This function is called by <code>compare_df_cols</code>.
</p>


<h3>Value</h3>

<p>A character scalar describing the class(es) of an object where if the
scalar will match, columns in a data.frame (or similar object) should bind
together without issue.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>describe_class(factor)</code>: Describe factors with their levels
and if they are ordered.
</p>
</li>
<li> <p><code>describe_class(default)</code>: List all classes of an object.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Data frame type comparison: 
<code><a href="#topic+compare_df_cols_same">compare_df_cols_same</a>()</code>,
<code><a href="#topic+compare_df_cols">compare_df_cols</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>describe_class(1)
describe_class(factor("A"))
describe_class(ordered(c("A", "B")))
describe_class(ordered(c("A", "B")), strict_description=FALSE)
</code></pre>

<hr>
<h2 id='excel_numeric_to_date'>Convert dates encoded as serial numbers to Date class.</h2><span id='topic+excel_numeric_to_date'></span>

<h3>Description</h3>

<p>Converts numbers like <code>42370</code> into date values like
<code>2016-01-01</code>.
</p>
<p>Defaults to the modern Excel date encoding system. However, Excel for Mac
2008 and earlier Mac versions of Excel used a different date system. To
determine what platform to specify: if the date 2016-01-01 is represented by
the number 42370 in your spreadsheet, it's the modern system.  If it's 40908,
it's the old Mac system. More on date encoding systems at
http://support.office.com/en-us/article/Date-calculations-in-Excel-e7fe7167-48a9-4b96-bb53-5612a800b487.
</p>
<p>A list of all timezones is available from <code>base::OlsonNames()</code>, and the
current timezone is available from <code>base::Sys.timezone()</code>.
</p>
<p>If your input data has a mix of Excel numeric dates and actual dates, see the
more powerful functions <code>convert_to_date()</code> and <code>convert_to_datetime()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excel_numeric_to_date(
  date_num,
  date_system = "modern",
  include_time = FALSE,
  round_seconds = TRUE,
  tz = Sys.timezone()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="excel_numeric_to_date_+3A_date_num">date_num</code></td>
<td>
<p>numeric vector of serial numbers to convert.</p>
</td></tr>
<tr><td><code id="excel_numeric_to_date_+3A_date_system">date_system</code></td>
<td>
<p>the date system, either <code>"modern"</code> or <code>"mac
pre-2011"</code>.</p>
</td></tr>
<tr><td><code id="excel_numeric_to_date_+3A_include_time">include_time</code></td>
<td>
<p>Include the time (hours, minutes, seconds) in the output?
(See details)</p>
</td></tr>
<tr><td><code id="excel_numeric_to_date_+3A_round_seconds">round_seconds</code></td>
<td>
<p>Round the seconds to an integer (only has an effect when
<code>include_time</code> is <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="excel_numeric_to_date_+3A_tz">tz</code></td>
<td>
<p>Time zone, used when <code>include_time = TRUE</code> (see details for
more information on timezones).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>include_time=TRUE</code>, days with leap seconds will not
be accurately handled as they do not appear to be accurately handled by
Windows (as described in
https://support.microsoft.com/en-us/help/2722715/support-for-the-leap-second).
</p>


<h3>Value</h3>

<p>Returns a vector of class Date if <code>include_time</code> is
<code>FALSE</code>.  Returns a vector of class POSIXlt if <code>include_time</code> is
<code>TRUE</code>.
</p>


<h3>See Also</h3>

<p>Other Date-time cleaning: 
<code><a href="#topic+convert_to_date">convert_to_date</a>()</code>,
<code><a href="#topic+sas_numeric_to_date">sas_numeric_to_date</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>excel_numeric_to_date(40000)
excel_numeric_to_date(40000.5) # No time is included
excel_numeric_to_date(40000.5, include_time = TRUE) # Time is included
excel_numeric_to_date(40000.521, include_time = TRUE) # Time is included
excel_numeric_to_date(40000.521, include_time = TRUE,
  round_seconds = FALSE) # Time with fractional seconds is included
</code></pre>

<hr>
<h2 id='find_header'>Find the header row in a data.frame</h2><span id='topic+find_header'></span>

<h3>Description</h3>

<p>Find the header row in a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_header(dat, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_header_+3A_dat">dat</code></td>
<td>
<p>The input data.frame</p>
</td></tr>
<tr><td><code id="find_header_+3A_...">...</code></td>
<td>
<p>See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>...</code> is missing, then the first row with no missing values is used.
</p>
<p>When searching for a specified value or value within a column, the first row
with a match will be returned, regardless of the completeness of the rest of
that row.  If <code>...</code> has a single character argument, then the first
column is searched for that value.  If <code>...</code> has a named numeric
argument, then the column whose position number matches the value of that
argument is searched for the name (see the last example below).  If more than one
row is found matching a value that is searched for, the number of the first
matching row will be returned (with a warning).
</p>


<h3>Value</h3>

<p>The row number for the header row
</p>


<h3>See Also</h3>

<p>Other Set names: 
<code><a href="#topic+clean_names">clean_names</a>()</code>,
<code><a href="#topic+mu_to_u">mu_to_u</a></code>,
<code><a href="#topic+row_to_names">row_to_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the first row
find_header(data.frame(A="B"))
# the second row
find_header(data.frame(A=c(NA, "B")))
# the second row since the first has an empty value
find_header(data.frame(A=c(NA, "B"), B=c("C", "D")))
# The third row because the second column was searched for the text "E"
find_header(data.frame(A=c(NA, "B", "C", "D"), B=c("C", "D", "E", "F")), "E"=2)
</code></pre>

<hr>
<h2 id='fisher.test'>Apply stats::fisher.test to a two-way tabyl</h2><span id='topic+fisher.test'></span><span id='topic+fisher.test.default'></span><span id='topic+fisher.test.tabyl'></span>

<h3>Description</h3>

<p>This generic function overrides stats::fisher.test. If the passed table 
is a two-way tabyl, it runs it through janitor::fisher.test.tabyl, otherwise
it just calls stats::fisher.test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher.test(x, ...)

## Default S3 method:
fisher.test(x, y = NULL, ...)

## S3 method for class 'tabyl'
fisher.test(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisher.test_+3A_x">x</code></td>
<td>
<p>a two-way tabyl, a numeric vector or a factor</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_...">...</code></td>
<td>
<p>other parameters passed to stats::fisher.test</p>
</td></tr>
<tr><td><code id="fisher.test_+3A_y">y</code></td>
<td>
<p>if x is a vector, must be another vector or factor of the same length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is the same as the one of stats::fisher.test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- tabyl(mtcars, gear, cyl)
fisher.test(tab)

</code></pre>

<hr>
<h2 id='get_dupes'>Get rows of a <code>data.frame</code> with identical values for the specified variables.</h2><span id='topic+get_dupes'></span>

<h3>Description</h3>

<p>For hunting duplicate records during data cleaning.  Specify the data.frame and the variable combination to search for duplicates and get back the duplicated rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dupes(dat, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dupes_+3A_dat">dat</code></td>
<td>
<p>The input data.frame.</p>
</td></tr>
<tr><td><code id="get_dupes_+3A_...">...</code></td>
<td>
<p>Unquoted variable names to search for duplicates. This takes a tidyselect specification.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with the full records where the specified variables have duplicated values, as well as a variable <code>dupe_count</code> showing the number of rows sharing that combination of duplicated values. If the input data.frame was of class <code>tbl_df</code>, the output is as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_dupes(mtcars, mpg, hp)

# or called with the magrittr pipe %&gt;% :
mtcars %&gt;% get_dupes(wt)

# You can use tidyselect helpers to specify variables:
mtcars %&gt;% get_dupes(-c(wt, qsec))
mtcars %&gt;% get_dupes(starts_with("cy"))
</code></pre>

<hr>
<h2 id='get_one_to_one'>Find the list of columns that have a 1:1 mapping to each other</h2><span id='topic+get_one_to_one'></span>

<h3>Description</h3>

<p>Find the list of columns that have a 1:1 mapping to each other
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_one_to_one(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_one_to_one_+3A_dat">dat</code></td>
<td>
<p>A data.frame or similar object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one element for each group of columns that map
identically to each other.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- data.frame(
  Lab_Test_Long=c("Cholesterol, LDL", "Cholesterol, LDL", "Glucose"),
  Lab_Test_Short=c("CLDL", "CLDL", "GLUC"),
  LOINC=c(12345, 12345, 54321),
  Person=c("Sam", "Bill", "Sam"),
  stringsAsFactors=FALSE
)
get_one_to_one(foo)
</code></pre>

<hr>
<h2 id='janitor'>janitor</h2><span id='topic+janitor'></span>

<h3>Description</h3>

<p>janitor has simple little tools for examining and cleaning dirty data.
</p>


<h3>Main functions</h3>

<p>The main janitor functions can: perfectly format ugly <code>data.frame</code> column names; isolate
duplicate records for further study; and provide quick one- and two-variable tabulations
(i.e., frequency tables and crosstabs) that improve on the base R function <code>table()</code>.
</p>
<p>Other functions in the package can format for reporting the results of these tabulations.
These tabulate-and-report functions approximate popular features of SPSS and Microsoft Excel.
</p>


<h3>Package context</h3>

<p>This package follows the principles of the &quot;tidyverse&quot; and in particular works well with
the <code>%&gt;%</code> pipe function.
</p>
<p>janitor was built with beginning-to-intermediate R users in mind
and is optimized for user-friendliness.  Advanced users can already do everything
covered here, but they can do it faster with janitor and save their thinking for
more fun tasks.
</p>

<hr>
<h2 id='janitor_deprecated'>Deprecated Functions in Package janitor</h2><span id='topic+janitor_deprecated'></span>

<h3>Description</h3>

<p>These functions have already become defunct or may be defunct as soon as the next release.
</p>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+adorn_crosstab">adorn_crosstab</a></code>
</p>
</li>
<li> <p><code><a href="#topic+crosstab">crosstab</a></code>
</p>
</li>
<li> <p><code><a href="#topic+use_first_valid_of">use_first_valid_of</a></code>
</p>
</li>
<li> <p><code><a href="#topic+convert_to_NA">convert_to_NA</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_totals_col">add_totals_col</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_totals_row">add_totals_row</a></code>
</p>
</li>
<li> <p><code><a href="#topic+remove_empty_rows">remove_empty_rows</a></code>
</p>
</li>
<li> <p><code><a href="#topic+remove_empty_cols">remove_empty_cols</a></code>
</p>
</li></ul>


<hr>
<h2 id='make_clean_names'>Cleans a vector of text, typically containing the names of an object.</h2><span id='topic+make_clean_names'></span>

<h3>Description</h3>

<p>Resulting strings are unique and consist only of the <code>_</code>
character, numbers, and letters. By default, the resulting strings will only
consist of ASCII characters, but non-ASCII (e.g. Unicode) may be allowed by
setting <code>ascii=FALSE</code>.  Capitalization preferences can be specified
using the <code>case</code> parameter.
</p>
<p>For use on the names of a data.frame, e.g., in a <code>`%&gt;%`</code> pipeline,
call the convenience function <code><a href="#topic+clean_names">clean_names</a></code>.
</p>
<p>When <code>ascii=TRUE</code> (the default), accented characters are transliterated
to ASCII.  For example, an &quot;o&quot; with a German umlaut over it becomes &quot;o&quot;, and
the Spanish character &quot;enye&quot; becomes &quot;n&quot;.
</p>
<p>The order of operations is: make replacements, (optional) ASCII conversion,
remove initial spaces and punctuation, apply <code>base::make.names()</code>,
apply <code>snakecase::to_any_case</code>, and add numeric suffixes 
to resolve any duplicated names.
</p>
<p>This function relies on <code>snakecase::to_any_case</code> and can take advantage of 
its versatility.  For instance, an abbreviation like &quot;ID&quot; can have its 
capitalization preserved by passing the argument <code>abbreviations = "ID"</code>. 
See the documentation for <code><a href="snakecase.html#topic+to_any_case">snakecase::to_any_case</a></code> 
for more about how to use its features.
</p>
<p>On some systems, not all transliterators to ASCII are available.  If this is
the case on your system, all available transliterators will be used, and a
warning will be issued once per session indicating that results may be
different when run on a different system.  That warning can be disabled with
<code>options(janitor_warn_transliterators=FALSE)</code>.
</p>
<p>If the objective of your call to <code>make_clean_names()</code> is only to translate to
ASCII, try the following instead:
<code>stringi::stri_trans_general(x, id="Any-Latin;Greek-Latin;Latin-ASCII")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_clean_names(
  string,
  case = "snake",
  replace = c(`'` = "", `"` = "", `%` = "_percent_", `#` = "_number_"),
  ascii = TRUE,
  use_make_names = TRUE,
  allow_dupes = FALSE,
  sep_in = "\\.",
  transliterations = "Latin-ASCII",
  parsing_option = 1,
  numerals = "asis",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_clean_names_+3A_string">string</code></td>
<td>
<p>A character vector of names to clean.</p>
</td></tr>
<tr><td><code id="make_clean_names_+3A_case">case</code></td>
<td>
<p>The desired target case (default is <code>"snake"</code>) will be
passed to <code>snakecase::to_any_case()</code> with the exception of &quot;old_janitor&quot;,
which exists only to support legacy code (it preserves the behavior of
<code>clean_names()</code> prior to addition of the &quot;case&quot; argument (janitor
versions &lt;= 0.3.1).  &quot;old_janitor&quot; is not intended for new code. See
<code><a href="snakecase.html#topic+to_any_case">to_any_case</a></code> for a wide variety of supported cases,
including &quot;sentence&quot; and &quot;title&quot; case.</p>
</td></tr>
<tr><td><code id="make_clean_names_+3A_replace">replace</code></td>
<td>
<p>A named character vector where the name is replaced by the
value.</p>
</td></tr>
<tr><td><code id="make_clean_names_+3A_ascii">ascii</code></td>
<td>
<p>Convert the names to ASCII (<code>TRUE</code>, default) or not
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="make_clean_names_+3A_use_make_names">use_make_names</code></td>
<td>
<p>Should <code>make.names()</code> be applied to ensure that the
output is usable as a name without quoting?  (Avoiding <code>make.names()</code>
ensures that the output is locale-independent but quoting may be required.)</p>
</td></tr>
<tr><td><code id="make_clean_names_+3A_allow_dupes">allow_dupes</code></td>
<td>
<p>Allow duplicates in the returned names (<code>TRUE</code>) or not
(<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="make_clean_names_+3A_sep_in">sep_in</code></td>
<td>
<p>(short for separator input) if character, is interpreted as a
regular expression (wrapped internally into <code>stringr::regex()</code>). 
The default value is a regular expression that matches any sequence of
non-alphanumeric values. All matches will be replaced by underscores 
(additionally to <code>"_"</code> and <code>" "</code>, for which this is always true, even
if <code>NULL</code> is supplied). These underscores are used internally to split
the strings into substrings and specify the word boundaries.</p>
</td></tr>
<tr><td><code id="make_clean_names_+3A_transliterations">transliterations</code></td>
<td>
<p>A character vector (if not <code>NULL</code>). The entries of this argument
need to be elements of <code>stringi::stri_trans_list()</code> (like &quot;Latin-ASCII&quot;, which is often useful) or names of lookup tables (currently only &quot;german&quot; is supported). In the order of the entries the letters of the input
string will be transliterated via <code>stringi::stri_trans_general()</code> or replaced via the 
matches of the lookup table. When named character elements are supplied as part of 'transliterations', anything that matches the names is replaced by the corresponding value.
You should use this feature with care in case of <code>case = "parsed"</code>, <code>case = "internal_parsing"</code> and 
<code>case = "none"</code>, since for upper case letters, which have transliterations/replacements
of length 2, the second letter will be transliterated to lowercase, for example Oe, Ae, Ss, which
might not always be what is intended. In this case you can make usage of the option to supply named elements and specify the transliterations yourself.</p>
</td></tr>
<tr><td><code id="make_clean_names_+3A_parsing_option">parsing_option</code></td>
<td>
<p>An integer that will determine the parsing_option.
</p>

<ul>
<li><p>1: <code>"RRRStudio" -&gt; "RRR_Studio"</code>
</p>
</li>
<li><p>2: <code>"RRRStudio" -&gt; "RRRS_tudio"</code>
</p>
</li>
<li><p>3: <code>"RRRStudio" -&gt; "RRRSStudio"</code>. This will become for example <code>"Rrrstudio"</code> when we convert to lower camel case.
</p>
</li>
<li><p>-1, -2, -3: These <code>parsing_options</code>'s will suppress the conversion after non-alphanumeric values.
</p>
</li>
<li><p>0: no parsing
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_clean_names_+3A_numerals">numerals</code></td>
<td>
<p>A character specifying the alignment of numerals (<code>"middle"</code>, <code>left</code>, <code>right</code>, <code>asis</code> or <code>tight</code>). I.e. <code>numerals = "left"</code> ensures that no output separator is in front of a digit.</p>
</td></tr>
<tr><td><code id="make_clean_names_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="snakecase.html#topic+to_any_case">snakecase::to_any_case</a></code>
</p>

<dl>
<dt><code>abbreviations</code></dt><dd><p>character. (Case insensitive) matched abbreviations are surrounded by underscores. In this way, they can get recognized by the parser. This is useful when e.g. <code>parsing_option</code> 1 is needed for the use case, but some abbreviations but some substrings would require <code>parsing_option</code> 2. Furthermore, this argument also specifies the formatting of abbreviations in the output for the cases title, mixed, lower and upper camel. E.g. for upper camel the first letter is always in upper case, but when the abbreviation is supplied in upper case, this will also be visible in the output.
</p>
<p>Use this feature with care: One letter abbreviations and abbreviations next to each other are hard to read and also not easy to parse for further processing.</p>
</dd>
<dt><code>sep_out</code></dt><dd><p>(short for separator output) String that will be used as separator. The defaults are <code>"_"</code> 
and <code>""</code>, regarding the specified <code>case</code>. When <code>length(sep_out) &gt; 1</code>, the last element of <code>sep_out</code> gets recycled and separators are incorporated per string according to their order.</p>
</dd>
<dt><code>unique_sep</code></dt><dd><p>A string. If not <code>NULL</code>, then duplicated names will get 
a suffix integer
in the order of their appearance. The suffix is separated by the supplied string
to this argument.</p>
</dd>
<dt><code>empty_fill</code></dt><dd><p>A string. If it is supplied, then each entry that matches &quot;&quot; will be replaced
by the supplied string to this argument.</p>
</dd>
<dt><code>prefix</code></dt><dd><p>prefix (string).</p>
</dd>
<dt><code>postfix</code></dt><dd><p>postfix (string).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the &quot;cleaned&quot; character vector.
</p>


<h3>See Also</h3>

<p><code><a href="snakecase.html#topic+to_any_case">to_any_case</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# cleaning the names of a vector:
x &lt;- structure(1:3, names = c("name with space", "TwoWords", "total $ (2009)"))
x
names(x) &lt;- make_clean_names(names(x))
x # now has cleaned names

# if you prefer camelCase variable names:
make_clean_names(names(x), "small_camel")

# similar to janitor::clean_names(poorly_named_df):
# not run:
# make_clean_names(names(poorly_named_df))

</code></pre>

<hr>
<h2 id='mu_to_u'>Constant to help map from mu to u</h2><span id='topic+mu_to_u'></span>

<h3>Description</h3>

<p>This is a character vector with names of all known Unicode code points that
look like the Greek mu or the micro symbol and values of &quot;u&quot;.  This is
intended to simplify mapping from mu or micro in Unicode to the character &quot;u&quot;
with <code>clean_names()</code> and <code>make_clean_names()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_to_u
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 10.
</p>


<h3>Details</h3>

<p>See the help in <code>clean_names()</code> for how to use this.
</p>


<h3>See Also</h3>

<p>Other Set names: 
<code><a href="#topic+clean_names">clean_names</a>()</code>,
<code><a href="#topic+find_header">find_header</a>()</code>,
<code><a href="#topic+row_to_names">row_to_names</a>()</code>
</p>

<hr>
<h2 id='remove_constant'>Remove constant columns from a data.frame or matrix.</h2><span id='topic+remove_constant'></span>

<h3>Description</h3>

<p>Remove constant columns from a data.frame or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_constant(dat, na.rm = FALSE, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_constant_+3A_dat">dat</code></td>
<td>
<p>the input data.frame or matrix.</p>
</td></tr>
<tr><td><code id="remove_constant_+3A_na.rm">na.rm</code></td>
<td>
<p>should <code>NA</code> values be removed when considering whether a
column is constant?  The default value of <code>FALSE</code> will result in a
column not being removed if it's a mix of a single value and <code>NA</code>.</p>
</td></tr>
<tr><td><code id="remove_constant_+3A_quiet">quiet</code></td>
<td>
<p>Should messages be suppressed (<code>TRUE</code>) or printed
(<code>FALSE</code>) indicating the summary of empty columns or rows removed?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+remove_empty">remove_empty()</a></code> for removing empty
columns or rows.
</p>
<p>Other remove functions: 
<code><a href="#topic+remove_empty">remove_empty</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>remove_constant(data.frame(A=1, B=1:3))

# To find the columns that are constant
data.frame(A=1, B=1:3) %&gt;%
  dplyr::select_at(setdiff(names(.), names(remove_constant(.)))) %&gt;%
  unique()
</code></pre>

<hr>
<h2 id='remove_empty'>Remove empty rows and/or columns from a data.frame or matrix.</h2><span id='topic+remove_empty'></span>

<h3>Description</h3>

<p>Removes all rows and/or columns from a data.frame or matrix that
are composed entirely of <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_empty(dat, which = c("rows", "cols"), cutoff = 1, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_empty_+3A_dat">dat</code></td>
<td>
<p>the input data.frame or matrix.</p>
</td></tr>
<tr><td><code id="remove_empty_+3A_which">which</code></td>
<td>
<p>one of &quot;rows&quot;, &quot;cols&quot;, or <code>c("rows", "cols")</code>.  Where no
value of which is provided, defaults to removing both empty rows and empty
columns, declaring the behavior with a printed message.</p>
</td></tr>
<tr><td><code id="remove_empty_+3A_cutoff">cutoff</code></td>
<td>
<p>What fraction (&gt;0 to &lt;=1) of rows or columns must be empty to
be removed?</p>
</td></tr>
<tr><td><code id="remove_empty_+3A_quiet">quiet</code></td>
<td>
<p>Should messages be suppressed (<code>TRUE</code>) or printed
(<code>FALSE</code>) indicating the summary of empty columns or rows removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the object without its missing rows or columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remove_constant">remove_constant()</a></code> for removing
constant columns.
</p>
<p>Other remove functions: 
<code><a href="#topic+remove_constant">remove_constant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run:
# dat %&gt;% remove_empty("rows")
# addressing a common untidy-data scenario where we have a mixture of
# blank values in some (character) columns and NAs in others:
library(dplyr)
dd &lt;- tibble(x=c(LETTERS[1:5],NA,rep("",2)),
             y=c(1:5,rep(NA,3)))
# remove_empty() drops row 5 (all NA) but not 6 and 7 (blanks + NAs)
dd %&gt;% remove_empty("rows")
# solution: preprocess to convert whitespace/empty strings to NA,
# _then_ remove empty (all-NA) rows
dd %&gt;% mutate(across(is.character,~na_if(trimws(.),""))) %&gt;%
   remove_empty("rows")
</code></pre>

<hr>
<h2 id='remove_empty_cols'>Removes empty columns from a data.frame.</h2><span id='topic+remove_empty_cols'></span>

<h3>Description</h3>

<p>This function is deprecated, use <code>remove_empty("cols")</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_empty_cols(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_empty_cols_+3A_dat">dat</code></td>
<td>
<p>the input data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the data.frame with no empty columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run:
# dat %&gt;% remove_empty_cols
</code></pre>

<hr>
<h2 id='remove_empty_rows'>Removes empty rows from a data.frame.</h2><span id='topic+remove_empty_rows'></span>

<h3>Description</h3>

<p>This function is deprecated, use <code>remove_empty("rows")</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_empty_rows(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_empty_rows_+3A_dat">dat</code></td>
<td>
<p>the input data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the data.frame with no empty rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run:
# dat %&gt;% remove_empty_rows
</code></pre>

<hr>
<h2 id='round_half_up'>Round a numeric vector; halves will be rounded up, ala Microsoft Excel.</h2><span id='topic+round_half_up'></span>

<h3>Description</h3>

<p>In base R <code>round()</code>, halves are rounded to even, e.g., 12.5 and 11.5 are both rounded to 12.  This function rounds 12.5 to 13 (assuming <code>digits = 0</code>).  Negative halves are rounded away from zero, e.g., -0.5 is rounded to -1.
</p>
<p>This may skew subsequent statistical analysis of the data, but may be desirable in certain contexts.  This function is implemented exactly from <a href="https://stackoverflow.com/a/12688836">https://stackoverflow.com/a/12688836</a>; see that question and comments for discussion of this issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_half_up(x, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="round_half_up_+3A_x">x</code></td>
<td>
<p>a numeric vector to round.</p>
</td></tr>
<tr><td><code id="round_half_up_+3A_digits">digits</code></td>
<td>
<p>how many digits should be displayed after the decimal point?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>round_half_up(12.5)
round_half_up(1.125, 2)
round_half_up(1.125, 1)
round_half_up(-0.5, 0) # negatives get rounded away from zero

</code></pre>

<hr>
<h2 id='round_to_fraction'>Round to the nearest fraction of a specified denominator.</h2><span id='topic+round_to_fraction'></span>

<h3>Description</h3>

<p>Round a decimal to the precise decimal value of a specified
fractional denominator.  Common use cases include addressing floating point
imprecision and enforcing that data values fall into a certain set.
</p>
<p>E.g., if a decimal represents hours and values should be logged to the nearest 
minute, <code>round_to_fraction(x, 60)</code> would enforce that distribution and 0.57 
would be rounded to 0.566667, the equivalent of 34/60.  0.56 would also be rounded 
to 34/60.
</p>
<p>Set <code>denominator = 1</code> to round to whole numbers.
</p>
<p>The <code>digits</code> argument allows for rounding of the subsequent result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_to_fraction(x, denominator, digits = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="round_to_fraction_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="round_to_fraction_+3A_denominator">denominator</code></td>
<td>
<p>The denominator of the fraction for rounding (a scalar or
vector positive integer).</p>
</td></tr>
<tr><td><code id="round_to_fraction_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used 
after rounding to the fraction.  This is passed to <code>base::round()</code>). 
Negative values are allowed (see Details). (<code>Inf</code> indicates no
subsequent rounding)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>digits</code> is <code>Inf</code>, <code>x</code> is rounded to the fraction
and then kept at full precision.  If <code>digits</code> is <code>"auto"</code>, the
number of digits is automatically selected as
<code>ceiling(log10(denominator)) + 1</code>.
</p>


<h3>Value</h3>

<p>the input x rounded to a decimal value that has an integer numerator relative
to <code>denominator</code> (possibly subsequently rounded to a number of decimal
digits).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>round_to_fraction(1.6, denominator = 2)
round_to_fraction(pi, denominator = 7) # 22/7
round_to_fraction(c(8.1, 9.2), denominator = c(7, 8))
round_to_fraction(c(8.1, 9.2), denominator = c(7, 8), digits = 3)
round_to_fraction(c(8.1, 9.2, 10.3), denominator = c(7, 8, 1001), digits = "auto")
</code></pre>

<hr>
<h2 id='row_to_names'>Elevate a row to be the column names of a data.frame.</h2><span id='topic+row_to_names'></span>

<h3>Description</h3>

<p>Elevate a row to be the column names of a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_to_names(dat, row_number, ..., remove_row = TRUE, remove_rows_above = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="row_to_names_+3A_dat">dat</code></td>
<td>
<p>The input data.frame</p>
</td></tr>
<tr><td><code id="row_to_names_+3A_row_number">row_number</code></td>
<td>
<p>The row of <code>dat</code> containing the variable names or the
string <code>"find_header"</code> to use <code>find_header(dat=dat, ...)</code> to find
the row_number.</p>
</td></tr>
<tr><td><code id="row_to_names_+3A_...">...</code></td>
<td>
<p>Sent to <code>find_header()</code>, if
<code>row_number = "find_header"</code>.  Otherwise, ignored.</p>
</td></tr>
<tr><td><code id="row_to_names_+3A_remove_row">remove_row</code></td>
<td>
<p>Should the row <code>row_number</code> be removed from the
resulting data.frame?</p>
</td></tr>
<tr><td><code id="row_to_names_+3A_remove_rows_above">remove_rows_above</code></td>
<td>
<p>If <code>row_number != 1</code>, should the rows above
<code>row_number</code> - that is, between <code>1:(row_number-1)</code> - be removed
from the resulting data.frame?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with new names (and some rows removed, if specified)
</p>


<h3>See Also</h3>

<p>Other Set names: 
<code><a href="#topic+clean_names">clean_names</a>()</code>,
<code><a href="#topic+find_header">find_header</a>()</code>,
<code><a href="#topic+mu_to_u">mu_to_u</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(X_1 = c(NA, "Title", 1:3),
                X_2 = c(NA, "Title2", 4:6))
x %&gt;%
  row_to_names(row_number = 2)

x %&gt;%
  row_to_names(row_number = "find_header")
</code></pre>

<hr>
<h2 id='sas_numeric_to_date'>Convert a SAS date, time or date/time to an R object</h2><span id='topic+sas_numeric_to_date'></span>

<h3>Description</h3>

<p>Convert a SAS date, time or date/time to an R object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sas_numeric_to_date(date_num, datetime_num, time_num, tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sas_numeric_to_date_+3A_date_num">date_num</code></td>
<td>
<p>numeric vector of serial numbers to convert.</p>
</td></tr>
<tr><td><code id="sas_numeric_to_date_+3A_datetime_num">datetime_num</code></td>
<td>
<p>numeric vector of date/time numbers (seconds since
midnight 1960-01-01) to convert</p>
</td></tr>
<tr><td><code id="sas_numeric_to_date_+3A_time_num">time_num</code></td>
<td>
<p>numeric vector of time numbers (seconds since midnight on the
current day) to convert</p>
</td></tr>
<tr><td><code id="sas_numeric_to_date_+3A_tz">tz</code></td>
<td>
<p>Time zone, used when <code>include_time = TRUE</code> (see details for
more information on timezones).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a date and time or datetime are provided, a POSIXct object.  If a
date is provided, a Date object.  If a time is provided, an hms::hms object
</p>


<h3>References</h3>

<p>SAS Date, Time, and Datetime Values reference (retrieved on
2022-03-08): https://v8doc.sas.com/sashtml/lrcon/zenid-63.htm
</p>


<h3>See Also</h3>

<p>Other Date-time cleaning: 
<code><a href="#topic+convert_to_date">convert_to_date</a>()</code>,
<code><a href="#topic+excel_numeric_to_date">excel_numeric_to_date</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sas_numeric_to_date(date_num=15639) # 2002-10-26
sas_numeric_to_date(datetime_num=1217083532, tz="UTC") # 1998-07-26T14:45:32Z
sas_numeric_to_date(date_num=15639, time_num=3600, tz="UTC") # 2002-10-26T01:00:00Z
sas_numeric_to_date(time_num=3600) # 01:00:00
</code></pre>

<hr>
<h2 id='signif_half_up'>Round a numeric vector to the specified number of significant digits; halves will be rounded up.</h2><span id='topic+signif_half_up'></span>

<h3>Description</h3>

<p>In base R <code>signif()</code>, halves are rounded to even, e.g.,
<code>signif(11.5, 2)</code> and <code>signif(12.5, 2)</code> are both rounded to 12.
This function rounds 12.5 to 13 (assuming <code>digits = 2</code>). Negative halves
are rounded away from zero, e.g., <code>signif(-2.5, 1)</code> is rounded to -3.
</p>
<p>This may skew subsequent statistical analysis of the data, but may be
desirable in certain contexts. This function is implemented from 
<a href="https://stackoverflow.com/a/1581007/">https://stackoverflow.com/a/1581007/</a>; see that question and
comments for discussion of this issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signif_half_up(x, digits = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signif_half_up_+3A_x">x</code></td>
<td>
<p>a numeric vector to round.</p>
</td></tr>
<tr><td><code id="signif_half_up_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of significant digits to be used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>signif_half_up(12.5, 2)
signif_half_up(1.125, 3)
signif_half_up(-2.5, 1) # negatives get rounded away from zero

</code></pre>

<hr>
<h2 id='single_value'>Ensure that a vector has only a single value throughout.</h2><span id='topic+single_value'></span>

<h3>Description</h3>

<p>Missing values are replaced with the single value, and if all values are
missing, the first value in <code>missing</code> is used throughout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_value(x, missing = NA, warn_if_all_missing = FALSE, info = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="single_value_+3A_x">x</code></td>
<td>
<p>The vector which should have a single value</p>
</td></tr>
<tr><td><code id="single_value_+3A_missing">missing</code></td>
<td>
<p>The vector of values to consider missing in <code>x</code></p>
</td></tr>
<tr><td><code id="single_value_+3A_warn_if_all_missing">warn_if_all_missing</code></td>
<td>
<p>Generate a warning if all values are missing?</p>
</td></tr>
<tr><td><code id="single_value_+3A_info">info</code></td>
<td>
<p>If more than one value is found, append this to the warning or
error to assist with determining the location of the issue.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> as the scalar single value found throughout (or an error if
more than one value is found).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple use case with vectors of input

single_value(c(NA, 1))
# Multiple, different values of missing can be given
single_value(c(NA, "a"), missing = c(NA, "a"))

# A typical use case with a grouped data.frame used for input and the output
# (`B` is guaranteed to have a single value and only one row, in this case)
data.frame(A = rep(1:3, each = 2),
           B = c(rep(4:6, each = 2))) %&gt;%
  dplyr::group_by(A) %&gt;%
  dplyr::summarize(
    B = single_value(B)
  )

try(
# info is useful to give when multiple values may be found to see what
# grouping variable or what calculation is causing the error
data.frame(A = rep(1:3, each = 2),
           B = c(rep(1:2, each = 2), 1:2)) %&gt;%
  dplyr::group_by(A) %&gt;%
  dplyr::mutate(
    C = single_value(B, info = paste("Calculating C for group A=", A))
  )
)
</code></pre>

<hr>
<h2 id='tabyl'>Generate a frequency table (1-, 2-, or 3-way).</h2><span id='topic+tabyl'></span><span id='topic+tabyl.default'></span><span id='topic+tabyl.data.frame'></span>

<h3>Description</h3>

<p>A fully-featured alternative to <code>table()</code>.  Results are data.frames and can be formatted and enhanced with janitor's family of <code>adorn_</code> functions.
</p>
<p>Specify a data.frame and the one, two, or three unquoted column names you want to tabulate.  Three variables generates a list of 2-way tabyls, split by the third variable.
</p>
<p>Alternatively, you can tabulate a single variable that isn't in a data.frame by calling <code>tabyl</code> on a vector, e.g., <code>tabyl(mtcars$gear)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabyl(dat, ...)

## Default S3 method:
tabyl(dat, show_na = TRUE, show_missing_levels = TRUE, ...)

## S3 method for class 'data.frame'
tabyl(dat, var1, var2, var3, show_na = TRUE, show_missing_levels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tabyl_+3A_dat">dat</code></td>
<td>
<p>a data.frame containing the variables you wish to count.  Or, a vector you want to tabulate.</p>
</td></tr>
<tr><td><code id="tabyl_+3A_...">...</code></td>
<td>
<p>the arguments to tabyl (here just for the sake of documentation compliance, as all arguments are listed with the vector- and data.frame-specific methods)</p>
</td></tr>
<tr><td><code id="tabyl_+3A_show_na">show_na</code></td>
<td>
<p>should counts of <code>NA</code> values be displayed?  In a one-way tabyl, the presence of <code>NA</code> values triggers an additional column showing valid percentages(calculated excluding <code>NA</code> values).</p>
</td></tr>
<tr><td><code id="tabyl_+3A_show_missing_levels">show_missing_levels</code></td>
<td>
<p>should counts of missing levels of factors be displayed?  These will be rows and/or columns of zeroes.  Useful for keeping consistent output dimensions even when certain factor levels may not be present in the data.</p>
</td></tr>
<tr><td><code id="tabyl_+3A_var1">var1</code></td>
<td>
<p>the column name of the first variable.</p>
</td></tr>
<tr><td><code id="tabyl_+3A_var2">var2</code></td>
<td>
<p>(optional) the column name of the second variable (the rows in a 2-way tabulation).</p>
</td></tr>
<tr><td><code id="tabyl_+3A_var3">var3</code></td>
<td>
<p>(optional) the column name of the third variable (the list in a 3-way tabulation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with frequencies and percentages of the tabulated variable(s).  A 3-way tabulation returns a list of data.frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tabyl(mtcars, cyl)
tabyl(mtcars, cyl, gear)
tabyl(mtcars, cyl, gear, am)

# or using the %&gt;% pipe
mtcars %&gt;%
  tabyl(cyl, gear)

# illustrating show_na functionality:
my_cars &lt;- rbind(mtcars, rep(NA, 11))
my_cars %&gt;% tabyl(cyl)
my_cars %&gt;% tabyl(cyl, show_na = FALSE)

# Calling on a single vector not in a data.frame:
val &lt;- c("hi", "med", "med", "lo")
tabyl(val)
</code></pre>

<hr>
<h2 id='top_levels'>Generate a frequency table of a factor grouped into top-n, bottom-n, and all other levels.</h2><span id='topic+top_levels'></span>

<h3>Description</h3>

<p>Get a frequency table of a factor variable, grouped into categories by level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_levels(input_vec, n = 2, show_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="top_levels_+3A_input_vec">input_vec</code></td>
<td>
<p>the factor variable to tabulate.</p>
</td></tr>
<tr><td><code id="top_levels_+3A_n">n</code></td>
<td>
<p>number of levels to include in top and bottom groups</p>
</td></tr>
<tr><td><code id="top_levels_+3A_show_na">show_na</code></td>
<td>
<p>should cases where the variable is NA be shown?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame (actually a <code>tbl_df</code>) with the frequencies of the grouped, tabulated variable.  Includes counts and percentages, and valid percentages (calculated omitting <code>NA</code> values, if present in the vector and <code>show_na = TRUE</code>.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>top_levels(as.factor(mtcars$hp), 2)
</code></pre>

<hr>
<h2 id='untabyl'>Remove <code>tabyl</code> attributes from a data.frame.</h2><span id='topic+untabyl'></span>

<h3>Description</h3>

<p>Strips away all <code>tabyl</code>-related attributes from a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untabyl(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="untabyl_+3A_dat">dat</code></td>
<td>
<p>a data.frame of class <code>tabyl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the same data.frame, but without the <code>tabyl</code> class and attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mtcars %&gt;%
  tabyl(am) %&gt;%
  untabyl() %&gt;%
  attributes() # tabyl-specific attributes are gone
</code></pre>

<hr>
<h2 id='use_first_valid_of'>Returns first non-NA value from a set of vectors.</h2><span id='topic+use_first_valid_of'></span>

<h3>Description</h3>

<p>At each position of the input vectors, iterates through in order and returns the first non-NA value.  This is a robust replacement of the common <code>ifelse(!is.na(x), x, ifelse(!is.na(y), y, z))</code>.  It's more readable and handles problems like <code>ifelse</code>'s inability to work with dates in this way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_first_valid_of(..., if_all_NA = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_first_valid_of_+3A_...">...</code></td>
<td>
<p>the input vectors.  Order matters: these are searched and prioritized in the order they are supplied.</p>
</td></tr>
<tr><td><code id="use_first_valid_of_+3A_if_all_na">if_all_NA</code></td>
<td>
<p>what value should be used when all of the vectors return <code>NA</code> for a certain index?  Default is NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a single vector with the selected values.
</p>


<h3>Warning</h3>

<p>Deprecated, do not use in new code. Use <code>dplyr::coalesce()</code> instead.
</p>


<h3>See Also</h3>

<p>janitor_deprecated
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
