<!DOCTYPE html><html lang="en"><head><title>Help for package ern</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ern}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agg_to_daily'><p>Infer daily counts from aggregates</p></a></li>
<li><a href='#attach_startdate_agg'><p>Attach start date from first observation for aggregated data from time (day number)</p></a></li>
<li><a href='#attach_t'><p>Attach internal time index column</p></a></li>
<li><a href='#attach_t_agg'><p>Attach time index (number of days) column. Exclude first day since we don't necessarily know over which period of time that data was aggregated</p></a></li>
<li><a href='#check_cl.input_format'><p>Check the format of input clinical data</p></a></li>
<li><a href='#check_df.input_daily'><p>Check if input data is already daily</p></a></li>
<li><a href='#check_dist'><p>Check distributions</p></a></li>
<li><a href='#check_for_deconv'><p>Check that deconvolution inputs are compatible</p></a></li>
<li><a href='#check_prm.daily'><p>Check parameters for daily data inference</p></a></li>
<li><a href='#check_prm.daily.check'><p>Check parameters for daily data inference check</p></a></li>
<li><a href='#check_prm.R'><p>Check parameters for Rt calculation</p></a></li>
<li><a href='#check_prm.smooth'><p>Check parameters for smoothing</p></a></li>
<li><a href='#cl.data'><p>Sample of aggregated clinical reports</p></a></li>
<li><a href='#correct_underreporting'><p>Correct underreporting by scaling up</p></a></li>
<li><a href='#deconv'><p>Wrapper for deconvolution with a given distribution</p></a></li>
<li><a href='#deconv_ww_inc'><p>Deconvoluting Wastewater Data to Incidence</p></a></li>
<li><a href='#deconvolution_RL'><p>Richardson-Lucy Deconvolution.</p></a></li>
<li><a href='#def_dist'><p>Define a family of distributions.</p></a></li>
<li><a href='#draw_from_gamma'><p>Draw from gamma for a parameter specified in a distribution family list.</p></a></li>
<li><a href='#estimate_R_cl'><p>Estimate the effective reproduction from clinical report data</p></a></li>
<li><a href='#estimate_R_cl_rep'><p>Ensemble estimate of Rt</p></a></li>
<li><a href='#estimate_R_cl_single'><p>A single realization of the Rt estimate</p></a></li>
<li><a href='#estimate_R_ww'><p>Estimate the effective reproduction from wastewater concentration</p>
data.</a></li>
<li><a href='#extract_mcmc_values'><p>Extract MCMC chains from a JAGS object</p></a></li>
<li><a href='#fit_jags_aggreg'><p>Fit JAGS model to aggregated data</p></a></li>
<li><a href='#get_discrete_dist'><p>Get a discretized, truncated version of a distribution</p></a></li>
<li><a href='#get_realizations'><p>Retrieve realizations for aggregated to daily inference</p></a></li>
<li><a href='#get_use_dates'><p>Get dates for which to use (trust) inferred daily reports</p></a></li>
<li><a href='#inc2R_one_iter'><p>Helper function.</p>
Converts wastewater to Rt after sampling one fecal shedding and
one generation interval distribution.</a></li>
<li><a href='#incidence_to_R'><p>Estimate Rt using EpiEstim</p></a></li>
<li><a href='#linear_int_daily'><p>Daily incidence from linear interpolation</p></a></li>
<li><a href='#na_to_0'><p>Replace NAs with 0s in vector</p></a></li>
<li><a href='#plot_diagnostic_cl'><p>Diagnostic plot for R estimation from clinical report data</p></a></li>
<li><a href='#plot_diagnostic_ww'><p>Diagnostic plot for R estimation from wastewater data</p></a></li>
<li><a href='#plot_dist'><p>Plot a distribution</p></a></li>
<li><a href='#plot_gelman_rubin'><p>Plot the Gelman Rubin statistic for all parameters.</p></a></li>
<li><a href='#plot_traces'><p>Plot MCMC traces</p></a></li>
<li><a href='#reports_to_incidence'><p>Infer incidence from reports via a series of deconvolutions</p></a></li>
<li><a href='#reshape_fit_jags'><p>Reshape JAGS fit object</p></a></li>
<li><a href='#sample_a_dist'><p>Sample parameters for a single distribution from a family of</p>
distributions, assuming parameters come from a Gamma distribution.</a></li>
<li><a href='#sample_from_dist'><p>Sample from a distribution</p>
(currently only implemented for a uniform distribution)</a></li>
<li><a href='#sample_post_ee'><p>Helper function - sample from EpiEstim's R posterior distribution</p></a></li>
<li><a href='#smooth_cl'><p>Smooth realizations from estimating daily reports</p></a></li>
<li><a href='#smooth_ww'><p>Smooth wastewater data (using pre-processed wastewater)</p></a></li>
<li><a href='#summarise_by_date_iters'><p>Summarise observations by date for raw iterations from an ensemble</p></a></li>
<li><a href='#summarise_report_counts'><p>Summarise daily inferred reports</p>
based on original reporting schedule and calculate error</a></li>
<li><a href='#summary_postsamples'><p>Helper function that summarises</p>
posterior samples of Rt from EpiEstim</a></li>
<li><a href='#ww.data'><p>Sample of wastewater concentration</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Effective Reproduction Number Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Champredon &lt;david.champredon@canada.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate the effective reproduction number from wastewater
    and clinical data sources.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, coda, dplyr, EpiEstim, ggplot2, lubridate,
patchwork, rjags, runjags, stats, stringr, tibble, tidyr, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bookdown, purrr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-16 17:31:38 UTC; user5023114</td>
</tr>
<tr>
<td>Author:</td>
<td>David Champredon <a href="https://orcid.org/0000-0002-7090-8757"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Warsame Yusuf <a href="https://orcid.org/0000-0001-5571-8122"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Irena Papst <a href="https://orcid.org/0000-0001-5901-7585"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-16 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='agg_to_daily'>Infer daily counts from aggregates</h2><span id='topic+agg_to_daily'></span>

<h3>Description</h3>

<p>Infer daily counts from aggregates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_to_daily(cl.data, dist.gi, prm.daily, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agg_to_daily_+3A_cl.data">cl.data</code></td>
<td>
<p>Data frame. Must have variables:
</p>

<ul>
<li> <p><code>date</code>: calendar date of report
</p>
</li>
<li> <p><code>value</code>: count of reported cases
</p>
</li></ul>
</td></tr>
<tr><td><code id="agg_to_daily_+3A_dist.gi">dist.gi</code></td>
<td>
<p>List. Parameters for the generation interval distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="agg_to_daily_+3A_prm.daily">prm.daily</code></td>
<td>
<p>List. Parameters for daily report inference via MCMC. Elements include:
</p>

<ul>
<li> <p><code>method</code>: String. Method name to infer the daily incidence reports from aggregated ones.
Either <code>linear</code> or <code>renewal</code> is currently implemented.
The <code>linear</code> method simply performs a linear interpolation that matches the aggregated values.
The <code>renewal</code> method fits a SIR-like model using a renewal equation to infer the daily incidence.
In this case, the fitting algorithm is a Markov Chain Monte Carlo (MCMC) implemented in JAGS
and needs the parameters below (e.g., <code>burn,iter,chains,...</code>).
The <code>renewal</code> method is more adapted for short single wave epidemics as this models
i) naturally fits a single wave and ii) has longer computing time.
For longer time series, user may perfer the <code>linear</code> method.
</p>
</li>
<li> <p><code>popsize</code>: Integer. Population size to use in MCMC simulation to infer daily observations from aggregated input data.
</p>
</li>
<li> <p><code>burn</code>: Numeric. Length of burn-in period (number of days).
</p>
</li>
<li> <p><code>iter</code>: Numeric. Number of iterations after burn-in period (number of days).
</p>
</li>
<li> <p><code>chains</code>: Numeric. Number of chains to simulate.
</p>
</li>
<li> <p><code>prior_R0_shape</code>: Shape of the (hyper-)parameter for the prior Gamma distribution for R0.
</p>
</li>
<li> <p><code>prior_R0_rate</code>: Rate of the (hyper-)parameter for the prior Gamma distribution for R0.
</p>
</li>
<li> <p><code>prior_alpha_shape</code>: Shape of the (hyper-)parameter for the prior Gamma distribution for alpha.
</p>
</li>
<li> <p><code>prior_alpha_rate</code>: Rate of the (hyper-)parameter for the prior Gamma distribution for alpha.
</p>
</li>
<li> <p><code>first.agg.period</code>: length of aggregation period for first aggregated observation (number of days); if NULL, assume same aggregation period as observed for second observation (gap between first and second observations)
</p>
</li></ul>
</td></tr>
<tr><td><code id="agg_to_daily_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a data frame with individual realizations of
daily reported cases and the JAGS object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Importing data attached to the `ern` package
# and selecting the Omicron wave in Ontario, Canada.
# This is *weekly* incidence.
data(cl.data)
data = cl.data[cl.data$pt == 'on' &amp; 
                  cl.data$date &gt; as.Date('2021-11-30') &amp; 
                  cl.data$date &lt; as.Date('2021-12-31'),] 
head(data)
dist.gi = ern::def_dist(
 dist     = "gamma",
 mean     = 6.84,
 mean_sd  = 0.7486,
 shape    = 2.39,
 shape_sd = 0.3573,
 max      = 15
)

a = agg_to_daily(
cl.data = data, 
dist.gi = dist.gi, 
  prm.daily = list(
  method = "renewal",
  popsize = 14e6,
  # MCMC parameters.
  # small values for computation speed for this example.
  # Increase for better accuracy
  burn = 100,
  iter = 100,
  chains = 2,
  # - - - - - 
  prior_R0_shape = 2,
  prior_R0_rate = 0.6,
  prior_alpha_shape = 1,
  prior_alpha_rate = 1
))
# This is a Bayesian inference, so we 
# have a posterior distribution of  
# daily incidences. Here we just plot
# one single draw:
      
 df = a$df
 df1 = df[df$id==1,]
 plot(x = df1$t, y = df1$value, typ = 'o',
      xlab = 'days', ylab = 'daily incidence',
      main = 'Posterior daily incidence infered from weekly incidence')
 
 # Extract of the parameters values from the first chain
 a$jags.object[[1]][1:9,1:9]
 
</code></pre>

<hr>
<h2 id='attach_startdate_agg'>Attach start date from first observation for aggregated data from time (day number)</h2><span id='topic+attach_startdate_agg'></span>

<h3>Description</h3>

<p>Attach start date from first observation for aggregated data from time (day number)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_startdate_agg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attach_startdate_agg_+3A_x">x</code></td>
<td>
<p>dataframe. only has columns <code>date</code>, <code>value</code>, and <code>t</code></p>
</td></tr>
</table>

<hr>
<h2 id='attach_t'>Attach internal time index column</h2><span id='topic+attach_t'></span>

<h3>Description</h3>

<p>Attach internal time index column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_t(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attach_t_+3A_df">df</code></td>
<td>
<p>Data frame. Must have column <code>date</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble.
</p>

<hr>
<h2 id='attach_t_agg'>Attach time index (number of days) column. Exclude first day since we don't necessarily know over which period of time that data was aggregated</h2><span id='topic+attach_t_agg'></span>

<h3>Description</h3>

<p>Attach time index (number of days) column. Exclude first day since we don't necessarily know over which period of time that data was aggregated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_t_agg(cl.data, prm.daily = NULL, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attach_t_agg_+3A_cl.data">cl.data</code></td>
<td>
<p>Data frame. Must have variables:
</p>

<ul>
<li> <p><code>date</code>: calendar date of report
</p>
</li>
<li> <p><code>value</code>: count of reported cases
</p>
</li></ul>
</td></tr>
<tr><td><code id="attach_t_agg_+3A_prm.daily">prm.daily</code></td>
<td>
<p>List. Parameters for daily report inference via MCMC. Elements include:
</p>

<ul>
<li> <p><code>method</code>: String. Method name to infer the daily incidence reports from aggregated ones.
Either <code>linear</code> or <code>renewal</code> is currently implemented.
The <code>linear</code> method simply performs a linear interpolation that matches the aggregated values.
The <code>renewal</code> method fits a SIR-like model using a renewal equation to infer the daily incidence.
In this case, the fitting algorithm is a Markov Chain Monte Carlo (MCMC) implemented in JAGS
and needs the parameters below (e.g., <code>burn,iter,chains,...</code>).
The <code>renewal</code> method is more adapted for short single wave epidemics as this models
i) naturally fits a single wave and ii) has longer computing time.
For longer time series, user may perfer the <code>linear</code> method.
</p>
</li>
<li> <p><code>popsize</code>: Integer. Population size to use in MCMC simulation to infer daily observations from aggregated input data.
</p>
</li>
<li> <p><code>burn</code>: Numeric. Length of burn-in period (number of days).
</p>
</li>
<li> <p><code>iter</code>: Numeric. Number of iterations after burn-in period (number of days).
</p>
</li>
<li> <p><code>chains</code>: Numeric. Number of chains to simulate.
</p>
</li>
<li> <p><code>prior_R0_shape</code>: Shape of the (hyper-)parameter for the prior Gamma distribution for R0.
</p>
</li>
<li> <p><code>prior_R0_rate</code>: Rate of the (hyper-)parameter for the prior Gamma distribution for R0.
</p>
</li>
<li> <p><code>prior_alpha_shape</code>: Shape of the (hyper-)parameter for the prior Gamma distribution for alpha.
</p>
</li>
<li> <p><code>prior_alpha_rate</code>: Rate of the (hyper-)parameter for the prior Gamma distribution for alpha.
</p>
</li>
<li> <p><code>first.agg.period</code>: length of aggregation period for first aggregated observation (number of days); if NULL, assume same aggregation period as observed for second observation (gap between first and second observations)
</p>
</li></ul>
</td></tr>
<tr><td><code id="attach_t_agg_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame
</p>

<hr>
<h2 id='check_cl.input_format'>Check the format of input clinical data</h2><span id='topic+check_cl.input_format'></span>

<h3>Description</h3>

<p>Check the format of input clinical data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cl.input_format(cl.data, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_cl.input_format_+3A_cl.data">cl.data</code></td>
<td>
<p>Data frame. Must have variables:
</p>

<ul>
<li> <p><code>date</code>: calendar date of report
</p>
</li>
<li> <p><code>value</code>: count of reported cases
</p>
</li></ul>
</td></tr>
<tr><td><code id="check_cl.input_format_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
</table>

<hr>
<h2 id='check_df.input_daily'>Check if input data is already daily</h2><span id='topic+check_df.input_daily'></span>

<h3>Description</h3>

<p>Check if input data is already daily
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_df.input_daily(df.input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_df.input_daily_+3A_df.input">df.input</code></td>
<td>
<p>Data frame. Must have variables:
</p>

<ul>
<li> <p><code>date</code>: calendar date of observation (report for clinical data, wastewater sampling for wastewater data)
</p>
</li>
<li> <p><code>value</code>: observed values (count of reported cases for clinical data, wastewater concentration for wastewater data)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. Indicates whether input data is already daily.
</p>

<hr>
<h2 id='check_dist'>Check distributions</h2><span id='topic+check_dist'></span>

<h3>Description</h3>

<p>Check distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dist(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dist_+3A_x">x</code></td>
<td>
<p>family of distributions to be checked, as generated by <code>def_dist_()</code></p>
</td></tr>
</table>

<hr>
<h2 id='check_for_deconv'>Check that deconvolution inputs are compatible</h2><span id='topic+check_for_deconv'></span>

<h3>Description</h3>

<p>Check that deconvolution inputs are compatible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_for_deconv(obs, dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_for_deconv_+3A_obs">obs</code></td>
<td>
<p>Numeric. Vector with observed signal (<em>e.g.</em>, case reports)</p>
</td></tr>
<tr><td><code id="check_for_deconv_+3A_dist">dist</code></td>
<td>
<p>Numeric. Vector of discretized distribution used as the deconvolution kernel (<em>e.g.</em>, reporting delay distribution)</p>
</td></tr>
</table>

<hr>
<h2 id='check_prm.daily'>Check parameters for daily data inference</h2><span id='topic+check_prm.daily'></span>

<h3>Description</h3>

<p>Check parameters for daily data inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_prm.daily(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_prm.daily_+3A_x">x</code></td>
<td>
<p>List. Parameters for daily data inference.</p>
</td></tr>
</table>

<hr>
<h2 id='check_prm.daily.check'>Check parameters for daily data inference check</h2><span id='topic+check_prm.daily.check'></span>

<h3>Description</h3>

<p>Check parameters for daily data inference check
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_prm.daily.check(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_prm.daily.check_+3A_x">x</code></td>
<td>
<p>List. Parameters for daily data inference check.</p>
</td></tr>
</table>

<hr>
<h2 id='check_prm.R'>Check parameters for Rt calculation</h2><span id='topic+check_prm.R'></span>

<h3>Description</h3>

<p>Check parameters for Rt calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_prm.R(x, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_prm.R_+3A_x">x</code></td>
<td>
<p>List. Parameters for Rt calculation.</p>
</td></tr>
<tr><td><code id="check_prm.R_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
</table>

<hr>
<h2 id='check_prm.smooth'>Check parameters for smoothing</h2><span id='topic+check_prm.smooth'></span>

<h3>Description</h3>

<p>Check parameters for smoothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_prm.smooth(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_prm.smooth_+3A_x">x</code></td>
<td>
<p>List that specifies the type of smoothing and the parameters associated with the smoothing method.</p>
</td></tr>
</table>

<hr>
<h2 id='cl.data'>Sample of aggregated clinical reports</h2><span id='topic+cl.data'></span>

<h3>Description</h3>

<p>A subset of COVID-19 weekly reports in the Government of Canada Health Infobase.
See <a href="https://health-infobase.canada.ca/covid-19/">https://health-infobase.canada.ca/covid-19/</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl.data
</code></pre>


<h3>Format</h3>



<h4><code>cl.data</code></h4>

<p>A data frame with 96 rows and 3 columns:
</p>

<ul>
<li> <p><code>pt</code>: standard two-character abbreviation (lowercase)
of the province name (based on Statistics Canada 2021 census abbreviations)
</p>
</li>
<li> <p><code>date</code>: report date
</p>
</li>
<li> <p><code>value</code>: count of reported cases for the previous week
</p>
</li></ul>

<p>Filter indicating a specific province to extract a sample dataset for use with <code><a href="#topic+estimate_R_cl">estimate_R_cl()</a></code>, <em>e.g.</em>
</p>
<p><code>estimate_R_cl(cl.data = dplyr::filter(cl.data, pt == 'bc'), ...)</code>
</p>


<hr>
<h2 id='correct_underreporting'>Correct underreporting by scaling up</h2><span id='topic+correct_underreporting'></span>

<h3>Description</h3>

<p>Correct underreporting by scaling up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_underreporting(reports.daily, reporting.fraction)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_underreporting_+3A_reports.daily">reports.daily</code></td>
<td>
<p>dataframe of daily reported cases. must at least include <code>value</code> column with counts.</p>
</td></tr>
<tr><td><code id="correct_underreporting_+3A_reporting.fraction">reporting.fraction</code></td>
<td>
<p>numeric. proportion of incidence that is reported.</p>
</td></tr>
</table>

<hr>
<h2 id='deconv'>Wrapper for deconvolution with a given distribution</h2><span id='topic+deconv'></span>

<h3>Description</h3>

<p>Wrapper for deconvolution with a given distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconv(counts, dist, max.iter = 10, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deconv_+3A_counts">counts</code></td>
<td>
<p>Numeric. Vector of daily counts.</p>
</td></tr>
<tr><td><code id="deconv_+3A_dist">dist</code></td>
<td>
<p>Numeric. Vector of discrete distributions (daily, truncated) with which we're deconvoluting counts, <em>e.g.</em>, produced by <code><a href="#topic+get_discrete_dist">get_discrete_dist()</a></code></p>
</td></tr>
<tr><td><code id="deconv_+3A_max.iter">max.iter</code></td>
<td>
<p>Numeric. Maximum number of Richardson-Lucy iterations.</p>
</td></tr>
<tr><td><code id="deconv_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
</table>

<hr>
<h2 id='deconv_ww_inc'>Deconvoluting Wastewater Data to Incidence</h2><span id='topic+deconv_ww_inc'></span>

<h3>Description</h3>

<p>Function estimates incidence from smoothed data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconv_ww_inc(d, fec, scaling.factor, silent, RL.max.iter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deconv_ww_inc_+3A_d">d</code></td>
<td>
<p>Data frame. Wastewater dataframe. Must include at least <code>date</code>, time <code>t</code> and
<code>obs</code> columns.</p>
</td></tr>
<tr><td><code id="deconv_ww_inc_+3A_fec">fec</code></td>
<td>
<p>List. Parameters for a single fecal shedding distribution, as generated by <code><a href="#topic+sample_a_dist">sample_a_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="deconv_ww_inc_+3A_scaling.factor">scaling.factor</code></td>
<td>
<p>Numeric. Scaling from wastewater concentration to
prevalence. This value may be assumed or independently calibrated to data.</p>
</td></tr>
<tr><td><code id="deconv_ww_inc_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
<tr><td><code id="deconv_ww_inc_+3A_rl.max.iter">RL.max.iter</code></td>
<td>
<p>Integer. Maximum of iterations for the Richardson-Lucy deconvolution algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with deconvoluted incidence
</p>

<hr>
<h2 id='deconvolution_RL'>Richardson-Lucy Deconvolution.</h2><span id='topic+deconvolution_RL'></span>

<h3>Description</h3>

<p>Richardson-Lucy Deconvolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconvolution_RL(
  observed,
  times,
  p_delay,
  max_iter = 50,
  out_col_name = "RL_result",
  right_censor = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deconvolution_RL_+3A_observed">observed</code></td>
<td>
<p>A vector of the number of observed cases, deaths,
hospitalizations, etc. per day</p>
</td></tr>
<tr><td><code id="deconvolution_RL_+3A_times">times</code></td>
<td>
<p>A numeric vector of times corresponding to the entries in
observed. Must be the same length as observed.</p>
</td></tr>
<tr><td><code id="deconvolution_RL_+3A_p_delay">p_delay</code></td>
<td>
<p>A numeric vector whose entries give the probability that
the delay from infection to observation is exactly 0, 1, ... N days.
p_delay must sum to 1 and to  facilitate vectorization should be
the same length as observed, and times
(the last several entries will most likely be 0s).</p>
</td></tr>
<tr><td><code id="deconvolution_RL_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of times to iterate.
Following Goldstein et al., the algorithm continues to run until
the normalized chi2 statistic comparing the observed and expected number
of deaths per day falls below 1, or until the maximum number of
iterations is reached.</p>
</td></tr>
<tr><td><code id="deconvolution_RL_+3A_out_col_name">out_col_name</code></td>
<td>
<p>String giving the name of the column
in which to output the imputed times of infection</p>
</td></tr>
<tr><td><code id="deconvolution_RL_+3A_right_censor">right_censor</code></td>
<td>
<p>If <code>TRUE</code> (default), upscale the observations
at the end of the time series based on the cumulative probability
that an infection occurring on that date would have been observed.</p>
</td></tr>
<tr><td><code id="deconvolution_RL_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Verbose mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns time and out_col_name
(which gives the imputed number of infections per timestep)
</p>

<hr>
<h2 id='def_dist'>Define a family of distributions.</h2><span id='topic+def_dist'></span>

<h3>Description</h3>

<p>Define a family of distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def_dist(dist, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="def_dist_+3A_dist">dist</code></td>
<td>
<p>distribution type. Distributions currently supported are:
</p>

<ul>
<li> <p><code>norm</code> = normal,
</p>
</li>
<li> <p><code>lnorm</code> = log-normal,
</p>
</li>
<li> <p><code>gamma</code> = Gamma,
</p>
</li>
<li> <p><code>unif</code> = uniform
</p>
</li></ul>
</td></tr>
<tr><td><code id="def_dist_+3A_...">...</code></td>
<td>
<p>a series of distribution parameters.
Included should be the following:
</p>

<ul>
<li> <p><code>mean</code> distribution mean (only for <code>dist</code> = <code>lnorm</code> or <code>gamma</code>).
</p>
</li>
<li> <p><code>mean_sd</code> standard deviation of the mean (only for <code>dist</code> = <code>lnorm</code>
or <code>gamma</code>).
</p>
</li>
<li> <p><code>sd</code> standard deviation (only for <code>dist</code> = <code>lnorm</code> or <code>gamma</code>).
</p>
</li>
<li> <p><code>sd_sd</code> standard deviation of the standard deviation (only for
<code>dist</code> = <code>lnorm</code> or <code>gamma</code>).
</p>
</li>
<li> <p><code>min</code> minimum value of the random variable modelled by this distribution
(only for <code>dist</code> = <code>unif</code>).
</p>
</li>
<li> <p><code>max</code> maximum value of the random variable modelled by this distribution.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List with components specified in the parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d = def_dist(
  dist     = "gamma",
  mean     = 3.49,
  mean_sd  = 0.1477,
  shape    = 8.5,
  shape_sd = 1.8945,
  max      = 8
)
print(d)

</code></pre>

<hr>
<h2 id='draw_from_gamma'>Draw from gamma for a parameter specified in a distribution family list.</h2><span id='topic+draw_from_gamma'></span>

<h3>Description</h3>

<p>Draw from gamma for a parameter specified in a distribution family list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_from_gamma(par, dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_from_gamma_+3A_par">par</code></td>
<td>
<p>Character. Name of the parameter to sample.</p>
</td></tr>
<tr><td><code id="draw_from_gamma_+3A_dist">dist</code></td>
<td>
<p>List. Distribution definition, as output by <code>def_dist()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. The sampled parameter value.
</p>

<hr>
<h2 id='estimate_R_cl'>Estimate the effective reproduction from clinical report data</h2><span id='topic+estimate_R_cl'></span>

<h3>Description</h3>

<p>Estimate the effective reproduction from clinical report data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_R_cl(
  cl.data,
  dist.repdelay,
  dist.repfrac,
  dist.incub,
  dist.gi,
  prm.daily = list(method = "linear", popsize = NULL, burn = 500, iter = 2000, chains =
    3, prior_R0_shape = 2, prior_R0_rate = 0.6, prior_alpha_shape = 1, prior_alpha_rate =
    1, first.agg.period = NULL),
  prm.daily.check = list(agg.reldiff.tol = 10),
  prm.smooth = list(method = "rollmean", align = "right", window = 7),
  prm.R = list(iter = 10, CI = 0.95, window = 7, config.EpiEstim = NULL),
  RL.max.iter = 10,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_R_cl_+3A_cl.data">cl.data</code></td>
<td>
<p>Data frame. Must have variables:
</p>

<ul>
<li> <p><code>date</code>: calendar date of report
</p>
</li>
<li> <p><code>value</code>: count of reported cases
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_R_cl_+3A_dist.repdelay">dist.repdelay</code></td>
<td>
<p>List. Parameters for the reporting delay distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_+3A_dist.repfrac">dist.repfrac</code></td>
<td>
<p>List. Parameters for the reporting fraction distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_+3A_dist.incub">dist.incub</code></td>
<td>
<p>List. Parameters for the incubation period distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_+3A_dist.gi">dist.gi</code></td>
<td>
<p>List. Parameters for the generation interval distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_+3A_prm.daily">prm.daily</code></td>
<td>
<p>List. Parameters for daily report inference via MCMC. Elements include:
</p>

<ul>
<li> <p><code>method</code>: String. Method name to infer the daily incidence reports from aggregated ones.
Either <code>linear</code> or <code>renewal</code> is currently implemented.
The <code>linear</code> method simply performs a linear interpolation that matches the aggregated values.
The <code>renewal</code> method fits a SIR-like model using a renewal equation to infer the daily incidence.
In this case, the fitting algorithm is a Markov Chain Monte Carlo (MCMC) implemented in JAGS
and needs the parameters below (e.g., <code>burn,iter,chains,...</code>).
The <code>renewal</code> method is more adapted for short single wave epidemics as this models
i) naturally fits a single wave and ii) has longer computing time.
For longer time series, user may perfer the <code>linear</code> method.
</p>
</li>
<li> <p><code>popsize</code>: Integer. Population size to use in MCMC simulation to infer daily observations from aggregated input data.
</p>
</li>
<li> <p><code>burn</code>: Numeric. Length of burn-in period (number of days).
</p>
</li>
<li> <p><code>iter</code>: Numeric. Number of iterations after burn-in period (number of days).
</p>
</li>
<li> <p><code>chains</code>: Numeric. Number of chains to simulate.
</p>
</li>
<li> <p><code>prior_R0_shape</code>: Shape of the (hyper-)parameter for the prior Gamma distribution for R0.
</p>
</li>
<li> <p><code>prior_R0_rate</code>: Rate of the (hyper-)parameter for the prior Gamma distribution for R0.
</p>
</li>
<li> <p><code>prior_alpha_shape</code>: Shape of the (hyper-)parameter for the prior Gamma distribution for alpha.
</p>
</li>
<li> <p><code>prior_alpha_rate</code>: Rate of the (hyper-)parameter for the prior Gamma distribution for alpha.
</p>
</li>
<li> <p><code>first.agg.period</code>: length of aggregation period for first aggregated observation (number of days); if NULL, assume same aggregation period as observed for second observation (gap between first and second observations)
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_R_cl_+3A_prm.daily.check">prm.daily.check</code></td>
<td>
<p>List. Parameters for checking aggregated to daily report inference. Elements include:
</p>

<ul>
<li> <p><code>agg.reldiff.tol</code>: numerical tolerance (%) for relative error between aggregated inferred daily reports and original aggregated reports; chronological observations are dropped until this tolerance is first acheived (convergence at the start of the timeseries is often the worst, need to maintain uninterrupted daily timeseries for input into Rt calculation).
</p>
</li></ul>

<p>Set this entire argument to <code>NULL</code> to use inferred daily reports as is.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_+3A_prm.smooth">prm.smooth</code></td>
<td>
<p>List. list of smoothing parameters. Parameters should be
specified as followed:
</p>

<ul>
<li> <p><code>method</code>: smoothing method, either <code>'rollmean'</code> (rolling mean) or <code>'loess'</code> (LOESS smoothing via <code><a href="stats.html#topic+loess">stats::loess()</a></code>)
</p>
</li>
<li> <p><code>window</code>: for <code style="white-space: pre;">&#8288;method = 'rollmean&#8288;</code> only; width of smoothing window in days
</p>
</li>
<li> <p><code>align</code>: for <code style="white-space: pre;">&#8288;method = 'rollmean&#8288;</code> only; smoothing alignment, either <code>'center'</code>, <code>'left'</code>, <code>'right'</code>
</p>
</li>
<li> <p><code>span</code>: for <code>method = 'loess'</code> only; smoothing span (see the documentation for <code><a href="stats.html#topic+loess">stats::loess()</a></code> for details)
</p>
</li>
<li> <p><code>floor</code>: optional call for wastewater concentration smoothing with <code>method = 'loess'</code> only; user defined minimum smoothing concentration
</p>
</li></ul>

<p>Set this entire list to <code>NULL</code> to turn off smoothing</p>
</td></tr>
<tr><td><code id="estimate_R_cl_+3A_prm.r">prm.R</code></td>
<td>
<p>List. Settings for the ensemble when calculating Rt.
Elements include:
</p>

<ul>
<li> <p><code>iter</code>: Integer. Number of iterations for the Rt ensemble
</p>
</li>
<li> <p><code>CI</code>: Numeric between 0 and 1. Confidence interval width for Rt
estimates after sampling uncertain distributions.
</p>
</li>
<li> <p><code>window</code>: Integer. Number of days defining the window of data used by
<code>EpiEstim</code> to estimate Rt. If <code>NULL</code>, will default to 7.
</p>
</li>
<li> <p><code>config.EpiEstim</code>: (optional) configuration for <code>EpiEstim</code> defined via
<code><a href="EpiEstim.html#topic+make_config">EpiEstim::make_config()</a></code>. If <code>NULL</code>, will use default config from
<code>EpiEstim</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_R_cl_+3A_rl.max.iter">RL.max.iter</code></td>
<td>
<p>Integer. Maximum of iterations for the Richardson-Lucy deconvolution algorithm.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Elements include:
</p>

<ul>
<li> <p><code>cl.data</code>: original aggregated reports signal
</p>
</li>
<li> <p><code>cl.daily</code>: reports as input for Rt calculation (inferred daily counts, smoothed)
</p>
</li>
<li> <p><code>inferred.agg</code>: inferred daily reports aggregated on the reporting schedule as input in <code>cl.data</code>
</p>
</li>
<li> <p><code>R</code>: the effective R estimate (summary from ensemble)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot_diagnostic_cl">plot_diagnostic_cl()</a></code> <code><a href="#topic+estimate_R_ww">estimate_R_ww()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# -- THIS EXAMPLE TAKES ABOUT 30 SECONDS TO RUN --
# Estimate Rt

## Not run: 
# Load SARS-CoV-2 reported cases in Quebec
# during the Summer 2021
dat &lt;- (ern::cl.data
    |&gt; dplyr::filter(
      pt == "qc", 
      dplyr::between(date, as.Date("2021-06-01"), as.Date("2021-09-01"))
    )
)
# distributions
dist.repdelay = ern::def_dist(
    dist = 'gamma',
    mean = 5, 
    mean_sd = 1,
    sd = 1,
    sd_sd = 0.1,
    max = 10
)
dist.repfrac = ern::def_dist(
    dist = "unif",
    min = 0.1,
    max = 0.3
)
dist.incub = ern::def_dist(
    dist = "gamma",
    mean = 3.49,
    mean_sd = 0.1477,
    shape = 8.5,
    shape_sd = 1.8945,
    max = 8
)
dist.gi = ern::def_dist(
    dist = "gamma",
    mean = 6,
    mean_sd = 0.75,
    shape = 2.4,
    shape_sd = 0.3,
    max = 10
)

# settings
prm.daily &lt;- list(
    method = "renewal",
    popsize = 8.5e6, # Q3 (July 1) 2022 estimate for Quebec
    burn = 500,
    iter = 500,
    chains = 2,
    prior_R0_shape = 1.1, prior_R0_rate = 0.6, 
    prior_alpha_shape = 1, prior_alpha_rate = 1
)
prm.daily.check &lt;- list(
    agg.reldiff.tol = 10
)
prm.smooth &lt;- list(
    method = "rollmean",
    align = "center",
    window = 7
)
prm.R &lt;- list(
    iter = 20, 
    CI = 0.95, 
    window = 7, 
    config.EpiEstim = NULL
)

x &lt;- estimate_R_cl(
  dat,
  dist.repdelay,
  dist.repfrac,
  dist.incub,
  dist.gi,
  prm.daily,
  prm.daily.check,
  prm.smooth,
  prm.R
)

# Rt estimates
print(x$R)

## End(Not run)

 

</code></pre>

<hr>
<h2 id='estimate_R_cl_rep'>Ensemble estimate of Rt</h2><span id='topic+estimate_R_cl_rep'></span>

<h3>Description</h3>

<p>Ensemble estimate of Rt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_R_cl_rep(
  cl.daily,
  dist.repfrac,
  dist.repdelay,
  dist.incub,
  dist.gi,
  prm.R,
  silent = FALSE,
  RL.max.iter = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_R_cl_rep_+3A_cl.daily">cl.daily</code></td>
<td>
<p>Dataframe of inferred daily incidence.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_rep_+3A_dist.repfrac">dist.repfrac</code></td>
<td>
<p>List. Parameters for the reporting fraction distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_rep_+3A_dist.repdelay">dist.repdelay</code></td>
<td>
<p>List. Parameters for the reporting delay distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_rep_+3A_dist.incub">dist.incub</code></td>
<td>
<p>List. Parameters for the incubation period distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_rep_+3A_dist.gi">dist.gi</code></td>
<td>
<p>List. Parameters for the generation interval distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_rep_+3A_prm.r">prm.R</code></td>
<td>
<p>List. Settings for the ensemble when calculating Rt.
Elements include:
</p>

<ul>
<li> <p><code>iter</code>: Integer. Number of iterations for the Rt ensemble
</p>
</li>
<li> <p><code>CI</code>: Numeric between 0 and 1. Confidence interval width for Rt
estimates after sampling uncertain distributions.
</p>
</li>
<li> <p><code>window</code>: Integer. Number of days defining the window of data used by
<code>EpiEstim</code> to estimate Rt. If <code>NULL</code>, will default to 7.
</p>
</li>
<li> <p><code>config.EpiEstim</code>: (optional) configuration for <code>EpiEstim</code> defined via
<code><a href="EpiEstim.html#topic+make_config">EpiEstim::make_config()</a></code>. If <code>NULL</code>, will use default config from
<code>EpiEstim</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_R_cl_rep_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_rep_+3A_rl.max.iter">RL.max.iter</code></td>
<td>
<p>Integer. Maximum of iterations for the Richardson-Lucy deconvolution algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of individual Rt realizations with 95% confidence intervals
</p>


<h3>See Also</h3>

<p><code><a href="EpiEstim.html#topic+make_config">EpiEstim::make_config()</a></code>
</p>

<hr>
<h2 id='estimate_R_cl_single'>A single realization of the Rt estimate</h2><span id='topic+estimate_R_cl_single'></span>

<h3>Description</h3>

<p>A single realization of the Rt estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_R_cl_single(
  cl.daily,
  dist.repfrac,
  dist.repdelay,
  dist.incub,
  dist.gi,
  prm.R,
  silent = FALSE,
  RL.max.iter = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_R_cl_single_+3A_cl.daily">cl.daily</code></td>
<td>
<p>Dataframe of inferred daily incidence.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_single_+3A_dist.repfrac">dist.repfrac</code></td>
<td>
<p>List. Parameters for the reporting fraction distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_single_+3A_dist.repdelay">dist.repdelay</code></td>
<td>
<p>List. Parameters for the reporting delay distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_single_+3A_dist.incub">dist.incub</code></td>
<td>
<p>List. Parameters for the incubation period distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_single_+3A_dist.gi">dist.gi</code></td>
<td>
<p>List. Parameters for the generation interval distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_single_+3A_prm.r">prm.R</code></td>
<td>
<p>List. Settings for the ensemble when calculating Rt.
Elements include:
</p>

<ul>
<li> <p><code>iter</code>: Integer. Number of iterations for the Rt ensemble
</p>
</li>
<li> <p><code>CI</code>: Numeric between 0 and 1. Confidence interval width for Rt
estimates after sampling uncertain distributions.
</p>
</li>
<li> <p><code>window</code>: Integer. Number of days defining the window of data used by
<code>EpiEstim</code> to estimate Rt. If <code>NULL</code>, will default to 7.
</p>
</li>
<li> <p><code>config.EpiEstim</code>: (optional) configuration for <code>EpiEstim</code> defined via
<code><a href="EpiEstim.html#topic+make_config">EpiEstim::make_config()</a></code>. If <code>NULL</code>, will use default config from
<code>EpiEstim</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_R_cl_single_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
<tr><td><code id="estimate_R_cl_single_+3A_rl.max.iter">RL.max.iter</code></td>
<td>
<p>Integer. Maximum of iterations for the Richardson-Lucy deconvolution algorithm.</p>
</td></tr>
</table>

<hr>
<h2 id='estimate_R_ww'>Estimate the effective reproduction from wastewater concentration
data.</h2><span id='topic+estimate_R_ww'></span>

<h3>Description</h3>

<p>Estimate the effective reproduction from wastewater concentration
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_R_ww(
  ww.conc,
  dist.fec,
  dist.gi,
  scaling.factor = 1,
  prm.smooth = list(window = 14, align = "center", method = "loess", span = 0.2),
  prm.R = list(iter = 10, CI = 0.95, window = 7, config.EpiEstim = NULL),
  silent = FALSE,
  RL.max.iter = 9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_R_ww_+3A_ww.conc">ww.conc</code></td>
<td>
<p>Data frame. Must have variables:
</p>

<ul>
<li> <p><code>date</code>: calendar date of wastewater collection
</p>
</li>
<li> <p><code>value</code>: pathogen concentration
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_R_ww_+3A_dist.fec">dist.fec</code></td>
<td>
<p>List. Parameters for the fecal shedding distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_ww_+3A_dist.gi">dist.gi</code></td>
<td>
<p>List. Parameters for the generation interval distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_R_ww_+3A_scaling.factor">scaling.factor</code></td>
<td>
<p>Numeric. Scaling from wastewater concentration to
prevalence. This value may be assumed or independently calibrated to data.</p>
</td></tr>
<tr><td><code id="estimate_R_ww_+3A_prm.smooth">prm.smooth</code></td>
<td>
<p>List. list of smoothing parameters. Parameters should be
specified as followed:
</p>

<ul>
<li> <p><code>method</code>: smoothing method, either <code>'rollmean'</code> (rolling mean) or <code>'loess'</code> (LOESS smoothing via <code><a href="stats.html#topic+loess">stats::loess()</a></code>)
</p>
</li>
<li> <p><code>window</code>: for <code style="white-space: pre;">&#8288;method = 'rollmean&#8288;</code> only; width of smoothing window in days
</p>
</li>
<li> <p><code>align</code>: for <code style="white-space: pre;">&#8288;method = 'rollmean&#8288;</code> only; smoothing alignment, either <code>'center'</code>, <code>'left'</code>, <code>'right'</code>
</p>
</li>
<li> <p><code>span</code>: for <code>method = 'loess'</code> only; smoothing span (see the documentation for <code><a href="stats.html#topic+loess">stats::loess()</a></code> for details)
</p>
</li>
<li> <p><code>floor</code>: optional call for wastewater concentration smoothing with <code>method = 'loess'</code> only; user defined minimum smoothing concentration
</p>
</li></ul>

<p>Set this entire list to <code>NULL</code> to turn off smoothing</p>
</td></tr>
<tr><td><code id="estimate_R_ww_+3A_prm.r">prm.R</code></td>
<td>
<p>List. Settings for the ensemble when calculating Rt.
Elements include:
</p>

<ul>
<li> <p><code>iter</code>: Integer. Number of iterations for the Rt ensemble
</p>
</li>
<li> <p><code>CI</code>: Numeric between 0 and 1. Confidence interval width for Rt
estimates after sampling uncertain distributions.
</p>
</li>
<li> <p><code>window</code>: Integer. Number of days defining the window of data used by
<code>EpiEstim</code> to estimate Rt. If <code>NULL</code>, will default to 7.
</p>
</li>
<li> <p><code>config.EpiEstim</code>: (optional) configuration for <code>EpiEstim</code> defined via
<code><a href="EpiEstim.html#topic+make_config">EpiEstim::make_config()</a></code>. If <code>NULL</code>, will use default config from
<code>EpiEstim</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_R_ww_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
<tr><td><code id="estimate_R_ww_+3A_rl.max.iter">RL.max.iter</code></td>
<td>
<p>Integer. Maximum of iterations for the Richardson-Lucy deconvolution algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Elements include:
</p>

<ul>
<li> <p><code>ww.conc</code>: original wastewater signal
</p>
</li>
<li> <p><code>ww.smooth</code>: smoothed wastewater signal
</p>
</li>
<li> <p><code>inc</code>: inferred incidence
</p>
</li>
<li> <p><code>R</code>: the effective reproduction number estimate
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot_diagnostic_ww">plot_diagnostic_ww()</a></code> <code><a href="#topic+estimate_R_cl">estimate_R_cl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Load data of viral concentration in wastewater
data("ww.data")

# Run the estimation of Rt based on the wastewater data
x = estimate_R_ww(
  ww.conc  = ww.data,
  dist.fec = ern::def_dist(
    dist = "gamma",
    mean = 12.90215,
    mean_sd = 1.136829,
    shape = 1.759937,
    shape_sd = 0.2665988,
    max = 33
    ),
  dist.gi  = ern::def_dist(
    dist     = "gamma",
    mean     = 6.84,
    mean_sd  = 0.7486,
    shape    = 2.39,
    shape_sd = 0.3573,
    max      = 15
    ), 
  silent   = TRUE
)

# Rt estimates
head(x$R)

# inferred daily incidence
head(x$inc)


</code></pre>

<hr>
<h2 id='extract_mcmc_values'>Extract MCMC chains from a JAGS object</h2><span id='topic+extract_mcmc_values'></span>

<h3>Description</h3>

<p>Extract MCMC chains from a JAGS object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_mcmc_values(chain, jags.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_mcmc_values_+3A_chain">chain</code></td>
<td>
<p>Integer. Chain number.</p>
</td></tr>
<tr><td><code id="extract_mcmc_values_+3A_jags.obj">jags.obj</code></td>
<td>
<p>JAGS object as returned by <code>code.sample()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of the chain values for selected parameters.
</p>

<hr>
<h2 id='fit_jags_aggreg'>Fit JAGS model to aggregated data</h2><span id='topic+fit_jags_aggreg'></span>

<h3>Description</h3>

<p>Fit JAGS model to aggregated data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_jags_aggreg(obs.times, Y, g, N, n.days = NULL, prm.daily, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_jags_aggreg_+3A_obs.times">obs.times</code></td>
<td>
<p>Numeric. Vector of observation times.</p>
</td></tr>
<tr><td><code id="fit_jags_aggreg_+3A_y">Y</code></td>
<td>
<p>Numeric. Vector of aggregated counts.</p>
</td></tr>
<tr><td><code id="fit_jags_aggreg_+3A_g">g</code></td>
<td>
<p>Numeric. Vector of discretized generation interval density.</p>
</td></tr>
<tr><td><code id="fit_jags_aggreg_+3A_n">N</code></td>
<td>
<p>Numeric. Scalar population size.</p>
</td></tr>
<tr><td><code id="fit_jags_aggreg_+3A_n.days">n.days</code></td>
<td>
<p>Numeric. Total number of days. if <code>NULL</code>, use <code>max(obs.times)</code></p>
</td></tr>
<tr><td><code id="fit_jags_aggreg_+3A_prm.daily">prm.daily</code></td>
<td>
<p>List. Parameters for daily report inference via MCMC. Elements include:
</p>

<ul>
<li> <p><code>method</code>: String. Method name to infer the daily incidence reports from aggregated ones.
Either <code>linear</code> or <code>renewal</code> is currently implemented.
The <code>linear</code> method simply performs a linear interpolation that matches the aggregated values.
The <code>renewal</code> method fits a SIR-like model using a renewal equation to infer the daily incidence.
In this case, the fitting algorithm is a Markov Chain Monte Carlo (MCMC) implemented in JAGS
and needs the parameters below (e.g., <code>burn,iter,chains,...</code>).
The <code>renewal</code> method is more adapted for short single wave epidemics as this models
i) naturally fits a single wave and ii) has longer computing time.
For longer time series, user may perfer the <code>linear</code> method.
</p>
</li>
<li> <p><code>popsize</code>: Integer. Population size to use in MCMC simulation to infer daily observations from aggregated input data.
</p>
</li>
<li> <p><code>burn</code>: Numeric. Length of burn-in period (number of days).
</p>
</li>
<li> <p><code>iter</code>: Numeric. Number of iterations after burn-in period (number of days).
</p>
</li>
<li> <p><code>chains</code>: Numeric. Number of chains to simulate.
</p>
</li>
<li> <p><code>prior_R0_shape</code>: Shape of the (hyper-)parameter for the prior Gamma distribution for R0.
</p>
</li>
<li> <p><code>prior_R0_rate</code>: Rate of the (hyper-)parameter for the prior Gamma distribution for R0.
</p>
</li>
<li> <p><code>prior_alpha_shape</code>: Shape of the (hyper-)parameter for the prior Gamma distribution for alpha.
</p>
</li>
<li> <p><code>prior_alpha_rate</code>: Rate of the (hyper-)parameter for the prior Gamma distribution for alpha.
</p>
</li>
<li> <p><code>first.agg.period</code>: length of aggregation period for first aggregated observation (number of days); if NULL, assume same aggregation period as observed for second observation (gap between first and second observations)
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_jags_aggreg_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
</table>

<hr>
<h2 id='get_discrete_dist'>Get a discretized, truncated version of a distribution</h2><span id='topic+get_discrete_dist'></span>

<h3>Description</h3>

<p>Get a discretized, truncated version of a distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_discrete_dist(params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_discrete_dist_+3A_params">params</code></td>
<td>
<p>distribution params (output of <code style="white-space: pre;">&#8288;def_dist_*()&#8288;</code> function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. Vector with discretized density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define distributions
fec = ern::def_dist(
  dist = "gamma",
  mean = 12.90215,
  mean_sd = 1.136829,
  shape = 1.759937,
  shape_sd = 0.2665988,
  max = 33
  )
gi  = ern::def_dist(
  dist     = "gamma",
  mean     = 6.84,
  mean_sd  = 0.7486,
  shape    = 2.39,
  shape_sd = 0.3573,
  max      = 15
  )

# Get their (discretized) densities
d.fec = get_discrete_dist(fec)
d.gi  = get_discrete_dist(gi)

print(d.fec)
print(d.gi)

</code></pre>

<hr>
<h2 id='get_realizations'>Retrieve realizations for aggregated to daily inference</h2><span id='topic+get_realizations'></span>

<h3>Description</h3>

<p>Retrieve realizations for aggregated to daily inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_realizations(fit.reports.daily, reports)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_realizations_+3A_fit.reports.daily">fit.reports.daily</code></td>
<td>
<p>Data frame. Realizations from daily report inference. Must at least have <code>t</code> (time index), <code>var</code> (variable name), <code>iteration</code> (realization number), and <code>value</code> (inferred count) columns.</p>
</td></tr>
<tr><td><code id="get_realizations_+3A_reports">reports</code></td>
<td>
<p>Data frame. Original aggregated reports. Must at least have <code>date</code> column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+agg_to_daily">agg_to_daily()</a></code>
</p>

<hr>
<h2 id='get_use_dates'>Get dates for which to use (trust) inferred daily reports</h2><span id='topic+get_use_dates'></span>

<h3>Description</h3>

<p>Get dates for which to use (trust) inferred daily reports
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_use_dates(cl.daily, cl.data, prm.daily.check, dates.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_use_dates_+3A_cl.daily">cl.daily</code></td>
<td>
<p>Data frame. Output of <code><a href="#topic+agg_to_daily">agg_to_daily()</a></code>.</p>
</td></tr>
<tr><td><code id="get_use_dates_+3A_cl.data">cl.data</code></td>
<td>
<p>Data frame. Must have variables:
</p>

<ul>
<li> <p><code>date</code>: calendar date of report
</p>
</li>
<li> <p><code>value</code>: count of reported cases
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_use_dates_+3A_prm.daily.check">prm.daily.check</code></td>
<td>
<p>List. Parameters for checking aggregated to daily report inference. Elements include:
</p>

<ul>
<li> <p><code>agg.reldiff.tol</code>: numerical tolerance (%) for relative error between aggregated inferred daily reports and original aggregated reports; chronological observations are dropped until this tolerance is first acheived (convergence at the start of the timeseries is often the worst, need to maintain uninterrupted daily timeseries for input into Rt calculation).
</p>
</li></ul>

<p>Set this entire argument to <code>NULL</code> to use inferred daily reports as is.</p>
</td></tr>
<tr><td><code id="get_use_dates_+3A_dates.only">dates.only</code></td>
<td>
<p>Logical. Return use dates only or all columns of <code>cl.daily</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame or vector, depending on <code>dates.only</code>
</p>

<hr>
<h2 id='inc2R_one_iter'>Helper function.
Converts wastewater to Rt after sampling one fecal shedding and
one generation interval distribution.</h2><span id='topic+inc2R_one_iter'></span>

<h3>Description</h3>

<p>Helper function.
Converts wastewater to Rt after sampling one fecal shedding and
one generation interval distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inc2R_one_iter(
  i,
  dist.fec,
  dist.gi,
  ww.conc,
  scaling.factor,
  prm.R,
  silent,
  RL.max.iter
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inc2R_one_iter_+3A_i">i</code></td>
<td>
<p>Numeric. Iteration index. (not used but required when using
<code>lapply()</code>)</p>
</td></tr>
<tr><td><code id="inc2R_one_iter_+3A_dist.fec">dist.fec</code></td>
<td>
<p>List. Parameters for the fecal shedding distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="inc2R_one_iter_+3A_dist.gi">dist.gi</code></td>
<td>
<p>List. Parameters for the generation interval distribution in the same format as returned by <code><a href="#topic+def_dist">def_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="inc2R_one_iter_+3A_ww.conc">ww.conc</code></td>
<td>
<p>Data frame. Must have variables:
</p>

<ul>
<li> <p><code>date</code>: calendar date of wastewater collection
</p>
</li>
<li> <p><code>value</code>: pathogen concentration
</p>
</li></ul>
</td></tr>
<tr><td><code id="inc2R_one_iter_+3A_scaling.factor">scaling.factor</code></td>
<td>
<p>Numeric. Scaling from wastewater concentration to
prevalence. This value may be assumed or independently calibrated to data.</p>
</td></tr>
<tr><td><code id="inc2R_one_iter_+3A_prm.r">prm.R</code></td>
<td>
<p>List. Settings for the ensemble when calculating Rt.
Elements include:
</p>

<ul>
<li> <p><code>iter</code>: Integer. Number of iterations for the Rt ensemble
</p>
</li>
<li> <p><code>CI</code>: Numeric between 0 and 1. Confidence interval width for Rt
estimates after sampling uncertain distributions.
</p>
</li>
<li> <p><code>window</code>: Integer. Number of days defining the window of data used by
<code>EpiEstim</code> to estimate Rt. If <code>NULL</code>, will default to 7.
</p>
</li>
<li> <p><code>config.EpiEstim</code>: (optional) configuration for <code>EpiEstim</code> defined via
<code><a href="EpiEstim.html#topic+make_config">EpiEstim::make_config()</a></code>. If <code>NULL</code>, will use default config from
<code>EpiEstim</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inc2R_one_iter_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
<tr><td><code id="inc2R_one_iter_+3A_rl.max.iter">RL.max.iter</code></td>
<td>
<p>Integer. Maximum of iterations for the Richardson-Lucy deconvolution algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Elements include <code>inc</code> (incidence) and <code>rt</code>
(reproduction number)
</p>

<hr>
<h2 id='incidence_to_R'>Estimate Rt using EpiEstim</h2><span id='topic+incidence_to_R'></span>

<h3>Description</h3>

<p>Estimate Rt using EpiEstim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incidence_to_R(incidence, generation.interval, prm.R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="incidence_to_R_+3A_incidence">incidence</code></td>
<td>
<p>Data frame. Estimated incidence. Must include at least
<code>date</code>, <code>I</code>, and <code>t</code> columns.</p>
</td></tr>
<tr><td><code id="incidence_to_R_+3A_generation.interval">generation.interval</code></td>
<td>
<p>List. Parameters for a single generation interval distribution, as generated by <code><a href="#topic+sample_a_dist">sample_a_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="incidence_to_R_+3A_prm.r">prm.R</code></td>
<td>
<p>List. Settings for the ensemble when calculating Rt.
Elements include:
</p>

<ul>
<li> <p><code>iter</code>: Integer. Number of iterations for the Rt ensemble
</p>
</li>
<li> <p><code>CI</code>: Numeric between 0 and 1. Confidence interval width for Rt
estimates after sampling uncertain distributions.
</p>
</li>
<li> <p><code>window</code>: Integer. Number of days defining the window of data used by
<code>EpiEstim</code> to estimate Rt. If <code>NULL</code>, will default to 7.
</p>
</li>
<li> <p><code>config.EpiEstim</code>: (optional) configuration for <code>EpiEstim</code> defined via
<code><a href="EpiEstim.html#topic+make_config">EpiEstim::make_config()</a></code>. If <code>NULL</code>, will use default config from
<code>EpiEstim</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+def_dist">def_dist()</a></code>
</p>
<p><code><a href="EpiEstim.html#topic+make_config">EpiEstim::make_config()</a></code>
</p>

<hr>
<h2 id='linear_int_daily'>Daily incidence from linear interpolation</h2><span id='topic+linear_int_daily'></span>

<h3>Description</h3>

<p>Daily incidence from linear interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_int_daily(cl.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_int_daily_+3A_cl.data">cl.data</code></td>
<td>
<p>Aggregated incidence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of daily incidence
</p>

<hr>
<h2 id='na_to_0'>Replace NAs with 0s in vector</h2><span id='topic+na_to_0'></span>

<h3>Description</h3>

<p>Replace NAs with 0s in vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_to_0(vec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na_to_0_+3A_vec">vec</code></td>
<td>
<p>Vector.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_diagnostic_cl'>Diagnostic plot for R estimation from clinical report data</h2><span id='topic+plot_diagnostic_cl'></span>

<h3>Description</h3>

<p>Diagnostic plot for R estimation from clinical report data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_diagnostic_cl(r.estim, caption = NULL, wrap.plots = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_diagnostic_cl_+3A_r.estim">r.estim</code></td>
<td>
<p>List. Output of <code><a href="#topic+estimate_R_cl">estimate_R_cl()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_diagnostic_cl_+3A_caption">caption</code></td>
<td>
<p>String. Caption to be inserted in the plot.
Default is <code>caption = NULL</code> which disables the caption.</p>
</td></tr>
<tr><td><code id="plot_diagnostic_cl_+3A_wrap.plots">wrap.plots</code></td>
<td>
<p>Logical. Wrap the plots together into a single ggplot object?
If <code>wrap.plots = TRUE</code> (the default) will return wrapped plots in a single object,
else will return a list of separate ggplot objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots of the clinical data used, the inferred daily incidence and
Rt estimates. If <code>wrap.plots = TRUE</code> (the default) will return
wrapped plots (with x-axis aligned to facilitate the comaprison)
in a single object,
else will return a list of separate ggplot objects.
</p>
<p>A <code>ggplot</code> object (or a list of ggplot objects
if <code>wrap.plots = FALSE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_R_cl">estimate_R_cl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# -- THIS EXAMPLE TAKES ABOUT 30 SECONDS TO RUN --
# Estimate Rt

## Not run: 
# Load SARS-CoV-2 reported cases in Quebec
# during the Summer 2021
dat &lt;- (ern::cl.data
    |&gt; dplyr::filter(
      pt == "qc", 
      dplyr::between(date, as.Date("2021-06-01"), as.Date("2021-09-01"))
    )
)
# distributions
dist.repdelay = ern::def_dist(
    dist = 'gamma',
    mean = 5, 
    mean_sd = 1,
    sd = 1,
    sd_sd = 0.1,
    max = 10
)
dist.repfrac = ern::def_dist(
    dist = "unif",
    min = 0.1,
    max = 0.3
)
dist.incub = ern::def_dist(
    dist = "gamma",
    mean = 3.49,
    mean_sd = 0.1477,
    shape = 8.5,
    shape_sd = 1.8945,
    max = 8
)
dist.gi = ern::def_dist(
    dist = "gamma",
    mean = 6,
    mean_sd = 0.75,
    shape = 2.4,
    shape_sd = 0.3,
    max = 10
)

# settings
prm.daily &lt;- list(
    method = "renewal",
    popsize = 8.5e6, # Q3 (July 1) 2022 estimate for Quebec
    burn = 500,
    iter = 500,
    chains = 2,
    prior_R0_shape = 1.1, prior_R0_rate = 0.6, 
    prior_alpha_shape = 1, prior_alpha_rate = 1
)
prm.daily.check &lt;- list(
    agg.reldiff.tol = 10
)
prm.smooth &lt;- list(
    method = "rollmean",
    align = "center",
    window = 7
)
prm.R &lt;- list(
    iter = 20, 
    CI = 0.95, 
    window = 7, 
    config.EpiEstim = NULL
)

x &lt;- estimate_R_cl(
  dat,
  dist.repdelay,
  dist.repfrac,
  dist.incub,
  dist.gi,
  prm.daily,
  prm.daily.check,
  prm.smooth,
  prm.R
)

# Diagnostic plot for Rt estimates 
# from clinical data
g = plot_diagnostic_cl(x)
plot(g)

g2 = plot_diagnostic_cl(x, caption = 'This is your caption', wrap.plots = FALSE)
plot(g2$clinical_data)
plot(g2$inferred_incidence)
plot(g2$Rt)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_diagnostic_ww'>Diagnostic plot for R estimation from wastewater data</h2><span id='topic+plot_diagnostic_ww'></span>

<h3>Description</h3>

<p>Diagnostic plot for R estimation from wastewater data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_diagnostic_ww(r.estim, caption = NULL, wrap.plots = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_diagnostic_ww_+3A_r.estim">r.estim</code></td>
<td>
<p>List. Output of <code><a href="#topic+estimate_R_ww">estimate_R_ww()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_diagnostic_ww_+3A_caption">caption</code></td>
<td>
<p>Character. Optional plot caption.</p>
</td></tr>
<tr><td><code id="plot_diagnostic_ww_+3A_wrap.plots">wrap.plots</code></td>
<td>
<p>Logical.
Wrap all diagnostic plots into one single ggplot object (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_R_ww">estimate_R_ww()</a></code> <code><a href="#topic+plot_diagnostic_cl">plot_diagnostic_cl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data of viral concentration in wastewater
data("ww.data")

# Estimate Rt based on wastewater data
x = estimate_R_ww(
  ww.conc  = ww.data,
  dist.fec = ern::def_dist(
    dist = "gamma",
    mean = 12.9,
    mean_sd = 1.13,
    shape = 1.75,
    shape_sd = 0.26,
    max = 33
    ),
  dist.gi  = ern::def_dist(
    dist     = "gamma",
    mean     = 6.84,
    mean_sd  = 0.74,
    shape    = 2.39,
    shape_sd = 0.35,
    max      = 15
    ), 
  silent   = TRUE
)

# Diagnostic plot
g = plot_diagnostic_ww(x)
plot(g)

g2 = plot_diagnostic_ww(x, wrap.plots = FALSE, caption = "This is your caption")
plot(g2$wastewater_data)
plot(g2$inferred_incidence)
plot(g2$Rt)


</code></pre>

<hr>
<h2 id='plot_dist'>Plot a distribution</h2><span id='topic+plot_dist'></span>

<h3>Description</h3>

<p>Plot a distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dist(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_dist_+3A_d">d</code></td>
<td>
<p>List that defines the distribution (as returned by <code>def_dist_incubation_period()</code> for example)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a `ern` distribution:
gi  = ern::def_dist(
  dist     = "gamma",
  mean     = 6.84,
  mean_sd  = 0.7486,
  shape    = 2.39,
  shape_sd = 0.3573,
  max      = 15
  )

# Plot can be customized like any `ggplot` object:
g = plot_dist(gi) + ggplot2::labs(subtitle = 'your subtitle')
plot(g)


</code></pre>

<hr>
<h2 id='plot_gelman_rubin'>Plot the Gelman Rubin statistic for all parameters.</h2><span id='topic+plot_gelman_rubin'></span>

<h3>Description</h3>

<p>Plot the Gelman Rubin statistic for all parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gelman_rubin(jags.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_gelman_rubin_+3A_jags.obj">jags.obj</code></td>
<td>
<p>JAGS object as returned by <code>code.sample()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> plot.
</p>

<hr>
<h2 id='plot_traces'>Plot MCMC traces</h2><span id='topic+plot_traces'></span>

<h3>Description</h3>

<p>Plot MCMC traces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_traces(jags.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_traces_+3A_jags.obj">jags.obj</code></td>
<td>
<p>JAGS object as returned by <code>code.sample()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> plot.
</p>

<hr>
<h2 id='reports_to_incidence'>Infer incidence from reports via a series of deconvolutions</h2><span id='topic+reports_to_incidence'></span>

<h3>Description</h3>

<p>Infer incidence from reports via a series of deconvolutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reports_to_incidence(
  reports.daily,
  reporting.delay,
  incubation.period,
  max.iter = 9,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reports_to_incidence_+3A_reports.daily">reports.daily</code></td>
<td>
<p>Data frame. Daily report counts. Includes at least <code>date</code> and <code>value</code> columns.</p>
</td></tr>
<tr><td><code id="reports_to_incidence_+3A_reporting.delay">reporting.delay</code></td>
<td>
<p>List. Parameters for a single reporting delay distribution, as generated by <code><a href="#topic+sample_a_dist">sample_a_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="reports_to_incidence_+3A_incubation.period">incubation.period</code></td>
<td>
<p>List. Parameters for a single incubation period distribution, as generated by <code><a href="#topic+sample_a_dist">sample_a_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="reports_to_incidence_+3A_max.iter">max.iter</code></td>
<td>
<p>Numeric. Maximum number of Richardson-Lucy iterations.</p>
</td></tr>
<tr><td><code id="reports_to_incidence_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
</table>

<hr>
<h2 id='reshape_fit_jags'>Reshape JAGS fit object</h2><span id='topic+reshape_fit_jags'></span>

<h3>Description</h3>

<p>Reshape JAGS fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_fit_jags(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reshape_fit_jags_+3A_x">x</code></td>
<td>
<p>Data frame. JAGS output from <code><a href="#topic+fit_jags_aggreg">fit_jags_aggreg()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='sample_a_dist'>Sample parameters for a single distribution from a family of
distributions, assuming parameters come from a Gamma distribution.</h2><span id='topic+sample_a_dist'></span>

<h3>Description</h3>

<p>Sample parameters for a single distribution from a family of
distributions, assuming parameters come from a Gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_a_dist(dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_a_dist_+3A_dist">dist</code></td>
<td>
<p>List. A list of distribution parameters, as defined by
<code>def_dist()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='sample_from_dist'>Sample from a distribution
(currently only implemented for a uniform distribution)</h2><span id='topic+sample_from_dist'></span>

<h3>Description</h3>

<p>Sample from a distribution
(currently only implemented for a uniform distribution)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_from_dist(n, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_from_dist_+3A_n">n</code></td>
<td>
<p>number of samples to draw</p>
</td></tr>
<tr><td><code id="sample_from_dist_+3A_params">params</code></td>
<td>
<p>distribution parameters</p>
</td></tr>
</table>

<hr>
<h2 id='sample_post_ee'>Helper function - sample from EpiEstim's R posterior distribution</h2><span id='topic+sample_post_ee'></span>

<h3>Description</h3>

<p>Helper function - sample from EpiEstim's R posterior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_post_ee(window, objee, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_post_ee_+3A_window">window</code></td>
<td>
<p>integer. Time slice used to estimate Rt.</p>
</td></tr>
<tr><td><code id="sample_post_ee_+3A_objee">objee</code></td>
<td>
<p>List. EpiEstim object as returned by EpiEstim::estimate_R</p>
</td></tr>
<tr><td><code id="sample_post_ee_+3A_n">n</code></td>
<td>
<p>integer. Number of posterior samples drawn.</p>
</td></tr>
</table>

<hr>
<h2 id='smooth_cl'>Smooth realizations from estimating daily reports</h2><span id='topic+smooth_cl'></span>

<h3>Description</h3>

<p>Smooth realizations from estimating daily reports
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_cl(cl.daily, prm.smooth)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_cl_+3A_cl.daily">cl.daily</code></td>
<td>
<p>Data frame. Output of <code><a href="#topic+agg_to_daily">agg_to_daily()</a></code>.</p>
</td></tr>
<tr><td><code id="smooth_cl_+3A_prm.smooth">prm.smooth</code></td>
<td>
<p>List. list of smoothing parameters. Parameters should be
specified as followed:
</p>

<ul>
<li> <p><code>method</code>: smoothing method, either <code>'rollmean'</code> (rolling mean) or <code>'loess'</code> (LOESS smoothing via <code><a href="stats.html#topic+loess">stats::loess()</a></code>)
</p>
</li>
<li> <p><code>window</code>: for <code style="white-space: pre;">&#8288;method = 'rollmean&#8288;</code> only; width of smoothing window in days
</p>
</li>
<li> <p><code>align</code>: for <code style="white-space: pre;">&#8288;method = 'rollmean&#8288;</code> only; smoothing alignment, either <code>'center'</code>, <code>'left'</code>, <code>'right'</code>
</p>
</li>
<li> <p><code>span</code>: for <code>method = 'loess'</code> only; smoothing span (see the documentation for <code><a href="stats.html#topic+loess">stats::loess()</a></code> for details)
</p>
</li>
<li> <p><code>floor</code>: optional call for wastewater concentration smoothing with <code>method = 'loess'</code> only; user defined minimum smoothing concentration
</p>
</li></ul>

<p>Set this entire list to <code>NULL</code> to turn off smoothing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame
</p>

<hr>
<h2 id='smooth_ww'>Smooth wastewater data (using pre-processed wastewater)</h2><span id='topic+smooth_ww'></span>

<h3>Description</h3>

<p>Smooth wastewater data (using pre-processed wastewater)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_ww(ww.conc, prm.smooth, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_ww_+3A_ww.conc">ww.conc</code></td>
<td>
<p>Data frame. Must have variables:
</p>

<ul>
<li> <p><code>date</code>: calendar date of wastewater collection
</p>
</li>
<li> <p><code>value</code>: pathogen concentration
</p>
</li></ul>
</td></tr>
<tr><td><code id="smooth_ww_+3A_prm.smooth">prm.smooth</code></td>
<td>
<p>List. list of smoothing parameters. Parameters should be
specified as followed:
</p>

<ul>
<li> <p><code>method</code>: smoothing method, either <code>'rollmean'</code> (rolling mean) or <code>'loess'</code> (LOESS smoothing via <code><a href="stats.html#topic+loess">stats::loess()</a></code>)
</p>
</li>
<li> <p><code>window</code>: for <code style="white-space: pre;">&#8288;method = 'rollmean&#8288;</code> only; width of smoothing window in days
</p>
</li>
<li> <p><code>align</code>: for <code style="white-space: pre;">&#8288;method = 'rollmean&#8288;</code> only; smoothing alignment, either <code>'center'</code>, <code>'left'</code>, <code>'right'</code>
</p>
</li>
<li> <p><code>span</code>: for <code>method = 'loess'</code> only; smoothing span (see the documentation for <code><a href="stats.html#topic+loess">stats::loess()</a></code> for details)
</p>
</li>
<li> <p><code>floor</code>: optional call for wastewater concentration smoothing with <code>method = 'loess'</code> only; user defined minimum smoothing concentration
</p>
</li></ul>

<p>Set this entire list to <code>NULL</code> to turn off smoothing</p>
</td></tr>
<tr><td><code id="smooth_ww_+3A_silent">silent</code></td>
<td>
<p>Logical. Flag to suppress all output messages, warnings, and progress bars.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame
</p>

<hr>
<h2 id='summarise_by_date_iters'>Summarise observations by date for raw iterations from an ensemble</h2><span id='topic+summarise_by_date_iters'></span>

<h3>Description</h3>

<p>Summarise observations by date for raw iterations from an ensemble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_by_date_iters(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise_by_date_iters_+3A_df">df</code></td>
<td>
<p>Data frame. Must have <code>date</code> and <code>value</code> columns.</p>
</td></tr>
</table>

<hr>
<h2 id='summarise_report_counts'>Summarise daily inferred reports
based on original reporting schedule and calculate error</h2><span id='topic+summarise_report_counts'></span>

<h3>Description</h3>

<p>Summarise daily inferred reports
based on original reporting schedule and calculate error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_report_counts(df, prm.daily.check)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise_report_counts_+3A_df">df</code></td>
<td>
<p>Data frame. As output by <code><a href="#topic+get_use_dates">get_use_dates()</a></code>.</p>
</td></tr>
<tr><td><code id="summarise_report_counts_+3A_prm.daily.check">prm.daily.check</code></td>
<td>
<p>List. Parameters for checking aggregated to daily report inference. Elements include:
</p>

<ul>
<li> <p><code>agg.reldiff.tol</code>: numerical tolerance (%) for relative error between aggregated inferred daily reports and original aggregated reports; chronological observations are dropped until this tolerance is first acheived (convergence at the start of the timeseries is often the worst, need to maintain uninterrupted daily timeseries for input into Rt calculation).
</p>
</li></ul>

<p>Set this entire argument to <code>NULL</code> to use inferred daily reports as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame
</p>

<hr>
<h2 id='summary_postsamples'>Helper function that summarises
posterior samples of Rt from EpiEstim</h2><span id='topic+summary_postsamples'></span>

<h3>Description</h3>

<p>Helper function that summarises
posterior samples of Rt from EpiEstim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_postsamples(x, prm.R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_postsamples_+3A_x">x</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="summary_postsamples_+3A_prm.r">prm.R</code></td>
<td>
<p>list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summarised dataframe
</p>

<hr>
<h2 id='ww.data'>Sample of wastewater concentration</h2><span id='topic+ww.data'></span>

<h3>Description</h3>

<p>A subset of SARS-CoV-2 (N2 gene) concentration data in
wastewater sampled from the Iona Island wastewater treatment plant
in Vancouver between 7 July 2023 and 5 November 2023.
Units are in N2 gene copies per milliliter of wastewater.
Concentration was measured using RT-qPCR assays; RNA was extracted from
suspended solids.
See <a href="https://health-infobase.canada.ca/covid-19/wastewater/">https://health-infobase.canada.ca/covid-19/wastewater/</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww.data
</code></pre>


<h3>Format</h3>



<h4><code>ww.data</code></h4>

<p>A data frame with 47 rows and 3 columns:
</p>

<ul>
<li> <p><code>date</code>: sampling date
</p>
</li>
<li> <p><code>value</code>: mean sample concentration between multiple replicates
</p>
</li></ul>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
