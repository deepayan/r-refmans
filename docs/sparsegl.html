<!DOCTYPE html><html><head><title>Help for package sparsegl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparsegl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#coef.cv.sparsegl'><p>Extract coefficients from a <code>cv.sparsegl</code> object.</p></a></li>
<li><a href='#coef.sparsegl'><p>Extract model coefficients from a <code>sparsegl</code> object.</p></a></li>
<li><a href='#cv.sparsegl'><p>Cross-validation for a <code>sparsegl</code> object.</p></a></li>
<li><a href='#estimate_risk'><p>Calculate information criteria.</p></a></li>
<li><a href='#make_irls_warmup'><p>Create starting values for iterative reweighted least squares</p></a></li>
<li><a href='#plot.cv.sparsegl'><p>Plot cross-validation curves produced from a <code>cv.sparsegl</code> object.</p></a></li>
<li><a href='#plot.sparsegl'><p>Plot solution paths from a <code>sparsegl</code> object.</p></a></li>
<li><a href='#predict.cv.sparsegl'><p>Make predictions from a <code>cv.sparsegl</code> object.</p></a></li>
<li><a href='#predict.sparsegl'><p>Make predictions from a <code>sparsegl</code> object.</p></a></li>
<li><a href='#sparsegl'><p>Regularization paths for sparse group-lasso models</p></a></li>
<li><a href='#trust_experts'><p>Trust in scientific experts during the Covid-19 pandemic</p></a></li>
<li><a href='#zero_norm'><p>Calculate common norms</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Group Lasso</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-17</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient implementation of sparse group lasso with optional
    bound constraints on the coefficients. It supports the use of a sparse
    design matrix as well as returning coefficient estimates in a sparse
    matrix. Furthermore, it correctly calculates the degrees of freedom to
    allow for information criteria rather than cross-validation with very
    large data. Finally, the interface to compiled code avoids unnecessary
    copies and allows for the use of long integers.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dajmcdon/sparsegl/">https://github.com/dajmcdon/sparsegl/</a>,
<a href="https://dajmcdon.github.io/sparsegl/">https://dajmcdon.github.io/sparsegl/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dajmcdon/sparsegl/issues/">https://github.com/dajmcdon/sparsegl/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dotCall64, ggplot2, magrittr, Matrix, methods, rlang,
RSpectra, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, gglasso, glmnet, knitr, markdown, rmarkdown, splines,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-25 16:23:51 UTC; dajmcdon</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel J. McDonald [aut, cre],
  Xiaoxuan Liang [aut],
  Anibal Solón Heinsfeld [aut],
  Aaron Cohen [aut],
  Yi Yang [ctb],
  Hui Zou [ctb],
  Jerome Friedman [ctb],
  Trevor Hastie [ctb],
  Rob Tibshirani [ctb],
  Balasubramanian Narasimhan [ctb],
  Kenneth Tay [ctb],
  Noah Simon [ctb],
  Junyang Qian [ctb],
  James Yang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel J. McDonald &lt;daniel@stat.ubc.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-25 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='coef.cv.sparsegl'>Extract coefficients from a <code>cv.sparsegl</code> object.</h2><span id='topic+coef.cv.sparsegl'></span>

<h3>Description</h3>

<p>This function etracts coefficients from a
cross-validated <code><a href="#topic+sparsegl">sparsegl()</a></code> model, using the stored <code>"sparsegl.fit"</code>
object, and the optimal value chosen for <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.sparsegl'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cv.sparsegl_+3A_object">object</code></td>
<td>
<p>Fitted <code><a href="#topic+cv.sparsegl">cv.sparsegl()</a></code> object.</p>
</td></tr>
<tr><td><code id="coef.cv.sparsegl_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
coefficients are desired. Default is the single
value <code>s = "lambda.1se"</code> stored in the CV object (corresponding to
the largest value of <code>lambda</code> such that CV error estimate is within 1
standard error of the minimum). Alternatively <code>s = "lambda.min"</code> can be
used (corresponding to the minimum of cross validation error estimate).
If <code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be used.</p>
</td></tr>
<tr><td><code id="coef.cv.sparsegl_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coefficients at the requested value(s) for <code>lambda</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.sparsegl">cv.sparsegl()</a></code> and <code><a href="#topic+predict.cv.sparsegl">predict.cv.sparsegl()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
fit1 &lt;- sparsegl(X, y, group = groups)
cv_fit &lt;- cv.sparsegl(X, y, groups)
coef(cv_fit, s = c(0.02, 0.03))
</code></pre>

<hr>
<h2 id='coef.sparsegl'>Extract model coefficients from a <code>sparsegl</code> object.</h2><span id='topic+coef.sparsegl'></span>

<h3>Description</h3>

<p>Computes the coefficients at the requested value(s) for <code>lambda</code> from a
<code><a href="#topic+sparsegl">sparsegl()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparsegl'
coef(object, s = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.sparsegl_+3A_object">object</code></td>
<td>
<p>Fitted <code><a href="#topic+sparsegl">sparsegl()</a></code> object.</p>
</td></tr>
<tr><td><code id="coef.sparsegl_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
coefficients are required. Default is the entire sequence.</p>
</td></tr>
<tr><td><code id="coef.sparsegl_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector of <code>lambda</code> values at which predictions are requested.
If <code>s</code> is not in the lambda sequence used for fitting the model, the <code>coef</code>
function will use linear interpolation to make predictions. The new values
are interpolated using a fraction of coefficients from both left and right
<code>lambda</code> indices.
</p>


<h3>Value</h3>

<p>The coefficients at the requested values for <code>lambda</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparsegl">sparsegl()</a></code> and <code><a href="#topic+predict.sparsegl">predict.sparsegl()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
fit1 &lt;- sparsegl(X, y, group = groups)
coef(fit1, s = c(0.02, 0.03))
</code></pre>

<hr>
<h2 id='cv.sparsegl'>Cross-validation for a <code>sparsegl</code> object.</h2><span id='topic+cv.sparsegl'></span>

<h3>Description</h3>

<p>Performs k-fold cross-validation for <code><a href="#topic+sparsegl">sparsegl()</a></code>.
This function is largely similar <code><a href="glmnet.html#topic+cv.glmnet">glmnet::cv.glmnet()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.sparsegl(
  x,
  y,
  group = NULL,
  family = c("gaussian", "binomial"),
  lambda = NULL,
  pred.loss = c("default", "mse", "deviance", "mae", "misclass"),
  nfolds = 10,
  foldid = NULL,
  weights = NULL,
  offset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.sparsegl_+3A_x">x</code></td>
<td>
<p>Double. A matrix of predictors, of dimension
<code class="reqn">n \times p</code>; each row
is a vector of measurements and each column is a feature. Objects of class
<code><a href="Matrix.html#topic+sparseMatrix">Matrix::sparseMatrix</a></code> are supported.</p>
</td></tr>
<tr><td><code id="cv.sparsegl_+3A_y">y</code></td>
<td>
<p>Double/Integer/Factor. The response variable.
Quantitative for <code>family="gaussian"</code> and for other exponential families.
If <code>family="binomial"</code> should be either a factor with two levels or
a vector of integers taking 2 unique values. For a factor, the last level
in alphabetical order is the target class.</p>
</td></tr>
<tr><td><code id="cv.sparsegl_+3A_group">group</code></td>
<td>
<p>Integer. A vector of consecutive integers describing the
grouping of the coefficients (see example below).</p>
</td></tr>
<tr><td><code id="cv.sparsegl_+3A_family">family</code></td>
<td>
<p>Character or function. Specifies the generalized linear model
to use. Valid options are:
</p>

<ul>
<li> <p><code>"gaussian"</code> - least squares loss (regression, the default),
</p>
</li>
<li> <p><code>"binomial"</code> - logistic loss (classification)
</p>
</li></ul>

<p>For any other type, a valid <code><a href="stats.html#topic+family">stats::family()</a></code> object may be passed. Note
that these will generally be much slower to estimate than the built-in
options passed as strings. So for example, <code>family = "gaussian"</code> and
<code>family = gaussian()</code> will produce the same results, but the first
will be much faster.</p>
</td></tr>
<tr><td><code id="cv.sparsegl_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence. The default, <code>NULL</code>
results in an automatic computation based on <code>nlambda</code>, the smallest value
of <code>lambda</code> that would give the null model (all coefficient estimates equal
to zero), and <code>lambda.factor</code>. Supplying a value of <code>lambda</code> overrides
this behaviour. It is likely better to supply a
decreasing sequence of <code>lambda</code> values than a single (small) value. If
supplied, the user-defined <code>lambda</code> sequence is automatically sorted in
decreasing order.</p>
</td></tr>
<tr><td><code id="cv.sparsegl_+3A_pred.loss">pred.loss</code></td>
<td>
<p>Loss to use for cross-validation error. Valid options are:
</p>

<ul>
<li> <p><code>"default"</code> the same as deviance (mse for regression and deviance otherwise)
</p>
</li>
<li> <p><code>"mse"</code> mean square error
</p>
</li>
<li> <p><code>"deviance"</code> the default (mse for Gaussian regression, and negative
log-likelihood otherwise)
</p>
</li>
<li> <p><code>"mae"</code> mean absolute error, can apply to any family
</p>
</li>
<li> <p><code>"misclass"</code> for classification only, misclassification error.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cv.sparsegl_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds - default is 10. Although <code>nfolds</code> can be
as large as the sample size (leave-one-out CV), it is not recommended for
large datasets. Smallest value allowable is <code>nfolds = 3</code>.</p>
</td></tr>
<tr><td><code id="cv.sparsegl_+3A_foldid">foldid</code></td>
<td>
<p>An optional vector of values between 1 and <code>nfolds</code>
identifying which fold each observation is in. If supplied, <code>nfolds</code> can
be missing.</p>
</td></tr>
<tr><td><code id="cv.sparsegl_+3A_weights">weights</code></td>
<td>
<p>Double vector. Optional observation weights. These can
only be used with a <code><a href="stats.html#topic+family">stats::family()</a></code> object.</p>
</td></tr>
<tr><td><code id="cv.sparsegl_+3A_offset">offset</code></td>
<td>
<p>Double vector. Optional offset (constant predictor without a
corresponding coefficient). These can only be used with a
<code><a href="stats.html#topic+family">stats::family()</a></code> object.</p>
</td></tr>
<tr><td><code id="cv.sparsegl_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+sparsegl">sparsegl()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code><a href="#topic+sparsegl">sparsegl()</a></code> <code>nfolds + 1</code> times; the first to
get the <code>lambda</code> sequence, and then the remainder to compute the fit
with each of the folds omitted. The average error and standard error
over the folds are computed.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+cv.sparsegl">cv.sparsegl()</a></code> is returned, which is a
list with the components describing the cross-validation error.
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>The values of <code>lambda</code> used in the fits.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>The mean cross-validated error - a vector of
length <code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>Estimate of standard error of <code>cvm</code>.</p>
</td></tr>
<tr><td><code>cvupper</code></td>
<td>
<p>Upper curve = <code>cvm + cvsd</code>.</p>
</td></tr>
<tr><td><code>cvlower</code></td>
<td>
<p>Lower curve = <code>cvm - cvsd</code>.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>A text string indicating type of measure (for plotting
purposes).</p>
</td></tr>
<tr><td><code>nnzero</code></td>
<td>
<p>The number of non-zero coefficients for each <code>lambda</code></p>
</td></tr>
<tr><td><code>active_grps</code></td>
<td>
<p>The number of active groups for each <code>lambda</code></p>
</td></tr>
<tr><td><code>sparsegl.fit</code></td>
<td>
<p>A fitted <code><a href="#topic+sparsegl">sparsegl()</a></code> object for the full data.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>The optimal value of <code>lambda</code> that gives
minimum cross validation error <code>cvm</code>.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>The largest value of <code>lambda</code> such that error
is within 1 standard error of the minimum.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sparsegl">sparsegl()</a></code>, as well as <code><a href="#topic+plot.cv.sparsegl">plot()</a></code>,
<code><a href="#topic+predict.cv.sparsegl">predict()</a></code>, and <code><a href="#topic+coef.cv.sparsegl">coef()</a></code>
methods for <code>"cv.sparsegl"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
cv_fit &lt;- cv.sparsegl(X, y, groups)

</code></pre>

<hr>
<h2 id='estimate_risk'>Calculate information criteria.</h2><span id='topic+estimate_risk'></span>

<h3>Description</h3>

<p>This function uses the degrees of freedom to calculate various information
criteria. This function uses the &quot;unknown variance&quot; version of the likelihood.
Only implemented for Gaussian regression. The constant is ignored (as in
<code><a href="stats.html#topic+extractAIC">stats::extractAIC()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_risk(object, x, type = c("AIC", "BIC", "GCV"), approx_df = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_risk_+3A_object">object</code></td>
<td>
<p>fitted object from a call to <code><a href="#topic+sparsegl">sparsegl()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_risk_+3A_x">x</code></td>
<td>
<p>Matrix. The matrix of predictors used to estimate
the <code>sparsegl</code> object. May be missing if <code>approx_df = TRUE</code>.</p>
</td></tr>
<tr><td><code id="estimate_risk_+3A_type">type</code></td>
<td>
<p>one or more of AIC, BIC, or GCV.</p>
</td></tr>
<tr><td><code id="estimate_risk_+3A_approx_df">approx_df</code></td>
<td>
<p>the <code>df</code> component of a <code>sparsegl</code> object is an
approximation (albeit a fairly accurate one) to the actual degrees-of-freedom.
However, the exact value requires inverting a portion of <code style="white-space: pre;">&#8288;X'X&#8288;</code>. So this
computation may take some time (the default computes the exact df).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with as many rows as <code>object$lambda</code>. It contains
columns <code>lambda</code>, <code>df</code>, and the requested risk types.
</p>


<h3>References</h3>

<p>Vaiter S, Deledalle C, Peyré G, Fadili J, Dossal C. (2012). <em>The
Degrees of Freedom of the Group Lasso for a General Design</em>.
<a href="https://arxiv.org/pdf/1212.6478.pdf">https://arxiv.org/pdf/1212.6478.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparsegl">sparsegl()</a></code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
fit1 &lt;- sparsegl(X, y, group = groups)
estimate_risk(fit1, type = "AIC", approx_df = TRUE)
</code></pre>

<hr>
<h2 id='make_irls_warmup'>Create starting values for iterative reweighted least squares</h2><span id='topic+make_irls_warmup'></span>

<h3>Description</h3>

<p>This function may be used to create potentially valid starting
values for calling <code><a href="#topic+sparsegl">sparsegl()</a></code> with a <code><a href="stats.html#topic+family">stats::family()</a></code> object.
It is not typically necessary to call this function (as it is used
internally to create some), but in some cases, especially with custom
generalized linear models, it may improve performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_irls_warmup(nobs, nvars, b0 = 0, beta = double(nvars), r = double(nobs))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_irls_warmup_+3A_nobs">nobs</code></td>
<td>
<p>Number of observations in the response (or rows in <code>x</code>).</p>
</td></tr>
<tr><td><code id="make_irls_warmup_+3A_nvars">nvars</code></td>
<td>
<p>Number of columns in <code>x</code></p>
</td></tr>
<tr><td><code id="make_irls_warmup_+3A_b0">b0</code></td>
<td>
<p>Scalar. Initial value for the intercept.</p>
</td></tr>
<tr><td><code id="make_irls_warmup_+3A_beta">beta</code></td>
<td>
<p>Vector. Initial values for the coefficients. Must be length
<code>nvars</code> (or a scalar).</p>
</td></tr>
<tr><td><code id="make_irls_warmup_+3A_r">r</code></td>
<td>
<p>Vector. Initial values for the deviance residuals. Must be length
<code>nobs</code> (or a scalar).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Occasionally, the irls fitting routine may fail with an admonition to
create valid starting values.
</p>


<h3>Value</h3>

<p>List of class <code>irlsspgl_warmup</code>
</p>

<hr>
<h2 id='plot.cv.sparsegl'>Plot cross-validation curves produced from a <code>cv.sparsegl</code> object.</h2><span id='topic+plot.cv.sparsegl'></span>

<h3>Description</h3>

<p>Plots the cross-validation curve, and upper and lower standard deviation
curves, as a function of the <code>lambda</code> values used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.sparsegl'
plot(x, log_axis = c("xy", "x", "y", "none"), sign.lambda = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cv.sparsegl_+3A_x">x</code></td>
<td>
<p>Fitted <code>"cv.sparsegl"</code> object, produced with <code><a href="#topic+cv.sparsegl">cv.sparsegl()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cv.sparsegl_+3A_log_axis">log_axis</code></td>
<td>
<p>Apply log scaling to the requested axes.</p>
</td></tr>
<tr><td><code id="plot.cv.sparsegl_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>Either plot against <code>log(lambda)</code> (default) or the
reverse if <code>sign.lambda &lt; 0</code>.</p>
</td></tr>
<tr><td><code id="plot.cv.sparsegl_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> plot is produced. Additional user
modifications may be added as desired.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.sparsegl">cv.sparsegl()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
cv_fit &lt;- cv.sparsegl(X, y, groups)
plot(cv_fit)
</code></pre>

<hr>
<h2 id='plot.sparsegl'>Plot solution paths from a <code>sparsegl</code> object.</h2><span id='topic+plot.sparsegl'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of a fitted
<code><a href="#topic+sparsegl">sparsegl()</a></code> object. The result is a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>. Additional user
modifications can be added as desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparsegl'
plot(
  x,
  y_axis = c("coef", "group"),
  x_axis = c("lambda", "penalty"),
  add_legend = n_legend_values &lt; 20,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sparsegl_+3A_x">x</code></td>
<td>
<p>Fitted <code>"sparsegl"</code> object, produced by <code><a href="#topic+sparsegl">sparsegl()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.sparsegl_+3A_y_axis">y_axis</code></td>
<td>
<p>Variable on the y_axis. Either the coefficients (default)
or the group norm.</p>
</td></tr>
<tr><td><code id="plot.sparsegl_+3A_x_axis">x_axis</code></td>
<td>
<p>Variable on the x-axis. Either the (log)-lambda
sequence (default) or the value of the penalty. In the second case,
the penalty is scaled by its maximum along the path.</p>
</td></tr>
<tr><td><code id="plot.sparsegl_+3A_add_legend">add_legend</code></td>
<td>
<p>Show the legend. Often, with many groups/predictors, this
can become overwhelming. The default produces a legend if the number of
groups/predictors is less than 20.</p>
</td></tr>
<tr><td><code id="plot.sparsegl_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sparsegl">sparsegl()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
fit1 &lt;- sparsegl(X, y, group = groups)
plot(fit1, y_axis = "coef", x_axis = "penalty")
</code></pre>

<hr>
<h2 id='predict.cv.sparsegl'>Make predictions from a <code>cv.sparsegl</code> object.</h2><span id='topic+predict.cv.sparsegl'></span>

<h3>Description</h3>

<p>This function makes predictions from a cross-validated <code><a href="#topic+cv.sparsegl">cv.sparsegl()</a></code> object,
using the stored <code>sparsegl.fit</code> object, and the value chosen for <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.sparsegl'
predict(
  object,
  newx,
  s = c("lambda.1se", "lambda.min"),
  type = c("link", "response", "coefficients", "nonzero", "class"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.sparsegl_+3A_object">object</code></td>
<td>
<p>Fitted <code><a href="#topic+cv.sparsegl">cv.sparsegl()</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.cv.sparsegl_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for <code>x</code> at which predictions are to be
made. Must be a matrix. This argument is mandatory.</p>
</td></tr>
<tr><td><code id="predict.cv.sparsegl_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
coefficients are desired. Default is the single
value <code>s = "lambda.1se"</code> stored in the CV object (corresponding to
the largest value of <code>lambda</code> such that CV error estimate is within 1
standard error of the minimum). Alternatively <code>s = "lambda.min"</code> can be
used (corresponding to the minimum of cross validation error estimate).
If <code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be used.</p>
</td></tr>
<tr><td><code id="predict.cv.sparsegl_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type <code>"link"</code> gives the linear
predictors for <code>"binomial"</code>; for <code>"gaussian"</code> models it gives the fitted
values. Type <code>"response"</code> gives predictions on the scale of the response
(for example, fitted probabilities for <code>"binomial"</code>); for <code>"gaussian"</code> type
<code>"response"</code> is equivalent to type <code>"link"</code>. Type
<code>"coefficients"</code> computes the coefficients at the requested values for
<code>s</code>.
Type <code>"class"</code> applies only to <code>"binomial"</code> models, and produces the
class label corresponding to
the maximum probability. Type <code>"nonzero"</code> returns a list of the indices
of the nonzero coefficients for each value of <code>s</code>.</p>
</td></tr>
<tr><td><code id="predict.cv.sparsegl_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or vector of predicted values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.sparsegl">cv.sparsegl()</a></code> and <code><a href="#topic+coef.cv.sparsegl">coef.cv.sparsegl()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
fit1 &lt;- sparsegl(X, y, group = groups)
cv_fit &lt;- cv.sparsegl(X, y, groups)
predict(cv_fit, newx = X[50:60, ], s = "lambda.min")

</code></pre>

<hr>
<h2 id='predict.sparsegl'>Make predictions from a <code>sparsegl</code> object.</h2><span id='topic+predict.sparsegl'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this function produces fitted values and
class labels from a fitted <code><a href="#topic+sparsegl">sparsegl</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparsegl'
predict(
  object,
  newx,
  s = NULL,
  type = c("link", "response", "coefficients", "nonzero", "class"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sparsegl_+3A_object">object</code></td>
<td>
<p>Fitted <code><a href="#topic+sparsegl">sparsegl()</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.sparsegl_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for <code>x</code> at which predictions are to be
made. Must be a matrix. This argument is mandatory.</p>
</td></tr>
<tr><td><code id="predict.sparsegl_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the entire sequence used to create the
model.</p>
</td></tr>
<tr><td><code id="predict.sparsegl_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type <code>"link"</code> gives the linear
predictors for <code>"binomial"</code>; for <code>"gaussian"</code> models it gives the fitted
values. Type <code>"response"</code> gives predictions on the scale of the response
(for example, fitted probabilities for <code>"binomial"</code>); for <code>"gaussian"</code> type
<code>"response"</code> is equivalent to type <code>"link"</code>. Type
<code>"coefficients"</code> computes the coefficients at the requested values for
<code>s</code>.
Type <code>"class"</code> applies only to <code>"binomial"</code> models, and produces the
class label corresponding to
the maximum probability. Type <code>"nonzero"</code> returns a list of the indices
of the nonzero coefficients for each value of <code>s</code>.</p>
</td></tr>
<tr><td><code id="predict.sparsegl_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector of <code>lambda</code> values at which predictions are requested.
If <code>s</code> is not in the lambda sequence used for fitting the model, the <code>coef</code>
function will use linear interpolation to make predictions. The new values
are interpolated using a fraction of coefficients from both left and right
<code>lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparsegl">sparsegl()</a></code>, <code><a href="#topic+coef.sparsegl">coef.sparsegl()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
fit1 &lt;- sparsegl(X, y, group = groups)
predict(fit1, newx = X[10, ], s = fit1$lambda[3:5])
</code></pre>

<hr>
<h2 id='sparsegl'>Regularization paths for sparse group-lasso models</h2><span id='topic+sparsegl'></span>

<h3>Description</h3>

<p>Fits regularization paths for sparse group-lasso penalized learning problems at a
sequence of regularization parameters <code>lambda</code>.
Note that the objective function for least squares is
</p>
<p style="text-align: center;"><code class="reqn">RSS/(2n) + \lambda penalty</code>
</p>

<p>Users can also tweak the penalty by choosing a different penalty factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsegl(
  x,
  y,
  group = NULL,
  family = c("gaussian", "binomial"),
  nlambda = 100,
  lambda.factor = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  pf_group = sqrt(bs),
  pf_sparse = rep(1, nvars),
  intercept = TRUE,
  asparse = 0.05,
  standardize = TRUE,
  lower_bnd = -Inf,
  upper_bnd = Inf,
  weights = NULL,
  offset = NULL,
  warm = NULL,
  trace_it = 0,
  dfmax = as.integer(max(group)) + 1L,
  pmax = min(dfmax * 1.2, as.integer(max(group))),
  eps = 1e-08,
  maxit = 3e+06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsegl_+3A_x">x</code></td>
<td>
<p>Double. A matrix of predictors, of dimension
<code class="reqn">n \times p</code>; each row
is a vector of measurements and each column is a feature. Objects of class
<code><a href="Matrix.html#topic+sparseMatrix">Matrix::sparseMatrix</a></code> are supported.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_y">y</code></td>
<td>
<p>Double/Integer/Factor. The response variable.
Quantitative for <code>family="gaussian"</code> and for other exponential families.
If <code>family="binomial"</code> should be either a factor with two levels or
a vector of integers taking 2 unique values. For a factor, the last level
in alphabetical order is the target class.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_group">group</code></td>
<td>
<p>Integer. A vector of consecutive integers describing the
grouping of the coefficients (see example below).</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_family">family</code></td>
<td>
<p>Character or function. Specifies the generalized linear model
to use. Valid options are:
</p>

<ul>
<li> <p><code>"gaussian"</code> - least squares loss (regression, the default),
</p>
</li>
<li> <p><code>"binomial"</code> - logistic loss (classification)
</p>
</li></ul>

<p>For any other type, a valid <code><a href="stats.html#topic+family">stats::family()</a></code> object may be passed. Note
that these will generally be much slower to estimate than the built-in
options passed as strings. So for example, <code>family = "gaussian"</code> and
<code>family = gaussian()</code> will produce the same results, but the first
will be much faster.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>A multiplicative factor for the minimal lambda in the
<code>lambda</code> sequence, where <code>min(lambda) = lambda.factor * max(lambda)</code>.
<code>max(lambda)</code> is the smallest value of <code>lambda</code> for which all coefficients
are zero. The default depends on the relationship between <code class="reqn">n</code>
(the number of rows in the matrix of predictors) and <code class="reqn">p</code>
(the number of predictors). If <code class="reqn">n \geq p</code>, the
default is <code>0.0001</code>.  If <code class="reqn">n &lt; p</code>, the default is <code>0.01</code>.
A very small value of <code>lambda.factor</code> will lead to a
saturated fit. This argument has no effect if there is user-defined
<code>lambda</code> sequence.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence. The default, <code>NULL</code>
results in an automatic computation based on <code>nlambda</code>, the smallest value
of <code>lambda</code> that would give the null model (all coefficient estimates equal
to zero), and <code>lambda.factor</code>. Supplying a value of <code>lambda</code> overrides
this behaviour. It is likely better to supply a
decreasing sequence of <code>lambda</code> values than a single (small) value. If
supplied, the user-defined <code>lambda</code> sequence is automatically sorted in
decreasing order.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_pf_group">pf_group</code></td>
<td>
<p>Penalty factor on the groups, a vector of the same
length as the total number of groups. Separate penalty weights can be applied
to each group of <code class="reqn">\beta</code>s to allow differential shrinkage.
Can be 0 for some
groups, which implies no shrinkage, and results in that group always being
included in the model (depending on <code>pf_sparse</code>). Default value for each
entry is the square-root of the corresponding size of each group.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_pf_sparse">pf_sparse</code></td>
<td>
<p>Penalty factor on l1-norm, a vector the same length as the
total number of columns in <code>x</code>. Each value corresponds to one predictor
Can be 0 for some predictors, which
implies that predictor will be receive only the group penalty.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_intercept">intercept</code></td>
<td>
<p>Whether to include intercept in the model. Default is TRUE.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_asparse">asparse</code></td>
<td>
<p>The relative weight to put on the <code class="reqn">\ell_1</code>-norm in
sparse group lasso. Default is <code>0.05</code> (resulting in <code>0.95</code> on the
<code class="reqn">\ell_2</code>-norm).</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for variable standardization (scaling) prior
to fitting the model. Default is TRUE.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_lower_bnd">lower_bnd</code></td>
<td>
<p>Lower bound for coefficient values, a vector in length of 1
or of length the number of groups. Must be non-positive numbers only.
Default value for each entry is <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_upper_bnd">upper_bnd</code></td>
<td>
<p>Upper for coefficient values, a vector in length of 1
or of length the number of groups. Must be non-negative numbers only.
Default value for each entry is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_weights">weights</code></td>
<td>
<p>Double vector. Optional observation weights. These can
only be used with a <code><a href="stats.html#topic+family">stats::family()</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_offset">offset</code></td>
<td>
<p>Double vector. Optional offset (constant predictor without a
corresponding coefficient). These can only be used with a
<code><a href="stats.html#topic+family">stats::family()</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_warm">warm</code></td>
<td>
<p>List created with <code><a href="#topic+make_irls_warmup">make_irls_warmup()</a></code>. These can only be used
with a <code><a href="stats.html#topic+family">stats::family()</a></code> object, and is not typically necessary even then.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_trace_it">trace_it</code></td>
<td>
<p>Scalar integer. Larger values print more output during
the irls loop. Typical values are <code>0</code> (no printing), <code>1</code> (some printing
and a progress bar), and <code>2</code> (more detailed printing).
These can only be used with a <code><a href="stats.html#topic+family">stats::family()</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_dfmax">dfmax</code></td>
<td>
<p>Limit the maximum number of groups in the model. Default is
no limit.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_pmax">pmax</code></td>
<td>
<p>Limit the maximum number of groups ever to be nonzero. For
example once a group enters the model, no matter how many times it exits or
re-enters model through the path, it will be counted only once.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_eps">eps</code></td>
<td>
<p>Convergence termination tolerance. Defaults value is <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="sparsegl_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of outer-loop iterations allowed at fixed lambda
value. Default is <code>3e8</code>. If models do not converge, consider increasing
<code>maxit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"sparsegl"</code>. Among the list components:
</p>

<ul>
<li> <p><code>call</code> The call that produced this object.
</p>
</li>
<li> <p><code>b0</code> Intercept sequence of length <code>length(lambda)</code>.
</p>
</li>
<li> <p><code>beta</code> A <code>p</code> x <code>length(lambda)</code> sparse matrix of coefficients.
</p>
</li>
<li> <p><code>df</code> The number of features with nonzero coefficients for each value of
<code>lambda</code>.
</p>
</li>
<li> <p><code>dim</code> Dimension of coefficient matrix.
</p>
</li>
<li> <p><code>lambda</code> The actual sequence of <code>lambda</code> values used.
</p>
</li>
<li> <p><code>npasses</code> Total number of iterations summed over all <code>lambda</code> values.
</p>
</li>
<li> <p><code>jerr</code> Error flag, for warnings and errors, 0 if no error.
</p>
</li>
<li> <p><code>group</code> A vector of consecutive integers describing the grouping of the
coefficients.
</p>
</li>
<li> <p><code>nobs</code> The number of observations used to estimate the model.
</p>
</li></ul>

<p>If <code>sparsegl()</code> was called with a <code><a href="stats.html#topic+family">stats::family()</a></code> method, this may also
contain information about the deviance and the family used in fitting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.sparsegl">cv.sparsegl()</a></code> and the <code><a href="#topic+plot.sparsegl">plot()</a></code>,
<code><a href="#topic+predict.sparsegl">predict()</a></code>, and <code><a href="#topic+coef.sparsegl">coef()</a></code>
methods for <code>"sparsegl"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), nrow = n)
eps &lt;- rnorm(n)
beta_star &lt;- c(rep(5, 5), c(5, -5, 2, 0, 0), rep(-5, 5), rep(0, (p - 15)))
y &lt;- X %*% beta_star + eps
groups &lt;- rep(1:(p / 5), each = 5)
fit &lt;- sparsegl(X, y, group = groups)

yp &lt;- rpois(n, abs(X %*% beta_star))
fit_pois &lt;- sparsegl(X, yp, group = groups, family = poisson())
</code></pre>

<hr>
<h2 id='trust_experts'>Trust in scientific experts during the Covid-19 pandemic</h2><span id='topic+trust_experts'></span>

<h3>Description</h3>

<p>A dataset containing a measurement of &quot;trust&quot; in experts along with other
metrics collected through the Delphi Group at Carnegie Mellon University
U.S. COVID-19 Trends and Impact Survey, in partnership with Facebook. This
particular dataset is created from one of the public
<a href="https://www.cmu.edu/delphi-web/surveys/monthly-rollup/">contingency tables</a>,
specifically, the breakdown by state, age, gender, and race/ethnicity published
on 05 February 2022.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trust_experts
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 9759 rows and 8 columns
</p>

<dl>
<dt><code>trust_experts</code></dt><dd><p>Real-valued. This is the average of
<code style="white-space: pre;">&#8288;pct_trust_covid_info_*&#8288;</code>
where <code>*</code> is each of <code>doctors</code>, <code>experts</code>, <code>cdc</code>, and <code>govt_health</code>.</p>
</dd>
<dt><code>period</code></dt><dd><p>Factor. Start date of data collection period.
There are 13 monthly periods</p>
</dd>
<dt><code>region</code></dt><dd><p>Factor. State abbreviation.</p>
</dd>
<dt><code>age</code></dt><dd><p>Factor. Self-reported age bucket.</p>
</dd>
<dt><code>gender</code></dt><dd><p>Factor. Self-reported gender.</p>
</dd>
<dt><code>raceethnicity</code></dt><dd><p>Factor. Self-reported race or ethnicity.</p>
</dd>
<dt><code>cli</code></dt><dd><p>Real-valued. This is the <code>wcli</code> indicator measuring the
percent of circulating Covid-like illness in a particular region. See
the <a href="https://cmu-delphi.github.io/delphi-epidata/api/covidcast-signals/fb-survey.html#ili-and-cli-indicators">Delphi Epidata API</a>
for a complete description.</p>
</dd>
<dt><code>hh_cmnty_cli</code></dt><dd><p>Real-valued. This is the <code>whh_cmnty_cli</code> indicator
measuring the percent of people reporting illness in their local
community and household.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The U.S. COVID-19 Trends and Impact Survey.
</p>
<p>The paper describing the survey:
</p>
<p>Joshua A. Salomon, Alex Reinhart, Alyssa Bilinski, Eu Jing Chua,
Wichada La Motte-Kerr, Minttu M. Rönn, Marissa Reitsma,
Katherine Ann Morris, Sarah LaRocca, Tamar Farag, Frauke Kreuter,
Roni Rosenfeld, and Ryan J. Tibshirani (2021). &quot;The US COVID-19 Trends
and Impact Survey: Continuous real-time measurement of COVID-19 symptoms,
risks, protective behaviors, testing, and vaccination&quot;, Proceedings of the
National Academy of Sciences 118 (51) e2111454118.
<a href="https://doi.org/10.1073/pnas.2111454118">doi:10.1073/pnas.2111454118</a>.
</p>
<p><a href="https://cmu-delphi.github.io/delphi-epidata/symptom-survey/contingency-tables.html">The Public Delphi US CTIS Documentation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(splines)
library(dplyr)
library(magrittr)
df &lt;- 10

trust_experts &lt;- trust_experts %&gt;%
  mutate(across(
    where(is.factor),
    ~ set_attr(.x, "contrasts", contr.sum(nlevels(.x), FALSE, TRUE))
  ))

x &lt;- Matrix::sparse.model.matrix(
    ~ 0 + region + age + gender + raceethnicity + period +
    bs(cli, df = df) + bs(hh_cmnty_cli, df = df),
    data = trust_experts, drop.unused.levels = TRUE)

gr &lt;- sapply(trust_experts, function(x) ifelse(is.factor(x), nlevels(x), NA))
gr &lt;- rep(seq(ncol(trust_experts) - 1), times = c(gr[!is.na(gr)], df, df))
fit &lt;- cv.sparsegl(x, trust_experts$trust_experts, gr)

## End(Not run)
</code></pre>

<hr>
<h2 id='zero_norm'>Calculate common norms</h2><span id='topic+zero_norm'></span><span id='topic+one_norm'></span><span id='topic+two_norm'></span><span id='topic+grouped_zero_norm'></span><span id='topic+grouped_one_norm'></span><span id='topic+grouped_two_norm'></span><span id='topic+grouped_sp_norm'></span><span id='topic+gr_one_norm'></span><span id='topic+gr_two_norm'></span><span id='topic+sp_group_norm'></span>

<h3>Description</h3>

<p>Calculate different norms of vectors with or without grouping structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_norm(x)

one_norm(x)

two_norm(x)

grouped_zero_norm(x, gr)

grouped_one_norm(x, gr)

grouped_two_norm(x, gr)

grouped_sp_norm(x, gr, asparse)

gr_one_norm(x, gr)

gr_two_norm(x, gr)

sp_group_norm(x, gr, asparse = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_norm_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="zero_norm_+3A_gr">gr</code></td>
<td>
<p>An integer (or factor) vector of the same length as x.</p>
</td></tr>
<tr><td><code id="zero_norm_+3A_asparse">asparse</code></td>
<td>
<p>Scalar. The weight to put on the l1 norm when calculating the
group norm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar or vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>zero_norm()</code>: l0-norm (number of nonzero entries).
</p>
</li>
<li> <p><code>one_norm()</code>: l1-norm (Absolute-value norm).
</p>
</li>
<li> <p><code>two_norm()</code>: l2-norm (Euclidean norm).
</p>
</li>
<li> <p><code>grouped_zero_norm()</code>: A vector of group-wise l0-norms.
</p>
</li>
<li> <p><code>grouped_one_norm()</code>: A vector of group-wise l1-norms.
</p>
</li>
<li> <p><code>grouped_two_norm()</code>: A vector of group-wise l2-norms.
</p>
</li>
<li> <p><code>grouped_sp_norm()</code>: A vector of length <code>unique(gr)</code> consisting of
the <code>asparse</code> convex combination of the l1 and l2-norm for each group.
</p>
</li>
<li> <p><code>gr_one_norm()</code>: The l1-norm norm of a vector (a scalar).
</p>
</li>
<li> <p><code>gr_two_norm()</code>: The sum of the group-wise l2-norms of a vector
(a scalar).
</p>
</li>
<li> <p><code>sp_group_norm()</code>: The sum of the <code>asparse</code> convex combination of
group l1 and l2-norms vectors (a scalar).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rep(-1, 5), rep(0, 5), rep(1,5))
gr &lt;- c(rep(1,5), rep(2,5), rep(3,5))
asparse &lt;- 0.05
grouped_sp_norm(x, gr, asparse)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
