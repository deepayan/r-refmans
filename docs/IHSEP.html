<!DOCTYPE html><html><head><title>Help for package IHSEP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IHSEP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asep'>
<p>An IHSEP data set</p></a></li>
<li><a href='#conv.seq'><p>Sequence convolution</p>
conv.seq calculates the convolution of two sequences</a></li>
<li><a href='#h.fn'><p>Mean Intensity Function of the Self-Exciting Point Process</p></a></li>
<li><a href='#h.fn.exp'><p>Mean Intensity of the Self-Exciting Point Process With an</p>
Exponential Excitation Function</a></li>
<li><a href='#IHSEP-package'>
<p>Inhomogeneous Self-exciting Process</p></a></li>
<li><a href='#mloglik0'>
<p>Minus loglikelihood of an IHSEP model</p></a></li>
<li><a href='#mloglik1a'>
<p>Minus loglikelihood of an IHSEP model</p></a></li>
<li><a href='#mloglik1b'>
<p>Minus loglikelihood of an IHSEP model</p></a></li>
<li><a href='#mloglik1c'>
<p>Minus loglikelihood of an IHSEP model</p></a></li>
<li><a href='#mloglik1d'>
<p>Minus loglikelihood of an IHSEP model</p></a></li>
<li><a href='#mloglik1e'>
<p>Minus loglikelihood of an IHSEP model</p></a></li>
<li><a href='#sepp.resid'><p>Calculate the self exciting point process residuals</p></a></li>
<li><a href='#simchildren'><p>Simulate the child events</p>
<code>simchildren</code> simulates the birth times of all child events
spawned from an event relative the birth time of the parent
event. This function is to be called by the simulator function for
offspring events and is not meant for external use.</a></li>
<li><a href='#simHawkes0'>
<p>Simulate a Hawkes process, or Self-exciting point process</p></a></li>
<li><a href='#simHawkes1'>
<p>Simulate a Hawkes process, or Self-exciting point process</p></a></li>
<li><a href='#simHawkes1a'><p>Simulate an (inhomogeneous) Hawkes self-exciting process</p>
<code>simHawkes1a</code> simulates the event times of an inhomogeneous
Hawkes process (IHSEP) with background event intensity/rate
<code class="reqn">nu(\cdot)\geq 0</code>, branching ratio <code class="reqn">\eta\in[0,1)</code>, and
offspring birthtime density <code class="reqn">g(\cdot)</code>, up to a censoring time
<code class="reqn">T</code>.</a></li>
<li><a href='#simoffspring'><p>Simulate the offspring events</p>
<code>simoffspring</code> simulates the birth times of offspring events
of all generations spawned from an event relative the birth time of
the parent event. This function is to be called by the simulator
function for Hawkes processes and is not meant for external use.</a></li>
<li><a href='#simPois'>
<p>Simulate a Poisson process</p></a></li>
<li><a href='#simPois0'>
<p>Simulate a Poisson process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inhomogeneous Self-Exciting Process</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-9-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Feng Chen &lt;feng.chen@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Feng Chen &lt;feng.chen@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate an inhomogeneous self-exciting process (IHSEP), or Hawkes process, with a given (possibly time-varying) baseline intensity and an excitation function. Calculate the likelihood of an IHSEP with given baseline intensity and excitation functions for an (increasing) sequence of event times. Calculate the point process residuals (integral transforms of the original event times). Calculate the mean intensity process.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>lpint,Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-16 21:11:32 UTC; ubuntu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-16 21:56:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='asep'>
An IHSEP data set
</h2><span id='topic+asep'></span>

<h3>Description</h3>

<p>A simulated data set from the inhomegeneous self-exciting process model
with baseline intensity, or immigration rate,
<code class="reqn">\nu(t)=200(2+\cos(2\pi t))</code> and excitation function, or fertility
<code class="reqn">g(t)=8\exp(-16 t)</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(asep)</code></pre>


<h3>Format</h3>

<p>The format is a list of the arrival/birth times of individuals of all
generations, in the order of generation 0 individuals, generation 1
individuals, etc. 
</p>


<h3>Details</h3>

<p>Times of arrivals/births of the same generation is listed
together in ascending order. Number of generations is given by the
length of the object. 
</p>


<h3>Source</h3>

<p>Simulated by a call to the function <code>simHawkes1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(asep)
## number of generations
length(asep)
## jump times of the observed self-exciting process
sort(unlist(asep))
</code></pre>

<hr>
<h2 id='conv.seq'>Sequence convolution
conv.seq calculates the convolution of two sequences</h2><span id='topic+conv.seq'></span>

<h3>Description</h3>

<p>Sequence convolution
conv.seq calculates the convolution of two sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv.seq(x, y, real = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv.seq_+3A_x">x</code>, <code id="conv.seq_+3A_y">y</code></td>
<td>
<p>numeric vectors</p>
</td></tr>
<tr><td><code id="conv.seq_+3A_real">real</code></td>
<td>
<p>logical value, indicating whether the result should be real valued</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of length equal to <code>length(x)+length(y)</code>, giving the convolution of <code>x</code> and <code>y</code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+convolve">convolve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conv.seq(1:5,1:4)
convolve(1:5,4:1,type="open")
</code></pre>

<hr>
<h2 id='h.fn'>Mean Intensity Function of the Self-Exciting Point Process</h2><span id='topic+h.fn'></span>

<h3>Description</h3>

<p><code>h.fn</code> calculate the values of the mean intensity function of the
self-exciting process with given baseline event rate and excitation
function at a (fairly large) number of points. Values of the function at
other points can be obtained by interpolation (e.g. spline
interpolation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h.fn(nu, g, N = 2^12, to = 1, abs.tol = 1e-10, maxit = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h.fn_+3A_nu">nu</code></td>
<td>
<p>a (vectorized) function specifying the baseline invent rate of the SEPP</p>
</td></tr>
<tr><td><code id="h.fn_+3A_g">g</code></td>
<td>
<p>a (vectorized) function specifying the excitation function of the SEPP</p>
</td></tr>
<tr><td><code id="h.fn_+3A_n">N</code></td>
<td>
<p>an integer giving the number of equal sized intervals to partition the domain into during the calculation The larger this value is, the more accurately the solution approxmates the truth, and the more time requred to evaluate.</p>
</td></tr>
<tr><td><code id="h.fn_+3A_to">to</code></td>
<td>
<p>a numeric scalar, the end point of the estimation domain</p>
</td></tr>
<tr><td><code id="h.fn_+3A_abs.tol">abs.tol</code></td>
<td>
<p>a numeric scalar specifying the absolute tolerance of error</p>
</td></tr>
<tr><td><code id="h.fn_+3A_maxit">maxit</code></td>
<td>
<p>an integer specifying the maximal number of iterations allowed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elelents, <code>x</code>: the vector of the points where <code class="reqn">h</code> is evaluated; <code>y</code>: the vector of the corresponding <code class="reqn">h</code> values; <code>nit</code>: the number of iterations used; <code>G.err</code>: the approximation error in <code class="reqn">G</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+h.fn.exp">h.fn.exp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nu &lt;- function(x)(200+100*cos(pi*x))*(x&gt;=0);
g &lt;- function(x) 2*exp(-x)
h.l &lt;- h.fn(nu=nu,g=g,to=5);
h &lt;- splinefun(h.l$x,h.l$y);
x &lt;- 1:500/100;
max(nu(x)+sapply(x,function(x)integrate(function(u)g(x-u)*h(u),0,x)$value) - h(x))

## End(Not run)
</code></pre>

<hr>
<h2 id='h.fn.exp'>Mean Intensity of the Self-Exciting Point Process With an
Exponential Excitation Function</h2><span id='topic+h.fn.exp'></span>

<h3>Description</h3>

<p><code>h.fn.exp</code> calculates the mean intensity function <code class="reqn">h(t)</code> which
solves the integral equation </p>
<p style="text-align: center;"><code class="reqn">h(t)=\nu(t)+\int_0^t g(t-s)h(s)ds,
  t\geq 0</code>
</p>
<p>, where the excitation function is exponential: <code class="reqn">g(t)=
  \gamma_1 e^{-\gamma_2t}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h.fn.exp(x, nu, g.p = c(4, 8))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h.fn.exp_+3A_x">x</code></td>
<td>
<p>numerical scalar, at which the mean intensity <code class="reqn">h</code> is to be evaluated</p>
</td></tr>
<tr><td><code id="h.fn.exp_+3A_nu">nu</code></td>
<td>
<p>a function, which gives the baseline event rate</p>
</td></tr>
<tr><td><code id="h.fn.exp_+3A_g.p">g.p</code></td>
<td>
<p>a numeric vector of two elements giving the two parameters <code class="reqn">\gamma_1,\gamma_2</code> of the exponential excitation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numric scalar which gives the value of the function <code class="reqn">h</code> at <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+h.fn">h.fn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nu &lt;- function(x)200+100*cos(pi*x);
x &lt;- 1:500/100;
y &lt;- sapply(x,h.fn.exp,nu=nu,g.p=c(2,1));
h &lt;- splinefun(x,y);
g &lt;- function(x)2*exp(-x)
round(nu(x)+sapply(x,function(x)integrate(function(u)g(x-u)*h(u),0,x)$value) - y,5)
</code></pre>

<hr>
<h2 id='IHSEP-package'>
Inhomogeneous Self-exciting Process
</h2><span id='topic+IHSEP-package'></span><span id='topic+IHSEP'></span>

<h3>Description</h3>

<p>Simulates the (inhomogeneous) Self-exciting point process (SEPP), or
Hawkes process, on <code class="reqn">[0,T]</code> with a given (possibly time-varying)
baseline/background intensity function <code class="reqn">nu</code> and excitation
function (fertility rate function) <code class="reqn">g</code>.  Or calculate the
likelihood of an SEPP with baseline intensity <code class="reqn">nu</code> and excitation
function <code class="reqn">g</code> for a given set of event times on <code class="reqn">[0,T]</code>.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> IHSEP</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-05-12</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL(&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>
<p>Maintainer: Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>References</h3>

<p>Feng Chen and Peter Hall (2013). Inference for a nonstationary
self-exciting point process with an application in ultra-high frequency
financial data modeling.  Journal of Applied Probability
50(4):1006-1024.
</p>
<p>Feng Chen and Peter Hall (2016). Nonparametric Estimation for
Self-Exciting Point Processes &ndash; A Parsimonious Approach. Journal of
Computational and Graphical Statistics 25(1): 209-224. 
</p>
<p>Alan G Hawkes (1971). Spectra of some self-exciting and mutually
exciting point processes. Biometrika 58(1):83-90.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simulate the times of a Poisson process on [0,1] with intensity
## function nu(t)=100*(2+cos(2*pi*t)).
tms &lt;- simPois(int=function(x)100*(2+cos(2*pi*x)),int.M=300)
## calculate a nonparametric estimate of the intensity function
int &lt;- lpint::lpint(tms,Tau=1)
matplot(int$x,int$y+qnorm(0.975)*outer(int$se,c(-1,0,1)),type="l",lty=c(2,1,2),
        col=1,xlab="t",ylab="nu(t)")
curve(100*(2+cos(2*pi*x)),add=TRUE,col="red")

## simulate an IHSEP on [0,1] with baseline intensity function
## nu(t)=100*(2+cos(2*pi*t)) and excitation function
## g(t)=0.5*8*exp(-8*t)
asep &lt;- simHawkes1(nu=function(x)200*(2+cos(2*pi*x)),nuM=600,
                              g=function(x)8*exp(-16*x),gM=8)
## get the birth times of all generations and sort in ascending order 
tms &lt;- sort(unlist(asep))
## calculate the minus loglikelihood of an SEPP with the true parameters 
mloglik1a(tms,TT=1,nu=function(x)200*(2+cos(2*pi*x)),
          g=function(x)8*exp(-16*x),Ig=function(x)8/16*(1-exp(-18*x)))
## calculate the MLE for the parameter assuming known parametric forms
## of the baseline intensity and excitation functions  
est &lt;- optim(c(400,200,2*pi,8,16),
             function(p){
               mloglik1a(jtms=tms,TT=1,
                         nu=function(x)p[1]+p[2]*cos(p[3]*x),
                         g=function(x)p[4]*exp(-p[5]*x),
                         Ig=function(x)p[4]/p[5]*(1-exp(-p[5]*x)))
             },
             hessian=TRUE,control=list(maxit=5000,trace=TRUE))
## point estimate by MLE
est$par
## standard error estimates:
diag(solve(est$hessian))^0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='mloglik0'>
Minus loglikelihood of an IHSEP model
</h2><span id='topic+mloglik0'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an IHSEP model with given
baseline inensity function <code class="reqn">\nu</code> and excitation function <code class="reqn">g</code>
for event times <code>jtms</code> on interval <code class="reqn">[0,TT]</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mloglik0(jtms, TT = max(jtms), nu, g,
         Ig=function(x)sapply(x,function(y)integrate(g,0,y)$value))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mloglik0_+3A_jtms">jtms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Jump times
to fit the inhomogeneous self-exciting point process model on. 
</p>
</td></tr>
<tr><td><code id="mloglik0_+3A_tt">TT</code></td>
<td>

<p>A scalar. The censoring time, or the terminal time for
observation. Should be (slightly) greater than the maximum of <code>jtms</code>.
</p>
</td></tr>
<tr><td><code id="mloglik0_+3A_nu">nu</code></td>
<td>

<p>A (vectorized) function. The baseline intensity function. 
</p>
</td></tr>
<tr><td><code id="mloglik0_+3A_g">g</code></td>
<td>

<p>A (vectorized) function. The excitation function. 
</p>
</td></tr>
<tr><td><code id="mloglik0_+3A_ig">Ig</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the excitation function from 0 to <code>t</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the negative log-liklihood. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulated data of an IHSEP on [0,1] with baseline intensity function
## nu(t)=200*(2+cos(2*pi*t)) and excitation function
## g(t)=8*exp(-16*t)
data(asep)

## get the birth times of all generations and sort in ascending order 
tms &lt;- sort(unlist(asep))
## calculate the minus loglikelihood of an SEPP with the true parameters 
mloglik0(tms,TT=1,nu=function(x)200*(2+cos(2*pi*x)),
          g=function(x)8*exp(-16*x),Ig=function(x)8/16*(1-exp(-16*x)))
## calculate the MLE for the parameter assuming known parametric forms
## of the baseline intensity and excitation functions  
## Not run: 
system.time(est &lt;- optim(c(400,200,2*pi,8,16),
                         function(p){
                           mloglik0(jtms=tms,TT=1,
                                     nu=function(x)p[1]+p[2]*cos(p[3]*x),
                                     g=function(x)p[4]*exp(-p[5]*x),
                                     Ig=function(x)p[4]/p[5]*(1-exp(-p[5]*x)))
                         },
                         hessian=TRUE,control=list(maxit=5000,trace=TRUE))
            )
## point estimate by MLE
est$par
## standard error estimates:
diag(solve(est$hessian))^0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='mloglik1a'>
Minus loglikelihood of an IHSEP model
</h2><span id='topic+mloglik1a'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an IHSEP model with given
baseline inensity function <code class="reqn">\nu</code> and excitation function <code class="reqn">g</code>
for event times <code>jtms</code> on interval <code class="reqn">[0,TT]</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mloglik1a(jtms, TT = max(jtms), nu, g,
          Ig = function(x) sapply(x, function(y) integrate(g, 0, y)$value),
          tol.abs = 1e-12, tol.rel = 1e-12, limit = 1000
          )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mloglik1a_+3A_jtms">jtms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Jump times
to fit the inhomogeneous self-exciting point process model on. 
</p>
</td></tr>
<tr><td><code id="mloglik1a_+3A_tt">TT</code></td>
<td>

<p>A scalar. The censoring time, or the terminal time for
observation. Should be (slightly) greater than the maximum of <code>jtms</code>.
</p>
</td></tr>
<tr><td><code id="mloglik1a_+3A_nu">nu</code></td>
<td>

<p>A (vectorized) function. The baseline intensity function. 
</p>
</td></tr>
<tr><td><code id="mloglik1a_+3A_g">g</code></td>
<td>

<p>A (vectorized) function. The excitation function. 
</p>
</td></tr>
<tr><td><code id="mloglik1a_+3A_ig">Ig</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the excitation function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="mloglik1a_+3A_tol.abs">tol.abs</code></td>
<td>

<p>A small positive number. The tolerance of the absolute error in the
numerical integral of <code class="reqn">\nu</code>. 
</p>
</td></tr>
<tr><td><code id="mloglik1a_+3A_tol.rel">tol.rel</code></td>
<td>

<p>A small positive number. The tolerance of the relative error in the
numerical integral of <code class="reqn">\nu</code>. 
</p>
</td></tr>
<tr><td><code id="mloglik1a_+3A_limit">limit</code></td>
<td>

<p>An (large) positive integer. The maximum number of subintervals
allowed in the adaptive quadrature method to find the numerical
integral of <code class="reqn">\nu</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version of the mloglik function uses external C code to speedup
the calculations. Otherwise it is the same as the <code>mloglik0</code>
function. 
</p>


<h3>Value</h3>

<p>The value of the negative log-liklihood. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>mloglik0</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulated data of an IHSEP on [0,1] with baseline intensity function
## nu(t)=200*(2+cos(2*pi*t)) and excitation function
## g(t)=8*exp(-16*t)
data(asep)

## get the birth times of all generations and sort in ascending order 
tms &lt;- sort(unlist(asep))
## calculate the minus loglikelihood of an SEPP with the true parameters 
mloglik1a(tms,TT=1,nu=function(x)200*(2+cos(2*pi*x)),
          g=function(x)8*exp(-16*x),Ig=function(x)8/16*(1-exp(-16*x)))
## calculate the MLE for the parameter assuming known parametric forms
## of the baseline intensity and excitation functions  
## Not run: 
system.time(est &lt;- optim(c(400,200,2*pi,8,16),
                         function(p){
                           mloglik1a(jtms=tms,TT=1,
                                     nu=function(x)p[1]+p[2]*cos(p[3]*x),
                                     g=function(x)p[4]*exp(-p[5]*x),
                                     Ig=function(x)p[4]/p[5]*(1-exp(-p[5]*x)))
                         },
                         hessian=TRUE,control=list(maxit=5000,trace=TRUE))
            )
## point estimate by MLE
est$par
## standard error estimates:
diag(solve(est$hessian))^0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='mloglik1b'>
Minus loglikelihood of an IHSEP model
</h2><span id='topic+mloglik1b'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an IHSEP model with given
baseline inensity function <code class="reqn">\nu</code> and excitation function <code class="reqn">g</code>
for event times <code>jtms</code> on interval <code class="reqn">[0,TT]</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mloglik1b(jtms, TT = max(jtms), nu, g,
          Ig=function(x)sapply(x,function(y)integrate(g,0,y,
               rel.tol=1e-12,abs.tol=1e-12,subdivisions=1000)$value),
          Inu=function(x)sapply(x,function(y)integrate(nu,0,y)$value))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mloglik1b_+3A_jtms">jtms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Jump times
to fit the inhomogeneous self-exciting point process model on. 
</p>
</td></tr>
<tr><td><code id="mloglik1b_+3A_tt">TT</code></td>
<td>

<p>A scalar. The censoring time, or the terminal time for
observation. Should be (slightly) greater than the maximum of <code>jtms</code>.
</p>
</td></tr>
<tr><td><code id="mloglik1b_+3A_nu">nu</code></td>
<td>

<p>A (vectorized) function. The baseline intensity function. 
</p>
</td></tr>
<tr><td><code id="mloglik1b_+3A_g">g</code></td>
<td>

<p>A (vectorized) function. The excitation function. 
</p>
</td></tr>
<tr><td><code id="mloglik1b_+3A_ig">Ig</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the excitation function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="mloglik1b_+3A_inu">Inu</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the baseline intensity function <code class="reqn">\nu</code> from 0 to <code>t</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version of the mloglik function uses external C code to speedup
the calculations. When given the analytical form of <code>Inu</code> or a
quickly calculatable <code>Inu</code>, it should be (probably slightly)
faster than <code>mloglik1a</code>. Otherwise it is the same as
<code>mloglik0</code> and <code>mloglik1a</code>. 
</p>


<h3>Value</h3>

<p>The value of the negative log-liklihood. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>mloglik0</code> and <code>mloglik1a</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulated data of an IHSEP on [0,1] with baseline intensity function
## nu(t)=200*(2+cos(2*pi*t)) and excitation function
## g(t)=8*exp(-16*t)
data(asep)

## get the birth times of all generations and sort in ascending order 
tms &lt;- sort(unlist(asep))
## calculate the minus loglikelihood of an SEPP with the true parameters 
mloglik1b(tms,TT=1,nu=function(x)200*(2+cos(2*pi*x)),
          g=function(x)8*exp(-16*x),Ig=function(x)8/16*(1-exp(-16*x)))
## calculate the MLE for the parameter assuming known parametric forms
## of the baseline intensity and excitation functions  
## Not run: 
system.time(est &lt;- optim(c(400,200,2*pi,8,16),
                         function(p){
                           mloglik1b(jtms=tms,TT=1,
                                     nu=function(x)p[1]+p[2]*cos(p[3]*x),
                                     g=function(x)p[4]*exp(-p[5]*x),
                                     Ig=function(x)p[4]/p[5]*(1-exp(-p[5]*x)))
                         },
                         hessian=TRUE,control=list(maxit=5000,trace=TRUE))
            )

## point estimate by MLE
est$par
## standard error estimates:
diag(solve(est$hessian))^0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='mloglik1c'>
Minus loglikelihood of an IHSEP model
</h2><span id='topic+mloglik1c'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an IHSEP model with given
baseline inensity function <code class="reqn">\nu</code> and excitation function <code class="reqn">g(x)=a
exp(-b x)</code> for event times <code>jtms</code> on interval <code>[0,TT]</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mloglik1c(jtms, TT, nu, gcoef, Inu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mloglik1c_+3A_jtms">jtms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Jump times
to fit the inhomogeneous self-exciting point process model on. 
</p>
</td></tr>
<tr><td><code id="mloglik1c_+3A_tt">TT</code></td>
<td>

<p>A scalar. The censoring time, or the terminal time for
observation. Should be (slightly) greater than the maximum of <code>jtms</code>.
</p>
</td></tr>
<tr><td><code id="mloglik1c_+3A_nu">nu</code></td>
<td>

<p>A (vectorized) function. The baseline intensity function. 
</p>
</td></tr>
<tr><td><code id="mloglik1c_+3A_gcoef">gcoef</code></td>
<td>

<p>A numeric vector (of two elements), giving the parameters (a,b) of the
exponential excitation function g(x)=a*exp(-b*x). 
</p>
</td></tr>
<tr><td><code id="mloglik1c_+3A_inu">Inu</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the baseline intensity function <code class="reqn">\nu</code> from 0 to <code>t</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version of the mloglik function uses external C code to speedup
the calculations. When given the analytical form of <code>Inu</code> or a
quickly calculatable <code>Inu</code>, it should be (substantially)
faster than <code>mloglik1a</code> when calculating the (minus log)
likelihood when the excitation function is exponential. Otherwise it
is the same as <code>mloglik0</code>, <code>mloglik1a</code>, <code>mloglik1b</code>. 
</p>


<h3>Value</h3>

<p>The value of the negative log-liklihood. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>mloglik0</code>, <code>mloglik1a</code> and <code>mloglik1b</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulated data of an IHSEP on [0,1] with baseline intensity function
## nu(t)=200*(2+cos(2*pi*t)) and excitation function
## g(t)=8*exp(-16*t)
data(asep)

## get the birth times of all generations and sort in ascending order 
tms &lt;- sort(unlist(asep))
## calculate the minus loglikelihood of an SEPP with the true parameters 
mloglik1c(tms,TT=1,nu=function(x)200*(2+cos(2*pi*x)),
          gcoef=8*1:2,
          Inu=function(y)integrate(function(x)200*(2+cos(2*pi*x)),0,y)$value)
## calculate the MLE for the parameter assuming known parametric forms
## of the baseline intensity and excitation functions  
## Not run: 
system.time(est &lt;- optim(c(400,200,2*pi,8,16),
                         function(p){
                           mloglik1c(jtms=tms,TT=1,
                                     nu=function(x)p[1]+p[2]*cos(p[3]*x),
                                     gcoef=p[-(1:3)],
                                     Inu=function(y){
                                      integrate(function(x)p[1]+p[2]*cos(p[3]*x),
                                                0,y)$value
                                     })
                         },hessian=TRUE,control=list(maxit=5000,trace=TRUE))
            )
## point estimate by MLE
est$par
## standard error estimates:
diag(solve(est$hessian))^0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='mloglik1d'>
Minus loglikelihood of an IHSEP model
</h2><span id='topic+mloglik1d'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an IHSEP model with given
baseline intensity function <code class="reqn">\nu</code> and excitation function
<code class="reqn">g(x)=\sum a_i exp(-b_i x)</code> for event times <code>jtms</code> on interval
<code>[0,TT]</code>.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mloglik1d(jtms, TT, nu, gcoef, Inu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mloglik1d_+3A_jtms">jtms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Jump times
to fit the inhomogeneous self-exciting point process model on. 
</p>
</td></tr>
<tr><td><code id="mloglik1d_+3A_tt">TT</code></td>
<td>

<p>A scalar. The censoring time, or the terminal time for
observation. Should be (slightly) greater than the maximum of <code>jtms</code>.
</p>
</td></tr>
<tr><td><code id="mloglik1d_+3A_nu">nu</code></td>
<td>

<p>A (vectorized) function. The baseline intensity function. 
</p>
</td></tr>
<tr><td><code id="mloglik1d_+3A_gcoef">gcoef</code></td>
<td>

<p>A numeric vector (of 2k elements), giving the parameters
<code>(a_1,...,a_k,b_1,...,b_k)</code> of the exponential excitation
function <code class="reqn">g(x)=\sum_{i=1}^k a_i*exp(-b_i*x)</code>.  
</p>
</td></tr>
<tr><td><code id="mloglik1d_+3A_inu">Inu</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the baseline intensity function <code class="reqn">\nu</code> from 0 to <code>t</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the minus loglikelihood of the inhomegeneous
Hawkes model with background intensity function <code class="reqn">\nu(t)</code> and
excitation kernel function <code class="reqn">g(t)=\sum_{i=1}^{k} a_i e^{-b_i t}</code>
relative to continuous observation of the process from time 0 to time
<code>TT</code>. Like <code>mloglik1c</code>, it takes advantage of the Markovian 
property of the intensity process and uses external C++ code to speed
up the computation.  
</p>


<h3>Value</h3>

<p>The value of the negative log-liklihood. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>mloglik1c</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulated data of an IHSEP on [0,1] with baseline intensity function
## nu(t)=200*(2+cos(2*pi*t)) and excitation function
## g(t)=8*exp(-16*t)
data(asep)

## get the birth times of all generations and sort in ascending order 
tms &lt;- sort(unlist(asep))
## calculate the minus loglikelihood of an SEPP with the true parameters 
mloglik1d(tms,TT=1,nu=function(x)200*(2+cos(2*pi*x)),
          gcoef=8*1:2,
          Inu=function(y)integrate(function(x)200*(2+cos(2*pi*x)),0,y)$value)
## calculate the MLE for the parameter assuming known parametric forms
## of the baseline intensity and excitation functions  
## Not run: 
system.time(est &lt;- optim(c(400,200,2*pi,8,16),
                         function(p){
                           mloglik1d(jtms=tms,TT=1,
                                     nu=function(x)p[1]+p[2]*cos(p[3]*x),
                                     gcoef=p[-(1:3)],
                                     Inu=function(y){
                                      integrate(function(x)p[1]+p[2]*cos(p[3]*x),
                                                0,y)$value
                                     })
                         },hessian=TRUE,control=list(maxit=5000,trace=TRUE),
                         method="BFGS")
            )
## point estimate by MLE
est$par
## standard error estimates:
diag(solve(est$hessian))^0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='mloglik1e'>
Minus loglikelihood of an IHSEP model
</h2><span id='topic+mloglik1e'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an IHSEP model with given
baseline inensity function <code class="reqn">\nu</code> and excitation function
<code class="reqn">g(x)=\sum a_i exp(-b_i x)</code> for event times <code>jtms</code> on interval
<code>[0,TT]</code>.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mloglik1e(jtms, TT, nuvs, gcoef, InuT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mloglik1e_+3A_jtms">jtms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Jump times
to fit the inhomogeneous self-exciting point process model on. 
</p>
</td></tr>
<tr><td><code id="mloglik1e_+3A_tt">TT</code></td>
<td>

<p>A scalar. The censoring time, or the terminal time for
observation. Should be (slightly) greater than the maximum of <code>jtms</code>.
</p>
</td></tr>
<tr><td><code id="mloglik1e_+3A_nuvs">nuvs</code></td>
<td>

<p>A numeric vector, giving the values of the baseline intensity
function <code class="reqn">\nu</code> at the jumptimes <code>jtms</code>. 
</p>
</td></tr>
<tr><td><code id="mloglik1e_+3A_gcoef">gcoef</code></td>
<td>

<p>A numeric vector (of 2k elements), giving the parameters
<code>(a_1,...,a_k,b_1,...,b_k)</code> of the exponential excitation
function <code class="reqn">g(x)=\sum_{i=1}^k a_i*exp(-b_i*x)</code>.  
</p>
</td></tr>
<tr><td><code id="mloglik1e_+3A_inut">InuT</code></td>
<td>

<p>A numeric value (scalar) giving the integral of <code class="reqn">\nu</code> on the
interval <code>[0,TT]</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version of the mloglik function uses external C code to speedup
the calculations. When given the analytical form of <code>Inu</code> or a
quickly calculatable <code>Inu</code>, it should be (substantially)
faster than <code>mloglik1a</code> when calculating the (minus log)
likelihood when the excitation function is exponential. Otherwise it
is the same as <code>mloglik0</code>, <code>mloglik1a</code>, <code>mloglik1b</code>. 
</p>


<h3>Value</h3>

<p>The value of the negative log-liklihood. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>mloglik0</code>, <code>mloglik1a</code> and <code>mloglik1b</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulated data of an IHSEP on [0,1] with baseline intensity function
## nu(t)=200*(2+cos(2*pi*t)) and excitation function
## g(t)=8*exp(-16*t)
data(asep)

## get the birth times of all generations and sort in ascending order 
tms &lt;- sort(unlist(asep))
## calculate the minus loglikelihood of an SEPP with the true parameters 
mloglik1e(tms,TT=1,nuvs=200*(2+cos(2*pi*tms)),
          gcoef=8*1:2,
          InuT=integrate(function(x)200*(2+cos(2*pi*x)),0,1)$value)
## calculate the MLE for the parameter assuming known parametric forms
## of the baseline intensity and excitation functions  
## Not run: 
system.time(est &lt;- optim(c(400,200,2*pi,8,16),
                         function(p){
                           mloglik1e(jtms=tms,TT=1,
                                     nuvs=p[1]+p[2]*cos(p[3]*tms),
                                     gcoef=p[-(1:3)],
                                     InuT=integrate(function(x)p[1]+p[2]*cos(p[3]*x),
                                                    0,1)$value
                                     )
                         },hessian=TRUE,control=list(maxit=5000,trace=TRUE),
                         method="BFGS")
            )
## point estimate by MLE
est$par
## standard error estimates:
diag(solve(est$hessian))^0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='sepp.resid'>Calculate the self exciting point process residuals</h2><span id='topic+sepp.resid'></span>

<h3>Description</h3>

<p>Calculate the self exciting point process residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sepp.resid(jtms, Tau, Inu, Ig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sepp.resid_+3A_jtms">jtms</code></td>
<td>
<p>A numerical vector containing the event times of the SEPP in ascending order</p>
</td></tr>
<tr><td><code id="sepp.resid_+3A_tau">Tau</code></td>
<td>
<p>A numerical scalar giving the censoring time, which should be greater than or equal to the event time</p>
</td></tr>
<tr><td><code id="sepp.resid_+3A_inu">Inu</code></td>
<td>
<p>A function that gives the integral of the baseline event rate function <code class="reqn">\nu(t)</code> from 0 to the argument of the function</p>
</td></tr>
<tr><td><code id="sepp.resid_+3A_ig">Ig</code></td>
<td>
<p>A function that gives the integral of the excitation function <code class="reqn">g(t)</code> from 0 to the argument of the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector containing the SEPP residuals <code class="reqn">\Lambda(t_i)</code> where <code class="reqn">\Lambda</code> is the cumulative intensity process.
</p>

<hr>
<h2 id='simchildren'>Simulate the child events
<code>simchildren</code> simulates the birth times of all child events
spawned from an event relative the birth time of the parent
event. This function is to be called by the simulator function for
offspring events and is not meant for external use.</h2><span id='topic+simchildren'></span>

<h3>Description</h3>

<p>Simulate the child events
<code>simchildren</code> simulates the birth times of all child events
spawned from an event relative the birth time of the parent
event. This function is to be called by the simulator function for
offspring events and is not meant for external use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simchildren(br = 0.5, dis = "exp", par.dis = list(rate = 1), cens = Inf, sorted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simchildren_+3A_br">br</code></td>
<td>
<p>numerical scalar in [0,1), the branching ratio, or the
expected number of direct children due to an event</p>
</td></tr>
<tr><td><code id="simchildren_+3A_dis">dis</code></td>
<td>
<p>character string, which gives the name of the common
(positive) distribution of the birth times of the child events
relative to the parent event (referred to as the child
birthtime distribution), such as &quot;exp&quot;, &quot;gamma&quot;, &quot;weibull&quot;,
etc.</p>
</td></tr>
<tr><td><code id="simchildren_+3A_par.dis">par.dis</code></td>
<td>
<p>list, which gives the values of the (named)
parameter(s) of the child birthtime distribution)</p>
</td></tr>
<tr><td><code id="simchildren_+3A_cens">cens</code></td>
<td>
<p>positive scalar, which gives the censoring time
(termination of observation time). The default value of Inf means no
censoring. </p>
</td></tr>
<tr><td><code id="simchildren_+3A_sorted">sorted</code></td>
<td>
<p>boolean scalar, which indicates whether the out child
birth times should be sorted or not.  The default value is TRUE. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of length giving the birth times of child
events relative to the parent event in ascending order
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simoffspring">simoffspring</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  simchildren(br=0.9,dis="exp",par.dis=list(rate=1))
</code></pre>

<hr>
<h2 id='simHawkes0'>
Simulate a Hawkes process, or Self-exciting point process
</h2><span id='topic+simHawkes0'></span>

<h3>Description</h3>

<p>Simulate an (inhomogeneous) self-exciting process with given background
intensity and excitation/fertility function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simHawkes0(nu, g, cens = 1,
           nuM=max(optimize(nu,c(0,cens),maximum=TRUE)$obj,nu(0),nu(cens))*1.1,
           gM=max(optimize(g,c(0,cens),maximum=TRUE)$obj, g(0),g(cens))*1.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simHawkes0_+3A_nu">nu</code></td>
<td>

<p>A (vectorized) function. The baseline intensity function. 
</p>
</td></tr>
<tr><td><code id="simHawkes0_+3A_g">g</code></td>
<td>

<p>A (vectorized) function. The excitation function. 
</p>
</td></tr>
<tr><td><code id="simHawkes0_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time, or the time of termination of observations. 
</p>
</td></tr>
<tr><td><code id="simHawkes0_+3A_num">nuM</code></td>
<td>

<p>A scalar. The maximum time of the baseline intensity from 0 to <code>cens</code>.
</p>
</td></tr>
<tr><td><code id="simHawkes0_+3A_gm">gM</code></td>
<td>

<p>A scalar. The maximum time of the excitation function from 0 to <code>cens</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by simulating the birth times generation by
generation according to inhomegenous Poisson processes with
appropriate intensity functions (<code class="reqn">\nu</code> or <code class="reqn">g</code>). 
</p>


<h3>Value</h3>

<p>A list of vectors of arrival/birth times of individuals/events of
generations 0, 1, .... 
</p>


<h3>Note</h3>

<p>Same algorithm as in <code>simHawkes1</code>, though the latter might be
more succinct and (very slightly) faster. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>simHawkes1</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>asepp &lt;- simHawkes0(nu=function(x)200*(2+cos(2*pi*x)),nuM=600,
                               g=function(x)8*exp(-16*x),gM=8)
</code></pre>

<hr>
<h2 id='simHawkes1'>
Simulate a Hawkes process, or Self-exciting point process
</h2><span id='topic+simHawkes1'></span>

<h3>Description</h3>

<p>Simulate an (inhomogeneous) self-exciting process with given background
intensity and excitation/fertility function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simHawkes1(nu=NULL, g=NULL, cens = 1,
           nuM=max(optimize(nu,c(0,cens),maximum=TRUE)$obj, nu(0), nu(cens))*1.1,
           gM=max(optimize(g,c(0,cens),maximum = TRUE)$obj, g(0),
g(cens))*1.1,
           exp.g=FALSE,gp=c(1,2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simHawkes1_+3A_nu">nu</code></td>
<td>

<p>A (vectorized) function. The baseline intensity function. 
</p>
</td></tr>
<tr><td><code id="simHawkes1_+3A_g">g</code></td>
<td>

<p>A (vectorized) function. The excitation function. 
</p>
</td></tr>
<tr><td><code id="simHawkes1_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time, or the time of termination of observations. 
</p>
</td></tr>
<tr><td><code id="simHawkes1_+3A_num">nuM</code></td>
<td>

<p>A scalar. The maximum time of the baseline intensity from 0 to <code>cens</code>.
</p>
</td></tr>
<tr><td><code id="simHawkes1_+3A_gm">gM</code></td>
<td>

<p>A scalar. The maximum time of the excitation function from 0 to <code>cens</code>.
</p>
</td></tr>
<tr><td><code id="simHawkes1_+3A_exp.g">exp.g</code></td>
<td>

<p>A logical. Whether the excitation function <code>g</code> should be treated as an
exponential function.
</p>
</td></tr>
<tr><td><code id="simHawkes1_+3A_gp">gp</code></td>
<td>

<p>A vector of two elements, giving the two parameters a and b in the
exponential excitation function <code class="reqn">g(x)=a*exp(-b*x)</code>, which is
used when <code>exp.g</code> is set to TRUE, and is ignored otherwise. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by simulating the birth times generation by
generation according to inhomegenous Poisson processes with
appropriate intensity functions (<code class="reqn">\nu</code> or <code class="reqn">g</code>). 
</p>


<h3>Value</h3>

<p>A list of vectors of arrival/birth times of individuals/events of
generations 0, 1, ... The length of the list is the total number of
generations.   
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>simHawkes0</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  asepp &lt;- simHawkes1(nu=function(x)200*(2+cos(2*pi*x)),nuM=600,
                      g=function(x)8*exp(-16*x),gM=8)
</code></pre>

<hr>
<h2 id='simHawkes1a'>Simulate an (inhomogeneous) Hawkes self-exciting process
<code>simHawkes1a</code> simulates the event times of an inhomogeneous
Hawkes process (IHSEP) with background event intensity/rate
<code class="reqn">nu(\cdot)\geq 0</code>, branching ratio <code class="reqn">\eta\in[0,1)</code>, and
offspring birthtime density <code class="reqn">g(\cdot)</code>, up to a censoring time
<code class="reqn">T</code>.</h2><span id='topic+simHawkes1a'></span>

<h3>Description</h3>

<p>Simulate an (inhomogeneous) Hawkes self-exciting process
<code>simHawkes1a</code> simulates the event times of an inhomogeneous
Hawkes process (IHSEP) with background event intensity/rate
<code class="reqn">nu(\cdot)\geq 0</code>, branching ratio <code class="reqn">\eta\in[0,1)</code>, and
offspring birthtime density <code class="reqn">g(\cdot)</code>, up to a censoring time
<code class="reqn">T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simHawkes1a(
  nu = function(x) rep(100, length(x)),
  cens = 1,
  nuM = max(optimize(nu, c(0, cens), maximum = TRUE)$obj, nu(0), nu(cens),
    .Machine$double.eps^0.5) * 1.1,
  br = 0.5,
  dis = "exp",
  par.dis = list(rate = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simHawkes1a_+3A_nu">nu</code></td>
<td>
<p>a function, which gives the background event intensity
function <code class="reqn">\nu(\cdot)</code>; needs to be a bounded function on
<code class="reqn">[0,T]</code>.</p>
</td></tr>
<tr><td><code id="simHawkes1a_+3A_cens">cens</code></td>
<td>
<p>a positive scalar, which gives the censoring time.</p>
</td></tr>
<tr><td><code id="simHawkes1a_+3A_num">nuM</code></td>
<td>
<p>positive scalar, optional argument giving the maximum
of the background intensity function on <code class="reqn">[0,T]</code>.</p>
</td></tr>
<tr><td><code id="simHawkes1a_+3A_br">br</code></td>
<td>
<p>scalar in [0,1), giving the branching ratio.</p>
</td></tr>
<tr><td><code id="simHawkes1a_+3A_dis">dis</code></td>
<td>
<p>character string giving the name of the child birthtime
distribution; 'd$dis' gives the density function <code class="reqn">g(\cdot)</code>.</p>
</td></tr>
<tr><td><code id="simHawkes1a_+3A_par.dis">par.dis</code></td>
<td>
<p>a (named) list giving the values of the parameters of the child birthtime distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector giving the event times of an inhomogeneous Hawkes process up to the censoring time in ascending order.
</p>

<hr>
<h2 id='simoffspring'>Simulate the offspring events
<code>simoffspring</code> simulates the birth times of offspring events
of all generations spawned from an event relative the birth time of
the parent event. This function is to be called by the simulator
function for Hawkes processes and is not meant for external use.</h2><span id='topic+simoffspring'></span>

<h3>Description</h3>

<p>Simulate the offspring events
<code>simoffspring</code> simulates the birth times of offspring events
of all generations spawned from an event relative the birth time of
the parent event. This function is to be called by the simulator
function for Hawkes processes and is not meant for external use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simoffspring(br = 0.5, dis = "exp", par.dis = list(rate = 1), cens = Inf, sorted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simoffspring_+3A_br">br</code></td>
<td>
<p>numerical scalar in [0,1), the branching ratio, or the
expected number of direct children due to an event</p>
</td></tr>
<tr><td><code id="simoffspring_+3A_dis">dis</code></td>
<td>
<p>character string, which gives the name of the common
(positive) distribution of the birth times of the child events
relative to the parent event (referred to as the child
birthtime distribution), such as &quot;exp&quot;, &quot;gamma&quot;, &quot;weibull&quot;,
etc.</p>
</td></tr>
<tr><td><code id="simoffspring_+3A_par.dis">par.dis</code></td>
<td>
<p>list, which gives the values of the (named)
parameter(s) of the child birthtime distribution)</p>
</td></tr>
<tr><td><code id="simoffspring_+3A_cens">cens</code></td>
<td>
<p>numeric scalar, which gives the censoring time
(termination of observation time). The default value of Inf means no
censoring. </p>
</td></tr>
<tr><td><code id="simoffspring_+3A_sorted">sorted</code></td>
<td>
<p>boolean scalar, which indicates whether the out child
birth times should be sorted or not.  The default value is TRUE. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses recursion, so can break down when the
branching ratio is close to 1, leading to very deep
recursions. In this case, we should use <code>simHawkes1</code> for
Hawkes process simulation.
</p>


<h3>Value</h3>

<p>a numeric vector of giving the birth times of offspring
events of all generations relative to the parent's birth time
in ascending order
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simchildren">simchildren</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  simoffspring(br=0.9,dis="exp",par.dis=list(rate=1))
</code></pre>

<hr>
<h2 id='simPois'>
Simulate a Poisson process
</h2><span id='topic+simPois'></span>

<h3>Description</h3>

<p>Simulate an (inhomogeneous) Poisson process with a given intensity/rate 
function over the interval <code class="reqn">[0,T]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPois(int=NULL,cens=1,int.M=optimize(int,c(0,cens),maximum=TRUE)$obj*1.1,
        B=max(as.integer(sqrt(int.M * cens)),10), exp.int=FALSE,par=c(1,2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simPois_+3A_int">int</code></td>
<td>

<p>A (vectorized) positive function. The intensity/rate function.
</p>
</td></tr>
<tr><td><code id="simPois_+3A_cens">cens</code></td>
<td>

<p>A positive scalar. The censoring time, or time of termination of
observations, <code class="reqn">T</code>. 
</p>
</td></tr>
<tr><td><code id="simPois_+3A_int.m">int.M</code></td>
<td>

<p>A positive scalar. Maximum value of the intensity function over <code class="reqn">[0,T]</code>,
or a larger value. 
</p>
</td></tr>
<tr><td><code id="simPois_+3A_b">B</code></td>
<td>

<p>An integer. The block size to be used in generating exponential
random variables in blocks. 
</p>
</td></tr>
<tr><td><code id="simPois_+3A_exp.int">exp.int</code></td>
<td>

<p>Logical. Set to TRUE, if the intensity function is exponential,
i.e. a*exp(-b*x). If set to TRUE, the parameters a and b should also
be supplied via the argument par.
</p>
</td></tr>
<tr><td><code id="simPois_+3A_par">par</code></td>
<td>

<p>A numerical vector of two elements, giving the parameters a and b of
the exponential intensity function. The values are not ignored if
exp.int is set to FALSE. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by first generating a Poisson process with constant
rate <code>int.M</code> oever <code class="reqn">[0,T]</code>, and then thinning the process
with retention probability function
</p>
<p style="text-align: center;"><code class="reqn">p(x)=\code{int}(x)/\code{int.M}</code>
</p>
<p>. 
</p>
<p>When generating the homoneous Poisson process, it first generates
about <code class="reqn">\Lambda+1.96*\sqrt{\Lambda}</code> exponential variables, then,
if the exponential variables are not enough (their sum has not reached
the censoring time <code class="reqn">T</code> yet), generates exponential variables in
blocks of size <code>B</code> until the total of all the generated
exponentials exceeds <code class="reqn">T</code>. Then <code>cumsum</code>s of the exponentials
that are smaller than or equal to <code class="reqn">T</code> are retained as the event
times of the homogeneous Poisson process. This method apparantly does
not produce tied event times. 
</p>


<h3>Value</h3>

<p>A numerical vector giving the event/jump times of the Poisson process
in <code class="reqn">[0,T]</code>, in ascending order. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>simPois0</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (int, cens = 1, int.M = optimize(int, c(0, cens), maximum = TRUE)$obj * 
    1.1, B = max(as.integer(sqrt(int.M * cens)), 10)) 
{
    tms &lt;- rexp(as.integer(int.M * cens + 2 * sqrt(int.M * cens)), 
        rate = int.M)
    while (sum(tms) &lt; cens) tms &lt;- c(tms, rexp(B, rate = int.M))
    cumtms &lt;- cumsum(tms)
    tms &lt;- cumtms[cumtms &lt;= cens]
    N &lt;- length(tms)
    if (N == 0) 
        return(numeric(0))
    tms[as.logical(mapply(rbinom, n = 1, size = 1, prob = int(tms)/int.M))]
  }
</code></pre>

<hr>
<h2 id='simPois0'>
Simulate a Poisson process
</h2><span id='topic+simPois0'></span>

<h3>Description</h3>

<p>Simulate an (inhomogeneous) Poisson process with a given intensity/rate 
function over the interval <code class="reqn">[0,T]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPois0(int, cens = 1, int.M = optimize(int, c(0, cens), maximum = TRUE)$obj * 1.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simPois0_+3A_int">int</code></td>
<td>

<p>A (vectorized) positive function. The intensity/rate function. 
</p>
</td></tr>
<tr><td><code id="simPois0_+3A_cens">cens</code></td>
<td>

<p>A positive scalar. The censoring time, or time of termination of
observations, <code class="reqn">T</code>. 
</p>
</td></tr>
<tr><td><code id="simPois0_+3A_int.m">int.M</code></td>
<td>

<p>A positive scalar. Maximum value of the intensity function over <code class="reqn">[0,T]</code>,
or a value larger than this. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by first generating a Poisson process with constant
rate <code>int.M</code> oever <code class="reqn">[0,T]</code>, and then thinning the process
with retention probability function
</p>
<p style="text-align: center;"><code class="reqn">p(x)=\code{int}(x)/\code{int.M}</code>
</p>
<p>. 
</p>


<h3>Value</h3>

<p>A numerical vector giving the event/jump times of the Poisson process
in <code class="reqn">[0,T]</code>, in ascending order. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>simPois0</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  aPP &lt;- simPois(int=function(x)200*(2+cos(2*pi*x)),cens=1,int.M=600)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
