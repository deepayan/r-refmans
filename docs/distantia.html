<!DOCTYPE html><html lang="en-US"><head><title>Help for package distantia</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distantia}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#distantia-package'><p>distantia: A Toolset for Time Series Dissimilarity Analysis</p></a></li>
<li><a href='#albatross'><p>Flight Path Time Series of Albatrosses in The Pacific</p></a></li>
<li><a href='#auto_distance_cpp'><p>(C++) Sum Distances Between Consecutive Samples in a Time Series</p></a></li>
<li><a href='#auto_sum_cpp'><p>(C++) Sum Distances Between Consecutive Samples in Two Time Series</p></a></li>
<li><a href='#auto_sum_full_cpp'><p>(C++) Sum Distances Between All Consecutive Samples in Two Time Series</p></a></li>
<li><a href='#auto_sum_path_cpp'><p>(C++) Sum Distances Between All Consecutive Samples in the Least Cost Path Between Two Time Series</p></a></li>
<li><a href='#cities_coordinates'><p>Coordinates of 100 Major Cities</p></a></li>
<li><a href='#cities_temperature'><p>Long Term Monthly Temperature in 20 Major Cities</p></a></li>
<li><a href='#color_continuous'><p>Default Continuous Color Palette</p></a></li>
<li><a href='#color_discrete'><p>Default Discrete Color Palettes</p></a></li>
<li><a href='#cost_matrix_diagonal_cpp'><p>(C++) Compute Orthogonal and Diagonal Least Cost Matrix from a Distance Matrix</p></a></li>
<li><a href='#cost_matrix_diagonal_weighted_cpp'><p>(C++) Compute Orthogonal and Weighted Diagonal Least Cost Matrix from a Distance Matrix</p></a></li>
<li><a href='#cost_matrix_orthogonal_cpp'><p>(C++) Compute Orthogonal Least Cost Matrix from a Distance Matrix</p></a></li>
<li><a href='#cost_path_cpp'><p>Least Cost Path</p></a></li>
<li><a href='#cost_path_diagonal_bandwidth_cpp'><p>(C++) Orthogonal and Diagonal Least Cost Path Restricted by Sakoe-Chiba band</p></a></li>
<li><a href='#cost_path_diagonal_cpp'><p>(C++) Orthogonal and Diagonal Least Cost Path</p></a></li>
<li><a href='#cost_path_orthogonal_bandwidth_cpp'><p>(C++) Orthogonal Least Cost Path</p></a></li>
<li><a href='#cost_path_orthogonal_cpp'><p>(C++) Orthogonal Least Cost Path</p></a></li>
<li><a href='#cost_path_slotting_cpp'><p>(C++) Least Cost Path for Sequence Slotting</p></a></li>
<li><a href='#cost_path_sum_cpp'><p>(C++) Sum Distances in a Least Cost Path</p></a></li>
<li><a href='#cost_path_trim_cpp'><p>(C++) Remove Blocks from a Least Cost Path</p></a></li>
<li><a href='#covid_counties'><p>County Coordinates of the Covid Prevalence Dataset</p></a></li>
<li><a href='#covid_prevalence'><p>Time Series of Covid Prevalence in California Counties</p></a></li>
<li><a href='#distance'><p>Distance Between Two Numeric Vectors</p></a></li>
<li><a href='#distance_bray_curtis_cpp'><p>(C++) Bray-Curtis Distance Between Two Vectors</p></a></li>
<li><a href='#distance_canberra_cpp'><p>(C++) Canberra Distance Between Two Binary Vectors</p></a></li>
<li><a href='#distance_chebyshev_cpp'><p>(C++) Chebyshev Distance Between Two Vectors</p></a></li>
<li><a href='#distance_chi_cpp'><p>(C++) Normalized Chi Distance Between Two Vectors</p></a></li>
<li><a href='#distance_cosine_cpp'><p>(C++) Cosine Dissimilarity Between Two Vectors</p></a></li>
<li><a href='#distance_euclidean_cpp'><p>(C++) Euclidean Distance Between Two Vectors</p></a></li>
<li><a href='#distance_hamming_cpp'><p>(C++) Hamming Distance Between Two Binary Vectors</p></a></li>
<li><a href='#distance_hellinger_cpp'><p>(C++) Hellinger Distance Between Two Vectors</p></a></li>
<li><a href='#distance_jaccard_cpp'><p>(C++) Jaccard Distance Between Two Binary Vectors</p></a></li>
<li><a href='#distance_ls_cpp'><p>(C++) Sum of Pairwise Distances Between Cases in Two Aligned Time Series</p></a></li>
<li><a href='#distance_manhattan_cpp'><p>(C++) Manhattan Distance Between Two Vectors</p></a></li>
<li><a href='#distance_matrix'><p>Data Frame to Distance Matrix</p></a></li>
<li><a href='#distance_matrix_cpp'><p>(C++) Distance Matrix of Two Time Series</p></a></li>
<li><a href='#distance_russelrao_cpp'><p>(C++) Russell-Rao Distance Between Two Binary Vectors</p></a></li>
<li><a href='#distance_sorensen_cpp'><p>(C++) SÃ¸rensen Distance Between Two Binary Vectors</p></a></li>
<li><a href='#distances'><p>Distance Methods</p></a></li>
<li><a href='#distantia'><p>Dissimilarity Analysis of Time Series Lists</p></a></li>
<li><a href='#distantia_aggregate'><p>Aggregate <code>distantia()</code> Data Frames Across Parameter Combinations</p></a></li>
<li><a href='#distantia_boxplot'><p>Distantia Boxplot</p></a></li>
<li><a href='#distantia_cluster_hclust'><p>Hierarchical Clustering of Dissimilarity Analysis Data Frames</p></a></li>
<li><a href='#distantia_cluster_kmeans'><p>K-Means Clustering of Dissimilarity Analysis Data Frames</p></a></li>
<li><a href='#distantia_dtw'><p>Dynamic Time Warping Dissimilarity Analysis of Time Series Lists</p></a></li>
<li><a href='#distantia_dtw_plot'><p>Two-Way Dissimilarity Plots of Time Series Lists</p></a></li>
<li><a href='#distantia_ls'><p>Lock-Step Dissimilarity Analysis of Time Series Lists</p></a></li>
<li><a href='#distantia_matrix'><p>Convert Dissimilarity Analysis Data Frame to Distance Matrix</p></a></li>
<li><a href='#distantia_model_frame'><p>Dissimilarity Model Frame</p></a></li>
<li><a href='#distantia_spatial'><p>Spatial Representation of <code>distantia()</code> Data Frames</p></a></li>
<li><a href='#distantia_stats'><p>Stats of Dissimilarity Data Frame</p></a></li>
<li><a href='#distantia_time_delay'><p>Time Shift Between Time Series</p></a></li>
<li><a href='#eemian_coordinates'><p>Site Coordinates of Nine Interglacial Sites in Central Europe</p></a></li>
<li><a href='#eemian_pollen'><p>Pollen Counts of Nine Interglacial Sites in Central Europe</p></a></li>
<li><a href='#f_binary'><p>Transform Zoo Object to Binary</p></a></li>
<li><a href='#f_clr'><p>Data Transformation: Rowwise Centered Log-Ratio</p></a></li>
<li><a href='#f_detrend_difference'><p>Data Transformation: Detrending and Differencing</p></a></li>
<li><a href='#f_detrend_linear'><p>Data Transformation: Linear Detrending of Zoo Time Series</p></a></li>
<li><a href='#f_detrend_poly'><p>Data Transformation: Polynomial Linear Detrending of Zoo Time Series</p></a></li>
<li><a href='#f_hellinger'><p>Data Transformation: Rowwise Hellinger Transformation</p></a></li>
<li><a href='#f_list'><p>Lists Available Transformation Functions</p></a></li>
<li><a href='#f_log'><p>Data Transformation: Log</p></a></li>
<li><a href='#f_percent'><p>Data Transformation: Rowwise Percentages</p></a></li>
<li><a href='#f_proportion'><p>Data Transformation: Rowwise Proportions</p></a></li>
<li><a href='#f_proportion_sqrt'><p>Data Transformation: Rowwise Square Root of Proportions</p></a></li>
<li><a href='#f_rescale_global'><p>Data Transformation: Global Rescaling of to a New Range</p></a></li>
<li><a href='#f_rescale_local'><p>Data Transformation: Local Rescaling of to a New Range</p></a></li>
<li><a href='#f_scale_global'><p>Data Transformation: Global Centering and Scaling</p></a></li>
<li><a href='#f_scale_local'><p>Data Transformation: Local Centering and Scaling</p></a></li>
<li><a href='#f_trend_linear'><p>Data Transformation: Linear Trend of Zoo Time Series</p></a></li>
<li><a href='#f_trend_poly'><p>Data Transformation: Polynomial Linear Trend of Zoo Time Series</p></a></li>
<li><a href='#fagus_coordinates'><p>Site Coordinates of Fagus sylvatica Stands</p></a></li>
<li><a href='#fagus_dynamics'><p>Time Series Data from Three Fagus sylvatica Stands</p></a></li>
<li><a href='#honeycomb_climate'><p>Rainfall and Temperature in The Americas</p></a></li>
<li><a href='#honeycomb_polygons'><p>Hexagonal Grid</p></a></li>
<li><a href='#importance_dtw_cpp'><p>(C++) Contribution of Individual Variables to the Dissimilarity Between Two Time Series (Robust Version)</p></a></li>
<li><a href='#importance_dtw_legacy_cpp'><p>(C++) Contribution of Individual Variables to the Dissimilarity Between Two Time Series (Legacy Version)</p></a></li>
<li><a href='#importance_ls_cpp'><p>(C++) Contribution of Individual Variables to the Dissimilarity Between Two Aligned Time Series</p></a></li>
<li><a href='#momentum'><p>Contribution of Individual Variables to Time Series Dissimilarity</p></a></li>
<li><a href='#momentum_aggregate'><p>Aggregate <code>momentum()</code> Data Frames Across Parameter Combinations</p></a></li>
<li><a href='#momentum_boxplot'><p>Momentum Boxplot</p></a></li>
<li><a href='#momentum_dtw'><p>Dynamic Time Warping Variable Importance Analysis of Multivariate Time Series Lists</p></a></li>
<li><a href='#momentum_ls'><p>Lock-Step Variable Importance Analysis of Multivariate Time Series Lists</p></a></li>
<li><a href='#momentum_model_frame'><p>Dissimilarity Model Frame</p></a></li>
<li><a href='#momentum_spatial'><p>Spatial Representation of <code>momentum()</code> Data Frames</p></a></li>
<li><a href='#momentum_stats'><p>Stats of Dissimilarity Data Frame</p></a></li>
<li><a href='#momentum_to_wide'><p>Momentum Data Frame to Wide Format</p></a></li>
<li><a href='#permute_free_by_row_cpp'><p>(C++) Unrestricted Permutation of Complete Rows</p></a></li>
<li><a href='#permute_free_cpp'><p>(C++) Unrestricted Permutation of Cases</p></a></li>
<li><a href='#permute_restricted_by_row_cpp'><p>(C++) Restricted Permutation of Complete Rows Within Blocks</p></a></li>
<li><a href='#permute_restricted_cpp'><p>(C++) Restricted Permutation of Cases Within Blocks</p></a></li>
<li><a href='#psi_auto_distance'><p>Cumulative Sum of Distances Between Consecutive Cases in a Time Series</p></a></li>
<li><a href='#psi_auto_sum'><p>Auto Sum</p></a></li>
<li><a href='#psi_cost_matrix'><p>Cost Matrix</p></a></li>
<li><a href='#psi_cost_path'><p>Least Cost Path</p></a></li>
<li><a href='#psi_cost_path_sum'><p>Sum of Distances in Least Cost Path</p></a></li>
<li><a href='#psi_distance_lock_step'><p>Lock-Step Distance</p></a></li>
<li><a href='#psi_distance_matrix'><p>Distance Matrix</p></a></li>
<li><a href='#psi_dtw_cpp'><p>(C++) Psi Dissimilarity Score of Two Time-Series</p></a></li>
<li><a href='#psi_equation'><p>Normalized Dissimilarity Score</p></a></li>
<li><a href='#psi_equation_cpp'><p>(C++) Equation of the Psi Dissimilarity Score</p></a></li>
<li><a href='#psi_ls_cpp'><p>(C++) Psi Dissimilarity Score of Two Aligned Time Series</p></a></li>
<li><a href='#psi_null_dtw_cpp'><p>(C++) Null Distribution of Dissimilarity Scores of Two Time Series</p></a></li>
<li><a href='#psi_null_ls_cpp'><p>(C++) Null Distribution of the Dissimilarity Scores of Two Aligned Time Series</p></a></li>
<li><a href='#subset_matrix_by_rows_cpp'><p>(C++) Subset Matrix by Rows</p></a></li>
<li><a href='#tsl_aggregate'><p>Aggregate Time Series List Over Time Periods</p></a></li>
<li><a href='#tsl_burst'><p>Multivariate TSL to Univariate TSL</p></a></li>
<li><a href='#tsl_colnames_clean'><p>Clean Column Names in Time Series Lists</p></a></li>
<li><a href='#tsl_colnames_get'><p>Get Column Names from a Time Series Lists</p></a></li>
<li><a href='#tsl_colnames_prefix'><p>Append Prefix to Column Names of Time Series List</p></a></li>
<li><a href='#tsl_colnames_set'><p>Set Column Names in Time Series Lists</p></a></li>
<li><a href='#tsl_colnames_suffix'><p>Append Suffix to Column Names of Time Series List</p></a></li>
<li><a href='#tsl_count_NA'><p>Count NA Cases in Time Series Lists</p></a></li>
<li><a href='#tsl_diagnose'><p>Diagnose Issues in Time Series Lists</p></a></li>
<li><a href='#tsl_handle_NA'><p>Handle NA Cases in Time Series Lists</p></a></li>
<li><a href='#tsl_initialize'><p>Transform Raw Time Series Data to Time Series List</p></a></li>
<li><a href='#tsl_join'><p>Join Time Series Lists</p></a></li>
<li><a href='#tsl_names_clean'><p>Clean Time Series Names in a Time Series List</p></a></li>
<li><a href='#tsl_names_get'><p>Get Time Series Names from a Time Series Lists</p></a></li>
<li><a href='#tsl_names_set'><p>Set Time Series Names in a Time Series List</p></a></li>
<li><a href='#tsl_names_test'><p>Tests Naming Issues in Time Series Lists</p></a></li>
<li><a href='#tsl_ncol'><p>Get Number of Columns in Time Series Lists</p></a></li>
<li><a href='#tsl_nrow'><p>Get Number of Rows in Time Series Lists</p></a></li>
<li><a href='#tsl_plot'><p>Plot Time Series List</p></a></li>
<li><a href='#tsl_repair'><p>Repair Issues in Time Series Lists</p></a></li>
<li><a href='#tsl_resample'><p>Resample Time Series Lists to a New Time</p></a></li>
<li><a href='#tsl_simulate'><p>Simulate a Time Series List</p></a></li>
<li><a href='#tsl_smooth'><p>Smoothing of Time Series Lists</p></a></li>
<li><a href='#tsl_stats'><p>Summary Statistics of Time Series Lists</p></a></li>
<li><a href='#tsl_subset'><p>Subset Time Series Lists by Time Series Names, Time, and/or Column Names</p></a></li>
<li><a href='#tsl_time'><p>Time Features of Time Series Lists</p></a></li>
<li><a href='#tsl_to_df'><p>Transform Time Series List to Data Frame</p></a></li>
<li><a href='#tsl_transform'><p>Transform Values in Time Series Lists</p></a></li>
<li><a href='#utils_as_time'><p>Ensures Correct Class for Time Arguments</p></a></li>
<li><a href='#utils_block_size'><p>Default Block Size for Restricted Permutation in Dissimilarity Analyses</p></a></li>
<li><a href='#utils_boxplot_common'><p>Common Boxplot Component of <code>distantia_boxplot()</code> and <code>momentum_boxplot()</code></p></a></li>
<li><a href='#utils_check_args_distantia'><p>Check Input Arguments of <code>distantia()</code></p></a></li>
<li><a href='#utils_check_args_matrix'><p>Checks Input Matrix</p></a></li>
<li><a href='#utils_check_args_momentum'><p>Check Input Arguments of <code>momentum()</code></p></a></li>
<li><a href='#utils_check_args_path'><p>Checks Least Cost Path</p></a></li>
<li><a href='#utils_check_args_tsl'><p>Structural Check for Time Series Lists</p></a></li>
<li><a href='#utils_check_args_zoo'><p>Checks Argument x</p></a></li>
<li><a href='#utils_check_distance_args'><p>Check Distance Argument</p></a></li>
<li><a href='#utils_check_list_class'><p>Checks Classes of List Elements Against Expectation</p></a></li>
<li><a href='#utils_clean_names'><p>Clean Character Vector of Names</p></a></li>
<li><a href='#utils_cluster_hclust_optimizer'><p>Optimize the Silhouette Width of Hierarchical Clustering Solutions</p></a></li>
<li><a href='#utils_cluster_kmeans_optimizer'><p>Optimize the Silhouette Width of K-Means Clustering Solutions</p></a></li>
<li><a href='#utils_cluster_silhouette'><p>Compute Silhouette Width of a Clustering Solution</p></a></li>
<li><a href='#utils_coerce_time_class'><p>Coerces Vector to a Given Time Class</p></a></li>
<li><a href='#utils_color_breaks'><p>Auto Breaks for Matrix Plotting Functions</p></a></li>
<li><a href='#utils_digits'><p>Number of Decimal Places</p></a></li>
<li><a href='#utils_distantia_df_split'><p>Split Dissimilarity Analysis Data Frames by Combinations of Arguments</p></a></li>
<li><a href='#utils_drop_geometry'><p>Removes Geometry Column from SF Data Frames</p></a></li>
<li><a href='#utils_global_scaling_params'><p>Global Centering and Scaling Parameters of Time Series Lists</p></a></li>
<li><a href='#utils_is_time'><p>Title</p></a></li>
<li><a href='#utils_line_color'><p>Handles Line Colors for Sequence Plots</p></a></li>
<li><a href='#utils_line_guide'><p>Guide for Time Series Plots</p></a></li>
<li><a href='#utils_matrix_guide'><p>Color Guide for Matrix Plot</p></a></li>
<li><a href='#utils_matrix_plot'><p>Plot Distance or Cost Matrix and Least Cost Path</p></a></li>
<li><a href='#utils_new_time'><p>New Time for Time Series Aggregation</p></a></li>
<li><a href='#utils_optimize_loess'><p>Optimize Loess Models for Time Series Resampling</p></a></li>
<li><a href='#utils_optimize_spline'><p>Optimize Spline Models for Time Series Resampling</p></a></li>
<li><a href='#utils_prepare_df'><p>Convert Data Frame to a List of Data Frames</p></a></li>
<li><a href='#utils_prepare_matrix'><p>Convert Matrix to Data Frame</p></a></li>
<li><a href='#utils_prepare_matrix_list'><p>Convert List of Matrices to List of Data Frames</p></a></li>
<li><a href='#utils_prepare_time'><p>Handles Time Column in a List of Data Frames</p></a></li>
<li><a href='#utils_prepare_vector_list'><p>Convert List of Vectors to List of Data Frames</p></a></li>
<li><a href='#utils_prepare_zoo_list'><p>Convert List of Data Frames to List of Zoo Objects</p></a></li>
<li><a href='#utils_rescale_vector'><p>Rescale Numeric Vector to a New Data Range</p></a></li>
<li><a href='#utils_time_keywords'><p>Valid Aggregation Keywords</p></a></li>
<li><a href='#utils_time_keywords_dictionary'><p>Dictionary of Time Keywords</p></a></li>
<li><a href='#utils_time_keywords_translate'><p>Translates The User's Time Keywords Into Valid Ones</p></a></li>
<li><a href='#utils_time_units'><p>Data Frame with Supported Time Units</p></a></li>
<li><a href='#utils_tsl_pairs'><p>Data Frame with Pairs of Time Series in Time Series Lists</p></a></li>
<li><a href='#zoo_aggregate'><p>Aggregate Cases in Zoo Time Series</p></a></li>
<li><a href='#zoo_name_clean'><p>Clean Name of a Zoo Time Series</p></a></li>
<li><a href='#zoo_name_get'><p>Get Name of a Zoo Time Series</p></a></li>
<li><a href='#zoo_name_set'><p>Set Name of a Zoo Time Series</p></a></li>
<li><a href='#zoo_permute'><p>Random or Restricted Permutation of Zoo Time Series</p></a></li>
<li><a href='#zoo_plot'><p>Plot Zoo Time Series</p></a></li>
<li><a href='#zoo_resample'><p>Resample Zoo Objects to a New Time</p></a></li>
<li><a href='#zoo_simulate'><p>Simulate a Zoo Time Series</p></a></li>
<li><a href='#zoo_smooth_exponential'><p>Exponential Smoothing of Zoo Time Series</p></a></li>
<li><a href='#zoo_smooth_window'><p>Rolling Window Smoothing of Zoo Time Series</p></a></li>
<li><a href='#zoo_time'><p>Get Time Features from Zoo Objects</p></a></li>
<li><a href='#zoo_to_tsl'><p>Convert Individual Zoo Objects to Time Series List</p></a></li>
<li><a href='#zoo_vector_to_matrix'><p>Coerce Coredata of Univariate Zoo Time Series to Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Advanced Toolset for Efficient Time Series Dissimilarity
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://blasbenito.github.io/distantia/">https://blasbenito.github.io/distantia/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/BlasBenito/distantia/issues">https://github.com/BlasBenito/distantia/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Fast C++ implementation of Dynamic Time Warping for time series dissimilarity analysis, with applications in environmental monitoring and sensor data analysis, climate science, signal processing and pattern recognition, and financial data analysis. Built upon the ideas presented in Benito and Birks (2020) &lt;<a href="https://doi.org/10.1111%2Fecog.04895">doi:10.1111/ecog.04895</a>&gt;, provides tools for analyzing time series of varying lengths and structures, including irregular multivariate time series. Key features include individual variable contribution analysis, restricted permutation tests for statistical significance, and imputation of missing data via GAMs. Additionally, the package provides an ample set of tools to prepare and manage time series data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1), doFuture</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, zoo, foreach, future.apply, lubridate, progressr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>roxyglobals, spelling, sf, lwgeom, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/roxyglobals/filename:</td>
<td>globals.R</td>
</tr>
<tr>
<td>Config/roxyglobals/unique:</td>
<td>FALSE</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-01 19:32:45 UTC; blas</td>
</tr>
<tr>
<td>Author:</td>
<td>Blas M. Benito <a href="https://orcid.org/0000-0001-5105-7232"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Blas M. Benito &lt;blasbenito@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-01 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='distantia-package'>distantia: A Toolset for Time Series Dissimilarity Analysis</h2><span id='topic+distantia-package'></span>

<h3>Description</h3>

<p>Fast C++ implementation of Dynamic Time Warping for time series dissimilarity analysis, with applications in environmental monitoring and sensor data analysis, climate science, signal processing and pattern recognition, and financial data analysis. Built upon the ideas presented in Benito and Birks (2020) <a href="doi:doi.org/10.1111/ecog.04895">doi:doi.org/10.1111/ecog.04895</a>, provides tools for analyzing time series of varying lengths and structures, including irregular multivariate time series. Key features include individual variable contribution analysis, restricted permutation tests for statistical significance, and imputation of missing data via GAMs. Additionally, the package provides an ample set of tools to prepare and manage time series data.
</p>


<h3>Author(s)</h3>

<p>Blas Benito <a href="mailto:blasbenito@gmail.com">blasbenito@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://blasbenito.github.io/distantia/">https://blasbenito.github.io/distantia/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/BlasBenito/distantia/issues">https://github.com/BlasBenito/distantia/issues</a>
</p>
</li></ul>


<hr>
<h2 id='albatross'>Flight Path Time Series of Albatrosses in The Pacific</h2><span id='topic+albatross'></span>

<h3>Description</h3>

<p>Daily mean flight path data of 4 individuals of Waved Albatross (Phoebastria irrorata) captured via GPS during the summer of 2008. Sf data frame with columns name, time, latitude, longitude, ground speed, heading, and (uncalibrated) temperature.
</p>
<p>The full dataset at hourly resolution can be downloaded from <a href="https://github.com/BlasBenito/distantia/blob/main/data_full/albatross.rda">https://github.com/BlasBenito/distantia/blob/main/data_full/albatross.rda</a> (use the &quot;Download raw file&quot; button).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(albatross)
</code></pre>


<h3>Format</h3>

<p>data frame
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.5441/001/1.3hp3s250">doi:10.5441/001/1.3hp3s250</a>
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load as tsl
#scale al variables
#aggregate to daily resolution
#align all time series to same temporal span
tsl &lt;- tsl_initialize(
  x = albatross,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_local
  ) |&gt;
  tsl_aggregate(
    new_time = "days"
  )

if(interactive()){
  tsl_plot(
    tsl = tsl,
    guide_columns = 5
    )
}
</code></pre>

<hr>
<h2 id='auto_distance_cpp'>(C++) Sum Distances Between Consecutive Samples in a Time Series</h2><span id='topic+auto_distance_cpp'></span>

<h3>Description</h3>

<p>Computes the cumulative sum of distances between consecutive
samples in a univariate or multivariate time series.
NA values should be removed before using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_distance_cpp(x, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_distance_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) univariate or multivariate time series.</p>
</td></tr>
<tr><td><code id="auto_distance_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_auto_sum: 
<code><a href="#topic+auto_sum_cpp">auto_sum_cpp</a>()</code>,
<code><a href="#topic+auto_sum_full_cpp">auto_sum_full_cpp</a>()</code>,
<code><a href="#topic+auto_sum_path_cpp">auto_sum_path_cpp</a>()</code>,
<code><a href="#topic+subset_matrix_by_rows_cpp">subset_matrix_by_rows_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate a time series
x &lt;- zoo_simulate()

#compute auto distance
auto_distance_cpp(
  x = x,
  distance = "euclidean"
  )
</code></pre>

<hr>
<h2 id='auto_sum_cpp'>(C++) Sum Distances Between Consecutive Samples in Two Time Series</h2><span id='topic+auto_sum_cpp'></span>

<h3>Description</h3>

<p>Sum of auto-distances of two time series.
This function switches between <code><a href="#topic+auto_sum_full_cpp">auto_sum_full_cpp()</a></code> and <code><a href="#topic+auto_sum_path_cpp">auto_sum_path_cpp()</a></code>
depending on the value of the argument <code>ignore_blocks</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_sum_cpp(x, y, path, distance = "euclidean", ignore_blocks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_sum_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) of same number of columns as 'y'.</p>
</td></tr>
<tr><td><code id="auto_sum_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) of same number of columns as 'x'.</p>
</td></tr>
<tr><td><code id="auto_sum_cpp_+3A_path">path</code></td>
<td>
<p>(required, data frame) output of <code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp()</a></code>.</p>
</td></tr>
<tr><td><code id="auto_sum_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="auto_sum_cpp_+3A_ignore_blocks">ignore_blocks</code></td>
<td>
<p>(optional, logical). If TRUE, blocks of consecutive path
coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_auto_sum: 
<code><a href="#topic+auto_distance_cpp">auto_distance_cpp</a>()</code>,
<code><a href="#topic+auto_sum_full_cpp">auto_sum_full_cpp</a>()</code>,
<code><a href="#topic+auto_sum_path_cpp">auto_sum_path_cpp</a>()</code>,
<code><a href="#topic+subset_matrix_by_rows_cpp">subset_matrix_by_rows_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#distance matrix
dist_matrix &lt;- distance_matrix_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

#least cost matrix
cost_matrix &lt;- cost_matrix_orthogonal_cpp(
  dist_matrix = dist_matrix
)

#least cost path
cost_path &lt;- cost_path_orthogonal_cpp(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix
)

nrow(cost_path)

#remove blocks from least-cost path
cost_path_trimmed &lt;- cost_path_trim_cpp(
  path = cost_path
)

nrow(cost_path_trimmed)

#auto sum
auto_sum_cpp(
  x = x,
  y = y,
  path = cost_path_trimmed,
  distance = "euclidean",
  ignore_blocks = FALSE
)
</code></pre>

<hr>
<h2 id='auto_sum_full_cpp'>(C++) Sum Distances Between All Consecutive Samples in Two Time Series</h2><span id='topic+auto_sum_full_cpp'></span>

<h3>Description</h3>

<p>Computes the cumulative auto sum of autodistances of two time series.
The output value is used as normalization factor when computing dissimilarity scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_sum_full_cpp(x, y, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_sum_full_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) univariate or multivariate time series.</p>
</td></tr>
<tr><td><code id="auto_sum_full_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) univariate or multivariate time series
with the same number of columns as 'x'.</p>
</td></tr>
<tr><td><code id="auto_sum_full_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_auto_sum: 
<code><a href="#topic+auto_distance_cpp">auto_distance_cpp</a>()</code>,
<code><a href="#topic+auto_sum_cpp">auto_sum_cpp</a>()</code>,
<code><a href="#topic+auto_sum_path_cpp">auto_sum_path_cpp</a>()</code>,
<code><a href="#topic+subset_matrix_by_rows_cpp">subset_matrix_by_rows_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#auto sum
auto_sum_full_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)
</code></pre>

<hr>
<h2 id='auto_sum_path_cpp'>(C++) Sum Distances Between All Consecutive Samples in the Least Cost Path Between Two Time Series</h2><span id='topic+auto_sum_path_cpp'></span>

<h3>Description</h3>

<p>Computes the cumulative auto sum of auto-distances of two time series
for the coordinates of a trimmed least cost path. The output value is used
as normalization factor when computing dissimilarity scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_sum_path_cpp(x, y, path, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_sum_path_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) univariate or multivariate time series.</p>
</td></tr>
<tr><td><code id="auto_sum_path_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) univariate or multivariate time series
with the same number of columns as 'x'.</p>
</td></tr>
<tr><td><code id="auto_sum_path_cpp_+3A_path">path</code></td>
<td>
<p>(required, data frame) least-cost path produced by <code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp()</a></code>.
Default: NULL</p>
</td></tr>
<tr><td><code id="auto_sum_path_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_auto_sum: 
<code><a href="#topic+auto_distance_cpp">auto_distance_cpp</a>()</code>,
<code><a href="#topic+auto_sum_cpp">auto_sum_cpp</a>()</code>,
<code><a href="#topic+auto_sum_full_cpp">auto_sum_full_cpp</a>()</code>,
<code><a href="#topic+subset_matrix_by_rows_cpp">subset_matrix_by_rows_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#distance matrix
dist_matrix &lt;- distance_matrix_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

#least cost matrix
cost_matrix &lt;- cost_matrix_orthogonal_cpp(
  dist_matrix = dist_matrix
)

#least cost path
cost_path &lt;- cost_path_orthogonal_cpp(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix
)

nrow(cost_path)

#remove blocks from least-cost path
cost_path_trimmed &lt;- cost_path_trim_cpp(
  path = cost_path
)

nrow(cost_path_trimmed)

#auto sum
auto_sum_path_cpp(
  x = x,
  y = y,
  path = cost_path_trimmed,
  distance = "euclidean"
)
</code></pre>

<hr>
<h2 id='cities_coordinates'>Coordinates of 100 Major Cities</h2><span id='topic+cities_coordinates'></span>

<h3>Description</h3>

<p>City coordinates and several environmental variables for the dataset <code>cities_temperature</code>.
</p>
<p>The full dataset with 100 cities can be downloaded from <a href="https://github.com/BlasBenito/distantia/blob/main/data_full/cities_coordinates.rda">https://github.com/BlasBenito/distantia/blob/main/data_full/cities_coordinates.rda</a> (use the &quot;Download raw file&quot; button).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cities_coordinates)
</code></pre>


<h3>Format</h3>

<p>sf data frame with 5 columns and 100 rows.
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>
<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>

<hr>
<h2 id='cities_temperature'>Long Term Monthly Temperature in 20 Major Cities</h2><span id='topic+cities_temperature'></span>

<h3>Description</h3>

<p>Average temperatures between 1975 and 2010 of 20 major cities of the world. <a href="https://www.kaggle.com/datasets/berkeleyearth/climate-change-earth-surface-temperature-data?resource=download&amp;select=GlobalLandTemperaturesByMajorCity.csv">Source</a>.
</p>
<p>Site coordinates for this dataset are in <a href="#topic+cities_coordinates">cities_coordinates</a>.
</p>
<p>The full dataset with 100 cities can be downloaded from <a href="https://github.com/BlasBenito/distantia/blob/main/data_full/cities_temperature.rda">https://github.com/BlasBenito/distantia/blob/main/data_full/cities_temperature.rda</a> (use the &quot;Download raw file&quot; button).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cities_temperature)
</code></pre>


<h3>Format</h3>

<p>data frame with 3 columns and 52100 rows.
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("cities_temperature")

#to time series list
cities &lt;- tsl_initialize(
  x = cities_temperature,
  name_column = "name",
  time_column = "time"
)

#time series plot
if(interactive()){

 #only four cities are shown
 tsl_plot(
  tsl = tsl_subset(
    tsl = tsl,
    names = 1:4
    ),
  guide = FALSE
  )

}
</code></pre>

<hr>
<h2 id='color_continuous'>Default Continuous Color Palette</h2><span id='topic+color_continuous'></span>

<h3>Description</h3>

<p>Uses the function <code><a href="grDevices.html#topic+palettes">grDevices::hcl.colors()</a></code> to generate a continuous color palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_continuous(n = 5, palette = "Zissou 1", rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="color_continuous_+3A_n">n</code></td>
<td>
<p>(required, integer) number of colors to generate. Default = NULL</p>
</td></tr>
<tr><td><code id="color_continuous_+3A_palette">palette</code></td>
<td>
<p>(required, character string) Argument <code>palette</code> of <code><a href="grDevices.html#topic+palettes">grDevices::hcl.colors()</a></code>. Default: &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="color_continuous_+3A_rev">rev</code></td>
<td>
<p>(optional, logical) If TRUE, the color palette is reversed. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>color vector
</p>


<h3>See Also</h3>

<p>Other internal_plotting: 
<code><a href="#topic+color_discrete">color_discrete</a>()</code>,
<code><a href="#topic+utils_color_breaks">utils_color_breaks</a>()</code>,
<code><a href="#topic+utils_line_color">utils_line_color</a>()</code>,
<code><a href="#topic+utils_line_guide">utils_line_guide</a>()</code>,
<code><a href="#topic+utils_matrix_guide">utils_matrix_guide</a>()</code>,
<code><a href="#topic+utils_matrix_plot">utils_matrix_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
color_continuous(n = 20)

</code></pre>

<hr>
<h2 id='color_discrete'>Default Discrete Color Palettes</h2><span id='topic+color_discrete'></span>

<h3>Description</h3>

<p>Uses the function <code><a href="grDevices.html#topic+palette">grDevices::palette.colors()</a></code> to generate discrete color palettes using the following rules:
</p>

<ul>
<li> <p><code>n &lt;= 9</code>: &quot;Okabe-Ito&quot;.
</p>
</li>
<li> <p><code>n == 10</code>: &quot;Tableau 10&quot;
</p>
</li>
<li> <p><code>n &gt; 10 &amp;&amp; n &lt;= 12</code>: &quot;Paired&quot;
</p>
</li>
<li> <p><code>n &gt; 12 &amp;&amp; n &lt;= 26</code>: &quot;Alphabet&quot;
</p>
</li>
<li> <p><code>n &gt; 26 &amp;&amp; n &lt;= 36</code>: &quot;Polychrome 36&quot;
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>color_discrete(n = NULL, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="color_discrete_+3A_n">n</code></td>
<td>
<p>(required, integer) number of colors to generate. Default = NULL</p>
</td></tr>
<tr><td><code id="color_discrete_+3A_rev">rev</code></td>
<td>
<p>(optional, logical) If TRUE, the color palette is reversed. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>color vector
</p>


<h3>See Also</h3>

<p>Other internal_plotting: 
<code><a href="#topic+color_continuous">color_continuous</a>()</code>,
<code><a href="#topic+utils_color_breaks">utils_color_breaks</a>()</code>,
<code><a href="#topic+utils_line_color">utils_line_color</a>()</code>,
<code><a href="#topic+utils_line_guide">utils_line_guide</a>()</code>,
<code><a href="#topic+utils_matrix_guide">utils_matrix_guide</a>()</code>,
<code><a href="#topic+utils_matrix_plot">utils_matrix_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
color_discrete(n = 9)
</code></pre>

<hr>
<h2 id='cost_matrix_diagonal_cpp'>(C++) Compute Orthogonal and Diagonal Least Cost Matrix from a Distance Matrix</h2><span id='topic+cost_matrix_diagonal_cpp'></span>

<h3>Description</h3>

<p>Computes the least cost matrix from a distance matrix.
Considers diagonals during computation of least-costs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_matrix_diagonal_cpp(dist_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_matrix_diagonal_cpp_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>(required, distance matrix). Square distance matrix, output of <code><a href="#topic+distance_matrix_cpp">distance_matrix_cpp()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Least cost matrix.
</p>


<h3>See Also</h3>

<p>Other Rcpp_matrix: 
<code><a href="#topic+cost_matrix_diagonal_weighted_cpp">cost_matrix_diagonal_weighted_cpp</a>()</code>,
<code><a href="#topic+cost_matrix_orthogonal_cpp">cost_matrix_orthogonal_cpp</a>()</code>,
<code><a href="#topic+distance_ls_cpp">distance_ls_cpp</a>()</code>,
<code><a href="#topic+distance_matrix_cpp">distance_matrix_cpp</a>()</code>
</p>

<hr>
<h2 id='cost_matrix_diagonal_weighted_cpp'>(C++) Compute Orthogonal and Weighted Diagonal Least Cost Matrix from a Distance Matrix</h2><span id='topic+cost_matrix_diagonal_weighted_cpp'></span>

<h3>Description</h3>

<p>Computes the least cost matrix from a distance matrix.
Weights diagonals by a factor of 1.414214 (square root of 2) with respect to orthogonal paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_matrix_diagonal_weighted_cpp(dist_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_matrix_diagonal_weighted_cpp_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>(required, distance matrix). Distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Least cost matrix.
</p>


<h3>See Also</h3>

<p>Other Rcpp_matrix: 
<code><a href="#topic+cost_matrix_diagonal_cpp">cost_matrix_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_matrix_orthogonal_cpp">cost_matrix_orthogonal_cpp</a>()</code>,
<code><a href="#topic+distance_ls_cpp">distance_ls_cpp</a>()</code>,
<code><a href="#topic+distance_matrix_cpp">distance_matrix_cpp</a>()</code>
</p>

<hr>
<h2 id='cost_matrix_orthogonal_cpp'>(C++) Compute Orthogonal Least Cost Matrix from a Distance Matrix</h2><span id='topic+cost_matrix_orthogonal_cpp'></span>

<h3>Description</h3>

<p>Computes the least cost matrix from a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_matrix_orthogonal_cpp(dist_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_matrix_orthogonal_cpp_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>(required, distance matrix). Output of <code><a href="#topic+distance_matrix_cpp">distance_matrix_cpp()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Least cost matrix.
</p>


<h3>See Also</h3>

<p>Other Rcpp_matrix: 
<code><a href="#topic+cost_matrix_diagonal_cpp">cost_matrix_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_matrix_diagonal_weighted_cpp">cost_matrix_diagonal_weighted_cpp</a>()</code>,
<code><a href="#topic+distance_ls_cpp">distance_ls_cpp</a>()</code>,
<code><a href="#topic+distance_matrix_cpp">distance_matrix_cpp</a>()</code>
</p>

<hr>
<h2 id='cost_path_cpp'>Least Cost Path</h2><span id='topic+cost_path_cpp'></span>

<h3>Description</h3>

<p>Least cost path between two time series <code>x</code> and <code>y</code>.
NA values must be removed from <code>x</code> and <code>y</code> before using this function.
If the selected distance function is &quot;chi&quot; or &quot;cosine&quot;, pairs of zeros should
be either removed or replaced with pseudo-zeros (i.e. 0.00001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_path_cpp(
  x,
  y,
  distance = "euclidean",
  diagonal = TRUE,
  weighted = TRUE,
  ignore_blocks = FALSE,
  bandwidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_path_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) multivariate time series.</p>
</td></tr>
<tr><td><code id="cost_path_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) multivariate time series
with the same number of columns as 'x'.</p>
</td></tr>
<tr><td><code id="cost_path_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="cost_path_cpp_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical). If TRUE, diagonals are included in the
computation of the cost matrix. Default: TRUE.</p>
</td></tr>
<tr><td><code id="cost_path_cpp_+3A_weighted">weighted</code></td>
<td>
<p>(optional, logical). Only relevant when diagonal is TRUE. When TRUE,
diagonal cost is weighted by y factor of 1.414214 (square root of 2). Default: TRUE.</p>
</td></tr>
<tr><td><code id="cost_path_cpp_+3A_ignore_blocks">ignore_blocks</code></td>
<td>
<p>(optional, logical). If TRUE, blocks of consecutive path
coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.</p>
</td></tr>
<tr><td><code id="cost_path_cpp_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(required, numeric) Size of the Sakoe-Chiba band at
both sides of the diagonal used to constrain the least cost path. Expressed
as a fraction of the number of matrix rows and columns. Unrestricted by default.
Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other Rcpp_cost_path: 
<code><a href="#topic+cost_path_diagonal_bandwidth_cpp">cost_path_diagonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_cpp">cost_path_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_bandwidth_cpp">cost_path_orthogonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_slotting_cpp">cost_path_slotting_cpp</a>()</code>,
<code><a href="#topic+cost_path_sum_cpp">cost_path_sum_cpp</a>()</code>,
<code><a href="#topic+cost_path_trim_cpp">cost_path_trim_cpp</a>()</code>
</p>

<hr>
<h2 id='cost_path_diagonal_bandwidth_cpp'>(C++) Orthogonal and Diagonal Least Cost Path Restricted by Sakoe-Chiba band</h2><span id='topic+cost_path_diagonal_bandwidth_cpp'></span>

<h3>Description</h3>

<p>Computes the least cost matrix from a distance matrix.
Considers diagonals during computation of least-costs. In case of ties,
diagonals are favored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_path_diagonal_bandwidth_cpp(dist_matrix, cost_matrix, bandwidth = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_path_diagonal_bandwidth_cpp_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>(required, numeric matrix). Distance matrix between two
time series.</p>
</td></tr>
<tr><td><code id="cost_path_diagonal_bandwidth_cpp_+3A_cost_matrix">cost_matrix</code></td>
<td>
<p>(required, numeric matrix). Cost matrix generated from
<code>dist_matrix</code>.</p>
</td></tr>
<tr><td><code id="cost_path_diagonal_bandwidth_cpp_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(required, numeric) Size of the Sakoe-Chiba band at
both sides of the diagonal used to constrain the least cost path. Expressed
as a fraction of the number of matrix rows and columns. Unrestricted by default.
Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other Rcpp_cost_path: 
<code><a href="#topic+cost_path_cpp">cost_path_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_cpp">cost_path_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_bandwidth_cpp">cost_path_orthogonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_slotting_cpp">cost_path_slotting_cpp</a>()</code>,
<code><a href="#topic+cost_path_sum_cpp">cost_path_sum_cpp</a>()</code>,
<code><a href="#topic+cost_path_trim_cpp">cost_path_trim_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#distance matrix
dist_matrix &lt;- distance_matrix_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

#least cost matrix
cost_matrix &lt;- cost_matrix_orthogonal_cpp(
  dist_matrix = dist_matrix
)

#least cost path
cost_path &lt;- cost_path_diagonal_cpp(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix
)

cost_path
</code></pre>

<hr>
<h2 id='cost_path_diagonal_cpp'>(C++) Orthogonal and Diagonal Least Cost Path</h2><span id='topic+cost_path_diagonal_cpp'></span>

<h3>Description</h3>

<p>Computes the least cost matrix from a distance matrix.
Considers diagonals during computation of least-costs. In case of ties,
diagonals are favored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_path_diagonal_cpp(dist_matrix, cost_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_path_diagonal_cpp_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>(required, numeric matrix). Distance matrix between two
time series.</p>
</td></tr>
<tr><td><code id="cost_path_diagonal_cpp_+3A_cost_matrix">cost_matrix</code></td>
<td>
<p>(required, numeric matrix). Cost matrix generated from
<code>dist_matrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other Rcpp_cost_path: 
<code><a href="#topic+cost_path_cpp">cost_path_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_bandwidth_cpp">cost_path_diagonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_bandwidth_cpp">cost_path_orthogonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_slotting_cpp">cost_path_slotting_cpp</a>()</code>,
<code><a href="#topic+cost_path_sum_cpp">cost_path_sum_cpp</a>()</code>,
<code><a href="#topic+cost_path_trim_cpp">cost_path_trim_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#distance matrix
dist_matrix &lt;- distance_matrix_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

#least cost matrix
cost_matrix &lt;- cost_matrix_orthogonal_cpp(
  dist_matrix = dist_matrix
)

#least cost path
cost_path &lt;- cost_path_diagonal_cpp(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix
)

cost_path
</code></pre>

<hr>
<h2 id='cost_path_orthogonal_bandwidth_cpp'>(C++) Orthogonal Least Cost Path</h2><span id='topic+cost_path_orthogonal_bandwidth_cpp'></span>

<h3>Description</h3>

<p>Computes an orthogonal least-cost path within a cost matrix. Each steps within
the least-cost path either moves in the x or the y direction, but never diagonally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_path_orthogonal_bandwidth_cpp(dist_matrix, cost_matrix, bandwidth = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_path_orthogonal_bandwidth_cpp_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>(required, numeric matrix). Distance matrix between two
time series.</p>
</td></tr>
<tr><td><code id="cost_path_orthogonal_bandwidth_cpp_+3A_cost_matrix">cost_matrix</code></td>
<td>
<p>(required, numeric matrix). Cost matrix generated from
<code>dist_matrix</code>.</p>
</td></tr>
<tr><td><code id="cost_path_orthogonal_bandwidth_cpp_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(required, numeric) Size of the Sakoe-Chiba band at
both sides of the diagonal used to constrain the least cost path. Expressed
as a fraction of the number of matrix rows and columns. Unrestricted by default.
Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other Rcpp_cost_path: 
<code><a href="#topic+cost_path_cpp">cost_path_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_bandwidth_cpp">cost_path_diagonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_cpp">cost_path_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_slotting_cpp">cost_path_slotting_cpp</a>()</code>,
<code><a href="#topic+cost_path_sum_cpp">cost_path_sum_cpp</a>()</code>,
<code><a href="#topic+cost_path_trim_cpp">cost_path_trim_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#distance matrix
dist_matrix &lt;- distance_matrix_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

#least cost matrix
cost_matrix &lt;- cost_matrix_orthogonal_cpp(
  dist_matrix = dist_matrix
)

#least cost path
cost_path &lt;- cost_path_orthogonal_cpp(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix
)

cost_path
</code></pre>

<hr>
<h2 id='cost_path_orthogonal_cpp'>(C++) Orthogonal Least Cost Path</h2><span id='topic+cost_path_orthogonal_cpp'></span>

<h3>Description</h3>

<p>Computes an orthogonal least-cost path within a cost matrix. Each steps within
the least-cost path either moves in the x or the y direction, but never diagonally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_path_orthogonal_cpp(dist_matrix, cost_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_path_orthogonal_cpp_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>(required, numeric matrix). Distance matrix between two
time series.</p>
</td></tr>
<tr><td><code id="cost_path_orthogonal_cpp_+3A_cost_matrix">cost_matrix</code></td>
<td>
<p>(required, numeric matrix). Cost matrix generated from
<code>dist_matrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other Rcpp_cost_path: 
<code><a href="#topic+cost_path_cpp">cost_path_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_bandwidth_cpp">cost_path_diagonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_cpp">cost_path_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_bandwidth_cpp">cost_path_orthogonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_slotting_cpp">cost_path_slotting_cpp</a>()</code>,
<code><a href="#topic+cost_path_sum_cpp">cost_path_sum_cpp</a>()</code>,
<code><a href="#topic+cost_path_trim_cpp">cost_path_trim_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#distance matrix
dist_matrix &lt;- distance_matrix_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

#least cost matrix
cost_matrix &lt;- cost_matrix_orthogonal_cpp(
  dist_matrix = dist_matrix
)

#least cost path
cost_path &lt;- cost_path_orthogonal_cpp(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix
)

cost_path
</code></pre>

<hr>
<h2 id='cost_path_slotting_cpp'>(C++) Least Cost Path for Sequence Slotting</h2><span id='topic+cost_path_slotting_cpp'></span>

<h3>Description</h3>

<p>Computes a least-cost matrix from a distance matrix.
This version differs from <code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp()</a></code> in the way it solves ties.
In the case of a tie, <code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp()</a></code> uses the first neighbor satisfying
the minimum distance condition, while this function selects the neighbor
that changes the axis of movement within the least-cost matrix. This function
is not used anywhere within the package, but was left here for future reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_path_slotting_cpp(dist_matrix, cost_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_path_slotting_cpp_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>(required, numeric matrix). Distance matrix between two
time series.</p>
</td></tr>
<tr><td><code id="cost_path_slotting_cpp_+3A_cost_matrix">cost_matrix</code></td>
<td>
<p>(required, numeric matrix). Least-cost matrix generated from
<code>dist_matrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other Rcpp_cost_path: 
<code><a href="#topic+cost_path_cpp">cost_path_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_bandwidth_cpp">cost_path_diagonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_cpp">cost_path_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_bandwidth_cpp">cost_path_orthogonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_sum_cpp">cost_path_sum_cpp</a>()</code>,
<code><a href="#topic+cost_path_trim_cpp">cost_path_trim_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#distance matrix
dist_matrix &lt;- distance_matrix_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

#least cost matrix
cost_matrix &lt;- cost_matrix_orthogonal_cpp(
  dist_matrix = dist_matrix
)

#least cost path
cost_path &lt;- cost_path_slotting_cpp(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix
)

cost_path
</code></pre>

<hr>
<h2 id='cost_path_sum_cpp'>(C++) Sum Distances in a Least Cost Path</h2><span id='topic+cost_path_sum_cpp'></span>

<h3>Description</h3>

<p>(C++) Sum Distances in a Least Cost Path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_path_sum_cpp(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_path_sum_cpp_+3A_path">path</code></td>
<td>
<p>(required, data frame) least-cost path produced by <code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_cost_path: 
<code><a href="#topic+cost_path_cpp">cost_path_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_bandwidth_cpp">cost_path_diagonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_cpp">cost_path_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_bandwidth_cpp">cost_path_orthogonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_slotting_cpp">cost_path_slotting_cpp</a>()</code>,
<code><a href="#topic+cost_path_trim_cpp">cost_path_trim_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#distance matrix
dist_matrix &lt;- distance_matrix_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

#least cost matrix
cost_matrix &lt;- cost_matrix_orthogonal_cpp(
  dist_matrix = dist_matrix
)

#least cost path
cost_path &lt;- cost_path_slotting_cpp(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix
)

cost_path_sum_cpp(
  path = cost_path
  )
</code></pre>

<hr>
<h2 id='cost_path_trim_cpp'>(C++) Remove Blocks from a Least Cost Path</h2><span id='topic+cost_path_trim_cpp'></span>

<h3>Description</h3>

<p>(C++) Remove Blocks from a Least Cost Path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost_path_trim_cpp(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost_path_trim_cpp_+3A_path">path</code></td>
<td>
<p>(required, data frame) least-cost path produced by <code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other Rcpp_cost_path: 
<code><a href="#topic+cost_path_cpp">cost_path_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_bandwidth_cpp">cost_path_diagonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_diagonal_cpp">cost_path_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_bandwidth_cpp">cost_path_orthogonal_bandwidth_cpp</a>()</code>,
<code><a href="#topic+cost_path_orthogonal_cpp">cost_path_orthogonal_cpp</a>()</code>,
<code><a href="#topic+cost_path_slotting_cpp">cost_path_slotting_cpp</a>()</code>,
<code><a href="#topic+cost_path_sum_cpp">cost_path_sum_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#distance matrix
dist_matrix &lt;- distance_matrix_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

#least cost matrix
cost_matrix &lt;- cost_matrix_orthogonal_cpp(
  dist_matrix = dist_matrix
)

#least cost path
cost_path &lt;- cost_path_slotting_cpp(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix
)

nrow(cost_path)

#remove blocks from least-cost path
cost_path_trimmed &lt;- cost_path_trim_cpp(
  path = cost_path
)

nrow(cost_path_trimmed)
</code></pre>

<hr>
<h2 id='covid_counties'>County Coordinates of the Covid Prevalence Dataset</h2><span id='topic+covid_counties'></span>

<h3>Description</h3>

<p>County Coordinates of the Covid Prevalence Dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(covid_counties)
</code></pre>


<h3>Format</h3>

<p>sf data frame with county polygons and census data.
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>

<hr>
<h2 id='covid_prevalence'>Time Series of Covid Prevalence in California Counties</h2><span id='topic+covid_prevalence'></span>

<h3>Description</h3>

<p>Dataset with Covid19 maximum weekly prevalence in California counties between 2020 and 2024, from healthdata.gov.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(covid_prevalence)
</code></pre>


<h3>Format</h3>

<p>data frame with 3 columns and 51048 rows
</p>


<h3>Details</h3>

<p>County polygons and additional data for this dataset are in <a href="#topic+covid_counties">covid_counties</a>.
</p>
<p>The full dataset at daily resolution can be downloaded from <a href="https://github.com/BlasBenito/distantia/blob/main/data_full/covid_prevalence.rda">https://github.com/BlasBenito/distantia/blob/main/data_full/covid_prevalence.rda</a> (use the &quot;Download raw file&quot; button).
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#to time series list
tsl &lt;- tsl_initialize(
  x = covid_prevalence,
  name_column = "name",
  time_column = "time"
)

#time series plot
if(interactive()){

 #subset to avoid margin errors
 tsl_plot(
  tsl = tsl_subset(
    tsl = tsl,
    names = 1:4
    ),
  guide = FALSE
  )

}
</code></pre>

<hr>
<h2 id='distance'>Distance Between Two Numeric Vectors</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>Computes the distance between two numeric vectors with a distance metric included in the data frame <code>distantia::distances</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(x = NULL, y = NULL, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="distance_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <code>distances</code>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+distance_matrix">distance_matrix</a>()</code>,
<code><a href="#topic+distances">distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
distance(
  x = runif(100),
  y = runif(100),
  distance = "euclidean"
)

</code></pre>

<hr>
<h2 id='distance_bray_curtis_cpp'>(C++) Bray-Curtis Distance Between Two Vectors</h2><span id='topic+distance_bray_curtis_cpp'></span>

<h3>Description</h3>

<p>Computes the Bray-Curtis distance, suitable for species abundance data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_bray_curtis_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_bray_curtis_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_bray_curtis_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_bray_curtis_cpp(x = runif(100), y = runif(100))
</code></pre>

<hr>
<h2 id='distance_canberra_cpp'>(C++) Canberra Distance Between Two Binary Vectors</h2><span id='topic+distance_canberra_cpp'></span>

<h3>Description</h3>

<p>Computes the Canberra distance between two binary vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_canberra_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_canberra_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_canberra_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_canberra_cpp(c(0, 1, 0, 1), c(1, 1, 0, 0))
</code></pre>

<hr>
<h2 id='distance_chebyshev_cpp'>(C++) Chebyshev Distance Between Two Vectors</h2><span id='topic+distance_chebyshev_cpp'></span>

<h3>Description</h3>

<p>Computed as: <code>max(abs(x - y))</code>. Cannot handle NA values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_chebyshev_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_chebyshev_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_chebyshev_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_chebyshev_cpp(x = runif(100), y = runif(100))
</code></pre>

<hr>
<h2 id='distance_chi_cpp'>(C++) Normalized Chi Distance Between Two Vectors</h2><span id='topic+distance_chi_cpp'></span>

<h3>Description</h3>

<p>Computed as:
<code>xy &lt;- x + y</code>
<code>y. &lt;- y / sum(y)</code>
<code>x. &lt;- x / sum(x)</code>
<code>sqrt(sum(((x. - y.)^2) / (xy / sum(xy))))</code>.
Cannot handle NA values. When <code>x</code> and <code>y</code> have zeros in the same
position, <code>NaNs</code> are produced. Please replace these zeros with
pseudo-zeros (i.e. 0.0001) if you wish to use this distance metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_chi_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_chi_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_chi_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_chi_cpp(x = runif(100), y = runif(100))
</code></pre>

<hr>
<h2 id='distance_cosine_cpp'>(C++) Cosine Dissimilarity Between Two Vectors</h2><span id='topic+distance_cosine_cpp'></span>

<h3>Description</h3>

<p>Computes the cosine dissimilarity between two numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_cosine_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_cosine_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_cosine_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_cosine_cpp(c(0.2, 0.4, 0.5), c(0.1, 0.8, 0.2))
</code></pre>

<hr>
<h2 id='distance_euclidean_cpp'>(C++) Euclidean Distance Between Two Vectors</h2><span id='topic+distance_euclidean_cpp'></span>

<h3>Description</h3>

<p>Computed as: <code>sqrt(sum((x - y)^2)</code>. Cannot handle NA values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_euclidean_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_euclidean_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_euclidean_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_euclidean_cpp(x = runif(100), y = runif(100))
</code></pre>

<hr>
<h2 id='distance_hamming_cpp'>(C++) Hamming Distance Between Two Binary Vectors</h2><span id='topic+distance_hamming_cpp'></span>

<h3>Description</h3>

<p>Computes the Hamming distance between two binary vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_hamming_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_hamming_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_hamming_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_hamming_cpp(c(0, 1, 0, 1), c(1, 1, 0, 0))
</code></pre>

<hr>
<h2 id='distance_hellinger_cpp'>(C++) Hellinger Distance Between Two Vectors</h2><span id='topic+distance_hellinger_cpp'></span>

<h3>Description</h3>

<p>Computed as: <code>sqrt(1/2 * sum((sqrt(x) - sqrt(y))^2))</code>.
Cannot handle NA values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_hellinger_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_hellinger_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_hellinger_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_hellinger_cpp(x = runif(100), y = runif(100))
</code></pre>

<hr>
<h2 id='distance_jaccard_cpp'>(C++) Jaccard Distance Between Two Binary Vectors</h2><span id='topic+distance_jaccard_cpp'></span>

<h3>Description</h3>

<p>Computes the Jaccard distance between two binary vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_jaccard_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_jaccard_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_jaccard_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_jaccard_cpp(x = c(0, 1, 0, 1), y = c(1, 1, 0, 0))
</code></pre>

<hr>
<h2 id='distance_ls_cpp'>(C++) Sum of Pairwise Distances Between Cases in Two Aligned Time Series</h2><span id='topic+distance_ls_cpp'></span>

<h3>Description</h3>

<p>Computes the lock-step sum of distances between two regular
and aligned time series. NA values should be removed before using this function.
If the selected distance function is &quot;chi&quot; or &quot;cosine&quot;, pairs of zeros should
be either removed or replaced with pseudo-zeros (i.e. 0.00001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_ls_cpp(x, y, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_ls_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) univariate or multivariate time series.</p>
</td></tr>
<tr><td><code id="distance_ls_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) univariate or multivariate time series
with the same number of columns and rows as 'x'.</p>
</td></tr>
<tr><td><code id="distance_ls_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_matrix: 
<code><a href="#topic+cost_matrix_diagonal_cpp">cost_matrix_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_matrix_diagonal_weighted_cpp">cost_matrix_diagonal_weighted_cpp</a>()</code>,
<code><a href="#topic+cost_matrix_orthogonal_cpp">cost_matrix_orthogonal_cpp</a>()</code>,
<code><a href="#topic+distance_matrix_cpp">distance_matrix_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two regular time series
x &lt;- zoo_simulate(
  seed = 1,
  irregular = FALSE
  )
y &lt;- zoo_simulate(
  seed = 2,
  irregular = FALSE
  )

#distance matrix
dist_matrix &lt;- distance_ls_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)
</code></pre>

<hr>
<h2 id='distance_manhattan_cpp'>(C++) Manhattan Distance Between Two Vectors</h2><span id='topic+distance_manhattan_cpp'></span>

<h3>Description</h3>

<p>Computed as: <code>sum(abs(x - y))</code>. Cannot handle NA values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_manhattan_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_manhattan_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_manhattan_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_manhattan_cpp(x = runif(100), y = runif(100))
</code></pre>

<hr>
<h2 id='distance_matrix'>Data Frame to Distance Matrix</h2><span id='topic+distance_matrix'></span>

<h3>Description</h3>

<p>Data Frame to Distance Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_matrix(df = NULL, name_column = NULL, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_matrix_+3A_df">df</code></td>
<td>
<p>(required, data frame) Data frame with numeric columns to transform into a distance matrix. Default: NULL</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_name_column">name_column</code></td>
<td>
<p>(optional, column name) Column naming individual time series. Numeric names are converted to character with the prefix &quot;X&quot;. Default: NULL</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>square matrix
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+distance">distance</a>()</code>,
<code><a href="#topic+distances">distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#compute distance matrix
m &lt;- distance_matrix(
  df = cities_coordinates,
  name_column = "name",
  distance = "euclidean"
)

#get data used to compute the matrix
attributes(m)$df

#check matrix
m

</code></pre>

<hr>
<h2 id='distance_matrix_cpp'>(C++) Distance Matrix of Two Time Series</h2><span id='topic+distance_matrix_cpp'></span>

<h3>Description</h3>

<p>Computes the distance matrix between the rows of two matrices
<code>y</code> and <code>x</code> representing regular or irregular time series with the same number of
columns. NA values should be removed before using this function. If the selected distance function is &quot;chi&quot; or &quot;cosine&quot;, pairs of zeros should
be either removed or replaced with pseudo-zeros (i.e. 0.00001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_matrix_cpp(x, y, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_matrix_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) univariate or multivariate time series.</p>
</td></tr>
<tr><td><code id="distance_matrix_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) univariate or multivariate time series
with the same number of columns as 'x'.</p>
</td></tr>
<tr><td><code id="distance_matrix_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>See Also</h3>

<p>Other Rcpp_matrix: 
<code><a href="#topic+cost_matrix_diagonal_cpp">cost_matrix_diagonal_cpp</a>()</code>,
<code><a href="#topic+cost_matrix_diagonal_weighted_cpp">cost_matrix_diagonal_weighted_cpp</a>()</code>,
<code><a href="#topic+cost_matrix_orthogonal_cpp">cost_matrix_orthogonal_cpp</a>()</code>,
<code><a href="#topic+distance_ls_cpp">distance_ls_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two time series
x &lt;- zoo_simulate(seed = 1)
y &lt;- zoo_simulate(seed = 2)

#distance matrix
dist_matrix &lt;- distance_matrix_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)
</code></pre>

<hr>
<h2 id='distance_russelrao_cpp'>(C++) Russell-Rao Distance Between Two Binary Vectors</h2><span id='topic+distance_russelrao_cpp'></span>

<h3>Description</h3>

<p>Computes the Russell-Rao distance between two binary vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_russelrao_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_russelrao_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric). Binary vector of 1s and 0s.</p>
</td></tr>
<tr><td><code id="distance_russelrao_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric) Binary vector of 1s and 0s of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_sorensen_cpp">distance_sorensen_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_russelrao_cpp(c(0, 1, 0, 1), c(1, 1, 0, 0))
</code></pre>

<hr>
<h2 id='distance_sorensen_cpp'>(C++) SÃ¸rensen Distance Between Two Binary Vectors</h2><span id='topic+distance_sorensen_cpp'></span>

<h3>Description</h3>

<p>Computes the SÃ¸rensen distance, suitable for presence/absence data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_sorensen_cpp(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_sorensen_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric vector).</p>
</td></tr>
<tr><td><code id="distance_sorensen_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) of same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_distance_methods: 
<code><a href="#topic+distance_bray_curtis_cpp">distance_bray_curtis_cpp</a>()</code>,
<code><a href="#topic+distance_canberra_cpp">distance_canberra_cpp</a>()</code>,
<code><a href="#topic+distance_chebyshev_cpp">distance_chebyshev_cpp</a>()</code>,
<code><a href="#topic+distance_chi_cpp">distance_chi_cpp</a>()</code>,
<code><a href="#topic+distance_cosine_cpp">distance_cosine_cpp</a>()</code>,
<code><a href="#topic+distance_euclidean_cpp">distance_euclidean_cpp</a>()</code>,
<code><a href="#topic+distance_hamming_cpp">distance_hamming_cpp</a>()</code>,
<code><a href="#topic+distance_hellinger_cpp">distance_hellinger_cpp</a>()</code>,
<code><a href="#topic+distance_jaccard_cpp">distance_jaccard_cpp</a>()</code>,
<code><a href="#topic+distance_manhattan_cpp">distance_manhattan_cpp</a>()</code>,
<code><a href="#topic+distance_russelrao_cpp">distance_russelrao_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_sorensen_cpp(x = c(0, 1, 1, 0), y = c(1, 1, 0, 0))
</code></pre>

<hr>
<h2 id='distances'>Distance Methods</h2><span id='topic+distances'></span>

<h3>Description</h3>

<p>Data frame with the names, abbreviations, and expressions of the distance metrics implemented in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(distances)
</code></pre>


<h3>Format</h3>

<p>data frame with 5 columns and 10 rows
</p>


<h3>See Also</h3>

<p>Other distances: 
<code><a href="#topic+distance">distance</a>()</code>,
<code><a href="#topic+distance_matrix">distance_matrix</a>()</code>
</p>

<hr>
<h2 id='distantia'>Dissimilarity Analysis of Time Series Lists</h2><span id='topic+distantia'></span>

<h3>Description</h3>

<p>This function combines <em>dynamic time warping</em> or <em>lock-step comparison</em> with the <em>psi dissimilarity score</em> and <em>permutation methods</em> to assess dissimilarity between pairs time series or any other sort of data composed of events ordered across a relevant dimension.
</p>
<p><strong>Dynamic Time Warping</strong> (DTW) finds the optimal alignment between two time series by minimizing the cumulative distance between their samples. It applies dynamic programming to identify the least-cost path through a distance matrix between all pairs of samples. The resulting sum of distances along the least cost path is a metric of time series similarity. DTW disregards the exact timing of samples and focuses on their order and pattern similarity between time series, making it suitable for comparing both <em>regular and irregular time series of the same or different lengths</em>, such as phenological data from different latitudes or elevations, time series from various years or periods, and movement trajectories like migration paths. Additionally, <code>distantia()</code> implements constrained DTW via Sakoe-Chiba bands with the <code>bandwidth</code> argument, which defines a region around the distance matrix diagonal to restrict the spread of the least cost path.
</p>
<p><strong>Lock-step</strong> (LS) sums pairwise distances between samples in <em>regular or irregular time series of the same length</em>, preferably captured at the same times. This method is an alternative to dynamic time warping when the goal is to assess the synchronicity of two time series.
</p>
<p>The <strong>psi score</strong> normalizes the cumulative sum of distances between two time series by the cumulative sum of distances between their consecutive samples to generate a comparable dissimilarity score. If for two time series <code class="reqn">x</code> and <code class="reqn">y</code> <code class="reqn">D_xy</code> represents the cumulative sum of distances between them, either resulting from dynamic time warping or the lock-step method, and <code class="reqn">S_xy</code> represents the cumulative sum of distances of their consecutive samples, then the psi score can be computed in two ways depending on the scenario:
</p>
<p><strong>Equation 1:</strong> <code class="reqn">\psi = \frac{D_{xy} - S_{xy}}{S_{xy}}</code>
</p>
<p><strong>Equation 2:</strong> <code class="reqn">\psi = \frac{D_{xy} - S_{xy}}{S_{xy}} + 1</code>
</p>
<p>When $D_xy$ is computed via dynamic time warping <strong>ignoring the distance matrix diagonals</strong> (<code>diagonal = FALSE</code>), then <em>Equation 1</em> is used. On the other hand, if $D_xy$ results from the lock-step method (<code>lock_step = TRUE</code>), or from dynamic time warping considering diagonals (<code>diagonal = TRUE</code>), then <em>Equation 2</em> is used instead:
</p>
<p>In both equations, a psi score of zero indicates maximum similarity.
</p>
<p><strong>Permutation methods</strong> are provided here to help assess the robustness of observed psi scores by direct comparison with a null distribution of psi scores resulting from randomized versions of the compared time series. The fraction of null scores smaller than the observed score is returned as a <em>p_value</em> in the function output and interpreted as &quot;the probability of finding a higher similarity (lower psi score) by chance&quot;.
</p>
<p>In essence, restricted permutation is useful to answer the question &quot;how robust is the similarity between two time series?&quot;
</p>
<p>Four different permutation methods are available:
</p>

<ul>
<li> <p><strong>&quot;restricted&quot;</strong>: Separates the data into blocks of contiguous rows, and re-shuffles data points randomly within these blocks, independently by row and column. Applied when the data is structured in blocks that should be preserved during permutations (e.g., &quot;seasons&quot;, &quot;years&quot;, &quot;decades&quot;, etc) and the columns represent independent variables.
</p>
</li>
<li> <p><strong>&quot;restricted_by_row&quot;</strong>: Separates the data into blocks of contiguous rows, and re-shuffles complete rows within these blocks. This method is suitable for cases where the data is organized into blocks as described above, but columns represent interdependent data (e.g., rows represent percentages or proportions), and maintaining the relationships between data within each row is important.
</p>
</li>
<li> <p><strong>&quot;free&quot;</strong>: Randomly re-shuffles data points across the entire time series, independently by row and column. This method is useful for loosely structured time series where data independence is assumed. When the data exhibits a strong temporal structure, this approach may lead to an overestimation of the robustness of dissimilarity scores.
</p>
</li>
<li> <p><strong>&quot;free_by_row&quot;</strong>: Randomly re-shuffles complete rows across the entire time series. This method is useful for loosely structured time series where dependency between columns is assumed (e.g., rows represent percentages or proportions). This method has the same drawbacks as the &quot;free&quot; method, when the data exhibits a strong temporal structure.
</p>
</li></ul>

<p>This function allows computing dissimilarity between pairs of time series using different combinations of arguments at once. For example, when the argument <code>distance</code> is set to <code>c("euclidean", "manhattan")</code>, the output data frame will show two dissimilarity scores for each pair of time series, one based on euclidean distances, and another based on manhattan distances. The same happens for most other parameters.
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>. However, due to the high performance of the C++ backend, parallelization might only result in efficiency gains when running permutation tests with large number of iterations, or working with very long time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia(
  tsl = NULL,
  distance = "euclidean",
  diagonal = TRUE,
  bandwidth = 1,
  lock_step = FALSE,
  permutation = "restricted_by_row",
  block_size = NULL,
  repetitions = 0,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_+3A_tsl">tsl</code></td>
<td>
<p>(required, time series list) list of zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="distantia_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical vector). If TRUE, diagonals are included in the dynamic time warping computation. Default: TRUE</p>
</td></tr>
<tr><td><code id="distantia_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(optional, numeric) Proportion of space at each side of the cost matrix diagonal (aka <em>Sakoe-Chiba band</em>) defining a valid region for dynamic time warping, used to control the flexibility of the warping path. This method prevents degenerate alignments due to differences in magnitude between time series when the data is not properly scaled. If <code>1</code> (default), DTW is unconstrained. If <code>0</code>, DTW is fully constrained and the warping path follows the matrix diagonal. Recommended values may vary depending on the nature of the data. Ignored if <code>lock_step = TRUE</code>. Default: 1.</p>
</td></tr>
<tr><td><code id="distantia_+3A_lock_step">lock_step</code></td>
<td>
<p>(optional, logical vector) If TRUE, time series captured at the same times are compared sample wise (with no dynamic time warping). Requires time series in argument <code>tsl</code> to be fully aligned, or it will return an error. Default: FALSE.</p>
</td></tr>
<tr><td><code id="distantia_+3A_permutation">permutation</code></td>
<td>
<p>(optional, character vector) permutation method, only relevant when <code>repetitions</code> is higher than zero. Valid values are: &quot;restricted_by_row&quot;, &quot;restricted&quot;, &quot;free_by_row&quot;, and &quot;free&quot;. Default: &quot;restricted_by_row&quot;.</p>
</td></tr>
<tr><td><code id="distantia_+3A_block_size">block_size</code></td>
<td>
<p>(optional, integer) Size of the row blocks for the restricted permutation test. Only relevant when permutation methods are &quot;restricted&quot; or &quot;restricted_by_row&quot; and <code>repetitions</code> is higher than zero. A block of size <code>n</code> indicates that a row can only be permuted within a block of <code>n</code> adjacent rows. If NULL, defaults to the rounded one tenth of the shortest time series in <code>tsl</code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="distantia_+3A_repetitions">repetitions</code></td>
<td>
<p>(optional, integer vector) number of permutations to compute the p-value. If 0, p-values are not computed. Otherwise, the minimum is 2. The resolution of the p-values and the overall computation time depends on the number of permutations. Default: 0</p>
</td></tr>
<tr><td><code id="distantia_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) initial random seed to use for replicability when computing p-values. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with columns:
</p>

<ul>
<li> <p><code>x</code>: time series name.
</p>
</li>
<li> <p><code>y</code>: time series name.
</p>
</li>
<li> <p><code>distance</code>: name of the distance metric.
</p>
</li>
<li> <p><code>diagonal</code>: value of the argument <code>diagonal</code>.
</p>
</li>
<li> <p><code>lock_step</code>: value of the argument <code>lock_step</code>.
</p>
</li>
<li> <p><code>repetitions</code> (only if <code>repetitions &gt; 0</code>): value of the argument <code>repetitions</code>.
</p>
</li>
<li> <p><code>permutation</code> (only if <code>repetitions &gt; 0</code>): name of the permutation method used to compute p-values.
</p>
</li>
<li> <p><code>seed</code> (only if <code>repetitions &gt; 0</code>): random seed used to in the permutations.
</p>
</li>
<li> <p><code>psi</code>: psi dissimilarity of the sequences <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code>null_mean</code> (only if <code>repetitions &gt; 0</code>): mean of the null distribution of psi scores.
</p>
</li>
<li> <p><code>null_sd</code> (only if <code>repetitions &gt; 0</code>): standard deviation of the null distribution of psi values.
</p>
</li>
<li> <p><code>p_value</code>  (only if <code>repetitions &gt; 0</code>): proportion of scores smaller or equal than <code>psi</code> in the null distribution.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other distantia: 
<code><a href="#topic+distantia_dtw">distantia_dtw</a>()</code>,
<code><a href="#topic+distantia_dtw_plot">distantia_dtw_plot</a>()</code>,
<code><a href="#topic+distantia_ls">distantia_ls</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#parallelization setup
#not worth it for this data size
# future::plan(
#   strategy = future::multisession,
#   workers = 2
# )

#progress bar (does not work in R examples)
# progressr::handlers(global = TRUE)


#load fagus_dynamics as tsl
#global centering and scaling
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

if(interactive()){
  tsl_plot(
    tsl = tsl,
    guide_columns = 3
    )
}

#dynamic time warping dissimilarity analysis
#-------------------------------------------
#permutation restricted by row to preserve dependency of ndvi on temperature and rainfall
#block size is 3 months to permute within same season
df_dtw &lt;- distantia(
  tsl = tsl,
  distance = "euclidean",
  permutation = "restricted_by_row",
  block_size = 3, #months
  repetitions = 10, #increase to 100 or more
  seed = 1
)

#focus on the important details
df_dtw[, c("x", "y", "psi", "p_value", "null_mean", "null_sd")]
#higher psi values indicate higher dissimilarity
#p-values indicate chance of finding a random permutation with a psi smaller than the observed

#visualize dynamic time warping
if(interactive()){

  distantia_dtw_plot(
    tsl = tsl[c("Spain", "Sweden")],
    distance = "euclidean"
  )

}

#recreating the null distribution
#direct call to C++ function
#use same args as distantia() call
psi_null &lt;- psi_null_dtw_cpp(
  x = tsl[["Spain"]],
  y = tsl[["Sweden"]],
  distance = "euclidean",
  repetitions = 10, #increase to 100 or more

  permutation = "restricted_by_row",
  block_size = 3,
  seed = 1
)

#compare null mean with output of distantia()
mean(psi_null)
df_dtw$null_mean[3]

</code></pre>

<hr>
<h2 id='distantia_aggregate'>Aggregate <code>distantia()</code> Data Frames Across Parameter Combinations</h2><span id='topic+distantia_aggregate'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+distantia">distantia()</a></code> allows dissimilarity assessments based on several combinations of arguments at once. For example, when the argument <code>distance</code> is set to <code>c("euclidean", "manhattan")</code>, the output data frame will show two dissimilarity scores for each pair of compared time series, one based on euclidean distances, and another based on manhattan distances.
</p>
<p>This function computes dissimilarity stats across combinations of parameters.
</p>
<p>If psi scores smaller than zero occur in the aggregated output, then the the smaller psi value is added to the column <code>psi</code> to start dissimilarity scores at zero.
</p>
<p>If there are no different combinations of arguments in the input data frame, no aggregation happens, but all parameter columns are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_aggregate(df = NULL, f = mean, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_aggregate_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+distantia">distantia()</a></code>, <code><a href="#topic+distantia_ls">distantia_ls()</a></code>, <code><a href="#topic+distantia_dtw">distantia_dtw()</a></code>, or <code><a href="#topic+distantia_time_delay">distantia_time_delay()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_aggregate_+3A_f">f</code></td>
<td>
<p>(optional, function) Function to summarize psi scores (for example, <code>mean</code>) when there are several combinations of parameters in <code>df</code>. Ignored when there is a single combination of arguments in the input. Default: <code>mean</code></p>
</td></tr>
<tr><td><code id="distantia_aggregate_+3A_...">...</code></td>
<td>
<p>(optional, arguments of <code>f</code>) Further arguments to pass to the function <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#three time series
#climate and ndvi in Fagus sylvatica stands in Spain, Germany, and Sweden
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

if(interactive()){
  tsl_plot(
    tsl = tsl,
    guide_columns = 3
    )
}

#distantia with multiple parameter combinations
#-------------------------------------
df &lt;- distantia(
  tsl = tsl,
  distance = c("euclidean", "manhattan"),
  lock_step = TRUE
)

df[, c(
  "x",
  "y",
  "distance",
  "psi"
)]

#aggregation using means
df &lt;- distantia_aggregate(
  df = df,
  f = mean
)

df
</code></pre>

<hr>
<h2 id='distantia_boxplot'>Distantia Boxplot</h2><span id='topic+distantia_boxplot'></span>

<h3>Description</h3>

<p>Boxplot of a data frame returned by <code><a href="#topic+distantia">distantia()</a></code> summarizing the stats of the psi scores of each time series against all others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_boxplot(df = NULL, fill_color = NULL, f = median, text_cex = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_boxplot_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+distantia">distantia()</a></code>, <code><a href="#topic+distantia_ls">distantia_ls()</a></code>, <code><a href="#topic+distantia_dtw">distantia_dtw()</a></code>, or <code><a href="#topic+distantia_time_delay">distantia_time_delay()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_boxplot_+3A_fill_color">fill_color</code></td>
<td>
<p>(optional, character vector) boxplot fill color. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_boxplot_+3A_f">f</code></td>
<td>
<p>(optional, function) function used to aggregate the input data frame and arrange the boxes. One of <code>mean</code> or <code>median</code>. Default: <code>median</code>.</p>
</td></tr>
<tr><td><code id="distantia_boxplot_+3A_text_cex">text_cex</code></td>
<td>
<p>(optional, numeric) Multiplier of the text size. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boxplot
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsl &lt;- tsl_initialize(
  x = distantia::albatross,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

df &lt;- distantia(
  tsl = tsl,
  lock_step = TRUE
  )

distantia_boxplot(
  df = df,
  text_cex = 1.5
  )
</code></pre>

<hr>
<h2 id='distantia_cluster_hclust'>Hierarchical Clustering of Dissimilarity Analysis Data Frames</h2><span id='topic+distantia_cluster_hclust'></span>

<h3>Description</h3>

<p>This function combines the dissimilarity scores computed by <code><a href="#topic+distantia">distantia()</a></code>, the agglomerative clustering methods provided by <code><a href="stats.html#topic+hclust">stats::hclust()</a></code>, and the clustering optimization method implemented in <code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer()</a></code> to help group together time series with similar features.
</p>
<p>When <code>clusters = NULL</code>, the function <code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer()</a></code> is run underneath to perform a parallelized grid search to find the  number of clusters maximizing the overall silhouette width of the clustering solution (see <code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette()</a></code>). When <code>method = NULL</code> as well, the optimization also includes all methods available in <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> in the grid search.
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_cluster_hclust(df = NULL, clusters = NULL, method = "complete")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_cluster_hclust_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+distantia">distantia()</a></code>, <code><a href="#topic+distantia_ls">distantia_ls()</a></code>, <code><a href="#topic+distantia_dtw">distantia_dtw()</a></code>, or <code><a href="#topic+distantia_time_delay">distantia_time_delay()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_cluster_hclust_+3A_clusters">clusters</code></td>
<td>
<p>(required, integer) Number of groups to generate. If NULL (default), <code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer()</a></code> is used to find the number of clusters that maximizes the mean silhouette width of the clustering solution (see <code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette()</a></code>). Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_cluster_hclust_+3A_method">method</code></td>
<td>
<p>(optional, character string) Argument of <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> defining the agglomerative method. One of: &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or &quot;centroid&quot; (= UPGMC). Unambiguous abbreviations are accepted as well. If NULL (default), <code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer()</a></code> finds the optimal method. Default: &quot;complete&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list:
</p>

<ul>
<li> <p><code>cluster_object</code>: hclust object for further analyses and custom plotting.
</p>
</li>
<li> <p><code>clusters</code>: integer, number of clusters.
</p>
</li>
<li> <p><code>silhouette_width</code>: mean silhouette width of the clustering solution.
</p>
</li>
<li> <p><code>df</code>: data frame with time series names, their cluster label, and their individual silhouette width scores.
</p>
</li>
<li> <p><code>d</code>: psi distance matrix used for clustering.
</p>
</li>
<li> <p><code>optimization</code>: only if <code>clusters = NULL</code>, data frame with optimization results from <code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#weekly covid prevalence in California
tsl &lt;- tsl_initialize(
  x = covid_prevalence,
  name_column = "name",
  time_column = "time"
)

#subset 10 elements to accelerate example execution
tsl &lt;- tsl_subset(
  tsl = tsl,
  names = 1:10
)

if(interactive()){
  #plotting first three time series
  tsl_plot(
    tsl = tsl[1:3],
    guide_columns = 3
  )
}

#dissimilarity analysis
distantia_df &lt;- distantia(
  tsl = tsl,
  lock_step = TRUE
)

#hierarchical clustering
#automated number of clusters
#automated method selection
distantia_clust &lt;- distantia_cluster_hclust(
  df = distantia_df,
  clusters = NULL,
  method = NULL
)

#names of the output object
names(distantia_clust)

#cluster object
distantia_clust$cluster_object

#distance matrix used for clustering
distantia_clust$d

#number of clusters
distantia_clust$clusters

#clustering data frame
#group label in column "cluster"
#negatives in column "silhouette_width" higlight anomalous cluster assignation
distantia_clust$df

#mean silhouette width of the clustering solution
distantia_clust$silhouette_width

#plot
if(interactive()){

  dev.off()

  clust &lt;- distantia_clust$cluster_object
  k &lt;- distantia_clust$clusters

  #tree plot
  plot(
    x = clust,
    hang = -1
  )

  #highlight groups
  stats::rect.hclust(
    tree = clust,
    k = k,
    cluster = stats::cutree(
      tree = clust,
      k = k
    )
  )

}

</code></pre>

<hr>
<h2 id='distantia_cluster_kmeans'>K-Means Clustering of Dissimilarity Analysis Data Frames</h2><span id='topic+distantia_cluster_kmeans'></span>

<h3>Description</h3>

<p>This function combines the dissimilarity scores computed by <code><a href="#topic+distantia">distantia()</a></code>, the K-means clustering method implemented in <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>, and the clustering optimization method implemented in <code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer()</a></code> to help group together time series with similar features.
</p>
<p>When <code>clusters = NULL</code>, the function <code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer()</a></code> is run underneath to perform a parallelized grid search to find the  number of clusters maximizing the overall silhouette width of the clustering solution (see <code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette()</a></code>).
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_cluster_kmeans(df = NULL, clusters = NULL, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_cluster_kmeans_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+distantia">distantia()</a></code>, <code><a href="#topic+distantia_ls">distantia_ls()</a></code>, <code><a href="#topic+distantia_dtw">distantia_dtw()</a></code>, or <code><a href="#topic+distantia_time_delay">distantia_time_delay()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_cluster_kmeans_+3A_clusters">clusters</code></td>
<td>
<p>(required, integer) Number of groups to generate. If NULL (default), <code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer()</a></code> is used to find the number of clusters that maximizes the mean silhouette width of the clustering solution (see <code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette()</a></code>). Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_cluster_kmeans_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) Random seed to be used during the K-means computation. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list:
</p>

<ul>
<li> <p><code>cluster_object</code>: kmeans object object for further analyses and custom plotting.
</p>
</li>
<li> <p><code>clusters</code>: integer, number of clusters.
</p>
</li>
<li> <p><code>silhouette_width</code>: mean silhouette width of the clustering solution.
</p>
</li>
<li> <p><code>df</code>: data frame with time series names, their cluster label, and their individual silhouette width scores.
</p>
</li>
<li> <p><code>d</code>: psi distance matrix used for clustering.
</p>
</li>
<li> <p><code>optimization</code>: only if <code>clusters = NULL</code>, data frame with optimization results from <code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#weekly covid prevalence in California
tsl &lt;- tsl_initialize(
  x = covid_prevalence,
  name_column = "name",
  time_column = "time"
)

#subset 10 elements to accelerate example execution
tsl &lt;- tsl_subset(
  tsl = tsl,
  names = 1:10
)

if(interactive()){
  #plotting first three time series
  tsl_plot(
    tsl = tsl[1:3],
    guide_columns = 3
  )
}

#dissimilarity analysis
distantia_df &lt;- distantia(
  tsl = tsl,
  lock_step = TRUE
)

#hierarchical clustering
#automated number of clusters
distantia_kmeans &lt;- distantia_cluster_kmeans(
  df = distantia_df,
  clusters = NULL
)

#names of the output object
names(distantia_kmeans)

#kmeans object
distantia_kmeans$cluster_object

#distance matrix used for clustering
distantia_kmeans$d

#number of clusters
distantia_kmeans$clusters

#clustering data frame
#group label in column "cluster"
distantia_kmeans$df

#mean silhouette width of the clustering solution
distantia_kmeans$silhouette_width

#kmeans plot
# factoextra::fviz_cluster(
#   object = distantia_kmeans$cluster_object,
#   data = distantia_kmeans$d,
#   repel = TRUE
# )
</code></pre>

<hr>
<h2 id='distantia_dtw'>Dynamic Time Warping Dissimilarity Analysis of Time Series Lists</h2><span id='topic+distantia_dtw'></span>

<h3>Description</h3>

<p>Minimalistic but slightly faster version of <code><a href="#topic+distantia">distantia()</a></code> to compute dynamic time warping dissimilarity scores using diagonal least cost paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_dtw(tsl = NULL, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_dtw_+3A_tsl">tsl</code></td>
<td>
<p>(required, time series list) list of zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_dtw_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with columns:
</p>

<ul>
<li> <p><code>x</code>: time series name.
</p>
</li>
<li> <p><code>y</code>: time series name.
</p>
</li>
<li> <p><code>distance</code>: name of the distance metric.
</p>
</li>
<li> <p><code>psi</code>: psi dissimilarity of the sequences <code>x</code> and <code>y</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other distantia: 
<code><a href="#topic+distantia">distantia</a>()</code>,
<code><a href="#topic+distantia_dtw_plot">distantia_dtw_plot</a>()</code>,
<code><a href="#topic+distantia_ls">distantia_ls</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load fagus_dynamics as tsl
#global centering and scaling
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

if(interactive()){
  tsl_plot(
    tsl = tsl,
    guide_columns = 3
    )
}

#dynamic time warping dissimilarity analysis
df_dtw &lt;- distantia_dtw(
  tsl = tsl,
  distance = "euclidean"
)

df_dtw[, c("x", "y", "psi")]

#visualize dynamic time warping
if(interactive()){

  distantia_dtw_plot(
    tsl = tsl[c("Spain", "Sweden")],
    distance = "euclidean"
  )

}


</code></pre>

<hr>
<h2 id='distantia_dtw_plot'>Two-Way Dissimilarity Plots of Time Series Lists</h2><span id='topic+distantia_dtw_plot'></span>

<h3>Description</h3>

<p>Plots two sequences, their distance or cost matrix, their least cost path, and all relevant values used to compute dissimilarity.
</p>
<p>Unlike <code><a href="#topic+distantia">distantia()</a></code>, this function does not accept vectors as inputs for the arguments to compute dissimilarity (<code>distance</code>, <code>diagonal</code>,  and <code>weighted</code>), and only plots a pair of sequences at once.
</p>
<p>The argument <code>lock_step</code> is not available because this plot does not make sense in such a case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_dtw_plot(
  tsl = NULL,
  distance = "euclidean",
  diagonal = TRUE,
  bandwidth = 1,
  matrix_type = "cost",
  matrix_color = NULL,
  path_width = 1,
  path_color = "black",
  diagonal_width = 1,
  diagonal_color = "white",
  line_color = NULL,
  line_width = 1,
  text_cex = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_dtw_plot_+3A_tsl">tsl</code></td>
<td>
<p>(required, time series list) list of zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical vector). If TRUE, diagonals are included in the dynamic time warping computation. Default: TRUE</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(optional, numeric) Proportion of space at each side of the cost matrix diagonal (aka <em>Sakoe-Chiba band</em>) defining a valid region for dynamic time warping, used to control the flexibility of the warping path. This method prevents degenerate alignments due to differences in magnitude between time series when the data is not properly scaled. If <code>1</code> (default), DTW is unconstrained. If <code>0</code>, DTW is fully constrained and the warping path follows the matrix diagonal. Recommended values may vary depending on the nature of the data. Ignored if <code>lock_step = TRUE</code>. Default: 1.</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_matrix_type">matrix_type</code></td>
<td>
<p>(optional, character string): one of &quot;cost&quot; or &quot;distance&quot; (the abbreviation &quot;dist&quot; is accepted as well). Default: &quot;cost&quot;.</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_matrix_color">matrix_color</code></td>
<td>
<p>(optional, character vector) vector of colors for the distance or cost matrix. If NULL, uses the palette &quot;Zissou 1&quot; provided by the function <code><a href="grDevices.html#topic+palettes">grDevices::hcl.colors()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_path_width">path_width</code></td>
<td>
<p>(optional, numeric) width of the least cost path. Default: 1</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_path_color">path_color</code></td>
<td>
<p>(optional, character string) color of the least-cost path. Default: &quot;black&quot;</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_diagonal_width">diagonal_width</code></td>
<td>
<p>(optional, numeric) width of the diagonal. Set to 0 to remove the diagonal line. Default: 0.5</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_diagonal_color">diagonal_color</code></td>
<td>
<p>(optional, character string) color of the diagonal. Default: &quot;white&quot;</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_line_color">line_color</code></td>
<td>
<p>(optional, character vector) Vector of colors for the time series plot. If not provided, defaults to a subset of <code>matrix_color</code>.</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_line_width">line_width</code></td>
<td>
<p>(optional, numeric vector) Width of the time series plot. Default: 1</p>
</td></tr>
<tr><td><code id="distantia_dtw_plot_+3A_text_cex">text_cex</code></td>
<td>
<p>(optional, numeric) Multiplier of the text size. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>multipanel plot
</p>


<h3>See Also</h3>

<p>Other distantia: 
<code><a href="#topic+distantia">distantia</a>()</code>,
<code><a href="#topic+distantia_dtw">distantia_dtw</a>()</code>,
<code><a href="#topic+distantia_ls">distantia_ls</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#three time series
#climate and ndvi in Fagus sylvatica stands in Spain, Germany, and Sweden
#convert to time series list
#scale and center to neutralize effect of different scales in temperature, rainfall, and ndvi
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global #see help(f_scale_global)
  )

if(interactive()){
  tsl_plot(
    tsl = tsl,
    guide_columns = 3
    )
}

#visualize dynamic time warping
if(interactive()){

  #plot pair with cost matrix (default)
  distantia_dtw_plot(
    tsl = tsl[c("Spain", "Sweden")] #only two time series!
  )

  #plot pair with distance matrix
  distantia_dtw_plot(
    tsl = tsl[c("Spain", "Sweden")],
    matrix_type = "distance"
  )

  #plot pair with different distance
  distantia_dtw_plot(
    tsl = tsl[c("Spain", "Sweden")],
    distance = "manhattan", #sed data(distances)
    matrix_type = "distance"
  )


  #with different colors
  distantia_dtw_plot(
    tsl = tsl[c("Spain", "Sweden")],
    matrix_type = "distance",
    matrix_color = grDevices::hcl.colors(
      n = 100,
      palette = "Inferno"
    ),
    path_color = "white",
    path_width = 2,
    line_color = grDevices::hcl.colors(
      n = 3, #same as variables in tsl
      palette = "Inferno"
    )
  )

}
</code></pre>

<hr>
<h2 id='distantia_ls'>Lock-Step Dissimilarity Analysis of Time Series Lists</h2><span id='topic+distantia_ls'></span>

<h3>Description</h3>

<p>Minimalistic but slightly faster version of <code><a href="#topic+distantia">distantia()</a></code> to compute lock-step dissimilarity scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_ls(tsl = NULL, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_ls_+3A_tsl">tsl</code></td>
<td>
<p>(required, time series list) list of zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_ls_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame:
</p>

<ul>
<li> <p><code>x</code>: time series name.
</p>
</li>
<li> <p><code>y</code>: time series name.
</p>
</li>
<li> <p><code>distance</code>: name of the distance metric.
</p>
</li>
<li> <p><code>psi</code>: psi dissimilarity of the sequences <code>x</code> and <code>y</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other distantia: 
<code><a href="#topic+distantia">distantia</a>()</code>,
<code><a href="#topic+distantia_dtw">distantia_dtw</a>()</code>,
<code><a href="#topic+distantia_dtw_plot">distantia_dtw_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#load fagus_dynamics as tsl
#global centering and scaling
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

if(interactive()){
  tsl_plot(
    tsl = tsl,
    guide_columns = 3
    )
}

#lock-step dissimilarity analysis
df_ls &lt;- distantia_ls(
  tsl = tsl,
  distance = "euclidean"
)

df_ls

</code></pre>

<hr>
<h2 id='distantia_matrix'>Convert Dissimilarity Analysis Data Frame to Distance Matrix</h2><span id='topic+distantia_matrix'></span>

<h3>Description</h3>

<p>Transforms a data frame resulting from <code><a href="#topic+distantia">distantia()</a></code> into a dissimilarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_matrix(df = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_matrix_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+distantia">distantia()</a></code>, <code><a href="#topic+distantia_ls">distantia_ls()</a></code>, <code><a href="#topic+distantia_dtw">distantia_dtw()</a></code>, or <code><a href="#topic+distantia_time_delay">distantia_time_delay()</a></code>. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#weekly covid prevalence in three California counties
#load as tsl
#subset 5 counties
#sum by month
tsl &lt;- tsl_initialize(
  x = covid_prevalence,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_subset(
    names = 1:5
  ) |&gt;
  tsl_aggregate(
    new_time = "months",
    method = sum
  )

if(interactive()){

  #plotting first three time series
  tsl_plot(
    tsl = tsl,
    guide_columns = 3
    )

  dev.off()

}

#dissimilarity analysis
#two combinations of arguments
distantia_df &lt;- distantia(
  tsl = tsl,
  lock_step = c(TRUE, FALSE)
)

#to dissimilarity matrix
distantia_matrix &lt;- distantia_matrix(
  df = distantia_df
)

#returns a list of matrices
lapply(
  X = distantia_matrix,
  FUN = class
  )

#these matrices have attributes tracing how they were generated
lapply(
  X = distantia_matrix,
  FUN = \(x) attributes(x)$distantia_args
)

#plot matrix
if(interactive()){

  #plot first matrix (default behavior of utils_matrix_plot())
  utils_matrix_plot(
    m = distantia_matrix
  )

  #plot second matrix
  utils_matrix_plot(
    m = distantia_matrix[[2]]
  )

}
</code></pre>

<hr>
<h2 id='distantia_model_frame'>Dissimilarity Model Frame</h2><span id='topic+distantia_model_frame'></span>

<h3>Description</h3>

<p>This function generates a model frame for statistical or machine learning analysis from these objects:
</p>

<ul>
<li><p>: Dissimilarity data frame generated by <code><a href="#topic+distantia">distantia()</a></code>, <code><a href="#topic+distantia_ls">distantia_ls()</a></code>, <code><a href="#topic+distantia_dtw">distantia_dtw()</a></code>, or <code><a href="#topic+distantia_time_delay">distantia_time_delay()</a></code>. The output model frame will have as many rows as this data frame.
</p>
</li>
<li><p>: Data frame with static descriptors of the time series. These descriptors are converted to distances between pairs of time series via <code><a href="#topic+distance_matrix">distance_matrix()</a></code>.
</p>
</li>
<li><p>: List defining composite predictors. This feature allows grouping together predictors that have a common meaning. For example, <code style="white-space: pre;">&#8288;composite_predictors = list(temperature = c("temperature_mean", "temperature_min", "temperature_max")&#8288;</code> generates a new predictor named &quot;temperature&quot;, which results from computing the multivariate distances between the vectors of temperature variables of each pair of time series. Predictors in one of such groups will be scaled before distance computation if their maximum standard deviations differ by a factor of 10 or more.
</p>
</li></ul>

<p>The resulting data frame contains the following columns:
</p>

<ul>
<li> <p><code>x</code> and <code>y</code>: names of the pair of time series represented in the row.
</p>
</li>
<li><p> response columns in <code>response_df</code>.
</p>
</li>
<li><p> predictors columns: representing the distance between the values of the given static predictor between <code>x</code> and <code>y</code>.
</p>
</li>
<li><p> (optional) <code>geographic_distance</code>: If <code>predictors_df</code> is an sf <code>sf</code> data frame, then geographic distances are computed via <code><a href="sf.html#topic+geos_measures">sf::st_distance()</a></code>.
</p>
</li></ul>

<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_model_frame(
  response_df = NULL,
  predictors_df = NULL,
  composite_predictors = NULL,
  scale = TRUE,
  distance = "euclidean"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_model_frame_+3A_response_df">response_df</code></td>
<td>
<p>(required, data frame) output of <code><a href="#topic+distantia">distantia()</a></code>, <code><a href="#topic+distantia_ls">distantia_ls()</a></code>, <code><a href="#topic+distantia_dtw">distantia_dtw()</a></code>, or <code><a href="#topic+distantia_time_delay">distantia_time_delay()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_model_frame_+3A_predictors_df">predictors_df</code></td>
<td>
<p>(required, data frame or sf data frame) data frame with numeric predictors for the the model frame. Must have a column with the time series names in <code>response_df$x</code> and <code>response_df$y</code>. If <code>sf</code> data frame, the column &quot;geographic_distance&quot; with distances between pairs of time series is added to the model frame. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_model_frame_+3A_composite_predictors">composite_predictors</code></td>
<td>
<p>(optional, list) list defining composite predictors. For example, <code>composite_predictors = list(a = c("b", "c"))</code> uses the columns <code>"b"</code> and <code>"c"</code> from <code>predictors_df</code> to generate the predictor <code>a</code> as the multivariate distance between <code>"b"</code> and <code>"c"</code> for each pair of time series in <code>response_df</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_model_frame_+3A_scale">scale</code></td>
<td>
<p>(optional, logical) if TRUE, all predictors are scaled and centered with <code><a href="base.html#topic+scale">scale()</a></code>. Default: TRUE</p>
</td></tr>
<tr><td><code id="distantia_model_frame_+3A_distance">distance</code></td>
<td>
<p>(optional, string) Method to compute the distance between predictor values for all pairs of time series in <code>response_df</code>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame: with attributes &quot;predictors&quot;, &quot;response&quot;, and &quot;formula&quot;.
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#covid prevalence in California counties
tsl &lt;- tsl_initialize(
  x = covid_prevalence,
  name_column = "name",
  time_column = "time"
) |&gt;
  #subset to shorten example runtime
  tsl_subset(
    names = 1:5
  )

#dissimilarity analysis
df &lt;- distantia_ls(tsl = tsl)

#combine several predictors
#into a new one
composite_predictors &lt;- list(
  economy = c(
    "poverty_percentage",
    "median_income",
    "domestic_product"
    )
)

#generate model frame
model_frame &lt;- distantia_model_frame(
  response_df = df,
  predictors_df = covid_counties,
  composite_predictors = composite_predictors,
  scale = TRUE
)

head(model_frame)

#names of response and predictors
#and an additive formula
#are stored as attributes
attributes(model_frame)$predictors

#if response_df is output of distantia():
attributes(model_frame)$response
attributes(model_frame)$formula

#example of linear model
# model &lt;- lm(
#   formula = attributes(model_frame)$formula,
#   data = model_frame
# )
#
# summary(model)

</code></pre>

<hr>
<h2 id='distantia_spatial'>Spatial Representation of <code>distantia()</code> Data Frames</h2><span id='topic+distantia_spatial'></span>

<h3>Description</h3>

<p>Given an sf data frame with geometry types POLYGON, MULTIPOLYGON, or POINT representing time series locations, this function transforms the output of <code><a href="#topic+distantia">distantia()</a></code>, <code><a href="#topic+distantia_ls">distantia_ls()</a></code>, <code><a href="#topic+distantia_dtw">distantia_dtw()</a></code> or <code><a href="#topic+distantia_time_delay">distantia_time_delay()</a></code> to an sf data frame.
</p>
<p>If <code>network = TRUE</code>, the sf data frame is of type LINESTRING, with edges connecting time series locations. This output is helpful to build many-to-many dissimilarity maps (see examples).
</p>
<p>If <code>network = FALSE</code>, the sf data frame contains the geometry in the input <code>sf</code> argument. This output helps build one-to-many dissimilarity maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_spatial(df = NULL, sf = NULL, network = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_spatial_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+distantia">distantia()</a></code> or <code><a href="#topic+distantia_time_delay">distantia_time_delay()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_spatial_+3A_sf">sf</code></td>
<td>
<p>(required, sf data frame) Points or polygons representing the location of the time series in argument 'df'. It must have a column with all time series names in <code>df$x</code> and <code>df$y</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_spatial_+3A_network">network</code></td>
<td>
<p>(optional, logical) If TRUE, the resulting sf data frame is of time LINESTRING and represent network edges. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf data frame (LINESTRING geometry)
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsl &lt;- distantia::tsl_initialize(
  x = distantia::covid_prevalence,
  name_column = "name",
  time_column = "time"
) |&gt;
distantia::tsl_subset(
  names = c(
    "Los_Angeles",
    "San_Francisco",
    "Fresno",
    "San_Joaquin"
    )
 )

df_psi &lt;- distantia::distantia_ls(
  tsl = tsl
)

#network many to many
sf_psi &lt;- distantia::distantia_spatial(
  df = df_psi,
  sf = distantia::covid_counties,
  network = TRUE
)

#network map
# mapview::mapview(
#   distantia::covid_counties,
#   col.regions = NA,
#   alpha.regions = 0,
#   color = "black",
#   label = "name",
#   legend = FALSE,
#   map.type = "OpenStreetMap"
# ) +
#   mapview::mapview(
#     sf_psi_subset,
#     layer.name = "Psi",
#     label = "edge_name",
#     zcol = "psi",
#     lwd = 3
#   ) |&gt;
#   suppressWarnings()

</code></pre>

<hr>
<h2 id='distantia_stats'>Stats of Dissimilarity Data Frame</h2><span id='topic+distantia_stats'></span>

<h3>Description</h3>

<p>Takes the output of <code><a href="#topic+distantia">distantia()</a></code> to return a data frame with one row per time series with the stats of its dissimilarity scores with all other time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_stats(df = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_stats_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+distantia">distantia()</a></code>, <code><a href="#topic+distantia_ls">distantia_ls()</a></code>, <code><a href="#topic+distantia_dtw">distantia_dtw()</a></code>, or <code><a href="#topic+distantia_time_delay">distantia_time_delay()</a></code>. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsl &lt;- tsl_simulate(
  n = 5,
  irregular = FALSE
  )

df &lt;- distantia(
  tsl = tsl,
  lock_step = TRUE
  )

df_stats &lt;- distantia_stats(df = df)

df_stats
</code></pre>

<hr>
<h2 id='distantia_time_delay'>Time Shift Between Time Series</h2><span id='topic+distantia_time_delay'></span>

<h3>Description</h3>

<p>This function computes an approximation to the time-shift between pairs of time series as the absolute time difference between pairs of observations in the time series <em>x</em> and <em>y</em> connected by the dynamic time warping path.
</p>
<p>If the time series are long enough, the extremes of the warping path are trimmed (5% of the total path length each) to avoid artifacts due to early misalignments.
</p>
<p>It returns a data frame with the modal, mean, median, minimum, maximum, quantiles 0.25 and 0.75, and standard deviation. The modal and the median are the most generally accurate time-shift descriptors.
</p>
<p>This function requires scaled and detrended time series. Still, it might yield non-sensical results in case of degenerate warping paths. Plotting dubious results with [distantia_dtw_plot())] is always a good approach to identify these cases.
</p>
<p>[distantia_dtw_plot())]: R:distantia_dtw_plot())
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distantia_time_delay(
  tsl = NULL,
  distance = "euclidean",
  bandwidth = 1,
  two_way = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distantia_time_delay_+3A_tsl">tsl</code></td>
<td>
<p>(required, time series list) list of zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="distantia_time_delay_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="distantia_time_delay_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(optional, numeric) Proportion of space at each side of the cost matrix diagonal (aka <em>Sakoe-Chiba band</em>) defining a valid region for dynamic time warping, used to control the flexibility of the warping path. This method prevents degenerate alignments due to differences in magnitude between time series when the data is not properly scaled. If <code>1</code> (default), DTW is unconstrained. If <code>0</code>, DTW is fully constrained and the warping path follows the matrix diagonal. Recommended values may vary depending on the nature of the data. Ignored if <code>lock_step = TRUE</code>. Default: 1.</p>
</td></tr>
<tr><td><code id="distantia_time_delay_+3A_two_way">two_way</code></td>
<td>
<p>(optional, logical) If TRUE, the time shift between the time series pairs <em>y</em> and <em>x</em> is added to the results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load two long-term temperature time series
#local scaling to focus in shape rather than values
#polynomial detrending to make them stationary
tsl &lt;- tsl_init(
  x = cities_temperature[
    cities_temperature$name %in% c("London", "Kinshasa"),
    ],
  name = "name",
  time = "time"
) |&gt;
  tsl_transform(
    f = f_scale_local
  ) |&gt;
  tsl_transform(
    f = f_detrend_poly,
    degree = 35 #data years
  )


if(interactive()){
  tsl_plot(
    tsl = tsl,
    guide = FALSE
  )
}

#compute shifts
df_shift &lt;- distantia_time_delay(
  tsl = tsl,
  two_way = TRUE
)

df_shift
#positive shift values indicate
#that the samples in Kinshasa
#are aligned with older samples in London.
</code></pre>

<hr>
<h2 id='eemian_coordinates'>Site Coordinates of Nine Interglacial Sites in Central Europe</h2><span id='topic+eemian_coordinates'></span>

<h3>Description</h3>

<p>Site Coordinates of Nine Interglacial Sites in Central Europe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eemian_coordinates)
</code></pre>


<h3>Format</h3>

<p>sf data frame with 4 columns and 9 rows.
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>
<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>

<hr>
<h2 id='eemian_pollen'>Pollen Counts of Nine Interglacial Sites in Central Europe</h2><span id='topic+eemian_pollen'></span>

<h3>Description</h3>

<p>Pollen counts of nine interglacial sites in central Europe.
</p>
<p>Site coordinates for this dataset are in <a href="#topic+eemian_coordinates">eemian_coordinates</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eemian_pollen)
</code></pre>


<h3>Format</h3>

<p>data frame with 24 columns and 376 rows.
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("eemian_pollen")

#to time series list
tsl &lt;- tsl_initialize(
  x = eemian_pollen,
  name_column = "name",
  time_column = "time"
)

#time series plot
if(interactive()){

 tsl_plot(
  tsl = tsl_subset(
    tsl = tsl,
    names = 1:3
    ),
  columns = 2,
  guide_columns = 2
  )

}

</code></pre>

<hr>
<h2 id='f_binary'>Transform Zoo Object to Binary</h2><span id='topic+f_binary'></span>

<h3>Description</h3>

<p>Converts a zoo object to binary (1 and 0) based on a given threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_binary(x = NULL, threshold = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_binary_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_binary_+3A_threshold">threshold</code></td>
<td>
<p>(required, numeric) Values greater than this number become 1, others become 0. Set to the mean of the time series by default. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(
  data_range = c(0, 1)
  )

y &lt;- f_binary(
  x = x,
  threshold = 0.5
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_clr'>Data Transformation: Rowwise Centered Log-Ratio</h2><span id='topic+f_clr'></span>

<h3>Description</h3>

<p>Centers log-transformed proportions by subtracting the geometric mean of the row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_clr(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_clr_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_clr_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(
  cols = 5,
  data_range = c(0, 500)
  )

y &lt;- f_clr(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_detrend_difference'>Data Transformation: Detrending and Differencing</h2><span id='topic+f_detrend_difference'></span>

<h3>Description</h3>

<p>Performs differencing to remove trends from a zoo time series, isolating short-term fluctuations by subtracting values at specified lags. The function preserves the original index and metadata, with an option to center the output around the mean of the original series. Suitable for preprocessing time series data to focus on random fluctuations unrelated to overall trends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_detrend_difference(x = NULL, lag = 1, center = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_detrend_difference_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_detrend_difference_+3A_lag">lag</code></td>
<td>
<p>(optional, integer)</p>
</td></tr>
<tr><td><code id="f_detrend_difference_+3A_center">center</code></td>
<td>
<p>(required, logical) If TRUE, the output is centered at zero. If FALSE, it is centered at the data mean. Default: TRUE</p>
</td></tr>
<tr><td><code id="f_detrend_difference_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(cols = 2)

y_lag1 &lt;- f_detrend_difference(
  x = x,
  lag = 1
)

y_lag5 &lt;- f_detrend_difference(
  x = x,
  lag = 5
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y_lag1)
  zoo_plot(y_lag5)
}
</code></pre>

<hr>
<h2 id='f_detrend_linear'>Data Transformation: Linear Detrending of Zoo Time Series</h2><span id='topic+f_detrend_linear'></span>

<h3>Description</h3>

<p>Fits a linear model on each column of a zoo object using time as a predictor, predicts the outcome, and subtracts it from the original data to return a detrended time series. This method might not be suitable if the input data is not seasonal and has a clear trend, so please be mindful of the limitations of this function when applied blindly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_detrend_linear(x = NULL, center = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_detrend_linear_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_detrend_linear_+3A_center">center</code></td>
<td>
<p>(required, logical) If TRUE, the output is centered at zero. If FALSE, it is centered at the data mean. Default: TRUE</p>
</td></tr>
<tr><td><code id="f_detrend_linear_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(cols = 2)

y &lt;- f_detrend_linear(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_detrend_poly'>Data Transformation: Polynomial Linear Detrending of Zoo Time Series</h2><span id='topic+f_detrend_poly'></span>

<h3>Description</h3>

<p>Fits a polynomial linear model on each column of a zoo object using time as a predictor, predicts the outcome, and subtracts it from the original data to return a detrended time series. This method is a useful alternative to <a href="#topic+f_detrend_linear">f_detrend_linear</a> when the overall trend of the time series does not follow a straight line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_detrend_poly(x = NULL, degree = 2, center = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_detrend_poly_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_detrend_poly_+3A_degree">degree</code></td>
<td>
<p>(optional, integer) Degree of the polynomial. Default: 2</p>
</td></tr>
<tr><td><code id="f_detrend_poly_+3A_center">center</code></td>
<td>
<p>(required, logical) If TRUE, the output is centered at zero. If FALSE, it is centered at the data mean. Default: TRUE</p>
</td></tr>
<tr><td><code id="f_detrend_poly_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(cols = 2)

y &lt;- f_detrend_poly(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_hellinger'>Data Transformation: Rowwise Hellinger Transformation</h2><span id='topic+f_hellinger'></span>

<h3>Description</h3>

<p>Transforms the input zoo object to proportions via <a href="#topic+f_proportion">f_proportion</a> and then applies the Hellinger transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_hellinger(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_hellinger_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_hellinger_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(
  cols = 5,
  data_range = c(0, 500)
  )

y &lt;- f_hellinger(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_list'>Lists Available Transformation Functions</h2><span id='topic+f_list'></span>

<h3>Description</h3>

<p>Lists Available Transformation Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_list()
</code></pre>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_list()
</code></pre>

<hr>
<h2 id='f_log'>Data Transformation: Log</h2><span id='topic+f_log'></span>

<h3>Description</h3>

<p>Applies logarithmic transformation to data to reduce skewness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_log(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_log_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_log_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(
  cols = 5,
  data_range = c(0, 500)
  )

y &lt;- f_log(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_percent'>Data Transformation: Rowwise Percentages</h2><span id='topic+f_percent'></span>

<h3>Description</h3>

<p>Data Transformation: Rowwise Percentages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_percent(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_percent_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_percent_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(cols = 2)

y &lt;- f_percent(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_proportion'>Data Transformation: Rowwise Proportions</h2><span id='topic+f_proportion'></span>

<h3>Description</h3>

<p>Data Transformation: Rowwise Proportions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_proportion(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_proportion_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_proportion_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(cols = 2)

y &lt;- f_proportion(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_proportion_sqrt'>Data Transformation: Rowwise Square Root of Proportions</h2><span id='topic+f_proportion_sqrt'></span>

<h3>Description</h3>

<p>Data Transformation: Rowwise Square Root of Proportions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_proportion_sqrt(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_proportion_sqrt_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_proportion_sqrt_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(cols = 2)

y &lt;- f_proportion_sqrt(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_rescale_global'>Data Transformation: Global Rescaling of to a New Range</h2><span id='topic+f_rescale_global'></span>

<h3>Description</h3>

<p>Data Transformation: Global Rescaling of to a New Range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_rescale_global(
  x = NULL,
  new_min = 0,
  new_max = 1,
  old_min = NULL,
  old_max = NULL,
  .global,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_rescale_global_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Time Series. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="f_rescale_global_+3A_new_min">new_min</code></td>
<td>
<p>(optional, numeric) New minimum value. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="f_rescale_global_+3A_new_max">new_max</code></td>
<td>
<p>(optional_numeric) New maximum value. Default: <code>1</code></p>
</td></tr>
<tr><td><code id="f_rescale_global_+3A_old_min">old_min</code></td>
<td>
<p>(optional, numeric) Old minimum value. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="f_rescale_global_+3A_old_max">old_max</code></td>
<td>
<p>(optional_numeric) Old maximum value. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="f_rescale_global_+3A_.global">.global</code></td>
<td>
<p>(optional, logical) Used to trigger global scaling within <code><a href="#topic+tsl_transform">tsl_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="f_rescale_global_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(cols = 2)

y &lt;- f_rescale_global(
  x = x,
  new_min = 0,
  new_max = 100
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_rescale_local'>Data Transformation: Local Rescaling of to a New Range</h2><span id='topic+f_rescale_local'></span>

<h3>Description</h3>

<p>Data Transformation: Local Rescaling of to a New Range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_rescale_local(
  x = NULL,
  new_min = 0,
  new_max = 1,
  old_min = NULL,
  old_max = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_rescale_local_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Time Series. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="f_rescale_local_+3A_new_min">new_min</code></td>
<td>
<p>(optional, numeric) New minimum value. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="f_rescale_local_+3A_new_max">new_max</code></td>
<td>
<p>(optional_numeric) New maximum value. Default: <code>1</code></p>
</td></tr>
<tr><td><code id="f_rescale_local_+3A_old_min">old_min</code></td>
<td>
<p>(optional, numeric) Old minimum value. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="f_rescale_local_+3A_old_max">old_max</code></td>
<td>
<p>(optional_numeric) Old maximum value. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="f_rescale_local_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(cols = 2)

y &lt;- f_rescale_global(
  x = x,
  new_min = 0,
  new_max = 100
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_scale_global'>Data Transformation: Global Centering and Scaling</h2><span id='topic+f_scale_global'></span>

<h3>Description</h3>

<p>Scaling and/or centering by variable using the mean and standard deviation computed across all time series. Global scaling helps dynamic time warping take variable offsets between time series into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_scale_global(x = NULL, center = TRUE, scale = TRUE, .global, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_scale_global_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_scale_global_+3A_center">center</code></td>
<td>
<p>(optional, logical or numeric vector) Triggers centering if TRUE. Default: TRUE</p>
</td></tr>
<tr><td><code id="f_scale_global_+3A_scale">scale</code></td>
<td>
<p>(optional, logical or numeric vector) Triggers scaling if TRUE. Default: TRUE</p>
</td></tr>
<tr><td><code id="f_scale_global_+3A_.global">.global</code></td>
<td>
<p>(optional, logical) Used to trigger global scaling within <code><a href="#topic+tsl_transform">tsl_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="f_scale_global_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate()

y &lt;- f_scale_global(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_scale_local'>Data Transformation: Local Centering and Scaling</h2><span id='topic+f_scale_local'></span>

<h3>Description</h3>

<p>Scaling and/or centering by variable and time series. Local scaling helps dynamic time warping focus entirely on shape comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_scale_local(x = NULL, center = TRUE, scale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_scale_local_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_scale_local_+3A_center">center</code></td>
<td>
<p>(optional, logical or numeric vector) Triggers centering if TRUE. Default: TRUE</p>
</td></tr>
<tr><td><code id="f_scale_local_+3A_scale">scale</code></td>
<td>
<p>(optional, logical or numeric vector) Triggers scaling if TRUE. Default: TRUE</p>
</td></tr>
<tr><td><code id="f_scale_local_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate()

y &lt;- f_scale_global(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_trend_linear'>Data Transformation: Linear Trend of Zoo Time Series</h2><span id='topic+f_trend_linear'></span>

<h3>Description</h3>

<p>Fits a linear model on each column of a zoo object using time as a predictor, and predicts the outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_trend_linear(x = NULL, center = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_trend_linear_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_trend_linear_+3A_center">center</code></td>
<td>
<p>(required, logical) If TRUE, the output is centered at zero. If FALSE, it is centered at the data mean. Default: TRUE</p>
</td></tr>
<tr><td><code id="f_trend_linear_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_poly">f_trend_poly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(cols = 2)

y &lt;- f_trend_linear(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='f_trend_poly'>Data Transformation: Polynomial Linear Trend of Zoo Time Series</h2><span id='topic+f_trend_poly'></span>

<h3>Description</h3>

<p>Fits a polynomial linear model on each column of a zoo object using time as a predictor, and predicts the outcome to return the polynomial trend of the time series. This method is a useful alternative to <a href="#topic+f_trend_linear">f_trend_linear</a> when the overall. trend of the time series does not follow a straight line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_trend_poly(x = NULL, degree = 2, center = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_trend_poly_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series object to transform.</p>
</td></tr>
<tr><td><code id="f_trend_poly_+3A_degree">degree</code></td>
<td>
<p>(optional, integer) Degree of the polynomial. Default: 2</p>
</td></tr>
<tr><td><code id="f_trend_poly_+3A_center">center</code></td>
<td>
<p>(required, logical) If TRUE, the output is centered at zero. If FALSE, it is centered at the data mean. Default: TRUE</p>
</td></tr>
<tr><td><code id="f_trend_poly_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) Ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other tsl_transformation: 
<code><a href="#topic+f_binary">f_binary</a>()</code>,
<code><a href="#topic+f_clr">f_clr</a>()</code>,
<code><a href="#topic+f_detrend_difference">f_detrend_difference</a>()</code>,
<code><a href="#topic+f_detrend_linear">f_detrend_linear</a>()</code>,
<code><a href="#topic+f_detrend_poly">f_detrend_poly</a>()</code>,
<code><a href="#topic+f_hellinger">f_hellinger</a>()</code>,
<code><a href="#topic+f_list">f_list</a>()</code>,
<code><a href="#topic+f_log">f_log</a>()</code>,
<code><a href="#topic+f_percent">f_percent</a>()</code>,
<code><a href="#topic+f_proportion">f_proportion</a>()</code>,
<code><a href="#topic+f_proportion_sqrt">f_proportion_sqrt</a>()</code>,
<code><a href="#topic+f_rescale_global">f_rescale_global</a>()</code>,
<code><a href="#topic+f_rescale_local">f_rescale_local</a>()</code>,
<code><a href="#topic+f_scale_global">f_scale_global</a>()</code>,
<code><a href="#topic+f_scale_local">f_scale_local</a>()</code>,
<code><a href="#topic+f_trend_linear">f_trend_linear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate(cols = 2)

y &lt;- f_trend_poly(
  x = x
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(y)
}
</code></pre>

<hr>
<h2 id='fagus_coordinates'>Site Coordinates of Fagus sylvatica Stands</h2><span id='topic+fagus_coordinates'></span>

<h3>Description</h3>

<p>Site Coordinates of Fagus sylvatica Stands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fagus_coordinates)
</code></pre>


<h3>Format</h3>

<p>sf data frame with 3 rows and 4 columns
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>

<hr>
<h2 id='fagus_dynamics'>Time Series Data from Three Fagus sylvatica Stands</h2><span id='topic+fagus_dynamics'></span>

<h3>Description</h3>

<p>A data frame with 648 rows representing enhanced vegetation index, rainfall and temperature in three stands of Fagus sylvatica in Spain, Germany, and Sweden.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fagus_dynamics)
</code></pre>


<h3>Format</h3>

<p>data frame with 5 columns and 648 rows.
</p>


<h3>Details</h3>

<p>Site coordinates for this dataset are in <a href="#topic+fagus_coordinates">fagus_coordinates</a>.
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("fagus_dynamics")

#to time series list
fagus &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
)

#time series plot
if(interactive()){

 tsl_plot(
  tsl = fagus
  )

}

</code></pre>

<hr>
<h2 id='honeycomb_climate'>Rainfall and Temperature in The Americas</h2><span id='topic+honeycomb_climate'></span>

<h3>Description</h3>

<p>Monthly temperature and rainfall between 2009 and 2019 in 72 hexagonal cells covering The Americas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(honeycomb_climate)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 9432 rows and 4 columns.
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_polygons">honeycomb_polygons</a></code>
</p>

<hr>
<h2 id='honeycomb_polygons'>Hexagonal Grid</h2><span id='topic+honeycomb_polygons'></span>

<h3>Description</h3>

<p>Sf data frame with hexagonal grid of the dataset <a href="#topic+honeycomb_climate">honeycomb_climate</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(honeycomb_polygons)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 72 rows and 2 columns.
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+albatross">albatross</a></code>,
<code><a href="#topic+cities_coordinates">cities_coordinates</a></code>,
<code><a href="#topic+cities_temperature">cities_temperature</a></code>,
<code><a href="#topic+covid_counties">covid_counties</a></code>,
<code><a href="#topic+covid_prevalence">covid_prevalence</a></code>,
<code><a href="#topic+eemian_coordinates">eemian_coordinates</a></code>,
<code><a href="#topic+eemian_pollen">eemian_pollen</a></code>,
<code><a href="#topic+fagus_coordinates">fagus_coordinates</a></code>,
<code><a href="#topic+fagus_dynamics">fagus_dynamics</a></code>,
<code><a href="#topic+honeycomb_climate">honeycomb_climate</a></code>
</p>

<hr>
<h2 id='importance_dtw_cpp'>(C++) Contribution of Individual Variables to the Dissimilarity Between Two Time Series (Robust Version)</h2><span id='topic+importance_dtw_cpp'></span>

<h3>Description</h3>

<p>Computes the contribution of individual variables to the
similarity/dissimilarity between two irregular multivariate time series.
In opposition to the legacy version, importance computation is
performed taking the least-cost path of the whole sequence as reference. This
operation makes the importance scores of individual variables fully comparable.
This function generates a data frame with the following columns:
</p>

<ul>
<li><p> variable: name of the individual variable for which the importance
is being computed, from the column names of the arguments <code>x</code> and <code>y</code>.
</p>
</li>
<li><p> psi: global dissimilarity score <code>psi</code> of the two time series.
</p>
</li>
<li><p> psi_only_with: dissimilarity between <code>x</code> and <code>y</code> computed from the given variable alone.
</p>
</li>
<li><p> psi_without: dissimilarity between <code>x</code> and <code>y</code> computed from all other variables.
</p>
</li>
<li><p> psi_difference: difference between <code>psi_only_with</code> and <code>psi_without</code>.
</p>
</li>
<li><p> importance: contribution of the variable to the similarity/dissimilarity
between <code>x</code> and <code>y</code>, computed as <code>(psi_difference * 100) / psi_all</code>.
Positive scores represent contribution to dissimilarity,
while negative scores represent contribution to similarity.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>importance_dtw_cpp(
  x,
  y,
  distance = "euclidean",
  diagonal = TRUE,
  weighted = TRUE,
  ignore_blocks = FALSE,
  bandwidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="importance_dtw_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) multivariate time series.</p>
</td></tr>
<tr><td><code id="importance_dtw_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) multivariate time series
with the same number of columns as 'x'.</p>
</td></tr>
<tr><td><code id="importance_dtw_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="importance_dtw_cpp_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical). If TRUE, diagonals are included in the
computation of the cost matrix. Default: TRUE.</p>
</td></tr>
<tr><td><code id="importance_dtw_cpp_+3A_weighted">weighted</code></td>
<td>
<p>(optional, logical). Only relevant when diagonal is TRUE. When TRUE,
diagonal cost is weighted by y factor of 1.414214 (square root of 2). Default: TRUE.</p>
</td></tr>
<tr><td><code id="importance_dtw_cpp_+3A_ignore_blocks">ignore_blocks</code></td>
<td>
<p>(optional, logical). If TRUE, blocks of consecutive path
coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.</p>
</td></tr>
<tr><td><code id="importance_dtw_cpp_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(required, numeric) Size of the Sakoe-Chiba band at
both sides of the diagonal used to constrain the least cost path. Expressed
as a fraction of the number of matrix rows and columns. Unrestricted by default.
Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other Rcpp_importance: 
<code><a href="#topic+importance_dtw_legacy_cpp">importance_dtw_legacy_cpp</a>()</code>,
<code><a href="#topic+importance_ls_cpp">importance_ls_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two regular time series
x &lt;- zoo_simulate(
  seed = 1,
  rows = 100
  )

y &lt;- zoo_simulate(
  seed = 2,
  rows = 150
  )

#different number of rows
#this is not a requirement though!
nrow(x) == nrow(y)

#compute importance
df &lt;- importance_dtw_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

df
</code></pre>

<hr>
<h2 id='importance_dtw_legacy_cpp'>(C++) Contribution of Individual Variables to the Dissimilarity Between Two Time Series (Legacy Version)</h2><span id='topic+importance_dtw_legacy_cpp'></span>

<h3>Description</h3>

<p>Computes the contribution of individual variables to the
similarity/dissimilarity between two irregular multivariate time series.
In opposition to the robust version, least-cost paths for each combination
of variables are computed independently, which makes the results of individual
variables harder to compare. This function should only be used when the objective is
replicating importance scores generated with previous versions of the package <code>distantia</code>.
This function generates a data frame with the following columns:
</p>

<ul>
<li><p> variable: name of the individual variable for which the importance
is being computed, from the column names of the arguments <code>x</code> and <code>y</code>.
</p>
</li>
<li><p> psi: global dissimilarity score <code>psi</code> of the two time series.
</p>
</li>
<li><p> psi_only_with: dissimilarity between <code>x</code> and <code>y</code> computed from the given variable alone.
</p>
</li>
<li><p> psi_without: dissimilarity between <code>x</code> and <code>y</code> computed from all other variables.
</p>
</li>
<li><p> psi_difference: difference between <code>psi_only_with</code> and <code>psi_without</code>.
</p>
</li>
<li><p> importance: contribution of the variable to the similarity/dissimilarity
between <code>x</code> and <code>y</code>, computed as <code>((psi_all - psi_without) * 100) / psi_all</code>.
Positive scores represent contribution to dissimilarity,
while negative scores represent contribution to similarity.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>importance_dtw_legacy_cpp(
  y,
  x,
  distance = "euclidean",
  diagonal = FALSE,
  weighted = TRUE,
  ignore_blocks = FALSE,
  bandwidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="importance_dtw_legacy_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) multivariate time series
with the same number of columns as 'x'.</p>
</td></tr>
<tr><td><code id="importance_dtw_legacy_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) multivariate time series.</p>
</td></tr>
<tr><td><code id="importance_dtw_legacy_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="importance_dtw_legacy_cpp_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical). If TRUE, diagonals are included in the
computation of the cost matrix. Default: TRUE.</p>
</td></tr>
<tr><td><code id="importance_dtw_legacy_cpp_+3A_weighted">weighted</code></td>
<td>
<p>(optional, logical). Only relevant when diagonal is TRUE. When TRUE,
diagonal cost is weighted by y factor of 1.414214 (square root of 2). Default: TRUE.</p>
</td></tr>
<tr><td><code id="importance_dtw_legacy_cpp_+3A_ignore_blocks">ignore_blocks</code></td>
<td>
<p>(optional, logical). If TRUE, blocks of consecutive path
coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.</p>
</td></tr>
<tr><td><code id="importance_dtw_legacy_cpp_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(required, numeric) Size of the Sakoe-Chiba band at
both sides of the diagonal used to constrain the least cost path. Expressed
as a fraction of the number of matrix rows and columns. Unrestricted by default.
Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other Rcpp_importance: 
<code><a href="#topic+importance_dtw_cpp">importance_dtw_cpp</a>()</code>,
<code><a href="#topic+importance_ls_cpp">importance_ls_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two regular time series
x &lt;- zoo_simulate(
  seed = 1,
  rows = 100
  )

y &lt;- zoo_simulate(
  seed = 2,
  rows = 150
  )

#different number of rows
#this is not a requirement though!
nrow(x) == nrow(y)

#compute importance
df &lt;- importance_dtw_legacy_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

df
</code></pre>

<hr>
<h2 id='importance_ls_cpp'>(C++) Contribution of Individual Variables to the Dissimilarity Between Two Aligned Time Series</h2><span id='topic+importance_ls_cpp'></span>

<h3>Description</h3>

<p>Computes the contribution of individual variables to the
similarity/dissimilarity between two aligned multivariate time series.
This function generates a data frame with the following columns:
</p>

<ul>
<li><p> variable: name of the individual variable for which the importance
is being computed, from the column names of the arguments <code>x</code> and <code>y</code>.
</p>
</li>
<li><p> psi: global dissimilarity score <code>psi</code> of the two time series.
</p>
</li>
<li><p> psi_only_with: dissimilarity between <code>x</code> and <code>y</code> computed from the given variable alone.
</p>
</li>
<li><p> psi_without: dissimilarity between <code>x</code> and <code>y</code> computed from all other variables.
</p>
</li>
<li><p> psi_difference: difference between <code>psi_only_with</code> and <code>psi_without</code>.
</p>
</li>
<li><p> importance: contribution of the variable to the similarity/dissimilarity
between <code>x</code> and <code>y</code>, computed as <code>(psi_difference * 100) / psi_all</code>.
Positive scores represent contribution to dissimilarity,
while negative scores represent contribution to similarity.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>importance_ls_cpp(x, y, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="importance_ls_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) multivariate time series.</p>
</td></tr>
<tr><td><code id="importance_ls_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) multivariate time series
with the same number of columns and rows as 'x'.</p>
</td></tr>
<tr><td><code id="importance_ls_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other Rcpp_importance: 
<code><a href="#topic+importance_dtw_cpp">importance_dtw_cpp</a>()</code>,
<code><a href="#topic+importance_dtw_legacy_cpp">importance_dtw_legacy_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate two regular time series
x &lt;- zoo_simulate(
  seed = 1,
  irregular = FALSE
  )

y &lt;- zoo_simulate(
  seed = 2,
  irregular = FALSE
  )

#same number of rows
nrow(x) == nrow(y)

#compute importance
df &lt;- importance_ls_cpp(
  x = x,
  y = y,
  distance = "euclidean"
)

df
</code></pre>

<hr>
<h2 id='momentum'>Contribution of Individual Variables to Time Series Dissimilarity</h2><span id='topic+momentum'></span>

<h3>Description</h3>

<p>This function measures the contribution of individual variables to the dissimilarity between pairs of time series to help answer the question <em>what makes two time series more or less similar?</em>
</p>
<p>Three key values are required to assess individual variable contributions:
</p>

<ul>
<li> <p><strong>psi</strong>: dissimilarity when all variables are considered.
</p>
</li>
<li> <p><strong>psi_only_with</strong>: dissimilarity when using only the target variable.
</p>
</li>
<li> <p><strong>psi_without</strong>: dissimilarity when removing the target variable.
</p>
</li></ul>

<p>The values <code>psi_only_with</code> and <code>psi_without</code> can be computed in two different ways defined by the argument <code>robust</code>.
</p>

<ul>
<li> <p><code>robust = FALSE</code>: This method replicates the importance algorithm released with the first version of the package, and it is only recommended when the goal to compare new results with previous studies. It normalizes <code>psi_only_with</code> and <code>psi_without</code> using the least cost path obtained from the individual variable. As different variables may have different least cost paths for the same time series, normalization values may change from variable to variable, making individual importance scores harder to compare.
</p>
</li>
<li> <p><code>robust = TRUE</code> (default, recommended): This a novel version of the importance algorithm that yields more stable and comparable solutions. It uses the least cost path of the complete time series to normalize <code>psi_only_with</code> and <code>psi_without</code>, making importance scores of separate variables fully comparable.
</p>
</li></ul>

<p>The individual importance score of each variable (column &quot;importance&quot; in the output data frame) is based on different expressions depending on the <code>robust</code> argument, even when <code>lock_step = TRUE</code>:
</p>

<ul>
<li> <p><code>robust = FALSE</code>: Importance is computed as <code>((psi - psi_without) * 100)/psi</code> and interpreted as &quot;change in similarity when a variable is removed&quot;.
</p>
</li>
<li> <p><code>robust = TRUE</code>: Importance is computed as <code>((psi_only_with - psi_without) * 100)/psi</code> and interpreted as &quot;relative dissimilarity induced by the variable expressed as a percentage&quot;.
</p>
</li></ul>

<p>In either case, positive values indicate that the variable contributes to dissimilarity, while negative values indicate a net contribution to similarity.
</p>
<p>This function allows computing dissimilarity between pairs of time series using different combinations of arguments at once. For example, when the argument <code>distance</code> is set to <code>c("euclidean", "manhattan")</code>, the output data frame will show two dissimilarity scores for each pair of time series, one based on euclidean distances, and another based on manhattan distances. The same happens for most other parameters.
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentum(
  tsl = NULL,
  distance = "euclidean",
  diagonal = TRUE,
  bandwidth = 1,
  lock_step = FALSE,
  robust = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentum_+3A_tsl">tsl</code></td>
<td>
<p>(required, time series list) list of zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="momentum_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical vector). If TRUE, diagonals are included in the dynamic time warping computation. Default: TRUE</p>
</td></tr>
<tr><td><code id="momentum_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(optional, numeric) Proportion of space at each side of the cost matrix diagonal (aka <em>Sakoe-Chiba band</em>) defining a valid region for dynamic time warping, used to control the flexibility of the warping path. This method prevents degenerate alignments due to differences in magnitude between time series when the data is not properly scaled. If <code>1</code> (default), DTW is unconstrained. If <code>0</code>, DTW is fully constrained and the warping path follows the matrix diagonal. Recommended values may vary depending on the nature of the data. Ignored if <code>lock_step = TRUE</code>. Default: 1.</p>
</td></tr>
<tr><td><code id="momentum_+3A_lock_step">lock_step</code></td>
<td>
<p>(optional, logical vector) If TRUE, time series captured at the same times are compared sample wise (with no dynamic time warping). Requires time series in argument <code>tsl</code> to be fully aligned, or it will return an error. Default: FALSE.</p>
</td></tr>
<tr><td><code id="momentum_+3A_robust">robust</code></td>
<td>
<p>(required, logical). If TRUE (default), importance scores are computed using the least cost path of the complete time series as reference. Setting it to FALSE allows to replicate importance scores of the previous versions of this package. This option is irrelevant when <code>lock_step = TRUE</code>. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame:
</p>

<ul>
<li> <p><code>x</code>: name of the time series <code>x</code>.
</p>
</li>
<li> <p><code>y</code>: name of the time series <code>y</code>.
</p>
</li>
<li> <p><code>psi</code>: psi score of <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code>variable</code>: name of the individual variable.
</p>
</li>
<li> <p><code>importance</code>: importance score of the variable.
</p>
</li>
<li> <p><code>effect</code>: interpretation of the &quot;importance&quot; column, with the values &quot;increases similarity&quot; and &quot;decreases similarity&quot;.
</p>
</li>
<li> <p><code>psi_only_with</code>: psi score of the variable.
</p>
</li>
<li> <p><code>psi_without</code>: psi score without the variable.
</p>
</li>
<li> <p><code>psi_difference</code>: difference between <code>psi_only_with</code> and <code>psi_without</code>.
</p>
</li>
<li> <p><code>distance</code>: name of the distance metric.
</p>
</li>
<li> <p><code>diagonal</code>: value of the argument <code>diagonal</code>.
</p>
</li>
<li> <p><code>lock_step</code>: value of the argument <code>lock_step</code>.
</p>
</li>
<li> <p><code>robust</code>: value of the argument <code>robust</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other momentum: 
<code><a href="#topic+momentum_dtw">momentum_dtw</a>()</code>,
<code><a href="#topic+momentum_ls">momentum_ls</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#progress bar
# progressr::handlers(global = TRUE)

tsl &lt;- tsl_initialize(
  x = distantia::albatross,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

df &lt;- momentum(
  tsl = tsl,
  lock_step = TRUE #to speed-up example
  )

#focus on important columns
df[, c(
  "x",
  "y",
  "variable",
  "importance",
  "effect"
  )]

</code></pre>

<hr>
<h2 id='momentum_aggregate'>Aggregate <code>momentum()</code> Data Frames Across Parameter Combinations</h2><span id='topic+momentum_aggregate'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+momentum">momentum()</a></code> allows variable importance assessments based on several combinations of arguments at once. For example, when the argument <code>distance</code> is set to <code>c("euclidean", "manhattan")</code>, the output data frame will show two importance scores for each pair of compared time series and variable, one based on euclidean distances, and another based on manhattan distances.
</p>
<p>This function computes importance stats across combinations of parameters.
</p>
<p>If there are no different combinations of arguments in the input data frame, no aggregation happens, but all parameter columns are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentum_aggregate(df = NULL, f = mean, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentum_aggregate_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+momentum">momentum()</a></code>, <code><a href="#topic+momentum_ls">momentum_ls()</a></code>, or <code><a href="#topic+momentum_dtw">momentum_dtw()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_aggregate_+3A_f">f</code></td>
<td>
<p>(optional, function) Function to summarize psi scores (for example, <code>mean</code>) when there are several combinations of parameters in <code>df</code>. Ignored when there is a single combination of arguments in the input. Default: <code>mean</code></p>
</td></tr>
<tr><td><code id="momentum_aggregate_+3A_...">...</code></td>
<td>
<p>(optional, arguments of <code>f</code>) Further arguments to pass to the function <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other momentum_support: 
<code><a href="#topic+momentum_boxplot">momentum_boxplot</a>()</code>,
<code><a href="#topic+momentum_model_frame">momentum_model_frame</a>()</code>,
<code><a href="#topic+momentum_spatial">momentum_spatial</a>()</code>,
<code><a href="#topic+momentum_stats">momentum_stats</a>()</code>,
<code><a href="#topic+momentum_to_wide">momentum_to_wide</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#three time series
#climate and ndvi in Fagus sylvatica stands in Spain, Germany, and Sweden
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

if(interactive()){
  tsl_plot(
    tsl = tsl,
    guide_columns = 3
    )
}

#momentum with multiple parameter combinations
#-------------------------------------
df &lt;- momentum(
  tsl = tsl,
  distance = c("euclidean", "manhattan"),
  lock_step = TRUE
)

df[, c(
  "x",
  "y",
  "distance",
  "importance"
)]

#aggregation using means
df &lt;- momentum_aggregate(
  df = df,
  f = mean
)

df
</code></pre>

<hr>
<h2 id='momentum_boxplot'>Momentum Boxplot</h2><span id='topic+momentum_boxplot'></span>

<h3>Description</h3>

<p>Boxplot of a data frame returned by <code><a href="#topic+momentum">momentum()</a></code> summarizing the contribution to similarity (negative) and/or dissimilarity (positive) of individual variables across all time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentum_boxplot(df = NULL, fill_color = NULL, f = median, text_cex = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentum_boxplot_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+momentum">momentum()</a></code>, <code><a href="#topic+momentum_ls">momentum_ls()</a></code>, or <code><a href="#topic+momentum_dtw">momentum_dtw()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_boxplot_+3A_fill_color">fill_color</code></td>
<td>
<p>(optional, character vector) boxplot fill color. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_boxplot_+3A_f">f</code></td>
<td>
<p>(optional, function) Function to summarize psi scores (for example, <code>mean</code>) when there are several combinations of parameters in <code>df</code>. Ignored when there is a single combination of arguments in the input. Default: <code>mean</code></p>
</td></tr>
<tr><td><code id="momentum_boxplot_+3A_text_cex">text_cex</code></td>
<td>
<p>(optional, numeric) Multiplier of the text size. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boxplot
</p>


<h3>See Also</h3>

<p>Other momentum_support: 
<code><a href="#topic+momentum_aggregate">momentum_aggregate</a>()</code>,
<code><a href="#topic+momentum_model_frame">momentum_model_frame</a>()</code>,
<code><a href="#topic+momentum_spatial">momentum_spatial</a>()</code>,
<code><a href="#topic+momentum_stats">momentum_stats</a>()</code>,
<code><a href="#topic+momentum_to_wide">momentum_to_wide</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsl &lt;- tsl_initialize(
  x = distantia::albatross,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

df &lt;- momentum(
  tsl = tsl,
  lock_step = TRUE
  )

momentum_boxplot(
  df = df
  )
</code></pre>

<hr>
<h2 id='momentum_dtw'>Dynamic Time Warping Variable Importance Analysis of Multivariate Time Series Lists</h2><span id='topic+momentum_dtw'></span>

<h3>Description</h3>

<p>Minimalistic but slightly faster version of <code><a href="#topic+momentum">momentum()</a></code> to compute dynamic time warping importance analysis with the &quot;robust&quot; setup in multivariate time series lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentum_dtw(tsl = NULL, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentum_dtw_+3A_tsl">tsl</code></td>
<td>
<p>(required, time series list) list of zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_dtw_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame:
</p>

<ul>
<li> <p><code>x</code>: name of the time series <code>x</code>.
</p>
</li>
<li> <p><code>y</code>: name of the time series <code>y</code>.
</p>
</li>
<li> <p><code>psi</code>: psi score of <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code>variable</code>: name of the individual variable.
</p>
</li>
<li> <p><code>importance</code>: importance score of the variable.
</p>
</li>
<li> <p><code>effect</code>: interpretation of the &quot;importance&quot; column, with the values &quot;increases similarity&quot; and &quot;decreases similarity&quot;.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other momentum: 
<code><a href="#topic+momentum">momentum</a>()</code>,
<code><a href="#topic+momentum_ls">momentum_ls</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tsl &lt;- tsl_initialize(
  x = distantia::albatross,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

df &lt;- momentum_dtw(
  tsl = tsl,
  distance = "euclidean"
  )

#focus on important columns
df[, c(
  "x",
  "y",
  "variable",
  "importance",
  "effect"
  )]

</code></pre>

<hr>
<h2 id='momentum_ls'>Lock-Step Variable Importance Analysis of Multivariate Time Series Lists</h2><span id='topic+momentum_ls'></span>

<h3>Description</h3>

<p>Minimalistic but slightly faster version of <code><a href="#topic+momentum">momentum()</a></code> to compute lock-step importance analysis in multivariate time series lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentum_ls(tsl = NULL, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentum_ls_+3A_tsl">tsl</code></td>
<td>
<p>(required, time series list) list of zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_ls_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame:
</p>

<ul>
<li> <p><code>x</code>: name of the time series <code>x</code>.
</p>
</li>
<li> <p><code>y</code>: name of the time series <code>y</code>.
</p>
</li>
<li> <p><code>psi</code>: psi score of <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code>variable</code>: name of the individual variable.
</p>
</li>
<li> <p><code>importance</code>: importance score of the variable.
</p>
</li>
<li> <p><code>effect</code>: interpretation of the &quot;importance&quot; column, with the values &quot;increases similarity&quot; and &quot;decreases similarity&quot;.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other momentum: 
<code><a href="#topic+momentum">momentum</a>()</code>,
<code><a href="#topic+momentum_dtw">momentum_dtw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tsl &lt;- tsl_initialize(
  x = distantia::albatross,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

df &lt;- momentum_ls(
  tsl = tsl,
  distance = "euclidean"
  )

#focus on important columns
df[, c(
  "x",
  "y",
  "variable",
  "importance",
  "effect"
  )]

</code></pre>

<hr>
<h2 id='momentum_model_frame'>Dissimilarity Model Frame</h2><span id='topic+momentum_model_frame'></span>

<h3>Description</h3>

<p>This function generates a model frame for statistical or machine learning analysis from these objects:
</p>

<ul>
<li><p>: Dissimilarity data frame generated by <code><a href="#topic+momentum">momentum()</a></code>, <code><a href="#topic+momentum_ls">momentum_ls()</a></code>, or <code><a href="#topic+momentum_dtw">momentum_dtw()</a></code>. The output model frame will have as many rows as this data frame.
</p>
</li>
<li><p>: Data frame with static descriptors of the time series. These descriptors are converted to distances between pairs of time series via <code><a href="#topic+distance_matrix">distance_matrix()</a></code>.
</p>
</li>
<li><p>: List defining composite predictors. This feature allows grouping together predictors that have a common meaning. For example, <code style="white-space: pre;">&#8288;composite_predictors = list(temperature = c("temperature_mean", "temperature_min", "temperature_max")&#8288;</code> generates a new predictor named &quot;temperature&quot;, which results from computing the multivariate distances between the vectors of temperature variables of each pair of time series. Predictors in one of such groups will be scaled before distance computation if their maximum standard deviations differ by a factor of 10 or more.
</p>
</li></ul>

<p>The resulting data frame contains the following columns:
</p>

<ul>
<li> <p><code>x</code> and <code>y</code>: names of the pair of time series represented in the row.
</p>
</li>
<li><p> response columns.
</p>
</li>
<li><p> predictors columns: representing the distance between the values of the given static predictor between <code>x</code> and <code>y</code>.
</p>
</li>
<li><p> (optional) <code>geographic_distance</code>: If <code>predictors_df</code> is an <code>sf</code> data frame, then geographic distances are computed via <code><a href="sf.html#topic+geos_measures">sf::st_distance()</a></code>.
</p>
</li></ul>

<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentum_model_frame(
  response_df = NULL,
  predictors_df = NULL,
  composite_predictors = NULL,
  scale = TRUE,
  distance = "euclidean"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentum_model_frame_+3A_response_df">response_df</code></td>
<td>
<p>(required, data frame) output of <code><a href="#topic+momentum">momentum()</a></code>, <code><a href="#topic+momentum_ls">momentum_ls()</a></code>, or <code><a href="#topic+momentum_dtw">momentum_dtw()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_model_frame_+3A_predictors_df">predictors_df</code></td>
<td>
<p>(required, data frame or sf data frame) data frame with numeric predictors for the the model frame. Must have a column with the time series names in <code>response_df$x</code> and <code>response_df$y</code>. If <code>sf</code> data frame, the column &quot;geographic_distance&quot; with distances between pairs of time series is added to the model frame. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_model_frame_+3A_composite_predictors">composite_predictors</code></td>
<td>
<p>(optional, list) list defining composite predictors. For example, <code>composite_predictors = list(a = c("b", "c"))</code> uses the columns <code>"b"</code> and <code>"c"</code> from <code>predictors_df</code> to generate the predictor <code>a</code> as the multivariate distance between <code>"b"</code> and <code>"c"</code> for each pair of time series in <code>response_df</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_model_frame_+3A_scale">scale</code></td>
<td>
<p>(optional, logical) if TRUE, all predictors are scaled and centered with <code><a href="base.html#topic+scale">scale()</a></code>. Default: TRUE</p>
</td></tr>
<tr><td><code id="momentum_model_frame_+3A_distance">distance</code></td>
<td>
<p>(optional, string) Method to compute the distance between predictor values for all pairs of time series in <code>response_df</code>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame: with the attribute &quot;predictors&quot;.
</p>


<h3>See Also</h3>

<p>Other momentum_support: 
<code><a href="#topic+momentum_aggregate">momentum_aggregate</a>()</code>,
<code><a href="#topic+momentum_boxplot">momentum_boxplot</a>()</code>,
<code><a href="#topic+momentum_spatial">momentum_spatial</a>()</code>,
<code><a href="#topic+momentum_stats">momentum_stats</a>()</code>,
<code><a href="#topic+momentum_to_wide">momentum_to_wide</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Fagus sylvatica dynamics in Europe
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
)

#dissimilarity analysis
df &lt;- momentum_ls(tsl = tsl)

#generate model frame
model_frame &lt;- momentum_model_frame(
  response_df = df,
  predictors_df = fagus_coordinates,
  scale = TRUE
)

head(model_frame)

#names of response and predictors
#and an additive formula
#are stored as attributes
attributes(model_frame)$predictors

</code></pre>

<hr>
<h2 id='momentum_spatial'>Spatial Representation of <code>momentum()</code> Data Frames</h2><span id='topic+momentum_spatial'></span>

<h3>Description</h3>

<p>Given an sf data frame with geometry types POLYGON, MULTIPOLYGON, or POINT representing time series locations, this function transforms the output of <code><a href="#topic+momentum">momentum()</a></code>, <code><a href="#topic+momentum_ls">momentum_ls()</a></code>, <code><a href="#topic+momentum_dtw">momentum_dtw()</a></code> to an sf data frame.
</p>
<p>If <code>network = TRUE</code>, the sf data frame is of type LINESTRING, with edges connecting time series locations. This output is helpful to build many-to-many dissimilarity maps (see examples).
</p>
<p>If <code>network = FALSE</code>, the sf data frame contains the geometry in the input <code>sf</code> argument. This output helps build one-to-many dissimilarity maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentum_spatial(df = NULL, sf = NULL, network = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentum_spatial_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+momentum">momentum()</a></code>, <code><a href="#topic+momentum_ls">momentum_ls()</a></code>, or <code><a href="#topic+momentum_dtw">momentum_dtw()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_spatial_+3A_sf">sf</code></td>
<td>
<p>(required, sf data frame) Points or polygons representing the location of the time series in argument 'df'. It must have a column with all time series names in <code>df$x</code> and <code>df$y</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_spatial_+3A_network">network</code></td>
<td>
<p>(optional, logical) If TRUE, the resulting sf data frame is of time LINESTRING and represent network edges. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf data frame (LINESTRING geometry)
</p>


<h3>See Also</h3>

<p>Other momentum_support: 
<code><a href="#topic+momentum_aggregate">momentum_aggregate</a>()</code>,
<code><a href="#topic+momentum_boxplot">momentum_boxplot</a>()</code>,
<code><a href="#topic+momentum_model_frame">momentum_model_frame</a>()</code>,
<code><a href="#topic+momentum_stats">momentum_stats</a>()</code>,
<code><a href="#topic+momentum_to_wide">momentum_to_wide</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsl &lt;- distantia::tsl_initialize(
  x = distantia::eemian_pollen,
  name_column = "name",
  time_column = "time"
) |&gt;
#reduce size to speed-up example runtime
distantia::tsl_subset(
  names = 1:3
  )

df_momentum &lt;- distantia::momentum(
  tsl = tsl
)

#network many to many
sf_momentum &lt;- distantia::momentum_spatial(
  df = df_momentum,
  sf = distantia::eemian_coordinates,
  network = TRUE
)

#network map
# mapview::mapview(
#   sf_momentum,
#   layer.name = "Importance - Abies",
#   label = "edge_name",
#   zcol = "importance__Abies",
#   lwd = 3
# ) |&gt;
#   suppressWarnings()

</code></pre>

<hr>
<h2 id='momentum_stats'>Stats of Dissimilarity Data Frame</h2><span id='topic+momentum_stats'></span>

<h3>Description</h3>

<p>Takes the output of <code><a href="#topic+distantia">distantia()</a></code> to return a data frame with one row per time series with the stats of its dissimilarity scores with all other time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentum_stats(df = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentum_stats_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+momentum">momentum()</a></code>, <code><a href="#topic+momentum_ls">momentum_ls()</a></code>, or <code><a href="#topic+momentum_dtw">momentum_dtw()</a></code>. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other momentum_support: 
<code><a href="#topic+momentum_aggregate">momentum_aggregate</a>()</code>,
<code><a href="#topic+momentum_boxplot">momentum_boxplot</a>()</code>,
<code><a href="#topic+momentum_model_frame">momentum_model_frame</a>()</code>,
<code><a href="#topic+momentum_spatial">momentum_spatial</a>()</code>,
<code><a href="#topic+momentum_to_wide">momentum_to_wide</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsl &lt;- tsl_simulate(
  n = 5,
  irregular = FALSE
  )

df &lt;- distantia(
  tsl = tsl,
  lock_step = TRUE
  )

df_stats &lt;- distantia_stats(df = df)

df_stats

</code></pre>

<hr>
<h2 id='momentum_to_wide'>Momentum Data Frame to Wide Format</h2><span id='topic+momentum_to_wide'></span>

<h3>Description</h3>

<p>Transforms a data frame returned by <code><a href="#topic+momentum">momentum()</a></code> to wide format with the following columns:
</p>

<ul>
<li> <p><code>most_similar</code>: name of the variable with the highest contribution to similarity (most negative value in the <code>importance</code> column) for each pair of time series.
</p>
</li>
<li> <p><code>most_dissimilar</code>: name of the variable with the highest contribution to dissimilarity (most positive value in the <code>importance</code> column) for each pair of time series.
</p>
</li>
<li> <p><code>importance__variable_name</code>: contribution to similarity (negative values) or dissimilarity (positive values) of the given variable.
</p>
</li>
<li> <p><code>psi_only_with__variable_name</code>: dissimilarity of the two time series when only using the given variable.
</p>
</li>
<li> <p><code>psi_without__variable_name</code>: dissimilarity of the two time series when removing the given variable.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>momentum_to_wide(df = NULL, sep = "__")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentum_to_wide_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+momentum">momentum()</a></code>, <code><a href="#topic+momentum_ls">momentum_ls()</a></code>, or <code><a href="#topic+momentum_dtw">momentum_dtw()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="momentum_to_wide_+3A_sep">sep</code></td>
<td>
<p>(required, character string) Separator between the name of the importance metric and the time series variable. Default: &quot;__&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other momentum_support: 
<code><a href="#topic+momentum_aggregate">momentum_aggregate</a>()</code>,
<code><a href="#topic+momentum_boxplot">momentum_boxplot</a>()</code>,
<code><a href="#topic+momentum_model_frame">momentum_model_frame</a>()</code>,
<code><a href="#topic+momentum_spatial">momentum_spatial</a>()</code>,
<code><a href="#topic+momentum_stats">momentum_stats</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tsl &lt;- tsl_initialize(
  x = distantia::albatross,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_transform(
    f = f_scale_global
  )

#importance data frame
df &lt;- momentum(
  tsl = tsl
)

df

#to wide format
df_wide &lt;- momentum_to_wide(
  df = df
)

df_wide

</code></pre>

<hr>
<h2 id='permute_free_by_row_cpp'>(C++) Unrestricted Permutation of Complete Rows</h2><span id='topic+permute_free_by_row_cpp'></span>

<h3>Description</h3>

<p>Unrestricted shuffling of rows within the whole sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_free_by_row_cpp(x, block_size, seed = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permute_free_by_row_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix). Numeric matrix to permute.</p>
</td></tr>
<tr><td><code id="permute_free_by_row_cpp_+3A_block_size">block_size</code></td>
<td>
<p>(optional, integer) this function ignores this argument and sets it to x.nrow().</p>
</td></tr>
<tr><td><code id="permute_free_by_row_cpp_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) random seed to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>See Also</h3>

<p>Other Rcpp_permutation: 
<code><a href="#topic+permute_free_cpp">permute_free_cpp</a>()</code>,
<code><a href="#topic+permute_restricted_by_row_cpp">permute_restricted_by_row_cpp</a>()</code>,
<code><a href="#topic+permute_restricted_cpp">permute_restricted_cpp</a>()</code>
</p>

<hr>
<h2 id='permute_free_cpp'>(C++) Unrestricted Permutation of Cases</h2><span id='topic+permute_free_cpp'></span>

<h3>Description</h3>

<p>Unrestricted shuffling of cases within the whole sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_free_cpp(x, block_size, seed = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permute_free_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix). Numeric matrix to permute.</p>
</td></tr>
<tr><td><code id="permute_free_cpp_+3A_block_size">block_size</code></td>
<td>
<p>(optional, integer) this function ignores this argument and sets it to x.nrow().</p>
</td></tr>
<tr><td><code id="permute_free_cpp_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) random seed to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>See Also</h3>

<p>Other Rcpp_permutation: 
<code><a href="#topic+permute_free_by_row_cpp">permute_free_by_row_cpp</a>()</code>,
<code><a href="#topic+permute_restricted_by_row_cpp">permute_restricted_by_row_cpp</a>()</code>,
<code><a href="#topic+permute_restricted_cpp">permute_restricted_cpp</a>()</code>
</p>

<hr>
<h2 id='permute_restricted_by_row_cpp'>(C++) Restricted Permutation of Complete Rows Within Blocks</h2><span id='topic+permute_restricted_by_row_cpp'></span>

<h3>Description</h3>

<p>Divides a sequence in blocks of a given size and permutes rows
within these blocks.
Larger block sizes increasingly disrupt the data structure over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_restricted_by_row_cpp(x, block_size, seed = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permute_restricted_by_row_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix). Numeric matrix to permute.</p>
</td></tr>
<tr><td><code id="permute_restricted_by_row_cpp_+3A_block_size">block_size</code></td>
<td>
<p>(optional, integer) block size in number of rows.
Minimum value is 2, and maximum value is nrow(x).</p>
</td></tr>
<tr><td><code id="permute_restricted_by_row_cpp_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) random seed to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>See Also</h3>

<p>Other Rcpp_permutation: 
<code><a href="#topic+permute_free_by_row_cpp">permute_free_by_row_cpp</a>()</code>,
<code><a href="#topic+permute_free_cpp">permute_free_cpp</a>()</code>,
<code><a href="#topic+permute_restricted_cpp">permute_restricted_cpp</a>()</code>
</p>

<hr>
<h2 id='permute_restricted_cpp'>(C++) Restricted Permutation of Cases Within Blocks</h2><span id='topic+permute_restricted_cpp'></span>

<h3>Description</h3>

<p>Divides a sequence or time series in blocks and permutes cases
within these blocks. This function does not preserve rows, and should not be
used if the sequence has dependent columns.
Larger block sizes increasingly disrupt the data structure over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_restricted_cpp(x, block_size, seed = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permute_restricted_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix). Numeric matrix to permute.</p>
</td></tr>
<tr><td><code id="permute_restricted_cpp_+3A_block_size">block_size</code></td>
<td>
<p>(optional, integer) block size in number of rows.
Minimum value is 2, and maximum value is nrow(x).</p>
</td></tr>
<tr><td><code id="permute_restricted_cpp_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) random seed to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>See Also</h3>

<p>Other Rcpp_permutation: 
<code><a href="#topic+permute_free_by_row_cpp">permute_free_by_row_cpp</a>()</code>,
<code><a href="#topic+permute_free_cpp">permute_free_cpp</a>()</code>,
<code><a href="#topic+permute_restricted_by_row_cpp">permute_restricted_by_row_cpp</a>()</code>
</p>

<hr>
<h2 id='psi_auto_distance'>Cumulative Sum of Distances Between Consecutive Cases in a Time Series</h2><span id='topic+psi_auto_distance'></span>

<h3>Description</h3>

<p>Demonstration function to compute the sum of distances between consecutive cases in a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_auto_distance(x = NULL, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_auto_distance_+3A_x">x</code></td>
<td>
<p>(required, zoo object or matrix) univariate or multivariate time series with no NAs. Default: NULL</p>
</td></tr>
<tr><td><code id="psi_auto_distance_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>


<h3>See Also</h3>

<p>Other psi_demo: 
<code><a href="#topic+psi_auto_sum">psi_auto_sum</a>()</code>,
<code><a href="#topic+psi_cost_matrix">psi_cost_matrix</a>()</code>,
<code><a href="#topic+psi_cost_path">psi_cost_path</a>()</code>,
<code><a href="#topic+psi_cost_path_sum">psi_cost_path_sum</a>()</code>,
<code><a href="#topic+psi_distance_lock_step">psi_distance_lock_step</a>()</code>,
<code><a href="#topic+psi_distance_matrix">psi_distance_matrix</a>()</code>,
<code><a href="#topic+psi_equation">psi_equation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#distance metric
d &lt;- "euclidean"

#simulate zoo time series
x &lt;- zoo_simulate(
  name = "x",
  rows = 100,
  seasons = 2,
  seed = 1
)

#sum distance between consecutive samples
psi_auto_distance(
  x = x,
  distance = d
)
</code></pre>

<hr>
<h2 id='psi_auto_sum'>Auto Sum</h2><span id='topic+psi_auto_sum'></span>

<h3>Description</h3>

<p>Demonstration function to computes the sum of distances between consecutive samples in two time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_auto_sum(x = NULL, y = NULL, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_auto_sum_+3A_x">x</code></td>
<td>
<p>(required, zoo object or numeric matrix) univariate or multivariate time series with no NAs. Default: NULL.</p>
</td></tr>
<tr><td><code id="psi_auto_sum_+3A_y">y</code></td>
<td>
<p>(required, zoo object or numeric matrix) a time series with the same number of columns as <code>x</code> and no NAs. Default: NULL.</p>
</td></tr>
<tr><td><code id="psi_auto_sum_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p>Other psi_demo: 
<code><a href="#topic+psi_auto_distance">psi_auto_distance</a>()</code>,
<code><a href="#topic+psi_cost_matrix">psi_cost_matrix</a>()</code>,
<code><a href="#topic+psi_cost_path">psi_cost_path</a>()</code>,
<code><a href="#topic+psi_cost_path_sum">psi_cost_path_sum</a>()</code>,
<code><a href="#topic+psi_distance_lock_step">psi_distance_lock_step</a>()</code>,
<code><a href="#topic+psi_distance_matrix">psi_distance_matrix</a>()</code>,
<code><a href="#topic+psi_equation">psi_equation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#distance metric
d &lt;- "euclidean"

#simulate two irregular time series
x &lt;- zoo_simulate(
  name = "x",
  rows = 100,
  seasons = 2,
  seed = 1
)

y &lt;- zoo_simulate(
  name = "y",
  rows = 80,
  seasons = 2,
  seed = 2
)

if(interactive()){
  zoo_plot(x = x)
  zoo_plot(x = y)
}

#auto sum of distances
psi_auto_sum(
  x = x,
  y = y,
  distance = d
)

#same as:
x_sum &lt;- psi_auto_distance(
  x = x,
  distance = d
)

y_sum &lt;- psi_auto_distance(
  x = y,
  distance = d
)

x_sum + y_sum

</code></pre>

<hr>
<h2 id='psi_cost_matrix'>Cost Matrix</h2><span id='topic+psi_cost_matrix'></span>

<h3>Description</h3>

<p>Demonstration function to compute a cost matrix from a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_cost_matrix(dist_matrix = NULL, diagonal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_cost_matrix_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>(required, numeric matrix). Distance matrix generated by <code><a href="#topic+psi_distance_matrix">psi_distance_matrix()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="psi_cost_matrix_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical vector). If TRUE, diagonals are included in the dynamic time warping computation. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>See Also</h3>

<p>Other psi_demo: 
<code><a href="#topic+psi_auto_distance">psi_auto_distance</a>()</code>,
<code><a href="#topic+psi_auto_sum">psi_auto_sum</a>()</code>,
<code><a href="#topic+psi_cost_path">psi_cost_path</a>()</code>,
<code><a href="#topic+psi_cost_path_sum">psi_cost_path_sum</a>()</code>,
<code><a href="#topic+psi_distance_lock_step">psi_distance_lock_step</a>()</code>,
<code><a href="#topic+psi_distance_matrix">psi_distance_matrix</a>()</code>,
<code><a href="#topic+psi_equation">psi_equation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#distance metric
d &lt;- "euclidean"

#use diagonals in least cost computations
diagonal &lt;- TRUE

#simulate two irregular time series
x &lt;- zoo_simulate(
  name = "x",
  rows = 100,
  seasons = 2,
  seed = 1
)

y &lt;- zoo_simulate(
  name = "y",
  rows = 80,
  seasons = 2,
  seed = 2
)

if(interactive()){
  zoo_plot(x = x)
  zoo_plot(x = y)
}

#distance matrix
dist_matrix &lt;- psi_distance_matrix(
  x = x,
  y = y,
  distance = d
)

#cost matrix
cost_matrix &lt;- psi_cost_matrix(
  dist_matrix = dist_matrix,
  diagonal = diagonal
)

if(interactive()){
  utils_matrix_plot(
    m = cost_matrix
    )
}
</code></pre>

<hr>
<h2 id='psi_cost_path'>Least Cost Path</h2><span id='topic+psi_cost_path'></span>

<h3>Description</h3>

<p>Demonstration function to compute the least cost path within a least cost matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_cost_path(
  dist_matrix = NULL,
  cost_matrix = NULL,
  diagonal = TRUE,
  bandwidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_cost_path_+3A_dist_matrix">dist_matrix</code></td>
<td>
<p>(required, numeric matrix) Distance matrix generated by <code><a href="#topic+psi_distance_matrix">psi_distance_matrix()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="psi_cost_path_+3A_cost_matrix">cost_matrix</code></td>
<td>
<p>(required, numeric matrix) Cost matrix generated from the distance matrix with <code><a href="#topic+psi_cost_matrix">psi_cost_matrix()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="psi_cost_path_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical vector). If TRUE, diagonals are included in the dynamic time warping computation. Default: TRUE</p>
</td></tr>
<tr><td><code id="psi_cost_path_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(optional, numeric) Proportion of space at each side of the cost matrix diagonal (aka <em>Sakoe-Chiba band</em>) defining a valid region for dynamic time warping, used to control the flexibility of the warping path. This method prevents degenerate alignments due to differences in magnitude between time series when the data is not properly scaled. If <code>1</code> (default), DTW is unconstrained. If <code>0</code>, DTW is fully constrained and the warping path follows the matrix diagonal. Recommended values may vary depending on the nature of the data. Ignored if <code>lock_step = TRUE</code>. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other psi_demo: 
<code><a href="#topic+psi_auto_distance">psi_auto_distance</a>()</code>,
<code><a href="#topic+psi_auto_sum">psi_auto_sum</a>()</code>,
<code><a href="#topic+psi_cost_matrix">psi_cost_matrix</a>()</code>,
<code><a href="#topic+psi_cost_path_sum">psi_cost_path_sum</a>()</code>,
<code><a href="#topic+psi_distance_lock_step">psi_distance_lock_step</a>()</code>,
<code><a href="#topic+psi_distance_matrix">psi_distance_matrix</a>()</code>,
<code><a href="#topic+psi_equation">psi_equation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#distance metric
d &lt;- "euclidean"

#simulate two irregular time series
x &lt;- zoo_simulate(
  name = "x",
  rows = 100,
  seasons = 2,
  seed = 1
)

y &lt;- zoo_simulate(
  name = "y",
  rows = 80,
  seasons = 2,
  seed = 2
)

if(interactive()){
  zoo_plot(x = x)
  zoo_plot(x = y)
}

#distance matrix
dist_matrix &lt;- psi_distance_matrix(
  x = x,
  y = y,
  distance = d
)

#diagonal least cost path
#------------------------

cost_matrix &lt;- psi_cost_matrix(
  dist_matrix = dist_matrix,
  diagonal = TRUE
)

cost_path &lt;- psi_cost_path(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix,
  diagonal = TRUE
)

if(interactive()){
  utils_matrix_plot(
    m = cost_matrix,
    path = cost_path
    )
}


#orthogonal least cost path
#--------------------------
cost_matrix &lt;- psi_cost_matrix(
  dist_matrix = dist_matrix,
  diagonal = FALSE
)

cost_path &lt;- psi_cost_path(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix,
  diagonal = FALSE
)

if(interactive()){
  utils_matrix_plot(
    m = cost_matrix,
    path = cost_path
  )
}
</code></pre>

<hr>
<h2 id='psi_cost_path_sum'>Sum of Distances in Least Cost Path</h2><span id='topic+psi_cost_path_sum'></span>

<h3>Description</h3>

<p>Demonstration function to sum the distances of a least cost path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_cost_path_sum(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_cost_path_sum_+3A_path">path</code></td>
<td>
<p>(required, data frame) least cost path produced by <code><a href="#topic+psi_cost_path">psi_cost_path()</a></code>. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>


<h3>See Also</h3>

<p>Other psi_demo: 
<code><a href="#topic+psi_auto_distance">psi_auto_distance</a>()</code>,
<code><a href="#topic+psi_auto_sum">psi_auto_sum</a>()</code>,
<code><a href="#topic+psi_cost_matrix">psi_cost_matrix</a>()</code>,
<code><a href="#topic+psi_cost_path">psi_cost_path</a>()</code>,
<code><a href="#topic+psi_distance_lock_step">psi_distance_lock_step</a>()</code>,
<code><a href="#topic+psi_distance_matrix">psi_distance_matrix</a>()</code>,
<code><a href="#topic+psi_equation">psi_equation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#distance metric
d &lt;- "euclidean"

#simulate two irregular time series
x &lt;- zoo_simulate(
  name = "x",
  rows = 100,
  seasons = 2,
  seed = 1
)

y &lt;- zoo_simulate(
  name = "y",
  rows = 80,
  seasons = 2,
  seed = 2
)

if(interactive()){
  zoo_plot(x = x)
  zoo_plot(x = y)
}

#distance matrix
dist_matrix &lt;- psi_distance_matrix(
  x = x,
  y = y,
  distance = d
)

#orthogonal least cost matrix
cost_matrix &lt;- psi_cost_matrix(
  dist_matrix = dist_matrix
)

#orthogonal least cost path
cost_path &lt;- psi_cost_path(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix
)

#sum of distances in cost path
psi_cost_path_sum(
  path = cost_path
)
</code></pre>

<hr>
<h2 id='psi_distance_lock_step'>Lock-Step Distance</h2><span id='topic+psi_distance_lock_step'></span>

<h3>Description</h3>

<p>Demonstration function to compute the lock-step distance between two univariate or multivariate time series.
</p>
<p>This function does not accept NA data in the matrices <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_distance_lock_step(x = NULL, y = NULL, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_distance_lock_step_+3A_x">x</code></td>
<td>
<p>(required, zoo object or numeric matrix) a time series with no NAs. Default: NULL</p>
</td></tr>
<tr><td><code id="psi_distance_lock_step_+3A_y">y</code></td>
<td>
<p>(zoo object or numeric matrix) a time series with the same columns as <code>x</code> and no NAs. Default: NULL</p>
</td></tr>
<tr><td><code id="psi_distance_lock_step_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other psi_demo: 
<code><a href="#topic+psi_auto_distance">psi_auto_distance</a>()</code>,
<code><a href="#topic+psi_auto_sum">psi_auto_sum</a>()</code>,
<code><a href="#topic+psi_cost_matrix">psi_cost_matrix</a>()</code>,
<code><a href="#topic+psi_cost_path">psi_cost_path</a>()</code>,
<code><a href="#topic+psi_cost_path_sum">psi_cost_path_sum</a>()</code>,
<code><a href="#topic+psi_distance_matrix">psi_distance_matrix</a>()</code>,
<code><a href="#topic+psi_equation">psi_equation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#distance metric
d &lt;- "euclidean"

#simulate two time series
#of the same length
x &lt;- zoo_simulate(
  name = "x",
  rows = 100,
  seasons = 2,
  seed = 1
)

y &lt;- zoo_simulate(
  name = "y",
  rows = 100,
  seasons = 2,
  seed = 2
)

if(interactive()){
  zoo_plot(x = x)
  zoo_plot(x = y)
}

#sum of distances
#between pairs of samples
psi_distance_lock_step(
  x = x,
  y = y,
  distance = d
)
</code></pre>

<hr>
<h2 id='psi_distance_matrix'>Distance Matrix</h2><span id='topic+psi_distance_matrix'></span>

<h3>Description</h3>

<p>Demonstration function to compute the distance matrix between two univariate or multivariate time series.
</p>
<p>This function does not accept NA data in the matrices <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_distance_matrix(x = NULL, y = NULL, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_distance_matrix_+3A_x">x</code></td>
<td>
<p>(required, zoo object or numeric matrix) a time series with no NAs. Default: NULL</p>
</td></tr>
<tr><td><code id="psi_distance_matrix_+3A_y">y</code></td>
<td>
<p>(zoo object or numeric matrix) a time series with the same columns as <code>x</code> and no NAs. Default: NULL</p>
</td></tr>
<tr><td><code id="psi_distance_matrix_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>See Also</h3>

<p>Other psi_demo: 
<code><a href="#topic+psi_auto_distance">psi_auto_distance</a>()</code>,
<code><a href="#topic+psi_auto_sum">psi_auto_sum</a>()</code>,
<code><a href="#topic+psi_cost_matrix">psi_cost_matrix</a>()</code>,
<code><a href="#topic+psi_cost_path">psi_cost_path</a>()</code>,
<code><a href="#topic+psi_cost_path_sum">psi_cost_path_sum</a>()</code>,
<code><a href="#topic+psi_distance_lock_step">psi_distance_lock_step</a>()</code>,
<code><a href="#topic+psi_equation">psi_equation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#distance metric
d &lt;- "euclidean"

#simulate two irregular time series
x &lt;- zoo_simulate(
  name = "x",
  rows = 100,
  seasons = 2,
  seed = 1
)

y &lt;- zoo_simulate(
  name = "y",
  rows = 80,
  seasons = 2,
  seed = 2
)

if(interactive()){
  zoo_plot(x = x)
  zoo_plot(x = y)
}

#distance matrix
dist_matrix &lt;- psi_distance_matrix(
  x = x,
  y = y,
  distance = d
)

if(interactive()){
  utils_matrix_plot(
    m = dist_matrix
    )
}
</code></pre>

<hr>
<h2 id='psi_dtw_cpp'>(C++) Psi Dissimilarity Score of Two Time-Series</h2><span id='topic+psi_dtw_cpp'></span>

<h3>Description</h3>

<p>Computes the psi score of two time series <code>y</code> and <code>x</code>
with the same number of columns.
NA values should be removed before using this function.
If the selected distance function is &quot;chi&quot; or &quot;cosine&quot;, pairs of zeros should
be either removed or replaced with pseudo-zeros (i.e. 0.00001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_dtw_cpp(
  x,
  y,
  distance = "euclidean",
  diagonal = TRUE,
  weighted = TRUE,
  ignore_blocks = FALSE,
  bandwidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_dtw_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) of same number of columns as 'y'.</p>
</td></tr>
<tr><td><code id="psi_dtw_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) time series.</p>
</td></tr>
<tr><td><code id="psi_dtw_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="psi_dtw_cpp_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical). If TRUE, diagonals are included in the
computation of the cost matrix. Default: TRUE.</p>
</td></tr>
<tr><td><code id="psi_dtw_cpp_+3A_weighted">weighted</code></td>
<td>
<p>(optional, logical). Only relevant when diagonal is TRUE. When TRUE,
diagonal cost is weighted by y factor of 1.414214 (square root of 2). Default: TRUE.</p>
</td></tr>
<tr><td><code id="psi_dtw_cpp_+3A_ignore_blocks">ignore_blocks</code></td>
<td>
<p>(optional, logical). If TRUE, blocks of consecutive path
coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.</p>
</td></tr>
<tr><td><code id="psi_dtw_cpp_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(required, numeric) Size of the Sakoe-Chiba band at
both sides of the diagonal used to constrain the least cost path. Expressed
as a fraction of the number of matrix rows and columns. Unrestricted by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_dissimilarity_analysis: 
<code><a href="#topic+psi_equation_cpp">psi_equation_cpp</a>()</code>,
<code><a href="#topic+psi_ls_cpp">psi_ls_cpp</a>()</code>,
<code><a href="#topic+psi_null_dtw_cpp">psi_null_dtw_cpp</a>()</code>,
<code><a href="#topic+psi_null_ls_cpp">psi_null_ls_cpp</a>()</code>
</p>

<hr>
<h2 id='psi_equation'>Normalized Dissimilarity Score</h2><span id='topic+psi_equation'></span>

<h3>Description</h3>

<p>Demonstration function to computes the <code>psi</code> dissimilarity score (Birks and Gordon 1985). Psi is computed as <code class="reqn">\psi = (2a / b) - 1</code>, where <code class="reqn">a</code> is the sum of distances between the relevant samples of two time series, and <code class="reqn">b</code> is the cumulative sum of distances between consecutive samples in the two time series.
</p>
<p>If <code>a</code> is computed with dynamic time warping, and diagonals are used in the computation of the least cost path, then one is added to the result of the equation above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_equation(a = NULL, b = NULL, diagonal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_equation_+3A_a">a</code></td>
<td>
<p>(required, numeric) Result of <code><a href="#topic+psi_cost_path_sum">psi_cost_path_sum()</a></code>, the sum of distances of the least cost path between two time series. Default: NULL</p>
</td></tr>
<tr><td><code id="psi_equation_+3A_b">b</code></td>
<td>
<p>(required, numeric) Result of <code><a href="#topic+psi_auto_sum">psi_auto_sum()</a></code>, the cumulative sum of the consecutive cases of two time series. Default: NULL</p>
</td></tr>
<tr><td><code id="psi_equation_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical) Used to correct <code>psi</code> when diagonals are used during the computation of the least cost path. If the cost matrix and least cost path were computed using <code>diagonal = TRUE</code>, this argument should be <code>TRUE</code> as well. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>


<h3>See Also</h3>

<p>Other psi_demo: 
<code><a href="#topic+psi_auto_distance">psi_auto_distance</a>()</code>,
<code><a href="#topic+psi_auto_sum">psi_auto_sum</a>()</code>,
<code><a href="#topic+psi_cost_matrix">psi_cost_matrix</a>()</code>,
<code><a href="#topic+psi_cost_path">psi_cost_path</a>()</code>,
<code><a href="#topic+psi_cost_path_sum">psi_cost_path_sum</a>()</code>,
<code><a href="#topic+psi_distance_lock_step">psi_distance_lock_step</a>()</code>,
<code><a href="#topic+psi_distance_matrix">psi_distance_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#distance metric
d &lt;- "euclidean"

#use diagonals in least cost computations
diagonal &lt;- TRUE

#simulate two irregular time series
x &lt;- zoo_simulate(
  name = "x",
  rows = 100,
  seasons = 2,
  seed = 1
  )

y &lt;- zoo_simulate(
  name = "y",
  rows = 80,
  seasons = 2,
  seed = 2
  )

if(interactive()){
  zoo_plot(x = x)
  zoo_plot(x = y)
}

#dynamic time warping

#distance matrix
dist_matrix &lt;- psi_distance_matrix(
  x = x,
  y = y,
  distance = d
)

#cost matrix
cost_matrix &lt;- psi_cost_matrix(
  dist_matrix = dist_matrix,
  diagonal = diagonal
)

#least cost path
cost_path &lt;- psi_cost_path(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix,
  diagonal = diagonal
)

if(interactive()){
  utils_matrix_plot(
    m = cost_matrix,
    path = cost_path
    )
}


#computation of psi score

#sum of distances in least cost path
a &lt;- psi_cost_path_sum(
  path = cost_path
  )

#auto sum of both time series
b &lt;- psi_auto_sum(
  x = x,
  y = y,
  distance = d
)

#dissimilarity score
psi_equation(
  a = a,
  b = b,
  diagonal = diagonal
)

#full computation with distantia()
tsl &lt;- list(
  x = x,
  y = y
)

distantia(
  tsl = tsl,
  distance = d,
  diagonal = diagonal
)$psi

if(interactive()){
  distantia_dtw_plot(
    tsl = tsl,
    distance = d,
    diagonal = diagonal
  )
}
</code></pre>

<hr>
<h2 id='psi_equation_cpp'>(C++) Equation of the Psi Dissimilarity Score</h2><span id='topic+psi_equation_cpp'></span>

<h3>Description</h3>

<p>Equation to compute the <code>psi</code> dissimilarity score
(Birks and Gordon 1985). Psi is computed as <code class="reqn">\psi = (2a / b) - 1</code>,
where <code class="reqn">a</code> is the sum of distances between the relevant samples of two
time series, and <code class="reqn">b</code> is the cumulative sum of distances between
consecutive samples in the two time series.
If <code>a</code> is computed with dynamic time warping, and diagonals are used in the
computation of the least cost path, then one is added to the result of the equation above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_equation_cpp(a, b, diagonal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_equation_cpp_+3A_a">a</code></td>
<td>
<p>(required, numeric) output of <code><a href="#topic+cost_path_sum_cpp">cost_path_sum_cpp()</a></code> on a least cost path.</p>
</td></tr>
<tr><td><code id="psi_equation_cpp_+3A_b">b</code></td>
<td>
<p>(required, numeric) auto sum of both sequences,
result of <code><a href="#topic+auto_sum_cpp">auto_sum_cpp()</a></code>.</p>
</td></tr>
<tr><td><code id="psi_equation_cpp_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical). Must be TRUE when diagonals are used in
dynamic time warping and for lock-step distances. Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_dissimilarity_analysis: 
<code><a href="#topic+psi_dtw_cpp">psi_dtw_cpp</a>()</code>,
<code><a href="#topic+psi_ls_cpp">psi_ls_cpp</a>()</code>,
<code><a href="#topic+psi_null_dtw_cpp">psi_null_dtw_cpp</a>()</code>,
<code><a href="#topic+psi_null_ls_cpp">psi_null_ls_cpp</a>()</code>
</p>

<hr>
<h2 id='psi_ls_cpp'>(C++) Psi Dissimilarity Score of Two Aligned Time Series</h2><span id='topic+psi_ls_cpp'></span>

<h3>Description</h3>

<p>Computes the psi dissimilarity score between two time series
observed at the same times. Time series <code>y</code> and <code>x</code> with the same
number of columns and rows. NA values should be removed before using this function.
If the selected distance function is &quot;chi&quot; or &quot;cosine&quot;, pairs of zeros should
be either removed or replaced with pseudo-zeros (i.e. 0.00001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_ls_cpp(x, y, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_ls_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) of same number of columns as 'y'.</p>
</td></tr>
<tr><td><code id="psi_ls_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) of same number of columns as 'x'.</p>
</td></tr>
<tr><td><code id="psi_ls_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>See Also</h3>

<p>Other Rcpp_dissimilarity_analysis: 
<code><a href="#topic+psi_dtw_cpp">psi_dtw_cpp</a>()</code>,
<code><a href="#topic+psi_equation_cpp">psi_equation_cpp</a>()</code>,
<code><a href="#topic+psi_null_dtw_cpp">psi_null_dtw_cpp</a>()</code>,
<code><a href="#topic+psi_null_ls_cpp">psi_null_ls_cpp</a>()</code>
</p>

<hr>
<h2 id='psi_null_dtw_cpp'>(C++) Null Distribution of Dissimilarity Scores of Two Time Series</h2><span id='topic+psi_null_dtw_cpp'></span>

<h3>Description</h3>

<p>Applies permutation methods to compute null distributions for
the psi scores of two time series.
NA values should be removed before using this function.
If the selected distance function is &quot;chi&quot; or &quot;cosine&quot;, pairs of zeros should
be either removed or replaced with pseudo-zeros (i.e. 0.00001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_null_dtw_cpp(
  x,
  y,
  distance = "euclidean",
  diagonal = TRUE,
  weighted = TRUE,
  ignore_blocks = FALSE,
  bandwidth = 1,
  repetitions = 100L,
  permutation = "restricted_by_row",
  block_size = 3L,
  seed = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_null_dtw_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) of same number of columns as 'y'.</p>
</td></tr>
<tr><td><code id="psi_null_dtw_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix).</p>
</td></tr>
<tr><td><code id="psi_null_dtw_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="psi_null_dtw_cpp_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical). If TRUE, diagonals are included in the
computation of the cost matrix. Default: FALSE.</p>
</td></tr>
<tr><td><code id="psi_null_dtw_cpp_+3A_weighted">weighted</code></td>
<td>
<p>(optional, logical). If TRUE, diagonal is set to TRUE, and
diagonal cost is weighted by a factor of 1.414214 (square root of 2). Default: FALSE.</p>
</td></tr>
<tr><td><code id="psi_null_dtw_cpp_+3A_ignore_blocks">ignore_blocks</code></td>
<td>
<p>(optional, logical). If TRUE, blocks of consecutive path
coordinates are trimmed to avoid inflating the psi distance. This argument
has nothing to do with block_size!. Default: FALSE.</p>
</td></tr>
<tr><td><code id="psi_null_dtw_cpp_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(required, numeric) Size of the Sakoe-Chiba band at
both sides of the diagonal used to constrain the least cost path. Expressed
as a fraction of the number of matrix rows and columns. Unrestricted by default.
Default: 1</p>
</td></tr>
<tr><td><code id="psi_null_dtw_cpp_+3A_repetitions">repetitions</code></td>
<td>
<p>(optional, integer) number of null psi values to generate. Default: 100</p>
</td></tr>
<tr><td><code id="psi_null_dtw_cpp_+3A_permutation">permutation</code></td>
<td>
<p>(optional, character) permutation method. Valid values are listed below from higher to lower randomness:
</p>

<ul>
<li><p> &quot;free&quot;: unrestricted shuffling of rows and columns. Ignores block_size.
</p>
</li>
<li><p> &quot;free_by_row&quot;: unrestricted shuffling of complete rows. Ignores block size.
</p>
</li>
<li><p> &quot;restricted&quot;: restricted shuffling of rows and columns within blocks.
</p>
</li>
<li><p> &quot;restricted_by_row&quot;: restricted shuffling of rows within blocks.
</p>
</li></ul>
</td></tr>
<tr><td><code id="psi_null_dtw_cpp_+3A_block_size">block_size</code></td>
<td>
<p>(optional, integer) block size in rows for
restricted permutation. A block size of 3 indicates that a row can only be permuted
within a block of 3 adjacent rows. Minimum value is 2. Default: 3.</p>
</td></tr>
<tr><td><code id="psi_null_dtw_cpp_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) initial random seed to use for replicability. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p>Other Rcpp_dissimilarity_analysis: 
<code><a href="#topic+psi_dtw_cpp">psi_dtw_cpp</a>()</code>,
<code><a href="#topic+psi_equation_cpp">psi_equation_cpp</a>()</code>,
<code><a href="#topic+psi_ls_cpp">psi_ls_cpp</a>()</code>,
<code><a href="#topic+psi_null_ls_cpp">psi_null_ls_cpp</a>()</code>
</p>

<hr>
<h2 id='psi_null_ls_cpp'>(C++) Null Distribution of the Dissimilarity Scores of Two Aligned Time Series</h2><span id='topic+psi_null_ls_cpp'></span>

<h3>Description</h3>

<p>Applies permutation methods to compute null distributions for
the psi scores of two time series observed at the same times.
NA values should be removed before using this function.
If the selected distance function is &quot;chi&quot; or &quot;cosine&quot;, pairs of zeros should
be either removed or replaced with pseudo-zeros (i.e. 0.00001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_null_ls_cpp(
  x,
  y,
  distance = "euclidean",
  repetitions = 100L,
  permutation = "restricted_by_row",
  block_size = 3L,
  seed = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psi_null_ls_cpp_+3A_x">x</code></td>
<td>
<p>(required, numeric matrix) of same number of columns as 'y'.</p>
</td></tr>
<tr><td><code id="psi_null_ls_cpp_+3A_y">y</code></td>
<td>
<p>(required, numeric matrix) of same number of columns as 'x'.</p>
</td></tr>
<tr><td><code id="psi_null_ls_cpp_+3A_distance">distance</code></td>
<td>
<p>(optional, character string) distance name from the &quot;names&quot;
column of the dataset <code>distances</code> (see <code>distances$name</code>). Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="psi_null_ls_cpp_+3A_repetitions">repetitions</code></td>
<td>
<p>(optional, integer) number of null psi values to generate. Default: 100</p>
</td></tr>
<tr><td><code id="psi_null_ls_cpp_+3A_permutation">permutation</code></td>
<td>
<p>(optional, character) permutation method. Valid values are listed below from higher to lower randomness:
</p>

<ul>
<li><p> &quot;free&quot;: unrestricted shuffling of rows and columns. Ignores block_size.
</p>
</li>
<li><p> &quot;free_by_row&quot;: unrestricted shuffling of complete rows. Ignores block size.
</p>
</li>
<li><p> &quot;restricted&quot;: restricted shuffling of rows and columns within blocks.
</p>
</li>
<li><p> &quot;restricted_by_row&quot;: restricted shuffling of rows within blocks.
</p>
</li></ul>
</td></tr>
<tr><td><code id="psi_null_ls_cpp_+3A_block_size">block_size</code></td>
<td>
<p>(optional, integer) block size in rows for
restricted permutation. A block size of 3 indicates that a row can only be permuted
within a block of 3 adjacent rows. Minimum value is 2. Default: 3.</p>
</td></tr>
<tr><td><code id="psi_null_ls_cpp_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) initial random seed to use for replicability. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p>Other Rcpp_dissimilarity_analysis: 
<code><a href="#topic+psi_dtw_cpp">psi_dtw_cpp</a>()</code>,
<code><a href="#topic+psi_equation_cpp">psi_equation_cpp</a>()</code>,
<code><a href="#topic+psi_ls_cpp">psi_ls_cpp</a>()</code>,
<code><a href="#topic+psi_null_dtw_cpp">psi_null_dtw_cpp</a>()</code>
</p>

<hr>
<h2 id='subset_matrix_by_rows_cpp'>(C++) Subset Matrix by Rows</h2><span id='topic+subset_matrix_by_rows_cpp'></span>

<h3>Description</h3>

<p>Subsets a time series matrix to the coordinates of a trimmed
least-cost path when blocks are ignored during a dissimilarity analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_matrix_by_rows_cpp(m, rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_matrix_by_rows_cpp_+3A_m">m</code></td>
<td>
<p>(required, numeric matrix) a univariate or multivariate time series.</p>
</td></tr>
<tr><td><code id="subset_matrix_by_rows_cpp_+3A_rows">rows</code></td>
<td>
<p>(required, integer vector) vector of rows to subset from a
least-cost path data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>See Also</h3>

<p>Other Rcpp_auto_sum: 
<code><a href="#topic+auto_distance_cpp">auto_distance_cpp</a>()</code>,
<code><a href="#topic+auto_sum_cpp">auto_sum_cpp</a>()</code>,
<code><a href="#topic+auto_sum_full_cpp">auto_sum_full_cpp</a>()</code>,
<code><a href="#topic+auto_sum_path_cpp">auto_sum_path_cpp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate a time series
m &lt;- zoo_simulate(seed = 1)

#sample some rows
rows &lt;- sample(
  x = nrow(m),
  size = 10
  ) |&gt;
  sort()

#subset by rows
m_subset &lt;- subset_matrix_by_rows_cpp(
  m = m,
  rows = rows
  )

#compare with original
m[rows, ]

</code></pre>

<hr>
<h2 id='tsl_aggregate'>Aggregate Time Series List Over Time Periods</h2><span id='topic+tsl_aggregate'></span>

<h3>Description</h3>

<p>Time series aggregation involves grouping observations and summarizing group values with a statistical function. This operation is useful to:
</p>

<ul>
<li><p> Decrease (downsampling) the temporal resolution of a time series.
</p>
</li>
<li><p> Highlight particular states of a time series over time. For example, a daily temperature series can be aggregated by month using <code>max</code> to represent the highest temperatures each month.
</p>
</li>
<li><p> Transform irregular time series into regular.
</p>
</li></ul>

<p>This function aggregates time series lists <strong>with overlapping times</strong>. Please check such overlap by assessing the columns &quot;begin&quot; and &quot;end &quot; of the data frame resulting from <code>df &lt;- tsl_time(tsl = tsl)</code>. Aggregation will be limited by the shortest time series in your time series list. To aggregate non-overlapping time series, please subset the individual components of <code>tsl</code> one by one either using <code><a href="#topic+tsl_subset">tsl_subset()</a></code> or the syntax <code>tsl = my_tsl[[i]]</code>.
</p>
<p><strong>Methods</strong>
</p>
<p>Any function returning a single number from a numeric vector can be used to aggregate a time series list. Quoted and unquoted function names can be used. Additional arguments to these functions can be passed via the argument <code>...</code>. Typical examples are:
</p>

<ul>
<li> <p><code>mean</code> or <code>"mean"</code>: see <code><a href="base.html#topic+mean">mean()</a></code>.
</p>
</li>
<li> <p><code>median</code> or <code>"median"</code>: see <code><a href="stats.html#topic+median">stats::median()</a></code>.
</p>
</li>
<li> <p><code>quantile</code> or &quot;quantile&quot;: see <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>.
</p>
</li>
<li> <p><code>min</code> or <code>"min"</code>: see <code><a href="base.html#topic+min">min()</a></code>.
</p>
</li>
<li> <p><code>max</code> or <code>"max"</code>: see <code><a href="base.html#topic+max">max()</a></code>.
</p>
</li>
<li> <p><code>sd</code> or <code>"sd"</code>: to compute standard deviation, see <code><a href="stats.html#topic+sd">stats::sd()</a></code>.
</p>
</li>
<li> <p><code>var</code> or <code>"var"</code>: to compute the group variance, see <code><a href="stats.html#topic+cor">stats::var()</a></code>.
</p>
</li>
<li> <p><code>length</code> or <code>"length"</code>: to compute group length.
</p>
</li>
<li> <p><code>sum</code> or <code>"sum"</code>: see <code><a href="base.html#topic+sum">sum()</a></code>.
</p>
</li></ul>

<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_aggregate(tsl = NULL, new_time = NULL, f = mean, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_aggregate_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_aggregate_+3A_new_time">new_time</code></td>
<td>
<p>(required, numeric, numeric vector, Date vector, POSIXct vector, or keyword) Definition of the aggregation pattern. The available options are:
</p>

<ul>
<li><p> numeric vector: only for the &quot;numeric&quot; time class, defines the breakpoints for time series aggregation.
</p>
</li>
<li><p> &quot;Date&quot; or &quot;POSIXct&quot; vector: as above, but for the time classes &quot;Date&quot; and &quot;POSIXct.&quot; In any case, the input vector is coerced to the time class of the <code>tsl</code> argument.
</p>
</li>
<li><p> numeric: defines fixed time intervals in the units of <code>tsl</code> for time series aggregation. Used as is when the time class is &quot;numeric&quot;, and coerced to integer and interpreted as days for the time classes &quot;Date&quot; and &quot;POSIXct&quot;.
</p>
</li>
<li><p> keyword (see <code><a href="#topic+utils_time_units">utils_time_units()</a></code>): the common options for the time classes &quot;Date&quot; and &quot;POSIXct&quot; are: &quot;millennia&quot;, &quot;centuries&quot;, &quot;decades&quot;, &quot;years&quot;, &quot;quarters&quot;, &quot;months&quot;, and &quot;weeks&quot;. Exclusive keywords for the &quot;POSIXct&quot; time class are: &quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot;, and &quot;seconds&quot;. The time class &quot;numeric&quot; accepts keywords coded as scientific numbers, from &quot;1e8&quot; to &quot;1e-8&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tsl_aggregate_+3A_f">f</code></td>
<td>
<p>(required, function name) Name of function taking a vector as input and returning a single value as output. Typical examples are <code>mean</code>, <code>max</code>,<code>min</code>, <code>median</code>, and <code>quantile</code>. Default: <code>mean</code>.</p>
</td></tr>
<tr><td><code id="tsl_aggregate_+3A_...">...</code></td>
<td>
<p>(optional) further arguments for <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zoo_aggregate">zoo_aggregate()</a></code>
</p>
<p>Other tsl_processing: 
<code><a href="#topic+tsl_resample">tsl_resample</a>()</code>,
<code><a href="#topic+tsl_smooth">tsl_smooth</a>()</code>,
<code><a href="#topic+tsl_stats">tsl_stats</a>()</code>,
<code><a href="#topic+tsl_transform">tsl_transform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# yearly aggregation
#----------------------------------
#long-term monthly temperature of 20 cities
tsl &lt;- tsl_initialize(
  x = cities_temperature,
  name_column = "name",
  time_column = "time"
)

#plot time series
if(interactive()){
  tsl_plot(
    tsl = tsl[1:4],
    guide_columns = 4
  )
}

#check time features
tsl_time(tsl)[, c("name", "resolution", "units")]

#aggregation: mean yearly values
tsl_year &lt;- tsl_aggregate(
  tsl = tsl,
  new_time = "year",
  f = mean
)

#' #check time features
tsl_time(tsl_year)[, c("name", "resolution", "units")]

if(interactive()){
  tsl_plot(
    tsl = tsl_year[1:4],
    guide_columns = 4
  )
}


# other supported keywords
#----------------------------------

#simulate full range of calendar dates
tsl &lt;- tsl_simulate(
  n = 2,
  rows = 1000,
  time_range = c(
    "0000-01-01",
    as.character(Sys.Date())
  )
)

#mean value by millennia (extreme case!!!)
tsl_millennia &lt;- tsl_aggregate(
  tsl = tsl,
  new_time = "millennia",
  f = mean
)

if(interactive()){
  tsl_plot(tsl_millennia)
}

#max value by centuries
tsl_century &lt;- tsl_aggregate(
  tsl = tsl,
  new_time = "century",
  f = max
)

if(interactive()){
  tsl_plot(tsl_century)
}

#quantile 0.75 value by centuries
tsl_centuries &lt;- tsl_aggregate(
  tsl = tsl,
  new_time = "centuries",
  f = stats::quantile,
  probs = 0.75 #argument of stats::quantile()
)

</code></pre>

<hr>
<h2 id='tsl_burst'>Multivariate TSL to Univariate TSL</h2><span id='topic+tsl_burst'></span>

<h3>Description</h3>

<p>Takes a time series list with multivariate zoo objects to generate a new one with one univariate zoo objects per variable. A time series list with the the zoo objects &quot;A&quot; and &quot;B&quot;, each with the columns &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;, becomes a time series list with the zoo objects &quot;A__a&quot;, &quot;A__b&quot;, &quot;A__c&quot;, &quot;B__a&quot;, &quot;B__b&quot;, and &quot;B__c&quot;. The only column of each new zoo object is named &quot;x&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_burst(tsl = NULL, sep = "__")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_burst_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_burst_+3A_sep">sep</code></td>
<td>
<p>(required, character string) separator between the time series name and the column name. Default: &quot;__&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list: list of univariate zoo objects with a column named &quot;x&quot;.
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tsl &lt;- tsl_simulate(
  n = 2,
  time_range = c(
    "2010-01-01",
    "2024-12-31"
  ),
  cols = 3
)

tsl_names_get(tsl)
tsl_colnames_get(tsl)

if(interactive()){
  tsl_plot(tsl)
}

tsl &lt;- tsl_burst(tsl)

tsl_names_get(tsl)
tsl_colnames_get(tsl)

if(interactive()){
  tsl_plot(tsl)
}
</code></pre>

<hr>
<h2 id='tsl_colnames_clean'>Clean Column Names in Time Series Lists</h2><span id='topic+tsl_colnames_clean'></span>

<h3>Description</h3>

<p>Uses the function <code><a href="#topic+utils_clean_names">utils_clean_names()</a></code> to simplify and normalize messy column names in a time series list.
</p>
<p>The cleanup operations are applied in the following order:
</p>

<ul>
<li><p> Remove leading and trailing whitespaces.
</p>
</li>
<li><p> Generates syntactically valid names with <code><a href="base.html#topic+make.names">base::make.names()</a></code>.
</p>
</li>
<li><p> Replaces dots and spaces with the <code>separator</code>.
</p>
</li>
<li><p> Coerces names to lowercase.
</p>
</li>
<li><p> If <code>capitalize_first = TRUE</code>, the first letter is capitalized.
</p>
</li>
<li><p> If <code>capitalize_all = TRUE</code>, all letters are capitalized.
</p>
</li>
<li><p> If argument <code>length</code> is provided, <code><a href="base.html#topic+abbreviate">base::abbreviate()</a></code> is used to abbreviate the new column names.
</p>
</li>
<li><p> If <code>suffix</code> is provided, it is added at the end of the column name using the separator.
</p>
</li>
<li><p> If <code>prefix</code> is provided, it is added at the beginning of the column name using the separator.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tsl_colnames_clean(
  tsl = NULL,
  lowercase = FALSE,
  separator = "_",
  capitalize_first = FALSE,
  capitalize_all = FALSE,
  length = NULL,
  suffix = NULL,
  prefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_colnames_clean_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_colnames_clean_+3A_lowercase">lowercase</code></td>
<td>
<p>(optional, logical) If TRUE, all names are coerced to lowercase. Default: FALSE</p>
</td></tr>
<tr><td><code id="tsl_colnames_clean_+3A_separator">separator</code></td>
<td>
<p>(optional, character string) Separator when replacing spaces and dots. Also used to separate <code>suffix</code> and <code>prefix</code> from the main word. Default: &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="tsl_colnames_clean_+3A_capitalize_first">capitalize_first</code></td>
<td>
<p>(optional, logical) Indicates whether to capitalize the first letter of each name Default: FALSE.</p>
</td></tr>
<tr><td><code id="tsl_colnames_clean_+3A_capitalize_all">capitalize_all</code></td>
<td>
<p>(optional, logical) Indicates whether to capitalize all letters of each name Default: FALSE.</p>
</td></tr>
<tr><td><code id="tsl_colnames_clean_+3A_length">length</code></td>
<td>
<p>(optional, integer) Minimum length of abbreviated names. Names are abbreviated via <code><a href="base.html#topic+abbreviate">abbreviate()</a></code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="tsl_colnames_clean_+3A_suffix">suffix</code></td>
<td>
<p>(optional, character string) String to append to the column names. Default: NULL.</p>
</td></tr>
<tr><td><code id="tsl_colnames_clean_+3A_prefix">prefix</code></td>
<td>
<p>(optional, character string)  String to prepend to the column names. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate example data
tsl &lt;- tsl_simulate(cols = 3)

#list all column names
tsl_colnames_get(
  tsl = tsl
)

#rename columns
tsl &lt;- tsl_colnames_set(
  tsl = tsl,
  names = c(
  "New name 1",
  "new Name 2",
  "NEW NAME 3"
  )
)

#check new names
tsl_colnames_get(
  tsl = tsl,
  names = "all"
)

#clean names
tsl &lt;- tsl_colnames_clean(
  tsl = tsl
)

tsl_colnames_get(
  tsl = tsl
)

#abbreviated
tsl &lt;- tsl_colnames_clean(
  tsl = tsl,
  capitalize_first = TRUE,
  length = 6,
  suffix = "clean"
)

tsl_colnames_get(
  tsl = tsl
)
</code></pre>

<hr>
<h2 id='tsl_colnames_get'>Get Column Names from a Time Series Lists</h2><span id='topic+tsl_colnames_get'></span>

<h3>Description</h3>

<p>Get Column Names from a Time Series Lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_colnames_get(tsl = NULL, names = c("all", "shared", "exclusive"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_colnames_get_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_colnames_get_+3A_names">names</code></td>
<td>
<p>(optional, character string) Three different sets of column names can be requested:
</p>

<ul>
<li><p> &quot;all&quot; (default): list with the column names in each zoo object in <code>tsl</code>. Unnamed columns are tagged with the string &quot;unnamed&quot;.
</p>
</li>
<li><p> &quot;shared&quot;: character vector with the shared column names in at least two zoo objects in <code>tsl</code>.
</p>
</li>
<li><p> &quot;exclusive&quot;: list with names of exclusive columns (if any) in each zoo object in <code>tsl</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate example data
tsl &lt;- tsl_simulate()

#list all column names
tsl_colnames_get(
  tsl = tsl,
  names = "all"
)

#change one column name
names(tsl[[1]])[1] &lt;- "new_column"

#all names again
tsl_colnames_get(
  tsl = tsl,
  names = "all"
)

#shared column names
tsl_colnames_get(
  tsl = tsl,
  names = "shared"
)

#exclusive column names
tsl_colnames_get(
  tsl = tsl,
  names = "exclusive"
)
</code></pre>

<hr>
<h2 id='tsl_colnames_prefix'>Append Prefix to Column Names of Time Series List</h2><span id='topic+tsl_colnames_prefix'></span>

<h3>Description</h3>

<p>Append Prefix to Column Names of Time Series List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_colnames_prefix(tsl = NULL, prefix = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_colnames_prefix_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_colnames_prefix_+3A_prefix">prefix</code></td>
<td>
<p>(optional, character string)  String to prepend to the column names. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsl &lt;- tsl_simulate()

tsl_colnames_get(tsl = tsl)

tsl &lt;- tsl_colnames_prefix(
  tsl = tsl,
  prefix = "my_prefix_"
)

tsl_colnames_get(tsl = tsl)
</code></pre>

<hr>
<h2 id='tsl_colnames_set'>Set Column Names in Time Series Lists</h2><span id='topic+tsl_colnames_set'></span>

<h3>Description</h3>

<p>Set Column Names in Time Series Lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_colnames_set(tsl = NULL, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_colnames_set_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_colnames_set_+3A_names">names</code></td>
<td>
<p>(required, list or character vector):
</p>

<ul>
<li><p> list: with same names as 'tsl', containing a vector of new column names for each time series in 'tsl'.
</p>
</li>
<li><p> character vector: vector of new column names assigned by position.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsl &lt;- tsl_simulate(
  cols = 3
  )

tsl_colnames_get(
  tsl = tsl
  )

#using a vector
#extra names are ignored
tsl &lt;- tsl_colnames_set(
  tsl = tsl,
  names = c("x", "y", "z", "zz")
)

tsl_colnames_get(
  tsl = tsl
)

#using a list
#extra names are ignored too
tsl &lt;- tsl_colnames_set(
  tsl = tsl,
  names = list(
    A = c("A", "B", "C"),
    B = c("X", "Y", "Z", "ZZ")
  )
)

tsl_colnames_get(
  tsl = tsl
)
</code></pre>

<hr>
<h2 id='tsl_colnames_suffix'>Append Suffix to Column Names of Time Series List</h2><span id='topic+tsl_colnames_suffix'></span>

<h3>Description</h3>

<p>Append Suffix to Column Names of Time Series List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_colnames_suffix(tsl = NULL, suffix = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_colnames_suffix_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_colnames_suffix_+3A_suffix">suffix</code></td>
<td>
<p>(optional, character string) String to append to the column names. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsl &lt;- tsl_simulate()

tsl_colnames_get(tsl = tsl)

tsl &lt;- tsl_colnames_suffix(
  tsl = tsl,
  suffix = "_my_suffix"
)

tsl_colnames_get(tsl = tsl)
</code></pre>

<hr>
<h2 id='tsl_count_NA'>Count NA Cases in Time Series Lists</h2><span id='topic+tsl_count_NA'></span>

<h3>Description</h3>

<p>Converts Inf, -Inf, and NaN to NA (via <code><a href="#topic+tsl_Inf_to_NA">tsl_Inf_to_NA()</a></code> and <code><a href="#topic+tsl_NaN_to_NA">tsl_NaN_to_NA()</a></code>), and counts the total number of NA cases in each time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_count_NA(tsl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_count_NA_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#tsl with no NA cases
tsl &lt;- tsl_simulate()

tsl_count_NA(tsl = tsl)

#tsl with NA cases
tsl &lt;- tsl_simulate(
  na_fraction = 0.3
)

tsl_count_NA(tsl = tsl)

#tsl with variety of empty cases
tsl &lt;- tsl_simulate()
tsl[[1]][1, 1] &lt;- Inf
tsl[[1]][2, 1] &lt;- -Inf
tsl[[1]][3, 1] &lt;- NaN
tsl[[1]][4, 1] &lt;- NaN

tsl_count_NA(tsl = tsl)

</code></pre>

<hr>
<h2 id='tsl_diagnose'>Diagnose Issues in Time Series Lists</h2><span id='topic+tsl_diagnose'></span>

<h3>Description</h3>

<p>A Time Series List (<code>tsl</code> for short) is a named list of zoo time series. This type of object, not defined as a class, is used throughout the <code>distantia</code> package to contain time series data ready for processing and analysis.
</p>
<p>The structure and values of a <code>tsl</code> must fulfill several general conditions:
</p>
<p>Structure:
</p>

<ul>
<li><p> List names match the attributes &quot;name&quot; of the zoo time series.
</p>
</li>
<li><p> Zoo time series must have at least one shared column name.
</p>
</li>
<li><p> The index (as extracted by <code><a href="zoo.html#topic+index">zoo::index()</a></code>) of all zoo objects must be of the same class (either &quot;Date&quot;, &quot;POSIXct&quot;, &quot;numeric&quot;, or &quot;integer&quot;).
</p>
</li>
<li><p> The &quot;core data&quot; (as extracted by <code><a href="zoo.html#topic+coredata">zoo::coredata()</a></code>) of univariate zoo time series must be of class &quot;matrix&quot;.
</p>
</li></ul>

<p>Values (optional, when <code>full = TRUE</code>):
</p>

<ul>
<li><p> All time series have at least one shared numeric column.
</p>
</li>
<li><p> There are no NA, Inf, or NaN values in the time series.
</p>
</li></ul>

<p>This function analyzes a <code>tsl</code> without modifying it to returns messages describing what conditions are not met, and provides hints on how to fix most issues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_diagnose(tsl = NULL, full = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_diagnose_+3A_tsl">tsl</code></td>
<td>
<p>(required, list of zoo time series) Time series list to diagnose. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_diagnose_+3A_full">full</code></td>
<td>
<p>(optional, logical) If TRUE, a full diagnostic is triggered. Otherwise, only the data structure is tested. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating three zoo time series

#one with NA values
x &lt;- zoo_simulate(
  name = "x",
  cols = 1,
  na_fraction = 0.1
  )

#with different number of columns
#wit repeated name
y &lt;- zoo_simulate(
  name = "x",
  cols = 2
  )

#with different time class
z &lt;- zoo_simulate(
  name = "z",
  cols = 1,
  time_range = c(1, 100)
  )

#adding a few structural issues

#changing the column name of x
colnames(x) &lt;- c("b")

#converting z to vector
z &lt;- zoo::zoo(
  x = runif(nrow(z)),
  order.by = zoo::index(z)
)

#storing zoo objects in a list
#with mismatched names
tsl &lt;- list(
  a = x,
  b = y,
  c = z
)

#running full diagnose
tsl_diagnose(
  tsl = tsl,
  full = TRUE
  )
</code></pre>

<hr>
<h2 id='tsl_handle_NA'>Handle NA Cases in Time Series Lists</h2><span id='topic+tsl_handle_NA'></span><span id='topic+tsl_Inf_to_NA'></span><span id='topic+tsl_NaN_to_NA'></span>

<h3>Description</h3>

<p>Removes or imputes NA cases in time series lists. Imputation is done via interpolation against time via <code><a href="zoo.html#topic+na.approx">zoo::na.approx()</a></code>, and if there are still leading or trailing NA cases after NA interpolation, then <code><a href="zoo.html#topic+na.approx">zoo::na.spline()</a></code> is applied as well to fill these gaps. Interpolated values are forced to fall within the observed data range.
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_handle_NA(tsl = NULL, na_action = c("impute", "omit"))

tsl_Inf_to_NA(tsl = NULL)

tsl_NaN_to_NA(tsl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_handle_NA_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_handle_NA_+3A_na_action">na_action</code></td>
<td>
<p>(required, character) NA handling action. Available options are:
</p>

<ul>
<li><p> &quot;impute&quot; (default): NA cases are interpolated from neighbors as a function of time (see <code><a href="zoo.html#topic+na.approx">zoo::na.approx()</a></code> and <code><a href="zoo.html#topic+na.approx">zoo::na.spline()</a></code>).
</p>
</li>
<li><p> &quot;omit&quot;: rows with NA cases are removed.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#tsl with NA cases
tsl &lt;- tsl_simulate(
  na_fraction = 0.25
)

tsl_count_NA(tsl = tsl)

if(interactive()){
  #issues warning
  tsl_plot(tsl = tsl)
}

#omit NA (default)
#--------------------------------------

#original row count
tsl_nrow(tsl = tsl)

#remove rows with NA
tsl_no_na &lt;- tsl_handle_NA(
  tsl = tsl,
  na_action = "omit"
)

#count rows again
#large data loss in this case!
tsl_nrow(tsl = tsl_no_na)

#count NA again
tsl_count_NA(tsl = tsl_no_na)

if(interactive()){
  tsl_plot(tsl = tsl_no_na)
}


#impute NA with zoo::na.approx
#--------------------------------------

#impute NA cases
tsl_no_na &lt;- tsl_handle_NA(
  tsl = tsl,
  na_action = "impute"
)

#count rows again
#large data loss in this case!
tsl_nrow(tsl = tsl_no_na)

if(interactive()){
  tsl_plot(tsl = tsl_no_na)
}
</code></pre>

<hr>
<h2 id='tsl_initialize'>Transform Raw Time Series Data to Time Series List</h2><span id='topic+tsl_initialize'></span><span id='topic+tsl_init'></span>

<h3>Description</h3>

<p>Most functions in this package take a <strong>time series list</strong> (or <strong>tsl</strong> for short) as main input. A <code>tsl</code> is a list of zoo time series objects (see <code><a href="zoo.html#topic+zoo">zoo::zoo()</a></code>). There is not a formal class for <code>tsl</code> objects, but there are requirements these objects must follow to ensure the stability of the package functionalities (see <code><a href="#topic+tsl_diagnose">tsl_diagnose()</a></code>). These requirements are:
</p>

<ul>
<li><p> There are no NA, Inf, -Inf, or NaN cases in the zoo objects (see <code><a href="#topic+tsl_count_NA">tsl_count_NA()</a></code> and <code><a href="#topic+tsl_handle_NA">tsl_handle_NA()</a></code>).
</p>
</li>
<li><p> All zoo objects must have at least one common column name to allow time series comparison (see <code><a href="#topic+tsl_colnames_get">tsl_colnames_get()</a></code>).
</p>
</li>
<li><p> All zoo objects have a character attribute &quot;name&quot; identifying the object. This attribute is not part of the zoo class, but the package ensures that this attribute is not lost during data manipulations.
</p>
</li>
<li><p> Each element of the time series list is named after the zoo object it contains (see <code><a href="#topic+tsl_names_get">tsl_names_get()</a></code>, <code><a href="#topic+tsl_names_set">tsl_names_set()</a></code> and <code><a href="#topic+tsl_names_clean">tsl_names_clean()</a></code>).
</p>
</li>
<li><p> The time series list contains two zoo objects or more.
</p>
</li></ul>

<p>The function <code><a href="#topic+tsl_initialize">tsl_initialize()</a></code> (and its alias <code><a href="#topic+tsl_init">tsl_init()</a></code>) is designed to convert the following data structures to a time series list:
</p>

<ul>
<li><p> Long data frame: with an ID column to separate time series, and a time column that can be of the classes &quot;Date&quot;, &quot;POSIXct&quot;, &quot;integer&quot;, or &quot;numeric&quot;. The resulting zoo objects and list elements are named after the values in the ID column.
</p>
</li>
<li><p> Wide data frame: each column is a time series representing the same variable observed at the same time in different places. Each column is converted to a separate zoo object and renamed.
</p>
</li>
<li><p> List of vectors: an object like <code>list(a = runif(10), b = runif(10))</code> is converted to a time series list with as many zoo objects as vectors are defined in the original list.
</p>
</li>
<li><p> List of matrices: a list containing matrices, such as <code>list(a = matrix(runif(30), 10, 3), b = matrix(runif(36), 12, 3))</code>.
</p>
</li>
<li><p> List of zoo objects: a list with zoo objects, such as <code>list(a = zoo_simulate(), b = zoo_simulate())</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tsl_initialize(
  x = NULL,
  name_column = NULL,
  time_column = NULL,
  lock_step = FALSE
)

tsl_init(x = NULL, name_column = NULL, time_column = NULL, lock_step = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_initialize_+3A_x">x</code></td>
<td>
<p>(required, list or data frame) Matrix or data frame in long format, list of vectors, list of matrices, or list of zoo objects. Default: NULL.</p>
</td></tr>
<tr><td><code id="tsl_initialize_+3A_name_column">name_column</code></td>
<td>
<p>(optional, column name) Column naming individual time series. Numeric names are converted to character with the prefix &quot;X&quot;. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_initialize_+3A_time_column">time_column</code></td>
<td>
<p>(optional if <code>lock_step = FALSE</code>, and required otherwise, character string) Name of the column representing time, if any. Default: NULL.</p>
</td></tr>
<tr><td><code id="tsl_initialize_+3A_lock_step">lock_step</code></td>
<td>
<p>(optional, logical) If TRUE, all input sequences are subsetted to their common times according to the values in <code>time_column</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#long data frame
#---------------------
data("fagus_dynamics")

#name_column is name
#time column is time
str(fagus_dynamics)

#to tsl
#each group in name_column is a different time series
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
)

#check validity (no messages or errors if valid)
tsl_diagnose(tsl)

#class of contained objects
lapply(X = tsl, FUN = class)

#get list and zoo names (between double quotes)
tsl_names_get(
  tsl = tsl,
  zoo = TRUE
  )

#plot tsl
if(interactive()){
  tsl_plot(tsl)
}

#list of zoo objects
#--------------------
x &lt;- zoo_simulate()
y &lt;- zoo_simulate()

tsl &lt;- tsl_initialize(
  x = list(
    x = x,
    y = y
  )
)

#plot
if(interactive()){
  tsl_plot(tsl)
}


#wide data frame
#--------------------
#wide data frame
#each column is same variable in different places
df &lt;- stats::reshape(
  data = fagus_dynamics[, c(
    "name",
    "time",
    "evi"
  )],
  timevar = "name",
  idvar = "time",
  direction = "wide",
  sep = "_"
)

str(df)

#to tsl
#key assumptions:
#all columns but "time" represent
#the same variable in different places
#all time series are of the same length
tsl &lt;- tsl_initialize(
  x = df,
  time_column = "time"
  )

#colnames are forced to be the same...
tsl_colnames_get(tsl)

#...but can be changed
tsl &lt;- tsl_colnames_set(
  tsl = tsl,
  names = "evi"
)
tsl_colnames_get(tsl)

#plot
if(interactive()){
  tsl_plot(tsl)
}


#list of vectors
#---------------------
#create list of vectors
vector_list &lt;- list(
  a = cumsum(stats::rnorm(n = 50)),
  b = cumsum(stats::rnorm(n = 70)),
  c = cumsum(stats::rnorm(n = 20))
)

#to tsl
#key assumptions:
#all vectors represent the same variable
#in different places
#time series can be of different lengths
#no time column, integer indices are used as time
tsl &lt;- tsl_initialize(
  x = vector_list
)

#plot
if(interactive()){
  tsl_plot(tsl)
}

#list of matrices
#-------------------------
#create list of matrices
matrix_list &lt;- list(
  a = matrix(runif(30), nrow = 10, ncol = 3),
  b = matrix(runif(80), nrow = 20, ncol = 4)
)

#to tsl
#key assumptions:
#each matrix represents a multivariate time series
#in a different place
#all multivariate time series have the same columns
#no time column, integer indices are used as time
tsl &lt;- tsl_initialize(
  x = matrix_list
)

#check column names
tsl_colnames_get(tsl = tsl)

#remove exclusive column
tsl &lt;- tsl_subset(
  tsl = tsl,
  shared_cols = TRUE
  )
tsl_colnames_get(tsl = tsl)

#plot
if(interactive()){
  tsl_plot(tsl)
}

#list of zoo objects
#-------------------------
zoo_list &lt;- list(
  a = zoo_simulate(),
  b = zoo_simulate()
)

#looks like a time series list! But...
tsl_diagnose(tsl = zoo_list)

#let's set the names
zoo_list &lt;- tsl_names_set(tsl = zoo_list)

#check again: it's now a valid time series list
tsl_diagnose(tsl = zoo_list)

#to do all this in one go:
tsl &lt;- tsl_initialize(
  x = list(
    a = zoo_simulate(),
    b = zoo_simulate()
  )
)

#plot
if(interactive()){
  tsl_plot(tsl)
}

</code></pre>

<hr>
<h2 id='tsl_join'>Join Time Series Lists</h2><span id='topic+tsl_join'></span>

<h3>Description</h3>

<p>Joins an arbitrary of time series lists by name and time. Pairs of zoo objects are joined with <code><a href="zoo.html#topic+merge.zoo">zoo::merge.zoo()</a></code>. Names that are not shared across all input TSLs are ignored, and observations with no matching time are filled with NA and then managed via <code><a href="#topic+tsl_handle_NA">tsl_handle_NA()</a></code> depending on the value of the argument <code>na_action</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_join(..., na_action = "impute")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_join_+3A_...">...</code></td>
<td>
<p>(required, time series lists) names of the time series lists to merge.</p>
</td></tr>
<tr><td><code id="tsl_join_+3A_na_action">na_action</code></td>
<td>
<p>(required, character) NA handling action. Available options are:
</p>

<ul>
<li><p> &quot;impute&quot; (default): NA cases are interpolated from neighbors as a function of time (see <code><a href="zoo.html#topic+na.approx">zoo::na.approx()</a></code> and <code><a href="zoo.html#topic+na.approx">zoo::na.spline()</a></code>).
</p>
</li>
<li><p> &quot;omit&quot;: rows with NA cases are removed.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate two time series list to join
tsl_a &lt;- tsl_simulate(
  n = 2,
  cols = 2,
  irregular = TRUE,
  seed = 1
)

#needs renaming
tsl_b &lt;- tsl_simulate(
  n = 3,
  cols = 2,
  irregular = TRUE,
  seed = 2
) |&gt;
  tsl_colnames_set(
    names = c("c", "d")
  )

#join
tsl &lt;- tsl_join(
  tsl_a,
  tsl_b
)

#plot result
if(interactive()){
  tsl_plot(
    tsl = tsl
  )
}

</code></pre>

<hr>
<h2 id='tsl_names_clean'>Clean Time Series Names in a Time Series List</h2><span id='topic+tsl_names_clean'></span>

<h3>Description</h3>

<p>Combines <code><a href="#topic+utils_clean_names">utils_clean_names()</a></code> and <code><a href="#topic+tsl_names_set">tsl_names_set()</a></code> to help clean, abbreviate, capitalize, and add a suffix or a prefix to time series list names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_names_clean(
  tsl = NULL,
  lowercase = FALSE,
  separator = "_",
  capitalize_first = FALSE,
  capitalize_all = FALSE,
  length = NULL,
  suffix = NULL,
  prefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_names_clean_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_names_clean_+3A_lowercase">lowercase</code></td>
<td>
<p>(optional, logical) If TRUE, all names are coerced to lowercase. Default: FALSE</p>
</td></tr>
<tr><td><code id="tsl_names_clean_+3A_separator">separator</code></td>
<td>
<p>(optional, character string) Separator when replacing spaces and dots. Also used to separate <code>suffix</code> and <code>prefix</code> from the main word. Default: &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="tsl_names_clean_+3A_capitalize_first">capitalize_first</code></td>
<td>
<p>(optional, logical) Indicates whether to capitalize the first letter of each name Default: FALSE.</p>
</td></tr>
<tr><td><code id="tsl_names_clean_+3A_capitalize_all">capitalize_all</code></td>
<td>
<p>(optional, logical) Indicates whether to capitalize all letters of each name Default: FALSE.</p>
</td></tr>
<tr><td><code id="tsl_names_clean_+3A_length">length</code></td>
<td>
<p>(optional, integer) Minimum length of abbreviated names. Names are abbreviated via <code><a href="base.html#topic+abbreviate">abbreviate()</a></code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="tsl_names_clean_+3A_suffix">suffix</code></td>
<td>
<p>(optional, character string) Suffix for the clean names. Default: NULL.</p>
</td></tr>
<tr><td><code id="tsl_names_clean_+3A_prefix">prefix</code></td>
<td>
<p>(optional, character string)  Prefix for the clean names. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#initialize time series list
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
)

#original names
tsl_names_get(
  tsl = tsl
)

#abbreviate names
#---------------------------
tsl_clean &lt;- tsl_names_clean(
  tsl = tsl,
  capitalize_first = TRUE,
  length = 4 #abbreviate to 4 characters
)

#new names
tsl_names_get(
  tsl = tsl_clean
)

#suffix and prefix
#---------------------------
tsl_clean &lt;- tsl_names_clean(
  tsl = tsl,
  capitalize_all = TRUE,
  separator = "_",
  suffix = "fagus",
  prefix = "country"
)

#new names
tsl_names_get(
  tsl = tsl_clean
)
</code></pre>

<hr>
<h2 id='tsl_names_get'>Get Time Series Names from a Time Series Lists</h2><span id='topic+tsl_names_get'></span>

<h3>Description</h3>

<p>A time series list has two sets of names: the names of the list items (as returned by <code>names(tsl)</code>), and the names of the contained zoo objects, as stored in their attribute &quot;name&quot;. These names should ideally be the same, for the sake of data consistency. This function extracts either set of names,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_names_get(tsl = NULL, zoo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_names_get_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_names_get_+3A_zoo">zoo</code></td>
<td>
<p>(optional, logical) If TRUE, the attributes &quot;name&quot; of the zoo objects are returned. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#initialize a time series list
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
)


#get names of zoo objects
tsl_names_get(
  tsl = tsl,
  zoo = TRUE
)

#get list names only
tsl_names_get(
  tsl = tsl,
  zoo = FALSE
  )

#same as
names(tsl)
</code></pre>

<hr>
<h2 id='tsl_names_set'>Set Time Series Names in a Time Series List</h2><span id='topic+tsl_names_set'></span>

<h3>Description</h3>

<p>Sets the names of a time series list and the internal names of the zoo objects inside, stored in their attribute &quot;name&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_names_set(tsl = NULL, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_names_set_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_names_set_+3A_names">names</code></td>
<td>
<p>(optional, character vector) names to set. Must be of the same length of <code>x</code>. If NULL, and the list <code>x</code> has names, then the names of the zoo objects inside of the list are taken from the names of the list elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate time series list
tsl &lt;- tsl_simulate(n = 3)

#assess validity
tsl_diagnose(
  tsl = tsl
)

#list and zoo names (default)
tsl_names_get(
  tsl = tsl
)

#list names
tsl_names_get(
  tsl = tsl,
  zoo = FALSE
)

#renaming list items and zoo objects
#------------------------------------
tsl &lt;- tsl_names_set(
  tsl = tsl,
  names = c("X", "Y", "Z")
)

# check new names
tsl_names_get(
  tsl = tsl
)

#fixing naming issues
#------------------------------------

#creating a invalid time series list
names(tsl)[2] &lt;- "B"

# check names
tsl_names_get(
  tsl = tsl
)

#validate tsl
#returns NOT VALID
#recommends a solution
tsl_diagnose(
  tsl = tsl
)

#fix issue with tsl_names_set()
#uses names of zoo objects for the list items
tsl &lt;- tsl_names_set(
  tsl = tsl
)

#validate again
tsl_diagnose(
  tsl = tsl
)

#list names
tsl_names_get(
  tsl = tsl
)
</code></pre>

<hr>
<h2 id='tsl_names_test'>Tests Naming Issues in Time Series Lists</h2><span id='topic+tsl_names_test'></span>

<h3>Description</h3>

<p>Tests Naming Issues in Time Series Lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_names_test(tsl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_names_test_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating three zoo time series

#one with NA values
x &lt;- zoo_simulate(
  name = "x",
  cols = 1,
  na_fraction = 0.1
  )

#with different number of columns
#wit repeated name
y &lt;- zoo_simulate(
  name = "x",
  cols = 2
  )

#with different time class
z &lt;- zoo_simulate(
  name = "z",
  cols = 1,
  time_range = c(1, 100)
  )

#adding a few structural issues

#changing the column name of x
colnames(x) &lt;- c("b")

#converting z to vector
z &lt;- zoo::zoo(
  x = runif(nrow(z)),
  order.by = zoo::index(z)
)

#storing zoo objects in a list
#with mismatched names
tsl &lt;- list(
  a = x,
  b = y,
  c = z
)

#running full diagnose
tsl_names_test(
  tsl = tsl
  )
</code></pre>

<hr>
<h2 id='tsl_ncol'>Get Number of Columns in Time Series Lists</h2><span id='topic+tsl_ncol'></span>

<h3>Description</h3>

<p>Get Number of Columns in Time Series Lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_ncol(tsl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_ncol_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#initialize time series list
tsl &lt;- tsl_simulate(
  n = 2,
  cols = 6
)

#number of columns per zoo object
tsl_ncol(tsl = tsl)
</code></pre>

<hr>
<h2 id='tsl_nrow'>Get Number of Rows in Time Series Lists</h2><span id='topic+tsl_nrow'></span>

<h3>Description</h3>

<p>Get Number of Rows in Time Series Lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_nrow(tsl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_nrow_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate zoo time series
tsl &lt;- tsl_simulate(
  rows = 150
  )

#count rows
tsl_nrow(
  tsl = tsl
)
</code></pre>

<hr>
<h2 id='tsl_plot'>Plot Time Series List</h2><span id='topic+tsl_plot'></span>

<h3>Description</h3>

<p>Plot Time Series List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_plot(
  tsl = NULL,
  columns = 1,
  xlim = NULL,
  ylim = "absolute",
  line_color = NULL,
  line_width = 1,
  text_cex = 1,
  guide = TRUE,
  guide_columns = 1,
  guide_cex = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_plot_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_plot_+3A_columns">columns</code></td>
<td>
<p>(optional, integer) Number of columns of the multipanel plot. Default: 1</p>
</td></tr>
<tr><td><code id="tsl_plot_+3A_xlim">xlim</code></td>
<td>
<p>(optional, numeric vector) Numeric vector with the limits of the x axis. Applies to all sequences. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_plot_+3A_ylim">ylim</code></td>
<td>
<p>(optional, numeric vector or character string) Numeric vector of length two with the limits of the vertical axis or a keyword. Accepted keywords are:
</p>

<ul>
<li><p> &quot;absolute&quot; (default): all time series are plotted using the overall data range. When this option is used, horizontal lines indicating the overall mean, minimum, and maximum are shown as reference.
</p>
</li>
<li><p> &quot;relative&quot;: each time series is plotted using its own range. Equivalent result can be achieved using <code>ylim = NULL</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tsl_plot_+3A_line_color">line_color</code></td>
<td>
<p>(optional, character vector) vector of colors for the distance or cost matrix. If NULL, uses an appropriate palette generated with <code><a href="grDevices.html#topic+palette">grDevices::palette.colors()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_plot_+3A_line_width">line_width</code></td>
<td>
<p>(optional, numeric vector) Width of the time series plot. Default: 1</p>
</td></tr>
<tr><td><code id="tsl_plot_+3A_text_cex">text_cex</code></td>
<td>
<p>(optional, numeric) Multiplicator of the text size. Default: 1</p>
</td></tr>
<tr><td><code id="tsl_plot_+3A_guide">guide</code></td>
<td>
<p>(optional, logical) If TRUE, plots a legend. Default: TRUE</p>
</td></tr>
<tr><td><code id="tsl_plot_+3A_guide_columns">guide_columns</code></td>
<td>
<p>(optional, integer) Columns of the line guide. Default: 1.</p>
</td></tr>
<tr><td><code id="tsl_plot_+3A_guide_cex">guide_cex</code></td>
<td>
<p>(optional, numeric) Size of the guide's text and separation between the guide's rows. Default: 0.7.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate zoo time series
tsl &lt;- tsl_simulate(
  cols = 3
  )

if(interactive()){

  #default plot
  tsl_plot(
    tsl = tsl
    )

  #relative vertical limits
  tsl_plot(
    tsl = tsl,
    ylim = "relative"
  )

  #changing layout
  tsl_plot(
    tsl = tsl,
    columns = 2,
    guide_columns = 2
  )

  #no legend
  tsl_plot(
    tsl = tsl,
    guide = FALSE
  )

  #changing color
  tsl_plot(
    tsl = tsl,
    line_color = c("red", "green", "blue"))

}
</code></pre>

<hr>
<h2 id='tsl_repair'>Repair Issues in Time Series Lists</h2><span id='topic+tsl_repair'></span>

<h3>Description</h3>

<p>A Time Series List (<code>tsl</code> for short) is a list of zoo time series. This type of object, not defined as a class, is used throughout the <code>distantia</code> package to contain time series data ready for processing and analysis.
</p>
<p>The structure and values of a <code>tsl</code> must fulfill several general conditions:
</p>
<p>Structure:
</p>

<ul>
<li><p> The list names match the attributes &quot;name&quot; of the zoo time series
</p>
</li>
<li><p> All zoo time series must have at least one shared column name.
</p>
</li>
<li><p> Data in univariate zoo time series (as extracted by <code>zoo::coredata(x)</code>) must be of the class &quot;matrix&quot;. Univariate zoo time series are often represented as vectors, but this breaks several subsetting and transformation operations implemented in this package.
</p>
</li></ul>

<p>Values (optional, when <code>full = TRUE</code>):
</p>

<ul>
<li><p> All time series have at least one shared numeric column.
</p>
</li>
<li><p> There are no NA, Inf, or NaN values in the time series.
</p>
</li></ul>

<p>This function analyzes a <code>tsl</code>, and tries to fix all possible issues to make it comply with the conditions listed above without any user input. Use with care, as it might defile your data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_repair(tsl = NULL, full = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_repair_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_repair_+3A_full">full</code></td>
<td>
<p>(optional, logical) If TRUE, a full repair (structure and values) is triggered. Otherwise, only the data structure is repaired Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating three zoo time series

#one with NA values
x &lt;- zoo_simulate(
  name = "x",
  cols = 1,
  na_fraction = 0.1
  )

#with different number of columns
#wit repeated name
y &lt;- zoo_simulate(
  name = "x",
  cols = 2
  )

#with different time class
z &lt;- zoo_simulate(
  name = "z",
  cols = 1,
  time_range = c(1, 100)
  )

#adding a few structural issues

#changing the column name of x
colnames(x) &lt;- c("b")

#converting z to vector
z &lt;- zoo::zoo(
  x = runif(nrow(z)),
  order.by = zoo::index(z)
)

#storing zoo objects in a list
#with mismatched names
tsl &lt;- list(
  a = x,
  b = y,
  c = z
)

#running full diagnose
tsl_diagnose(
  tsl = tsl,
  full = TRUE
  )

tsl &lt;- tsl_repair(tsl)
</code></pre>

<hr>
<h2 id='tsl_resample'>Resample Time Series Lists to a New Time</h2><span id='topic+tsl_resample'></span>

<h3>Description</h3>

<p><strong>Objective</strong>
</p>
<p>Time series resampling interpolates new values for time steps not available in the original time series. This operation is useful to:
</p>

<ul>
<li><p> Transform irregular time series into regular.
</p>
</li>
<li><p> Align time series with different temporal resolutions.
</p>
</li>
<li><p> Increase (upsampling) or decrease (downsampling) the temporal resolution of a time series.
</p>
</li></ul>

<p>Time series resampling <strong>should not be used</strong> to extrapolate new values outside of the original time range of the time series, or to increase the resolution of a time series by a factor of two or more. These operations are known to produce non-sensical results.
</p>
<p><strong>Warning</strong>: This function resamples time series lists <strong>with overlapping times</strong>. Please check such overlap by assessing the columns &quot;begin&quot; and &quot;end &quot; of the data frame resulting from <code>df &lt;- tsl_time(tsl = tsl)</code>. Resampling will be limited by the shortest time series in your time series list. To resample non-overlapping time series, please subset the individual components of <code>tsl</code> one by one either using <code><a href="#topic+tsl_subset">tsl_subset()</a></code> or the syntax <code>tsl = my_tsl[[i]]</code>.
</p>
<p><strong>Methods</strong>
</p>
<p>This function offers three methods for time series interpolation:
</p>

<ul>
<li><p> &quot;linear&quot; (default): interpolation via piecewise linear regression as implemented in <code><a href="zoo.html#topic+na.approx">zoo::na.approx()</a></code>.
</p>
</li>
<li><p> &quot;spline&quot;: cubic smoothing spline regression as implemented in <code><a href="stats.html#topic+smooth.spline">stats::smooth.spline()</a></code>.
</p>
</li>
<li><p> &quot;loess&quot;: local polynomial regression fitting as implemented in <code><a href="stats.html#topic+loess">stats::loess()</a></code>.
</p>
</li></ul>

<p>These methods are used to fit models <code>y ~ x</code> where <code>y</code> represents the values of a univariate time series and <code>x</code> represents a numeric version of its time.
</p>
<p>The functions <code><a href="#topic+utils_optimize_spline">utils_optimize_spline()</a></code> and <code><a href="#topic+utils_optimize_loess">utils_optimize_loess()</a></code> are used under the hood to optimize the complexity of the methods &quot;spline&quot; and &quot;loess&quot; by finding the configuration that minimizes the root mean squared error (RMSE) between  observed and predicted <code>y</code>. However, when the argument <code>max_complexity = TRUE</code>, the complexity optimization is ignored, and a maximum complexity model is used instead.
</p>
<p><strong>New time</strong>
</p>
<p>The argument <code>new_time</code> offers several alternatives to help define the new time of the resulting time series:
</p>

<ul>
<li> <p><code>NULL</code>: the target time series (<code>x</code>) is resampled to a regular time within its original time range and number of observations.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;zoo object&#8288;</code>: a zoo object to be used as template for resampling. Useful when the objective is equalizing the frequency of two separate zoo objects.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;time series list&#8288;</code>: a time series list to be used as template. The range of overlapping dates and the average resolution are used to generate the new resampling time. This method cannot be used to align two time series lists, unless the template is resampled beforehand.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;time vector&#8288;</code>: a time vector of a class compatible with the time in <code>x</code>.
</p>
</li>
<li> <p><code>keyword</code>: character string defining a resampling keyword, obtained via <code>zoo_time(x, keywords = "resample")$keywords</code>..
</p>
</li>
<li> <p><code>numeric</code>: a single number representing the desired interval between consecutive samples in the units of <code>x</code> (relevant units can be obtained via <code>zoo_time(x)$units</code>).
</p>
</li></ul>

<p><strong>Step by Step</strong>
</p>
<p>The steps to resample a time series list are:
</p>

<ol>
<li><p> The time interpolation range is computed from the intersection of all times in <code>tsl</code>. This step ensures that no extrapolation occurs during resampling, but it also makes resampling of non-overlapping time series impossible.
</p>
</li>
<li><p> If <code>new_time</code> is provided, any values of <code>new_time</code> outside of the minimum and maximum interpolation times are removed to avoid extrapolation. If <code>new_time</code> is not provided, a regular time within the interpolation time range with the length of the shortest time series in <code>tsl</code> is generated.
</p>
</li>
<li><p> For each univariate time time series, a model <code>y ~ x</code>, where <code>y</code> is the time series and <code>x</code> is its own time coerced to numeric is fitted.
</p>

<ul>
<li><p> If <code>max_complexity == FALSE</code>, the model with the complexity that minimizes the root mean squared error between the observed and predicted <code>y</code> is returned.
</p>
</li>
<li><p> If <code>max_complexity == TRUE</code> and <code>method = "spline"</code> or <code>method = "loess"</code>, the first valid model closest to a maximum complexity is returned.
</p>
</li></ul>

</li>
<li><p> The fitted model is predicted over <code>new_time</code> to generate the resampled time series.
</p>
</li></ol>

<p><strong>Other Details</strong>
</p>
<p>Please use this operation with care, as there are limits to the amount of resampling that can be done without distorting the data. The safest option is to keep the distance between new time points within the same magnitude of the distance between the old time points.
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_resample(
  tsl = NULL,
  new_time = NULL,
  method = "linear",
  max_complexity = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_resample_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_resample_+3A_new_time">new_time</code></td>
<td>
<p>(required, zoo object, time series list, character string, time vector, numeric) New time to resample to. If a time vector is provided, it must be of a class compatible with the time of <code>tsl</code>.  If a zoo object or time series list is provided, its time is used as a template to resample <code>tsl</code>. Valid resampling keywords (see <code><a href="#topic+tsl_time">tsl_time()</a></code>) are allowed. Numeric values are interpreted as interval widths in the time units of the time series. If NULL, irregular time series are predicted into a regular version of their own time. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_resample_+3A_method">method</code></td>
<td>
<p>(optional, character string) Name of the method to resample the time series. One of &quot;linear&quot;, &quot;spline&quot; or &quot;loess&quot;. Default: &quot;linear&quot;.</p>
</td></tr>
<tr><td><code id="tsl_resample_+3A_max_complexity">max_complexity</code></td>
<td>
<p>(required, logical). Only relevant for methods &quot;spline&quot; and &quot;loess&quot;. If TRUE, model optimization is ignored, and the a model of maximum complexity (an overfitted model) is used for resampling. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zoo_resample">zoo_resample()</a></code>
</p>
<p>Other tsl_processing: 
<code><a href="#topic+tsl_aggregate">tsl_aggregate</a>()</code>,
<code><a href="#topic+tsl_smooth">tsl_smooth</a>()</code>,
<code><a href="#topic+tsl_stats">tsl_stats</a>()</code>,
<code><a href="#topic+tsl_transform">tsl_transform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate irregular time series
tsl &lt;- tsl_simulate(
  n = 2,
  rows = 100,
  irregular = TRUE
)

if(interactive()){
  tsl_plot(tsl)
}


#range of times between samples
tsl_time_summary(tsl)[
  c(
    "units",
    "resolution_min",
    "resolution_max"
    )
  ]

#resample to regular using linear interpolation
tsl_regular &lt;- tsl_resample(
  tsl = tsl
)

if(interactive()){
  tsl_plot(tsl_regular)
}

#check new resolution
tsl_time_summary(tsl_regular)[
  c(
    "units",
    "resolution_min",
    "resolution_max"
  )
]

#resample using keywords

#valid resampling keywords
tsl_time_summary(
  tsl = tsl,
  keywords = "resample"
)$keywords

#by month
tsl_months &lt;- tsl_resample(
  tsl = tsl,
  new_time = "months"
)

if(interactive()){
  tsl_plot(tsl_months)
}

#by week
tsl_weeks &lt;- tsl_resample(
  tsl = tsl,
  new_time = "weeks"
)

if(interactive()){
  tsl_plot(tsl_weeks)
}

#resample using time interval

#get relevant units
tsl_time(tsl)$units

#resampling to 15 days intervals
tsl_15_days &lt;- tsl_resample(
  tsl = tsl,
  new_time = 15 #days
)

tsl_time_summary(tsl_15_days)[
  c(
    "units",
    "resolution_min",
    "resolution_max"
  )
]

if(interactive()){
  tsl_plot(tsl_15_days)
}

#aligning two time series listsÃ§

#two time series lists with different time ranges
tsl1 &lt;- tsl_simulate(
  n = 2,
  rows = 80,
  time_range = c("2010-01-01", "2020-01-01"),
  irregular = TRUE
)

tsl2 &lt;- tsl_simulate(
  n = 2,
  rows = 120,
  time_range = c("2005-01-01", "2024-01-01"),
  irregular = TRUE
)

#check time features
tsl_time_summary(tsl1)[
  c(
    "begin",
    "end",
    "resolution_min",
    "resolution_max"
  )
]

tsl_time_summary(tsl2)[
  c(
    "begin",
    "end",
    "resolution_min",
    "resolution_max"
  )
]

#tsl1 to regular
tsl1_regular &lt;- tsl_resample(
  tsl = tsl1
)

#tsl2 resampled to time of tsl1_regular
tsl2_regular &lt;- tsl_resample(
  tsl = tsl2,
  new_time = tsl1_regular
)

#check alignment
tsl_time_summary(tsl1_regular)[
  c(
    "begin",
    "end",
    "resolution_min",
    "resolution_max"
  )
]

tsl_time_summary(tsl2_regular)[
  c(
    "begin",
    "end",
    "resolution_min",
    "resolution_max"
  )
]

</code></pre>

<hr>
<h2 id='tsl_simulate'>Simulate a Time Series List</h2><span id='topic+tsl_simulate'></span>

<h3>Description</h3>

<p>Generates simulated time series lists for testing and learning.
</p>
<p>This function supports progress bars generated by the <code>progressr</code> package, and accepts a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code> (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_simulate(
  n = 2,
  cols = 5,
  rows = 100,
  time_range = c("2010-01-01", "2020-01-01"),
  data_range = c(0, 1),
  seasons = 0,
  na_fraction = 0,
  independent = FALSE,
  irregular = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_simulate_+3A_n">n</code></td>
<td>
<p>(optional, integer) Number of time series to simulate. Default: 2.</p>
</td></tr>
<tr><td><code id="tsl_simulate_+3A_cols">cols</code></td>
<td>
<p>(optional, integer) Number of columns of each time series. Default: 5</p>
</td></tr>
<tr><td><code id="tsl_simulate_+3A_rows">rows</code></td>
<td>
<p>(optional, integer) Length of each time series. Minimum is 10, but maximum is not limited. Very large numbers might crash the R session. Default: 100</p>
</td></tr>
<tr><td><code id="tsl_simulate_+3A_time_range">time_range</code></td>
<td>
<p>(optional character or numeric vector) Time interval of the time series. Either a character vector with dates in format YYYY-MM-DD or or a numeric vector. If there is a mismatch between <code>time_range</code> and <code>rows</code> (for example, the number of days in <code>time_range</code> is smaller than <code>rows</code>), the upper value in <code>time_range</code> is adapted to <code>rows</code>. Default: c(&quot;2010-01-01&quot;, &quot;2020-01-01&quot;)</p>
</td></tr>
<tr><td><code id="tsl_simulate_+3A_data_range">data_range</code></td>
<td>
<p>(optional, numeric vector of length 2) Extremes of the time series values. Default: c(0, 1)</p>
</td></tr>
<tr><td><code id="tsl_simulate_+3A_seasons">seasons</code></td>
<td>
<p>(optional, integer) Number of seasons in the resulting time series. The maximum number of seasons is computed as <code>floor(rows/3)</code>. Default: 0</p>
</td></tr>
<tr><td><code id="tsl_simulate_+3A_na_fraction">na_fraction</code></td>
<td>
<p>(optional, numeric) Value between 0 and 0.5 indicating the approximate fraction of NA data in the simulated time series. Default: 0.</p>
</td></tr>
<tr><td><code id="tsl_simulate_+3A_independent">independent</code></td>
<td>
<p>(optional, logical) If TRUE, each new column in a simulated time series is averaged with the previous column to generate dependency across columns, and each new simulated time series is weighted-averaged with a time series template to generate dependency across time series. Irrelevant when <code>cols &lt; 2</code> or <code>n &lt; 2</code>, and hard to perceive in the output when <code>seasons &gt; 0</code>. Default: FALSE</p>
</td></tr>
<tr><td><code id="tsl_simulate_+3A_irregular">irregular</code></td>
<td>
<p>(optional, logical) If TRUE, the time intervals between consecutive samples and the number of rows are irregular. Default: TRUE</p>
</td></tr>
<tr><td><code id="tsl_simulate_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) Random seed used to simulate the zoo object. If NULL (default), a seed is selected at random. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other simulate_time_series: 
<code><a href="#topic+zoo_simulate">zoo_simulate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generates a different time series list on each iteration when seed = NULL
tsl &lt;- tsl_simulate(
  n = 2,
  seasons = 4
)

if(interactive()){
  tsl_plot(
    tsl = tsl
  )
}

# generate 3 independent time series
tsl_independent &lt;- tsl_simulate(
  n = 3,
  cols = 3,
  independent = TRUE
)

if(interactive()){
  tsl_plot(
    tsl = tsl_independent
  )
}

# generate 3 independent time series
tsl_dependent &lt;- tsl_simulate(
  n = 3,
  cols = 3,
  independent = FALSE
)

if(interactive()){
  tsl_plot(
    tsl = tsl_dependent
  )
}

# with seasons
tsl_seasons &lt;- tsl_simulate(
  n = 3,
  cols = 3,
  seasons = 4,
  independent = FALSE
)

if(interactive()){
  tsl_plot(
    tsl = tsl_seasons
  )
}

</code></pre>

<hr>
<h2 id='tsl_smooth'>Smoothing of Time Series Lists</h2><span id='topic+tsl_smooth'></span>

<h3>Description</h3>

<p>Rolling-window and exponential smoothing of Time Series Lists.
</p>
<p>Rolling-window smoothing This computes a statistic over a fixed-width window of consecutive cases and replaces each central value with the computed statistic. It is commonly used to mitigate noise in high-frequency time series.
</p>
<p>Exponential smoothing computes each value as the weighted average of the current value and past smoothed values. This method is useful for reducing noise in time series data while preserving the overall trend.
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_smooth(tsl = NULL, window = 3, f = mean, alpha = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_smooth_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_smooth_+3A_window">window</code></td>
<td>
<p>(optional, integer) Smoothing window width, in number of cases. Default: 3</p>
</td></tr>
<tr><td><code id="tsl_smooth_+3A_f">f</code></td>
<td>
<p>(optional, quoted or unquoted function name) Name of a standard or custom function to aggregate numeric vectors. Typical examples are <code>mean</code>, <code>max</code>,<code>min</code>, <code>median</code>, and <code>quantile</code>. Default: <code>mean</code>.</p>
</td></tr>
<tr><td><code id="tsl_smooth_+3A_alpha">alpha</code></td>
<td>
<p>(required, numeric) Exponential smoothing factor in the range (0, 1]. Determines the weight of the current value relative to past values. If not NULL, the arguments <code>window</code> and <code>f</code> are ignored, and exponential smoothing is performed instead. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_smooth_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) additional arguments to <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_processing: 
<code><a href="#topic+tsl_aggregate">tsl_aggregate</a>()</code>,
<code><a href="#topic+tsl_resample">tsl_resample</a>()</code>,
<code><a href="#topic+tsl_stats">tsl_stats</a>()</code>,
<code><a href="#topic+tsl_transform">tsl_transform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

tsl &lt;- tsl_simulate(n = 2)

#rolling window smoothing
tsl_smooth &lt;- tsl_smooth(
  tsl = tsl,
  window = 5,
  f = mean
)

if(interactive()){
  tsl_plot(tsl)
  tsl_plot(tsl_smooth)
}

#exponential smoothing
tsl_smooth &lt;- tsl_smooth(
  tsl = tsl,
  alpha = 0.2
)

if(interactive()){
  tsl_plot(tsl)
  tsl_plot(tsl_smooth)
}

</code></pre>

<hr>
<h2 id='tsl_stats'>Summary Statistics of Time Series Lists</h2><span id='topic+tsl_stats'></span>

<h3>Description</h3>

<p>This function computes a variety of summary statistics for each time series and numeric column within a time series list. The statistics include common metrics  such as minimum, maximum, quartiles, mean, standard deviation, range, interquartile range, skewness, kurtosis, and autocorrelation for specified lags.
</p>
<p>For irregular time series, autocorrelation computation is performed after regularizing the time series via interpolation with <code><a href="#topic+zoo_resample">zoo_resample()</a></code>. This regularization does not affect the computation of all other stats.
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_stats(tsl = NULL, lags = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_stats_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_stats_+3A_lags">lags</code></td>
<td>
<p>(optional, integer) An integer specifying the number of autocorrelation lags to compute. If NULL, autocorrelation computation is disabled. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame:
</p>

<ul>
<li><p> name: name of the zoo object.
</p>
</li>
<li><p> rows: rows of the zoo object.
</p>
</li>
<li><p> columns: columns of the zoo object.
</p>
</li>
<li><p> time_units: time units of the zoo time series (see <code><a href="#topic+zoo_time">zoo_time()</a></code>).
</p>
</li>
<li><p> time_begin: beginning time of the time series.
</p>
</li>
<li><p> time_end: end time of the time series.
</p>
</li>
<li><p> time_length: total length of the time series, expressed in time units.
</p>
</li>
<li><p> time_resolution: average distance between consecutive observations
</p>
</li>
<li><p> variable: name of the variable, a column of the zoo object.
</p>
</li>
<li><p> min: minimum value of the zoo column.
</p>
</li>
<li><p> q1: first quartile (25th percentile).
</p>
</li>
<li><p> median: 50th percentile.
</p>
</li>
<li><p> q3: third quartile (75th percentile).
</p>
</li>
<li><p> max: maximum value.
</p>
</li>
<li><p> mean: average value.
</p>
</li>
<li><p> sd: standard deviation.
</p>
</li>
<li><p> range: range of the variable, computed as max - min.
</p>
</li>
<li><p> iq_range: interquartile range of the variable, computed as q3 - q1.
</p>
</li>
<li><p> skewness: asymmetry of the variable distribution.
</p>
</li>
<li><p> kurtosis:&quot;tailedness&quot; of the variable distribution.
</p>
</li>
<li><p> ac_lag_1, ac_lag_2, ...: autocorrelation values for the specified lags.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other tsl_processing: 
<code><a href="#topic+tsl_aggregate">tsl_aggregate</a>()</code>,
<code><a href="#topic+tsl_resample">tsl_resample</a>()</code>,
<code><a href="#topic+tsl_smooth">tsl_smooth</a>()</code>,
<code><a href="#topic+tsl_transform">tsl_transform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#three time series
#climate and ndvi in Fagus sylvatica stands in Spain, Germany, and Sweden
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
)


#stats computation
df &lt;- tsl_stats(
  tsl = tsl,
  lags = 3
  )

df
</code></pre>

<hr>
<h2 id='tsl_subset'>Subset Time Series Lists by Time Series Names, Time, and/or Column Names</h2><span id='topic+tsl_subset'></span>

<h3>Description</h3>

<p>Subset Time Series Lists by Time Series Names, Time, and/or Column Names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_subset(
  tsl = NULL,
  names = NULL,
  colnames = NULL,
  time = NULL,
  numeric_cols = TRUE,
  shared_cols = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_subset_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_subset_+3A_names">names</code></td>
<td>
<p>(optional, character or numeric vector) Character vector of names or numeric vector with list indices. If NULL, all time series are kept. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_subset_+3A_colnames">colnames</code></td>
<td>
<p>(optional, character vector) Column names of the zoo objects in <code>tsl</code>. If NULL, all columns are returned. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_subset_+3A_time">time</code></td>
<td>
<p>(optional, numeric vector) time vector of length two used to subset rows by time. If NULL, all rows in <code>tsl</code> are preserved. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_subset_+3A_numeric_cols">numeric_cols</code></td>
<td>
<p>(optional, logical) If TRUE, only the numeric columns of the zoo objects are returned. Default: TRUE</p>
</td></tr>
<tr><td><code id="tsl_subset_+3A_shared_cols">shared_cols</code></td>
<td>
<p>(optional, logical) If TRUE, only columns shared across all zoo objects are returned. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#initialize time series list
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
)

#checking available dimensions

#names
tsl_names_get(
  tsl = tsl
)

#colnames
tsl_colnames_get(
  tsl = tsl
)

#time
tsl_time(
  tsl = tsl
)[, c("name", "begin", "end")]

#subset
tsl_new &lt;- tsl_subset(
  tsl = tsl,
  names = c("Sweden", "Germany"),
  colnames = c("rainfall", "temperature"),
  time = c("2010-01-01", "2015-01-01")
)

#check new dimensions

#names
tsl_names_get(
  tsl = tsl_new
)

#colnames
tsl_colnames_get(
  tsl = tsl_new
)

#time
tsl_time(
  tsl = tsl_new
)[, c("name", "begin", "end")]
</code></pre>

<hr>
<h2 id='tsl_time'>Time Features of Time Series Lists</h2><span id='topic+tsl_time'></span><span id='topic+tsl_time_summary'></span>

<h3>Description</h3>

<p>The functions <code><a href="#topic+tsl_time">tsl_time()</a></code> and <code><a href="#topic+tsl_time_summary">tsl_time_summary()</a></code> summarize the time features of a time series list.
</p>

<ul>
<li> <p><code><a href="#topic+tsl_time">tsl_time()</a></code> returns a data frame with one row per time series in the argument 'tsl'
</p>
</li>
<li> <p><code><a href="#topic+tsl_time_summary">tsl_time_summary()</a></code> returns a list with the features captured by <code><a href="#topic+tsl_time">tsl_time()</a></code>, but aggregated across time series.
</p>
</li></ul>

<p>Both functions return keywords useful for the functions <code><a href="#topic+tsl_aggregate">tsl_aggregate()</a></code> and <code><a href="#topic+tsl_resample">tsl_resample()</a></code>, depending on the value of the argument <code>keywords</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_time(tsl = NULL, keywords = c("resample", "aggregate"))

tsl_time_summary(tsl = NULL, keywords = c("resample", "aggregate"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_time_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_time_+3A_keywords">keywords</code></td>
<td>
<p>(optional, character string or vector) Defines what keywords are returned. If &quot;aggregate&quot;, returns valid keywords for <code><a href="#topic+zoo_aggregate">zoo_aggregate()</a></code>. If &quot;resample&quot;, returns valid keywords for <code><a href="#topic+zoo_resample">zoo_resample()</a></code>. If both, returns all valid keywords. Default: c(&quot;aggregate&quot;, &quot;resample&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+tsl_time">tsl_time()</a></code>: data frame with the following columns:
</p>

<ul>
<li> <p><code>name</code> (string): time series name.
</p>
</li>
<li> <p><code>rows</code> (integer): number of observations.
</p>
</li>
<li> <p><code>class</code> (string): time class, one of &quot;Date&quot;, &quot;POSIXct&quot;, or &quot;numeric.&quot;
</p>
</li>
<li> <p><code>units</code> (string): units of the time series.
</p>
</li>
<li> <p><code>length</code> (numeric): total length of the time series expressed in <code>units</code>.
</p>
</li>
<li> <p><code>resolution</code> (numeric): average interval between observations expressed in <code>units</code>.
</p>
</li>
<li> <p><code>begin</code> (date or numeric): begin time of the time series.
</p>
</li>
<li> <p><code>end</code> (date or numeric): end time of the time series.
</p>
</li>
<li> <p><code>keywords</code> (character vector): valid keywords for <code><a href="#topic+tsl_aggregate">tsl_aggregate()</a></code> or <code><a href="#topic+tsl_resample">tsl_resample()</a></code>, depending on the value of the argument <code>keywords</code>.
</p>
</li></ul>

</li>
<li> <p><code><a href="#topic+tsl_time_summary">tsl_time_summary()</a></code>: list with the following objects:
</p>

<ul>
<li> <p><code>class</code> (string): time class, one of &quot;Date&quot;, &quot;POSIXct&quot;, or &quot;numeric.&quot;
</p>
</li>
<li> <p><code>units</code> (string): units of the time series.
</p>
</li>
<li> <p><code>begin</code> (date or numeric): begin time of the time series.
</p>
</li>
<li> <p><code>end</code> (date or numeric): end time of the time series.
</p>
</li>
<li> <p><code>resolution_max</code> (numeric): longer time interval between consecutive samples expressed in <code>units</code>.
</p>
</li>
<li> <p><code>resolution_min</code> (numeric): shorter time interval between consecutive samples expressed in <code>units</code>.
</p>
</li>
<li> <p><code>keywords</code> (character vector): valid keywords for <code><a href="#topic+tsl_aggregate">tsl_aggregate()</a></code> or <code><a href="#topic+tsl_resample">tsl_resample()</a></code>, depending on the value of the argument <code>keywords</code>.
</p>
</li>
<li> <p><code>units_df</code> (data frame) data frame for internal use within <code><a href="#topic+tsl_aggregate">tsl_aggregate()</a></code> and <code><a href="#topic+tsl_resample">tsl_resample()</a></code>.
</p>
</li></ul>

</li></ul>



<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_to_df">tsl_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate a time series list
tsl &lt;- tsl_simulate(
  n = 3,
  rows = 150,
  time_range = c(
    Sys.Date() - 365,
    Sys.Date()
  ),
  irregular = TRUE
)

#time data frame
tsl_time(
  tsl = tsl
)

#time summary
tsl_time_summary(
  tsl = tsl
)
</code></pre>

<hr>
<h2 id='tsl_to_df'>Transform Time Series List to Data Frame</h2><span id='topic+tsl_to_df'></span>

<h3>Description</h3>

<p>Transform Time Series List to Data Frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_to_df(tsl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_to_df_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other tsl_management: 
<code><a href="#topic+tsl_burst">tsl_burst</a>()</code>,
<code><a href="#topic+tsl_colnames_clean">tsl_colnames_clean</a>()</code>,
<code><a href="#topic+tsl_colnames_get">tsl_colnames_get</a>()</code>,
<code><a href="#topic+tsl_colnames_prefix">tsl_colnames_prefix</a>()</code>,
<code><a href="#topic+tsl_colnames_set">tsl_colnames_set</a>()</code>,
<code><a href="#topic+tsl_colnames_suffix">tsl_colnames_suffix</a>()</code>,
<code><a href="#topic+tsl_count_NA">tsl_count_NA</a>()</code>,
<code><a href="#topic+tsl_diagnose">tsl_diagnose</a>()</code>,
<code><a href="#topic+tsl_handle_NA">tsl_handle_NA</a>()</code>,
<code><a href="#topic+tsl_join">tsl_join</a>()</code>,
<code><a href="#topic+tsl_names_clean">tsl_names_clean</a>()</code>,
<code><a href="#topic+tsl_names_get">tsl_names_get</a>()</code>,
<code><a href="#topic+tsl_names_set">tsl_names_set</a>()</code>,
<code><a href="#topic+tsl_names_test">tsl_names_test</a>()</code>,
<code><a href="#topic+tsl_ncol">tsl_ncol</a>()</code>,
<code><a href="#topic+tsl_nrow">tsl_nrow</a>()</code>,
<code><a href="#topic+tsl_repair">tsl_repair</a>()</code>,
<code><a href="#topic+tsl_subset">tsl_subset</a>()</code>,
<code><a href="#topic+tsl_time">tsl_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tsl &lt;- tsl_simulate(
  n = 3,
  rows = 10,
  time_range = c(
    "2010-01-01",
    "2020-01-01"
  ),
  irregular = FALSE
)

df &lt;- tsl_to_df(
  tsl = tsl
)

names(df)
nrow(df)
head(df)
</code></pre>

<hr>
<h2 id='tsl_transform'>Transform Values in Time Series Lists</h2><span id='topic+tsl_transform'></span>

<h3>Description</h3>

<p>Function for time series transformations without changes in data dimensions. Generally, functions introduced via the argument <code>f</code> should not change the dimensions of the output time series list. See <code><a href="#topic+tsl_resample">tsl_resample()</a></code> and <code><a href="#topic+tsl_aggregate">tsl_aggregate()</a></code> for transformations requiring changes in time series dimensions.
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsl_transform(tsl = NULL, f = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsl_transform_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="tsl_transform_+3A_f">f</code></td>
<td>
<p>(required, transformation function) name of a function taking a matrix as input. Currently, the following options are implemented, but any other function taking a matrix as input (for example, <code><a href="base.html#topic+scale">scale()</a></code>) should work as well:
</p>

<ul>
<li><p> f_proportion: proportion computed by row.
</p>
</li>
<li><p> f_percent: percentage computed by row.
</p>
</li>
<li><p> f_hellinger: Hellinger transformation computed by row
</p>
</li>
<li><p> f_scale_local: Local centering and/or scaling based on the variable mean and standard deviation in each time series within <code>tsl</code>.
</p>
</li>
<li><p> f_scale_global: Global centering and/or scaling based on the variable mean and standard deviation across all time series within <code>tsl</code>.
</p>
</li>
<li><p> f_smooth: Time series smoothing with a user defined rolling window.
</p>
</li>
<li><p> f_detrend_difference: Differencing detrending of time series via <code><a href="base.html#topic+diff">diff()</a></code>.
</p>
</li>
<li><p> f_detrend_linear: Detrending of seasonal time series via linear modeling.
</p>
</li>
<li><p> f_detrend_gam: Detrending of seasonal time series via Generalized Additive Models.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tsl_transform_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments of <code>f</code>) Optional arguments for the transformation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list
</p>


<h3>See Also</h3>

<p>Other tsl_processing: 
<code><a href="#topic+tsl_aggregate">tsl_aggregate</a>()</code>,
<code><a href="#topic+tsl_resample">tsl_resample</a>()</code>,
<code><a href="#topic+tsl_smooth">tsl_smooth</a>()</code>,
<code><a href="#topic+tsl_stats">tsl_stats</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#two time series
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_subset(
    names = c("Spain", "Sweden"),
    colnames = c("rainfall", "temperature")
  )

if(interactive()){
  tsl_plot(
    tsl = tsl
  )
}

#centering and scaling
#-----------------------------------------
#same mean and standard deviation are used to scale each variable across all time series
tsl_scale &lt;- tsl_transform(
  tsl = tsl,
  f = f_scale_local
)

if(interactive()){
  tsl_plot(
    tsl = tsl_scale,
    guide_columns = 3
  )
}


#rescaling to a new range
#-----------------------------------------

#rescale between -100 and 100
tsl_rescaled &lt;- tsl_transform(
  tsl = tsl,
  f = f_rescale_local,
  new_min = -100,
  new_max = 100
)

#old range
sapply(X = tsl, FUN = range)

#new range
sapply(X = tsl_rescaled, FUN = range)



#numeric transformations
#-----------------------------------------
#eemian pollen counts
tsl &lt;- tsl_initialize(
  x = distantia::eemian_pollen,
  name_column = "name",
  time_column = "time"
)

if(interactive()){
  tsl_plot(
    tsl = tsl
  )
}

#percentages
tsl_percentage &lt;- tsl_transform(
  tsl = tsl,
  f = f_percent
)

if(interactive()){
  tsl_plot(
    tsl = tsl_percentage
  )
}

#hellinger transformation
tsl_hellinger &lt;- tsl_transform(
  tsl = tsl,
  f = f_hellinger
)

if(interactive()){
  tsl_plot(
    tsl = tsl_hellinger
  )
}

</code></pre>

<hr>
<h2 id='utils_as_time'>Ensures Correct Class for Time Arguments</h2><span id='topic+utils_as_time'></span>

<h3>Description</h3>

<p>This function guesses the class of a vector based on its elements. It can handle numeric vectors, character vectors that can be coerced to either &quot;Date&quot; or &quot;POSIXct&quot; classes, and vectors already in &quot;Date&quot; or &quot;POSIXct&quot; classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_as_time(x = NULL, to_class = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_as_time_+3A_x">x</code></td>
<td>
<p>(required, vector) Vectors of the classes 'numeric', 'Date', and 'POSIXct' are valid and returned without any transformation. Character vectors are analyzed to determine their more probable type, and are coerced to 'Date' or 'POSIXct' depending on their number of elements. Generally, any character vector representing an ISO 8601 standard, like &quot;YYYY-MM-DD&quot; or &quot;YYYY-MM-DD HH:MM:SS&quot; will be converted to a valid class. If a character vector cannot be coerced to date, it is returned as is. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_as_time_+3A_to_class">to_class</code></td>
<td>
<p>(optional, class) Options are: NULL, &quot;numeric&quot;, &quot;Date&quot;, and &quot;POSIXct&quot;. If NULL, 'x' is returned as the most appropriate time class. Otherwise, 'x' is coerced to the given class. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time vector
</p>


<h3>See Also</h3>

<p>Other internal_time_handling: 
<code><a href="#topic+utils_coerce_time_class">utils_coerce_time_class</a>()</code>,
<code><a href="#topic+utils_is_time">utils_is_time</a>()</code>,
<code><a href="#topic+utils_new_time">utils_new_time</a>()</code>,
<code><a href="#topic+utils_time_keywords">utils_time_keywords</a>()</code>,
<code><a href="#topic+utils_time_keywords_dictionary">utils_time_keywords_dictionary</a>()</code>,
<code><a href="#topic+utils_time_keywords_translate">utils_time_keywords_translate</a>()</code>,
<code><a href="#topic+utils_time_units">utils_time_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># numeric
utils_as_time(
  x = c(-123120, 1200)
  )

# character string to Date
utils_as_time(
  x = c("2022-03-17", "2024-02-05")
  )

# incomplete character strings to Date
utils_as_time(
  x = c("2022", "2024")
  )

utils_as_time(
  x = c("2022-02", "2024-03")
  )

# character string to POSIXct
utils_as_time(
  x = c("2022-03-17 12:30:45", "2024-02-05 11:15:45")
  )

# Date vector (returns the input)
utils_as_time(
  x = as.Date(c("2022-03-17", "2024-02-05"))
  )

# POSIXct vector (returns the input)
utils_as_time(
  x = as.POSIXct(c("2022-03-17 12:30:45", "2024-02-05 11:15:45"))
  )

</code></pre>

<hr>
<h2 id='utils_block_size'>Default Block Size for Restricted Permutation in Dissimilarity Analyses</h2><span id='topic+utils_block_size'></span>

<h3>Description</h3>

<p>Default Block Size for Restricted Permutation in Dissimilarity Analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_block_size(tsl = NULL, block_size = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_block_size_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_block_size_+3A_block_size">block_size</code></td>
<td>
<p>(optional, integer vector) Row block sizes for restricted permutation tests. Only relevant when permutation methods are &quot;restricted&quot; or &quot;restricted_by_row&quot;. A block of size <code>n</code> indicates that a row can only be permuted within a block of <code>n</code> adjacent rows. If NULL, defaults to the 20% rows of the shortest time series in <code>tsl</code>. Minimum value is 2, and maximum value is 50% rows of the shortest time series in <code>tsl</code>. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>

<hr>
<h2 id='utils_boxplot_common'>Common Boxplot Component of <code>distantia_boxplot()</code> and <code>momentum_boxplot()</code></h2><span id='topic+utils_boxplot_common'></span>

<h3>Description</h3>

<p>Common Boxplot Component of <code>distantia_boxplot()</code> and <code>momentum_boxplot()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_boxplot_common(
  variable = NULL,
  value = NULL,
  fill_color = NULL,
  f = median,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  text_cex = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_boxplot_common_+3A_variable">variable</code></td>
<td>
<p>(required, character vector) vector with variable or time series names. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_boxplot_common_+3A_value">value</code></td>
<td>
<p>(required, numeric vector) vector of numeric values to compute the boxplot for. Must have the same length as <code>variable</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_boxplot_common_+3A_fill_color">fill_color</code></td>
<td>
<p>(optional, character vector) boxplot fill color. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_boxplot_common_+3A_f">f</code></td>
<td>
<p>(optional, function) function used to aggregate the input data frame and arrange the boxes. One of <code>mean</code> or <code>median</code>. Default: <code>median</code>.</p>
</td></tr>
<tr><td><code id="utils_boxplot_common_+3A_main">main</code></td>
<td>
<p>(optional, string) boxplot title. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_boxplot_common_+3A_xlab">xlab</code></td>
<td>
<p>(optional, string) x axis label. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_boxplot_common_+3A_ylab">ylab</code></td>
<td>
<p>(optional, string) y axis label. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_boxplot_common_+3A_text_cex">text_cex</code></td>
<td>
<p>(optional, numeric) Multiplier of the text size. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boxplot
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils_boxplot_common(
  variable = rep(x = c("a", "b"), times = 50),
  value = stats::runif(100)
)
</code></pre>

<hr>
<h2 id='utils_check_args_distantia'>Check Input Arguments of <code>distantia()</code></h2><span id='topic+utils_check_args_distantia'></span>

<h3>Description</h3>

<p>Check Input Arguments of <code>distantia()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_check_args_distantia(
  tsl = NULL,
  distance = NULL,
  diagonal = NULL,
  bandwidth = NULL,
  lock_step = NULL,
  repetitions = NULL,
  permutation = NULL,
  block_size = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_check_args_distantia_+3A_tsl">tsl</code></td>
<td>
<p>(required, time series list) list of zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_check_args_distantia_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="utils_check_args_distantia_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical vector). If TRUE, diagonals are included in the dynamic time warping computation. Default: TRUE</p>
</td></tr>
<tr><td><code id="utils_check_args_distantia_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(optional, numeric) Proportion of space at each side of the cost matrix diagonal (aka <em>Sakoe-Chiba band</em>) defining a valid region for dynamic time warping, used to control the flexibility of the warping path. This method prevents degenerate alignments due to differences in magnitude between time series when the data is not properly scaled. If <code>1</code> (default), DTW is unconstrained. If <code>0</code>, DTW is fully constrained and the warping path follows the matrix diagonal. Recommended values may vary depending on the nature of the data. Ignored if <code>lock_step = TRUE</code>. Default: 1.</p>
</td></tr>
<tr><td><code id="utils_check_args_distantia_+3A_lock_step">lock_step</code></td>
<td>
<p>(optional, logical vector) If TRUE, time series captured at the same times are compared sample wise (with no dynamic time warping). Requires time series in argument <code>tsl</code> to be fully aligned, or it will return an error. Default: FALSE.</p>
</td></tr>
<tr><td><code id="utils_check_args_distantia_+3A_repetitions">repetitions</code></td>
<td>
<p>(optional, integer vector) number of permutations to compute the p-value. If 0, p-values are not computed. Otherwise, the minimum is 2. The resolution of the p-values and the overall computation time depends on the number of permutations. Default: 0</p>
</td></tr>
<tr><td><code id="utils_check_args_distantia_+3A_permutation">permutation</code></td>
<td>
<p>(optional, character vector) permutation method, only relevant when <code>repetitions</code> is higher than zero. Valid values are: &quot;restricted_by_row&quot;, &quot;restricted&quot;, &quot;free_by_row&quot;, and &quot;free&quot;. Default: &quot;restricted_by_row&quot;.</p>
</td></tr>
<tr><td><code id="utils_check_args_distantia_+3A_block_size">block_size</code></td>
<td>
<p>(optional, integer) Size of the row blocks for the restricted permutation test. Only relevant when permutation methods are &quot;restricted&quot; or &quot;restricted_by_row&quot; and <code>repetitions</code> is higher than zero. A block of size <code>n</code> indicates that a row can only be permuted within a block of <code>n</code> adjacent rows. If NULL, defaults to the rounded one tenth of the shortest time series in <code>tsl</code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="utils_check_args_distantia_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) initial random seed to use for replicability when computing p-values. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_check_args_matrix'>Checks Input Matrix</h2><span id='topic+utils_check_args_matrix'></span>

<h3>Description</h3>

<p>Checks Input Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_check_args_matrix(m = NULL, arg_name = "m")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_check_args_matrix_+3A_m">m</code></td>
<td>
<p>(required, matrix) distance or cost matrix resulting from <code><a href="#topic+psi_distance_matrix">psi_distance_matrix()</a></code> or <code><a href="#topic+psi_cost_matrix">psi_cost_matrix()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_check_args_matrix_+3A_arg_name">arg_name</code></td>
<td>
<p>(optional, character string) name of the argument being checked. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_check_args_momentum'>Check Input Arguments of <code>momentum()</code></h2><span id='topic+utils_check_args_momentum'></span>

<h3>Description</h3>

<p>Check Input Arguments of <code>momentum()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_check_args_momentum(
  tsl = NULL,
  distance = NULL,
  diagonal = NULL,
  bandwidth = NULL,
  lock_step = NULL,
  robust = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_check_args_momentum_+3A_tsl">tsl</code></td>
<td>
<p>(required, time series list) list of zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_check_args_momentum_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <a href="#topic+distances">distances</a>. Default: &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="utils_check_args_momentum_+3A_diagonal">diagonal</code></td>
<td>
<p>(optional, logical vector). If TRUE, diagonals are included in the dynamic time warping computation. Default: TRUE</p>
</td></tr>
<tr><td><code id="utils_check_args_momentum_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(optional, numeric) Proportion of space at each side of the cost matrix diagonal (aka <em>Sakoe-Chiba band</em>) defining a valid region for dynamic time warping, used to control the flexibility of the warping path. This method prevents degenerate alignments due to differences in magnitude between time series when the data is not properly scaled. If <code>1</code> (default), DTW is unconstrained. If <code>0</code>, DTW is fully constrained and the warping path follows the matrix diagonal. Recommended values may vary depending on the nature of the data. Ignored if <code>lock_step = TRUE</code>. Default: 1.</p>
</td></tr>
<tr><td><code id="utils_check_args_momentum_+3A_lock_step">lock_step</code></td>
<td>
<p>(optional, logical vector) If TRUE, time series captured at the same times are compared sample wise (with no dynamic time warping). Requires time series in argument <code>tsl</code> to be fully aligned, or it will return an error. Default: FALSE.</p>
</td></tr>
<tr><td><code id="utils_check_args_momentum_+3A_robust">robust</code></td>
<td>
<p>(required, logical). If TRUE (default), importance scores are computed using the least cost path of the complete time series as reference. Setting it to FALSE allows to replicate importance scores of the previous versions of this package. This option is irrelevant when <code>lock_step = TRUE</code>. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_check_args_path'>Checks Least Cost Path</h2><span id='topic+utils_check_args_path'></span>

<h3>Description</h3>

<p>Checks Least Cost Path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_check_args_path(path = NULL, arg_name = "path")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_check_args_path_+3A_path">path</code></td>
<td>
<p>(required, data frame) least cost path generated with <code><a href="#topic+psi_cost_path">psi_cost_path()</a></code>. This data frame must have the attribute <code style="white-space: pre;">&#8288;type == "cost_path&#8288;</code>, and must have been computed from the same time series used to compute the matrix <code>m</code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="utils_check_args_path_+3A_arg_name">arg_name</code></td>
<td>
<p>(optional, character string) name of the argument being checked. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_check_args_tsl'>Structural Check for Time Series Lists</h2><span id='topic+utils_check_args_tsl'></span>

<h3>Description</h3>

<p>Internal function to check that a time series list is a list of zoo objects and has a minimum number of objects. For a more comprehensive test, use <code><a href="#topic+tsl_diagnose">tsl_diagnose()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_check_args_tsl(tsl = NULL, min_length = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_check_args_tsl_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) list of zoo objects. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_check_args_tsl_+3A_min_length">min_length</code></td>
<td>
<p>(required, positive integer) minimum number of zoo objects in <code>tsl</code>. Default: 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>error messages (if any)
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_check_args_zoo'>Checks Argument x</h2><span id='topic+utils_check_args_zoo'></span>

<h3>Description</h3>

<p>Checks Argument x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_check_args_zoo(x = NULL, arg_name = "x")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_check_args_zoo_+3A_x">x</code></td>
<td>
<p>(required, zoo object) zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_check_args_zoo_+3A_arg_name">arg_name</code></td>
<td>
<p>(optional, character string) name of the argument being checked. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_check_distance_args'>Check Distance Argument</h2><span id='topic+utils_check_distance_args'></span>

<h3>Description</h3>

<p>Check Distance Argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_check_distance_args(distance = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_check_distance_args_+3A_distance">distance</code></td>
<td>
<p>(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns &quot;names&quot; and &quot;abbreviation&quot; of the dataset <code>distances</code>. Default: &quot;euclidean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
utils_check_distance_args(
  distance = c(
    "euclidean",
    "euc"
   )
  )
</code></pre>

<hr>
<h2 id='utils_check_list_class'>Checks Classes of List Elements Against Expectation</h2><span id='topic+utils_check_list_class'></span>

<h3>Description</h3>

<p>Checks Classes of List Elements Against Expectation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_check_list_class(x = NULL, expected_class = "data.frame")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_check_list_class_+3A_x">x</code></td>
<td>
<p>(required, list) Default: NULL</p>
</td></tr>
<tr><td><code id="utils_check_list_class_+3A_expected_class">expected_class</code></td>
<td>
<p>(required, class name). One of &quot;data.frame&quot;, &quot;matrix&quot;, or &quot;vector&quot;. Default: &quot;data.frame&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>side effects
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_clean_names'>Clean Character Vector of Names</h2><span id='topic+utils_clean_names'></span>

<h3>Description</h3>

<p>Clean and format character vectors for use as column names or variable names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_clean_names(
  x = NULL,
  lowercase = FALSE,
  separator = "_",
  capitalize_first = FALSE,
  capitalize_all = FALSE,
  length = NULL,
  suffix = NULL,
  prefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_clean_names_+3A_x">x</code></td>
<td>
<p>(required, character vector) Names to be cleaned. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_clean_names_+3A_lowercase">lowercase</code></td>
<td>
<p>(optional, logical) If TRUE, all names are coerced to lowercase. Default: FALSE</p>
</td></tr>
<tr><td><code id="utils_clean_names_+3A_separator">separator</code></td>
<td>
<p>(optional, character string) Separator when replacing spaces and dots and appending <code>suffix</code> and <code>prefix</code> to the main word. Default: &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="utils_clean_names_+3A_capitalize_first">capitalize_first</code></td>
<td>
<p>(optional, logical) Indicates whether to capitalize the first letter of each name Default: FALSE.</p>
</td></tr>
<tr><td><code id="utils_clean_names_+3A_capitalize_all">capitalize_all</code></td>
<td>
<p>(optional, logical) Indicates whether to capitalize all letters of each name Default: FALSE.</p>
</td></tr>
<tr><td><code id="utils_clean_names_+3A_length">length</code></td>
<td>
<p>(optional, integer) Minimum length of abbreviated names. Names are abbreviated via <code><a href="base.html#topic+abbreviate">abbreviate()</a></code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="utils_clean_names_+3A_suffix">suffix</code></td>
<td>
<p>(optional, character string) String to append to the cleaned names. Default: NULL.</p>
</td></tr>
<tr><td><code id="utils_clean_names_+3A_prefix">prefix</code></td>
<td>
<p>(optional, character string)  String to prepend to the cleaned names. Default: NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cleanup operations are applied in the following order:
</p>

<ul>
<li><p> Remove leading and trailing whitespaces.
</p>
</li>
<li><p> Generates syntactically valid names with <code><a href="base.html#topic+make.names">base::make.names()</a></code>.
</p>
</li>
<li><p> Replaces dots and spaces with the <code>separator</code>.
</p>
</li>
<li><p> Coerces names to lowercase.
</p>
</li>
<li><p> If argument <code>length</code> is provided, <code><a href="base.html#topic+abbreviate">base::abbreviate()</a></code> is used to abbreviate the new column names.
</p>
</li>
<li><p> If <code>suffix</code> is provided, it is added at the end of the column name using the separator.
</p>
</li>
<li><p> If <code>prefix</code> is provided, it is added at the beginning of the column name using the separator.
</p>
</li>
<li><p> If <code>capitalize_first = TRUE</code>, the first letter is capitalized.
</p>
</li>
<li><p> If <code>capitalize_all = TRUE</code>, all letters are capitalized.
</p>
</li></ul>



<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(
  "GerMany",
  "spain",
  "SWEDEN"
)

#abbreviate names
#---------------------------
#abbreviate to 4 characters
utils_clean_names(
  x = x,
  capitalize_all = TRUE,
  length = 4
)

#suffix and prefix
#---------------------------
utils_clean_names(
  x = x,
  capitalize_first = TRUE,
  separator = "_",
  prefix = "my_prefix",
  suffix = "my_suffix"
)
</code></pre>

<hr>
<h2 id='utils_cluster_hclust_optimizer'>Optimize the Silhouette Width of Hierarchical Clustering Solutions</h2><span id='topic+utils_cluster_hclust_optimizer'></span>

<h3>Description</h3>

<p>Performs a parallelized grid search to find the number of clusters maximizing the overall silhouette width of the clustering solution (see <code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette()</a></code>). When <code>method = NULL</code>, the optimization also includes all methods available in <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> in the grid search. This function supports parallelization via <code><a href="future.html#topic+plan">future::plan()</a></code> and a progress bar generated by the <code>progressr</code> package (see Examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_cluster_hclust_optimizer(d = NULL, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_cluster_hclust_optimizer_+3A_d">d</code></td>
<td>
<p>(required, matrix) distance matrix typically resulting from <code><a href="#topic+distantia_matrix">distantia_matrix()</a></code>, but any other square matrix should work. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_cluster_hclust_optimizer_+3A_method">method</code></td>
<td>
<p>(optional, character string) Argument of <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> defining the agglomerative method. One of: &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or &quot;centroid&quot; (= UPGMC). Unambiguous abbreviations are accepted as well.
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#weekly covid prevalence
#in 10 California counties
#aggregated by month
tsl &lt;- tsl_initialize(
  x = covid_prevalence,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_subset(
    names = 1:10
  ) |&gt;
  tsl_aggregate(
    new_time = "months",
    fun = max
  )

if(interactive()){
  #plotting first three time series
  tsl_plot(
    tsl = tsl_subset(
      tsl = tsl,
      names = 1:3
    ),
    guide_columns = 3
  )
}

#compute dissimilarity matrix
psi_matrix &lt;- distantia(
  tsl = tsl,
  lock_step = TRUE
) |&gt;
  distantia_matrix()

#optimize hierarchical clustering
hclust_optimization &lt;- utils_cluster_hclust_optimizer(
  d = psi_matrix
)

#best solution in first row
head(hclust_optimization)

</code></pre>

<hr>
<h2 id='utils_cluster_kmeans_optimizer'>Optimize the Silhouette Width of K-Means Clustering Solutions</h2><span id='topic+utils_cluster_kmeans_optimizer'></span>

<h3>Description</h3>

<p>Generates k-means solutions from 2 to <code>nrow(d) - 1</code> number of clusters and returns the number of clusters with a higher silhouette width median. See <code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette()</a></code> for more details.
</p>
<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_cluster_kmeans_optimizer(d = NULL, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_cluster_kmeans_optimizer_+3A_d">d</code></td>
<td>
<p>(required, matrix) distance matrix typically resulting from <code><a href="#topic+distantia_matrix">distantia_matrix()</a></code>, but any other square matrix should work. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_cluster_kmeans_optimizer_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) Random seed to be used during the K-means computation. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_silhouette">utils_cluster_silhouette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#weekly covid prevalence
#in 10 California counties
#aggregated by month
tsl &lt;- tsl_initialize(
  x = covid_prevalence,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_subset(
    names = 1:10
  ) |&gt;
  tsl_aggregate(
    new_time = "months",
    fun = max
  )

if(interactive()){
  #plotting first three time series
  tsl_plot(
    tsl = tsl_subset(
      tsl = tsl,
      names = 1:3
    ),
    guide_columns = 3
  )
}

#compute dissimilarity matrix
psi_matrix &lt;- distantia(
  tsl = tsl,
  lock_step = TRUE
) |&gt;
  distantia_matrix()

#optimize hierarchical clustering
kmeans_optimization &lt;- utils_cluster_kmeans_optimizer(
  d = psi_matrix
)

#best solution in first row
head(kmeans_optimization)

</code></pre>

<hr>
<h2 id='utils_cluster_silhouette'>Compute Silhouette Width of a Clustering Solution</h2><span id='topic+utils_cluster_silhouette'></span>

<h3>Description</h3>

<p>The silhouette width is a measure of how similar an object is to its own cluster (cohesion) compared to other clusters (separation).
</p>
<p>There are some general guidelines to interpret the  individual silhouette widths of the clustered objects (as returned by this function when <code>mean = FALSE</code>):
</p>

<ul>
<li><p> Close to 1: object is well matched to its own cluster and poorly matched to neighboring clusters.
</p>
</li>
<li><p> Close to 0: the object is between two neighboring clusters.
</p>
</li>
<li><p> Close to -1: the object is likely to be assigned to the wrong cluster
</p>
</li></ul>

<p>When <code>mean = TRUE</code>, the overall mean of the silhouette widths of all objects is returned. These values should be interpreted as follows:
</p>

<ul>
<li><p> Higher than 0.7: robust clustering .
</p>
</li>
<li><p> Higher than 0.5: reasonable clustering.
</p>
</li>
<li><p> Higher than 0.25: weak clustering.
</p>
</li></ul>

<p>This metric may not perform well when the clusters have irregular shapes or sizes.
</p>
<p>This code was adapted from <a href="https://svn.r-project.org/R-packages/trunk/cluster/R/silhouette.R">https://svn.r-project.org/R-packages/trunk/cluster/R/silhouette.R</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_cluster_silhouette(labels = NULL, d = NULL, mean = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_cluster_silhouette_+3A_labels">labels</code></td>
<td>
<p>(required, integer vector) Labels resulting from a clustering algorithm applied to <code>d</code>. Must have the same length as columns and rows in <code>d</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_cluster_silhouette_+3A_d">d</code></td>
<td>
<p>(required, matrix) distance matrix typically resulting from <code><a href="#topic+distantia_matrix">distantia_matrix()</a></code>, but any other square matrix should work. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_cluster_silhouette_+3A_mean">mean</code></td>
<td>
<p>(optional, logical) If TRUE, the mean of the silhouette widths is returned. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other distantia_support: 
<code><a href="#topic+distantia_aggregate">distantia_aggregate</a>()</code>,
<code><a href="#topic+distantia_boxplot">distantia_boxplot</a>()</code>,
<code><a href="#topic+distantia_cluster_hclust">distantia_cluster_hclust</a>()</code>,
<code><a href="#topic+distantia_cluster_kmeans">distantia_cluster_kmeans</a>()</code>,
<code><a href="#topic+distantia_matrix">distantia_matrix</a>()</code>,
<code><a href="#topic+distantia_model_frame">distantia_model_frame</a>()</code>,
<code><a href="#topic+distantia_spatial">distantia_spatial</a>()</code>,
<code><a href="#topic+distantia_stats">distantia_stats</a>()</code>,
<code><a href="#topic+distantia_time_delay">distantia_time_delay</a>()</code>,
<code><a href="#topic+utils_block_size">utils_block_size</a>()</code>,
<code><a href="#topic+utils_cluster_hclust_optimizer">utils_cluster_hclust_optimizer</a>()</code>,
<code><a href="#topic+utils_cluster_kmeans_optimizer">utils_cluster_kmeans_optimizer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#weekly covid prevalence in three California counties
#load as tsl
#subset first 10 time series
#sum by month
tsl &lt;- tsl_initialize(
  x = covid_prevalence,
  name_column = "name",
  time_column = "time"
) |&gt;
  tsl_subset(
    names = 1:10
  ) |&gt;
  tsl_aggregate(
    new_time = "months",
    method = max
  )

#compute dissimilarity
distantia_df &lt;- distantia(
  tsl = tsl,
  lock_step = TRUE
)

#generate dissimilarity matrix
psi_matrix &lt;- distantia_matrix(
  df = distantia_df
)

#example with kmeans clustering
#------------------------------------

#kmeans with 3 groups
psi_kmeans &lt;- stats::kmeans(
  x = as.dist(psi_matrix[[1]]),
  centers = 3
)

#case-wise silhouette width
utils_cluster_silhouette(
  labels = psi_kmeans$cluster,
  d = psi_matrix
)

#overall silhouette width
utils_cluster_silhouette(
  labels = psi_kmeans$cluster,
  d = psi_matrix,
  mean = TRUE
)


#example with hierarchical clustering
#------------------------------------

#hierarchical clustering
psi_hclust &lt;- stats::hclust(
  d = as.dist(psi_matrix[[1]])
)

#generate labels for three groups
psi_hclust_labels &lt;- stats::cutree(
  tree = psi_hclust,
  k = 3,
)

#case-wise silhouette width
utils_cluster_silhouette(
  labels = psi_hclust_labels,
  d = psi_matrix
)

#overall silhouette width
utils_cluster_silhouette(
  labels = psi_hclust_labels,
  d = psi_matrix,
  mean = TRUE
)
</code></pre>

<hr>
<h2 id='utils_coerce_time_class'>Coerces Vector to a Given Time Class</h2><span id='topic+utils_coerce_time_class'></span>

<h3>Description</h3>

<p>Coerces Vector to a Given Time Class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_coerce_time_class(x = NULL, to = "POSIXct")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_coerce_time_class_+3A_x">x</code></td>
<td>
<p>(required, vector of class Date or POSIXct) time vector to convert. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_coerce_time_class_+3A_to">to</code></td>
<td>
<p>(required, class name) class to coerce <code>x</code> to. Either &quot;Date&quot;, &quot;POSIXct&quot;, &quot;integer&quot; or &quot;numeric&quot;. Default: &quot;POSIXct&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time vector
</p>


<h3>See Also</h3>

<p>Other internal_time_handling: 
<code><a href="#topic+utils_as_time">utils_as_time</a>()</code>,
<code><a href="#topic+utils_is_time">utils_is_time</a>()</code>,
<code><a href="#topic+utils_new_time">utils_new_time</a>()</code>,
<code><a href="#topic+utils_time_keywords">utils_time_keywords</a>()</code>,
<code><a href="#topic+utils_time_keywords_dictionary">utils_time_keywords_dictionary</a>()</code>,
<code><a href="#topic+utils_time_keywords_translate">utils_time_keywords_translate</a>()</code>,
<code><a href="#topic+utils_time_units">utils_time_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- utils_coerce_time_class(
  x = c("2024-01-01", "2024-02-01"),
  to = "Date"
)

x
class(x)

x &lt;- utils_coerce_time_class(
  x = c("2024-01-01", "2024-02-01"),
  to = "POSIXct"
)

x
class(x)

x &lt;- utils_coerce_time_class(
  x = c("2024-01-01", "2024-02-01"),
  to = "numeric"
)

x
class(x)
</code></pre>

<hr>
<h2 id='utils_color_breaks'>Auto Breaks for Matrix Plotting Functions</h2><span id='topic+utils_color_breaks'></span>

<h3>Description</h3>

<p>Auto Breaks for Matrix Plotting Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_color_breaks(m = NULL, n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_color_breaks_+3A_m">m</code></td>
<td>
<p>(required, numeric matrix) distance or cost matrix generated by <code><a href="#topic+psi_distance_matrix">psi_distance_matrix()</a></code> or <code><a href="#topic+psi_cost_matrix">psi_cost_matrix()</a></code>, but any numeric matrix will work. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_color_breaks_+3A_n">n</code></td>
<td>
<p>(required, integer) number of colors to compute the breaks for. Default: 100</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p>Other internal_plotting: 
<code><a href="#topic+color_continuous">color_continuous</a>()</code>,
<code><a href="#topic+color_discrete">color_discrete</a>()</code>,
<code><a href="#topic+utils_line_color">utils_line_color</a>()</code>,
<code><a href="#topic+utils_line_guide">utils_line_guide</a>()</code>,
<code><a href="#topic+utils_matrix_guide">utils_matrix_guide</a>()</code>,
<code><a href="#topic+utils_matrix_plot">utils_matrix_plot</a>()</code>
</p>

<hr>
<h2 id='utils_digits'>Number of Decimal Places</h2><span id='topic+utils_digits'></span>

<h3>Description</h3>

<p>Number of Decimal Places
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_digits(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_digits_+3A_x">x</code></td>
<td>
<p>(required, numeric) Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils_digits(x = 0.234)
</code></pre>

<hr>
<h2 id='utils_distantia_df_split'>Split Dissimilarity Analysis Data Frames by Combinations of Arguments</h2><span id='topic+utils_distantia_df_split'></span>

<h3>Description</h3>

<p>Internal function to split a distantia data frame by groups of the arguments 'distance', 'diagonal', and 'lock_step'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_distantia_df_split(df = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_distantia_df_split_+3A_df">df</code></td>
<td>
<p>(required, data frame) Output of <code><a href="#topic+distantia">distantia()</a></code> or <code><a href="#topic+distantia_aggregate">distantia_aggregate()</a></code>. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#three time series
#climate and ndvi in Fagus sylvatica stands in Spain, Germany, and Sweden
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
)

#dissimilarity analysis with four combinations of parameters
df &lt;- distantia(
  tsl = tsl,
  distance = c(
    "euclidean",
    "manhattan"
    ),
  lock_step = c(
    TRUE,
    FALSE
  )
)

#split by combinations of parameters
df_split &lt;- utils_distantia_df_split(
  df = df
)

#print output
df_split

#class and length of the output
class(df_split)
length(df_split)
</code></pre>

<hr>
<h2 id='utils_drop_geometry'>Removes Geometry Column from SF Data Frames</h2><span id='topic+utils_drop_geometry'></span>

<h3>Description</h3>

<p>Replicates the functionality of  <code>sf::st_drop_geometry()</code> without depending on the <code>sf</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_drop_geometry(df = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_drop_geometry_+3A_df">df</code></td>
<td>
<p>(required, data frame) Input data frame. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other tsl_processing_internal: 
<code><a href="#topic+utils_global_scaling_params">utils_global_scaling_params</a>()</code>,
<code><a href="#topic+utils_optimize_loess">utils_optimize_loess</a>()</code>,
<code><a href="#topic+utils_optimize_spline">utils_optimize_spline</a>()</code>,
<code><a href="#topic+utils_rescale_vector">utils_rescale_vector</a>()</code>
</p>

<hr>
<h2 id='utils_global_scaling_params'>Global Centering and Scaling Parameters of Time Series Lists</h2><span id='topic+utils_global_scaling_params'></span>

<h3>Description</h3>

<p>Internal function to compute global scaling parameters (mean and standard deviation) for time series lists. Used within <code><a href="#topic+tsl_transform">tsl_transform()</a></code> when the scaling function <code><a href="#topic+f_scale_global">f_scale_global()</a></code> is used as input for the argument <code>f</code>.
</p>
<p>Warning: this function removes exclusive columns from the data. See function <code><a href="#topic+tsl_subset">tsl_subset()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_global_scaling_params(tsl = NULL, f = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_global_scaling_params_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_global_scaling_params_+3A_f">f</code></td>
<td>
<p>(required, function) function <code><a href="#topic+f_scale_global">f_scale_global()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_global_scaling_params_+3A_...">...</code></td>
<td>
<p>(optional, arguments of <code>f</code>) Optional arguments for the transformation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other tsl_processing_internal: 
<code><a href="#topic+utils_drop_geometry">utils_drop_geometry</a>()</code>,
<code><a href="#topic+utils_optimize_loess">utils_optimize_loess</a>()</code>,
<code><a href="#topic+utils_optimize_spline">utils_optimize_spline</a>()</code>,
<code><a href="#topic+utils_rescale_vector">utils_rescale_vector</a>()</code>
</p>

<hr>
<h2 id='utils_is_time'>Title</h2><span id='topic+utils_is_time'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_is_time(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_is_time_+3A_x">x</code></td>
<td>
<p>(required, vector) Vector to test. If the class of the vector elements is 'numeric', 'POSIXct', or 'Date', the function returns TRUE. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>See Also</h3>

<p>Other internal_time_handling: 
<code><a href="#topic+utils_as_time">utils_as_time</a>()</code>,
<code><a href="#topic+utils_coerce_time_class">utils_coerce_time_class</a>()</code>,
<code><a href="#topic+utils_new_time">utils_new_time</a>()</code>,
<code><a href="#topic+utils_time_keywords">utils_time_keywords</a>()</code>,
<code><a href="#topic+utils_time_keywords_dictionary">utils_time_keywords_dictionary</a>()</code>,
<code><a href="#topic+utils_time_keywords_translate">utils_time_keywords_translate</a>()</code>,
<code><a href="#topic+utils_time_units">utils_time_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
utils_is_time(
  x = c("2024-01-01", "2024-02-01")
)

utils_is_time(
  x = utils_as_time(
    x = c("2024-01-01", "2024-02-01")
    )
)
</code></pre>

<hr>
<h2 id='utils_line_color'>Handles Line Colors for Sequence Plots</h2><span id='topic+utils_line_color'></span>

<h3>Description</h3>

<p>This is an internal function, but can be used to better understand how line colors are handled within other plotting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_line_color(x = NULL, line_color = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_line_color_+3A_x">x</code></td>
<td>
<p>(required, sequence) zoo object or time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_line_color_+3A_line_color">line_color</code></td>
<td>
<p>(optional, character vector) vector of colors for the time series columns. Selected palette depends on the number of columns to plot. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>color vector
</p>


<h3>See Also</h3>

<p>Other internal_plotting: 
<code><a href="#topic+color_continuous">color_continuous</a>()</code>,
<code><a href="#topic+color_discrete">color_discrete</a>()</code>,
<code><a href="#topic+utils_color_breaks">utils_color_breaks</a>()</code>,
<code><a href="#topic+utils_line_guide">utils_line_guide</a>()</code>,
<code><a href="#topic+utils_matrix_guide">utils_matrix_guide</a>()</code>,
<code><a href="#topic+utils_matrix_plot">utils_matrix_plot</a>()</code>
</p>

<hr>
<h2 id='utils_line_guide'>Guide for Time Series Plots</h2><span id='topic+utils_line_guide'></span>

<h3>Description</h3>

<p>Guide for Time Series Plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_line_guide(
  x = NULL,
  position = "topright",
  line_color = NULL,
  line_width = 1,
  length = 1,
  text_cex = 0.7,
  guide_columns = 1,
  subpanel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_line_guide_+3A_x">x</code></td>
<td>
<p>(required, sequence) a zoo time series or a time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_line_guide_+3A_position">position</code></td>
<td>
<p>(optional, vector of xy coordinates or character string). This is a condensed version of the <code>x</code> and <code>y</code> arguments of the <code><a href="graphics.html#topic+legend">graphics::legend()</a></code> function. Coordinates (in the range 0 1) or keyword to position the legend. Accepted keywords are: &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;. Default: &quot;topright&quot;.</p>
</td></tr>
<tr><td><code id="utils_line_guide_+3A_line_color">line_color</code></td>
<td>
<p>(optional, character vector) vector of colors for the time series columns. If NULL, uses the palette &quot;Zissou 1&quot; provided by the function <code><a href="grDevices.html#topic+palettes">grDevices::hcl.colors()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_line_guide_+3A_line_width">line_width</code></td>
<td>
<p>(optional, numeric vector) Widths of the time series lines. Default: 1</p>
</td></tr>
<tr><td><code id="utils_line_guide_+3A_length">length</code></td>
<td>
<p>(optional, numeric) maps to the argument <code>seg.len</code> of <code><a href="graphics.html#topic+legend">graphics::legend()</a></code>. Length of the lines drawn in the legend. Default: 1</p>
</td></tr>
<tr><td><code id="utils_line_guide_+3A_text_cex">text_cex</code></td>
<td>
<p>(optional, numeric) Multiplier of the text size. Default: 0.7</p>
</td></tr>
<tr><td><code id="utils_line_guide_+3A_guide_columns">guide_columns</code></td>
<td>
<p>(optional, integer) Number of columns in which to set the legend items. Default: 1.</p>
</td></tr>
<tr><td><code id="utils_line_guide_+3A_subpanel">subpanel</code></td>
<td>
<p>(optional, logical) internal argument used when generating the multipanel plot produced by <code><a href="#topic+distantia_dtw_plot">distantia_dtw_plot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>


<h3>See Also</h3>

<p>Other internal_plotting: 
<code><a href="#topic+color_continuous">color_continuous</a>()</code>,
<code><a href="#topic+color_discrete">color_discrete</a>()</code>,
<code><a href="#topic+utils_color_breaks">utils_color_breaks</a>()</code>,
<code><a href="#topic+utils_line_color">utils_line_color</a>()</code>,
<code><a href="#topic+utils_matrix_guide">utils_matrix_guide</a>()</code>,
<code><a href="#topic+utils_matrix_plot">utils_matrix_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate()

if(interactive()){

  zoo_plot(x, guide = FALSE)

  utils_line_guide(
    x = x,
    position = "right"
  )

}

</code></pre>

<hr>
<h2 id='utils_matrix_guide'>Color Guide for Matrix Plot</h2><span id='topic+utils_matrix_guide'></span>

<h3>Description</h3>

<p>Plots a color legend for a distance or cost matrix for multi-panel plots or external image editors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_matrix_guide(
  m = NULL,
  matrix_color = NULL,
  breaks = NULL,
  title = NULL,
  text_cex = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_matrix_guide_+3A_m">m</code></td>
<td>
<p>(required, numeric matrix) distance or cost matrix generated by <code><a href="#topic+psi_distance_matrix">psi_distance_matrix()</a></code> or <code><a href="#topic+psi_cost_matrix">psi_cost_matrix()</a></code>, but any numeric matrix will work. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_matrix_guide_+3A_matrix_color">matrix_color</code></td>
<td>
<p>(optional, character vector) vector of colors. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_matrix_guide_+3A_breaks">breaks</code></td>
<td>
<p>(optional, numeric vector) vector of breaks for the color guide. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_matrix_guide_+3A_title">title</code></td>
<td>
<p>(optional, character string) guide title. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_matrix_guide_+3A_text_cex">text_cex</code></td>
<td>
<p>(optional, numeric) multiplier for the text size. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot
</p>


<h3>See Also</h3>

<p>Other internal_plotting: 
<code><a href="#topic+color_continuous">color_continuous</a>()</code>,
<code><a href="#topic+color_discrete">color_discrete</a>()</code>,
<code><a href="#topic+utils_color_breaks">utils_color_breaks</a>()</code>,
<code><a href="#topic+utils_line_color">utils_line_color</a>()</code>,
<code><a href="#topic+utils_line_guide">utils_line_guide</a>()</code>,
<code><a href="#topic+utils_matrix_plot">utils_matrix_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#prepare time series list
tsl &lt;- tsl_simulate(
  n = 2,
  independent = TRUE
)

#distance matrix between time series
dm &lt;- psi_distance_matrix(
  x = tsl[[1]],
  y = tsl[[2]]
)

if(interactive()){
  utils_matrix_guide(m = dm)
}
</code></pre>

<hr>
<h2 id='utils_matrix_plot'>Plot Distance or Cost Matrix and Least Cost Path</h2><span id='topic+utils_matrix_plot'></span>

<h3>Description</h3>

<p>This function is a simplified version of <code><a href="fields.html#topic+imagePlot">fields::imagePlot()</a></code>, by <a href="https://dnychka.github.io/">Douglas Nychka</a>. The original version is recommended in case more customization than the provided here is needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_matrix_plot(
  m = NULL,
  matrix_color = NULL,
  title = NULL,
  subtitle = NULL,
  xlab = NULL,
  ylab = NULL,
  text_cex = 1,
  path = NULL,
  path_width = 1,
  path_color = "black",
  diagonal_width = 1,
  diagonal_color = "white",
  guide = TRUE,
  subpanel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_matrix_plot_+3A_m">m</code></td>
<td>
<p>(required, numeric matrix) distance or cost matrix generated by <code><a href="#topic+psi_distance_matrix">psi_distance_matrix()</a></code> or <code><a href="#topic+psi_cost_matrix">psi_cost_matrix()</a></code>, but any numeric matrix will work. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_matrix_color">matrix_color</code></td>
<td>
<p>(optional, character vector) vector of colors. Uses the palette &quot;Zissou 1&quot; by default. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_title">title</code></td>
<td>
<p>(optional, character string) plot title. By default, names of the sequences used to compute the matrix <code>m</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_subtitle">subtitle</code></td>
<td>
<p>(optional, character string) plot subtitle. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_xlab">xlab</code></td>
<td>
<p>(optional, character string) title of the x axis (matrix columns). By default, the name of one of the sequences used to compute the matrix <code>m</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_ylab">ylab</code></td>
<td>
<p>(optional, character string) title of the y axis (matrix rows). By default, the name of one of the sequences used to compute the matrix <code>m</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_text_cex">text_cex</code></td>
<td>
<p>(optional, numeric) multiplicator of the text size for the plot labels and titles. Default: 1</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_path">path</code></td>
<td>
<p>(optional, data frame) least cost path generated with <code><a href="#topic+psi_cost_path">psi_cost_path()</a></code>. This data frame must have the attribute <code style="white-space: pre;">&#8288;type == "cost_path&#8288;</code>, and must have been computed from the same sequences used to compute the matrix <code>m</code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_path_width">path_width</code></td>
<td>
<p>(optional, numeric) width of the least cost path. Default: 1</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_path_color">path_color</code></td>
<td>
<p>(optional, character string) color of the least-cost path. Default: &quot;black&quot;</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_diagonal_width">diagonal_width</code></td>
<td>
<p>(optional, numeric) width of the diagonal. Set to 0 to remove the diagonal line. Default: 0.5</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_diagonal_color">diagonal_color</code></td>
<td>
<p>(optional, character string) color of the diagonal. Default: &quot;white&quot;</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_guide">guide</code></td>
<td>
<p>(optional, logical) if TRUE, a color guide for the matrix <code>m</code> is added by <code><a href="#topic+utils_matrix_guide">utils_matrix_guide()</a></code>.</p>
</td></tr>
<tr><td><code id="utils_matrix_plot_+3A_subpanel">subpanel</code></td>
<td>
<p>(optional, logical) internal argument used when generating the multi-panel plot produced by <code><a href="#topic+distantia_dtw_plot">distantia_dtw_plot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>


<h3>See Also</h3>

<p>Other internal_plotting: 
<code><a href="#topic+color_continuous">color_continuous</a>()</code>,
<code><a href="#topic+color_discrete">color_discrete</a>()</code>,
<code><a href="#topic+utils_color_breaks">utils_color_breaks</a>()</code>,
<code><a href="#topic+utils_line_color">utils_line_color</a>()</code>,
<code><a href="#topic+utils_line_guide">utils_line_guide</a>()</code>,
<code><a href="#topic+utils_matrix_guide">utils_matrix_guide</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#prepare time series list
tsl &lt;- tsl_simulate(
  n = 2,
  independent = TRUE
)

#distance matrix between time series
dm &lt;- psi_distance_matrix(
  x = tsl[[1]],
  y = tsl[[2]]
)

#cost matrix
cm &lt;- psi_cost_matrix(
  dist_matrix = dm
  )

#least cost path
cp &lt;- psi_cost_path(
  dist_matrix = dm,
  cost_matrix = cm
)

#plot cost matrix and least cost path
if(interactive()){
  utils_matrix_plot(
    m = cm,
    path = cp,
    guide = TRUE
  )
}
</code></pre>

<hr>
<h2 id='utils_new_time'>New Time for Time Series Aggregation</h2><span id='topic+utils_new_time'></span><span id='topic+utils_new_time_type'></span>

<h3>Description</h3>

<p>Internal function called by <code><a href="#topic+tsl_aggregate">tsl_aggregate()</a></code> and <code><a href="#topic+tsl_resample">tsl_resample()</a></code> to help transform the input argument <code>new_time</code> into the proper format for time series aggregation or resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_new_time(tsl = NULL, new_time = NULL, keywords = "aggregate")

utils_new_time_type(
  tsl = NULL,
  new_time = NULL,
  keywords = c("resample", "aggregate")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_new_time_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_new_time_+3A_new_time">new_time</code></td>
<td>
<p>(required, zoo object, numeric, numeric vector, Date vector, POSIXct vector, or keyword) breakpoints defining aggregation groups. Options are:
</p>

<ul>
<li><p> numeric vector: only for the &quot;numeric&quot; time class, defines the breakpoints for time series aggregation.
</p>
</li>
<li><p> &quot;Date&quot; or &quot;POSIXct&quot; vector: as above, but for the time classes &quot;Date&quot; and &quot;POSIXct.&quot; In any case, the input vector is coerced to the time class of the <code>tsl</code> argument.
</p>
</li>
<li><p> numeric: defines fixed with time intervals for time series aggregation. Used as is when the time class is &quot;numeric&quot;, and coerced to integer and interpreted as days for the time classes &quot;Date&quot; and &quot;POSIXct&quot;.
</p>
</li>
<li><p> keyword (see <code><a href="#topic+utils_time_units">utils_time_units()</a></code> and <code><a href="#topic+tsl_time_summary">tsl_time_summary()</a></code>): the common options for the time classes &quot;Date&quot; and &quot;POSIXct&quot; are: &quot;millennia&quot;, &quot;centuries&quot;, &quot;decades&quot;, &quot;years&quot;, &quot;quarters&quot;, &quot;months&quot;, and &quot;weeks&quot;. Exclusive keywords for the &quot;POSIXct&quot; time class are: &quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot;, and &quot;seconds&quot;. The time class &quot;numeric&quot; accepts keywords coded as scientific numbers, from &quot;1e8&quot; to &quot;1e-8&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="utils_new_time_+3A_keywords">keywords</code></td>
<td>
<p>(optional, character string or vector) Defines what keywords are returned. If &quot;aggregate&quot;, returns valid keywords for <code><a href="#topic+zoo_aggregate">zoo_aggregate()</a></code>. If &quot;resample&quot;, returns valid keywords for <code><a href="#topic+zoo_resample">zoo_resample()</a></code>. Default: &quot;aggregate&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of class numeric, Date, or POSIXct
</p>


<h3>See Also</h3>

<p>Other internal_time_handling: 
<code><a href="#topic+utils_as_time">utils_as_time</a>()</code>,
<code><a href="#topic+utils_coerce_time_class">utils_coerce_time_class</a>()</code>,
<code><a href="#topic+utils_is_time">utils_is_time</a>()</code>,
<code><a href="#topic+utils_time_keywords">utils_time_keywords</a>()</code>,
<code><a href="#topic+utils_time_keywords_dictionary">utils_time_keywords_dictionary</a>()</code>,
<code><a href="#topic+utils_time_keywords_translate">utils_time_keywords_translate</a>()</code>,
<code><a href="#topic+utils_time_units">utils_time_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#three time series
#climate and ndvi in Fagus sylvatica stands in Spain, Germany, and Sweden
tsl &lt;- tsl_initialize(
  x = fagus_dynamics,
  name_column = "name",
  time_column = "time"
)

# new time for aggregation using keywords
#-----------------------------------

#get valid keywords for aggregation
tsl_time_summary(
  tsl = tsl,
  keywords = "aggregate"
)$keywords

#if no keyword is used, for aggregation the highest resolution keyword is selected automatically
new_time &lt;- utils_new_time(
  tsl = tsl,
  new_time = NULL,
  keywords = "aggregate"
)

new_time

#if no keyword is used
#for resampling a regular version
#of the original time based on the
#average resolution is used instead
new_time &lt;- utils_new_time(
  tsl = tsl,
  new_time = NULL,
  keywords = "resample"
)

new_time

#aggregation time vector form keyword "years"
new_time &lt;- utils_new_time(
  tsl = tsl,
  new_time = "years",
  keywords = "aggregate"
)

new_time

#same from shortened keyword
#see utils_time_keywords_dictionary()
utils_new_time(
  tsl = tsl,
  new_time = "year",
  keywords = "aggregate"
)

#same for abbreviated keyword
utils_new_time(
  tsl = tsl,
  new_time = "y",
  keywords = "aggregate"
)

#from a integer defining a time interval in days
utils_new_time(
  tsl = tsl,
  new_time = 365,
  keywords = "aggregate"
)

#using this vector as input for aggregation
tsl_aggregated &lt;- tsl_aggregate(
  tsl = tsl,
  new_time = new_time
)
</code></pre>

<hr>
<h2 id='utils_optimize_loess'>Optimize Loess Models for Time Series Resampling</h2><span id='topic+utils_optimize_loess'></span>

<h3>Description</h3>

<p>Internal function used in <code><a href="#topic+zoo_resample">zoo_resample()</a></code>. It finds the <code>span</code> parameter of a univariate Loess (Locally Estimated Scatterplot Smoothing.) model <code>y ~ x</code> fitted with <code><a href="stats.html#topic+loess">stats::loess()</a></code> that minimizes the root mean squared error (rmse) between observations and predictions, and returns a model fitted with such <code>span</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_optimize_loess(x = NULL, y = NULL, max_complexity = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_optimize_loess_+3A_x">x</code></td>
<td>
<p>(required, numeric vector) predictor, a time vector coerced to numeric. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_optimize_loess_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) response, a column of a zoo object. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_optimize_loess_+3A_max_complexity">max_complexity</code></td>
<td>
<p>(required, logical). If TRUE, RMSE optimization is ignored, and the model of maximum complexity is returned. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Loess model.
</p>


<h3>See Also</h3>

<p>Other tsl_processing_internal: 
<code><a href="#topic+utils_drop_geometry">utils_drop_geometry</a>()</code>,
<code><a href="#topic+utils_global_scaling_params">utils_global_scaling_params</a>()</code>,
<code><a href="#topic+utils_optimize_spline">utils_optimize_spline</a>()</code>,
<code><a href="#topic+utils_rescale_vector">utils_rescale_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#zoo time series
xy &lt;- zoo_simulate(
  cols = 1,
  rows = 30
)

#optimize loess model
m &lt;- utils_optimize_loess(
  x = as.numeric(zoo::index(xy)), #predictor
  y = xy[, 1] #response
)

print(m)

#plot observation
plot(
  x = zoo::index(xy),
  y = xy[, 1],
  col = "forestgreen",
  type = "l",
  lwd = 2
  )

#plot prediction
points(
  x = zoo::index(xy),
  y = stats::predict(
    object = m,
    newdata = as.numeric(zoo::index(xy))
    ),
  col = "red4"
  )

</code></pre>

<hr>
<h2 id='utils_optimize_spline'>Optimize Spline Models for Time Series Resampling</h2><span id='topic+utils_optimize_spline'></span>

<h3>Description</h3>

<p>Internal function used in <code><a href="#topic+zoo_resample">zoo_resample()</a></code>. It finds optimal <code>df</code> parameter of a smoothing spline model <code>y ~ x</code> fitted with <code><a href="stats.html#topic+smooth.spline">stats::smooth.spline()</a></code>  that minimizes the root mean squared error (rmse) between observations and predictions, and returns a model fitted with such <code>df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_optimize_spline(x = NULL, y = NULL, max_complexity = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_optimize_spline_+3A_x">x</code></td>
<td>
<p>(required, numeric vector) predictor, a time vector coerced to numeric. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_optimize_spline_+3A_y">y</code></td>
<td>
<p>(required, numeric vector) response, a column of a zoo object. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_optimize_spline_+3A_max_complexity">max_complexity</code></td>
<td>
<p>(required, logical). If TRUE, RMSE optimization is ignored, and the model of maximum complexity is returned. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;smooth.spline&quot;.
</p>


<h3>See Also</h3>

<p>Other tsl_processing_internal: 
<code><a href="#topic+utils_drop_geometry">utils_drop_geometry</a>()</code>,
<code><a href="#topic+utils_global_scaling_params">utils_global_scaling_params</a>()</code>,
<code><a href="#topic+utils_optimize_loess">utils_optimize_loess</a>()</code>,
<code><a href="#topic+utils_rescale_vector">utils_rescale_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#zoo time series
xy &lt;- zoo_simulate(
  cols = 1,
  rows = 30
)

#optimize splines model
m &lt;- utils_optimize_spline(
  x = as.numeric(zoo::index(xy)), #predictor
  y = xy[, 1] #response
)

print(m)

#plot observation
plot(
  x = zoo::index(xy),
  y = xy[, 1],
  col = "forestgreen",
  type = "l",
  lwd = 2
  )

#plot prediction
points(
  x = zoo::index(xy),
  y = stats::predict(
    object = m,
    x = as.numeric(zoo::index(xy))
  )$y,
  col = "red"
)

</code></pre>

<hr>
<h2 id='utils_prepare_df'>Convert Data Frame to a List of Data Frames</h2><span id='topic+utils_prepare_df'></span>

<h3>Description</h3>

<p>Convert Data Frame to a List of Data Frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_prepare_df(x = NULL, name_column = NULL, time_column = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_prepare_df_+3A_x">x</code></td>
<td>
<p>(required, data frame) Input data frame. Default: NULL.</p>
</td></tr>
<tr><td><code id="utils_prepare_df_+3A_name_column">name_column</code></td>
<td>
<p>(optional, column name) Column name used to split <code>x</code> to a list of data frames. If omitted, the split is done by column instead. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_prepare_df_+3A_time_column">time_column</code></td>
<td>
<p>(optional, column name) Name of the column representing time, if any. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of data frames
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_prepare_matrix'>Convert Matrix to Data Frame</h2><span id='topic+utils_prepare_matrix'></span>

<h3>Description</h3>

<p>Convert Matrix to Data Frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_prepare_matrix(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_prepare_matrix_+3A_x">x</code></td>
<td>
<p>(required, matrix) Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_prepare_matrix_list'>Convert List of Matrices to List of Data Frames</h2><span id='topic+utils_prepare_matrix_list'></span>

<h3>Description</h3>

<p>Convert List of Matrices to List of Data Frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_prepare_matrix_list(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_prepare_matrix_list_+3A_x">x</code></td>
<td>
<p>(required, list of matrices) Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of Data Frames
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_prepare_time'>Handles Time Column in a List of Data Frames</h2><span id='topic+utils_prepare_time'></span>

<h3>Description</h3>

<p>Handles Time Column in a List of Data Frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_prepare_time(x = NULL, time_column = NULL, lock_step = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_prepare_time_+3A_x">x</code></td>
<td>
<p>(required, named list of data frames). List with named data frames. Default: NULL.</p>
</td></tr>
<tr><td><code id="utils_prepare_time_+3A_time_column">time_column</code></td>
<td>
<p>(optional if <code>lock_step = FALSE</code>, and required otherwise, column name) Name of numeric column representing time. Default: NULL.</p>
</td></tr>
<tr><td><code id="utils_prepare_time_+3A_lock_step">lock_step</code></td>
<td>
<p>(optional, logical) If TRUE, all input sequences are subset to their common times according to the values in the <code>time_column</code>. Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of data frames
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_prepare_vector_list'>Convert List of Vectors to List of Data Frames</h2><span id='topic+utils_prepare_vector_list'></span>

<h3>Description</h3>

<p>Convert List of Vectors to List of Data Frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_prepare_vector_list(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_prepare_vector_list_+3A_x">x</code></td>
<td>
<p>(required, list of vectors) Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of data frames
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>

<hr>
<h2 id='utils_prepare_zoo_list'>Convert List of Data Frames to List of Zoo Objects</h2><span id='topic+utils_prepare_zoo_list'></span>

<h3>Description</h3>

<p>Convert List of Data Frames to List of Zoo Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_prepare_zoo_list(x = NULL, time_column = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_prepare_zoo_list_+3A_x">x</code></td>
<td>
<p>(required, list of data frames) A named list with data frames. Default: NULL.</p>
</td></tr>
<tr><td><code id="utils_prepare_zoo_list_+3A_time_column">time_column</code></td>
<td>
<p>(required, column name) Name of the column representing time, if any. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of data frames, matrices, or vectors.
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_tsl_pairs">utils_tsl_pairs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- utils_prepare_zoo_list(
  x = list(
    spain = fagus_dynamics[fagus_dynamics$name == "Spain", ],
    sweden = fagus_dynamics[fagus_dynamics$name == "Sweden", ]
  ),
  time_column = "time"
)
</code></pre>

<hr>
<h2 id='utils_rescale_vector'>Rescale Numeric Vector to a New Data Range</h2><span id='topic+utils_rescale_vector'></span>

<h3>Description</h3>

<p>Rescale Numeric Vector to a New Data Range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_rescale_vector(
  x = NULL,
  new_min = 0,
  new_max = 1,
  old_min = NULL,
  old_max = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_rescale_vector_+3A_x">x</code></td>
<td>
<p>(required, numeric vector) Numeric vector. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="utils_rescale_vector_+3A_new_min">new_min</code></td>
<td>
<p>(optional, numeric) New minimum value. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="utils_rescale_vector_+3A_new_max">new_max</code></td>
<td>
<p>(optional_numeric) New maximum value. Default: <code>1</code></p>
</td></tr>
<tr><td><code id="utils_rescale_vector_+3A_old_min">old_min</code></td>
<td>
<p>(optional, numeric) Old minimum value. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="utils_rescale_vector_+3A_old_max">old_max</code></td>
<td>
<p>(optional_numeric) Old maximum value. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p>Other tsl_processing_internal: 
<code><a href="#topic+utils_drop_geometry">utils_drop_geometry</a>()</code>,
<code><a href="#topic+utils_global_scaling_params">utils_global_scaling_params</a>()</code>,
<code><a href="#topic+utils_optimize_loess">utils_optimize_loess</a>()</code>,
<code><a href="#topic+utils_optimize_spline">utils_optimize_spline</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 out &lt;- utils_rescale_vector(
   x = stats::rnorm(100),
   new_min = 0,
   new_max = 100,
   )

 out

</code></pre>

<hr>
<h2 id='utils_time_keywords'>Valid Aggregation Keywords</h2><span id='topic+utils_time_keywords'></span>

<h3>Description</h3>

<p>Internal function to obtain valid aggregation keywords from a zoo object or a time series list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_time_keywords(tsl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_time_keywords_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string, aggregation keyword, or &quot;none&quot;.
</p>


<h3>See Also</h3>

<p>Other internal_time_handling: 
<code><a href="#topic+utils_as_time">utils_as_time</a>()</code>,
<code><a href="#topic+utils_coerce_time_class">utils_coerce_time_class</a>()</code>,
<code><a href="#topic+utils_is_time">utils_is_time</a>()</code>,
<code><a href="#topic+utils_new_time">utils_new_time</a>()</code>,
<code><a href="#topic+utils_time_keywords_dictionary">utils_time_keywords_dictionary</a>()</code>,
<code><a href="#topic+utils_time_keywords_translate">utils_time_keywords_translate</a>()</code>,
<code><a href="#topic+utils_time_units">utils_time_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#one minute time series
#-----------------------------------
tsl &lt;- tsl_simulate(
  time_range = c(
    Sys.time() - 60,
    Sys.time()
  )
)

#valid keywords for aggregation and/or resampling
utils_time_keywords(
  tsl = tsl
)

#10 minutes time series
#-----------------------------------
tsl &lt;- tsl_simulate(
  time_range = c(
    Sys.time() - 600,
    Sys.time()
  )
)

utils_time_keywords(
  tsl = tsl
)

#10 hours time series
#-----------------------------------
tsl &lt;- tsl_simulate(
  time_range = c(
    Sys.time() - 6000,
    Sys.time()
  )
)

utils_time_keywords(
  tsl = tsl
)

#10 days time series
#-----------------------------------
tsl &lt;- tsl_simulate(
  time_range = c(
    Sys.Date() - 10,
    Sys.Date()
  )
)

utils_time_keywords(
  tsl = tsl
)

#10 years time series
#-----------------------------------
tsl &lt;- tsl_simulate(
  time_range = c(
    Sys.Date() - 3650,
    Sys.Date()
  )
)

utils_time_keywords(
  tsl = tsl
)
</code></pre>

<hr>
<h2 id='utils_time_keywords_dictionary'>Dictionary of Time Keywords</h2><span id='topic+utils_time_keywords_dictionary'></span>

<h3>Description</h3>

<p>Called by <code><a href="#topic+utils_time_keywords_translate">utils_time_keywords_translate()</a></code> to generate a data frame that helps translate misnamed or abbreviated time keywords, like &quot;day&quot;, &quot;daily&quot;, or &quot;d&quot;, into correct ones such as &quot;days&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_time_keywords_dictionary()
</code></pre>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other internal_time_handling: 
<code><a href="#topic+utils_as_time">utils_as_time</a>()</code>,
<code><a href="#topic+utils_coerce_time_class">utils_coerce_time_class</a>()</code>,
<code><a href="#topic+utils_is_time">utils_is_time</a>()</code>,
<code><a href="#topic+utils_new_time">utils_new_time</a>()</code>,
<code><a href="#topic+utils_time_keywords">utils_time_keywords</a>()</code>,
<code><a href="#topic+utils_time_keywords_translate">utils_time_keywords_translate</a>()</code>,
<code><a href="#topic+utils_time_units">utils_time_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- utils_time_keywords_dictionary()
</code></pre>

<hr>
<h2 id='utils_time_keywords_translate'>Translates The User's Time Keywords Into Valid Ones</h2><span id='topic+utils_time_keywords_translate'></span>

<h3>Description</h3>

<p>Internal function to translate misnamed or abbreviated keywords into valid ones. Uses <code><a href="#topic+utils_time_keywords_dictionary">utils_time_keywords_dictionary()</a></code> as reference dictionary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_time_keywords_translate(keyword = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_time_keywords_translate_+3A_keyword">keyword</code></td>
<td>
<p>(optional, character string) A time keyword such as &quot;day&quot;. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time keyword.
</p>


<h3>See Also</h3>

<p>Other internal_time_handling: 
<code><a href="#topic+utils_as_time">utils_as_time</a>()</code>,
<code><a href="#topic+utils_coerce_time_class">utils_coerce_time_class</a>()</code>,
<code><a href="#topic+utils_is_time">utils_is_time</a>()</code>,
<code><a href="#topic+utils_new_time">utils_new_time</a>()</code>,
<code><a href="#topic+utils_time_keywords">utils_time_keywords</a>()</code>,
<code><a href="#topic+utils_time_keywords_dictionary">utils_time_keywords_dictionary</a>()</code>,
<code><a href="#topic+utils_time_units">utils_time_units</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#millennia
utils_time_keywords_translate(
  keyword = "1000 years"
)

utils_time_keywords_translate(
  keyword = "1000 y"
)

utils_time_keywords_translate(
  keyword = "thousands"
)

#years
utils_time_keywords_translate(
  keyword = "year"
)

utils_time_keywords_translate(
  keyword = "y"
)

#days
utils_time_keywords_translate(
  keyword = "d"
)

utils_time_keywords_translate(
  keyword = "day"
)

#seconds
utils_time_keywords_translate(
  keyword = "s"
)

utils_time_keywords_translate(
  keyword = "sec"
)
</code></pre>

<hr>
<h2 id='utils_time_units'>Data Frame with Supported Time Units</h2><span id='topic+utils_time_units'></span>

<h3>Description</h3>

<p>Returns a data frame with the names of the supported time units, the classes that can handle each time unit, and a the threshold used to identify what time units can be used when aggregating a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_time_units(all_columns = FALSE, class = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_time_units_+3A_all_columns">all_columns</code></td>
<td>
<p>(optional, logical) If TRUE, all columns are returned. Default: FALSE</p>
</td></tr>
<tr><td><code id="utils_time_units_+3A_class">class</code></td>
<td>
<p>(optional, class name). Used to filter rows and columns. Accepted values are &quot;numeric&quot;, &quot;Date&quot;, and &quot;POSIXct&quot;. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other internal_time_handling: 
<code><a href="#topic+utils_as_time">utils_as_time</a>()</code>,
<code><a href="#topic+utils_coerce_time_class">utils_coerce_time_class</a>()</code>,
<code><a href="#topic+utils_is_time">utils_is_time</a>()</code>,
<code><a href="#topic+utils_new_time">utils_new_time</a>()</code>,
<code><a href="#topic+utils_time_keywords">utils_time_keywords</a>()</code>,
<code><a href="#topic+utils_time_keywords_dictionary">utils_time_keywords_dictionary</a>()</code>,
<code><a href="#topic+utils_time_keywords_translate">utils_time_keywords_translate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- utils_time_units()
head(df)
</code></pre>

<hr>
<h2 id='utils_tsl_pairs'>Data Frame with Pairs of Time Series in Time Series Lists</h2><span id='topic+utils_tsl_pairs'></span>

<h3>Description</h3>

<p>Internal function used in <code><a href="#topic+distantia">distantia()</a></code> and <code><a href="#topic+momentum">momentum()</a></code> to generate a data frame with combinations of time series and function arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils_tsl_pairs(tsl = NULL, args_list = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_tsl_pairs_+3A_tsl">tsl</code></td>
<td>
<p>(required, list) Time series list. Default: NULL</p>
</td></tr>
<tr><td><code id="utils_tsl_pairs_+3A_args_list">args_list</code></td>
<td>
<p>(required, list) arguments to combine with the pairs of time series. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+utils_boxplot_common">utils_boxplot_common</a>()</code>,
<code><a href="#topic+utils_check_args_distantia">utils_check_args_distantia</a>()</code>,
<code><a href="#topic+utils_check_args_matrix">utils_check_args_matrix</a>()</code>,
<code><a href="#topic+utils_check_args_momentum">utils_check_args_momentum</a>()</code>,
<code><a href="#topic+utils_check_args_path">utils_check_args_path</a>()</code>,
<code><a href="#topic+utils_check_args_tsl">utils_check_args_tsl</a>()</code>,
<code><a href="#topic+utils_check_args_zoo">utils_check_args_zoo</a>()</code>,
<code><a href="#topic+utils_check_distance_args">utils_check_distance_args</a>()</code>,
<code><a href="#topic+utils_check_list_class">utils_check_list_class</a>()</code>,
<code><a href="#topic+utils_clean_names">utils_clean_names</a>()</code>,
<code><a href="#topic+utils_digits">utils_digits</a>()</code>,
<code><a href="#topic+utils_distantia_df_split">utils_distantia_df_split</a>()</code>,
<code><a href="#topic+utils_prepare_df">utils_prepare_df</a>()</code>,
<code><a href="#topic+utils_prepare_matrix">utils_prepare_matrix</a>()</code>,
<code><a href="#topic+utils_prepare_matrix_list">utils_prepare_matrix_list</a>()</code>,
<code><a href="#topic+utils_prepare_time">utils_prepare_time</a>()</code>,
<code><a href="#topic+utils_prepare_vector_list">utils_prepare_vector_list</a>()</code>,
<code><a href="#topic+utils_prepare_zoo_list">utils_prepare_zoo_list</a>()</code>
</p>

<hr>
<h2 id='zoo_aggregate'>Aggregate Cases in Zoo Time Series</h2><span id='topic+zoo_aggregate'></span>

<h3>Description</h3>

<p>Aggregate Cases in Zoo Time Series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_aggregate(x = NULL, new_time = NULL, f = mean, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_aggregate_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Time series to aggregate. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_aggregate_+3A_new_time">new_time</code></td>
<td>
<p>(optional, zoo object, keyword, or time vector) New time to aggregate <code>x</code> to. The available options are:
</p>

<ul>
<li><p> NULL: the highest resolution keyword returned by <code>zoo_time(x)$keywords</code> is used to generate a new time vector to aggregate <code>x</code>.
</p>
</li>
<li><p> zoo object: the index of the given zoo object is used as template to aggregate <code>x</code>.
</p>
</li>
<li><p> time vector: a vector with new times to resample <code>x</code> to. If time in <code>x</code> is of class &quot;numeric&quot;, this vector must be numeric as well. Otherwise, vectors of classes &quot;Date&quot; and &quot;POSIXct&quot; can be used indistinctly.
</p>
</li>
<li><p> keyword: a valid keyword returned by <code>zoo_time(x)$keywords</code>, used to generate a time vector with the relevant units.
</p>
</li>
<li><p> numeric of length 1: interpreted as new time interval, in the highest resolution units returned by <code>zoo_time(x)$units</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="zoo_aggregate_+3A_f">f</code></td>
<td>
<p>(optional, quoted or unquoted function name) Name of a standard or custom function to aggregate numeric vectors. Typical examples are <code>mean</code>, <code>max</code>,<code>min</code>, <code>median</code>, and <code>quantile</code>. Default: <code>mean</code>.</p>
</td></tr>
<tr><td><code id="zoo_aggregate_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) additional arguments to <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#full range of calendar dates
x &lt;- zoo_simulate(
  rows = 1000,
  time_range = c(
    "0000-01-01",
    as.character(Sys.Date())
    )
)

#plot time series
if(interactive()){
  zoo_plot(x)
}


#find valid aggregation keywords
x_time &lt;- zoo_time(x)
x_time$keywords

#mean value by millennia (extreme case!!!)
x_millennia &lt;- zoo_aggregate(
  x = x,
  new_time = "millennia",
  f = mean
)

if(interactive()){
  zoo_plot(x_millennia)
}

#max value by centuries
x_centuries &lt;- zoo_aggregate(
  x = x,
  new_time = "centuries",
  f = max
)

if(interactive()){
  zoo_plot(x_centuries)
}

#quantile 0.75 value by centuries
x_centuries &lt;- zoo_aggregate(
  x = x,
  new_time = "centuries",
  f = stats::quantile,
  probs = 0.75 #argument of stats::quantile()
)

if(interactive()){
  zoo_plot(x_centuries)
}
</code></pre>

<hr>
<h2 id='zoo_name_clean'>Clean Name of a Zoo Time Series</h2><span id='topic+zoo_name_clean'></span>

<h3>Description</h3>

<p>Combines <code><a href="#topic+utils_clean_names">utils_clean_names()</a></code> and <code><a href="#topic+zoo_name_set">zoo_name_set()</a></code> to help clean, abbreviate, capitalize, and add a suffix or a prefix to the name of a zoo object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_name_clean(
  x = NULL,
  lowercase = FALSE,
  separator = "_",
  capitalize_first = FALSE,
  capitalize_all = FALSE,
  length = NULL,
  suffix = NULL,
  prefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_name_clean_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series to analyze. Default: NULL.</p>
</td></tr>
<tr><td><code id="zoo_name_clean_+3A_lowercase">lowercase</code></td>
<td>
<p>(optional, logical) If TRUE, all names are coerced to lowercase. Default: FALSE</p>
</td></tr>
<tr><td><code id="zoo_name_clean_+3A_separator">separator</code></td>
<td>
<p>(optional, character string) Separator when replacing spaces and dots. Also used to separate <code>suffix</code> and <code>prefix</code> from the main word. Default: &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="zoo_name_clean_+3A_capitalize_first">capitalize_first</code></td>
<td>
<p>(optional, logical) Indicates whether to capitalize the first letter of each name Default: FALSE.</p>
</td></tr>
<tr><td><code id="zoo_name_clean_+3A_capitalize_all">capitalize_all</code></td>
<td>
<p>(optional, logical) Indicates whether to capitalize all letters of each name Default: FALSE.</p>
</td></tr>
<tr><td><code id="zoo_name_clean_+3A_length">length</code></td>
<td>
<p>(optional, integer) Minimum length of abbreviated names. Names are abbreviated via <code><a href="base.html#topic+abbreviate">abbreviate()</a></code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="zoo_name_clean_+3A_suffix">suffix</code></td>
<td>
<p>(optional, character string) Suffix for the clean names. Default: NULL.</p>
</td></tr>
<tr><td><code id="zoo_name_clean_+3A_prefix">prefix</code></td>
<td>
<p>(optional, character string)  Prefix for the clean names. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo time series
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate zoo time series
x &lt;- zoo_simulate()

#get current name
zoo_name_get(x = x)

#change name
x &lt;- zoo_name_set(
  x = x,
  name = "My.New.name"
)

zoo_name_get(x = x)

#clean name
x &lt;- zoo_name_clean(
  x = x,
  lowercase = TRUE
)

zoo_name_get(x = x)
</code></pre>

<hr>
<h2 id='zoo_name_get'>Get Name of a Zoo Time Series</h2><span id='topic+zoo_name_get'></span>

<h3>Description</h3>

<p>Just a convenient wrapper of <code>attributes(x)$name</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_name_get(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_name_get_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series to analyze. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate zoo time series
x &lt;- zoo_simulate()

#get current name
zoo_name_get(x = x)

#change name
x &lt;- zoo_name_set(
  x = x,
  name = "My.New.name"
)

zoo_name_get(x = x)

#clean name
x &lt;- zoo_name_clean(
  x = x,
  lowercase = TRUE
)

zoo_name_get(x = x)
</code></pre>

<hr>
<h2 id='zoo_name_set'>Set Name of a Zoo Time Series</h2><span id='topic+zoo_name_set'></span>

<h3>Description</h3>

<p>Zoo time series do not have an attribute 'name'. However, within <code>distantia</code>,  to keep data consistency in several plotting and analysis operations, an attribute 'name' is used for these objects. This function is a convenient wrapper of <code>attr(x = x, which = "name") &lt;- "xxx"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_name_set(x = NULL, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_name_set_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series to analyze. Default: NULL.</p>
</td></tr>
<tr><td><code id="zoo_name_set_+3A_name">name</code></td>
<td>
<p>(required, character string) name or new name of the zoo object. If NULL, <code>x</code> is returned as is. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo time series
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate zoo time series
x &lt;- zoo_simulate()

#get current name
zoo_name_get(x = x)

#change name
x &lt;- zoo_name_set(
  x = x,
  name = "My.New.name"
)

zoo_name_get(x = x)

#clean name
x &lt;- zoo_name_clean(
  x = x,
  lowercase = TRUE
)

zoo_name_get(x = x)
</code></pre>

<hr>
<h2 id='zoo_permute'>Random or Restricted Permutation of Zoo Time Series</h2><span id='topic+zoo_permute'></span>

<h3>Description</h3>

<p>Fast permutation of zoo time series for null model testing using a fast and efficient C++ implementations of different restricted and free permutation methods.
</p>
<p>The available permutation methods are:
</p>

<ul>
<li><p> &quot;free&quot; (see <code><a href="#topic+permute_free_cpp">permute_free_cpp()</a></code>): Unrestricted and independent re-shuffling of individual cases across rows and columns. Individual values are relocated to a new row and column within the dimensions of the original matrix.
</p>
</li>
<li><p> &quot;free_by_row&quot; (see <code><a href="#topic+permute_free_by_row_cpp">permute_free_by_row_cpp()</a></code>): Unrestricted re-shuffling of complete rows. Each individual row is given a new random row number, and the data  matrix is re-ordered accordingly.
</p>
</li>
<li><p> &quot;restricted&quot; (see <code><a href="#topic+permute_restricted_cpp">permute_restricted_cpp()</a></code>): Data re-shuffling across rows and columns is restricted to blocks of contiguous rows. The algorithm divides the data matrix into a set of blocks of contiguous rows, and individual cases are then assigned to a new row and column within their original block.
</p>
</li>
<li><p> &quot;restricted_by_row&quot; (see <code><a href="#topic+permute_restricted_by_row_cpp">permute_restricted_by_row_cpp()</a></code>): Re-shuffling of complete rows is restricted to blocks of contiguous rows. The algorithm divides the data matrix into a set of blocks of contiguous rows, each individual row is given a new random row number within its original block, and the block is reordered accordingly to generate the permuted output.
</p>
</li></ul>

<p>This function supports a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code>, and progress bars provided by the package <a href="https://CRAN.R-project.org/package=progressr">progressr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_permute(
  x = NULL,
  repetitions = 1L,
  permutation = "restricted_by_row",
  block_size = NULL,
  seed = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_permute_+3A_x">x</code></td>
<td>
<p>(required, zoo object) zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_permute_+3A_repetitions">repetitions</code></td>
<td>
<p>(optional, integer) number of permutations to compute. Large numbers may compromise your R session. Default: 1</p>
</td></tr>
<tr><td><code id="zoo_permute_+3A_permutation">permutation</code></td>
<td>
<p>(optional, character string) permutation method. Valid values are listed below from higher to lower induced randomness:
</p>

<ul>
<li><p> &quot;free&quot;: unrestricted re-shuffling of individual cases across rows and columns. Ignores block_size.
</p>
</li>
<li><p> &quot;free_by_row&quot;: unrestricted re-shuffling of complete rows. Ignores block size.
</p>
</li>
<li><p> &quot;restricted&quot;: restricted shuffling across rows and columns within blocks of rows.
</p>
</li>
<li><p> &quot;restricted_by_row&quot;: restricted re-shuffling of rows within blocks.
</p>
</li></ul>
</td></tr>
<tr><td><code id="zoo_permute_+3A_block_size">block_size</code></td>
<td>
<p>(optional, integer) Block size in number of rows for restricted permutations. Only relevant when permutation methods are &quot;restricted&quot; or &quot;restricted_by_row&quot;. A block of size <code>n</code> indicates that the original data is pre-divided into blocks of such size, and a given row can only be permuted within their original block. If NULL, defaults to the rounded one tenth of the number of rows in <code>x</code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="zoo_permute_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) initial random seed to use during permutations. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time Series List
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#simulate zoo time series
x &lt;- zoo_simulate(cols = 2)

if(interactive()){
  zoo_plot(x)
}

#free
x_free &lt;- zoo_permute(
  x = x,
  permutation = "free",
  repetitions = 2
)

if(interactive()){
  tsl_plot(
    tsl = x_free,
    guide = FALSE
    )
}

#free by row
x_free_by_row &lt;- zoo_permute(
  x = x,
  permutation = "free_by_row",
  repetitions = 2
)

if(interactive()){
  tsl_plot(
    tsl = x_free_by_row,
    guide = FALSE
  )
}

#restricted
x_restricted &lt;- zoo_permute(
  x = x,
  permutation = "restricted",
  repetitions = 2
)

if(interactive()){
  tsl_plot(
    tsl = x_restricted,
    guide = FALSE
  )
}

#restricted by row
x_restricted_by_row &lt;- zoo_permute(
  x = x,
  permutation = "restricted_by_row",
  repetitions = 2
)

if(interactive()){
  tsl_plot(
    tsl = x_restricted_by_row,
    guide = FALSE
  )
}

</code></pre>

<hr>
<h2 id='zoo_plot'>Plot Zoo Time Series</h2><span id='topic+zoo_plot'></span>

<h3>Description</h3>

<p>Plot Zoo Time Series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_plot(
  x = NULL,
  line_color = NULL,
  line_width = 1,
  xlim = NULL,
  ylim = NULL,
  title = NULL,
  xlab = NULL,
  ylab = NULL,
  text_cex = 1,
  guide = TRUE,
  guide_position = "topright",
  guide_cex = 0.8,
  vertical = FALSE,
  subpanel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_plot_+3A_x">x</code></td>
<td>
<p>(required, zoo object) zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_line_color">line_color</code></td>
<td>
<p>(optional, character vector) vector of colors for the distance or cost matrix. If NULL, uses an appropriate palette generated with <code><a href="grDevices.html#topic+palette">grDevices::palette.colors()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_line_width">line_width</code></td>
<td>
<p>(optional, numeric vector) Width of the time series lines. Default: 1</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_xlim">xlim</code></td>
<td>
<p>(optional, numeric vector) Numeric vector with the limits of the x axis. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_ylim">ylim</code></td>
<td>
<p>(optional, numeric vector) Numeric vector with the limits of the x axis. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_title">title</code></td>
<td>
<p>(optional, character string) Main title of the plot. If NULL, it's set to the name of the time series. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_xlab">xlab</code></td>
<td>
<p>(optional, character string) Title of the x axis. Disabled if <code>subpanel</code> or <code>vertical</code> are TRUE. If NULL, the word &quot;Time&quot; is used. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_ylab">ylab</code></td>
<td>
<p>(optional, character string) Title of the x axis. Disabled if <code>subpanel</code> or <code>vertical</code> are TRUE. If NULL, it is left empty. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_text_cex">text_cex</code></td>
<td>
<p>(optional, numeric) Multiplicator of the text size. Default: 1</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_guide">guide</code></td>
<td>
<p>(optional, logical) If TRUE, plots a legend. Default: TRUE</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_guide_position">guide_position</code></td>
<td>
<p>(optional, vector of xy coordinates or character string). This is a condensed version of the <code>x</code> and <code>y</code> arguments of the <code><a href="graphics.html#topic+legend">graphics::legend()</a></code> function. Coordinates (in the range 0 1) or keyword to position the legend. Accepted keywords are: &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;. Default: &quot;topright&quot;.</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_guide_cex">guide_cex</code></td>
<td>
<p>(optional, numeric) Size of the guide's text and separation between the guide's rows. Default: 0.7.</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_vertical">vertical</code></td>
<td>
<p>(optional, logical) For internal use within the package in multipanel plots. Switches the plot axes. Disabled if <code>subpanel = FALSE</code>. Default: FALSE</p>
</td></tr>
<tr><td><code id="zoo_plot_+3A_subpanel">subpanel</code></td>
<td>
<p>(optional, logical) For internal use within the package in multipanel plots. Strips down the plot for a sub-panel. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#simulate zoo time series
x &lt;- zoo_simulate()

if(interactive()){

  zoo_plot(
    x = x,
    xlab = "Date",
    ylab = "Value",
    title = "My time series"
  )

}
</code></pre>

<hr>
<h2 id='zoo_resample'>Resample Zoo Objects to a New Time</h2><span id='topic+zoo_resample'></span>

<h3>Description</h3>

<p><strong>Objective</strong>
</p>
<p>Time series resampling involves interpolating new values for time steps not available in the original time series. This operation is useful to:
</p>

<ul>
<li><p> Transform irregular time series into regular.
</p>
</li>
<li><p> Align time series with different temporal resolutions.
</p>
</li>
<li><p> Increase (upsampling) or decrease (downsampling) the temporal resolution of a time series.
</p>
</li></ul>

<p>On the other hand, time series resampling <strong>should not be used</strong> to extrapolate new values outside of the original time range of the time series, or to increase the resolution of a time series by a factor of two or more. These operations are known to produce non-sensical results.
</p>
<p><strong>Methods</strong>
This function offers three methods for time series interpolation:
</p>

<ul>
<li><p> &quot;linear&quot; (default): interpolation via piecewise linear regression as implemented in <code><a href="zoo.html#topic+na.approx">zoo::na.approx()</a></code>.
</p>
</li>
<li><p> &quot;spline&quot;: cubic smoothing spline regression as implemented in <code><a href="stats.html#topic+smooth.spline">stats::smooth.spline()</a></code>.
</p>
</li>
<li><p> &quot;loess&quot;: local polynomial regression fitting as implemented in <code><a href="stats.html#topic+loess">stats::loess()</a></code>.
</p>
</li></ul>

<p>These methods are used to fit models <code>y ~ x</code> where <code>y</code> represents the values of a univariate time series and <code>x</code> represents a numeric version of its time.
</p>
<p>The functions <code><a href="#topic+utils_optimize_spline">utils_optimize_spline()</a></code> and <code><a href="#topic+utils_optimize_loess">utils_optimize_loess()</a></code> are used under the hood to optimize the complexity of the methods &quot;spline&quot; and &quot;loess&quot; by finding the configuration that minimizes the root mean squared error (RMSE) between  observed and predicted <code>y</code>. However, when the argument <code>max_complexity = TRUE</code>, the complexity optimization is ignored, and a maximum complexity model is used instead.
</p>
<p><strong>New time</strong>
</p>
<p>The argument <code>new_time</code> offers several alternatives to help define the new time of the resulting time series:
</p>

<ul>
<li> <p><code>NULL</code>: the target time series (<code>x</code>) is resampled to a regular time within its original time range and number of observations.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;zoo object&#8288;</code>: a zoo object to be used as template for resampling. Useful when the objective is equalizing the frequency of two separate zoo objects.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;time vector&#8288;</code>: a time vector of a class compatible with the time in <code>x</code>.
</p>
</li>
<li> <p><code>keyword</code>: character string defining a resampling keyword, obtained via <code>zoo_time(x, keywords = "resample")$keywords</code>..
</p>
</li>
<li> <p><code>numeric</code>: a single number representing the desired interval between consecutive samples in the units of <code>x</code> (relevant units can be obtained via <code>zoo_time(x)$units</code>).
</p>
</li></ul>

<p><strong>Step by Step</strong>
</p>
<p>The steps to resample a time series list are:
</p>

<ol>
<li><p> The time interpolation range taken from the index of the zoo object. This step ensures that no extrapolation occurs during resampling.
</p>
</li>
<li><p> If <code>new_time</code> is provided, any values of <code>new_time</code> outside of the minimum and maximum interpolation times are removed to avoid extrapolation. If <code>new_time</code> is not provided, a regular time within the interpolation time range of the zoo object is generated.
</p>
</li>
<li><p> For each univariate time time series, a model <code>y ~ x</code>, where <code>y</code> is the time series and <code>x</code> is its own time coerced to numeric is fitted.
</p>

<ul>
<li><p> If <code>max_complexity == FALSE</code> and <code>method = "spline"</code> or <code>method = "loess"</code>, the model with the complexity that minimizes the root mean squared error between the observed and predicted <code>y</code> is returned.
</p>
</li>
<li><p> If <code>max_complexity == TRUE</code> and <code>method = "spline"</code> or <code>method = "loess"</code>, the first valid model closest to a maximum complexity is returned.
</p>
</li></ul>

</li>
<li><p> The fitted model is predicted over <code>new_time</code> to generate the resampled time series.
</p>
</li></ol>

<p><strong>Other Details</strong>
</p>
<p>Please use this operation with care, as there are limits to the amount of resampling that can be done without distorting the data. The safest option is to keep the distance between new time points within the same magnitude of the distance between the old time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_resample(
  x = NULL,
  new_time = NULL,
  method = "linear",
  max_complexity = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_resample_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Time series to resample. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_resample_+3A_new_time">new_time</code></td>
<td>
<p>(optional, zoo object, keyword, or time vector) New time to resample <code>x</code> to. The available options are:
</p>

<ul>
<li><p> NULL: a regular version of the time in <code>x</code> is generated and used for resampling.
</p>
</li>
<li><p> zoo object: the index of the given zoo object is used as template to resample <code>x</code>.
</p>
</li>
<li><p> time vector: a vector with new times to resample <code>x</code> to. If time in <code>x</code> is of class &quot;numeric&quot;, this vector must be numeric as well. Otherwise, vectors of classes &quot;Date&quot; and &quot;POSIXct&quot; can be used indistinctly.
</p>
</li>
<li><p> keyword: a valid keyword returned by <code>zoo_time(x)$keywords</code>, used to generate a time vector with the relevant units.
</p>
</li>
<li><p> numeric of length 1: interpreted as new time interval, in the highest resolution units returned by <code>zoo_time(x)$units</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="zoo_resample_+3A_method">method</code></td>
<td>
<p>(optional, character string) Name of the method to resample the time series. One of &quot;linear&quot;, &quot;spline&quot; or &quot;loess&quot;. Default: &quot;linear&quot;.</p>
</td></tr>
<tr><td><code id="zoo_resample_+3A_max_complexity">max_complexity</code></td>
<td>
<p>(required, logical). Only relevant for methods &quot;spline&quot; and &quot;loess&quot;. If TRUE, model optimization is ignored, and the a model of maximum complexity (an overfitted model) is used for resampling. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate irregular time series
x &lt;- zoo_simulate(
  cols = 2,
  rows = 50,
  time_range = c("2010-01-01", "2020-01-01"),
  irregular = TRUE
  )

#plot time series
if(interactive()){
  zoo_plot(x)
}

#intervals between samples
x_intervals &lt;- diff(zoo::index(x))
x_intervals

#create regular time from the minimum of the observed intervals
new_time &lt;- seq.Date(
  from = min(zoo::index(x)),
  to = max(zoo::index(x)),
  by = floor(min(x_intervals))
)

new_time
diff(new_time)

#resample using piecewise linear regression
x_linear &lt;- zoo_resample(
  x = x,
  new_time = new_time,
  method = "linear"
)

#resample using max complexity splines
x_spline &lt;- zoo_resample(
  x = x,
  new_time = new_time,
  method = "spline",
  max_complexity = TRUE
)

#resample using max complexity loess
x_loess &lt;- zoo_resample(
  x = x,
  new_time = new_time,
  method = "loess",
  max_complexity = TRUE
)


#intervals between new samples
diff(zoo::index(x_linear))
diff(zoo::index(x_spline))
diff(zoo::index(x_loess))

#plotting results
if(interactive()){

  par(mfrow = c(4, 1), mar = c(3,3,2,2))

  zoo_plot(
    x,
    guide = FALSE,
    title = "Original"
    )

  zoo_plot(
    x_linear,
    guide = FALSE,
    title = "Method: linear"
  )

  zoo_plot(
    x_spline,
    guide = FALSE,
    title = "Method: spline"
    )

  zoo_plot(
    x_loess,
    guide = FALSE,
    title = "Method: loess"
  )

}

</code></pre>

<hr>
<h2 id='zoo_simulate'>Simulate a Zoo Time Series</h2><span id='topic+zoo_simulate'></span>

<h3>Description</h3>

<p>Generates simulated zoo time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_simulate(
  name = "A",
  cols = 5,
  rows = 100,
  time_range = c("2010-01-01", "2020-01-01"),
  data_range = c(0, 1),
  seasons = 0,
  na_fraction = 0,
  independent = FALSE,
  irregular = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_simulate_+3A_name">name</code></td>
<td>
<p>(optional, character string) Name of the zoo object, to be stored in the attribute &quot;name&quot;. Default: &quot;A&quot;</p>
</td></tr>
<tr><td><code id="zoo_simulate_+3A_cols">cols</code></td>
<td>
<p>(optional, integer) Number of time series. Default: 5</p>
</td></tr>
<tr><td><code id="zoo_simulate_+3A_rows">rows</code></td>
<td>
<p>(optional, integer) Length of the time series. Minimum is 10, but maximum is not limited. Very large numbers might crash the R session. Default: 100</p>
</td></tr>
<tr><td><code id="zoo_simulate_+3A_time_range">time_range</code></td>
<td>
<p>(optional character or numeric vector) Interval of the time series. Either a character vector with dates in format YYYY-MM-DD or or a numeric vector. If there is a mismatch between <code>time_range</code> and <code>rows</code> (for example, the number of days in <code>time_range</code> is smaller than <code>rows</code>), the upper value in <code>time_range</code> is adapted to <code>rows</code>. Default: c(&quot;2010-01-01&quot;, &quot;2020-01-01&quot;)</p>
</td></tr>
<tr><td><code id="zoo_simulate_+3A_data_range">data_range</code></td>
<td>
<p>(optional, numeric vector of length 2) Extremes of the simulated time series values. The simulated time series are independently adjusted to random values within the provided range. Default: c(0, 1)</p>
</td></tr>
<tr><td><code id="zoo_simulate_+3A_seasons">seasons</code></td>
<td>
<p>(optional, integer) Number of seasons in the resulting time series. The maximum number of seasons is computed as <code>floor(rows/3)</code>. Default: 0</p>
</td></tr>
<tr><td><code id="zoo_simulate_+3A_na_fraction">na_fraction</code></td>
<td>
<p>(optional, numeric) Value between 0 and 0.5 indicating the approximate fraction of NA data in the simulated time series. Default: 0.</p>
</td></tr>
<tr><td><code id="zoo_simulate_+3A_independent">independent</code></td>
<td>
<p>(optional, logical) If TRUE, each new column in a simulated time series is averaged with the previous column. Irrelevant when <code>cols &lt;= 2</code>, and hard to perceive in the output when <code>seasons &gt; 0</code>. Default: FALSE</p>
</td></tr>
<tr><td><code id="zoo_simulate_+3A_irregular">irregular</code></td>
<td>
<p>(optional, logical) If TRUE, the time series is created with 20 percent more rows, and a random 20 percent of rows are removed at random. Default: TRUE</p>
</td></tr>
<tr><td><code id="zoo_simulate_+3A_seed">seed</code></td>
<td>
<p>(optional, integer) Random seed used to simulate the zoo object. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other simulate_time_series: 
<code><a href="#topic+tsl_simulate">tsl_simulate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generates a different time series on each execution when 'seed = NULL'
x &lt;- zoo_simulate()

#returns a zoo object
class(x)

#time series names are uppercase letters
#this attribute is not defined in the zoo class and might be lost during data transformations
attributes(x)$name

#column names are lowercase letters
names(x)

#plotting methods
if(interactive()){

  #plot time series with default zoo method
  plot(x)

  #plot time series with distantia
  zoo_plot(
    x = x,
    xlab = "Date",
    ylab = "Value",
    title = "My time series"
  )

}
</code></pre>

<hr>
<h2 id='zoo_smooth_exponential'>Exponential Smoothing of Zoo Time Series</h2><span id='topic+zoo_smooth_exponential'></span>

<h3>Description</h3>

<p>Applies exponential smoothing to a zoo time series object, where each value is a weighted average of the current value and past smoothed values. This method is useful for reducing noise in time series data while preserving the general trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_smooth_exponential(x = NULL, alpha = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_smooth_exponential_+3A_x">x</code></td>
<td>
<p>(required, zoo object) time series to smooth Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_smooth_exponential_+3A_alpha">alpha</code></td>
<td>
<p>(required, numeric) Smoothing factor in the range (0, 1]. Determines the weight of the current value relative to past values. A higher value gives more weight to recent observations, while a lower value gives more weight to past observations. Default: 0.2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate()

x_smooth &lt;- zoo_smooth_exponential(
  x = x,
  alpha = 0.2
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(x_smooth)
}
</code></pre>

<hr>
<h2 id='zoo_smooth_window'>Rolling Window Smoothing of Zoo Time Series</h2><span id='topic+zoo_smooth_window'></span>

<h3>Description</h3>

<p>Just a fancy wrapper for <code><a href="zoo.html#topic+rollapply">zoo::rollapply()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_smooth_window(x = NULL, window = 3, f = mean, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_smooth_window_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Time series to smooth Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_smooth_window_+3A_window">window</code></td>
<td>
<p>(optional, integer) Smoothing window width, in number of cases. Default: 3</p>
</td></tr>
<tr><td><code id="zoo_smooth_window_+3A_f">f</code></td>
<td>
<p>(optional, quoted or unquoted function name) Name of a standard or custom function to aggregate numeric vectors. Typical examples are <code>mean</code>, <code>max</code>,<code>min</code>, <code>median</code>, and <code>quantile</code>. Default: <code>mean</code>.</p>
</td></tr>
<tr><td><code id="zoo_smooth_window_+3A_...">...</code></td>
<td>
<p>(optional, additional arguments) additional arguments to <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo object
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- zoo_simulate()

x_smooth &lt;- zoo_smooth_window(
  x = x,
  window = 5,
  f = mean
)

if(interactive()){
  zoo_plot(x)
  zoo_plot(x_smooth)
}
</code></pre>

<hr>
<h2 id='zoo_time'>Get Time Features from Zoo Objects</h2><span id='topic+zoo_time'></span>

<h3>Description</h3>

<p>This function generates a data frame summarizing the time features (class, length, resolution, and others) of zoo time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_time(x = NULL, keywords = c("resample", "aggregate"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_time_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Zoo time series to analyze. Default: NULL.</p>
</td></tr>
<tr><td><code id="zoo_time_+3A_keywords">keywords</code></td>
<td>
<p>(optional, character string or vector) Defines what keywords are returned. If &quot;aggregate&quot;, returns valid keywords for <code><a href="#topic+zoo_aggregate">zoo_aggregate()</a></code>. If &quot;resample&quot;, returns valid keywords for <code><a href="#topic+zoo_resample">zoo_resample()</a></code>. If both, returns all valid keywords. Default: c(&quot;aggregate&quot;, &quot;resample&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the following columns:
</p>

<ul>
<li> <p><code>name</code> (string): time series name.
</p>
</li>
<li> <p><code>rows</code> (integer): number of observations.
</p>
</li>
<li> <p><code>class</code> (string): time class, one of &quot;Date&quot;, &quot;POSIXct&quot;, or &quot;numeric.&quot;
</p>
</li>
<li> <p><code>units</code> (string): units of the time series.
</p>
</li>
<li> <p><code>length</code> (numeric): total length of the time series expressed in <code>units</code>.
</p>
</li>
<li> <p><code>resolution</code> (numeric): average interval between observations expressed in <code>units</code>.
</p>
</li>
<li> <p><code>begin</code> (date or numeric): begin time of the time series.
</p>
</li>
<li> <p><code>end</code> (date or numeric): end time of the time series.
</p>
</li>
<li> <p><code>keywords</code> (character vector): valid keywords for <code><a href="#topic+tsl_aggregate">tsl_aggregate()</a></code> or <code><a href="#topic+tsl_resample">tsl_resample()</a></code>, depending on the value of the argument <code>keywords</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simulate a zoo time series
x &lt;- zoo_simulate(
  rows = 150,
  time_range = c(
    Sys.Date() - 365,
    Sys.Date()
  ),
  irregular = TRUE
)

#time data frame
zoo_time(
  x = x
)
</code></pre>

<hr>
<h2 id='zoo_to_tsl'>Convert Individual Zoo Objects to Time Series List</h2><span id='topic+zoo_to_tsl'></span>

<h3>Description</h3>

<p>Internal function to wrap a zoo object into a time series list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_to_tsl(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_to_tsl_+3A_x">x</code></td>
<td>
<p>(required, zoo object) Time series. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time series list of length one.
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_vector_to_matrix">zoo_vector_to_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create zoo object
x &lt;- zoo_simulate()
class(x)

#to time series list
tsl &lt;- zoo_to_tsl(
  x = x
)

class(tsl)
class(tsl[[1]])
names(tsl)
attributes(tsl[[1]])$name
</code></pre>

<hr>
<h2 id='zoo_vector_to_matrix'>Coerce Coredata of Univariate Zoo Time Series to Matrix</h2><span id='topic+zoo_vector_to_matrix'></span>

<h3>Description</h3>

<p>Transforms vector coredata of univariate zoo time series to class matrix. If the input zoo time series has the attribute &quot;name&quot;, the output inherits the value of such attribute.
</p>
<p>Multivariate zoo objects are returned without changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_vector_to_matrix(x = NULL, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_vector_to_matrix_+3A_x">x</code></td>
<td>
<p>(required, zoo object) zoo time series. Default: NULL</p>
</td></tr>
<tr><td><code id="zoo_vector_to_matrix_+3A_name">name</code></td>
<td>
<p>(required, character string) name of the matrix column. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoo time series
</p>


<h3>See Also</h3>

<p>Other zoo_functions: 
<code><a href="#topic+zoo_aggregate">zoo_aggregate</a>()</code>,
<code><a href="#topic+zoo_name_clean">zoo_name_clean</a>()</code>,
<code><a href="#topic+zoo_name_get">zoo_name_get</a>()</code>,
<code><a href="#topic+zoo_name_set">zoo_name_set</a>()</code>,
<code><a href="#topic+zoo_permute">zoo_permute</a>()</code>,
<code><a href="#topic+zoo_plot">zoo_plot</a>()</code>,
<code><a href="#topic+zoo_resample">zoo_resample</a>()</code>,
<code><a href="#topic+zoo_smooth_exponential">zoo_smooth_exponential</a>()</code>,
<code><a href="#topic+zoo_smooth_window">zoo_smooth_window</a>()</code>,
<code><a href="#topic+zoo_time">zoo_time</a>()</code>,
<code><a href="#topic+zoo_to_tsl">zoo_to_tsl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create zoo object from vector
x &lt;- zoo::zoo(
  x = runif(100)
)

#coredata is not a matrix
is.matrix(zoo::coredata(x))

#convert to matrix
y &lt;- zoo_vector_to_matrix(
  x = x
)

#coredata is now a matrix
is.matrix(zoo::coredata(y))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
