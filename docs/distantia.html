<!DOCTYPE html><html><head><title>Help for package distantia</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distantia}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autoSum'><p>Computes sum of distances between consecutive samples in a multivariate time-series.</p></a></li>
<li><a href='#climate'><p>Dataframe with palaeoclimatic data.</p></a></li>
<li><a href='#climateLong'><p>Dataframe with palaeoclimatic data.</p></a></li>
<li><a href='#climateShort'><p>Dataframe with palaeoclimatic data.</p></a></li>
<li><a href='#distance'><p>Computes a multivariate distance between two vectors.</p></a></li>
<li><a href='#distanceMatrix'><p>Computes distance matrices among the samples of two or more multivariate time-series.</p></a></li>
<li><a href='#distancePairedSamples'><p>Computes distance among pairs of aligned samples in two or more multivariate time-series.</p></a></li>
<li><a href='#distantia-package'><p>distantia: Assessing Dissimilarity Between Multivariate Time Series</p></a></li>
<li><a href='#formatPsi'><p>Formats the output of <code>psi</code>.</p></a></li>
<li><a href='#handleNA'><p>Handles emtpy and NA data in a multivariate time series.</p></a></li>
<li><a href='#leastCost'><p>Extracts the least cost from a least-cost path.</p></a></li>
<li><a href='#leastCostMatrix'><p>Computes a least cost matrix from a distance matrix.</p></a></li>
<li><a href='#leastCostPath'><p>Find the least cost path in a least cost matrix.</p></a></li>
<li><a href='#leastCostPathNoBlocks'><p>Extracts the least-cost from a least cost matrix by trimming blocks.</p></a></li>
<li><a href='#plotMatrix'><p>Plots distance matrices and least cost paths.</p></a></li>
<li><a href='#pollenGP'><p>Pollen dataset.</p></a></li>
<li><a href='#prepareSequences'><p>Prepare sequences for a comparison analysis.</p></a></li>
<li><a href='#psi'><p>Computes sum of distances between consecutive samples in a multivariate time-series.</p></a></li>
<li><a href='#sequenceA'><p>Multivariate and irregular time series with pollen counts.</p></a></li>
<li><a href='#sequenceB'><p>Multivariate and irregular time series with pollen counts.</p></a></li>
<li><a href='#sequencesMIS'><p>Dataframe with pollen counts for different MIS stages.</p></a></li>
<li><a href='#workflowImportance'><p>Computes the contribution to dissimilarity of each variable.</p></a></li>
<li><a href='#workflowImportanceHP'><p>Computes the contribution to dissimilarity of each variable using workflowPsiHP.</p></a></li>
<li><a href='#workflowNullPsi'><p>Computes the dissimilarity measure <em>psi</em> on restricted permutations of two or more sequences.</p></a></li>
<li><a href='#workflowNullPsiHP'><p>Computes the dissimilarity measure <em>psi</em> on restricted permutations of two or more sequences. High performance version with limited options</p></a></li>
<li><a href='#workflowPartialMatch'><p>Finds the section in a long sequence that better matches a short sequence.</p></a></li>
<li><a href='#workflowPsi'><p>Computes the dissimilarity measure <em>psi</em> on two or more sequences.</p></a></li>
<li><a href='#workflowPsiHP'><p>A refactored version of <code>workflowPsi</code> with a higher performance (hence the suffix HP).</p></a></li>
<li><a href='#workflowSlotting'><p>Slots two sequences into a single composite sequence.</p></a></li>
<li><a href='#workflowTransfer'><p>Transfers an attribute (time, age, depth) from one sequence to another</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Assessing Dissimilarity Between Multivariate Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Blas M. Benito</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://blasbenito.github.io/distantia/">https://blasbenito.github.io/distantia/</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Blas M. Benito &lt;blasbenito@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools to assess the dissimilarity between multivariate time-series. It is based on the psi measure described  by Birks and Gordon (1985 &lt;<a href="https://doi.org/10.1002%2Fjqs.3390020110">doi:10.1002/jqs.3390020110</a>&gt;), which computes dissimilarity between irregular time-series constrained by sample order. However, in this package the original idea has been extended to work with any kind of multivariate time-series, no matter whether they are regular, irregular, aligned or unaligned. Furthermore, the package allows to assess the significance of dissimilarity values by applying a restricted permutation test, allows to measure the contribution of individual variables to dissimilarity, and offers tools to transfer attributes (generally time or age, but other are possible) between sequences based on the similarity of their samples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, grDevices, foreach, parallel, doParallel, fields,
viridis, RColorBrewer, data.table, iterators, arrangements</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, formatR, kableExtra, magrittr, knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-10-28 19:27:28 UTC; blas</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-10-28 23:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='autoSum'>Computes sum of distances between consecutive samples in a multivariate time-series.</h2><span id='topic+autoSum'></span>

<h3>Description</h3>

<p>Computes the sum of distances between consecutive samples in a multivariate time-series. Required to compute the measure of dissimilarity <code>psi</code> (Birks and Gordon 1985). Distances can be computed through the methods &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;, and are implemented in the function <code><a href="#topic+distance">distance</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoSum(
  sequences = NULL,
  least.cost.path = NULL,
  time.column = NULL,
  grouping.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoSum_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with one or several multivariate time-series identified by a grouping column.</p>
</td></tr>
<tr><td><code id="autoSum_+3A_least.cost.path">least.cost.path</code></td>
<td>
<p>a list usually resulting from either <code><a href="#topic+leastCostPath">leastCostPath</a></code> or <code><a href="#topic+leastCostPathNoBlocks">leastCostPathNoBlocks</a></code>.</p>
</td></tr>
<tr><td><code id="autoSum_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data. The data in this column is not modified.</p>
</td></tr>
<tr><td><code id="autoSum_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file. This argument is ignored if <code>sequence.A</code> and <code>sequence.B</code> are provided.</p>
</td></tr>
<tr><td><code id="autoSum_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code>, or <code>squence.A</code> and <code>sequence.B</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="autoSum_+3A_method">method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;. Invalid entries will throw an error.</p>
</td></tr>
<tr><td><code id="autoSum_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distances are computed as:
</p>

<ul>
<li> <p><code>manhattan</code>: <code>d &lt;- sum(abs(x - y))</code>
</p>
</li>
<li> <p><code>euclidean</code>: <code>d &lt;- sqrt(sum((x - y)^2))</code>
</p>
</li>
<li> <p><code>chi</code>: <code>
    xy &lt;- x + y
    y. &lt;- y / sum(y)
    x. &lt;- x / sum(x)
    d &lt;- sqrt(sum(((x. - y.)^2) / (xy / sum(xy))))</code>
</p>
</li>
<li> <p><code>hellinger</code>: <code>d &lt;- sqrt(1/2 * sum(sqrt(x) - sqrt(y))^2)</code>
</p>
</li></ul>

<p>Note that zeroes are replaced by 0.00001 whem <code>method</code> equals &quot;chi&quot; or &quot;hellinger&quot;.
</p>


<h3>Value</h3>

<p>A list with slots named according <code>grouping.column</code> if there are several sequences in <code>sequences</code> or a number if there is only one sequence.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>

<ul>
<li><p> Birks, H.J.B.  and Gordon, A.D. (1985) Numerical Methods in Quaternary Pollen Analysis. Academic Press.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#loading data
data(sequenceA)
data(sequenceB)

#preparing datasets
AB.sequences &lt;- prepareSequences(
 sequence.A = sequenceA,
 sequence.A.name = "A",
 sequence.B = sequenceB,
 sequence.B.name = "B",
 merge.mode = "complete",
 if.empty.cases = "zero",
 transformation = "hellinger"
 )

#computing distance matrix
AB.distance.matrix &lt;- distanceMatrix(
 sequences = AB.sequences,
 grouping.column = "id",
 method = "manhattan",
 parallel.execution = FALSE
 )

#computing least cost matrix
AB.least.cost.matrix &lt;- leastCostMatrix(
 distance.matrix = AB.distance.matrix,
 diagonal = FALSE,
 parallel.execution = FALSE
 )

AB.least.cost.path &lt;- leastCostPath(
 distance.matrix = AB.distance.matrix,
 least.cost.matrix = AB.least.cost.matrix,
 parallel.execution = FALSE
 )

#autosum
AB.autosum &lt;- autoSum(
 sequences = AB.sequences,
 least.cost.path = AB.least.cost.path,
 grouping.column = "id",
 parallel.execution = FALSE
 )
AB.autosum



</code></pre>

<hr>
<h2 id='climate'>Dataframe with palaeoclimatic data.</h2><span id='topic+climate'></span>

<h3>Description</h3>

<p>A dataframe containing palaeoclimate data at 1 ky temporal resolution with the following columns:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(climate)
</code></pre>


<h3>Format</h3>

<p>dataframe with 6 columns and 800 rows.</p>


<h3>Details</h3>


<ul>
<li> <p><em>time</em> in kiloyears before present (ky BP).
</p>
</li>
<li> <p><em>sequenceId</em> numeric identifier of sequences of 200ky within the main sequence, useful to test some functions of the package, such as <code><a href="#topic+distancePairedSamples">distancePairedSamples</a></code>
</p>
</li>
<li> <p><em>temperatureAverage</em> average annual temperature in Celsius degrees.
</p>
</li>
<li> <p><em>rainfallAverage</em> average annual precipitation in milimetres per day (mm/day).
</p>
</li>
<li> <p><em>temperatureWarmestMonth</em> average temperature of the warmest month, in Celsius degrees.
</p>
</li>
<li> <p><em>temperatureColdestMonth</em> average temperature of the coldest month, in Celsius degrees.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>

<hr>
<h2 id='climateLong'>Dataframe with palaeoclimatic data.</h2><span id='topic+climateLong'></span>

<h3>Description</h3>

<p>A dataframe containing 800 simulated samples of palaeoclimate data at 1 ky temporal resolution with the following columns:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(climateLong)
</code></pre>


<h3>Format</h3>

<p>dataframe with 6 columns and 800 rows.</p>


<h3>Details</h3>


<ul>
<li> <p><em>age</em> in kiloyears before present (ky BP).
</p>
</li>
<li> <p><em>temperatureAverage</em> average annual temperature in Celsius degrees.
</p>
</li>
<li> <p><em>rainfallAverage</em> average annual precipitation in milimetres per day (mm/day).
</p>
</li>
<li> <p><em>temperatureWarmestMonth</em> average temperature of the warmest month, in Celsius degrees.
</p>
</li>
<li> <p><em>temperatureColdestMonth</em> average temperature of the coldest month, in Celsius degrees.
</p>
</li>
<li> <p><em>oxigenIsotope</em> delta O18, global ratio of stable isotopes in the sea floor, see <a href="http://lorraine-lisiecki.com/stack.html">http://lorraine-lisiecki.com/stack.html</a> for further details.
</p>
</li></ul>


<hr>
<h2 id='climateShort'>Dataframe with palaeoclimatic data.</h2><span id='topic+climateShort'></span>

<h3>Description</h3>

<p>A dataframe containing 11 simulated samples of palaeoclimate data at 1 ky temporal resolution with the following columns:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(climateShort)
</code></pre>


<h3>Format</h3>

<p>dataframe with 5 columns and 11 rows.</p>


<h3>Details</h3>


<ul>
<li> <p><em>temperatureAverage</em> average annual temperature in Celsius degrees.
</p>
</li>
<li> <p><em>rainfallAverage</em> average annual precipitation in milimetres per day (mm/day).
</p>
</li>
<li> <p><em>temperatureWarmestMonth</em> average temperature of the warmest month, in Celsius degrees.
</p>
</li>
<li> <p><em>temperatureColdestMonth</em> average temperature of the coldest month, in Celsius degrees.
</p>
</li>
<li> <p><em>oxigenIsotope</em> delta O18, global ratio of stable isotopes in the sea floor, see <a href="http://lorraine-lisiecki.com/stack.html">http://lorraine-lisiecki.com/stack.html</a> for further details.
</p>
</li></ul>


<hr>
<h2 id='distance'>Computes a multivariate distance between two vectors.</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>Computes a multivariate distance (one of: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;) between two vectors of the same length. It is used internally by <code><a href="#topic+distanceMatrix">distanceMatrix</a></code> and <code><a href="#topic+autoSum">autoSum</a></code>. This function has no buit-in error trapping procedures in order to speed up execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(x, y, method = "manhattan")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_x">x</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="distance_+3A_y">y</code></td>
<td>
<p>numeric vector of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="distance_+3A_method">method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;. Invalid entries will throw an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectors <code>x</code> and <code>y</code> are not checked to speed-up execution time. Distances are computed as:
</p>

<ul>
<li> <p><code>manhattan</code>: <code>d &lt;- sum(abs(x - y))</code>
</p>
</li>
<li> <p><code>euclidean</code>: <code>d &lt;- sqrt(sum((x - y)^2))</code>
</p>
</li>
<li> <p><code>chi</code>: <code>
    xy &lt;- x + y
    y. &lt;- y / sum(y)
    x. &lt;- x / sum(x)
    d &lt;- sqrt(sum(((x. - y.)^2) / (xy / sum(xy))))</code>
</p>
</li>
<li> <p><code>hellinger</code>: <code>d &lt;- sqrt(1/2 * sum(sqrt(x) - sqrt(y))^2)</code>
</p>
</li></ul>

<p>Note that zeroes are replaced by 0.00001 whem <code>method</code> equals &quot;chi&quot; or &quot;hellinger&quot;.
</p>


<h3>Value</h3>

<p>A number representing the distance between both vectors.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(100)
y &lt;- runif(100)
distance(x, y, method = "manhattan")

</code></pre>

<hr>
<h2 id='distanceMatrix'>Computes distance matrices among the samples of two or more multivariate time-series.</h2><span id='topic+distanceMatrix'></span>

<h3>Description</h3>

<p>Computes distance matrices among the samples of two or more multivariate time-series provided in a single dataframe (generally produced by <code><a href="#topic+prepareSequences">prepareSequences</a></code>), identified by a grouping column (argument <code>grouping.column</code>). Distances can be computed with the methods &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;, and are implemented in the function <code><a href="#topic+distance">distance</a></code>. The function uses the packages <code><a href="parallel.html#topic+parallel">parallel</a></code>, <code><a href="foreach.html#topic+foreach">foreach</a></code>, and <code><a href="doParallel.html#topic+doParallel">doParallel</a></code> to compute distances matrices among different sequences in parallel. It is configured to use all processors available minus one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceMatrix(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceMatrix_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column. Generally the ouput of <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file. This argument is ignored if <code>sequence.A</code> and <code>sequence.B</code> are provided.</p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data. The data in this column is not modified.</p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code>, or <code>squence.A</code> and <code>sequence.B</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_method">method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;. Invalid entries will throw an error.</p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distances are computed as:
</p>

<ul>
<li> <p><code>manhattan</code>: <code>d &lt;- sum(abs(x - y))</code>
</p>
</li>
<li> <p><code>euclidean</code>: <code>d &lt;- sqrt(sum((x - y)^2))</code>
</p>
</li>
<li> <p><code>chi</code>: <code>
    xy &lt;- x + y
    y. &lt;- y / sum(y)
    x. &lt;- x / sum(x)
    d &lt;- sqrt(sum(((x. - y.)^2) / (xy / sum(xy))))</code>
</p>
</li>
<li> <p><code>hellinger</code>: <code>d &lt;- sqrt(1/2 * sum(sqrt(x) - sqrt(y))^2)</code>
</p>
</li></ul>

<p>Note that zeroes are replaced by 0.00001 whem <code>method</code> equals &quot;chi&quot; or &quot;hellinger&quot;.
</p>


<h3>Value</h3>

<p>A list with named slots containing the the distance matrices of every possible combination of sequences according to <code>grouping.column</code>.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#loading data
data(sequenceA)
data(sequenceB)

#preparing datasets
AB.sequences &lt;- prepareSequences(
 sequence.A = sequenceA,
 sequence.A.name = "A",
 sequence.B = sequenceB,
 sequence.B.name = "B",
 merge.mode = "complete",
 if.empty.cases = "zero",
 transformation = "hellinger"
 )

#computing distance matrix
AB.distance.matrix &lt;- distanceMatrix(
 sequences = AB.sequences,
 grouping.column = "id",
 method = "manhattan",
 parallel.execution = FALSE
 )


#plot
plotMatrix(distance.matrix = AB.distance.matrix)

</code></pre>

<hr>
<h2 id='distancePairedSamples'>Computes distance among pairs of aligned samples in two or more multivariate time-series.</h2><span id='topic+distancePairedSamples'></span>

<h3>Description</h3>

<p>Computes the distance (one of: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, or &quot;hellinger&quot;) between pairs of aligned samples (same order/depth/age) in two or more multivariate time-series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePairedSamples(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  same.time = FALSE,
  method = "manhattan",
  sum.distances = FALSE,
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distancePairedSamples_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column. Generally the ouput of <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="distancePairedSamples_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file. This argument is ignored if <code>sequence.A</code> and <code>sequence.B</code> are provided.</p>
</td></tr>
<tr><td><code id="distancePairedSamples_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data. The data in this column is not modified.</p>
</td></tr>
<tr><td><code id="distancePairedSamples_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code>, or <code>squence.A</code> and <code>sequence.B</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="distancePairedSamples_+3A_same.time">same.time</code></td>
<td>
<p>boolean. If <code>TRUE</code>, samples in the sequences to compare will be tested to check if they have the same time/age/depth according to <code>time.column</code>. This argument is only useful when the user needs to compare two sequences taken at different sites but same time frames.</p>
</td></tr>
<tr><td><code id="distancePairedSamples_+3A_method">method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;. Invalid entries will throw an error.</p>
</td></tr>
<tr><td><code id="distancePairedSamples_+3A_sum.distances">sum.distances</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default option), the distances between samples are summed, and the output of the function (now a list with a single number on each slot) can be directly used as input for the argument <code>least.cost</code> in the function <code><a href="#topic+psi">psi</a></code>.</p>
</td></tr>
<tr><td><code id="distancePairedSamples_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distances are computed as:
</p>

<ul>
<li> <p><code>manhattan</code>: <code>d &lt;- sum(abs(x - y))</code>
</p>
</li>
<li> <p><code>euclidean</code>: <code>d &lt;- sqrt(sum((x - y)^2))</code>
</p>
</li>
<li> <p><code>chi</code>: <code>
    xy &lt;- x + y
    y. &lt;- y / sum(y)
    x. &lt;- x / sum(x)
    d &lt;- sqrt(sum(((x. - y.)^2) / (xy / sum(xy))))</code>
</p>
</li>
<li> <p><code>hellinger</code>: <code>d &lt;- sqrt(1/2 * sum(sqrt(x) - sqrt(y))^2)</code>
</p>
</li></ul>

<p>Note that zeroes are replaced by 0.00001 whem <code>method</code> equals &quot;chi&quot; or &quot;hellinger&quot;.
</p>


<h3>Value</h3>

<p>A list with named slots (names of the sequences separated by a vertical line, as in &quot;A|B&quot;) containing numeric vectors with the distance between paired samples of every possible combination of sequences according to <code>grouping.column</code>.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#loading data
data(climate)

#preparing sequences
#notice the argument paired.samples
climate.prepared &lt;- prepareSequences(
  sequences = climate,
  grouping.column = "sequenceId",
  time.column = "time",
  paired.samples = TRUE
  )

#compute pairwise distances between paired samples
climate.prepared.distances &lt;- distancePairedSamples(
  sequences = climate.prepared,
  grouping.column = "sequenceId",
  time.column = "time",
  exclude.columns = NULL,
  method = "manhattan",
  sum.distances = FALSE,
  parallel.execution = FALSE
  )


</code></pre>

<hr>
<h2 id='distantia-package'>distantia: Assessing Dissimilarity Between Multivariate Time Series</h2><span id='topic+distantia'></span><span id='topic+distantia-package'></span>

<h3>Description</h3>

<p>Provides tools to assess the dissimilarity between multivariate time-series. It is based on the psi measure described  by Birks and Gordon (1985 &lt;doi:10.1002/jqs.3390020110&gt;), which computes dissimilarity between irregular time-series constrained by sample order. However, in this package the original idea has been extended to work with any kind of multivariate time-series, no matter whether they are regular, irregular, aligned or unaligned. Furthermore, the package allows to assess the significance of dissimilarity values by applying a restricted permutation test, allows to measure the contribution of individual variables to dissimilarity, and offers tools to transfer attributes (generally time or age, but other are possible) between sequences based on the similarity of their samples.
</p>


<h3>Details</h3>

<p>Details
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://blasbenito.github.io/distantia/">https://blasbenito.github.io/distantia/</a>
</p>
</li></ul>


<hr>
<h2 id='formatPsi'>Formats the output of <code><a href="#topic+psi">psi</a></code>.</h2><span id='topic+formatPsi'></span>

<h3>Description</h3>

<p>Parses a list produced by <code><a href="#topic+psi">psi</a></code> to generate either a dataframe or a matrix. Can also format a psi matrix into a dataframe and viceversa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatPsi(
  psi.values = NULL,
  to = "dataframe")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatPsi_+3A_psi.values">psi.values</code></td>
<td>
<p>list produced by <code><a href="#topic+psi">psi</a></code>.</p>
</td></tr>
<tr><td><code id="formatPsi_+3A_to">to</code></td>
<td>
<p>character, either &quot;dataframe&quot; or &quot;matrix&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function detects the type of input, and checks that it is different from the value of <code>to</code>. If that is the case, it throws a warning, and returns the input object. It uses the helper function .psiToDataframe, only intended for internal use.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>

<hr>
<h2 id='handleNA'>Handles emtpy and NA data in a multivariate time series.</h2><span id='topic+handleNA'></span>

<h3>Description</h3>

<p>This function is used internally by <code><a href="#topic+prepareSequences">prepareSequences</a></code>. Handles empty and NA data in a multivariate time-series in two possible ways: 1) deleting rows with NA or empty cases; 2) replacing NA data with zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleNA(
  sequence = NULL,
  if.empty.cases = "zero"
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handleNA_+3A_sequence">sequence</code></td>
<td>
<p>Dataframe, a multivariate time-series.</p>
</td></tr>
<tr><td><code id="handleNA_+3A_if.empty.cases">if.empty.cases</code></td>
<td>
<p>character, one of: &quot;omit&quot; (default), &quot;zero&quot;. When &quot;omit&quot;, the function removes every row with at least one empty/NA record. When &quot;zero&quot;, empty/NA data is replaced with zeros.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the same columns as <code>sequence</code>.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sequenceB)
B.sequence &lt;- handleNA(
  sequence = sequenceB,
  if.empty.cases = "zero"
  )

</code></pre>

<hr>
<h2 id='leastCost'>Extracts the least cost from a least-cost path.</h2><span id='topic+leastCost'></span>

<h3>Description</h3>

<p>Sums the the distances of the samples in a least-cost path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leastCost(
  least.cost.path = NULL,
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leastCost_+3A_least.cost.path">least.cost.path</code></td>
<td>
<p>dataframe produced by <code><a href="#topic+leastCostPath">leastCostPath</a></code>.</p>
</td></tr>
<tr><td><code id="leastCost_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with least-cost values.
</p>
<p>A named list with least cost values.
</p>

<hr>
<h2 id='leastCostMatrix'>Computes a least cost matrix from a distance matrix.</h2><span id='topic+leastCostMatrix'></span>

<h3>Description</h3>

<p>Computes the constrained (by sample order) minimum sum of distances among samples in two multivariate time-series by finding the least cost path between the first and last samples in a distance matrix computed by <code><a href="#topic+distanceMatrix">distanceMatrix</a></code>. The minimum distance is found trough an efficient dynamic programming algorithm that first solves the local least cost path between adjacent samples, and uses the partial solutions to find the global solution.
</p>
<p>The algorithm is based on the sequence slotting algorithm described by Birks and Gordon (1985). In its original version, the algorithm searches for the least cost path between a given sample of one sequence (A) and the samples of the other sequence (B) in orthogonal directions (either one step in the x axis or one step in the y axis), which allows to locate the two samples in B between which the target sample in A &quot;belongs&quot; (has the least distance to). Therefore, the algorithm is in fact ordering the samples in both sequences to virtually create a single sequence (as in <code>B1, A1, A2, B2, etc</code>) with the samples ordered in the way that minimizes the global distance among them.
</p>
<p>This function provides an additional option that allows to include the diagonals in the search of the least cost path through the <code>diagonal</code> argument (which is <code>FALSE</code> by default). This modification allows to find, for each sample in A, the most similar sample in B, and align them together, if the distance among them is lower than the one found in the orthogonal directions. Both options give highly correlated least cost distances for the same matrices, but have different applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leastCostMatrix(
  distance.matrix = NULL,
  diagonal = FALSE,
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leastCostMatrix_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>numeric matrix or list of numeric matrices, a distance matrix produced by <code><a href="#topic+distanceMatrix">distanceMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="leastCostMatrix_+3A_diagonal">diagonal</code></td>
<td>
<p>boolean, if <code>TRUE</code>, diagonals are included in the computation of the least cost path. Defaults to <code>FALSE</code>, as the original algorithm did not include diagonals in the computation of the least cost path.</p>
</td></tr>
<tr><td><code id="leastCostMatrix_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices with the same dimensions as <code>distance.matrix</code> with the cumulative least cost among samples. The value of the lower-right cell (in the actual data matrix, not in the plotted version!) represents the sum of the least cost path across all samples.
</p>

<ul>
<li><p> Birks, H.J.B.  and Gordon, A.D. (1985) Numerical Methods in Quaternary Pollen Analysis. Academic Press.
</p>
</li>
<li><p> Clark, R.M., (1985) A FORTRAN program for constrained sequence-slotting based on minimum combined path length. Computers &amp; Geosciences, Volume 11, Issue 5, Pages 605-617. Doi: https://doi.org/10.1016/0098-3004(85)90089-5.
</p>
</li>
<li><p> Thompson, R., Clark, R.M. (1989) Sequence slotting for stratigraphic correlation between cores: theory and practice. Journal of Paleolimnology, Volume 2, Issue 3, pp 173â€“184
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>


#loading data
data(sequenceA)
data(sequenceB)

#preparing datasets
AB.sequences &lt;- prepareSequences(
 sequence.A = sequenceA,
 sequence.A.name = "A",
 sequence.B = sequenceB,
 sequence.B.name = "B",
 merge.mode = "complete",
 if.empty.cases = "zero",
 transformation = "hellinger"
 )

#computing distance matrix
AB.distance.matrix &lt;- distanceMatrix(
 sequences = AB.sequences,
 grouping.column = "id",
 method = "manhattan",
 parallel.execution = FALSE
 )

#computing least cost matrix
AB.least.cost.matrix &lt;- leastCostMatrix(
 distance.matrix = AB.distance.matrix,
 diagonal = FALSE,
 parallel.execution = FALSE
 )

#plot
par(mfrow=c(1,2))
plotMatrix(distance.matrix = AB.distance.matrix)
plotMatrix(distance.matrix = AB.least.cost.matrix)
dev.off()



</code></pre>

<hr>
<h2 id='leastCostPath'>Find the least cost path in a least cost matrix.</h2><span id='topic+leastCostPath'></span>

<h3>Description</h3>

<p>Uses the original distance matrix created by <code><a href="#topic+distanceMatrix">distanceMatrix</a></code> and the least cost path matrix created by <code><a href="#topic+leastCostMatrix">leastCostMatrix</a></code> to find the least cost path between the first and the last cells of the matrix. If <code>diagonal</code> was <code>TRUE</code> in <code><a href="#topic+leastCostMatrix">leastCostMatrix</a></code>, then it must be <code>TRUE</code> when using this function. Otherwise, the default is <code>FALSE</code> in both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leastCostPath(
  distance.matrix = NULL,
  least.cost.matrix = NULL,
  diagonal = FALSE,
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leastCostPath_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>numeric matrix or list of numeric matrices, a distance matrix produced by <code><a href="#topic+distanceMatrix">distanceMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="leastCostPath_+3A_least.cost.matrix">least.cost.matrix</code></td>
<td>
<p>numeric matrix or list of numeric matrices produced by <code><a href="#topic+leastCostMatrix">leastCostMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="leastCostPath_+3A_diagonal">diagonal</code></td>
<td>
<p>boolean, if <code>TRUE</code>, diagonals are included in the computation of the least cost path. Defaults to <code>FALSE</code>, as the original algorithm did not include diagonals in the computation of the least cost path.</p>
</td></tr>
<tr><td><code id="leastCostPath_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Alist of dataframes if <code>least.cost.matrix</code> is a list, or a dataframe if <code>least.cost.matrix</code> is a matrix. The dataframe/s have the following columns:
</p>

<ul>
<li> <p><em>A</em> row/sample of one of the sequences.
</p>
</li>
<li> <p><em>B</em> row/sample of one the other sequence.
</p>
</li>
<li> <p><em>distance</em> distance between both samples, extracted from <code>distance.matrix</code>.
</p>
</li>
<li> <p><em>cumulative.distance</em> cumulative distance at the samples <code>A</code> and <code>B</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>


#loading data
data(sequenceA)
data(sequenceB)

#preparing datasets
AB.sequences &lt;- prepareSequences(
 sequence.A = sequenceA,
 sequence.A.name = "A",
 sequence.B = sequenceB,
 sequence.B.name = "B",
 merge.mode = "complete",
 if.empty.cases = "zero",
 transformation = "hellinger"
 )

#computing distance matrix
AB.distance.matrix &lt;- distanceMatrix(
 sequences = AB.sequences,
 grouping.column = "id",
 method = "manhattan",
 parallel.execution = FALSE
 )

#computing least cost matrix
AB.least.cost.matrix &lt;- leastCostMatrix(
 distance.matrix = AB.distance.matrix,
 diagonal = FALSE,
 parallel.execution = FALSE
 )

AB.least.cost.path &lt;- leastCostPath(
 distance.matrix = AB.distance.matrix,
 least.cost.matrix = AB.least.cost.matrix,
 parallel.execution = FALSE
 )

#plot
plotMatrix(distance.matrix = AB.distance.matrix,
 least.cost.path = AB.least.cost.path,
 )



</code></pre>

<hr>
<h2 id='leastCostPathNoBlocks'>Extracts the least-cost from a least cost matrix by trimming blocks.</h2><span id='topic+leastCostPathNoBlocks'></span>

<h3>Description</h3>

<p>Extracts the minimum cost of a least-cost path by trimming blocks (straight segments of the path that appear in highly dissimilar regions of the sequences). Blocks inflate psi values when two sequences are similar but have very different numbers of rows. This function is for internal use of other functions in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leastCostPathNoBlocks(
  least.cost.path = NULL,
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leastCostPathNoBlocks_+3A_least.cost.path">least.cost.path</code></td>
<td>
<p>dataframe produced by <code><a href="#topic+leastCostPath">leastCostPath</a></code>.</p>
</td></tr>
<tr><td><code id="leastCostPathNoBlocks_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with least cost values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


#'#loading data
data(sequenceA)
data(sequenceB)

#preparing datasets
AB.sequences &lt;- prepareSequences(
 sequence.A = sequenceA,
 sequence.A.name = "A",
 sequence.B = sequenceB,
 sequence.B.name = "B",
 merge.mode = "complete",
 if.empty.cases = "zero",
 transformation = "hellinger"
 )

#computing distance matrix
AB.distance.matrix &lt;- distanceMatrix(
 sequences = AB.sequences,
 grouping.column = "id",
 method = "manhattan",
 parallel.execution = FALSE
 )

#computing least cost matrix
AB.least.cost.matrix &lt;- leastCostMatrix(
 distance.matrix = AB.distance.matrix,
 diagonal = FALSE,
 parallel.execution = FALSE
 )

AB.least.cost.path &lt;- leastCostPath(
 distance.matrix = AB.distance.matrix,
 least.cost.matrix = AB.least.cost.matrix,
 parallel.execution = FALSE
 )

AB.least.cost.path.nb &lt;- leastCostPathNoBlocks(
 least.cost.path = AB.least.cost.path,
 parallel.execution = FALSE
 )



</code></pre>

<hr>
<h2 id='plotMatrix'>Plots distance matrices and least cost paths.</h2><span id='topic+plotMatrix'></span>

<h3>Description</h3>

<p>Plots the output matrices of <code><a href="#topic+distanceMatrix">distanceMatrix</a></code> and <code><a href="#topic+leastCostMatrix">leastCostMatrix</a></code>, and superimposes the least cost path generated by <code><a href="#topic+leastCostPath">leastCostPath</a></code>. This functions relies on <code><a href="fields.html#topic+image.plot">image.plot</a></code> to plot a color scale along with the matrix plot, or <code><a href="graphics.html#topic+image">image</a></code> when a color scale is not needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMatrix(
  distance.matrix = NULL,
  least.cost.path = NULL,
  plot.columns = NULL,
  plot.rows = NULL,
  legend = TRUE,
  color.palette = "divergent",
  path.color = "black",
  path.width = 1,
  margins = c(2,3,2,4),
  pdf.filename = NULL,
  pdf.width = 7,
  pdf.height = 4,
  pdf.pointsize = 12,
  rotate = FALSE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMatrix_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>numeric matrix or list of numeric matrices either produced by <code><a href="#topic+distanceMatrix">distanceMatrix</a></code> or <code><a href="#topic+leastCostMatrix">leastCostMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_least.cost.path">least.cost.path</code></td>
<td>
<p>dataframe or list of fdataframes produced by <code><a href="#topic+leastCostPath">leastCostPath</a></code>. If a list, must have the same number of slots as <code>distance.matrix</code>.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_plot.columns">plot.columns</code></td>
<td>
<p>number of columns of the output plot if the inputs are lists. If not provided, it is computed automatically by <code><a href="grDevices.html#topic+n2mfrow">n2mfrow</a></code>.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_plot.rows">plot.rows</code></td>
<td>
<p>number of rows of the output plot if the inputs are lists. If not provided, it is computed automatically by <code><a href="grDevices.html#topic+n2mfrow">n2mfrow</a></code>.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_legend">legend</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the plot is made with <code><a href="fields.html#topic+image.plot">image.plot</a></code>, and includes a color scale on the right side. If <code>FALSE</code>, the plot is made with <code><a href="graphics.html#topic+image">image</a></code>, and the color scale is omitted.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_color.palette">color.palette</code></td>
<td>
<p>string defining the color palette to be used, or a color palette. Accepted strings are &quot;divergent&quot; (default), which uses a red-white-blue divergent palette produced by the code <code>colorRampPalette(rev(RColorBrewer::brewer.pal(9, "RdBu")))(100)</code>, and &quot;viridis&quot;, which uses the default settings of the <code><a href="viridis.html#topic+viridis">viridis</a></code> function to generate the palette. Both settings are color-blind friendly.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_path.color">path.color</code></td>
<td>
<p>string, color of the line representing the least cost path if <code>least.cost.path</code> is provided.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_path.width">path.width</code></td>
<td>
<p>line width (lwd) of the plotted path.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_margins">margins</code></td>
<td>
<p>a numeric vector with four positions indicating the margins of each plotted matrix. Order of margins in this vector is: bottom, left, top, right.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_pdf.filename">pdf.filename</code></td>
<td>
<p>character string with the name, without extension, of the pdf to be written. If <code>NULL</code>, no pdf is written.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_pdf.width">pdf.width</code></td>
<td>
<p>with in inches of the output pdf. Default value is 7.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_pdf.height">pdf.height</code></td>
<td>
<p>height in inches of the output pdf. Default value is 4.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_pdf.pointsize">pdf.pointsize</code></td>
<td>
<p>base font size of the output pdf.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_rotate">rotate</code></td>
<td>
<p>boolean, if <code>TRUE</code>, the matrix is rotated. Allows the user to plot the matrix axes in the desired direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dataframes if <code>least.cost.matrix</code> is a list, or a dataframe if <code>least.cost.matrix</code> is a matrix. The dataframe/s have the following columns:
</p>

<ul>
<li> <p><em>A</em> row/sample of one of the sequences.
</p>
</li>
<li> <p><em>B</em> row/sample of one the other sequence.
</p>
</li>
<li> <p><em>distance</em> distance between both samples, extracted from <code>distance.matrix</code>.
</p>
</li>
<li> <p><em>cumulative.distance</em> cumulative distance at the samples <code>A</code> and <code>B</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

#loading data
data(sequenceA)
data(sequenceB)

#preparing datasets
AB.sequences &lt;- prepareSequences(
 sequence.A = sequenceA,
 sequence.A.name = "A",
 sequence.B = sequenceB,
 sequence.B.name = "B",
 merge.mode = "complete",
 if.empty.cases = "zero",
 transformation = "hellinger"
 )

#computing distance matrix
AB.distance.matrix &lt;- distanceMatrix(
 sequences = AB.sequences,
 grouping.column = "id",
 method = "manhattan",
 parallel.execution = FALSE
 )

#plot
plotMatrix(distance.matrix = AB.distance.matrix)

#viridis palette
plotMatrix(distance.matrix = AB.distance.matrix,
 color.palette = "viridis")

#custom palette
plotMatrix(distance.matrix = AB.distance.matrix,
color.palette = viridis::viridis(8, option = "B", direction = -1))



</code></pre>

<hr>
<h2 id='pollenGP'>Pollen dataset.</h2><span id='topic+pollenGP'></span>

<h3>Description</h3>

<p>A subset of the Grande Pile dataset (<a href="https://doi.pangaea.de/10.1594/PANGAEA.739275">https://doi.pangaea.de/10.1594/PANGAEA.739275</a>). It contains a depth (cm) and age columns (ky BP), and 40 pollen types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sequenceA)
</code></pre>


<h3>Format</h3>

<p>Dataframe with 42 columns and 200 rows</p>

<hr>
<h2 id='prepareSequences'>Prepare sequences for a comparison analysis.</h2><span id='topic+prepareSequences'></span>

<h3>Description</h3>

<p>This function prepares two or more multivariate time-series that are to be compared. It can work on two different scenarios:
</p>

<ul>
<li> <p><em>Two dataframes</em>: The user provides two separated dataframes, each containing a multivariate time series. These time-series can be regular or irregular, aligned or unaligned, but must have at least a few columns with the same names (pay attention to differences in case between column names representing the same entity) and units. This mode uses exclusively the following arguments: <code>sequence.A</code>, <code>sequence.A.name</code> (optional), <code>sequence.B</code>, <code>sequence.B.name</code> (optional), and <code>merge.model</code>.
</p>
</li>
<li> <p><em>One long dataframe</em>: The user provides a single dataframe, through the <code>sequences</code> argument, with two or more multivariate time-series identified by a <code>grouping.column</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>prepareSequences(
  sequence.A = NULL,
  sequence.A.name = "A",
  sequence.B = NULL,
  sequence.B.name = "B",
  merge.mode = "complete",
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  if.empty.cases = "zero",
  transformation = "none",
  paired.samples = FALSE,
  same.time = FALSE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareSequences_+3A_sequence.a">sequence.A</code></td>
<td>
<p>dataframe containing a multivariate time-series.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_sequence.a.name">sequence.A.name</code></td>
<td>
<p>character string with the name of <code>sequence.A</code>. Will be used as identificator in the <code>id</code> column of the output dataframe.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_sequence.b">sequence.B</code></td>
<td>
<p>dataframe containing a multivariate time-series. Must have overlapping columns with <code>sequence.A</code> with same column names and units.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_sequence.b.name">sequence.B.name</code></td>
<td>
<p>character string with the name of <code>sequence.B</code>. Will be used as identificator in the <code>id</code> column of the output dataframe.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_merge.mode">merge.mode</code></td>
<td>
<p>character string, one of: &quot;overlap&quot;, &quot;complete&quot; (default option). If &quot;overlap&quot;, <code>sequence.A</code> and <code>sequence.B</code> are merged by their common columns, and non-common columns are dropped If &quot;complete&quot;, columns absent in one dataset but present in the other are added, with values equal to 0. This argument is ignored if <code>sequences</code> is provided instead of <code>sequence.A</code> and <code>sequence.B</code>.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file. If two sequences are provided through the arguments <code>sequence.A</code> and <code>sequence.B</code>, this argument defines the name of the grouping column in the output dataframe. If two or several sequences are provided as a single dataframe through the argument <code>sequences</code>, then <code>grouping.column</code> must be a column in this dataset.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data. If <code>sequence.A</code> and <code>sequence.B</code> are provided, <code>time.column</code> must have the same name and units in both dataframes.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code>, or <code>squence.A</code> and <code>sequence.B</code>, to be excluded from the transformation.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_if.empty.cases">if.empty.cases</code></td>
<td>
<p>character string with two possible values: &quot;omit&quot;, or &quot;zero&quot;. If &quot;zero&quot; (default), <code>NA</code> values are replaced by zeroes. If &quot;omit&quot;, rows with <code>NA</code> data are removed.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_transformation">transformation</code></td>
<td>
<p>character string. Defines what data transformation is to be applied to the sequences. One of: &quot;none&quot; (default), &quot;percentage&quot;, &quot;proportion&quot;, &quot;hellinger&quot;, and &quot;scale&quot; (the latter centers and scales the data using the <code><a href="base.html#topic+scale">scale</a></code> function).</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_paired.samples">paired.samples</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the function will test if the datasets have paired samples. This means that each dataset must have the same number of rows/samples, and that, if available, the <code>time.column</code> must have the same values in every dataset. This is only mandatory when using the functions <code><a href="#topic+distancePairedSamples">distancePairedSamples</a></code> or <code><a href="#topic+workflowPsi">workflowPsi</a></code> with <code>paired.samples = TRUE</code> after preparing the sequences. The default setting is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="prepareSequences_+3A_same.time">same.time</code></td>
<td>
<p>boolean. If <code>TRUE</code>, samples in the sequences to compare will be tested to check if they have the same time/age/depth according to <code>time.column</code>. This argument is only useful when the user needs to compare two sequences taken at different sites but same time frames.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the multivariate time series. If <code>squence.A</code> and <code>sequence.B</code> are provided, the column identifying the sequences is named &quot;id&quot;. If <code>sequences</code> is provided, the time-series are identified by <code>grouping.column</code>.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#two sequences as inputs
data(sequenceA)
data(sequenceB)

AB.sequences &lt;- prepareSequences(
 sequence.A = sequenceA,
 sequence.A.name = "A",
 sequence.B = sequenceB,
 sequence.B.name = "B",
 merge.mode = "complete",
 if.empty.cases = "zero",
 transformation = "hellinger"
 )


#several sequences in a single dataframe
data(sequencesMIS)
MIS.sequences &lt;- prepareSequences(
 sequences = sequencesMIS,
 grouping.column = "MIS",
 if.empty.cases = "zero",
 transformation = "hellinger"
 )

</code></pre>

<hr>
<h2 id='psi'>Computes sum of distances between consecutive samples in a multivariate time-series.</h2><span id='topic+psi'></span>

<h3>Description</h3>

<p>Computes the sum of distances between consecutive samples in a multivariate time-series. Required to compute the measure of dissimilarity <code>psi</code> (Birks and Gordon 1985). Distances can be computed through the methods &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;, and are implemented in the function <code><a href="#topic+distance">distance</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi(
  least.cost = NULL,
  autosum = NULL,
  parallel.execution = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psi_+3A_least.cost">least.cost</code></td>
<td>
<p>character string, name of the column with time/depth/rank data. The data in this column is not modified.</p>
</td></tr>
<tr><td><code id="psi_+3A_autosum">autosum</code></td>
<td>
<p>dataframe with one or several multivariate time-series identified by a grouping column.</p>
</td></tr>
<tr><td><code id="psi_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measure of dissimilarity <code>psi</code> is computed as: <code>least.cost - (autosum of sequences)) / autosum of sequences</code>. It has a lower limit at 0, while there is no upper limit.
</p>


<h3>Value</h3>

<p>A list with named slots, each one with a psi value.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>

<ul>
<li><p> Birks, H.J.B.  and Gordon, A.D. (1985) Numerical Methods in Quaternary Pollen Analysis. Academic Press.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

#loading data
data(sequenceA)
data(sequenceB)

#preparing datasets
AB.sequences &lt;- prepareSequences(
 sequence.A = sequenceA,
 sequence.A.name = "A",
 sequence.B = sequenceB,
 sequence.B.name = "B",
 merge.mode = "complete",
 if.empty.cases = "zero",
 transformation = "hellinger"
 )

#computing distance matrix
AB.distance.matrix &lt;- distanceMatrix(
 sequences = AB.sequences,
 grouping.column = "id",
 method = "manhattan",
 parallel.execution = FALSE
 )

#computing least cost matrix
AB.least.cost.matrix &lt;- leastCostMatrix(
 distance.matrix = AB.distance.matrix,
 diagonal = FALSE,
 parallel.execution = FALSE
 )

AB.least.cost.path &lt;- leastCostPath(
 least.cost.matrix = AB.least.cost.matrix,
 distance.matrix = AB.distance.matrix,
 parallel.execution = FALSE
 )

#extracting least cost
AB.least.cost &lt;- leastCost(
 least.cost.path = AB.least.cost.path,
 parallel.execution = FALSE
 )

#autosum
AB.autosum &lt;- autoSum(
 sequences = AB.sequences,
 least.cost.path = AB.least.cost.path,
 grouping.column = "id",
 parallel.execution = FALSE
 )
AB.autosum

AB.psi &lt;- psi(
 least.cost = AB.least.cost,
 autosum = AB.autosum,
 parallel.execution = FALSE
 )
AB.psi



</code></pre>

<hr>
<h2 id='sequenceA'>Multivariate and irregular time series with pollen counts.</h2><span id='topic+sequenceA'></span>

<h3>Description</h3>

<p>A dataframe with 9 columns representing pollen types (betula, pinus, corylus, empetrum, cypera, artemisia, rumex) and 49 rows representing increasing depths with pollen counts taken from the Abernethy dataset (Birks and Mathewes (1978).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sequenceA)
</code></pre>


<h3>Format</h3>

<p>Dataframe with 9 columns and 49 rows</p>


<h3>References</h3>

<p>Birks, H.H. and Mathewes, R.W. (1978) Studies in the vegetational history of Scotland. <em>New Phytologist</em> <strong>80</strong>, 455-484.
</p>

<hr>
<h2 id='sequenceB'>Multivariate and irregular time series with pollen counts.</h2><span id='topic+sequenceB'></span>

<h3>Description</h3>

<p>A dataframe with 8 columns (the column <code>empetr</code> is missing with respect to <code><a href="#topic+sequenceA">sequenceA</a></code>) representing pollen types (betula, pinus, corylus, cypera, artemisia, rumex) and 41 rows representing increasing depths with pollen counts taken from the Abernethy dataset (Birks and Mathewes (1978). Several NA values have been introduced in the dataset to demonstrate the data-handling capabilities of <code><a href="#topic+prepareSequences">prepareSequences</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sequenceB)
</code></pre>


<h3>Format</h3>

<p>Dataframe with 9 columns and 41 rows</p>


<h3>References</h3>

<p>Birks, H.H. and Mathewes, R.W. (1978) Studies in the vegetational history of Scotland. <em>New Phytologist</em> <strong>80</strong>, 455-484.
</p>

<hr>
<h2 id='sequencesMIS'>Dataframe with pollen counts for different MIS stages.</h2><span id='topic+sequencesMIS'></span>

<h3>Description</h3>

<p>A dataframe with 427 rows representing pollen counts for 12 marine isotope stages and 6 pollen types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sequencesMIS)
</code></pre>


<h3>Format</h3>

<p>dataframe with 7 columns and 427 rows.</p>

<hr>
<h2 id='workflowImportance'>Computes the contribution to dissimilarity of each variable.</h2><span id='topic+workflowImportance'></span>

<h3>Description</h3>

<p>This workflow executes the following steps:
</p>

<ul>
<li><p> computes <code>psi</code> as done by <code><a href="#topic+workflowPsi">workflowPsi</a></code>.
</p>
</li>
<li><p> computes <code>psi</code> as many times as numeric variables in <code>sequences</code>, removing one of them each time (jacknife analysis) to compute the relative contribution of each variable to overall dissimilarity.
</p>
</li>
<li><p> Delivers an output of type &quot;list&quot; with two slots:
</p>

<ul>
<li> <p><code>psi</code> a dataframe with the columns &quot;A&quot; and &quot;B&quot; with the respective names of the sequences compared, a column named &quot;All variables&quot; with the psi values of each pair of sequences computed by considering all variables, and then one column per variable, indicating the <code>psi</code> value when that variable is removed.
</p>
</li>
<li> <p><code>psi.drop</code> a dataframe with the columns &quot;A&quot; and &quot;B&quot;, and then one column per numeric variable in <code>sequences</code> indicating the percentage of drop in <code>psi</code> (as indicated by the &quot;All variables&quot; column in the psi dataframe) when the given variable is removed. Positive values indicate that the given variable reduces dissimilarity when removed, making the sequences more similar, while negative values indicate that the variable increases dissimilarity when removed, making the sequences more different.
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>workflowImportance(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  diagonal = FALSE,
  paired.samples = FALSE,
  same.time = FALSE,
  ignore.blocks = FALSE,
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workflowImportance_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column generated by <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="workflowImportance_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file.</p>
</td></tr>
<tr><td><code id="workflowImportance_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data.</p>
</td></tr>
<tr><td><code id="workflowImportance_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="workflowImportance_+3A_method">method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;. Invalid entries will throw an error.</p>
</td></tr>
<tr><td><code id="workflowImportance_+3A_diagonal">diagonal</code></td>
<td>
<p>boolean, if <code>TRUE</code>, diagonals are included in the computation of the least cost path. Defaults to <code>FALSE</code>, as the original algorithm did not include diagonals in the computation of the least cost path.</p>
</td></tr>
<tr><td><code id="workflowImportance_+3A_paired.samples">paired.samples</code></td>
<td>
<p>boolean, if <code>TRUE</code>, the sequences are assumed to be aligned, and distances are computed for paired-samples only (no distance matrix required). Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="workflowImportance_+3A_same.time">same.time</code></td>
<td>
<p>boolean. If <code>TRUE</code>, samples in the sequences to compare will be tested to check if they have the same time/age/depth according to <code>time.column</code>. This argument is only useful when the user needs to compare two sequences taken at different sites but same time frames.</p>
</td></tr>
<tr><td><code id="workflowImportance_+3A_ignore.blocks">ignore.blocks</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the function <code><a href="#topic+leastCostPathNoBlocks">leastCostPathNoBlocks</a></code> analyzes the least-cost path of the best solution, and removes blocks (straight-orthogonal sections of the least-cost path), which happen in highly dissimilar sections of the sequences, and inflate output psi values.</p>
</td></tr>
<tr><td><code id="workflowImportance_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If we consider the question &quot;what variable contributes the most to the dissimilarity between two sequences?&quot; the answer &quot;the one dropping dissimilarity the most when excluded from the analysis&quot; sounds like a reasonable answer. This workflow attempts to reach that answer by computing <code>psi</code> while removing one variable at a time.
</p>


<h3>Value</h3>

<p>A list with two slots named <em>psi</em> and <em>psi.drop</em>. The former contains the dissimilarity values when removing each variable, while the latter contains the drop in dissimilarity (as a percentage of psi computed on all variables) that happens when each variable is removed. Positive values indicate that dissimilarity drops when the variable is removed, while negative values indicate that similarity drops when the variable is removed.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>

<hr>
<h2 id='workflowImportanceHP'>Computes the contribution to dissimilarity of each variable using workflowPsiHP.</h2><span id='topic+workflowImportanceHP'></span>

<h3>Description</h3>

<p>This workflow executes the following steps:
</p>

<ul>
<li><p> computes <code>psi</code> as done by <code><a href="#topic+workflowPsi">workflowPsi</a></code>.
</p>
</li>
<li><p> computes <code>psi</code> as many times as numeric variables in <code>sequences</code>, removing one of them each time (jacknife analysis) to compute the relative contribution of each variable to overall dissimilarity.
</p>
</li>
<li><p> Delivers an output of type &quot;list&quot; with two slots:
</p>

<ul>
<li> <p><code>psi</code> a dataframe with the columns &quot;A&quot; and &quot;B&quot; with the respective names of the sequences compared, a column named &quot;All variables&quot; with the psi values of each pair of sequences computed by considering all variables, and then one column per variable, indicating the <code>psi</code> value when that variable is removed.
</p>
</li>
<li> <p><code>psi.drop</code> a dataframe with the columns &quot;A&quot; and &quot;B&quot;, and then one column per numeric variable in <code>sequences</code> indicating the percentage of drop in <code>psi</code> (as indicated by the &quot;All variables&quot; column in the psi dataframe) when the given variable is removed. Positive values indicate that the given variable reduces dissimilarity when removed, making the sequences more similar, while negative values indicate that the variable increases dissimilarity when removed, making the sequences more different.
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>workflowImportanceHP(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workflowImportanceHP_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column generated by <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="workflowImportanceHP_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file.</p>
</td></tr>
<tr><td><code id="workflowImportanceHP_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data.</p>
</td></tr>
<tr><td><code id="workflowImportanceHP_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="workflowImportanceHP_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If we consider the question &quot;what variable contributes the most to the dissimilarity between two sequences?&quot; the answer &quot;the one dropping dissimilarity the most when excluded from the analysis&quot; sounds like a reasonable answer. This workflow attempts to reach that answer by computing <code>psi</code> while removing one variable at a time.
</p>


<h3>Value</h3>

<p>A list with two slots named <em>psi</em> and <em>psi.drop</em>. The former contains the dissimilarity values when removing each variable, while the latter contains the drop in dissimilarity (as a percentage of psi computed on all variables) that happens when each variable is removed. Positive values indicate that dissimilarity drops when the variable is removed, while negative values indicate that similarity drops when the variable is removed.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>

<hr>
<h2 id='workflowNullPsi'>Computes the dissimilarity measure <em>psi</em> on restricted permutations of two or more sequences.</h2><span id='topic+workflowNullPsi'></span>

<h3>Description</h3>

<p>The function first computes psi on the observed sequences, and then computes it on permutations of the input sequences by the <code>repetitions</code> argument. The data is randomized as follows: within each column, each data-point can be: 1) left as is; 2) replaced by the previous case; 3) replaced by the next case. The action applied to each data-point is selected randomly, and independently from the actions applied to other data-points. This type of randomization generates versions of the dataset that have the same general structure as the original one, but small local and independent changes only ocurring within the immediate neighborhood (one row up or down) of each case in the table. The method should generate very conservative random values of <code>psi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>workflowNullPsi(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  diagonal = FALSE,
  paired.samples = FALSE,
  same.time = FALSE,
  ignore.blocks = FALSE,
  parallel.execution = TRUE,
  repetitions = 9
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workflowNullPsi_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column generated by <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="workflowNullPsi_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file.</p>
</td></tr>
<tr><td><code id="workflowNullPsi_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data.</p>
</td></tr>
<tr><td><code id="workflowNullPsi_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="workflowNullPsi_+3A_method">method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;. Invalid entries will throw an error.</p>
</td></tr>
<tr><td><code id="workflowNullPsi_+3A_diagonal">diagonal</code></td>
<td>
<p>boolean, if <code>TRUE</code>, diagonals are included in the computation of the least cost path. Defaults to <code>FALSE</code>, as the original algorithm did not include diagonals in the computation of the least cost path. If <code>paired.samples</code> is <code>TRUE</code>, then <code>diagonal</code> is irrelevant.</p>
</td></tr>
<tr><td><code id="workflowNullPsi_+3A_paired.samples">paired.samples</code></td>
<td>
<p>boolean, if <code>TRUE</code>, the sequences are assumed to be aligned, and distances are computed for paired-samples only (no distance matrix required). Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="workflowNullPsi_+3A_same.time">same.time</code></td>
<td>
<p>boolean. If <code>TRUE</code>, samples in the sequences to compare will be tested to check if they have the same time/age/depth according to <code>time.column</code>. This argument is only useful when the user needs to compare two sequences taken at different sites but same time frames.</p>
</td></tr>
<tr><td><code id="workflowNullPsi_+3A_ignore.blocks">ignore.blocks</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the function <code><a href="#topic+leastCostPathNoBlocks">leastCostPathNoBlocks</a></code> analyzes the least-cost path of the best solution, and removes blocks (straight-orthogonal sections of the least-cost path), which happen in highly dissimilar sections of the sequences, and inflate output psi values.</p>
</td></tr>
<tr><td><code id="workflowNullPsi_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="workflowNullPsi_+3A_repetitions">repetitions</code></td>
<td>
<p>integer, number of null psi values to obtain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two slots:
</p>

<ul>
<li> <p><em>psi</em>: a dataframe. The first two columns contain the names of the sequences being compared, the third column contains the real <code>psi</code> value, and the rest of the column contain <code>psi</code> values computed on permutated versions of the datasets.
</p>
</li>
<li> <p><em>p</em>: a dataframe. The first two columns are as above, the third column contains the probability of obtaining a <code>random psi</code> lower than the real <code>psi</code> by chance.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#load data
data("sequencesMIS")

#prepare sequences
MIS.sequences &lt;- prepareSequences(
  sequences = sequencesMIS,
  grouping.column = "MIS",
  transformation = "hellinger"
  )

#execute workflow to compute psi
MIS.null.psi &lt;- workflowNullPsi(
 sequences = MIS.sequences[MIS.sequences$MIS %in% c("MIS-1", "MIS-2"), ],
 grouping.column = "MIS",
 method = "manhattan",
 repetitions = 3,
 parallel.execution = FALSE
 )

MIS.null.psi


</code></pre>

<hr>
<h2 id='workflowNullPsiHP'>Computes the dissimilarity measure <em>psi</em> on restricted permutations of two or more sequences. High performance version with limited options</h2><span id='topic+workflowNullPsiHP'></span>

<h3>Description</h3>

<p>The function first computes psi on the observed sequences, and then computes it on permutations of the input sequences by the <code>repetitions</code> argument. The data is randomized as follows: within each column, each data-point can be: 1) left as is; 2) replaced by the previous case; 3) replaced by the next case. The action applied to each data-point is selected randomly, and independently from the actions applied to other data-points. This type of randomization generates versions of the dataset that have the same general structure as the original one, but small local and independent changes only ocurring within the immediate neighborhood (one row up or down) of each case in the table. The method should generate very conservative random values of <code>psi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>workflowNullPsiHP(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  parallel.execution = TRUE,
  repetitions = 9
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workflowNullPsiHP_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column generated by <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="workflowNullPsiHP_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file.</p>
</td></tr>
<tr><td><code id="workflowNullPsiHP_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data.</p>
</td></tr>
<tr><td><code id="workflowNullPsiHP_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="workflowNullPsiHP_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="workflowNullPsiHP_+3A_repetitions">repetitions</code></td>
<td>
<p>integer, number of null psi values to obtain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two slots:
</p>

<ul>
<li> <p><em>psi</em>: a dataframe. The first two columns contain the names of the sequences being compared, the third column contains the real <code>psi</code> value, and the rest of the column contain <code>psi</code> values computed on permutated versions of the datasets.
</p>
</li>
<li> <p><em>p</em>: a dataframe. The first two columns are as above, the third column contains the probability of obtaining a <code>random psi</code> lower than the real <code>psi</code> by chance.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#load data
data("sequencesMIS")

#prepare sequences
MIS.sequences &lt;- prepareSequences(
  sequences = sequencesMIS,
  grouping.column = "MIS",
  transformation = "hellinger"
  )

#execute workflow to compute psi
MIS.null.psi &lt;- workflowNullPsiHP(
 sequences = MIS.sequences[MIS.sequences$MIS %in% c("MIS-1", "MIS-2"), ],
 grouping.column = "MIS",
 repetitions = 3,
 parallel.execution = FALSE
 )

MIS.null.psi


</code></pre>

<hr>
<h2 id='workflowPartialMatch'>Finds the section in a long sequence that better matches a short sequence.</h2><span id='topic+workflowPartialMatch'></span>

<h3>Description</h3>

<p>This workflow works under the following scenario: the user has a short sequence, and a long sequence, and has the objective of finding the segment in the long sequence that better matches the short sequence. The function identifies automatically the short and the long sequence, but throws an error if more than two sequences are introduced. The lengths of the segments in the long sequence to be compared with the long sequence are defined through the arguments <code>min.length</code> and <code>max.length</code>. If left empty, <code>min.length</code> and <code>max.length</code> equal 0, meaning that the segment to be searched for will have the same number of cases as the short sequence. Note that this is a brute force algorithm, can have a large memory footpring if the interval between <code>min.length</code> and <code>max.length</code> is too long. It might be convenient to pre-check the number of iterations to be performed by computing <code>sum(nrow(long.sequence) - min.length:max.length) + 1</code>. The algorithm is parallelized and optimized as possible, so still, large searches are possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>workflowPartialMatch(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  diagonal = FALSE,
  paired.samples = FALSE,
  min.length = NULL,
  max.length = NULL,
  ignore.blocks = FALSE,
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workflowPartialMatch_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column generated by <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="workflowPartialMatch_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file.</p>
</td></tr>
<tr><td><code id="workflowPartialMatch_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data.</p>
</td></tr>
<tr><td><code id="workflowPartialMatch_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="workflowPartialMatch_+3A_method">method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;. Invalid entries will throw an error.</p>
</td></tr>
<tr><td><code id="workflowPartialMatch_+3A_diagonal">diagonal</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), diagonals are included in the computation of the least cost path. This is the best option if the user suspects that a given segment in the short sequence might be identical to the short sequence.</p>
</td></tr>
<tr><td><code id="workflowPartialMatch_+3A_paired.samples">paired.samples</code></td>
<td>
<p>boolean, if <code>TRUE</code>, the sequences are assumed to be aligned, and distances are computed for paired-samples only (no distance matrix required). Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="workflowPartialMatch_+3A_min.length">min.length</code></td>
<td>
<p>integer, minimum length (in rows) of the subsets of the long sequence to be matched against the short sequence. If <code>NULL</code> (default), the subset of the long sequence to be matched will thave the same number of samples as the short sequence.</p>
</td></tr>
<tr><td><code id="workflowPartialMatch_+3A_max.length">max.length</code></td>
<td>
<p>integer, maximum length (in rows) of the subsets of the long sequence to be matched against the short sequence. If <code>NULL</code> (default), the subset of the long sequence to be matched will thave the same number of samples as the short sequence.</p>
</td></tr>
<tr><td><code id="workflowPartialMatch_+3A_ignore.blocks">ignore.blocks</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the function <code><a href="#topic+leastCostPathNoBlocks">leastCostPathNoBlocks</a></code> analyzes the least-cost path of the best solution, and removes blocks (straight-orthogonal sections of the least-cost path), which happen in highly dissimilar sections of the sequences, and inflate output psi values.</p>
</td></tr>
<tr><td><code id="workflowPartialMatch_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with three columns:
</p>

<ul>
<li> <p><em>first.row</em> first row of the segment in the long sequence matched against the short one.
</p>
</li>
<li> <p><em>last.row</em> last row of the segment in the long sequence matched against the short one.
</p>
</li>
<li> <p><em>psi</em> psi values, ordered from lower (mÃ¡ximum similarity / minimum dissimilarity) to higher.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


#loading the data
data(sequencesMIS)

#removing grouping column
sequencesMIS$MIS &lt;- NULL

#mock-up short sequence
MIS.short &lt;- sequencesMIS[1:10, ]

#mock-up long sequence
MIS.long &lt;- sequencesMIS[1:30, ]

#preparing sequences
MIS.sequences &lt;- prepareSequences(
 sequence.A = MIS.short,
 sequence.A.name = "short",
 sequence.B = MIS.long,
 sequence.B.name = "long",
 grouping.column = "id",
 transformation = "hellinger"
 )

#matching sequences
#min.length and max.length are
#minimal to speed up execution
MIS.psi &lt;- workflowPartialMatch(
 sequences = MIS.sequences,
 grouping.column = "id",
 time.column = NULL,
 exclude.columns = NULL,
 method = "manhattan",
 diagonal = FALSE,
 parallel.execution = FALSE
 )

#output dataframe
MIS.psi



</code></pre>

<hr>
<h2 id='workflowPsi'>Computes the dissimilarity measure <em>psi</em> on two or more sequences.</h2><span id='topic+workflowPsi'></span>

<h3>Description</h3>

<p>If the sequences are not aligned (<code>paired.samples = FALSE</code>), the function executes these steps.
</p>

<ul>
<li><p> Computes the autosum of the sequences with <code><a href="#topic+autoSum">autoSum</a></code>.
</p>
</li>
<li><p> Computes the distance matrix with <code><a href="#topic+distanceMatrix">distanceMatrix</a></code>.
</p>
</li>
<li><p> Uses the distance matrix to compute the least cost matrix with <code><a href="#topic+leastCostMatrix">leastCostMatrix</a></code>.
</p>
</li>
<li><p> Extracts the cost of the least cost path with <code><a href="#topic+leastCost">leastCost</a></code>.
</p>
</li>
<li><p> Computes the dissimilarity measure <em>psi</em> with the function <code><a href="#topic+psi">psi</a></code>.
</p>
</li>
<li><p> Delivers an output of type &quot;list&quot; (default), &quot;data.frame&quot; or &quot;matrix&quot;, depending on the user input, through <code><a href="#topic+formatPsi">formatPsi</a></code>.
</p>
</li></ul>

<p>If the sequences are aligned (<code>paired.samples = TRUE</code>), these steps are executed:
</p>

<ul>
<li><p> Computes the autosum of the sequences with <code><a href="#topic+autoSum">autoSum</a></code>.
</p>
</li>
<li><p> Sums the distances between paired samples with <code><a href="#topic+distancePairedSamples">distancePairedSamples</a></code>.
</p>
</li>
<li><p> Computes the dissimilarity measure <em>psi</em> with the function <code><a href="#topic+psi">psi</a></code>.
</p>
</li>
<li><p> Delivers an output of type &quot;list&quot; (default), &quot;data.frame&quot; or &quot;matrix&quot;, depending on the user input, through <code><a href="#topic+formatPsi">formatPsi</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>workflowPsi(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  diagonal = FALSE,
  format = "dataframe",
  paired.samples = FALSE,
  same.time = FALSE,
  ignore.blocks = FALSE,
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workflowPsi_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column generated by <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="workflowPsi_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file.</p>
</td></tr>
<tr><td><code id="workflowPsi_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data.</p>
</td></tr>
<tr><td><code id="workflowPsi_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="workflowPsi_+3A_method">method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;. Invalid entries will throw an error.</p>
</td></tr>
<tr><td><code id="workflowPsi_+3A_diagonal">diagonal</code></td>
<td>
<p>boolean, if <code>TRUE</code>, diagonals are included in the computation of the least cost path. Defaults to <code>FALSE</code>, as the original algorithm did not include diagonals in the computation of the least cost path. If <code>paired.samples</code> is <code>TRUE</code>, then <code>diagonal</code> is irrelevant.</p>
</td></tr>
<tr><td><code id="workflowPsi_+3A_format">format</code></td>
<td>
<p>string, type of output. One of: &quot;data.frame&quot;, &quot;matrix&quot;. If <code>NULL</code> or empty, a list is returned.</p>
</td></tr>
<tr><td><code id="workflowPsi_+3A_paired.samples">paired.samples</code></td>
<td>
<p>boolean, if <code>TRUE</code>, the sequences are assumed to be aligned, and distances are computed for paired-samples only (no distance matrix required). Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="workflowPsi_+3A_same.time">same.time</code></td>
<td>
<p>boolean. If <code>TRUE</code>, samples in the sequences to compare will be tested to check if they have the same time/age/depth according to <code>time.column</code>. This argument is only useful when the user needs to compare two sequences taken at different sites but same time frames.</p>
</td></tr>
<tr><td><code id="workflowPsi_+3A_ignore.blocks">ignore.blocks</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the function <code><a href="#topic+leastCostPathNoBlocks">leastCostPathNoBlocks</a></code> analyzes the least-cost path of the best solution, and removes blocks (straight-orthogonal sections of the least-cost path), which happen in highly dissimilar sections of the sequences, and inflate output psi values.</p>
</td></tr>
<tr><td><code id="workflowPsi_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, matrix, or dataframe, with sequence names and psi values.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("sequencesMIS")
#prepare sequences
MIS.sequences &lt;- prepareSequences(
  sequences = sequencesMIS,
  grouping.column = "MIS",
  if.empty.cases = "zero",
  transformation = "hellinger"
  )

#execute workflow to compute psi
MIS.psi &lt;- workflowPsi(
 sequences = MIS.sequences[MIS.sequences$MIS %in% c("MIS-1", "MIS-2"), ],
 grouping.column = "MIS",
 time.column = NULL,
 exclude.columns = NULL,
 method = "manhattan",
 diagonal = FALSE,
 parallel.execution = FALSE
 )

MIS.psi



</code></pre>

<hr>
<h2 id='workflowPsiHP'>A refactored version of <code><a href="#topic+workflowPsi">workflowPsi</a></code> with a higher performance (hence the suffix HP).</h2><span id='topic+workflowPsiHP'></span>

<h3>Description</h3>

<p>Ideal for large analyses with hundreds to thousands of sequences. Several options available in <code><a href="#topic+workflowPsi">workflowPsi</a></code> have been removed from this function in order to simplify the code as much as possible. Psi is computed with the options <code>diagonal = TRUE</code>, <code>ignore.blocks = TRUE</code>, and <code>method = "euclidean"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>workflowPsiHP(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  parallel.execution = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workflowPsiHP_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column generated by <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="workflowPsiHP_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file.</p>
</td></tr>
<tr><td><code id="workflowPsiHP_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data.</p>
</td></tr>
<tr><td><code id="workflowPsiHP_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="workflowPsiHP_+3A_parallel.execution">parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to limitations of the function <code><a href="arrangements.html#topic+permutations">permutations</a></code>, the maximum number of groups (according to <code>grouping.column</code>) is around 30000. Besides, a combinations table of this size takes, roughlyl, 7GB of memory.
</p>


<h3>Value</h3>

<p>A dataframe with sequence names and psi values.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("sequencesMIS")
#prepare sequences
MIS.sequences &lt;- prepareSequences(
  sequences = sequencesMIS[sequencesMIS$MIS %in% c("MIS-1", "MIS-2"), ],
  grouping.column = "MIS",
  if.empty.cases = "zero",
  transformation = "hellinger"
  )

#execute workflow to compute psi
MIS.psi &lt;- workflowPsiHP(
 sequences = MIS.sequences,
 grouping.column = "MIS",
 parallel.execution = FALSE
 )

MIS.psi



</code></pre>

<hr>
<h2 id='workflowSlotting'>Slots two sequences into a single composite sequence.</h2><span id='topic+workflowSlotting'></span>

<h3>Description</h3>

<p>Generates a composite sequence, constrained by sample order, from two sequences, by minimizing the dissimilarity between adjacent samples of each input sequence. The algorithm computes the distance matrix, least cost matrix, and least cost path of two sequences, and uses the least cost path file to find the slotting that better minimizes the dissimilarity between adjacent samples. The algorithm assumes that the samples are not aligned or paired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>workflowSlotting(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  plot = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workflowSlotting_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with two sequences identified by a grouping column generated by <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="workflowSlotting_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file.</p>
</td></tr>
<tr><td><code id="workflowSlotting_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data.</p>
</td></tr>
<tr><td><code id="workflowSlotting_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="workflowSlotting_+3A_method">method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;. Invalid entries will throw an error.</p>
</td></tr>
<tr><td><code id="workflowSlotting_+3A_plot">plot</code></td>
<td>
<p>boolean, if <code>TRUE</code>, plots the distance matrix and the least-cost path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the same number of rows as <code>sequences</code>, ordered according to the best solution found by the least-cost algorithm.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#loading the data
data(pollenGP)

#getting first 20 samples
pollenGP &lt;- pollenGP[1:20, ]

#sampling indices
set.seed(10) #to get same result every time
sampling.indices &lt;- sort(sample(1:20, 10))

#subsetting the sequence
A &lt;- pollenGP[sampling.indices, ]
B &lt;- pollenGP[-sampling.indices, ]

#preparing the sequences
AB &lt;- prepareSequences(
  sequence.A = A,
  sequence.A.name = "A",
  sequence.B = B,
  sequence.B.name = "B",
  grouping.column = "id",
  exclude.columns = c("depth", "age"),
  transformation = "hellinger"
  )

AB.combined &lt;- workflowSlotting(
  sequences = AB,
  grouping.column = "id",
  time.column = "age",
  exclude.columns = "depth",
  method = "manhattan",
  plot = TRUE
  )

AB.combined



</code></pre>

<hr>
<h2 id='workflowTransfer'>Transfers an attribute (time, age, depth) from one sequence to another</h2><span id='topic+workflowTransfer'></span>

<h3>Description</h3>

<p>Transfers an attribute (generally time/age, but any others are possible) from one sequence (defined by the argument <code>transfer.from</code>) to another (defined by the argument <code>transfer.to</code>) lacking it. The transference of the attribute is based on the following assumption: similar samples have similar attributes. This assumption might not hold for noisy multivariate time-series. Attribute transference can be done in two different ways (defined by the <code>mode</code> argument):
</p>

<ul>
<li> <p><em>Direct</em>: transfers the selected attribute between samples with the maximum similarity. This option will likely generate duplicated attribute values in the output.
</p>
</li>
<li> <p><em>Interpolate</em>: obtains new attribute values through weighted interpolation, being the weights derived from the distances between samples
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>workflowTransfer(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  transfer.what = NULL,
  transfer.from = NULL,
  transfer.to = NULL,
  mode = "direct",
  plot = FALSE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workflowTransfer_+3A_sequences">sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column generated by <code><a href="#topic+prepareSequences">prepareSequences</a></code>.</p>
</td></tr>
<tr><td><code id="workflowTransfer_+3A_grouping.column">grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file.</p>
</td></tr>
<tr><td><code id="workflowTransfer_+3A_time.column">time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data.</p>
</td></tr>
<tr><td><code id="workflowTransfer_+3A_exclude.columns">exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code> to be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="workflowTransfer_+3A_method">method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;chi&quot;, and &quot;hellinger&quot;. Invalid entries will throw an error.</p>
</td></tr>
<tr><td><code id="workflowTransfer_+3A_transfer.what">transfer.what</code></td>
<td>
<p>character string, column of <code>sequences</code> with the attribute to be transferred. If empty or ill-defined, <code>time.column</code> is used instead if available.</p>
</td></tr>
<tr><td><code id="workflowTransfer_+3A_transfer.from">transfer.from</code></td>
<td>
<p>character string, group available in <code>grouping.column</code> identifying the sequence from which to take the attribute values.</p>
</td></tr>
<tr><td><code id="workflowTransfer_+3A_transfer.to">transfer.to</code></td>
<td>
<p>character string, group available in <code>grouping.column</code> identifying the sequence to which transfer the attribute values.</p>
</td></tr>
<tr><td><code id="workflowTransfer_+3A_mode">mode</code></td>
<td>
<p>character string, one of: &quot;direct&quot; (default), &quot;interpolate&quot;.</p>
</td></tr>
<tr><td><code id="workflowTransfer_+3A_plot">plot</code></td>
<td>
<p>boolean, if <code>TRUE</code>, plots the distance matrix and the least-cost path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the sequence <code>transfer.to</code>, with a column named after <code>transfer.what</code> with the attribute values.
</p>


<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


#loading sample dataset
data(pollenGP)
#subset pollenGP to make a shorter dataset
pollenGP &lt;- pollenGP[1:50, ]

#generating a subset of pollenGP
set.seed(10)
pollenX &lt;- pollenGP[sort(sample(1:50, 40)), ]

#we separate the age column
pollenX.age &lt;- pollenX$age

#and remove the age values from pollenX
pollenX$age &lt;- NULL
pollenX$depth &lt;- NULL

#removing some samples from pollenGP
#so pollenX is not a perfect subset of pollenGP
pollenGP &lt;- pollenGP[-sample(1:50, 10), ]

#prepare sequences
GP.X &lt;- prepareSequences(
  sequence.A = pollenGP,
  sequence.A.name = "GP",
  sequence.B = pollenX,
  sequence.B.name = "X",
  grouping.column = "id",
  time.column = "age",
  exclude.columns = "depth",
  transformation = "none"
  )

#transferring age
X.new &lt;- workflowTransfer(
 sequences = GP.X,
 grouping.column = "id",
 time.column = "age",
 method = "manhattan",
 transfer.what = "age",
 transfer.from = "GP",
 transfer.to = "X",
 mode = "interpolated"
 )



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
