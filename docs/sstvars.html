<!DOCTYPE html><html lang="en"><head><title>Help for package sstvars</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sstvars}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sstvars-package'><p>sstvars: toolkit for reduced form and structural smooth transition vector autoregressive models</p></a></li>
<li><a href='#acidata'><p>A monthly  U.S. data covering the period from 1961I to 2022III (735 observations) and consisting four variables.</p>
First, The Actuaries Climate Index (ACI), which is a measure of the frequency of severe weather and the extend changes in sea levels.
Second, the monthly GDP growth rate constructed by the Federal Reserve Bank of Chicago from a collapsed dynamic factor analysis of
a panel of 500 monthly measures of real economic activity and quarterly real GDP growth. Third, the monthly growth rate of the
consumer price index (CPI). Third, an interest rate variable, which is the effective federal funds rate that is replaced by the
the Wu and Xia (2016) shadow rate during zero-lower-bound periods. The Wu and Xia (2016) shadow rate is not bounded by the zero
lower bound and also quantifies unconventional monetary policy measures, while it closely follows the federal funds rate when the
zero lower bound does not bind.</a></li>
<li><a href='#all_pos_ints'><p>Check whether all arguments are positive integers</p></a></li>
<li><a href='#alt_stvar'><p>Construct a STVAR model based on results from an arbitrary estimation round of <code>fitSTVAR</code></p></a></li>
<li><a href='#bound_JSR'><p>Calculate upper bound for the joint spectral radius of the &quot;companion form AR matrices&quot; of the regimes</p></a></li>
<li><a href='#bound_jsr_G'><p>Calculate upper bound for the joint spectral radius of a set of matrices</p></a></li>
<li><a href='#bounding_const_M'><p>Compute the bounding constant for acceptance-rejection sampling</p></a></li>
<li><a href='#calc_gradient'><p>Calculate gradient or Hessian matrix</p></a></li>
<li><a href='#change_parametrization'><p>Change parametrization of a parameter vector</p></a></li>
<li><a href='#change_regime'><p>Change the parameters of a specific regime of the given parameter vector</p></a></li>
<li><a href='#check_Bt_Cpp'><p>Check Matrix B Invertibility with C++ (Internal Function)</p></a></li>
<li><a href='#check_constraints'><p>Check the constraint matrix has the correct form</p></a></li>
<li><a href='#check_data'><p>Check the data is in the correct form</p></a></li>
<li><a href='#check_exoweights'><p>Checks whether the given exogenous transition weights for simulation are correctly specified.</p></a></li>
<li><a href='#check_params'><p>Check whether the parameter vector is in the parameter space and throw error if not</p></a></li>
<li><a href='#check_pMd'><p>Check that p, M, and d are correctly set</p></a></li>
<li><a href='#check_stvar'><p>Checks whether the given object has class attribute 'stvar'</p></a></li>
<li><a href='#check_weightfun_pars'><p>Check the argument <code>weightfun_pars</code></p></a></li>
<li><a href='#create_Fi_matrix'><p>Create Matrix F_i</p></a></li>
<li><a href='#create_J_matrix'><p>Create a special matrix J</p></a></li>
<li><a href='#diag_Omegas'><p>Simultaneously diagonalize two covariance matrices</p></a></li>
<li><a href='#diagnostic_plot'><p>Residual diagnostic plot for a STVAR model</p></a></li>
<li><a href='#estim_LS'><p>Internal estimation function for estimating autoregressive and threshold parameters of</p>
TVAR models by the method of least squares.</a></li>
<li><a href='#estim_NLS'><p>Internal estimation function for estimating autoregressive and weight parameters of</p>
STVAR models by the method of nonlinear least squares.</a></li>
<li><a href='#filter_estimates'><p>Filter inappropriate the estimates produced by fitSTVAR</p></a></li>
<li><a href='#fitbsSSTVAR'><p>Internal estimation function for estimating STVAR model when bootstrapping confidence</p>
bounds for IRFs in <code>linear_IRF</code></a></li>
<li><a href='#fitSSTVAR'><p>Maximum likelihood estimation of a structural STVAR model based on preliminary estimates from</p>
a reduced form model.</a></li>
<li><a href='#fitSTVAR'><p>Two-phase or three-phase (penalized) maximum likelihood estimation of a reduced form smooth transition VAR model</p></a></li>
<li><a href='#form_boldA'><p>Form the <code class="reqn">(dp\times dp)</code> &quot;bold A&quot; matrices related to the VAR processes</p></a></li>
<li><a href='#format_valuef'><p>Function factory for value formatting</p></a></li>
<li><a href='#GAfit'><p>Genetic algorithm for preliminary estimation of reduced form STVAR models</p></a></li>
<li><a href='#Gaussian_densities_const_Cpp'><p>Calculate log multivariate Gaussian densities</p></a></li>
<li><a href='#Gaussian_densities_Cpp'><p>Calculate log multivariate Gaussian densities</p></a></li>
<li><a href='#gdpdef'><p>U.S. real GDP percent change and GDP implicit price deflator percent change.</p></a></li>
<li><a href='#generate_skewed_t'><p>Generate random samples from the skewed t-distribution</p></a></li>
<li><a href='#get_alpha_mt'><p>Get the transition weights alpha_mt</p></a></li>
<li><a href='#get_boldA_eigens'><p>Calculate absolute values of the eigenvalues of the &quot;bold A&quot; matrices containing the AR coefficients</p></a></li>
<li><a href='#get_boldA_eigens_par'><p>Calculate absolute values of the eigenvalues of the &quot;bold A&quot; matrices containing the AR coefficients</p></a></li>
<li><a href='#get_Bt_Cpp'><p>Calculate the impact matrix <code class="reqn">B_t</code> for all <code class="reqn">t</code> for models with a non-Gaussian</p>
conditional distribution with mutually independent shocks.</a></li>
<li><a href='#get_hetsked_sstvar'><p>Switch from two-regime reduced form STVAR model to a structural model identified by heteroskedasticity</p></a></li>
<li><a href='#get_IC'><p>Calculate AIC, HQIC, and BIC</p></a></li>
<li><a href='#get_minval'><p>Returns the default smallest allowed log-likelihood for given data.</p></a></li>
<li><a href='#get_mu_yt_Cpp'><p>Calculate the conditional means of the process</p></a></li>
<li><a href='#get_new_start'><p>Get the new starting time of series that is forwarded some number of steps</p></a></li>
<li><a href='#get_omega_eigens'><p>Calculate the eigenvalues of the &quot;Omega&quot; error term covariance matrices</p></a></li>
<li><a href='#get_omega_eigens_par'><p>Calculate the eigenvalues of the &quot;Omega&quot; error term covariance matrices</p></a></li>
<li><a href='#get_regime_autocovs'><p>Calculate regimewise autocovariance matrices</p></a></li>
<li><a href='#get_regime_means'><p>Calculate regime means <code class="reqn">\mu_{m}</code></p></a></li>
<li><a href='#get_residuals'><p>Calculate residuals of a smooth transition VAR</p></a></li>
<li><a href='#get_Sigmas'><p>Calculate the dp-dimensional covariance matrices <code class="reqn">\Sigma_{m,p}</code> in the transition weights</p>
with <code>weight_function="relative_dens"</code></a></li>
<li><a href='#get_symmetric_sqrt'><p>Calculate symmetric square root matrix of a positive definite covariance</p>
matrix</a></li>
<li><a href='#GFEVD'><p>Estimate generalized forecast error variance decomposition for structural</p>
STVAR models.</a></li>
<li><a href='#GIRF'><p>Estimate generalized impulse response function for</p>
structural STVAR models.</a></li>
<li><a href='#in_paramspace'><p>Determine whether the parameter vector is in the parameter space</p></a></li>
<li><a href='#ind_skewed_t_densities_Cpp'><p>Calculate log independent multivariate skewed t densities</p></a></li>
<li><a href='#ind_Student_densities_Cpp'><p>Calculate log independent multivariate Student's t densities</p></a></li>
<li><a href='#iterate_more'><p>Maximum likelihood estimation of a reduced form or structural STVAR model based on preliminary estimates</p></a></li>
<li><a href='#linear_IRF'><p>Estimate linear impulse response function based on a single regime of a structural STVAR model.</p></a></li>
<li><a href='#loglikelihood'><p>Log-likelihood function</p></a></li>
<li><a href='#LR_test'><p>Perform likelihood ratio test for a STVAR model</p></a></li>
<li><a href='#mat_power'><p>Compute the j:th power of a square matrix A</p></a></li>
<li><a href='#n_params'><p>Calculate the number of (freely estimaed) parameters in the model</p></a></li>
<li><a href='#order_B'><p>Reorder columns of a square matrix so that the first nonzero elements are</p>
in decreasing order</a></li>
<li><a href='#pick_allA'><p>Pick all coefficient matrices</p></a></li>
<li><a href='#pick_Am'><p>Pick coefficient matrices</p></a></li>
<li><a href='#pick_Ami'><p>Pick coefficient matrix</p></a></li>
<li><a href='#pick_distpars'><p>Pick distribution parameters</p></a></li>
<li><a href='#pick_lambdas'><p>Pick the structural parameter eigenvalues 'lambdas'</p></a></li>
<li><a href='#pick_Omegas'><p>Pick covariance matrices</p></a></li>
<li><a href='#pick_phi0'><p>Pick <code class="reqn">\phi_{m,0}</code> or <code class="reqn">\mu_{m}</code>, m=1,..,M vectors</p></a></li>
<li><a href='#pick_regime'><p>Pick regime parameters</p></a></li>
<li><a href='#pick_W'><p>Pick the structural parameter matrix W</p></a></li>
<li><a href='#pick_weightpars'><p>Pick transition weight parameters</p></a></li>
<li><a href='#plot_struct_shocks'><p>Plot structural shock time series of a STVAR model</p></a></li>
<li><a href='#plot.stvarpred'><p>Predict method for class 'stvar' objects</p></a></li>
<li><a href='#Portmanteau_test'><p>Perform adjusted Portmanteau test for a STVAR model</p></a></li>
<li><a href='#print.hypotest'><p>Print method for the class hypotest</p></a></li>
<li><a href='#print.stvarsum'><p>Summary print method from objects of class 'stvarsum'</p></a></li>
<li><a href='#profile_logliks'><p>Plot profile log-likelihood functions about the estimates</p></a></li>
<li><a href='#random_coefmats'><p>Create random VAR model <code class="reqn">(dxd)</code> coefficient matrices <code class="reqn">A</code>.</p></a></li>
<li><a href='#random_coefmats2'><p>Create random stationary VAR model <code class="reqn">(dxd)</code> coefficient matrices <code class="reqn">A</code>.</p></a></li>
<li><a href='#random_covmat'><p>Create random VAR model error term covariance matrix</p></a></li>
<li><a href='#random_distpars'><p>Create random distribution parameter values</p></a></li>
<li><a href='#random_impactmat'><p>Create random VAR model impact matrix</p></a></li>
<li><a href='#random_ind'><p>Create random mean parametrized parameter vector</p></a></li>
<li><a href='#random_weightpars'><p>Create random transition weight parameter values</p></a></li>
<li><a href='#Rao_test'><p>Perform Rao's score test for a STVAR model</p></a></li>
<li><a href='#redecompose_Omegas'><p>In the decomposition of the covariance matrices (Muirhead, 1982, Theorem A9.9), change</p>
the ordering of the covariance matrices.</a></li>
<li><a href='#reform_constrained_pars'><p>Reform constrained parameter vector into the &quot;standard&quot; form</p></a></li>
<li><a href='#reform_data'><p>Reform data</p></a></li>
<li><a href='#regime_distance'><p>Calculate &quot;distance&quot; between two (scaled) regimes</p>
<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code></a></li>
<li><a href='#reorder_B_columns'><p>Reorder columns of impact matrix B of a structural STVAR model</p>
that is identified by heteroskedasticity or non-Gaussianity.</a></li>
<li><a href='#simulate_from_regime'><p>Simulate observations from a regime of a STVAR model</p></a></li>
<li><a href='#simulate.stvar'><p>Simulate method for class 'stvar' objects</p></a></li>
<li><a href='#skewed_t_dens'><p>The density function of the univariate skewed t distribution</p></a></li>
<li><a href='#smart_covmat'><p>Create random VAR model <code class="reqn">(dxd)</code> error term covariance matrix <code class="reqn">\Omega</code></p>
fairly close to the given <strong>positive definite</strong> covariance matrix using (scaled)
Wishart distribution</a></li>
<li><a href='#smart_distpars'><p>Create random distribution parameter values close to given values</p></a></li>
<li><a href='#smart_impactmat'><p>Create a random VAR model <code class="reqn">(dxd)</code> error impact matrix <code class="reqn">B</code></p>
fairly close to the given <strong>invertible</strong> impact matrix.</a></li>
<li><a href='#smart_ind'><p>Create random parameter vector that is fairly close to a given parameter vector</p></a></li>
<li><a href='#smart_weightpars'><p>Create random transition weight parameter values</p></a></li>
<li><a href='#sort_impactmats'><p>Sort and sign change the columns of the impact matrices of the regimes so that the first element in each column of <code class="reqn">B_1</code></p>
is positive and in a decreasing order.</a></li>
<li><a href='#sort_regimes'><p>Sort regimes in parameter vector according to transition weights into a decreasing order</p></a></li>
<li><a href='#stab_conds_satisfied'><p>Check the stability condition for each of the regimes</p></a></li>
<li><a href='#stand_t_dens'><p>The density function of the univariate t distribution with zero mean and unit variance</p></a></li>
<li><a href='#standard_errors'><p>Calculate standard errors for estimates of a smooth transition VAR model</p></a></li>
<li><a href='#Student_densities_Cpp'><p>Calculate log multivariate Student's t densities</p></a></li>
<li><a href='#STVAR'><p>Create a class 'stvar' object defining a reduced form or structural smooth transition VAR model</p></a></li>
<li><a href='#stvar_to_sstvars110'><p>Update STVAR model estimated with a version of the package &lt;1.1.0 to</p>
be compatible with the versions &gt;=1.1.0.</a></li>
<li><a href='#swap_B_signs'><p>Swap all signs in pointed columns of the impact matrix of a structural STVAR model</p>
that is identified by heteroskedasticity or non-Gaussianity</a></li>
<li><a href='#swap_parametrization'><p>Swap the parametrization of a STVAR model</p></a></li>
<li><a href='#uncond_moments'><p>Calculate the unconditional means, variances, the first p autocovariances, and the first p autocorrelations</p>
of the regimes of the model.</a></li>
<li><a href='#unvec'><p>Reverse vectorization operator</p></a></li>
<li><a href='#unvech'><p>Reverse operator of the parsimonious vectorization operator <code>vech</code></p></a></li>
<li><a href='#unWvec'><p>Reverse vectorization operator that restores zeros</p></a></li>
<li><a href='#usacpu'><p>A monthly  U.S. data covering the period from 1987:4 to 2024:12 (453 observations) and consisting six variables.</p>
First, the climate policy uncertainty index (CPUI) (Gavridiilis, 2021), which is a news based measure of climate policy uncertainty.
Second, the economic policy uncertainty index (EPUI), which is a news based measure of economic policy uncertainty, including also
components quantifying the present value of future scheduled tax code expirations and disagreement among professional forecasters
over future goverment purchases and consumer prices.
Third, the log-difference of real indsitrial production index (IPI).
Fourth, the log-difference of the consumer price index (CPI).
Fifth, the log-difference of the producer price index (PPI).
Sixth, an interest rate variable, which is the effective federal funds rate that is replaced by the
the Wu and Xia (2016) shadow rate during zero-lower-bound periods. The Wu and Xia (2016) shadow rate is not bounded by the zero
lower bound and also quantifies unconventional monetary policy measures, while it closely follows the federal funds rate when the
zero lower bound does not bind. This is the dataset used in Virolainen (2025)</a></li>
<li><a href='#usamone'><p>A quarterly U.S. data covering the period from 1954Q3 to 2021Q4 (270 observations) and consisting three variables:</p>
cyclical component of the log of real GDP, the log-difference of GDP implicit price deflator, and an interest rate variable.
The interest rate variable is the effective federal funds rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016)
shadow rate, which is not constrained by the zero lower bound and also quantifies unconventional monetary policy measures.
The log-differences of the GDP deflator and producer price index are multiplied by hundred.</a></li>
<li><a href='#VAR_pcovmat'><p>Calculate the dp-dimensional covariance matrix of p consecutive</p>
observations of a VAR process</a></li>
<li><a href='#vec'><p>Vectorization operator</p></a></li>
<li><a href='#vech'><p>Parsimonious vectorization operator for symmetric matrices</p></a></li>
<li><a href='#Wald_test'><p>Perform Wald test for a STVAR model</p></a></li>
<li><a href='#warn_eigens'><p>Warn about near-unit-roots in some regimes</p></a></li>
<li><a href='#Wvec'><p>Vectorization operator that removes zeros</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Toolkit for Reduced Form and Structural Smooth Transition Vector
Autoregressive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Savi Virolainen &lt;savi.virolainen@helsinki.fi&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Penalized and non-penalized maximum likelihood estimation of smooth
  transition vector autoregressive models with various types of transition weight
  functions, conditional distributions, and identification methods. Constrained
  estimation with various types of constraints is available. Residual based
  model diagnostics, forecasting, simulations, and calculation of impulse
  response functions, generalized impulse response functions, and generalized 
  forecast error variance decompositions. See
  Heather Anderson, Farshid Vahid (1998) &lt;<a href="https://doi.org/10.1016%2FS0304-4076%2897%2900076-6">doi:10.1016/S0304-4076(97)00076-6</a>&gt;,
  Helmut Lütkepohl, Aleksei Netšunajev (2017) &lt;<a href="https://doi.org/10.1016%2Fj.jedc.2017.09.001">doi:10.1016/j.jedc.2017.09.001</a>&gt;,
  Markku Lanne, Savi Virolainen (2025) &lt;<a href="https://doi.org/10.48550%2FarXiv.2403.14216">doi:10.48550/arXiv.2403.14216</a>&gt;,
  Savi Virolainen (2025) &lt;<a href="https://doi.org/10.48550%2FarXiv.2404.19707">doi:10.48550/arXiv.2404.19707</a>&gt;.    </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/saviviro/sstvars">https://github.com/saviviro/sstvars</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/saviviro/sstvars/issues">https://github.com/saviviro/sstvars/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>BLAS, LAPACK</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), RcppArmadillo (&ge; 0.12.0.0.0), parallel (&ge;
4.0.0), pbapply (&ge; 1.7-0), stats (&ge; 4.0.0), graphics (&ge;
4.0.0), utils (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-27 14:24:31 UTC; savi</td>
</tr>
<tr>
<td>Author:</td>
<td>Savi Virolainen <a href="https://orcid.org/0000-0002-5075-6821"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-27 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sstvars-package'>sstvars: toolkit for reduced form and structural smooth transition vector autoregressive models</h2><span id='topic+sstvars'></span><span id='topic+sstvars-package'></span>

<h3>Description</h3>

<p><code>sstvars</code> is a package for reduced form and structural smooth transition vector
autoregressive models. The package implements various transition weight functions, conditional distributions,
identification methods, and parameter restrictions. The model parameters are estimated with the method of maximum
likelihood or penalized maximum likelihood by running multiple rounds of either a two-phase estimation procedure
or a three-phase procedure. In the former, a genetic algorithm is used to find starting values for a gradient based
variable metric algorithm. In the latter, nonlinear least squares (NLS) first used obtain initial estimates for some
of the parameters, then a genetic algorithm is used to find starting values for the rest of the parameters conditional
on the NLS estimates, and finally a gradient based variable metric algorithm is initialized from the estimates obtained
from the previous two steps. For evaluating the adequacy of the estimated models, <code>sstvars</code> utilizes residuals based
diagnostics and provides functions for graphical diagnostics as well as for calculating formal diagnostic tests.
<code>sstvars</code> also accommodates the estimation of linear impulse response functions, nonlinear generalized impulse response
functions, and generalized forecast error variance decompositions. Further functionality includes hypothesis testing,
plotting the profile log-likelihood functions about the estimate, simulation from STVAR processes, and forecasting, for example.
</p>
<p>The vignette is a good place to start, and see also the readme file.
</p>


<h3>Author(s)</h3>

<p>you &lt;savi.virolainen@helsinki.fi&gt;
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/saviviro/sstvars">https://github.com/saviviro/sstvars</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/saviviro/sstvars/issues">https://github.com/saviviro/sstvars/issues</a>
</p>
</li></ul>


<hr>
<h2 id='acidata'>A monthly  U.S. data covering the period from 1961I to 2022III (735 observations) and consisting four variables.
First, The Actuaries Climate Index (ACI), which is a measure of the frequency of severe weather and the extend changes in sea levels.
Second, the monthly GDP growth rate constructed by the Federal Reserve Bank of Chicago from a collapsed dynamic factor analysis of
a panel of 500 monthly measures of real economic activity and quarterly real GDP growth. Third, the monthly growth rate of the
consumer price index (CPI). Third, an interest rate variable, which is the effective federal funds rate that is replaced by the
the Wu and Xia (2016) shadow rate during zero-lower-bound periods. The Wu and Xia (2016) shadow rate is not bounded by the zero
lower bound and also quantifies unconventional monetary policy measures, while it closely follows the federal funds rate when the
zero lower bound does not bind.</h2><span id='topic+acidata'></span>

<h3>Description</h3>

<p>A monthly  U.S. data covering the period from 1961I to 2022III (735 observations) and consisting four variables.
First, The Actuaries Climate Index (ACI), which is a measure of the frequency of severe weather and the extend changes in sea levels.
Second, the monthly GDP growth rate constructed by the Federal Reserve Bank of Chicago from a collapsed dynamic factor analysis of
a panel of 500 monthly measures of real economic activity and quarterly real GDP growth. Third, the monthly growth rate of the
consumer price index (CPI). Third, an interest rate variable, which is the effective federal funds rate that is replaced by the
the Wu and Xia (2016) shadow rate during zero-lower-bound periods. The Wu and Xia (2016) shadow rate is not bounded by the zero
lower bound and also quantifies unconventional monetary policy measures, while it closely follows the federal funds rate when the
zero lower bound does not bind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acidata
</code></pre>


<h3>Format</h3>

<p>A numeric matrix of class <code>'ts'</code> with 735 rows and 4 columns with one time series in each column:
</p>

<dl>
<dt>First column (GDP):</dt><dd><p>The cyclical component of the log of real GDP, <a href="https://fred.stlouisfed.org/series/GDPC1">https://fred.stlouisfed.org/series/GDPC1</a>.</p>
</dd>
<dt>Second column (GDPDEF):</dt><dd><p>The log-difference of GDP implicit price deflator, <a href="https://fred.stlouisfed.org/series/GDPDEF">https://fred.stlouisfed.org/series/GDPDEF</a>.</p>
</dd>
<dt>Third column (RATE):</dt><dd><p>The Federal funds rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016) shadow rate,
<a href="https://fred.stlouisfed.org/series/FEDFUNDS">https://fred.stlouisfed.org/series/FEDFUNDS</a>, <a href="https://www.atlantafed.org/cqer/research/wu-xia-shadow-federal-funds-rate">https://www.atlantafed.org/cqer/research/wu-xia-shadow-federal-funds-rate</a>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Federal Reserve Bank of St. Louis database and the Federal Reserve Bank of Atlanta's website
</p>


<h3>References</h3>


<ul>
<li><p> American Academy of Actuaries, Canadian Institute of Actuaries, Casualty Actuarial Society,
and Society of Actuaries, 2023. Actuaries Climate Index. https://actuariesclimateindex.org.
</p>
</li>
<li><p> Federal Reserve Bank of Chicago, 2023. Monthly GDP Growth Rate Data. <a href="https://www.chicagofed.org/publications/bbki/index">https://www.chicagofed.org/publications/bbki/index</a>.
</p>
</li>
<li><p> Wu J. and Xia F. 2016. Measuring the macroeconomic impact of monetary policy at the zero lower bound.
<em>Journal of Money, Credit and Banking</em>, 48(2-3): 253-291.
</p>
</li></ul>


<hr>
<h2 id='all_pos_ints'>Check whether all arguments are positive integers</h2><span id='topic+all_pos_ints'></span>

<h3>Description</h3>

<p><code>all_pos_ints</code> checks whether all the elements in a vector
are positive integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_pos_ints(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_pos_ints_+3A_x">x</code></td>
<td>
<p>a vector containing the elements to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> or <code>FALSE</code> accordingly.
</p>

<hr>
<h2 id='alt_stvar'>Construct a STVAR model based on results from an arbitrary estimation round of <code>fitSTVAR</code></h2><span id='topic+alt_stvar'></span>

<h3>Description</h3>

<p><code>alt_stvar</code> constructs a STVAR model based on results from an arbitrary estimation
round of <code>fitSTVAR</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alt_stvar(stvar, which_largest = 1, which_round, calc_std_errors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alt_stvar_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
<tr><td><code id="alt_stvar_+3A_which_largest">which_largest</code></td>
<td>
<p>based on estimation round with which largest log-likelihood should the model be constructed?
An integer value in 1,...,<code>nrounds</code>. For example, <code>which_largest=2</code> would take the second largest log-likelihood
and construct the model based on the corresponding estimates.</p>
</td></tr>
<tr><td><code id="alt_stvar_+3A_which_round">which_round</code></td>
<td>
<p>based on which estimation round should the model be constructed? An integer value in 1,...,<code>nrounds</code>.
If specified, then <code>which_largest</code> is ignored.</p>
</td></tr>
<tr><td><code id="alt_stvar_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's sometimes useful to examine other estimates than the one with the highest log-likelihood. This function
is wrapper around <code>STVAR</code> that picks the correct estimates from an object returned by <code>fitSTVAR</code>.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td></tr>
<tr><td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td></tr>
<tr><td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td></tr>
<tr><td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td></tr>
<tr><td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td></tr>
<tr><td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td></tr>
<tr><td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td></tr>
<tr><td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td></tr>
<tr><td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td></tr>
<tr><td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td></tr>
<tr><td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td></tr>
<tr><td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>The seeds used in the estimation in <code>fitSTVAR</code>, if applicable.</p>
</td></tr>
<tr><td><code>LS_estimates</code></td>
<td>
<p>The least squares estimates of the parameters in the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code> (intercepts replaced by unconditional means
if mean parametrization is used), if applicable.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hubrich K., Teräsvirta. T. 2013. Thresholds and Smooth Transitions in Vector Autoregressive Models.
<em>CREATES Research Paper 2013-18, Aarhus University.</em>
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H., Netšunajev A. 2017. Structural vector autoregressions with smooth transition in variances.
<em>Journal of Economic Dynamics &amp; Control</em>, <strong>84</strong>, 43-57.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+STVAR">STVAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long-running examples that take approximately 10 seconds to run.

# Estimate a Gaussian STVAR p=1, M=2 model with threshold weight function and
# the first lag of the second variable as the switching variables. Run only two
# estimation rounds and use the two-phase estimation method:
fit12 &lt;- fitSTVAR(gdpdef, p=1, M=2, weight_function="threshold", weightfun_pars=c(2, 1),
 nrounds=2, seeds=c(1, 4), estim_method="two-phase")
fit12$loglik # Log-likelihood of the estimated model

# Print the log-likelihood obtained from each estimation round:
fit12$all_logliks

# Construct the model based on the second largest log-likelihood found in the
# estimation procedure:
fit12_alt &lt;- alt_stvar(fit12, which_largest=2, calc_std_errors=FALSE)
fit12_alt$loglik # Log-likelihood of the alternative solution

# Construct a model based on a specific estimation round, the first round:
fit12_alt2 &lt;- alt_stvar(fit12, which_round=1, calc_std_errors=FALSE)
fit12_alt2$loglik # Log-likelihood of the alternative solution

</code></pre>

<hr>
<h2 id='bound_JSR'>Calculate upper bound for the joint spectral radius of the &quot;companion form AR matrices&quot; of the regimes</h2><span id='topic+bound_JSR'></span>

<h3>Description</h3>

<p><code>bound_JSR</code> calculates an bounds for the joint spectral radius of the
&quot;companion form AR matrices&quot; matrices of the regimes to assess the validity of the stationarity condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bound_JSR(
  stvar,
  epsilon = 0.02,
  adaptive_eps = FALSE,
  ncores = 2,
  print_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bound_JSR_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
<tr><td><code id="bound_JSR_+3A_epsilon">epsilon</code></td>
<td>
<p>a strictly positive real number that approximately defines the goal of length of the interval between the lower
and upper bounds. A smaller epsilon value results in a narrower interval, thus providing better accuracy for the bounds,
but at the cost of increased computational effort. Note that the bounds are always wider than <code>epsilon</code> and it is not
obvious what <code>epsilon</code> should be chosen obtain bounds of specific tightness.</p>
</td></tr>
<tr><td><code id="bound_JSR_+3A_adaptive_eps">adaptive_eps</code></td>
<td>
<p>logical: if <code>TRUE</code>, starts with a large epsilon and then decreases it gradually whenever the progress
of the algorithm requires, until the value given in the argument <code>epsilon</code> is reached. Usually speeds up the algorithm
substantially but is an unconventional approach, and there is no guarantee that the algorithm converges appropriately towards
bounds with the tightness given by the argument <code>epsilon</code>.</p>
</td></tr>
<tr><td><code id="bound_JSR_+3A_ncores">ncores</code></td>
<td>
<p>the number of cores to be used in parallel computing.</p>
</td></tr>
<tr><td><code id="bound_JSR_+3A_print_progress">print_progress</code></td>
<td>
<p>logical: should the progress of the algorithm be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sufficient condition for ergodic stationarity of the STVAR processes implemented in <code>sstvars</code> is that the joint
spectral radius of the &quot;companion form AR matrices&quot; of the regimes is smaller than one (Kheifets and Saikkonen, 2020).
This function calculates an upper (and lower) bound for the JSR and is implemented to assess the validity of this condition
in practice. If the bound is smaller than one, the model is deemed ergodic stationary.
</p>
<p>Implements the branch-and-bound method by Gripenberg (1996) in the conventional form (<code>adaptive_eps=FALSE</code>) and in a form
incorporating &quot;adaptive tightness&quot; (<code>adaptive_eps=FALSE</code>). The latter approach is unconventional and does not guarantee
appropriate convergence of the bounds close to the desired tightness given in the argument <code>epsilon</code>, but it usually
substantially speeds up the algorithm. When <code>print_progress==TRUE</code>, the tightest bounds found so-far are printed in each
iteration of the algorithm, so you can also just terminate the algorithm when the bounds are tight enough for your purposes.
Consider also adjusting the argument <code>epsilon</code>, in particular when <code>adaptive_eps=FALSE</code>, as larger epsilon does not
just make the bounds less tight but also speeds up the algorithm significantly. See Chang and Blondel (2013) for a discussion
on variuous methods for bounding the JSR.
</p>


<h3>Value</h3>

<p>Returns lower and upper bounds for the joint spectral radius of the &quot;companion form AR matrices&quot; of the regimes.
</p>


<h3>References</h3>


<ul>
<li><p> C-T Chang and V.D. Blondel. 2013 . An experimental study of approximation algorithms for the joint spectral radius.
<em>Numerical algorithms</em>, <strong>64</strong>, 181-202.
</p>
</li>
<li><p> Gripenberg, G. 1996. Computing the joint spectral radius. <em>Linear Algebra and its Applications</em>,
234, 43–60.
</p>
</li>
<li><p> I.L. Kheifets, P.J. Saikkonen. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available in ArXiv.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bound_jsr_G">bound_jsr_G</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Below examples take approximately 5 seconds to run.

# Gaussian STVAR p=1, M=2 model with weighted relative stationary densities
# of the regimes as the transition weight function:
theta_122relg &lt;- c(0.734054, 0.225598, 0.705744, 0.187897, 0.259626, -0.000863,
  -0.3124, 0.505251, 0.298483, 0.030096, -0.176925, 0.838898, 0.310863, 0.007512,
  0.018244, 0.949533, -0.016941, 0.121403, 0.573269)
mod122 &lt;- STVAR(data=gdpdef, p=1, M=2, params=theta_122relg)

# Absolute values of the eigenvalues of the "companion form AR matrices":
summary(mod122)$abs_boldA_eigens
# It is a necessary (but not sufficient!) condition for ergodic stationary that
# the spectral radius of the "companion form AR matrices" are smaller than one
# for all of the regimes. A sufficient (but not necessary) condition for
# ergodic stationary is that the joint spectral radius of the companion form
# AR matrices" of the regimes is smaller than one. Therefore, we calculate
# bounds for the joint spectral radius.

## Bounds by Gripenberg's (1996) branch-and-bound method:
# Since the largest modulus of the companion form AR matrices is not very close
# to one, we likely won't need very thight bounds to verify the JSR is smaller
# than one. Thus, using a small epsilon would make the algorithm unnecessarily slow,
# so we use the (still quite small) epsilon=0.01:
bound_JSR(mod122, epsilon=0.01, adaptive_eps=FALSE)
# The upper bound is smaller than one, so the model is ergodic stationary.

# If we want tighter bounds, we can set smaller epsilon, e.g., epsilon=0.001:
bound_JSR(mod122, epsilon=0.001, adaptive_eps=FALSE)

# Using adaptive_eps=TRUE usually speeds up the algorithm when the model
# is large, but with the small model here, the speed-difference is small:
bound_JSR(mod122, epsilon=0.001, adaptive_eps=TRUE)

</code></pre>

<hr>
<h2 id='bound_jsr_G'>Calculate upper bound for the joint spectral radius of a set of matrices</h2><span id='topic+bound_jsr_G'></span>

<h3>Description</h3>

<p><code>bound_jsr_G</code> calculates lower and upper bounds for the joint spectral radious of a set of square matrices,
typically the &quot;bold A&quot; matrices, using the algorithm by Gripenberg (1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bound_jsr_G(
  S,
  epsilon = 0.01,
  adaptive_eps = FALSE,
  ncores = 2,
  print_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bound_jsr_G_+3A_s">S</code></td>
<td>
<p>the set of matrices the bounds should be calculated for in an array, in STVAR applications,
all <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; (companion form) matrices in a 3D array, so that <code>[, , m]</code> gives the matrix
the regime <code>m</code>.</p>
</td></tr>
<tr><td><code id="bound_jsr_G_+3A_epsilon">epsilon</code></td>
<td>
<p>a strictly positive real number that approximately defines the goal of length of the interval between the lower
and upper bounds. A smaller epsilon value results in a narrower interval, thus providing better accuracy for the bounds,
but at the cost of increased computational effort. Note that the bounds are always wider than <code>epsilon</code> and it is not
obvious what <code>epsilon</code> should be chosen obtain bounds of specific tightness.</p>
</td></tr>
<tr><td><code id="bound_jsr_G_+3A_adaptive_eps">adaptive_eps</code></td>
<td>
<p>logical: if <code>TRUE</code>, starts with a large epsilon and then decreases it gradually whenever the progress
of the algorithm requires, until the value given in the argument <code>epsilon</code> is reached. Usually speeds up the algorithm
substantially but is an unconventional approach, and there is no guarantee that the algorithm converges appropriately towards
bounds with the tightness given by the argument <code>epsilon</code>.</p>
</td></tr>
<tr><td><code id="bound_jsr_G_+3A_ncores">ncores</code></td>
<td>
<p>the number of cores to be used in parallel computing.</p>
</td></tr>
<tr><td><code id="bound_jsr_G_+3A_print_progress">print_progress</code></td>
<td>
<p>logical: should the progress of the algorithm be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The upper and lower bounds are calculated using the Gripenberg's (1996) branch-and-bound method, which is also discussed
in Chang and Blondel (2013). This function can be generally used for approximating the JSR of a set of square matrices, but the
main intention is STVAR applications (for models created with <code>sstvars</code>, the function <code>bound_JSR</code> should be preferred).
Specifically, Kheifets and Saikkonen (2020) show that if the joint spectral radius of the companion form AR matrices of the regimes
is smaller than one, the STVAR process is ergodic stationary. Virolainen (2025) shows the same result for his parametrization of
of threshold and smooth transition vector autoregressive models. Therefore, if the upper bound is smaller than one, the process is
stationary ergodic. However, as the condition is not necessary but sufficient and also because the bound might be too conservative,
upper bound larger than one does not imply that the process is not ergodic stationary. You can try higher accuracy, and if the bound
is still larger than one, the result does not tell whether the process is ergodic stationary or not.
</p>
<p>Note that with high precision (small <code>epsilon</code>), the computational effort required are substantial and
the estimation may take long, even though the function takes use of parallel computing. This is because
with small epsilon the the number of candidate solutions in each iteration may grow exponentially and a large
number of iterations may be required. For this reason, <code>adaptive_eps=TRUE</code> can be considered for large matrices,
in which case the algorithm starts with a large epsilon, and then decreases it when new candidate solutions are
not found, until the epsilon given by the argument <code>epsilon</code> is reached.
</p>


<h3>Value</h3>

<p>Returns an upper bound for the joint spectral radius of the &quot;companion form AR matrices&quot; of the regimes.
</p>


<h3>References</h3>


<ul>
<li><p> C-T Chang and V.D. Blondel. 2013 . An experimental study of approximation algorithms for the joint spectral radius.
<em>Numerical algorithms</em>, <strong>64</strong>, 181-202.
</p>
</li>
<li><p> Gripenberg, G. 1996. Computing the joint spectral radius. <em>Linear Algebra and its Applications</em>,
234, 43–60.
</p>
</li>
<li><p> I.L. Kheifets, P.J. Saikkonen. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available in ArXiv.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bound_JSR">bound_JSR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Below examples take approximately 5 seconds to run.

# A set of two (5x5) square matrices:
set.seed(1); S1 &lt;- array(rnorm(20*20*2), dim=c(5, 5, 2))

# Bound the joint spectral radius of the set of matrices S1, with the
# approximate tightness epsilon=0.01:
bound_jsr_G(S1, epsilon=0.01, adaptive_eps=FALSE)

# Obtain bounds faster with adaptive_eps=TRUE:
bound_jsr_G(S1, epsilon=0.01, adaptive_eps=TRUE)
# Note that the upper bound is not the same as with adaptive_eps=FALSE.

# A set of three (3x3) square matrices:
set.seed(2); S2 &lt;- array(rnorm(3*3*3), dim=c(3, 3, 3))

# Bound the joint spectral radius of the set of matrices S2:
bound_jsr_G(S2, epsilon=0.01, adaptive_eps=FALSE)

# Larger epsilon terminates the iteration earlier and results in wider bounds:
bound_jsr_G(S2, epsilon=0.05, adaptive_eps=FALSE)

# A set of eight (2x2) square matrices:
set.seed(3); S3 &lt;- array(rnorm(2*2*8), dim=c(2, 2, 8))

# Bound the joint spectral radius of the set of matrices S3:
bound_jsr_G(S3, epsilon=0.01, adaptive_eps=FALSE)

</code></pre>

<hr>
<h2 id='bounding_const_M'>Compute the bounding constant for acceptance-rejection sampling</h2><span id='topic+bounding_const_M'></span>

<h3>Description</h3>

<p><code>bounding_const_M</code> calculates the bounding constant <code class="reqn">M</code> used in the acceptance-rejection sampling algorithm
for the univariate skewed <em>t</em>-distribution described in Hansen (1994)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounding_const_M(nu, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bounding_const_M_+3A_nu">nu</code></td>
<td>
<p>the degrees of freedom parameter value, a numeric scalar strictly larger than two.</p>
</td></tr>
<tr><td><code id="bounding_const_M_+3A_lambda">lambda</code></td>
<td>
<p>the skewness parameter value, a numeric scalar strictly between -1 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the bounding constant <code class="reqn">M</code> required for the acceptance-rejection sampling method by evaluating
the ratio of the skewed <em>t</em>-density (<code><a href="#topic+skewed_t_dens">skewed_t_dens</a></code>) to the standard <em>t</em>-density (<code><a href="#topic+stand_t_dens">stand_t_dens</a></code>)
over a grid of <code class="reqn">y</code> values ranging from <code class="reqn">-10</code> to <code class="reqn">10</code>. To improve the efficiency of the sampling algorithm, the degrees
of freedom parameter for the proposal distribution is set to the minimum of <code>nu</code> and <code class="reqn">3</code>, ensuring heavier tails in the
proposal distribution when <code>nu</code> is large. A safety margin of 10% is added to the maximum ratio to account for numerical
inaccuracies and ensure that the inequality <code class="reqn">f(y) \leq M \cdot q(y)</code> holds over the entire support.
</p>


<h3>Value</h3>

<p>Returns a numeric scalar representing the estimated bounding constant <code class="reqn">M</code> to be used in the acceptance-rejection
sampling algorithm.
</p>


<h3>References</h3>


<ul>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation. <em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li></ul>


<hr>
<h2 id='calc_gradient'>Calculate gradient or Hessian matrix</h2><span id='topic+calc_gradient'></span><span id='topic+calc_hessian'></span><span id='topic+get_gradient'></span><span id='topic+get_hessian'></span><span id='topic+get_foc'></span><span id='topic+get_soc'></span>

<h3>Description</h3>

<p><code>calc_gradient</code> or <code>calc_hessian</code> calculates the gradient or Hessian matrix
of the given function at the given point using central difference numerical approximation.
<code>get_gradient</code> or <code>get_hessian</code> calculates the gradient or Hessian matrix of the
log-likelihood function at the parameter estimates of a class <code>'stvar'</code> object. <code>get_soc</code>
returns eigenvalues of the Hessian matrix, and <code>get_foc</code> is the same as <code>get_gradient</code>
but named conveniently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_gradient(x, fn, h = 0.001, ...)

calc_hessian(x, fn, h = 0.001, ...)

get_gradient(stvar, ...)

get_hessian(stvar, ...)

get_foc(stvar, ...)

get_soc(stvar, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_gradient_+3A_x">x</code></td>
<td>
<p>a numeric vector specifying the point where the gradient or Hessian should be calculated.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_fn">fn</code></td>
<td>
<p>a function that takes in argument <code>x</code> as the <strong>first</strong> argument.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_h">h</code></td>
<td>
<p>difference used to approximate the derivatives: either a positive real number of a vector of
positive real numbers with the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>fn</code> (or argument passed to <code>calc_gradient</code> or <code>calc_hessian</code>).</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In particular, the functions <code>get_foc</code> and <code>get_soc</code> can be used to check whether
the found estimates denote a (local) maximum point, a saddle point, or something else. Note that
profile log-likelihood functions can be conveniently plotted with the function <code>profile_logliks</code>.
</p>


<h3>Value</h3>

<p>Gradient functions return numerical approximation of the gradient and Hessian functions return
numerical approximation of the Hessian. <code>get_soc</code> returns eigenvalues of the Hessian matrix.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a simple function:
foo &lt;- function(x) x^2 + x

# Calculate the gradient at x=1 and x=-0.5:
calc_gradient(x=1, fn=foo)
calc_gradient(x=-0.5, fn=foo)

# Create a more complicated function
foo &lt;- function(x, a, b) a*x[1]^2 - b*x[2]^2

# Calculate the gradient at x=c(1, 2) with parameter values a=0.3 and b=0.1:
calc_gradient(x=c(1, 2), fn=foo, a=0.3, b=0.1)

# Create a linear Gaussian VAR p=1 model:
theta_112 &lt;- c(0.649526, 0.066507, 0.288526, 0.021767, -0.144024, 0.897103,
 0.601786, -0.002945, 0.067224)
mod112 &lt;- STVAR(data=gdpdef, p=1, M=1, params=theta_112)

# Calculate the gradient of the log-likelihood function about the parameter values:
get_foc(mod112)

# Calculate the eigenvalues of the Hessian matrix of the log-likelihood function
# about the parameter values:
get_soc(mod112)
</code></pre>

<hr>
<h2 id='change_parametrization'>Change parametrization of a parameter vector</h2><span id='topic+change_parametrization'></span>

<h3>Description</h3>

<p><code>change_parametrization</code> changes the parametrization of the given parameter
vector to <code>change_to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_parametrization(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL,
  change_to = c("intercept", "mean", "orig", "alt")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="change_parametrization_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="change_parametrization_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="change_parametrization_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_change_to">change_to</code></td>
<td>

<dl>
<dt>If you want to switch between mean and intercept parametrizations:</dt><dd><p>either &quot;intercept&quot; or &quot;mean&quot; specifying
to which parametrization it should be switched to. If set to <code>"intercept"</code>, it's assumed that <code>params</code>
is mean parametrized, and if set to <code>"mean"</code> it's assumed that <code>params</code> is intercept parametrized.</p>
</dd>
<dt>If you want to switch between the paramterizations <code class="reqn">B_{y,t}=\sum_{m=1}^M\alpha_{m,t}B_m</code> and
<code class="reqn">B_{y,t}=B_1 + \sum_{m=2}^M\alpha_{m,t}B_m^{*}</code>, <code class="reqn">B_m^{*} = B_m - B_1</code>:</dt><dd><p>either &quot;orig&quot;
(with <code class="reqn">B_m</code>) or &quot;alt&quot; (with <code class="reqn">B_m^{*}</code>). It is assumed that the parameter vector is in the
other parametrization than the one specified in <code>change_to</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Parametrization cannot be changed for models with mean constraints! Note that changing between &quot;orig&quot; and &quot;alt&quot;
changes the meaning of sign constraints in <code>B_constraints</code> (sign constraints imposed on &quot;alt&quot; is very different to
those imposed on &quot;orig&quot;). Thus, this function should not be used to switch between &quot;orig&quot; and &quot;alt&quot; when sign constraints
are imposed!
</p>


<h3>Value</h3>

<p>Returns parameter vector described in <code>params</code>, but with parametrization changed according
to <code>change_to</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='change_regime'>Change the parameters of a specific regime of the given parameter vector</h2><span id='topic+change_regime'></span>

<h3>Description</h3>

<p><code>change_regime</code> changes the regime parameters
<code class="reqn">(\phi_{m,0},vec(A_{m,1}),...,\vec(A_{m,p}),vech(\Omega_m))</code> (replace <code class="reqn">vech(\Omega_m)</code>
by <code class="reqn">vec(B_m)</code> for <code>cond_dist="ind_Student"</code>)
of the given regime to the new given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_regime(
  p,
  M,
  d,
  params,
  m,
  regime_pars,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="change_regime_+3A_p">p</code></td>
<td>
<p>the autoregressive order of the model</p>
</td></tr>
<tr><td><code id="change_regime_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="change_regime_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="change_regime_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime. If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean
<code class="reqn">\mu_{m}</code>.</p>
</td></tr>
<tr><td><code id="change_regime_+3A_m">m</code></td>
<td>
<p>which regime?</p>
</td></tr>
<tr><td><code id="change_regime_+3A_regime_pars">regime_pars</code></td>
<td>

<dl>
<dt>If <code>cond_dist="Gaussian"</code> or <code>cond_dist="Student"</code>:</dt><dd><p>rhe <code class="reqn">(dp + pd^2 + d(d+1)/2)</code> vector
<code class="reqn">(\phi_{m,0},vec(A_{m,1}),...,\vec(A_{m,p}),vech(\Omega_m))</code>.</p>
</dd>
<dt>If <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p>the <code class="reqn">(dp + pd^2 + d^2 + 1)</code> vector
<code class="reqn">(\phi_{m,0},vec(A_{m,1}),...,\vec(A_{m,p}),vec(B_m))</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained models or structural models. Weight parameters and distribution
parameters are not changed.
</p>


<h3>Value</h3>

<p>Returns parameter vector with <code>m</code>:th regime changed to <code>regime_pars</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='check_Bt_Cpp'>Check Matrix B Invertibility with C++ (Internal Function)</h2><span id='topic+check_Bt_Cpp'></span>

<h3>Description</h3>

<p>This internal function takes a cube of matrices (<code>all_Omegas</code>),
a matrix of weights (<code>alpha_mt</code>), and a numerical tolerance (<code>posdef_tol</code>)
to check the invertibility of weighted sums of the matrices in the cube. For each row
in <code>alpha_mt</code>, it computes a weighted sum of matrices, and checks if this sum is
invertible by verifying that its determinant is not within the specified tolerance of zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_Bt_Cpp(all_Omegas, alpha_mt, posdef_tol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_Bt_Cpp_+3A_all_omegas">all_Omegas</code></td>
<td>
<p>A cube (3D array) of impact matrices, with each slice being an inveritble square matrix.</p>
</td></tr>
<tr><td><code id="check_Bt_Cpp_+3A_alpha_mt">alpha_mt</code></td>
<td>
<p>A matrix of weights, with as many columns as there are slices in <code>all_Omegas</code>.</p>
</td></tr>
<tr><td><code id="check_Bt_Cpp_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>A strictly positive small number used as a tolerance for checking
the invertibility of the matrix. The matrix is considered non-invertible if
its determinant is less than this tolerance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean value: 'TRUE' if all weighted sums are invertible up to the specified
tolerance, 'FALSE' otherwise.
</p>

<hr>
<h2 id='check_constraints'>Check the constraint matrix has the correct form</h2><span id='topic+check_constraints'></span>

<h3>Description</h3>

<p><code>check_constraints</code> checks that the constraints are correctly set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_constraints(
  data,
  p,
  M,
  d,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_constraints_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_constraints_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_constraints_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Does return anything but checks the constraints and throws an error if something is wrong.
</p>

<hr>
<h2 id='check_data'>Check the data is in the correct form</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p><code>check_data</code> checks the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(data, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_data_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="check_data_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Checks the data and tries to correct it. Throws an error if something is wrong and
returns the corrected data otherwise.
</p>

<hr>
<h2 id='check_exoweights'>Checks whether the given exogenous transition weights for simulation are correctly specified.</h2><span id='topic+check_exoweights'></span>

<h3>Description</h3>

<p><code>check_exoweights</code> checks whether the given exogenous transition weights for
simulation are correctly specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_exoweights(M, exo_weights, how_many_rows, name_of_row_number)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_exoweights_+3A_exo_weights">exo_weights</code></td>
<td>
<p>Exogenous transition weights weights given for simulation in some context.</p>
</td></tr>
<tr><td><code id="check_exoweights_+3A_how_many_rows">how_many_rows</code></td>
<td>
<p>how many rows the exogenous weights should have?</p>
</td></tr>
<tr><td><code id="check_exoweights_+3A_name_of_row_number">name_of_row_number</code></td>
<td>
<p>what is the name of the object whose value should determine the
the number of rows in the exogenous weights?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used by simulate.stvar, predict.stvar, GIRF, and GFEVD.
</p>


<h3>Value</h3>

<p>Throws an error if the exogenous weights are incorrectly specified.
</p>

<hr>
<h2 id='check_params'>Check whether the parameter vector is in the parameter space and throw error if not</h2><span id='topic+check_params'></span>

<h3>Description</h3>

<p><code>check_params</code> checks whether the parameter vector is in the parameter
space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_params(
  data,
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL,
  transition_weights,
  allow_unstab = FALSE,
  stab_tol = 0.001,
  posdef_tol = 1e-08,
  distpar_tol = 1e-08,
  weightpar_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_params_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="check_params_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="check_params_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="check_params_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="check_params_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="check_params_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="check_params_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_params_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="check_params_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="check_params_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_params_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="check_params_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="check_params_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="check_params_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
<tr><td><code id="check_params_+3A_transition_weights">transition_weights</code></td>
<td>
<p>(optional; only for models with <code>cond_dist="ind_Student"</code> or <code>identification="non-Gaussianity"</code>)
A <code class="reqn">T \times M</code> matrix containing the transition weights. If <code>cond_dist="ind_Student"</code> checks that the impact matrix
<code class="reqn">\sum_{m=1}^M\alpha_{m,t}^{1/2}B_m</code> is invertible for all <code class="reqn">t=1,...,T</code>.</p>
</td></tr>
<tr><td><code id="check_params_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
<tr><td><code id="check_params_+3A_stab_tol">stab_tol</code></td>
<td>
<p>numerical tolerance for stability of condition of the regimes: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the parameter is considered to be outside the parameter space.
Note that if tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="check_params_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the parameter is considered
to be outside the parameter space. Note that if the tolerance is too small, numerical evaluation of the
log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="check_params_+3A_distpar_tol">distpar_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if the degrees of
freedom parameters is not larger than <code>2 + distpar_tol</code> (applies only if <code>cond_dist="Student"</code>).</p>
</td></tr>
<tr><td><code id="check_params_+3A_weightpar_tol">weightpar_tol</code></td>
<td>
<p>numerical tolerance for weight parameters being in the parameter space. Values closer to
to the border of the parameter space than this are considered to be &quot;outside&quot; the parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an informative error if there is something wrong with the parameter vector.
</p>


<h3>References</h3>


<ul>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # There examples will cause an informative error
 params112_notpd &lt;- c(6.5e-01, 7.0e-01, 2.9e-01, 2.0e-02, -1.4e-01,
  9.0e-01, 6.0e-01, -1.0e-02, 1.0e-07)
 try(check_params(p=1, M=1, d=2, params=params112_notpd))

 params112_notstat &lt;- c(6.5e-01, 7.0e-01, 10.9e-01, 2.0e-02, -1.4e-01,
  9.0e-01, 6.0e-01, -1.0e-02, 1.0e-07)
 try(check_params(p=1, M=1, d=2, params=params112_notstat))

 params112_wronglength &lt;- c(6.5e-01, 7.0e-01, 2.9e-01, 2.0e-02, -1.4e-01,
  9.0e-01, 6.0e-01, -1.0e-02)
 try(check_params(p=1, M=1, d=2, params=params112_wronglength))
</code></pre>

<hr>
<h2 id='check_pMd'>Check that p, M, and d are correctly set</h2><span id='topic+check_pMd'></span>

<h3>Description</h3>

<p><code>check_pMd</code> checks the arguments p, M, and d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pMd(
  p,
  M,
  d,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_pMd_+3A_p">p</code></td>
<td>
<p>the autoregressive order of the model</p>
</td></tr>
<tr><td><code id="check_pMd_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="check_pMd_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an error if something is wrong.
</p>

<hr>
<h2 id='check_stvar'>Checks whether the given object has class attribute 'stvar'</h2><span id='topic+check_stvar'></span>

<h3>Description</h3>

<p><code>check_stvar</code> checks that the object has class attribute 'stvar'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_stvar(object, object_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_stvar_+3A_object">object</code></td>
<td>
<p>S3 object to be tested</p>
</td></tr>
<tr><td><code id="check_stvar_+3A_object_name">object_name</code></td>
<td>
<p>what is the name of the object that should of class 'stvar'?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an error if the object doesn't have the class attribute 'stvar'.
</p>

<hr>
<h2 id='check_weightfun_pars'>Check the argument <code>weightfun_pars</code></h2><span id='topic+check_weightfun_pars'></span>

<h3>Description</h3>

<p><code>check_weightfun_pars</code> checks that the argument <code>weightfun_pars</code>.
is correctly set, if not, tries to correct them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_weightfun_pars(
  data,
  p,
  M,
  d,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_weightfun_pars_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="check_weightfun_pars_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="check_weightfun_pars_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="check_weightfun_pars_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="check_weightfun_pars_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_weightfun_pars_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Does checks the argument <code>weightfun_pars</code> and throws an error if something is wrong; returns
a corrected version of the argument if possible.
</p>

<hr>
<h2 id='create_Fi_matrix'>Create Matrix F_i</h2><span id='topic+create_Fi_matrix'></span>

<h3>Description</h3>

<p><code>create_Fi_matrix</code> function generates a <code class="reqn">(T_obs \times T_obs)</code> matrix
with 1's on the <code>(i+1)</code>-th sub-diagonal and 0's elsewhere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_Fi_matrix(i, T_obs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_Fi_matrix_+3A_i">i</code></td>
<td>
<p>Integer, the lag for which the matrix is constructed, corresponding to the sub-diagonal filled with 1's.</p>
</td></tr>
<tr><td><code id="create_Fi_matrix_+3A_t_obs">T_obs</code></td>
<td>
<p>Integer, the number of time periods or observations in the dataset, corresponding to the dimensions of the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used in <code>Portmanteau_test</code>. The matrix <code class="reqn">F_i</code> in Lütkepohl (2005), p.158.
</p>


<h3>Value</h3>

<p>A <code class="reqn">(T_obs \times T_obs)</code> matrix with 1's on the <code>(i+1)</code>-th sub-diagonal and 0's elsewhere.
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl, H. (2005). New Introduction to Multiple Time Series Analysis. Springer.
</p>
</li></ul>


<hr>
<h2 id='create_J_matrix'>Create a special matrix J</h2><span id='topic+create_J_matrix'></span>

<h3>Description</h3>

<p><code>create_J_matrix</code> generates a d x dp matrix J, where the first d x d block is the identity matrix I_d,
and the rest is filled with zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_J_matrix(d, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_J_matrix_+3A_d">d</code></td>
<td>
<p>An integer representing the dimension of the identity matrix.</p>
</td></tr>
<tr><td><code id="create_J_matrix_+3A_p">p</code></td>
<td>
<p>An integer representing the factor by which to extend the matrix with zeros.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">d x dp</code> matrix <code class="reqn">J</code> where the first <code class="reqn">d x d</code> block is the identity matrix <code class="reqn">I_d</code>,
and the rest is filled with zeros.
</p>

<hr>
<h2 id='diag_Omegas'>Simultaneously diagonalize two covariance matrices</h2><span id='topic+diag_Omegas'></span>

<h3>Description</h3>

<p><code>diag_Omegas</code> Simultaneously diagonalizes two covariance matrices using
eigenvalue decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_Omegas(Omega1, Omega2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diag_Omegas_+3A_omega1">Omega1</code></td>
<td>
<p>a positive definite <code class="reqn">(dxd)</code> covariance matrix <code class="reqn">(d&gt;1)</code></p>
</td></tr>
<tr><td><code id="diag_Omegas_+3A_omega2">Omega2</code></td>
<td>
<p>another positive definite <code class="reqn">(dxd)</code> covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the return value and Muirhead (1982), Theorem A9.9 for details.
</p>


<h3>Value</h3>

<p>Returns a length <code class="reqn">d^2 + d</code> vector where the first <code class="reqn">d^2</code> elements
are <code class="reqn">vec(W)</code> with the columns of <code class="reqn">W</code> being (specific) eigenvectors of
the matrix <code class="reqn">\Omega_2\Omega_1^{-1}</code> and the rest <code class="reqn">d</code> elements are the
corresponding eigenvalues &quot;lambdas&quot;. The result satisfies <code class="reqn">WW' = Omega1</code> and
<code class="reqn">Wdiag(lambdas)W' = Omega2</code>.
</p>
<p>If <code>Omega2</code> is not supplied, returns a vectorized symmetric (and pos. def.)
square root matrix of <code>Omega1</code>.
</p>


<h3>Warning</h3>

<p>No argument checks! Does not work with dimension <code class="reqn">d=1</code>!
</p>


<h3>References</h3>


<ul>
<li><p> Muirhead R.J. 1982. Aspects of Multivariate Statistical Theory, <em>Wiley</em>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create two (2x2) coviance matrices using the parameters W and lambdas:
d &lt;- 2 # The dimension
W0 &lt;- matrix(1:(d^2), nrow=2) # W
lambdas0 &lt;- 1:d # The eigenvalues
(Omg1 &lt;- W0%*%t(W0)) # The first covariance matrix
(Omg2 &lt;- W0%*%diag(lambdas0)%*%t(W0)) # The second covariance matrix

# Then simultaneously diagonalize the covariance matrices:
res &lt;- diag_Omegas(Omg1, Omg2)

# Recover W:
W &lt;- matrix(res[1:(d^2)], nrow=d, byrow=FALSE)
tcrossprod(W) # == Omg1, the first covariance matrix

# Recover lambdas:
lambdas &lt;- res[(d^2 + 1):(d^2 + d)]
W%*%diag(lambdas)%*%t(W) # == Omg2, the second covariance matrix
</code></pre>

<hr>
<h2 id='diagnostic_plot'>Residual diagnostic plot for a STVAR model</h2><span id='topic+diagnostic_plot'></span>

<h3>Description</h3>

<p><code>diagnostic_plot</code> plots a multivariate residual diagnostic plot
for either autocorrelation, conditional heteroskedasticity, or distribution,
or simply draws the residual time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic_plot(
  stvar,
  type = c("all", "series", "ac", "ch", "dist"),
  resid_type = c("standardized", "raw"),
  maxlag = 12
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnostic_plot_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
<tr><td><code id="diagnostic_plot_+3A_type">type</code></td>
<td>
<p>which type of diagnostic plot should be plotted?
</p>

<ul>
<li><p><code>"all"</code> all below sequentially.
</p>
</li>
<li><p><code>"series"</code> the residual time series.
</p>
</li>
<li><p><code>"ac"</code> the residual autocorrelation and cross-correlation functions.
</p>
</li>
<li><p><code>"ch"</code> the squared residual autocorrelation and cross-correlation functions.
</p>
</li>
<li><p><code>"dist"</code> the residual histogram with theoretical density (dashed line) and QQ-plots.
</p>
</li></ul>
</td></tr>
<tr><td><code id="diagnostic_plot_+3A_resid_type">resid_type</code></td>
<td>
<p>should standardized or raw residuals be used?</p>
</td></tr>
<tr><td><code id="diagnostic_plot_+3A_maxlag">maxlag</code></td>
<td>
<p>the maximum lag considered in types <code>"ac"</code> and <code>"ch"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Auto- and cross-correlations (types <code>"ac"</code> and <code>"ch"</code>) are calculated with the function
<code>acf</code> from the package <code>stats</code> and the plot method for class <code>'acf'</code> objects is employed.
</p>
<p>If <code>cond_dist == "Student"</code> or <code>"ind_Student"</code>, the estimates of the degrees of freedom parameters is used in
theoretical densities and quantiles. If <code>cond_dist == "ind_skewed_t"</code>, the estimates of the degrees of freedom and
skewness parameters are used in theoretical densities and quantiles, and the quantile function is computed numerically.
</p>


<h3>Value</h3>

<p>No return value, called for its side effect of plotting the diagnostic plot.
</p>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation.
<em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>International Economic Review</em>, <strong>35</strong>:3, 407-414.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+Portmanteau_test">Portmanteau_test</a></code>, <code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>,
<code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>, <code><a href="#topic+Rao_test">Rao_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gaussian STVAR p=1, M=2 model, with weighted relative stationary densities
# of the regimes as the transition weight function:
theta_122relg &lt;- c(0.734054, 0.225598, 0.705744, 0.187897, 0.259626, -0.000863,
  -0.3124, 0.505251, 0.298483, 0.030096, -0.176925, 0.838898, 0.310863, 0.007512,
  0.018244, 0.949533, -0.016941, 0.121403, 0.573269)
mod122 &lt;- STVAR(data=gdpdef, p=1, M=2, params=theta_122relg)

# Autocorelation function of raw residuals for checking remaining autocorrelation:
diagnostic_plot(mod122, type="ac", resid_type="raw")

# Autocorelation function of squared standardized residuals for checking remaining
# conditional heteroskedasticity:
diagnostic_plot(mod122, type="ch", resid_type="standardized")

# Below, ACF of squared raw residuals, which is not very informative for evaluating
# adequacy to capture conditional heteroskedasticity, since it doesn't take into account
# the time-varying conditional covariance matrix of the model:
diagnostic_plot(mod122, type="ch", resid_type="raw")

# Similarly, below the time series of raw residuals first, and then the
# time series of standardized residuals. The latter is more informative
# for evaluating adequacy:
diagnostic_plot(mod122, type="series", resid_type="raw")
diagnostic_plot(mod122, type="series", resid_type="standardized")

# Also similarly, histogram and Q-Q plots are more informative for standardized
# residuals when evaluating model adequacy:
diagnostic_plot(mod122, type="dist", resid_type="raw") # Bad fit for GDPDEF
diagnostic_plot(mod122, type="dist", resid_type="standardized") # Good fit for GDPDEF

## Linear Gaussian VAR p=1 model:
theta_112 &lt;- c(0.649526, 0.066507, 0.288526, 0.021767, -0.144024, 0.897103,
  0.601786, -0.002945, 0.067224)
mod112 &lt;- STVAR(data=gdpdef, p=1, M=1, params=theta_112)
diagnostic_plot(mod112, resid_type="standardized") # All plots for std. resids
diagnostic_plot(mod112, resid_type="raw") # All plots for raw residuals
</code></pre>

<hr>
<h2 id='estim_LS'>Internal estimation function for estimating autoregressive and threshold parameters of
TVAR models by the method of least squares.</h2><span id='topic+estim_LS'></span>

<h3>Description</h3>

<p><code>estim_LS</code> estimates the autoregressive and threshold parameters of TVAR models
by the method of least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_LS(
  data,
  p,
  M,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  penalized = TRUE,
  penalty_params = c(0.05, 0.2),
  min_obs_coef = 3,
  sparse_grid = FALSE,
  use_parallel = TRUE,
  ncores = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_LS_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="estim_LS_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_penalized">penalized</code></td>
<td>
<p>Perform penalized LS estimation that minimizes penalized RSS in which estimates close to breaking or not satisfying the
usual stability condition are penalized? If <code>TRUE</code>, the tuning parameter is set by the argument <code>penalty_params[2]</code>,
and the penalization starts when the eigenvalues of the companion form AR matrix are larger than <code>1 - penalty_params[1]</code>.</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_penalty_params">penalty_params</code></td>
<td>
<p>a numeric vector with two positive elements specifying the penalization parameters:
the first element determined how far from the boundary of the stability region the penalization starts
(a number between zero and one, smaller number starts penalization closer to the boundary) and the second element
is a tuning parameter for the penalization (a positive real number, a higher value penalizes non-stability more).</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_min_obs_coef">min_obs_coef</code></td>
<td>
<p>the smallest accepted number of observations (times variables) from each regime
relative to the number of parameters in the regime. For models with AR constraints, the number of
AR matrix parameters in each regimes is simplisticly assumed to be <code>ncol(AR_constraints)/M</code>.</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_sparse_grid">sparse_grid</code></td>
<td>
<p>should the grid of weight function values in LS/NLS estimation be more sparse (speeding up the estimation)?</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_use_parallel">use_parallel</code></td>
<td>
<p>employ parallel computing? If <code>FALSE</code>, does not print anything.</p>
</td></tr>
<tr><td><code id="estim_LS_+3A_ncores">ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally in the multiple phase estimation procedure proposed by Koivisto,
Luoto, and Virolainen (2025). Mean constraints are not supported. Only weight constraints that
specify the threshold parameters as fixed values are supported. Only intercept parametrization is
supported.
</p>


<h3>Value</h3>

<p>Returns the estimated parameters in a vector of the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code>, where
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code> the <code class="reqn">(M-1\times 1)</code> vector of the threshold parameters.
</p>
</li></ul>

<p>For models with...
</p>

<dl>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Hubrich K., Teräsvirta. T. 2013. Thresholds and Smooth Transitions in Vector Autoregressive Models.
<em>CREATES Research Paper 2013-18, Aarhus University.</em>
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>


<hr>
<h2 id='estim_NLS'>Internal estimation function for estimating autoregressive and weight parameters of
STVAR models by the method of nonlinear least squares.</h2><span id='topic+estim_NLS'></span>

<h3>Description</h3>

<p><code>estim_NLS</code> estimates the autoregressive and weight parameters of STVAR models
by the method of least squares (<code>relative_dens</code> weight function is not supported).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_NLS(
  data,
  p,
  M,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  penalized = TRUE,
  penalty_params = c(0.05, 0.2),
  min_obs_coef = 3,
  sparse_grid = FALSE,
  use_parallel = TRUE,
  ncores = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_NLS_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="estim_NLS_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_penalized">penalized</code></td>
<td>
<p>Perform penalized LS estimation that minimizes penalized RSS in which estimates close to breaking or not satisfying the
usual stability condition are penalized? If <code>TRUE</code>, the tuning parameter is set by the argument <code>penalty_params[2]</code>,
and the penalization starts when the eigenvalues of the companion form AR matrix are larger than <code>1 - penalty_params[1]</code>.</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_penalty_params">penalty_params</code></td>
<td>
<p>a numeric vector with two positive elements specifying the penalization parameters:
the first element determined how far from the boundary of the stability region the penalization starts
(a number between zero and one, smaller number starts penalization closer to the boundary) and the second element
is a tuning parameter for the penalization (a positive real number, a higher value penalizes non-stability more).</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_min_obs_coef">min_obs_coef</code></td>
<td>
<p>the smallest accepted number of observations (times variables) from each regime
relative to the number of parameters in the regime. For models with AR constraints, the number of
AR matrix parameters in each regimes is simplisticly assumed to be <code>ncol(AR_constraints)/M</code>.</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_sparse_grid">sparse_grid</code></td>
<td>
<p>should the grid of weight function values in LS/NLS estimation be more sparse (speeding up the estimation)?</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_use_parallel">use_parallel</code></td>
<td>
<p>employ parallel computing? If <code>FALSE</code>, does not print anything.</p>
</td></tr>
<tr><td><code id="estim_NLS_+3A_ncores">ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally in the multiple phase estimation procedure proposed by Virolainen (2025).
The weight function <code>relative_dens</code> is not supported.  Mean constraints are not supported.
Only weight constraints that specify the weight parameters as fixed values are supported.
Only intercept parametrization is supported.
</p>


<h3>Value</h3>

<p>Returns the estimated parameters in a vector of the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code>, where
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li><p><code class="reqn">\alpha</code> is the vector of the weight parameters: </p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
</dl>

</li></ul>

<p>For models with...
</p>

<dl>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Hubrich K., Teräsvirta. T. 2013. Thresholds and Smooth Transitions in Vector Autoregressive Models.
<em>CREATES Research Paper 2013-18, Aarhus University.</em>
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>


<hr>
<h2 id='filter_estimates'>Filter inappropriate the estimates produced by fitSTVAR</h2><span id='topic+filter_estimates'></span>

<h3>Description</h3>

<p><code>filter_estimates</code> filters out inappropriate estimates produced by <code>fitSTVAR</code>:
can be used to obtain the (possibly) appropriate estimate with the largest found log-likelihood
(among possibly appropriate estimates) as well as (possibly) appropriate estimates based on smaller
log-likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_estimates(
  stvar,
  which_largest = 1,
  filter_stab = TRUE,
  calc_std_errors = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_estimates_+3A_stvar">stvar</code></td>
<td>
<p>a class 'stvar' object defining a structural STVAR model that is identified by heteroskedasticity
or non-Gaussianity, typically created with <code>fitSSTVAR</code>.</p>
</td></tr>
<tr><td><code id="filter_estimates_+3A_which_largest">which_largest</code></td>
<td>
<p>an integer at least one specifying the (possibly) appropriate estimate corresponding
to which largest log-likelihood should be returned. E.g., if <code>which_largest=2</code>, the function will
return among the estimates that it does not deem inappropriate the one that has the second largest log-likelihood.</p>
</td></tr>
<tr><td><code id="filter_estimates_+3A_filter_stab">filter_stab</code></td>
<td>
<p>Should estimates close to breaking the usual stability condition be filtered out?</p>
</td></tr>
<tr><td><code id="filter_estimates_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function goes through the estimates produced by <code>fitSTVAR</code> and checks which estimates are
deemed inappropriate. That is, estimates that are not likely solutions of interest. Specifically, solutions
that incorporate a near-singular error term covariance matrix (any eigenvalue less than <code class="reqn">0.002</code>),
any modulus of the eigenvalues of the companion form AR matrices larger than $0.9985$ (indicating the
necessary condition for stationarity is close to break), or transition weights such that they are close to zero
for almost all <code class="reqn">t</code> for at least one regime. Then, among the solutions are not deemed inappropriate, it
returns a STVAR models based on the estimate that has the <code>which_largest</code> largest log-likelihood.
</p>
<p>The function <code>filter_estimates</code> is kind of a version of <code>alt_stvar</code> that only considers estimates
that are not deemed inappropriate
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td></tr>
<tr><td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td></tr>
<tr><td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td></tr>
<tr><td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td></tr>
<tr><td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td></tr>
<tr><td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td></tr>
<tr><td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td></tr>
<tr><td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td></tr>
<tr><td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td></tr>
<tr><td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td></tr>
<tr><td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td></tr>
<tr><td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>The seeds used in the estimation in <code>fitSTVAR</code>, if applicable.</p>
</td></tr>
<tr><td><code>LS_estimates</code></td>
<td>
<p>The least squares estimates of the parameters in the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code> (intercepts replaced by unconditional means
if mean parametrization is used), if applicable.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+alt_stvar">alt_stvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Fit a two-regime STVAR model with logistic transition weights and Student's t errors,
 # and use two-phase estimation method:
 fit12 &lt;- fitSTVAR(gdpdef, p=1, M=2, weight_function="logistic", weightfun_pars=c(2, 1),
  cond_dist="Student", nrounds=2, ncores=2, seeds=1:2, estim_method="two-phase")
 fit12

 # Filter through inappropriate estimates and obtain the second best appropriate solution:
 fit12_2 &lt;- filter_estimates(fit12, which_largest=2)
 fit12_2 # The same model since the two estimation rounds yielded the same estimate

</code></pre>

<hr>
<h2 id='fitbsSSTVAR'>Internal estimation function for estimating STVAR model when bootstrapping confidence
bounds for IRFs in <code>linear_IRF</code></h2><span id='topic+fitbsSSTVAR'></span>

<h3>Description</h3>

<p><code>fitbsSSTVAR</code> uses a robust method and a variable metric algorithm to estimate
a structural STVAR model based on preliminary estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitbsSSTVAR(
  data,
  p,
  M,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL,
  other_constraints = NULL,
  robust_method = c("Nelder-Mead", "SANN", "none"),
  penalized = FALSE,
  penalty_params = c(0.05, 0.2),
  allow_unstab = FALSE,
  minval = NULL,
  maxit = 1000,
  maxit_robust = 1000,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitbsSSTVAR_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_other_constraints">other_constraints</code></td>
<td>
<p>A list containing internally used additional type of constraints (see the options below).
</p>

<dl>
<dt>$fixed_lambdas (only if <code>identification="heteroskedasticity"</code>):</dt><dd><p>a length <code class="reqn">d(M-1)</code> numeric vector
(<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger
than zero specifying the fixed parameter values for the parameters <code class="reqn">\lambda_{mi}</code> should be constrained to.</p>
</dd>
<dt>$B1_constraints (only if <code>identification="non-Gaussianity"</code>):</dt><dd><p>set to the string &quot;fixed_sign_and_order&quot;
to impose the constraints that the elements of the first impact matrix <code class="reqn">B_1</code> are strictly positive and that they
are in a decreasing order.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_robust_method">robust_method</code></td>
<td>
<p>Should some robust estimation method be used in the estimation before switching
to the gradient based variable metric algorithm? See details.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_penalized">penalized</code></td>
<td>
<p>Perform penalized LS estimation that minimizes penalized RSS in which estimates close to breaking or not satisfying the
usual stability condition are penalized? If <code>TRUE</code>, the tuning parameter is set by the argument <code>penalty_params[2]</code>,
and the penalization starts when the eigenvalues of the companion form AR matrix are larger than <code>1 - penalty_params[1]</code>.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_penalty_params">penalty_params</code></td>
<td>
<p>a numeric vector with two positive elements specifying the penalization parameters:
the first element determined how far from the boundary of the stability region the penalization starts
(a number between zero and one, smaller number starts penalization closer to the boundary) and the second element
is a tuning parameter for the penalization (a positive real number, a higher value penalizes non-stability more).</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_minval">minval</code></td>
<td>
<p>the value that will be returned if the parameter vector does not lie in the parameter space
(excluding the identification condition).</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations in the variable metric algorithm.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_maxit_robust">maxit_robust</code></td>
<td>
<p>the maximum number of iterations on the first phase robust estimation, if employed.</p>
</td></tr>
<tr><td><code id="fitbsSSTVAR_+3A_seed">seed</code></td>
<td>
<p>the seed for the random number generator (relevant when using SANN).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally in the functions <code>linear_IRF</code> for estimating the model in each bootstrap replication.
</p>
<p>Employs the estimation function <code>optim</code> from the package <code>stats</code> that implements the optimization
algorithms.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td></tr>
<tr><td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td></tr>
<tr><td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td></tr>
<tr><td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td></tr>
<tr><td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td></tr>
<tr><td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td></tr>
<tr><td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td></tr>
<tr><td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td></tr>
<tr><td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td></tr>
<tr><td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td></tr>
<tr><td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td></tr>
<tr><td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>The seeds used in the estimation in <code>fitSTVAR</code>, if applicable.</p>
</td></tr>
<tr><td><code>LS_estimates</code></td>
<td>
<p>The least squares estimates of the parameters in the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code> (intercepts replaced by unconditional means
if mean parametrization is used), if applicable.</p>
</td></tr>
</table>


<h3>warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Lütkepohl H., Netšunajev A. 2017. Structural vector autoregressions with smooth transition in variances.
<em>Journal of Economic Dynamics &amp; Control</em>, <strong>84</strong>, 43-57.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+linear_IRF">linear_IRF</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>
</p>

<hr>
<h2 id='fitSSTVAR'>Maximum likelihood estimation of a structural STVAR model based on preliminary estimates from
a reduced form model.</h2><span id='topic+fitSSTVAR'></span>

<h3>Description</h3>

<p><code>fitSSTVAR</code> uses a robust method and a variable metric algorithm to estimate
a structural STVAR model based on preliminary estimates from a reduced form model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSSTVAR(
  stvar,
  identification = c("recursive", "heteroskedasticity", "non-Gaussianity"),
  B_constraints = NULL,
  B_pm_reg = NULL,
  B_perm = NULL,
  B_signs = NULL,
  maxit = 1000,
  maxit_robust = 1000,
  robust_method = c("Nelder-Mead", "SANN", "none"),
  print_res = TRUE,
  calc_std_errors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitSSTVAR_+3A_stvar">stvar</code></td>
<td>
<p>a an object of class <code>'stvar'</code>, created by, e.g., <code>fitSTVAR</code>,
specifying a reduced form or a structural model</p>
</td></tr>
<tr><td><code id="fitSSTVAR_+3A_identification">identification</code></td>
<td>
<p>Which identification should the structural model use?
(see the vignette or the references for details)
</p>

<dl>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fitSSTVAR_+3A_b_constraints">B_constraints</code></td>
<td>
<p>Employ further constraints on the impact matrix?
A <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> due to the (in)availability of appropriate
parametrizations that allow such constraints to be imposed.</p>
</td></tr>
<tr><td><code id="fitSSTVAR_+3A_b_pm_reg">B_pm_reg</code></td>
<td>
<p>an integer between <code class="reqn">1</code> and <code class="reqn">M</code> specifying the regime the permutations and sign changes of <code class="reqn">B_m</code>
specified in the arguments <code>B_perm</code> and <code>B_signs</code> are applied to.</p>
</td></tr>
<tr><td><code id="fitSSTVAR_+3A_b_perm">B_perm</code></td>
<td>
<p>a numeric vector of length <code class="reqn">d</code> specifying the permutation of the columns of the impact matrix <code class="reqn">B_m</code>
of a single regime specified in the argument <code>B_pm_reg</code> prior to re-estimating the model. Applicable only for models
with <code>cond_dist = "ind_Student"</code> or <code>"ind_skewed_t"</code>.</p>
</td></tr>
<tr><td><code id="fitSSTVAR_+3A_b_signs">B_signs</code></td>
<td>
<p>a numeric vector specifying the columns of the impact matrix of a single regime specified in the argument
<code>B_pm_reg</code> that should be multiplied by -1 <strong>prior</strong> to reordering them according to <code>B_perm</code> (if specified).
Applicable only for models with <code>cond_dist = "ind_Student"</code> or <code>"ind_skewed_t"</code>.</p>
</td></tr>
<tr><td><code id="fitSSTVAR_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations in the variable metric algorithm.</p>
</td></tr>
<tr><td><code id="fitSSTVAR_+3A_maxit_robust">maxit_robust</code></td>
<td>
<p>the maximum number of iterations on the first phase robust estimation, if employed.</p>
</td></tr>
<tr><td><code id="fitSSTVAR_+3A_robust_method">robust_method</code></td>
<td>
<p>Should some robust estimation method be used in the estimation before switching
to the gradient based variable metric algorithm? See details.</p>
</td></tr>
<tr><td><code id="fitSSTVAR_+3A_print_res">print_res</code></td>
<td>
<p>should summaries of estimation results be printed?</p>
</td></tr>
<tr><td><code id="fitSSTVAR_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>Calculate approximate standard errors (based on standard asymptotics)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the structural model does not impose overidentifying constraints, it is directly
obtained from the reduced form model, and estimation is not required. When overidentifying constraints
are imposed, the model is estimated subject to the constraints.
</p>
<p>Using the robust estimation method before switching to the variable metric can be useful if the initial
estimates are not very close to the ML estimate of the structural model, as the variable metric algorithm
(usually) converges to a nearby local maximum or saddle point. However, if the initial estimates are far from
the ML estimate, the resulting solution is likely local only due to the complexity of the model. Note that
Nelder-Mead algorithm is much faster than SANN but can get stuck at a local solution.
This is particularly the case when the imposed overidentifying restrictions are such that the unrestricted
estimate is not close to satisfying them. Nevertheless, in most practical cases, the model is just identified
and estimation is not required, and often reasonable overidentifying constraints are close to the unrestricted estimate.
</p>
<p>Employs the estimation function <code>optim</code> from the package <code>stats</code> that implements the optimization
algorithms. See <code>?optim</code> for the documentation on the optimization methods.
</p>
<p>The arguments <code>B_pm_reg</code>, <code>B_perm</code>, and <code>B_signs</code> can be used to explore estimates based various orderings
and sign changes of the columns of the impact matrices <code class="reqn">B_m</code> of specific regimes. This can be useful in the presence
of weak identification with respect to the ordering or signs of the columns <code class="reqn">B_2,...,B_M</code> (see Virolainen 2025).
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td></tr>
<tr><td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td></tr>
<tr><td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td></tr>
<tr><td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td></tr>
<tr><td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td></tr>
<tr><td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td></tr>
<tr><td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td></tr>
<tr><td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td></tr>
<tr><td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td></tr>
<tr><td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td></tr>
<tr><td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td></tr>
<tr><td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>The seeds used in the estimation in <code>fitSTVAR</code>, if applicable.</p>
</td></tr>
<tr><td><code>LS_estimates</code></td>
<td>
<p>The least squares estimates of the parameters in the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code> (intercepts replaced by unconditional means
if mean parametrization is used), if applicable.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Lütkepohl H., Netšunajev A. 2017. Structural vector autoregressions with smooth transition in variances.
<em>Journal of Economic Dynamics &amp; Control</em>, <strong>84</strong>, 43-57.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples that take approximately 1 minute to run.

## Estimate first a reduced form Gaussian STVAR p=3, M=2 model with the weighted relative
# stationary densities of the regimes as the transition weight function, and the means and
# AR matrices constrained to be identical across the regimes:
fit32cm &lt;- fitSTVAR(gdpdef, p=3, M=2, AR_constraints=rbind(diag(3*2^2), diag(3*2^2)),
  weight_function="relative_dens", mean_constraints=list(1:2), parametrization="mean",
  nrounds=1, seeds=1, ncores=1)

# Then, we estimate/create various structural models based on the reduced form model.
# Create a structural model with the shocks identified recursively:
fit32cms_rec &lt;- fitSSTVAR(fit32cm, identification="recursive")

# Create a structural model with the shocks identified by conditional heteroskedasticity:
fit32cms_hetsked &lt;- fitSSTVAR(fit32cm, identification="heteroskedasticity")
fit32cms_hetsked # Print the estimates

# Estimate a structural model with the shocks identified by conditional heteroskedasticity
# and overidentifying constraints imposed on the impact matrix: positive diagonal element
# and zero upper right element:
fit32cms_hs2 &lt;- fitSSTVAR(fit32cm, identification="heteroskedasticity",
 B_constraints=matrix(c(1, NA, 0, 1), nrow=2))

# Estimate a structural model with the shocks identified by conditional heteroskedasticity
# and overidentifying constraints imposed on the impact matrix: positive diagonal element
# and zero off-diagonal elements:
fit32cms_hs3 &lt;- fitSSTVAR(fit32cms_hs2, identification="heteroskedasticity",
 B_constraints=matrix(c(1, 0, 0, 1), nrow=2))

# Estimate first a reduced form two-regime Threshold VAR p=1 model with
# with independent skewed t shocks, and the first lag of the second variable
# as the switching variable, and AR matrices constrained to be identical
# across the regimes:
fit12c &lt;- fitSTVAR(gdpdef, p=1, M=2, cond_dist="ind_skewed_t",
 AR_constraints=rbind(diag(1*2^2), diag(1*2^2)), weight_function="threshold",
 weightfun_pars=c(2, 1), nrounds=1, seeds=1, ncores=1)

# Due to the independent non-Gaussian shocks, the structural shocks are readily
# identified. The following returns the same model but marked as structural
# with the shocks identified by non-Gaussianity:
fit12c &lt;- fitSSTVAR(fit12c)

# Estimate a model based on a reversed ordering of the columns of the impact matrix B_2:
fit12c2 &lt;- fitSSTVAR(fit12c, B_pm_reg=2, B_perm=c(2, 1))

# Estimate a model based on reversed signs of the second column of B_2 and reversed
# ordering of the columns of B_2:
fit12c3 &lt;- fitSSTVAR(fit12c, B_pm_reg=2, B_perm=c(2, 1), B_signs=2)

</code></pre>

<hr>
<h2 id='fitSTVAR'>Two-phase or three-phase (penalized) maximum likelihood estimation of a reduced form smooth transition VAR model</h2><span id='topic+fitSTVAR'></span>

<h3>Description</h3>

<p><code>fitSTVAR</code> estimates a reduced form smooth transition VAR model in two phases
or three phases. In additional ML estimation, also penalized ML estimation is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSTVAR(
  data,
  p,
  M,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  estim_method,
  penalized,
  penalty_params = c(0.05, 0.2),
  allow_unstab,
  min_obs_coef = 3,
  sparse_grid = FALSE,
  nrounds,
  ncores = 2,
  maxit = 2000,
  seeds = NULL,
  print_res = TRUE,
  use_parallel = TRUE,
  calc_std_errors = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitSTVAR_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_estim_method">estim_method</code></td>
<td>
<p>either <code>"two-phase"</code> or <code>"three-phase"</code> (the latter is the default
option for threshold models and the former is currently the only option for other models). See details.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_penalized">penalized</code></td>
<td>
<p>should penalized log-likelihood function be used that penalizes the log-likelihood function when
the parameter values are close the boundary of the stability region or outside it? If <code>TRUE</code>, estimates
that do not satisfy the stability condition are allowed (except when <code>weight_function="relative_dens"</code>).
The default is <code>TRUE</code> for three-phase estimation and <code>FALSE</code> for two-phase estimation.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_penalty_params">penalty_params</code></td>
<td>
<p>a numeric vector with two positive elements specifying the penalization parameters:
the first element determined how far from the boundary of the stability region the penalization starts
(a number between zero and one, smaller number starts penalization closer to the boundary) and the second element
is a tuning parameter for the penalization (a positive real number, a higher value penalizes non-stability more).</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_min_obs_coef">min_obs_coef</code></td>
<td>
<p>In the LS/NLS step of the three phase estimation, the smallest accepted number of observations
(times variables) from each regime relative to the number of parameters in the regime. For models with AR constraints,
the number of AR matrix parameters in each regimes is simplisticly assumed to be <code>ncol(AR_constraints)/M</code>.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_sparse_grid">sparse_grid</code></td>
<td>
<p>should the grid of weight function values in LS/NLS estimation be more sparse (speeding up the estimation)?</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_nrounds">nrounds</code></td>
<td>
<p>the number of estimation rounds that should be performed. The default is <code>(M*ncol(data))^3</code>
when <code>estim_method="two-phase"</code> and <code>(M*ncol(data))^2</code> when <code>estim_method="three-phase"</code>.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_ncores">ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations in the variable metric algorithm.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_seeds">seeds</code></td>
<td>
<p>a length <code>nrounds</code> vector containing the random number generator seed
for each call to the genetic algorithm, or <code>NULL</code> for not initializing the seed.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_print_res">print_res</code></td>
<td>
<p>should summaries of estimation results be printed?</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_use_parallel">use_parallel</code></td>
<td>
<p>employ parallel computing? If <code>use_parallel=FALSE &amp;&amp; print_res=FALSE</code>,
nothing is printed during the estimation process.</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>Calculate approximate standard errors (based on standard asymptotics)?</p>
</td></tr>
<tr><td><code id="fitSTVAR_+3A_...">...</code></td>
<td>
<p>additional settings passed to the function <code>GAfit</code> employing the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you wish to estimate a structural model, estimate first the reduced form model and then use the
use the function <code>fitSSTVAR</code> to create (and estimate if necessary) the structural model
based on the estimated reduced form model.
</p>
<p><strong>three-phase estimation.</strong> With <code>estim_method="three-phase"</code> (not available for models with <code>relative_dens</code>
weight function), an extra phase is added to the beginning of the two-phase estimation procedure:
the autoregressive and weight function parameters are first estimated by the method of (penalized) least squares. Then,
the rest of the parameters are estimated by (penalized) ML with the genetic algorithm conditionally on the LS estimates.
Finally, all the parameters are estimated by (penalized) ML by initializing a gradient based variable metric algorithm
from initial estimates obtained from the first two phases. This allows to use substantially decrease the required
number of estimation rounds, and thereby typically speeds up the estimation substantially. On the other hand, the three-phase
procedure tends to produce estimates close to the initial (penalized) LS estimates, while the two-phase procedure explores
the parameter space more thoroughly (when a large enough number of estimation rounds is ran).
</p>
<p><strong>Penalized estimation.</strong> The penalized estimation (<code>penalized=TRUE</code>) maximizes the penalized log-likelihood function
in which a penalty term is added. The penalty term becomes nonzero when the parameter values are close to the boundary of the
stability region or outside it, it increases in the modulus of the eigenvalues of the companion form AR matrices of the regimes.
With <code>allow_unstab=TRUE</code>, allowing for unstable estimates, it allows the estimation algorithms to explore the parameter space
outside the stability region, but with high enough penalization, the optimization algorithm eventually converges back to the
stability region. By default, penalized estimation (with unstable estimates allow) is used for <code>estim_method="three-phase"</code>
and not used for <code>estim_method="two-phase"</code>.
</p>
<p><strong>The rest concerns both two-phase and three-phase procedures.</strong>\
Because of complexity and high multimodality of the log-likelihood function, it is <strong>not certain</strong>
that the estimation algorithm will end up in the global maximum point. When <code>estim_method="two-phase"</code>,
it is expected that many of the estimation rounds will end up in some local maximum or a saddle point instead.
Therefore, a (sometimes very large) number of estimation rounds is required for reliable results
(when <code>estim_method="three-phase"</code> substantially smaller number should be sufficient). Due to
identification problems and high complexity of the surface of the log-likelihood function, the estimation may
fail especially in the cases where the number of regimes is chosen too large.
</p>
<p>The estimation process is computationally heavy and it might take considerably long time for large models to
estimate, particularly if <code>estim_method="two-phase"</code>. Note that reliable estimation of model with
<code>cond_dist == "ind_Student"</code> or <code>"ind_skewed_t"</code> is more difficult than with Gaussian or Student's t
models due to the increased complexity.
</p>
<p>If the iteration limit <code>maxit</code> in the variable metric algorithm is reached, one can continue the estimation by
iterating more with the function <code>iterate_more</code>. Alternatively, one may use the found estimates as starting values
for the genetic algorithm and employ another round of estimation (see <code>??GAfit</code> how to set up an initial population
with the dot parameters).
</p>
<p><strong>If the estimation algorithm performs poorly</strong>, it usually helps to scale the individual series so that they
vary roughly in the same scale. This makes it is easier to draw reasonable AR coefficients and (with some weight functions)
weight parameter values in the genetic algorithm. Even if the estimation algorithm somewhat works, it should be preferred
to scale the data so that most of the AR coefficients will not be very large, as the genetic algorithm works better with
relatively small AR coefficients. If needed, another package can be used to fit linear VARs to the series to see which scaling
of the series results in relatively small AR coefficients. You should avoid very small (or very high) variance in the data as
well, so that the eigenvalues of the covariance matrices are in a reasonable range.
</p>
<p><strong>weight_constraints:</strong> If you are using weight constraints other than restricting some of the weight parameters to known
constants, make sure the constraints are sensible. Otherwise, the estimation may fail due to the estimation algorithm not being
able to generate reasonable random guesses for the values of the constrained weight parameters.
</p>
<p><strong>Filtering inappropriate estimates:</strong> <code>fitSTVAR</code> automatically filters through estimates
that it deems &quot;inappropriate&quot;. That is, estimates that are not likely solutions of interest.
Specifically, solutions that incorporate a near-singular error term covariance matrix (any eigenvalue less than <code class="reqn">0.002</code>),
any modulus of the eigenvalues of the companion form AR matrices larger than $0.9985$ (indicating the necessary condition for
stationarity is close to break), or transition weights such that they are close to zero for almost all <code class="reqn">t</code> for at least
one regime. You can also always find the solutions of interest yourself by using the function <code>alt_stvar</code> as well since
results from all estimation rounds are saved).
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td></tr>
<tr><td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td></tr>
<tr><td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td></tr>
<tr><td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td></tr>
<tr><td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td></tr>
<tr><td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td></tr>
<tr><td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td></tr>
<tr><td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td></tr>
<tr><td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td></tr>
<tr><td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td></tr>
<tr><td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td></tr>
<tr><td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>The seeds used in the estimation in <code>fitSTVAR</code>, if applicable.</p>
</td></tr>
<tr><td><code>LS_estimates</code></td>
<td>
<p>The least squares estimates of the parameters in the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code> (intercepts replaced by unconditional means
if mean parametrization is used), if applicable.</p>
</td></tr>
</table>


<h3>S3 methods</h3>

<p>The following S3 methods are supported for class <code>'stvar'</code>: <code>logLik</code>, <code>residuals</code>, <code>print</code>, <code>summary</code>,
<code>predict</code>, <code>simulate</code>, and <code>plot</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hubrich K., Teräsvirta. T. 2013. Thresholds and Smooth Transitions in Vector Autoregressive Models.
<em>CREATES Research Paper 2013-18, Aarhus University.</em>
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitSSTVAR">fitSSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>, <code><a href="#topic+GAfit">GAfit</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, <code><a href="#topic+filter_estimates">filter_estimates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples. Running all the below examples will take
## approximately three minutes.
# When estimating the models in empirical applications, typically a large number
# of estimation rounds (set by the argument 'nrounds') should be used. These examples
# use only a small number of rounds to make the running time of the examples reasonable.

# The below examples make use of the two-variate dataset 'gdpdef' containing
# the the quarterly U.S. GDP and GDP deflator from 1947Q1 to 2019Q4.

# Estimate Gaussian STVAR model of autoregressive order p=3 and two regimes (M=2),
# with the weighted relative stationary densities of the regimes as the transition
# weight function. The estimation is performed with 2 rounds and 2 CPU cores, with
# the random number generator seeds set for reproducibility (two-phase estimation):
fit32 &lt;- fitSTVAR(gdpdef, p=3, M=2, weight_function="relative_dens", cond_dist="Gaussian",
 nrounds=2, ncores=2, seeds=1:2)

# Examine the results:
fit32 # Printout of the estimates
summary(fit32) # A more detailed summary printout
plot(fit32) # Plot the fitted transition weights
get_foc(fit32) # Gradient of the log-likelihood function about the estimate
get_soc(fit32) # Eigenvalues of the Hessian of the log-lik. fn. about the estimate
profile_logliks(fit32) # Profile log-likelihood functions about the estimate

# Estimate a two-regime Student's t STVAR p=5 model with logistic transition weights
# and the first lag of the second variable as the switching variable, only two
# estimation rounds using two CPU cores (three-phase estimation):
fitlogistict32 &lt;- fitSTVAR(gdpdef, p=3, M=2, weight_function="logistic", weightfun_pars=c(2, 1),
 cond_dist="Student", nrounds=2, ncores=2, seeds=1:2)
summary(fitlogistict32) # Summary printout of the estimates

# Estimate a two-regime threshold VAR p=3 model with independent skewed t shocks
# using the three-phase estimation procedure.
# The first lag of the the second variable is specified as the switching variable,
# and the threshold parameter constrained to the fixed value 1 (three-phase estimation):
fitthres32wit &lt;- fitSTVAR(gdpdef, p=3, M=2, weight_function="threshold", weightfun_pars=c(2, 1),
  cond_dist="ind_skewed_t", weight_constraints=list(R=0, r=1), nrounds=2, ncores=2, seeds=1:2)
plot(fitthres32wit) # Plot the fitted transition weights

# Estimate a two-regime STVAR p=1 model with exogenous transition weights defined as the indicator
# of NBER based U.S. recessions (source: St. Louis Fed database). Moreover, restrict the AR matrices
# to be identical across the regimes (i.e., allowing for time-variation in the intercepts and the
# covariance matrix only), (three-phase estimation):

# Step 1: Define transition weights of Regime 1 as the indicator of NBER based U.S. recessions
# (the start date of weights is start of data + p, since the first p values are used as the initial
# values):
tw1 &lt;- c(0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

# Step 2: Define the transition weights of Regime 2 as one minus the weights of Regime 1, and
# combine the weights to matrix of transition weights:
twmat &lt;- cbind(tw1, 1 - tw1)

# Step 3: Create the appropriate constraint matrix:
C_122 &lt;- rbind(diag(1*2^2), diag(1*2^2))

# Step 4: Estimate the model by specifying the weights in the argument 'weightfun_pars'
# and the constraint matrix in the argument 'AR_constraints':
fitexo12cit &lt;- fitSTVAR(gdpdef, p=1, M=2, weight_function="exogenous", weightfun_pars=twmat,
 cond_dist="ind_Student", AR_constraints=C_122, nrounds=2, ncores=2, seeds=1:2)
plot(fitexo12cit) # Plot the transition weights
summary(fitexo12cit) # Summary printout of the estimates

# Estimate a two-regime Gaussian STVAR p=1 model with the weighted relative stationary densities
# of the regimes as the transition weight function; constrain AR matrices to be identical
# across the regimes and also constrain the off-diagonal elements of the AR matrices to be zero.
# Moreover, constrain the unconditional means of both regimes to be equal (two-phase estimation):
mat0 &lt;- matrix(c(1, rep(0, 10), 1, rep(0, 8), 1, rep(0, 10), 1), nrow=2*2^2, byrow=FALSE)
C_222 &lt;- rbind(mat0, mat0) # The constraint matrix
fit22cm &lt;- fitSTVAR(gdpdef, p=2, M=2, weight_function="relative_dens", cond_dist="Gaussian",
 parametrization="mean", AR_constraints=C_222, mean_constraints=list(1:2), nrounds=2, seeds=1:2)
fit22cm # Print the estimates

# Estimate a two-regime Student's t STVAR p=3 model with logistic transition weights and the
# first lag of the second variable as the switching variable. Constraint the location parameter
# to the fixed value 1 and leave the scale parameter unconstrained (three-phase estimation):
fitlogistic32w &lt;- fitSTVAR(gdpdef, p=3, M=2, weight_function="logistic", weightfun_pars=c(2, 1),
 cond_dist="Student", weight_constraints=list(R=matrix(c(0, 1), nrow=2), r=c(1, 0)), nrounds=2,
 seeds=1:2)
plot(fitlogistic32w) # Plot the fitted transition weights

</code></pre>

<hr>
<h2 id='form_boldA'>Form the <code class="reqn">(dp\times dp)</code> &quot;bold A&quot; matrices related to the VAR processes</h2><span id='topic+form_boldA'></span>

<h3>Description</h3>

<p><code>form_boldA</code> creates the &quot;bold A&quot; (companien form) coefficient matrices related to
VAR processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>form_boldA(p, M, d, all_A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="form_boldA_+3A_p">p</code></td>
<td>
<p>the autoregressive order of the model</p>
</td></tr>
<tr><td><code id="form_boldA_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="form_boldA_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="form_boldA_+3A_all_a">all_A</code></td>
<td>
<p>4D array containing all coefficient matrices <code class="reqn">A_{m,i}</code>, obtained from <code>pick_allA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;bold A&quot; (companion form) matrix is given, for instance, in Lütkepohl (2005, p. 15).
</p>


<h3>Value</h3>

<p>Returns 3D array containing the <code class="reqn">(dp \times dp)</code> &quot;bold A&quot; matrices related to each component VAR-process.
The matrix <strong><code class="reqn">A_{m}</code></strong> can be obtained by choosing <code>[, , m]</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li></ul>


<hr>
<h2 id='format_valuef'>Function factory for value formatting</h2><span id='topic+format_valuef'></span>

<h3>Description</h3>

<p><code>format_valuef</code> is a function factory for
formatting values with certain number of digits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_valuef(digits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_valuef_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function that takes an atomic vector as argument
and returns it formatted to character with <code>digits</code> decimals.
</p>

<hr>
<h2 id='GAfit'>Genetic algorithm for preliminary estimation of reduced form STVAR models</h2><span id='topic+GAfit'></span>

<h3>Description</h3>

<p><code>GAfit</code> estimates the specified reduced form STVAR model using a genetic algorithm.
It is designed to find starting values for gradient based methods and NOT to obtain final estimates
constituting a local maximum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAfit(
  data,
  p,
  M,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  ngen = 200,
  popsize,
  smart_mu = min(100, ceiling(0.5 * ngen)),
  initpop = NULL,
  mu_scale,
  mu_scale2,
  omega_scale,
  B_scale,
  weight_scale,
  ar_scale = 0.2,
  upper_ar_scale = 1,
  ar_scale2 = 1,
  regime_force_scale = 1,
  penalized,
  penalty_params = c(0.05, 0.5),
  allow_unstab,
  red_criteria = c(0.05, 0.01),
  bound_by_weights,
  pre_smart_mu_prob = 0,
  to_return = c("alt_ind", "best_ind"),
  minval,
  fixed_params = NULL,
  fixed_params_in_smart_mu = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GAfit_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="GAfit_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="GAfit_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GAfit_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="GAfit_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="GAfit_+3A_ngen">ngen</code></td>
<td>
<p>a positive integer specifying the number of generations to be ran through in
the genetic algorithm.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_popsize">popsize</code></td>
<td>
<p>a positive even integer specifying the population size in the genetic algorithm.
Default is <code>10*n_params</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_smart_mu">smart_mu</code></td>
<td>
<p>a positive integer specifying the generation after which the random mutations
in the genetic algorithm are &quot;smart&quot;. This means that mutating individuals will mostly mutate fairly
close (or partially close) to the best fitting individual (which has the least regimes with time varying
mixing weights practically at zero) so far.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_initpop">initpop</code></td>
<td>
<p>a list of parameter vectors from which the initial population of the genetic algorithm
will be generated from. The parameter vectors hould have the form
<code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>, where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> vector defining <strong>means</strong> of the normal distributions from which each
mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations. Default is <code>colMeans(data)</code>. Note that
mean-parametrization is always used for optimization in <code>GAfit</code> - even when <code>parametrization=="intercept"</code>.
However, input (in <code>initpop</code>) and output (return value) parameter vectors can be intercept-parametrized.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_mu_scale2">mu_scale2</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector defining <strong>standard deviations</strong> of the normal
distributions from which each mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations.
Default is <code>vapply(1:d, function(i1) sd(data[,i1]), numeric(1))</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_omega_scale">omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
<code>cond_dist == "ind_Student"</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_b_scale">B_scale</code></td>
<td>
<p>a size <code class="reqn">(d \times 1)</code> strictly positive vector specifying the mean and variability of the
random impact matrices in random mutations. In Regime 1, the mean of the error term covariance matrix
implied by the random impact matrix will be <code>0.95*diag(B_scale)</code> and in the rest of the regimes <code>diag(B_scale)</code>,
whereas the variability increases with <code>B_scale</code>.
Default in <code>GAfit</code> is <code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>.
This argument is ignored if <code>cond_dist != "ind_Student"</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_weight_scale">weight_scale</code></td>
<td>
<p>For...
</p>

<dl>
<dt><code>weight_function %in% c("relative_dens", "exogenous")</code>:</dt><dd><p>not used.</p>
</dd>
<dt><code>weight_function %in% c("logistic", "exponential")</code>:</dt><dd><p>length three vector with the mean (in the first element)
and standard deviation (in the second element) of the normal distribution the location parameter is drawn from
in random mutations. The third element is the standard deviation of the normal distribution from whose absolute value
the location parameter is drawn from.</p>
</dd>
<dt><code>weight_function == "mlogit"</code>:</dt><dd><p>length two vector with the mean (in the first element)
and standard deviation (in the second element) of the normal distribution the coefficients of the logit sub model's
constant terms are drawn from in random mutations. The third element is the standard deviation of the normal distribution
from which the non-constant regressors' coefficients are drawn from.</p>
</dd>
<dt><code>weight_function == "threshold"</code>:</dt><dd><p>a lenght two vector with the lower bound, in the first element
and the upper bound, in the second element, of the uniform distribution threshold parameters are drawn from
in random mutations.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GAfit_+3A_ar_scale">ar_scale</code></td>
<td>
<p>a positive real number between zero and one adjusting how large AR parameter values are typically
proposed in construction of the initial population: larger value implies larger coefficients (in absolute value).
After construction of the initial population, a new scale is drawn from <code>(0, upper_ar_scale)</code> uniform
distribution in each iteration.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_upper_ar_scale">upper_ar_scale</code></td>
<td>
<p>the upper bound for <code>ar_scale</code> parameter (see above) in the random mutations. Setting
this too high might lead to failure in proposing new parameters that are well enough inside the parameter space,
and especially with large <code>p</code> one might want to try smaller upper bound (e.g., 0.5). With large <code>p</code> or
<code>d</code>, <code>upper_ar_scale</code> is restricted from above, see the details section.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_ar_scale2">ar_scale2</code></td>
<td>
<p>a positive real number adjusting how large AR parameter values are typically proposed in some
random mutations (if AR constraints are employed, in all random mutations): larger value implies <strong>smaller</strong>
coefficients (in absolute value). <strong>Values larger than 1 can be used if the AR coefficients are expected to
be very small. If set smaller than 1, be careful as it might lead to failure in the creation of parameter candidates
that satisfy the stability condition.</strong></p>
</td></tr>
<tr><td><code id="GAfit_+3A_regime_force_scale">regime_force_scale</code></td>
<td>
<p>a non-negative real number specifying how much should natural selection favor individuals
with less regimes that have almost all mixing weights (practically) at zero. Set to zero for no favoring or large
number for heavy favoring. Without any favoring the genetic algorithm gets more often stuck in an area of the
parameter space where some regimes are wasted, but with too much favouring the best genes might never mix into
the population and the algorithm might converge poorly. Default is <code>1</code> and it gives <code class="reqn">2x</code> larger surviving
probability weights for individuals with no wasted regimes compared to individuals with one wasted regime.
Number <code>2</code> would give <code class="reqn">3x</code> larger probability weights etc.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_penalized">penalized</code></td>
<td>
<p>Perform penalized LS estimation that minimizes penalized RSS in which estimates close to breaking or not satisfying the
usual stability condition are penalized? If <code>TRUE</code>, the tuning parameter is set by the argument <code>penalty_params[2]</code>,
and the penalization starts when the eigenvalues of the companion form AR matrix are larger than <code>1 - penalty_params[1]</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_penalty_params">penalty_params</code></td>
<td>
<p>a numeric vector with two positive elements specifying the penalization parameters:
the first element determined how far from the boundary of the stability region the penalization starts
(a number between zero and one, smaller number starts penalization closer to the boundary) and the second element
is a tuning parameter for the penalization (a positive real number, a higher value penalizes non-stability more).</p>
</td></tr>
<tr><td><code id="GAfit_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_red_criteria">red_criteria</code></td>
<td>
<p>a length 2 numeric vector specifying the criteria that is used to determine whether a regime is
redundant (or &quot;wasted&quot;) or not.
Any regime <code>m</code> which satisfies <code>sum(transitionWeights[,m] &gt; red_criteria[1]) &lt; red_criteria[2]*n_obs</code> will
be considered &quot;redundant&quot;. One should be careful when adjusting this argument (set <code>c(0, 0)</code> to fully disable
the 'redundant regime' features from the algorithm).</p>
</td></tr>
<tr><td><code id="GAfit_+3A_bound_by_weights">bound_by_weights</code></td>
<td>
<p>should the parameter space be constrained to areas where the transition weights do allocate
enough weights to each regime compared to the number of observations in the regime? See the source code of
the function <code>loglikelihood</code> for details.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_pre_smart_mu_prob">pre_smart_mu_prob</code></td>
<td>
<p>A number in <code class="reqn">[0,1]</code> giving a probability of a &quot;smart mutation&quot; occuring randomly in each
iteration before the iteration given by the argument <code>smart_mu</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_to_return">to_return</code></td>
<td>
<p>should the genetic algorithm return the best fitting individual which has &quot;positive enough&quot; mixing
weights for as many regimes as possible (<code>"alt_ind"</code>) or the individual which has the highest log-likelihood
in general (<code>"best_ind"</code>) but might have more wasted regimes?</p>
</td></tr>
<tr><td><code id="GAfit_+3A_minval">minval</code></td>
<td>
<p>a real number defining the minimum value of the log-likelihood function that will be considered.
Values smaller than this will be treated as they were <code>minval</code> and the corresponding individuals will
never survive. The default is <code>-(10^(ceiling(log10(n_obs)) + d) - 1)</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_fixed_params">fixed_params</code></td>
<td>
<p>a vector containing fixed parameter values for intercept, autoregressive, and weight parameters
that should be fixed in the <strong>initial population</strong>. Should have the form:
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code>, where
</p>

<ul>
<li><p><code class="reqn">(\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li><p><code class="reqn">\alpha</code> vector of the weight parameters.
</p>
</li></ul>

<p>For models with...
</p>

<dl>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
</dl>

<p>Note that <code>fixed_params</code> should always be in the intercept parametrization (and <code>parametrization="intercept"</code> should always be used).
<strong>Passing this argument from fitSTVAR in does not do anything, as it is designed to be used with the three-phase estimation
procedure only. Also, this argument does not do anything if the initial population is specified in the argument initpop.</strong></p>
</td></tr>
<tr><td><code id="GAfit_+3A_fixed_params_in_smart_mu">fixed_params_in_smart_mu</code></td>
<td>
<p>should the fixed parameters be fixed in the smart mutation phase as well? If <code>TRUE</code>, the fixed
parameters stay fixed throughout the whole GA estimation.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_seed">seed</code></td>
<td>
<p>a single value, interpreted as an integer, or NULL, that sets seed for the random number generator in
the beginning of the function call. If calling <code>GAfit</code> from <code>fitSTVAR</code>, use the argument <code>seeds</code>
instead of passing the argument <code>seed</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only reduced form models are supported!
</p>
<p>The core of the genetic algorithm is mostly based on the description by <em>Dorsey and Mayer (1995)</em>.
It utilizes a slightly modified version of the individually adaptive crossover and mutation rates described
by <em>Patnaik and Srinivas (1994)</em> and employs (50%) fitness inheritance discussed by
<em>Smith, Dike and Stegmann (1995)</em>.
</p>
<p>By &quot;redundant&quot; or &quot;wasted&quot; regimes we mean regimes that have the time varying mixing weights practically at
zero for almost all t. A model including redundant regimes would have about the same log-likelihood value without
the redundant regimes and there is no purpose to have redundant regimes in a model.
</p>
<p>Some of the AR coefficients are drawn with the algorithm by Ansley and Kohn (1986). However,
when using large <code>ar_scale</code> with large <code>p</code> or <code>d</code>, numerical inaccuracies caused
by the imprecision of the float-point presentation may result in errors or nonstationary AR-matrices.
Using smaller <code>ar_scale</code> facilitates the usage of larger <code>p</code> or <code>d</code>. Therefore, we bound
<code>upper_ar_scale</code> from above by <code class="reqn">1-pd/150</code> when <code>p*d&gt;40</code> and by <code class="reqn">1</code> otherwise.
</p>
<p>Structural models are not supported here, as they are best estimated based on reduced form parameter estimates
using the function <code>fitSSTVAR</code>.
</p>


<h3>Value</h3>

<p>Returns the estimated parameter vector which has the form described in <code>initpop</code>,
<strong>with the exception</strong> that for models with <code>cond_dist == "ind_Student"</code> or
<code>"ind_skewed_t"</code>, the parameter vector is parametrized with <code class="reqn">B_1,B_2^*,...,B_M^*</code>
instead of  <code class="reqn">B_1,B_2,...,B_M</code>, where <code class="reqn">B_m^* = B_m - B_1</code>. Use the function <code>change_parametrization</code>
to change back to the original parametrization if desired.
</p>


<h3>References</h3>


<ul>
<li><p> Ansley C.F., Kohn R. 1986. A note on reparameterizing a vector autoregressive
moving average model to enforce stationarity. <em>Journal of statistical computation
and simulation</em>, <strong>24</strong>:2,  99-106.
</p>
</li>
<li><p> Dorsey R. E. and Mayer W. J. 1995. Genetic algorithms for estimation problems with multiple optima,
nondifferentiability, and other irregular features. <em>Journal of Business &amp; Economic Statistics</em>,
<strong>13</strong>, 53-66.
</p>
</li>
<li><p> Patnaik L.M. and Srinivas M. 1994. Adaptive Probabilities of Crossover and Mutation in Genetic Algorithms.
<em>Transactions on Systems, Man and Cybernetics</em> <strong>24</strong>, 656-667.
</p>
</li>
<li><p> Smith R.E., Dike B.A., Stegmann S.A. 1995. Fitness inheritance in genetic algorithms.
<em>Proceedings of the 1995 ACM Symposium on Applied Computing</em>, 345-350.
</p>
</li></ul>


<hr>
<h2 id='Gaussian_densities_const_Cpp'>Calculate log multivariate Gaussian densities</h2><span id='topic+Gaussian_densities_const_Cpp'></span>

<h3>Description</h3>

<p>Calculates logs of multivariate Gaussian densities with constant mean
and constant covariance matrix AND EXCLUDING the constant term of the density
(the constant is calculated and added in R code).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian_densities_const_Cpp(obs, mean, cholcovmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gaussian_densities_const_Cpp_+3A_obs">obs</code></td>
<td>
<p>a <code class="reqn">(T \times dp)</code> matrix such that the i:th row contains the vector
<code class="reqn">(y_{i-1}',...,y_{i-p}')</code> <code class="reqn">((dp)x1)</code>, where <code class="reqn">y_{i}=(y_{1i},...,y_{di})</code>
<code class="reqn">(dx1)</code>. That is, the initial values are included but the last observations not.</p>
</td></tr>
<tr><td><code id="Gaussian_densities_const_Cpp_+3A_mean">mean</code></td>
<td>
<p>the <code class="reqn">((dp)x1)</code> mean vector, <code>rep(all_mu[,m], times=p)</code>, that is the same for
all observations.</p>
</td></tr>
<tr><td><code id="Gaussian_densities_const_Cpp_+3A_cholcovmat">cholcovmat</code></td>
<td>
<p>the <code class="reqn">(dp \times dp)</code> covariance matrix that is the same for all observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in the relative density transition weights with Gaussian regimes.
</p>


<h3>Value</h3>

<p>a numeric vector containing the multivariate Gaussian densities, excluding the constant term.
</p>

<hr>
<h2 id='Gaussian_densities_Cpp'>Calculate log multivariate Gaussian densities</h2><span id='topic+Gaussian_densities_Cpp'></span>

<h3>Description</h3>

<p>Calculates logs of multivariate Gaussian densities with varying mean
and varying covariance matrix AND EXCLUDING the constant term of the density
(the constant is calculated and added in R code). The varying conditional covariance
matrix is calculated within the function from the regime covariance matrices and
transition weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian_densities_Cpp(obs, means, covmats, alpha_mt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gaussian_densities_Cpp_+3A_obs">obs</code></td>
<td>
<p>a <code class="reqn">(T \times d)</code> matrix such that the <code class="reqn">i</code>th row contains the vector
<code class="reqn">y_{i}=(y_{1i},...,y_{di})</code> <code class="reqn">(dx1)</code>. That is, the initial values are
excluded but the last observations is included.</p>
</td></tr>
<tr><td><code id="Gaussian_densities_Cpp_+3A_means">means</code></td>
<td>
<p>a <code class="reqn">(T \times d)</code> matrix such that the <code class="reqn">i</code>th row contains the
conditional mean of the process <code class="reqn">\mu_{y,i}</code>.</p>
</td></tr>
<tr><td><code id="Gaussian_densities_Cpp_+3A_covmats">covmats</code></td>
<td>
<p>a <code class="reqn">(d \times d \times M)</code> array such that the slice <code>[, , m]</code>
contains the conditional covariance matrix of regime m.</p>
</td></tr>
<tr><td><code id="Gaussian_densities_Cpp_+3A_alpha_mt">alpha_mt</code></td>
<td>
<p>a <code class="reqn">(T \times M)</code> matrix such that <code>[t, m]</code> contains the time t
transition weights of the <code class="reqn">m</code>th regime.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector containing the multivariate Gaussian densities, excluding the constant term.
</p>

<hr>
<h2 id='gdpdef'>U.S. real GDP percent change and GDP implicit price deflator percent change.</h2><span id='topic+gdpdef'></span>

<h3>Description</h3>

<p>A dataset containing a quarterly U.S. time series with two components:
the percentage change of real GDP and the percentage change of GDP implicit price deflator,
covering the period from 1959Q1 - 2019Q4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdpdef
</code></pre>


<h3>Format</h3>

<p>A numeric matrix of class <code>'ts'</code> with 244 rows and 2 columns with one time series in each column:
</p>

<dl>
<dt>First column (GDP):</dt><dd><p>The quarterly percent change of real U.S. GDP, from 1959Q1 to 2019Q4, <a href="https://fred.stlouisfed.org/series/GDPC1">https://fred.stlouisfed.org/series/GDPC1</a>.</p>
</dd>
<dt>Second column (GDPDEF):</dt><dd><p>The quarterly percent change of U.S. GDP implicit price deflator, from 1959Q1 to 2019Q4, <a href="https://fred.stlouisfed.org/series/GDPDEF">https://fred.stlouisfed.org/series/GDPDEF</a>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Federal Reserve Bank of St. Louis database
</p>

<hr>
<h2 id='generate_skewed_t'>Generate random samples from the skewed t-distribution</h2><span id='topic+generate_skewed_t'></span>

<h3>Description</h3>

<p><code>generate_skewed_t</code> generates <code>n</code> random observations from the univariate skewed <em>t</em>-distribution
described in Hansen (1994) using the acceptance-rejection sampling method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_skewed_t(n, nu, lambda, bc_M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_skewed_t_+3A_n">n</code></td>
<td>
<p>An integer specifying the number of random observations to generate. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="generate_skewed_t_+3A_nu">nu</code></td>
<td>
<p>A numeric scalar specifying the degrees of freedom parameter for the skewed <em>t</em>-distribution. Must be greater than 2.</p>
</td></tr>
<tr><td><code id="generate_skewed_t_+3A_lambda">lambda</code></td>
<td>
<p>A numeric scalar specifying the skewness parameter for the skewed <em>t</em>-distribution. Must be between <code class="reqn">-1</code> and <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="generate_skewed_t_+3A_bc_m">bc_M</code></td>
<td>
<p>An optional numeric scalar specifying the bounding constant <code class="reqn">M</code> used in the acceptance-rejection algorithm.
If not provided, it is computed using <code><a href="#topic+bounding_const_M">bounding_const_M</a></code> with the given <code>nu</code> and <code>lambda</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the acceptance-rejection algorithm to generate random samples from the skewed <em>t</em>-distribution.
The proposal distribution used is a standard <em>t</em>-distribution with degrees of freedom <code>proposal_nu</code>, which is set to <code class="reqn">3</code>
when <code>nu &gt; 3</code> to ensure heavier tails and accommodate the skewness of the target distribution.
</p>
<p>If <code>bounding_const_M</code> is not provided, it is calculated using the <code><a href="#topic+bounding_const_M">bounding_const_M</a></code> function. It is important that
the same proposal distribution is used in both the computation of <code>bounding_const_M</code> and the acceptance-rejection sampling
algorithm to ensure correctness.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code> containing random observations from the skewed <em>t</em>-distribution with
parameters <code>nu</code> and <code>lambda</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation. <em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li></ul>


<hr>
<h2 id='get_alpha_mt'>Get the transition weights alpha_mt</h2><span id='topic+get_alpha_mt'></span>

<h3>Description</h3>

<p><code>get_alpha_mt</code> computes the transition weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_alpha_mt(
  data,
  Y2,
  p,
  M,
  d,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  all_A,
  all_boldA,
  all_Omegas,
  weightpars,
  all_mu,
  epsilon,
  log_mvdvalues = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_alpha_mt_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_y2">Y2</code></td>
<td>
<p>the data arranged as obtained from <code>reform_data(data, p)</code> but excluding the last row</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_all_a">all_A</code></td>
<td>
<p>4D array containing all coefficient matrices <code class="reqn">A_{m,i}</code>, obtained from <code>pick_allA</code>.</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_all_bolda">all_boldA</code></td>
<td>
<p>3D array containing the <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; (companion form) matrices of each regime,
obtained from <code>form_boldA</code>. Will be computed if not given.</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_all_omegas">all_Omegas</code></td>
<td>
<p>A 3D array containing the covariance matrix parameters obtain from <code>pick_Omegas</code>...
</p>

<dl>
<dt>If <code>cond_dist %in% c("Gaussian", "Student")</code>:</dt><dd><p>all covariance matrices <code class="reqn">\Omega_{m}</code> in <code>[, , m]</code>.</p>
</dd>
<dt>If <code>cond_dist=="ind_Student"</code>:</dt><dd><p>all impact matrices <code class="reqn">B_m</code> of the regimes in <code>[, , m]</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_weightpars">weightpars</code></td>
<td>
<p>numerical vector containing the transition weight parameters, obtained from <code>pick_weightpars</code>.</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_all_mu">all_mu</code></td>
<td>
<p>an <code class="reqn">(d \times M)</code> matrix containing the unconditional regime-specific means</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_epsilon">epsilon</code></td>
<td>
<p>the smallest number such that its exponent is wont classified as numerically zero
(around <code>-698</code> is used).</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_log_mvdvalues">log_mvdvalues</code></td>
<td>
<p>a <code class="reqn">T x M</code> matrix containing log multivariate normal densities (can be used with
relative dens weight function only)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that we index the time series as <code class="reqn">-p+1,...,0,1,...,T</code>.
</p>


<h3>Value</h3>

<p>Returns the mixing weights a <code class="reqn">(T x M)</code> matrix, so that the <code class="reqn">t</code>th row is for the time period <code class="reqn">t</code>
and <code class="reqn">m</code>:th column is for the regime <code class="reqn">m</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='get_boldA_eigens'>Calculate absolute values of the eigenvalues of the &quot;bold A&quot; matrices containing the AR coefficients</h2><span id='topic+get_boldA_eigens'></span>

<h3>Description</h3>

<p><code>get_boldA_eigens</code> calculates absolute values of the eigenvalues of
the &quot;bold A&quot; matrices containing the AR coefficients for each regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_boldA_eigens(stvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_boldA_eigens_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with <code class="reqn">d*p</code> rows and <code class="reqn">M</code> columns - one column for each regime.
The <code class="reqn">m</code>th column contains the absolute values (or modulus) of the eigenvalues of the &quot;bold A&quot; matrix containing
the AR coefficients correspinding to regime <code class="reqn">m</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li></ul>


<hr>
<h2 id='get_boldA_eigens_par'>Calculate absolute values of the eigenvalues of the &quot;bold A&quot; matrices containing the AR coefficients</h2><span id='topic+get_boldA_eigens_par'></span>

<h3>Description</h3>

<p><code>get_boldA_eigens_par</code> calculates absolute values of the eigenvalues of
the &quot;bold A&quot; matrices containing the AR coefficients for each regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_boldA_eigens_par(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_boldA_eigens_par_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="get_boldA_eigens_par_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with <code class="reqn">d*p</code> rows and <code class="reqn">M</code> columns - one column for each regime.
The <code class="reqn">m</code>th column contains the absolute values (or modulus) of the eigenvalues of the &quot;bold A&quot; matrix containing
the AR coefficients corresponding to regime <code class="reqn">m</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li></ul>


<hr>
<h2 id='get_Bt_Cpp'>Calculate the impact matrix <code class="reqn">B_t</code> for all <code class="reqn">t</code> for models with a non-Gaussian
conditional distribution with mutually independent shocks.</h2><span id='topic+get_Bt_Cpp'></span>

<h3>Description</h3>

<p>This internal function takes a cube of matrices (<code>all_Omegas</code>) and a matrix of weights (<code>alpha_mt</code>),
and calculates the weighted sums of the matrices in the cube. For each row in <code>alpha_mt</code>, it computes
a weighted sum of matrices, and returns the
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Bt_Cpp(all_Omegas, alpha_mt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Bt_Cpp_+3A_all_omegas">all_Omegas</code></td>
<td>
<p>A cube (3D array) of impact matrices, with each slice being an inveritble square matrix.</p>
</td></tr>
<tr><td><code id="get_Bt_Cpp_+3A_alpha_mt">alpha_mt</code></td>
<td>
<p>A matrix of weights, with as many columns as there are slices in <code>all_Omegas</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An arma::cube value (3D array in R) such that each slice contains the weighted sum of the matrices,
i.e, the impact matrix <code class="reqn">B_t</code> for all <code class="reqn">t</code>.
</p>

<hr>
<h2 id='get_hetsked_sstvar'>Switch from two-regime reduced form STVAR model to a structural model identified by heteroskedasticity</h2><span id='topic+get_hetsked_sstvar'></span>

<h3>Description</h3>

<p><code>get_hetsked_sstvar</code> constructs structural STVAR model identified by heteroskedasticity
based on a reduced form STVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hetsked_sstvar(stvar, calc_std_errors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hetsked_sstvar_+3A_stvar">stvar</code></td>
<td>
<p>a an object of class <code>'stvar'</code>, created by, e.g., <code>fitSTVAR</code>,
specifying a reduced form or a structural model</p>
</td></tr>
<tr><td><code id="get_hetsked_sstvar_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>Calculate approximate standard errors (based on standard asymptotics)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The switch is made by simultaneously diagonalizing the two error term covariance matrices
with a well known matrix decomposition (Muirhead, 1982, Theorem A9.9) and then normalizing the
diagonal of the matrix W positive (which implies positive diagonal of the impact matrix). Models with
more that two regimes are not supported because the matrix decomposition does not generally
exists for more than two covariance matrices.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'stvar'</code> defining a structural STVAR model identified by heteroskedasticity,
with the main diagonal of the impact matrix normalized to be positive.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitSSTVAR">fitSSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>, <code><a href="#topic+fitSTVAR">fitSTVAR</a></code>
</p>

<ul>
<li><p> Muirhead R.J. 1982. Aspects of Multivariate Statistical Theory, <em>Wiley</em>.
</p>
</li></ul>


<hr>
<h2 id='get_IC'>Calculate AIC, HQIC, and BIC</h2><span id='topic+get_IC'></span>

<h3>Description</h3>

<p><code>get_IC</code> calculates the information criteria values
AIC, HQIC, and BIC divided by the number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_IC(loglik, npars, T_obs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_IC_+3A_loglik">loglik</code></td>
<td>
<p>log-likelihood value</p>
</td></tr>
<tr><td><code id="get_IC_+3A_npars">npars</code></td>
<td>
<p>number of (freely estimated) parameters in the model</p>
</td></tr>
<tr><td><code id="get_IC_+3A_t_obs">T_obs</code></td>
<td>
<p>numbers of observations with the <code class="reqn">p</code> starting values excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame containing the information criteria values
divided by the number of observations.
</p>

<hr>
<h2 id='get_minval'>Returns the default smallest allowed log-likelihood for given data.</h2><span id='topic+get_minval'></span>

<h3>Description</h3>

<p><code>get_minval</code> returns the default smallest allowed log-likelihood for given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_minval(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_minval_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>-(10^(ceiling(log10(nrow(data)) + ncol(data))) - 1)</code>
</p>

<hr>
<h2 id='get_mu_yt_Cpp'>Calculate the conditional means of the process</h2><span id='topic+get_mu_yt_Cpp'></span>

<h3>Description</h3>

<p>Calculates the conditional means <code class="reqn">\mu_{y,t}</code> of the process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mu_yt_Cpp(obs, all_phi0, all_A, alpha_mt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_mu_yt_Cpp_+3A_obs">obs</code></td>
<td>
<p>a <code class="reqn">(T \times dp)</code> matrix such that the i:th row contains the vector
<code class="reqn">(y_{i-1},...,y_{i-p})</code> <code class="reqn">((dp)x1)</code>, where <code class="reqn">y_{i}=(y_{1i},...,y_{di})</code>
<code class="reqn">(dx1)</code>. That is, the initial values are included but the last observations not.</p>
</td></tr>
<tr><td><code id="get_mu_yt_Cpp_+3A_all_phi0">all_phi0</code></td>
<td>
<p>a <code class="reqn">(d \times M)</code> matrix such that the m:th column contains the
intercept parameters of the m:th regime.</p>
</td></tr>
<tr><td><code id="get_mu_yt_Cpp_+3A_all_a">all_A</code></td>
<td>
<p>a <code class="reqn">(d \times dp \times M)</code> array such that the slice <code>[, , m]</code>
contains the AR matrices of the m:th regime cbinded together: <code class="reqn">[A_{m,1}:...:A_{m,p}]</code>.</p>
</td></tr>
<tr><td><code id="get_mu_yt_Cpp_+3A_alpha_mt">alpha_mt</code></td>
<td>
<p>a <code class="reqn">(T \times M)</code> matrix such that <code>[t, m]</code> contains the time t
transition weights of the m:th regime.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code class="reqn">(T \times d)</code> matrix such that the i:th row contains the conditional
mean of the process.
</p>

<hr>
<h2 id='get_new_start'>Get the new starting time of series that is forwarded some number of steps</h2><span id='topic+get_new_start'></span>

<h3>Description</h3>

<p><code>get_new_start</code> calculates the new starting time of series
that is forwarded some number of steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_new_start(y_start, y_freq, steps_forward)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_new_start_+3A_y_start">y_start</code></td>
<td>
<p>original starting time of the series</p>
</td></tr>
<tr><td><code id="get_new_start_+3A_y_freq">y_freq</code></td>
<td>
<p>frequency of the series</p>
</td></tr>
<tr><td><code id="get_new_start_+3A_steps_forward">steps_forward</code></td>
<td>
<p>how many steps the series should be forwarded?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a length two numeric vector with the &quot;year&quot; (or &quot;major&quot;)
time point in the first element the &quot;quarter/month/week/day&quot; (or &quot;minor&quot;)
time in the second element for a series that is forwarded from <code>y_start</code>
<code>steps_forward</code> steps forward.
</p>

<hr>
<h2 id='get_omega_eigens'>Calculate the eigenvalues of the &quot;Omega&quot; error term covariance matrices</h2><span id='topic+get_omega_eigens'></span>

<h3>Description</h3>

<p><code>get_omega_eigens</code> calculates the eigenvalues of the &quot;Omega&quot; error
term covariance matrices for each regime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_omega_eigens(stvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_omega_eigens_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with <code class="reqn">d</code> rows and <code class="reqn">M</code> columns - one column for each regime.
The <code class="reqn">m</code>th column contains the eigenvalues of the &quot;Omega&quot; error term covariance matrix
of the <code class="reqn">m</code>th regime.
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li></ul>


<hr>
<h2 id='get_omega_eigens_par'>Calculate the eigenvalues of the &quot;Omega&quot; error term covariance matrices</h2><span id='topic+get_omega_eigens_par'></span>

<h3>Description</h3>

<p><code>get_omega_eigens_par</code> calculates the eigenvalues of the &quot;Omega&quot; error
term covariance matrices for each regime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_omega_eigens_par(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_omega_eigens_par_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="get_omega_eigens_par_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with <code class="reqn">d</code> rows and <code class="reqn">M</code> columns - one column for each regime.
The <code class="reqn">m</code>th column contains the eigenvalues of the &quot;Omega&quot; error term covariance matrix
of the <code class="reqn">m</code>th regime.
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li></ul>


<hr>
<h2 id='get_regime_autocovs'>Calculate regimewise autocovariance matrices</h2><span id='topic+get_regime_autocovs'></span>

<h3>Description</h3>

<p><code>get_regime_autocovs</code> calculates the regimewise autocovariance matrices <code class="reqn">\Gamma_{m}(j)</code>
<code class="reqn">j=0,1,...,p</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_regime_autocovs(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_regime_autocovs_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_regime_autocovs_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_regime_autocovs_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code class="reqn">(d \times d \times p+1 \times M)</code> array containing the first p regimewise autocovariance matrices.
The subset <code>[, , j, m]</code> contains the j-1:th lag autocovariance matrix of the m:th regime.
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li></ul>


<hr>
<h2 id='get_regime_means'>Calculate regime means <code class="reqn">\mu_{m}</code></h2><span id='topic+get_regime_means'></span>

<h3>Description</h3>

<p><code>get_regime_means</code> calculates regime means <code class="reqn">\mu_{m} = (I - \sum A)^(-1))</code>
from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_regime_means(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_regime_means_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="get_regime_means_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="get_regime_means_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="get_regime_means_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="get_regime_means_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="get_regime_means_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_regime_means_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="get_regime_means_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="get_regime_means_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_regime_means_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="get_regime_means_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="get_regime_means_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="get_regime_means_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">(d\times M)</code> matrix containing regime mean <code class="reqn">\mu_{m}</code> in the m:th column, <code class="reqn">m=1,..,M</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li></ul>


<hr>
<h2 id='get_residuals'>Calculate residuals of a smooth transition VAR</h2><span id='topic+get_residuals'></span>

<h3>Description</h3>

<p><code>get_residuals</code> calculates residuals of a smooth transition VAR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_residuals(
  data,
  p,
  M,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL,
  standardize = TRUE,
  structural_shocks = FALSE,
  penalized = FALSE,
  penalty_params = c(0.05, 0.5),
  allow_unstab = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_residuals_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_residuals_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_residuals_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_standardize">standardize</code></td>
<td>
<p>standardize the residuals to identity matrix covariance matrix?</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_structural_shocks">structural_shocks</code></td>
<td>
<p>If <code>TRUE</code>, returns structural shocks instead of residuals
(not available if <code>identification == "reduced_form"</code>, argument <code>standardize</code>
is if structural shocks are to be returned).</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_penalized">penalized</code></td>
<td>
<p>Perform penalized LS estimation that minimizes penalized RSS in which estimates close to breaking or not satisfying the
usual stability condition are penalized? If <code>TRUE</code>, the tuning parameter is set by the argument <code>penalty_params[2]</code>,
and the penalization starts when the eigenvalues of the companion form AR matrix are larger than <code>1 - penalty_params[1]</code>.</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_penalty_params">penalty_params</code></td>
<td>
<p>a numeric vector with two positive elements specifying the penalization parameters:
the first element determined how far from the boundary of the stability region the penalization starts
(a number between zero and one, smaller number starts penalization closer to the boundary) and the second element
is a tuning parameter for the penalization (a positive real number, a higher value penalizes non-stability more).</p>
</td></tr>
<tr><td><code id="get_residuals_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">(T \times d)</code> matrix containing...
</p>

<dl>
<dt>If <code>standardize == TRUE</code>:</dt><dd><p>the standardized Pearson residuals.</p>
</dd>
<dt>If <code>standardize == FALSE</code>:</dt><dd><p>the nonstandardized residuals.</p>
</dd>
<dt>If <code>structural_shocks == TRUE</code>:</dt><dd><p>the structural shocks.</p>
</dd>
</dl>

<p>Note that the starting time is <code class="reqn">p + 1</code> counted from the beginning of the starting time of the data,
as the first <code class="reqn">p</code> observations are used as initial values.
</p>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation.
<em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>International Economic Review</em>, <strong>35</strong>:3, 407-414.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>


<hr>
<h2 id='get_Sigmas'>Calculate the dp-dimensional covariance matrices <code class="reqn">\Sigma_{m,p}</code> in the transition weights
with <code>weight_function="relative_dens"</code></h2><span id='topic+get_Sigmas'></span>

<h3>Description</h3>

<p><code>get_Sigmas</code> calculatesthe dp-dimensional covariance matrices <code class="reqn">\Sigma_{m,p}</code> in
the transition weights with <code>weight_function="relative_dens"</code> so that the algorithm proposed
by McElroy (2017) employed whenever it reduces the computation time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Sigmas(p, M, d, all_A, all_boldA, all_Omegas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Sigmas_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="get_Sigmas_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="get_Sigmas_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="get_Sigmas_+3A_all_a">all_A</code></td>
<td>
<p>4D array containing all coefficient matrices <code class="reqn">A_{m,i}</code>, obtained from <code>pick_allA</code>.</p>
</td></tr>
<tr><td><code id="get_Sigmas_+3A_all_bolda">all_boldA</code></td>
<td>
<p>3D array containing the <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; (companion form) matrices of each regime,
obtained from <code>form_boldA</code>. Will be computed if not given.</p>
</td></tr>
<tr><td><code id="get_Sigmas_+3A_all_omegas">all_Omegas</code></td>
<td>
<p>a <code>[d, d, M]</code> array containing the covariance matrix Omegas</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the dp-dimensional covariance matrix using the formula (2.1.39) in Lütkepohl (2005) when
<code>d*p &lt; 12</code> and using the algorithm proposed by McElroy (2017) otherwise.
</p>
<p>The code in the implementation of the McElroy's (2017) algorithm (in the function <code>VAR_pcovmat</code>) is
adapted from the one provided in the supplementary material of McElroy (2017). Reproduced under GNU General
Public License, Copyright (2015) Tucker McElroy.
</p>


<h3>Value</h3>

<p>Returns a <code>[dp, dp, M]</code> array containing the dp-dimensional covariance matrices for each regime.
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li></ul>


<hr>
<h2 id='get_symmetric_sqrt'>Calculate symmetric square root matrix of a positive definite covariance
matrix</h2><span id='topic+get_symmetric_sqrt'></span>

<h3>Description</h3>

<p><code>get_symmetric_sqrt</code> calculates symmetric square root matrix
of a positive definite covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_symmetric_sqrt(Omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_symmetric_sqrt_+3A_omega">Omega</code></td>
<td>
<p>a positive definite covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vectorized symmetric square root matrix of the matrix <code>Omega</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='GFEVD'>Estimate generalized forecast error variance decomposition for structural
STVAR models.</h2><span id='topic+GFEVD'></span><span id='topic+plot.gfevd'></span><span id='topic+print.gfevd'></span>

<h3>Description</h3>

<p><code>GFEVD</code> estimates generalized forecast error variance decomposition
for structural STVAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFEVD(
  stvar,
  N = 30,
  shock_size = 1,
  initval_type = c("data", "random", "fixed"),
  which_cumulative = numeric(0),
  use_data_shocks = FALSE,
  data_gfevd_pars = c(0, 0.75),
  init_regime = 1,
  init_values = NULL,
  R1 = 250,
  R2 = 250,
  ncores = 2,
  burn_in = 1000,
  exo_weights = NULL,
  seeds = NULL,
  use_parallel = TRUE
)

## S3 method for class 'gfevd'
plot(x, ..., data_shock_pars = NULL)

## S3 method for class 'gfevd'
print(x, ..., digits = 2, N_to_print)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GFEVD_+3A_stvar">stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code>, created by, e.g., <code>fitSTVAR</code> or <code>fitSSTVAR</code>.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_n">N</code></td>
<td>
<p>a positive integer specifying the horizon how far ahead should the GFEVD be calculated.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_shock_size">shock_size</code></td>
<td>
<p>What sign and size should be used for all shocks? By the normalization, the conditional
covariance matrix of the structural error is an identity matrix.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_initval_type">initval_type</code></td>
<td>
<p>What type initial values are used for estimating the GIRFs that the GFEVD is based on?
</p>

<dl>
<dt><code>"data"</code>:</dt><dd><p>Estimate the GIRF for all the possible length <code class="reqn">p</code> histories in the data.</p>
</dd>
<dt><code>"random"</code>:</dt><dd><p>Estimate the GIRF for several random initial values generated from the a specific regime
specified by the argument <code>init_regimes</code>. The number of initial values is set with the argument <code>R2</code>.</p>
</dd>
<dt><code>"fixed"</code>:</dt><dd><p>Estimate the GIRF for the initial values specified with the argument <code>init_values</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GFEVD_+3A_which_cumulative">which_cumulative</code></td>
<td>
<p>a numeric vector with values in <code class="reqn">1,...,d</code>
(<code>d=ncol(data)</code>) specifying which the variables for which the impulse
responses should be cumulative. Default is none.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_use_data_shocks">use_data_shocks</code></td>
<td>
<p>set <code>TRUE</code> (<strong>recommended</strong>) for a special feature in which for every possible length <code class="reqn">p</code> history
in the data, or a subset of them if so specified in the argument <code>data_gfevd_pars</code>, the GFEVD is estimated for a shock that
has the sign and size of the corresponding structural shock recovered from the data. See the details section.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_data_gfevd_pars">data_gfevd_pars</code></td>
<td>
<p>a length two numeric vector with the following elements determining settings for <code>initval_type="data"</code>
and <code>use_data_shocks=TRUE</code>:
</p>

<ol>
<li><p> An integer between <code>0</code> and <code>M</code> determining the (dominant) regime for which the GFEVD should be calculated (<code>0</code>
for all regimes).
</p>
</li>
<li><p> A number between <code>0.5</code> and <code>1</code> determining how large transition weight a regime should have to be considered dominant
in a given time period (i.e., determining which histories are used to calculate the GFEVD if the first element is not <code>0</code>).
</p>
</li></ol>
</td></tr>
<tr><td><code id="GFEVD_+3A_init_regime">init_regime</code></td>
<td>
<p>an integer in <code class="reqn">1,...,M</code> specifying the regime from which
the initial values should be generated from (using a simulation procedure with a burn-in period).
For models with Gaussian conditional distribution, it is also possible to generate the starting
values from the stationary distribution of a regime. See the details section.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_init_values">init_values</code></td>
<td>
<p>a size <code>[p, d, R2]</code> array specifying the initial values in each slice
for each Monte Carlo repetition, where d is the number of time series in the system and <code>R2</code>
is an argument of this function. In each slice, the <strong>last</strong> row will be used as initial values
for the first lag, the second last row for second lag etc. If not specified, initial values will be
drawn from the regime specified in <code>init_regimes</code>.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_r1">R1</code></td>
<td>
<p>the number of repetitions used to estimate GIRF for each initial
value.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_r2">R2</code></td>
<td>
<p>the number of initial values to be drawn/used if <code>initval_type="random"</code> or <code>"fixed"</code>.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_ncores">ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing. Only
single core computing is supported if an initial value is specified (and
the GIRF won't thus be estimated multiple times).</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_burn_in">burn_in</code></td>
<td>
<p>Burn-in period for simulating initial values from a regime.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_exo_weights">exo_weights</code></td>
<td>
<p>if <code>weight_function="exogenous"</code>, provide a size
<code class="reqn">(N+1 \times M)</code> matrix of exogenous transition weights for the regimes: <code>[h, m]</code>
for the (after-the-impact) period <code class="reqn">h-1</code> and regime <code class="reqn">m</code> weight (<code>[1, m]</code>
is for the impact period). Ignored if <code>weight_function!="exogenous"</code>.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_seeds">seeds</code></td>
<td>
<p>a numeric vector containing the random number generator seed for estimation
of each GIRF. Should have the length of at least...
</p>

<ul>
<li><p> ...<code>nrow(data) - p + 1</code> if <code>initval_type="data"</code> or <code>use_data_shocks=TRUE</code>.
</p>
</li>
<li><p> ...<code>R2</code> if <code>initval_type="random"</code>.
</p>
</li>
<li><p> ...<code>1</code> if <code>initval_type="fixed."</code>.
</p>
</li></ul>

<p>If the length of the vector is greater than what is needed, the extra seeds are dropped from the
end of the <code>seeds</code> vector. Set to <code>NULL</code> for not initializing the seed.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_use_parallel">use_parallel</code></td>
<td>
<p>employ parallel computing? If <code>FALSE</code>, does not print
anything.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_x">x</code></td>
<td>
<p>object of class <code>'gfevd'</code> generated by the function <code>GFEVD</code>.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to the <code>'ts'</code> plot method when using <code>data_shock_pars</code>.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_data_shock_pars">data_shock_pars</code></td>
<td>
<p>if <code>use_data_shocks</code>, alternative plot method can be used that
plots the relative contribution of a given shock to the forecast error variance of each variable
at a given horizon. Should be a length two numeric vector with the number of the shock (1,..,d)
in the first element and the horizon (0,1,2,...,N) in the second element.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_n_to_print">N_to_print</code></td>
<td>
<p>an integer specifying the horizon how far to print the estimates.
The default is that all the values are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GFEVD is a forecast error variance decomposition calculated with the generalized
impulse response function (GIRF). See Lanne and Nyberg (2016) for details.
</p>
<p>If <code>use_data_shocks=TRUE</code>, each GIRF in the GFEVD is estimated for a shock that has the sign and size of the
corresponding structural shock recovered from the fitted model. This is done for every possible length <code class="reqn">p</code> history
in the data, or to a subset of the histories based in the settings given in the argument <code>data_gfevd_pars</code>.
The GFEVD is then calculated as the average of the GFEVDs obtained from the GIRFs estimated for
the data shocks. The plot and print methods can be used as usual for this GFEVD, but there is also a special feature
that allows to plot the contribution of each shock to the variance of the forecast errors at various horizons in specific
historical points of time. This can be done by using the plot method with the argument <code>data_shock_pars</code>.
Note that the arguments <code>shock_size</code>, <code>initval_type</code>, and <code>init_regime</code> are ignored if <code>use_data_shocks=TRUE</code>.
</p>


<h3>Value</h3>

<p>Returns and object of class 'gfevd' containing the GFEVD for all the variables and to
the transition weights. Note that the decomposition does not exist at horizon zero for transition weights
because the related GIRFs are always zero at impact.
Also contains the individual GFEVDs for each used initial length <code class="reqn">p</code> initial value (history) as
4D array with dimensions <code>[horizon, variable, shock, time]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(gfevd)</code>: plot method
</p>
</li>
<li> <p><code>print(gfevd)</code>: print method
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Lanne M. and Nyberg H. 2016. Generalized Forecast Error Variance Decomposition for Linear
and Nonlineae Multivariate Models. <em>Oxford Bulletin of Economics and Statistics</em>, <strong>78</strong>, 4, 595-603.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+linear_IRF">linear_IRF</a></code>, <code><a href="#topic+fitSSTVAR">fitSSTVAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 # These are long-running examples that use parallel computing.
 # It takes approximately 30 seconds to run all the below examples.
 # Note that larger R1 and R2 should be used for more reliable results;
 # small R1 and R2 are used here to shorten the estimation time.

 # Recursively identifed logistic Student's t STVAR(p=3, M=2) model with the first
 # lag of the second variable as the switching variable:
 params32logt &lt;- c(0.5959, 0.0447, 2.6279, 0.2897, 0.2837, 0.0504, -0.2188, 0.4008,
  0.3128, 0.0271, -0.1194, 0.1559, -0.0972, 0.0082, -0.1118, 0.2391, 0.164, -0.0363,
  -1.073, 0.6759, 3e-04, 0.0069, 0.4271, 0.0533, -0.0498, 0.0355, -0.4686, 0.0812,
   0.3368, 0.0035, 0.0325, 1.2289, -0.047, 0.1666, 1.2067, 7.2392, 11.6091)
 mod32logt &lt;- STVAR(gdpdef, p=3, M=2, params=params32logt, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student", identification="recursive")

 # GFEVD for one-standard-error positive structural shocks, N=30 steps ahead,
 # with fix initial values assuming all possible histories in the data.
 gfevd1 &lt;- GFEVD(mod32logt, shock_size=1, N=30, initval_type="data", R1=10,
   seeds=1:(nrow(mod32logt$data)-2))
 print(gfevd1) # Print the results
 plot(gfevd1) # Plot the GFEVD

 # GFEVD for one-standard-error positive structural shocks, N=30 steps ahead,
 # with fix initial values that are the last p observations of the data.
 gfevd2 &lt;- GFEVD(mod32logt, shock_size=1, N=30, initval_type="fixed", R1=100, R2=1,
  init_values=array(mod32logt$data[(nrow(mod32logt$data) - 2):nrow(mod32logt$data),],
  dim=c(3, 2, 1)), seeds=1)
 plot(gfevd2) # Plot the GFEVD

 # GFEVD for two-standard-error negative structural shocks, N=50 steps ahead
 # with the inital values drawn from the first regime. The responses of both
 # variables are accumulated.
 gfevd3 &lt;- GFEVD(mod32logt, shock_size=-2, N=50, initval_type="random",
  R1=50, R2=50, init_regime=1)
 plot(gfevd3) # Plot the GFEVD

 # GFEVD calculated for each lenght p history in the data in such a way that
 # for each history, the structural shock recovered from the fitted model is
 # used.
 gfevd4 &lt;- GFEVD(mod32logt, N=20, use_data_shocks=TRUE, R1=10)
 plot(gfevd4) # The usual plot method

 # Plot the contribution of the first to the variance of the forecast errors at
 # the historial points of time using the structural shocks recovered from the data:
 plot(gfevd4, data_shock_pars=c(1, 0)) # Contribution at impact
 plot(gfevd4, data_shock_pars=c(1, 2)) # Contribution after two periods
 plot(gfevd4, data_shock_pars=c(1, 4)) # Contribution after four periods

 # GFEVD calculated for each length p history in the data in such a way that
 # for each history, the structural shock recovered from the fitted model is
 # used, and only include the histories in which Regime 1 is dominant (its
 # transition weight is at least 0.75):
 gfevd5 &lt;- GFEVD(mod32logt, N=20, use_data_shocks=TRUE, data_gfevd_pars=c(1, 0.75),
   R1=10)
 plot(gfevd5) # Plot the GFEVD
 
</code></pre>

<hr>
<h2 id='GIRF'>Estimate generalized impulse response function for
structural STVAR models.</h2><span id='topic+GIRF'></span><span id='topic+plot.girf'></span><span id='topic+print.girf'></span>

<h3>Description</h3>

<p><code>GIRF</code> estimates generalized impulse response function for
structural STVAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GIRF(
  stvar,
  which_shocks,
  shock_size = 1,
  N = 30,
  R1 = 250,
  R2 = 250,
  init_regime = 1,
  init_values = NULL,
  which_cumulative = numeric(0),
  scale = NULL,
  scale_type = c("instant", "peak"),
  scale_horizon = N,
  ci = c(0.95, 0.8),
  use_data_shocks = FALSE,
  data_girf_pars = c(0, 0.75, 0, 0, 1.5),
  ncores = 2,
  burn_in = 1000,
  exo_weights = NULL,
  seeds = NULL,
  use_parallel = TRUE
)

## S3 method for class 'girf'
plot(x, margs, ...)

## S3 method for class 'girf'
print(x, ..., digits = 2, N_to_print)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GIRF_+3A_stvar">stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code>, created by, e.g., <code>fitSTVAR</code> or <code>fitSSTVAR</code>.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_which_shocks">which_shocks</code></td>
<td>
<p>a numeric vector of length at most <code class="reqn">d</code>
(<code>=ncol(data)</code>) and elements in <code class="reqn">1,...,d</code> specifying the
structural shocks for which the GIRF should be estimated.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_shock_size">shock_size</code></td>
<td>
<p>a non-zero scalar value specifying the common size for all scalar
components of the structural shock. Note that the conditional covariance
matrix of the structural shock is normalized to an identity matrix and that the
(generalized) impulse responses may not be symmetric with respect to the sign
and size of the shock.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_n">N</code></td>
<td>
<p>a positive integer specifying the horizon how far ahead should the
generalized impulse responses be calculated.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_r1">R1</code></td>
<td>
<p>the number of repetitions used to estimate GIRF for each initial
value.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_r2">R2</code></td>
<td>
<p>the number of initial values to use, i.e., to draw from <code>init_regime</code>
if <code>init_values</code> are not specified. The confidence bounds
will be sample quantiles of the GIRFs based on different initial values.
Ignored if the argument <code>init_value</code> is specified.
@param init_regime an integer in <code class="reqn">1,...,M</code> specifying the regime from which
the initial values should be generated from (see <code>?simulate.stvar</code>). If
<code>use_data_shocks=TRUE</code> this is argument not used and <code>data_girf_pars</code>
should be specified instead.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_init_regime">init_regime</code></td>
<td>
<p>an integer in <code class="reqn">1,...,M</code> specifying the regime from which
the initial values should be generated from (using a simulation procedure with a burn-in period).
For models with Gaussian conditional distribution, it is also possible to generate the starting
values from the stationary distribution of a regime. See the details section.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_init_values">init_values</code></td>
<td>
<p>a size <code>[p, d, R2]</code> array specifying the initial values in each slice
for each Monte Carlo repetition, where d is the number of time series in the system and <code>R2</code>
is an argument of this function. In each slice, the <strong>last</strong> row will be used as initial values
for the first lag, the second last row for second lag etc. If not specified, initial values will be
drawn from the regime specified in <code>init_regimes</code>.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_which_cumulative">which_cumulative</code></td>
<td>
<p>a numeric vector with values in <code class="reqn">1,...,d</code>
(<code>d=ncol(data)</code>) specifying which the variables for which the impulse
responses should be cumulative. Default is none.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_scale">scale</code></td>
<td>
<p>should the GIRFs to some of the shocks be scaled so that they
correspond to a specific magnitude of instantaneous or peak response
of some specific variable (see the argument <code>scale_type</code>)?
Provide a length three vector where the shock of interest
is given in the first element (an integer in <code class="reqn">1,...,d</code>), the variable of
interest is given in the second element (an integer in <code class="reqn">1,...,d</code>), and
the magnitude of its instantaneous or peak response in the third element
(a non-zero real number). If the GIRFs of multiple shocks should be scaled, provide
a matrix which has one column for each of the shocks with the columns being
the length three vectors described above.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_scale_type">scale_type</code></td>
<td>
<p>If argument <code>scale</code> is specified, should the GIRFs be
scaled to match an instantaneous response (<code>"instant"</code>) or peak response
(<code>"peak"</code>). If <code>"peak"</code>, the scale is based on the largest magnitude
of peak response in absolute value. Ignored if <code>scale</code> is not specified.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_scale_horizon">scale_horizon</code></td>
<td>
<p>If <code>scale_type == "peak"</code> what the maximum horizon up
to which peak response is expected? Scaling won't based on values after this.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_ci">ci</code></td>
<td>
<p>a numeric vector with elements in <code class="reqn">(0, 1)</code> specifying the
confidence levels of the &quot;confidence intervals&quot; that <strong>do not</strong> quantify uncertainty about the true parameter value
but only uncertainty about the initial value (and possibly sign and size of the shock) within the given regime.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_use_data_shocks">use_data_shocks</code></td>
<td>
<p>set <code>TRUE</code> for a special feature in which for every possible length <code class="reqn">p</code> history in the data,
or a subset of them if so specified in the argument <code>data_girf_pars</code>, the GIRF is estimated for a shock that has the
sign and size of the corresponding structural shock recovered from the data. If used, the argument <code>which_shocks</code>
must specify only one shock. See the details section.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_data_girf_pars">data_girf_pars</code></td>
<td>
<p>a length five numeric vector with the following elements determining settings for <code>use_data_shocks=TRUE</code>
(concerns the single shock specified in the argument <code>which_shocks</code>):
</p>

<ol>
<li><p> An integer between <code>0</code> and <code>M</code> determining the (dominant) regime for which the GIRF should be calculated (<code>0</code>
for all regimes).
</p>
</li>
<li><p> A number between <code>0.5</code> and <code>1</code> determining how large transition weight a regime should have to be considered dominant
in a given time period (i.e., determining which histories are used to calculate the GIRF if the first element is not <code>0</code>).
</p>
</li>
<li><p> Either <code>0</code>, <code>-1</code>, or <code>1</code>, determining whether the GIRF should be calculated using shocks of all signs,
only negative shocks, or only positive shocks, respectively.
</p>
</li>
<li><p> Either, <code>0</code>, <code>1</code>, or <code>2</code>, determining whether the GIRF should be calculated using shocks of all sizes,
only small shocks, or only large shocks, respectively.
</p>
</li>
<li><p> A strictly positive real number determining what size shocks are considered large and what size small &quot;in the scale of standard
deviations&quot; (for example, if set to <code>2</code>, shocks larger than that are considered large and shocks smaller than that are considered
small; note that the standard deviations of the shocks are normalized to unity).
</p>
</li></ol>
</td></tr>
<tr><td><code id="GIRF_+3A_ncores">ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing. Only
single core computing is supported if an initial value is specified (and
the GIRF won't thus be estimated multiple times).</p>
</td></tr>
<tr><td><code id="GIRF_+3A_burn_in">burn_in</code></td>
<td>
<p>Burn-in period for simulating initial values from a regime.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_exo_weights">exo_weights</code></td>
<td>
<p>if <code>weight_function="exogenous"</code>, provide a size
<code class="reqn">(N+1 \times M)</code> matrix of exogenous transition weights for the regimes: <code>[h, m]</code>
for the (after-the-impact) period <code class="reqn">h-1</code> and regime <code class="reqn">m</code> weight (<code>[1, m]</code>
is for the impact period). Ignored if <code>weight_function!="exogenous"</code>.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_seeds">seeds</code></td>
<td>
<p>A numeric vector initializing the seeds for the random number generator
for estimation of each GIRF. Should have the length of at least (extra seeds are removed
from the end of the vector)...
</p>

<dl>
<dt>If initial values are drawn using <code>init_regime</code>:</dt><dd><p><code>R2</code></p>
</dd>
<dt>If initial values are specified in <code>init_values</code>:</dt><dd><p><code>dim(init_values)[3]</code></p>
</dd>
<dt>If <code>use_data_shocks=TRUE</code>:</dt><dd><p>1 (the vector of seeds are generated according on the number of histories
in the data that satisfy the conditions given in the argument <code>data_girf_pars</code>).</p>
</dd>
</dl>

<p>Set <code>NULL</code> for not initializing the seed.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_use_parallel">use_parallel</code></td>
<td>
<p>employ parallel computing? If <code>FALSE</code>, does not print
anything.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_x">x</code></td>
<td>
<p>object of class <code>'girf'</code> generated by the function <code>GIRF</code>.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_margs">margs</code></td>
<td>
<p>numeric vector of length four that adjusts the
<code>[bottom_marginal, left_marginal, top_marginal, right_marginal]</code>
as the relative sizes of the marginals to the figures of the responses.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code>plot</code> method plotting the GIRFs</p>
</td></tr>
<tr><td><code id="GIRF_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
<tr><td><code id="GIRF_+3A_n_to_print">N_to_print</code></td>
<td>
<p>an integer specifying the horizon how far to print the estimates and
confidence intervals. The default is that all the values are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;confidence bounds&quot; <strong>do not</strong> quantify uncertainty about the true parameter
value but only the initial values (and possibly sign and size of the shock) within the given regime.
If initial values are specified, confidence intervals won't be calculated. Note that if the bounds
look weird in the figure produced by <code>plot.girf</code>, it is probably because the point estimate is not
inside the bounds. In this case, increasing the argument <code>R2</code> usually fixes the issue.
</p>
<p>Note that if the argument <code>scale</code> is used, the scaled responses of
the transition weights might be more than one in absolute value.
</p>
<p>If <code>weight_function="exogenous"</code>, exogenous transition weights used in
the Monte Carlo simulations for the future sample paths of the process must
the given in the argument <code>exo_weights</code>. The same weights are used as
the transition weights across the Monte Carlo repetitions.
</p>
<p>If <code>use_data_shocks=TRUE</code>, the GIRF is estimated using all, or a subset of, the length p histories in the data
as the initial values, and using the sign and size of the corresponding structural shock recovered from the fitted model.
The subset of the length p histories are determined based in the settings given in the argument <code>data_girf_pars</code>.
Note that the arguments <code>shock_size</code>  and <code>init_regime</code> are ignored if <code>use_data_shocks=TRUE</code>.
</p>


<h3>Value</h3>

<p>Returns a class <code>'girf'</code> list with the GIRFs in the first
element (<code>$girf_res</code>) and the used arguments the rest. The first
element containing the GIRFs is a list with the <code class="reqn">m</code>th element
containing the point estimates for the GIRF in <code>$point_est</code> (the first
element) and confidence intervals in <code>$conf_ints</code> (the second
element). The first row is for the GIRF at impact <code class="reqn">(n=0)</code>, the second
for <code class="reqn">n=1</code>, the third for <code class="reqn">n=2</code>, and so on.
</p>
<p>The element <code>$all_girfs</code> is a list containing results from all the individual GIRFs
obtained from the MC repetitions. Each element is for one shock and results are in
array of the form <code>[horizon, variables, MC-repetitions]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(girf)</code>: plot method
</p>
</li>
<li> <p><code>print(girf)</code>: print method
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+GFEVD">GFEVD</a></code>, <code><a href="#topic+linear_IRF">linear_IRF</a></code>, <code><a href="#topic+fitSSTVAR">fitSSTVAR</a></code>
</p>

<ul>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'> 
 # These are long-running examples that use parallel computing.
 # It takes approximately 30 seconds to run all the below examples.
 # Note that larger R1 and R2 should be used for more reliable results;
 # small R1 and R2 are used here to shorten the estimation time.

 # Recursively identified logistic Student's t STVAR(p=3, M=2) model with the first
 # lag of the second variable as the switching variable:
 params32logt &lt;- c(0.5959, 0.0447, 2.6279, 0.2897, 0.2837, 0.0504, -0.2188, 0.4008,
  0.3128, 0.0271, -0.1194, 0.1559, -0.0972, 0.0082, -0.1118, 0.2391, 0.164, -0.0363,
  -1.073, 0.6759, 3e-04, 0.0069, 0.4271, 0.0533, -0.0498, 0.0355, -0.4686, 0.0812,
   0.3368, 0.0035, 0.0325, 1.2289, -0.047, 0.1666, 1.2067, 7.2392, 11.6091)
 mod32logt &lt;- STVAR(gdpdef, p=3, M=2, params=params32logt, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student", identification="recursive")

 # GIRF for one-standard-error positive structural shocks, N=30 steps ahead,
 # with the inital values drawn from the first regime.
 girf1 &lt;- GIRF(mod32logt, which_shocks=1:2, shock_size=1, N=30, R1=50, R2=50,
  init_regime=2)
 print(girf1) # Print the results
 plot(girf1) # Plot the GIRFs

 # GIRF for one-standard-error positive structural shocks, N=30 steps ahead,
 # with the inital values drawn from the second regime. The responses of the
 # GDP and GDP deflator growth rates are accumulated.
 girf2 &lt;- GIRF(mod32logt, which_shocks=1:2, which_cumulative=1:2, shock_size=1,
  N=30, R1=50, R2=50, init_regime=2)
 plot(girf2) # Plot the GIRFs

 # GIRF for two-standard-error negative structural shock - the first shock only.
 # N=50 steps ahead with the inital values drawn from the first regime. The responses
 # are scaled to correspond an instantanous increase of 0.5 of the first variable.
 girf3 &lt;- GIRF(mod32logt, which_shocks=1, shock_size=-2, N=50, R1=50, R2=50,
  init_regime=1, scale_type="instant", scale=c(1, 1, 0.5))
 plot(girf3) # Plot the GIRFs

 # GIRFs for the first shock, using the length p histories in the data where
 # the first regime is dominant (its transition weight is at least 0.75),
 # the shock is negative, and the size of the shock is less than 1.5.
 # The responses are scaled to correspond a unit instantanous increase of the
 # first variable.
 girf4 &lt;- GIRF(mod32logt, which_shocks=1, N=30, R1=10, use_data_shocks=TRUE,
  data_girf_pars=c(1, 0.75, -1, 1, 1.5), scale_type="instant", scale=c(1, 1, 0.5))
 plot(girf4) # Plot the GIRFs
 
</code></pre>

<hr>
<h2 id='in_paramspace'>Determine whether the parameter vector is in the parameter space</h2><span id='topic+in_paramspace'></span>

<h3>Description</h3>

<p><code>in_paramspace</code> checks whether the parameter vector is in the parameter
space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_paramspace(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  B_constraints = NULL,
  other_constraints = NULL,
  all_boldA,
  all_Omegas,
  weightpars,
  distpars,
  transition_weights,
  allow_unstab = FALSE,
  stab_tol = 0.001,
  posdef_tol = 1e-08,
  distpar_tol = 1e-08,
  weightpar_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="in_paramspace_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="in_paramspace_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="in_paramspace_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_other_constraints">other_constraints</code></td>
<td>
<p>A list containing internally used additional type of constraints (see the options below).
</p>

<dl>
<dt>$fixed_lambdas (only if <code>identification="heteroskedasticity"</code>):</dt><dd><p>a length <code class="reqn">d(M-1)</code> numeric vector
(<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger
than zero specifying the fixed parameter values for the parameters <code class="reqn">\lambda_{mi}</code> should be constrained to.</p>
</dd>
<dt>$B1_constraints (only if <code>identification="non-Gaussianity"</code>):</dt><dd><p>set to the string &quot;fixed_sign_and_order&quot;
to impose the constraints that the elements of the first impact matrix <code class="reqn">B_1</code> are strictly positive and that they
are in a decreasing order.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="in_paramspace_+3A_all_bolda">all_boldA</code></td>
<td>
<p>3D array containing the <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; (companion form) matrices of each regime,
obtained from <code>form_boldA</code>. Will be computed if not given.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_all_omegas">all_Omegas</code></td>
<td>
<p>A 3D array containing the covariance matrix parameters obtain from <code>pick_Omegas</code>...
</p>

<dl>
<dt>If <code>cond_dist %in% c("Gaussian", "Student")</code>:</dt><dd><p>all covariance matrices <code class="reqn">\Omega_{m}</code> in <code>[, , m]</code>.</p>
</dd>
<dt>If <code>cond_dist=="ind_Student"</code>:</dt><dd><p>all impact matrices <code class="reqn">B_m</code> of the regimes in <code>[, , m]</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="in_paramspace_+3A_weightpars">weightpars</code></td>
<td>
<p>numerical vector containing the transition weight parameters, obtained from <code>pick_weightpars</code>.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_distpars">distpars</code></td>
<td>
<p>A numeric vector containing the distribution parameters...
</p>

<dl>
<dt>If <code>cond_dist=="Gaussian"</code>:</dt><dd><p>Not used, i.e., a numeric vector of length zero.</p>
</dd>
<dt>If <code>cond_dist=="Student"</code>:</dt><dd><p>The degrees of freedom parameter, i.e., a numeric vector of length one.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="in_paramspace_+3A_transition_weights">transition_weights</code></td>
<td>
<p>(optional; only for models with <code>cond_dist="ind_Student"</code> or <code>identification="non-Gaussianity"</code>)
A <code class="reqn">T \times M</code> matrix containing the transition weights. If <code>cond_dist="ind_Student"</code> checks that the impact matrix
<code class="reqn">\sum_{m=1}^M\alpha_{m,t}^{1/2}B_m</code> is invertible for all <code class="reqn">t=1,...,T</code>.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_stab_tol">stab_tol</code></td>
<td>
<p>numerical tolerance for stability of condition of the regimes: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the parameter is considered to be outside the parameter space.
Note that if tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the parameter is considered
to be outside the parameter space. Note that if the tolerance is too small, numerical evaluation of the
log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_distpar_tol">distpar_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if the degrees of
freedom parameters is not larger than <code>2 + distpar_tol</code> (applies only if <code>cond_dist="Student"</code>).</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_weightpar_tol">weightpar_tol</code></td>
<td>
<p>numerical tolerance for weight parameters being in the parameter space. Values closer to
to the border of the parameter space than this are considered to be &quot;outside&quot; the parameter space.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter vector in the argument <code>params</code> should be unconstrained and reduced form.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the given parameter values are in the parameter space and <code>FALSE</code> otherwise.
This function does NOT consider identification conditions!
</p>


<h3>References</h3>


<ul>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='ind_skewed_t_densities_Cpp'>Calculate log independent multivariate skewed t densities</h2><span id='topic+ind_skewed_t_densities_Cpp'></span>

<h3>Description</h3>

<p>Calculates logs of independent multivariate skewed t densities with varying mean
and impact matrix (including the constant terms of the density). The varying impact matrix
is calculated within the function from the impact matrices of the regimes and transition weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_skewed_t_densities_Cpp(
  obs,
  means,
  impact_matrices,
  alpha_mt,
  all_nu,
  all_lambda,
  minval,
  posdef_tol
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ind_skewed_t_densities_Cpp_+3A_obs">obs</code></td>
<td>
<p>a <code class="reqn">(T \times d)</code> matrix such that the <code class="reqn">i</code>th row contains the vector
<code class="reqn">y_{i}=(y_{1i},...,y_{di})</code> <code class="reqn">(dx1)</code>. That is, the initial values are
excluded but the last observations is included.</p>
</td></tr>
<tr><td><code id="ind_skewed_t_densities_Cpp_+3A_means">means</code></td>
<td>
<p>a <code class="reqn">(T \times d)</code> matrix such that the <code class="reqn">i</code>th row contains the
conditional mean of the process <code class="reqn">\mu_{y,i}</code>.</p>
</td></tr>
<tr><td><code id="ind_skewed_t_densities_Cpp_+3A_impact_matrices">impact_matrices</code></td>
<td>
<p>a size <code class="reqn">d\times d \times M</code> <code>arma::cube</code> (3D array in R), where each slice contains an
invertible (d x d) impact matrix of each regime.</p>
</td></tr>
<tr><td><code id="ind_skewed_t_densities_Cpp_+3A_alpha_mt">alpha_mt</code></td>
<td>
<p>a <code class="reqn">(T \times M)</code> matrix such that <code>[t, m]</code> contains the time t
transition weights of the <code class="reqn">m</code>th regime.</p>
</td></tr>
<tr><td><code id="ind_skewed_t_densities_Cpp_+3A_all_nu">all_nu</code></td>
<td>
<p>a numeric vector of length <code class="reqn">d</code>, containing the degrees of freedom parameters for each component.</p>
</td></tr>
<tr><td><code id="ind_skewed_t_densities_Cpp_+3A_all_lambda">all_lambda</code></td>
<td>
<p>a numeric vector of length <code class="reqn">d</code>, containing the skewness parameters for each component.</p>
</td></tr>
<tr><td><code id="ind_skewed_t_densities_Cpp_+3A_minval">minval</code></td>
<td>
<p>the value that will be returned if the parameter vector does not lie in the parameter space
(excluding the identification condition).</p>
</td></tr>
<tr><td><code id="ind_skewed_t_densities_Cpp_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the parameter is considered
to be outside the parameter space. Note that if the tolerance is too small, numerical evaluation of the
log-likelihood might fail and cause error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>minval</code> if the impact matrix <code class="reqn">B_t</code> is not invertible for some t up to the numerical tolerance
<code>posdef_tol</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code class="reqn">T</code>, where each element represents the computed density component for
the corresponding observation.
</p>

<hr>
<h2 id='ind_Student_densities_Cpp'>Calculate log independent multivariate Student's t densities</h2><span id='topic+ind_Student_densities_Cpp'></span>

<h3>Description</h3>

<p>Calculates logs of independent multivariate Student t densities with varying mean
and impact matrix AND EXCLUDING the constant term of the density
(the constant is calculated and added in R code). The varying impact matrix is calculated within
the function from the impact matrices of the regimes and transition weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_Student_densities_Cpp(
  obs,
  means,
  impact_matrices,
  alpha_mt,
  distpars,
  minval,
  posdef_tol
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ind_Student_densities_Cpp_+3A_obs">obs</code></td>
<td>
<p>a <code class="reqn">(T \times d)</code> matrix such that the <code class="reqn">i</code>th row contains the vector
<code class="reqn">y_{i}=(y_{1i},...,y_{di})</code> <code class="reqn">(dx1)</code>. That is, the initial values are
excluded but the last observations is included.</p>
</td></tr>
<tr><td><code id="ind_Student_densities_Cpp_+3A_means">means</code></td>
<td>
<p>a <code class="reqn">(T \times d)</code> matrix such that the <code class="reqn">i</code>th row contains the
conditional mean of the process <code class="reqn">\mu_{y,i}</code>.</p>
</td></tr>
<tr><td><code id="ind_Student_densities_Cpp_+3A_impact_matrices">impact_matrices</code></td>
<td>
<p>a size <code class="reqn">d\times d \times M</code> <code>arma::cube</code> (3D array in R), where each slice contains an
invertible (d x d) impact matrix of each regime.</p>
</td></tr>
<tr><td><code id="ind_Student_densities_Cpp_+3A_alpha_mt">alpha_mt</code></td>
<td>
<p>a <code class="reqn">(T \times M)</code> matrix such that <code>[t, m]</code> contains the time t
transition weights of the <code class="reqn">m</code>th regime.</p>
</td></tr>
<tr><td><code id="ind_Student_densities_Cpp_+3A_distpars">distpars</code></td>
<td>
<p>a numeric vector of length <code class="reqn">d</code>, containing the degrees of freedom parameters for each component.</p>
</td></tr>
<tr><td><code id="ind_Student_densities_Cpp_+3A_minval">minval</code></td>
<td>
<p>the value that will be returned if the parameter vector does not lie in the parameter space
(excluding the identification condition).</p>
</td></tr>
<tr><td><code id="ind_Student_densities_Cpp_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the parameter is considered
to be outside the parameter space. Note that if the tolerance is too small, numerical evaluation of the
log-likelihood might fail and cause error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>minval</code> if the impact matrix <code class="reqn">B_t</code> is not invertible for some t up to the numerical tolerance
<code>posdef_tol</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code class="reqn">T</code>, where each element represents the computed density component for
the corresponding observation.
</p>

<hr>
<h2 id='iterate_more'>Maximum likelihood estimation of a reduced form or structural STVAR model based on preliminary estimates</h2><span id='topic+iterate_more'></span>

<h3>Description</h3>

<p><code>iterate_more</code> uses a variable metric algorithm to estimate a reduced form or structural STVAR model
(object of class <code>'stvar'</code>) based on preliminary estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate_more(
  stvar,
  maxit = 1000,
  h = 0.001,
  penalized,
  penalty_params,
  allow_unstab,
  calc_std_errors = TRUE,
  print_trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iterate_more_+3A_stvar">stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code>, created by, e.g., <code>fitSTVAR</code> or <code>fitSSTVAR</code>.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations in the variable metric algorithm.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_h">h</code></td>
<td>
<p>the step size used in the central difference approximation of the gradient of the log-likelihood function, so
<code>h</code> should be a small positive real number.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_penalized">penalized</code></td>
<td>
<p>should penalized log-likelihood function be used that penalizes the log-likelihood function when
the parameter values are close the boundary of the stability region or outside it? If <code>TRUE</code>, estimates
that do not satisfy the stability condition are allowed (except when <code>weight_function="relative_dens"</code>).
The default is <code>TRUE</code> for three-phase estimation and <code>FALSE</code> for two-phase estimation.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_penalty_params">penalty_params</code></td>
<td>
<p>a numeric vector with two positive elements specifying the penalization parameters:
the first element determined how far from the boundary of the stability region the penalization starts
(a number between zero and one, smaller number starts penalization closer to the boundary) and the second element
is a tuning parameter for the penalization (a positive real number, a higher value penalizes non-stability more).</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>Calculate approximate standard errors (based on standard asymptotics)?</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_print_trace">print_trace</code></td>
<td>
<p>should the trace of the optimization algorithm be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of <code>iterate_more</code> is to provide a simple and convenient tool to finalize
the estimation when the maximum number of iterations is reached when estimating a STVAR model
with the main estimation function <code>fitSTVAR</code> or <code>fitSSTVAR</code>.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td></tr>
<tr><td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td></tr>
<tr><td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td></tr>
<tr><td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td></tr>
<tr><td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td></tr>
<tr><td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td></tr>
<tr><td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td></tr>
<tr><td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td></tr>
<tr><td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td></tr>
<tr><td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td></tr>
<tr><td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td></tr>
<tr><td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>The seeds used in the estimation in <code>fitSTVAR</code>, if applicable.</p>
</td></tr>
<tr><td><code>LS_estimates</code></td>
<td>
<p>The least squares estimates of the parameters in the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code> (intercepts replaced by unconditional means
if mean parametrization is used), if applicable.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hubrich K., Teräsvirta. T. 2013. Thresholds and Smooth Transitions in Vector Autoregressive Models.
<em>CREATES Research Paper 2013-18, Aarhus University.</em>
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+swap_B_signs">swap_B_signs</a></code>, <code><a href="#topic+reorder_B_columns">reorder_B_columns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples that take approximately 20 seconds to run.

# Estimate two-regime Gaussian STVAR p=1 model with the weighted relative stationary densities
# of the regimes as the transition weight function, but only 5 iterations of the variable matrix
# algorithm:
fit12 &lt;- fitSTVAR(gdpdef, p=1, M=2, nrounds=1, seeds=1, ncores=1, maxit=5)

# The iteration limit was reached, so the estimate is not local maximum.
# The gradient of the log-likelihood function:
get_foc(fit12) # Not close to zero!

# So, we run more iterations of the variable metric algorithm:
fit12 &lt;- iterate_more(fit12)

# The gradient of the log-likelihood function after iterating more:
get_foc(fit12) # Close (enough) to zero!

</code></pre>

<hr>
<h2 id='linear_IRF'>Estimate linear impulse response function based on a single regime of a structural STVAR model.</h2><span id='topic+linear_IRF'></span><span id='topic+plot.irf'></span><span id='topic+print.irf'></span>

<h3>Description</h3>

<p><code>linear_IRF</code> estimates linear impulse response function based on a single regime
of a structural STVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_IRF(
  stvar,
  N = 30,
  regime = 1,
  which_cumulative = numeric(0),
  scale = NULL,
  ci = NULL,
  bootstrap_reps = 100,
  ncores = 2,
  robust_method = c("Nelder-Mead", "SANN", "none"),
  maxit_robust = 1000,
  seed = NULL,
  ...
)

## S3 method for class 'irf'
plot(x, shocks_to_plot, ...)

## S3 method for class 'irf'
print(x, ..., digits = 2, N_to_print, shocks_to_print)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_IRF_+3A_stvar">stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code> defining a structural or reduced form
STVAR model. For a reduced form model, the shocks are automatically identified by
the lower triangular Cholesky decomposition.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_n">N</code></td>
<td>
<p>a positive integer specifying the horizon how far ahead should the
linear impulse responses be calculated.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_regime">regime</code></td>
<td>
<p>Based on which regime the linear IRF should be calculated?
An integer in <code class="reqn">1,...,M</code>.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_which_cumulative">which_cumulative</code></td>
<td>
<p>a numeric vector with values in <code class="reqn">1,...,d</code>
(<code>d=ncol(data)</code>) specifying which the variables for which the linear impulse
responses should be cumulative. Default is none.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_scale">scale</code></td>
<td>
<p>should the linear IRFs to some of the shocks be scaled so that they
correspond to a specific instantaneous response of some specific
variable? Provide a length three vector where the shock of interest
is given in the first element (an integer in <code class="reqn">1,...,d</code>), the variable of
interest is given in the second element (an integer in <code class="reqn">1,...,d</code>), and
its instantaneous response in the third element (a non-zero real number).
If the linear IRFs of multiple shocks should be scaled, provide a matrix which has one
column for each of the shocks with the columns being the length three vectors described above.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_ci">ci</code></td>
<td>
<p>a real number in <code class="reqn">(0, 1)</code> specifying the confidence level of the
confidence intervals calculated via a fixed-design wild residual bootstrap method.
Available only for models that impose linear autoregressive dynamics
(excluding changes in the volatility regime).</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_bootstrap_reps">bootstrap_reps</code></td>
<td>
<p>the number of bootstrap repetitions for estimating confidence bounds.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_ncores">ncores</code></td>
<td>
<p>the number of CPU cores to be used in parallel computing when bootstrapping confidence bounds.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_robust_method">robust_method</code></td>
<td>
<p>Should some robust estimation method be used in the estimation before switching
to the gradient based variable metric algorithm? See details.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_maxit_robust">maxit_robust</code></td>
<td>
<p>the maximum number of iterations on the first phase robust estimation, if employed.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_seed">seed</code></td>
<td>
<p>a real number initializing the seed for the random generator.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_x">x</code></td>
<td>
<p>object of class <code>'irf'</code> generated by the function <code>linear_IRF</code>.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_shocks_to_plot">shocks_to_plot</code></td>
<td>
<p>IRFs of which shocks should be plotted? A numeric vector
with elements in <code>1,...,d</code>.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_n_to_print">N_to_print</code></td>
<td>
<p>an integer specifying the horizon how far to print the estimates and
confidence intervals. The default is that all the values are printed.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_shocks_to_print">shocks_to_print</code></td>
<td>
<p>the responses to which should should be printed?
A numeric vector with elements in <code>1,...,d</code>. The default is that responses to
all the shocks are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the autoregressive dynamics of the model are linear (i.e., either M == 1 or mean and AR parameters
are constrained identical across the regimes), confidence bounds can be calculated based on a fixed-design
wild residual bootstrap method. We employ the method described in Herwartz and Lütkepohl (2014); see also
the relevant chapters in Kilian and Lütkepohl (2017).
</p>
<p>Employs the estimation function <code>optim</code> from the package <code>stats</code> that implements the optimization
algorithms. The robust optimization method Nelder-Mead is much faster than SANN but can get stuck at a local
solution. See <code>?optim</code> and the references therein for further details.
</p>
<p>For model identified by non-Gaussianity, the signs and ordering of the shocks are normalized by assuming
that the first non-zero element of each column of the impact matrix of Regime 1 is strictly positive and they are
in a decreasing order. Use the argument <code>scale</code> to obtain IRFs scaled for specific impact responses.
</p>


<h3>Value</h3>

<p>Returns a class <code>'irf'</code> list with  with the following elements:
</p>

<dl>
<dt><code>$point_est</code>:</dt><dd><p>a 3D array <code>[variables, shock, horizon]</code> containing the point estimates of the IRFs.
Note that the first slice is for the impact responses and the slice i+1 for the period i. The response of the
variable 'i1' to the shock 'i2' is subsetted as <code>$point_est[i1, i2, ]</code>.</p>
</dd>
<dt><code>$conf_ints</code>:</dt><dd><p>bootstrapped confidence intervals for the IRFs in a <code>[variables, shock, horizon, bound]</code>
4D array. The lower bound is obtained as <code>$conf_ints[, , , 1]</code>, and similarly the upper bound as
<code>$conf_ints[, , , 2]</code>. The subsetted 3D array is then the bound in a form similar to <code>$point_est</code>.</p>
</dd>
<dt><code>$all_bootstrap_reps</code>:</dt><dd><p>IRFs from all of the bootstrap replications in a <code>[variables, shock, horizon, rep]</code>.
4D array. The IRF from replication i1 is obtained as <code>$all_bootstrap_reps[, , , i1]</code>, and the subsetted 3D array
is then the in a form similar to <code>$point_est</code>.</p>
</dd>
<dt>Other elements:</dt><dd><p>contains some of the arguments the <code>linear_IRF</code> was called with.</p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(irf)</code>: plot method
</p>
</li>
<li> <p><code>print(irf)</code>: print method
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Herwartz H. and Lütkepohl H. 2014. Structural vector autoregressions with Markov switching:
Combining conventional with statistical identification of shocks. <em>Journal of Econometrics</em>,
183, pp. 104-116.
</p>
</li>
<li><p> Kilian L. and Lütkepohl H. 2017. Structural Vectors Autoregressive Analysis.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+GFEVD">GFEVD</a></code>, <code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>,
<code><a href="#topic+reorder_B_columns">reorder_B_columns</a></code>, <code><a href="#topic+swap_B_signs">swap_B_signs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples that take approximately 10 seconds to run.
## A small number of bootstrap replications is used below to shorten the
## running time (in practice, a larger number of replications should be used).

# p=1, M=1, d=2, linear VAR model with independent Student's t shocks identified
# by non-Gaussianity (arbitrary weight function applied here):
theta_112it &lt;- c(0.644, 0.065, 0.291, 0.021, -0.124, 0.884, 0.717, 0.105, 0.322,
  -0.25, 4.413, 3.912)
mod112 &lt;- STVAR(data=gdpdef, p=1, M=1, params=theta_112it, cond_dist="ind_Student",
 identification="non-Gaussianity", weight_function="threshold", weightfun_pars=c(1, 1))
mod112 &lt;- swap_B_signs(mod112, which_to_swap=1:2)

# Estimate IRFs 20 periods ahead, bootstrapped 90% confidence bounds based on
# 10 bootstrap replications. Linear model so robust estimation methods are
# not required.
irf1 &lt;- linear_IRF(stvar=mod112, N=20, regime=1, ci=0.90, bootstrap_reps=1,
 robust_method="none", seed=1, ncores=1)
plot(irf1)
print(irf1, digits=3)

# p=1, M=2, d=2, Gaussian STVAR with relative dens weight function,
# shocks identified recursively.
theta_122relg &lt;- c(0.734054, 0.225598, 0.705744, 0.187897, 0.259626, -0.000863,
  -0.3124, 0.505251, 0.298483, 0.030096, -0.176925, 0.838898, 0.310863, 0.007512,
  0.018244, 0.949533, -0.016941, 0.121403, 0.573269)
mod122 &lt;- STVAR(data=gdpdef, p=1, M=2, params=theta_122relg, identification="recursive")

# Estimate IRF based on the first regime 30 period ahead. Scale IRFs so that
# the instantaneous response of the first variable to the first shock is 0.3,
# and the response of the second variable to the second shock is 0.5.
# response of the Confidence bounds
# are not available since the autoregressive dynamics are nonlinear.
irf2 &lt;- linear_IRF(stvar=mod122, N=30, regime=1, scale=cbind(c(1, 1, 0.3), c(2, 2, 0.5)))
plot(irf2)

 # Estimate IRF based on the second regime without scaling the IRFs:
irf3 &lt;- linear_IRF(stvar=mod122, N=30, regime=2)
plot(irf3)

# p=3, M=2, d=3, Students't logistic STVAR model with the first lag of the second
# variable as the switching variable. Autoregressive dynamics restricted linear,
# but the volatility regime varies in time, allowing the shocks to be identified
# by conditional heteroskedasticity.
theta_322 &lt;- c(0.7575, 0.6675, 0.2634, 0.031, -0.007, 0.5468, 0.2508, 0.0217, -0.0356,
 0.171, -0.083, 0.0111, -0.1089, 0.1987, 0.2181, -0.1685, 0.5486, 0.0774, 5.9398, 3.6945,
 1.2216, 8.0716, 8.9718)
mod322 &lt;- STVAR(data=gdpdef, p=3, M=2, params=theta_322, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student", mean_constraints=list(1:2),
  AR_constraints=rbind(diag(3*2^2), diag(3*2^2)), identification="heteroskedasticity",
  parametrization="mean")

## Estimate IRFs 30 periods ahead, bootstrapped 90% confidence bounds based on
# 10 bootstrap replications. Responses of the second variable are accumulated.
irf4 &lt;- linear_IRF(stvar=mod322, N=30, regime=1, ci=0.90, bootstrap_reps=10,
 which_cumulative=2, seed=1)
plot(irf4)

</code></pre>

<hr>
<h2 id='loglikelihood'>Log-likelihood function</h2><span id='topic+loglikelihood'></span>

<h3>Description</h3>

<p><code>loglikelihood</code> log-likelihood function of a smooth transition VAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood(
  data,
  p,
  M,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL,
  other_constraints = NULL,
  to_return = c("loglik", "tw", "loglik_and_tw", "terms", "regime_cmeans",
    "total_cmeans", "total_ccovs", "B_t"),
  check_params = TRUE,
  penalized = FALSE,
  penalty_params = c(0.05, 0.2),
  allow_unstab = FALSE,
  bound_by_weights = FALSE,
  indt_R = FALSE,
  alt_par = FALSE,
  minval = NULL,
  stab_tol = 0.001,
  posdef_tol = 1e-08,
  distpar_tol = 1e-08,
  weightpar_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglikelihood_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="loglikelihood_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="loglikelihood_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_other_constraints">other_constraints</code></td>
<td>
<p>A list containing internally used additional type of constraints (see the options below).
</p>

<dl>
<dt>$fixed_lambdas (only if <code>identification="heteroskedasticity"</code>):</dt><dd><p>a length <code class="reqn">d(M-1)</code> numeric vector
(<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger
than zero specifying the fixed parameter values for the parameters <code class="reqn">\lambda_{mi}</code> should be constrained to.</p>
</dd>
<dt>$B1_constraints (only if <code>identification="non-Gaussianity"</code>):</dt><dd><p>set to the string &quot;fixed_sign_and_order&quot;
to impose the constraints that the elements of the first impact matrix <code class="reqn">B_1</code> are strictly positive and that they
are in a decreasing order.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="loglikelihood_+3A_to_return">to_return</code></td>
<td>
<p>should the returned object be the log-likelihood, which is the default, or something else?
See the section &quot;Value&quot; for all the options.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_check_params">check_params</code></td>
<td>
<p>should it be checked that the parameter vector satisfies the model assumptions? Can be skipped to save
computation time if it does for sure.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_penalized">penalized</code></td>
<td>
<p>Perform penalized LS estimation that minimizes penalized RSS in which estimates close to breaking or not satisfying the
usual stability condition are penalized? If <code>TRUE</code>, the tuning parameter is set by the argument <code>penalty_params[2]</code>,
and the penalization starts when the eigenvalues of the companion form AR matrix are larger than <code>1 - penalty_params[1]</code>.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_penalty_params">penalty_params</code></td>
<td>
<p>a numeric vector with two positive elements specifying the penalization parameters:
the first element determined how far from the boundary of the stability region the penalization starts
(a number between zero and one, smaller number starts penalization closer to the boundary) and the second element
is a tuning parameter for the penalization (a positive real number, a higher value penalizes non-stability more).</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_bound_by_weights">bound_by_weights</code></td>
<td>
<p>should <code>minval</code> be returned if the transition weights do not allocate enough weights to a regime
compared to the number of observations in the regime? See the source code for details.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_indt_r">indt_R</code></td>
<td>
<p>If <code>TRUE</code> calculates the independent Student's t density in R instead of C++ without any approximations
employed for speed-up.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_alt_par">alt_par</code></td>
<td>
<p>If <code>TRUE</code> assumes that models identified by non-Gaussianiaty (or <code>cond_dist="Student"</code>) are
parametrized as <code class="reqn">B_{y,t}=B_1 + \sum_{m=2}^M\alpha_{m,t}B_m^*</code>, where <code class="reqn">B_m^* = B_m - B_1</code>.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_minval">minval</code></td>
<td>
<p>the value that will be returned if the parameter vector does not lie in the parameter space
(excluding the identification condition).</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_stab_tol">stab_tol</code></td>
<td>
<p>numerical tolerance for stability of condition of the regimes: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the parameter is considered to be outside the parameter space.
Note that if tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the parameter is considered
to be outside the parameter space. Note that if the tolerance is too small, numerical evaluation of the
log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_distpar_tol">distpar_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if the degrees of
freedom parameters is not larger than <code>2 + distpar_tol</code> (applies only if <code>cond_dist="Student"</code>).</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_weightpar_tol">weightpar_tol</code></td>
<td>
<p>numerical tolerance for weight parameters being in the parameter space. Values closer to
to the border of the parameter space than this are considered to be &quot;outside&quot; the parameter space.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the log-likelihood of the specified model.
</p>


<h3>Value</h3>


<dl>
<dt>If <code>to_return="loglik"</code>:</dt><dd><p>the log-likelihood of the specified model.</p>
</dd>
<dt>If <code>to_return=="tw"</code>:</dt><dd><p>a size <code>[n_obs-p, M]</code> matrix containing the transition weights: for m:th component
in m:th column.</p>
</dd>
<dt>If <code>to_return=="loglik_and_tw"</code>:</dt><dd><p>a list of two elements. The first element (<code>$loglik</code>) contains the
log-likelihood and the second element (<code>$tw</code>) contains the transition weights.</p>
</dd>
<dt>If <code>to_return=="terms"</code>:</dt><dd><p>a length <code>n_obs-p</code> numeric vector containing the terms <code class="reqn">l_{t}</code>.</p>
</dd>
<dt>If <code>to_return=="regime_cmeans"</code>:</dt><dd><p>an <code>[n_obs-p, d, M]</code> array containing the regimewise conditional means.</p>
</dd>
<dt>If <code>to_return=="total_cmeans"</code>:</dt><dd><p>a <code>[n_obs-p, d]</code> matrix containing the conditional means of the process.</p>
</dd>
<dt>If <code>to_return=="total_ccovs"</code>:</dt><dd><p>an <code>[d, d, n_obs-p]</code> array containing the conditional covariance matrices of
the process.</p>
</dd>
<dt>If <code>to_return=="B_t"</code>:</dt><dd><p>an <code>[d, d, n_obs-p]</code> array containing the impact matrices <code class="reqn">B_t</code> of
the process. Available only for models with <code>cond_dist="ind_Student"</code>.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation.
<em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>International Economic Review</em>, <strong>35</strong>:3, 407-414.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>


<hr>
<h2 id='LR_test'>Perform likelihood ratio test for a STVAR model</h2><span id='topic+LR_test'></span>

<h3>Description</h3>

<p><code>LR_test</code> performs a likelihood ratio test for a STVAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR_test(stvar1, stvar2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LR_test_+3A_stvar1">stvar1</code></td>
<td>
<p>an object of class <code>'stvar'</code> generated by <code>fitSTVAR</code> or <code>STVAR</code>, containing
the <strong>freely estimated</strong> model.</p>
</td></tr>
<tr><td><code id="LR_test_+3A_stvar2">stvar2</code></td>
<td>
<p>an object of class <code>'stvar'</code> generated by <code>fitSTVAR</code> or <code>STVAR</code>, containing
the <strong>constrained</strong> model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a likelihood ratio test, testing the null hypothesis that the true parameter value lies
in the constrained parameter space. Under the null, the test statistic is asymptotically
<code class="reqn">\chi^2</code>-distributed with <code class="reqn">k</code> degrees of freedom, <code class="reqn">k</code> being the difference in the dimensions
of the unconstrained and constrained parameter spaces.
</p>
<p><strong>The test is based on the assumption of the standard result of asymptotic normality!</strong>
Also, note that this function does <strong>not</strong> verify that the two models are actually nested.
</p>


<h3>Value</h3>

<p>A list with class &quot;hypotest&quot; containing the test results and arguments used to calculate the test.
</p>


<h3>References</h3>


<ul>
<li><p> Buse A. (1982). The Likelihood Ratio, Wald, and Lagrange Multiplier Tests: An Expository Note.
<em>The American Statistician</em>, 36(3a), 153-157.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+Wald_test">Wald_test</a></code>, <code><a href="#topic+Rao_test">Rao_test</a></code>, <code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>,
<code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+Portmanteau_test">Portmanteau_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Logistic Student's t STVAR with p=1, M=2, and the first lag of the second variable
# as the switching variable (parameter values were obtained by maximum likelihood estimation;
 # fitSTVAR is not used here because the estimation is computationally demanding).
params12 &lt;- c(0.62906848, 0.14245295, 2.41245785, 0.66719269, 0.3534745, 0.06041779, -0.34909745,
  0.61783824, 0.125769, -0.04094521, -0.99122586, 0.63805416, 0.371575, 0.00314754, 0.03440824,
  1.29072533, -0.06067807, 0.18737385, 1.21813844, 5.00884263, 7.70111672)
fit12 &lt;- STVAR(data=gdpdef, p=1, M=2, params=params12, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student")
fit12

## Test whether the location parameter equals 1:

# Same as the original model but with the location parameter constrained to 1
# (parameter values were obtained by maximum likelihood estimation; fitSTVAR
# is not used here because the estimation is computationally demanding).
params12w &lt;- c(0.6592583, 0.16162866, 1.7811393, 0.38876396, 0.35499367, 0.0576433,
 -0.43570508, 0.57337706, 0.16449607, -0.01910167, -0.70747014, 0.75386158, 0.3612087,
  0.00241419, 0.03202824, 1.07459924, -0.03432236, 0.14982445, 6.22717097, 8.18575651)
fit12w &lt;- STVAR(data=gdpdef, p=1, M=2, params=params12w, weight_function="logistic",
 weightfun_pars=c(2, 1), cond_dist="Student",
 weight_constraints=list(R=matrix(c(0, 1), nrow=2), r=c(1, 0)))

# Test the null hypothesis of the location parameter equal 1:
LR_test(fit12, fit12w)

## Test whether the means and AR matrices are identical across the regimes:

# Same as the original model but with the mean and AR matrices constrained identical
# across the regimes (parameter values were obtained by maximum likelihood estimation;
# fitSTVAR is not used here because the estimation is computationally demanding).
params12cm &lt;- c(0.76892423, 0.67128089, 0.30824474, 0.03530802, -0.11498402, 0.85942541,
 0.39106754, 0.0049437, 0.03897287, 1.44457723, -0.05939876, 0.20885008, 1.23568782,
 6.42128475, 7.28733557)
fit12cm &lt;- STVAR(data=gdpdef, p=1, M=2, params=params12cm, weight_function="logistic",
 weightfun_pars=c(2, 1), parametrization="mean", cond_dist="Student",
 mean_constraints=list(1:2), AR_constraints=rbind(diag(4), diag(4)))

# Test the null hypothesis of the means and AR matrices being identical across the regimes:
LR_test(fit12, fit12cm)
</code></pre>

<hr>
<h2 id='mat_power'>Compute the j:th power of a square matrix A</h2><span id='topic+mat_power'></span>

<h3>Description</h3>

<p><code>mat_power</code> computes the j:th power of a square matrix A using
exponentiation by squaring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_power(A, j)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mat_power_+3A_a">A</code></td>
<td>
<p>A square numeric matrix.</p>
</td></tr>
<tr><td><code id="mat_power_+3A_j">j</code></td>
<td>
<p>A natural number representing the power to which the matrix will be raised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix which is A raised to the power j.
</p>

<hr>
<h2 id='n_params'>Calculate the number of (freely estimaed) parameters in the model</h2><span id='topic+n_params'></span>

<h3>Description</h3>

<p><code>n_params</code> calculates the number of (freely estimaed) parameters in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_params(
  p,
  M,
  d,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_params_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="n_params_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="n_params_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="n_params_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="n_params_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="n_params_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="n_params_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="n_params_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="n_params_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="n_params_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="n_params_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the number of parameters in the parameter vector of the specified model.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='order_B'>Reorder columns of a square matrix so that the first nonzero elements are
in decreasing order</h2><span id='topic+order_B'></span>

<h3>Description</h3>

<p><code>order_B</code> takes a square matrix <code>B</code> as input and reorders its columns
so that the diagonal entries of <code>B</code> are in decreasing order. The function
is designed to be computationally efficient and ensures that the input is a square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_B(B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_B_+3A_b">B</code></td>
<td>
<p>A square numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix <code>B</code> with columns reordered so that its
diagonal entries are in a decreasing order.
</p>

<hr>
<h2 id='pick_allA'>Pick all coefficient matrices</h2><span id='topic+pick_allA'></span>

<h3>Description</h3>

<p><code>pick_allA</code> picks all coefficient matrices <code class="reqn">A_{m,i} (i=1,..,p, m=1,..,M)</code>
from the given parameter vector so that they are arranged in a 4D array with the fourth dimension
indicating each regime and third dimension indicating each lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_allA(p, M, d, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_allA_+3A_p">p</code></td>
<td>
<p>the autoregressive order of the model</p>
</td></tr>
<tr><td><code id="pick_allA_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="pick_allA_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="pick_allA_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime. If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean
<code class="reqn">\mu_{m}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns a 4D array containing the coefficient matrices of the all components. Coefficient matrix
<code class="reqn">A_{m,i}</code> can be obtained by choosing <code>[, , i, m]</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='pick_Am'>Pick coefficient matrices</h2><span id='topic+pick_Am'></span>

<h3>Description</h3>

<p><code>pick_Am</code> picks the coefficient matrices <code class="reqn">A_{m,i} (i=1,..,p)</code>
from the given parameter vector for a given regime, so that they are arranged in
a 3D array with the third dimension indicating each lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_Am(p, M, d, params, m, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_Am_+3A_p">p</code></td>
<td>
<p>the autoregressive order of the model</p>
</td></tr>
<tr><td><code id="pick_Am_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="pick_Am_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="pick_Am_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime. If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean
<code class="reqn">\mu_{m}</code>.</p>
</td></tr>
<tr><td><code id="pick_Am_+3A_m">m</code></td>
<td>
<p>which regime?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns a 3D array containing the coefficient matrices of the given regime.
The coefficient matrix <code class="reqn">A_{m,i}</code> can be obtained by choosing <code>[, , i]</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='pick_Ami'>Pick coefficient matrix</h2><span id='topic+pick_Ami'></span>

<h3>Description</h3>

<p><code>pick_Ami</code> picks the coefficient matrix <code class="reqn">A_{m,i}</code> from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_Ami(p, M, d, params, m, i, unvec = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_Ami_+3A_p">p</code></td>
<td>
<p>the autoregressive order of the model</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime. If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean
<code class="reqn">\mu_{m}</code>.</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_m">m</code></td>
<td>
<p>which regime?</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_i">i</code></td>
<td>
<p>which lag in <code class="reqn">1,...,p</code>?</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_unvec">unvec</code></td>
<td>
<p>if <code>FALSE</code> then vectorized version of <code class="reqn">A_{m,i}</code> will be returned instead of matrix.
Default if <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns the i:th lag coefficient matrix of m:th regime, <code class="reqn">A_{m,i}</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='pick_distpars'>Pick distribution parameters</h2><span id='topic+pick_distpars'></span>

<h3>Description</h3>

<p><code>pick_distpars</code> picks all the distribution parameters from
the parameter vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_distpars(
  d,
  params,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_distpars_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="pick_distpars_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime. If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean
<code class="reqn">\mu_{m}</code>.</p>
</td></tr>
<tr><td><code id="pick_distpars_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns...
</p>

<dl>
<dt>If <code>cond_dist == "Gaussian"</code>:</dt><dd><p>a numeric vector of length zero.</p>
</dd>
<dt>If <code>cond_dist == "Student"</code>:</dt><dd><p>the degrees of freedom parameter.</p>
</dd>
<dt>If <code>cond_dist == "ind_Student"</code>:</dt><dd><p>a numeric vector of length <code class="reqn">d</code> containing the degrees of freedom parameters.</p>
</dd>
<dt>If <code>cond_dist == "ind_skewed_t"</code>:</dt><dd><p>a numeric vector <code class="reqn">(\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> of length <code class="reqn">2d</code>
containing the degrees of freedom and skewness parameters.</p>
</dd>
</dl>


<hr>
<h2 id='pick_lambdas'>Pick the structural parameter eigenvalues 'lambdas'</h2><span id='topic+pick_lambdas'></span>

<h3>Description</h3>

<p><code>pick_lambdas</code> picks the structural parameters eigenvalue 'lambdas' from the parameter vector
of a structural model identified by heteroskedasticity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_lambdas(
  p,
  M,
  d,
  params,
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_lambdas_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="pick_lambdas_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="pick_lambdas_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="pick_lambdas_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Constrained parameter vectors are not supported. Not even constraints in <code class="reqn">W</code>!
</p>


<h3>Value</h3>

<p>Returns the length <code>(d*(M - 1))</code> vector <code class="reqn">(\lambda_{2},...,\lambda_{M})</code>
(see the argument <code>params</code>) for structural models identified by heteroskedasticity,
<code>numeric(0)</code> if <code class="reqn">M=1</code>, and <code>NULL</code> for other models.
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H., Netšunajev A. 2017. Structural vector autoregressions with smooth transition in variances.
<em>Journal of Economic Dynamics &amp; Control</em>, <strong>84</strong>, 43-57.
</p>
</li></ul>


<hr>
<h2 id='pick_Omegas'>Pick covariance matrices</h2><span id='topic+pick_Omegas'></span>

<h3>Description</h3>

<p><code>pick_Omegas</code> picks the covariance matrices <code class="reqn">\Omega_{m}</code> or impact matrices <code class="reqn">B_m</code>
from the given parameter vector so that they are arranged in a 3D array with the third dimension indicating
each regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_Omegas(
  p,
  M,
  d,
  params,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_Omegas_+3A_p">p</code></td>
<td>
<p>the autoregressive order of the model</p>
</td></tr>
<tr><td><code id="pick_Omegas_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="pick_Omegas_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="pick_Omegas_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime. If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean
<code class="reqn">\mu_{m}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constrained parameter vectors are not supported.
</p>


<h3>Value</h3>

<p>Returns a 3D array containing...
</p>

<dl>
<dt>If <code>identification == "non-Gaussianity"</code> or <code>cond_dist %in% c("ind_Student", "ind_skewed_t")</code>:</dt><dd><p>the impact
matrices of the regimes, <code class="reqn">B_m</code> in <code>[, , m]</code>.</p>
</dd>
<dt>If otherwise:</dt><dd><p>the covariance matrices of the given model, <code class="reqn">\Omega_m</code> in <code>[, , m]</code>.</p>
</dd>
</dl>



<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='pick_phi0'>Pick <code class="reqn">\phi_{m,0}</code> or <code class="reqn">\mu_{m}</code>, m=1,..,M vectors</h2><span id='topic+pick_phi0'></span>

<h3>Description</h3>

<p><code>pick_phi0</code> picks the intercept or mean parameters from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_phi0(M, d, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_phi0_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="pick_phi0_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="pick_phi0_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime. If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean
<code class="reqn">\mu_{m}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">(d\times M)</code> matrix containing <code class="reqn">\phi_{m,0}</code> in the m:th column or
<code class="reqn">\mu_{m}</code> if the parameter vector is mean-parametrized, <code class="reqn">, m=1,..,M</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='pick_regime'>Pick regime parameters</h2><span id='topic+pick_regime'></span>

<h3>Description</h3>

<p><code>pick_regime</code> picks the regime parameters
<code class="reqn">(\phi_{m,0},vec(A_{m,1}),...,vec(A_{m,p}),vech(\Omega_m))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_regime(
  p,
  M,
  d,
  params,
  m,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_regime_+3A_p">p</code></td>
<td>
<p>the autoregressive order of the model</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime. If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean
<code class="reqn">\mu_{m}</code>.</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_m">m</code></td>
<td>
<p>which regime?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constrained models nor structural models are supported.
</p>


<h3>Value</h3>

<p>Returns the vector...
</p>

<dl>
<dt>If <code>identification == "non-Gaussianity"</code> or <code>cond_dist %in% c("ind_Student", "ind_skewed_t")</code>:</dt><dd>
<p><code class="reqn">(\phi_{m,0},vec(A_{m,1}),...,vec(A_{m,p}),vec(B_m))</code>.</p>
</dd>
<dt>If otherwise:</dt><dd><p><code class="reqn">(\phi_{m,0},vec(A_{m,1}),...,vec(A_{m,p}),vech(\Omega_m))</code>.</p>
</dd>
</dl>

<p>Note that neither weight parameters or distribution parameters are picked.
</p>

<hr>
<h2 id='pick_W'>Pick the structural parameter matrix W</h2><span id='topic+pick_W'></span>

<h3>Description</h3>

<p><code>pick_W</code> picks the structural parameter matrix W from the parameter vector
of a structural model identified by heteroskedasticity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_W(
  p,
  M,
  d,
  params,
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_W_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="pick_W_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="pick_W_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="pick_W_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Constrained parameter vectors are not supported. Not even constraints in <code class="reqn">W</code>!
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">(d x d)</code> matrix <code class="reqn">W</code> for structural models identified by heteroskedasticity
and <code>NULL</code> for other models.
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H., Netšunajev A. 2017. Structural vector autoregressions with smooth transition in variances.
<em>Journal of Economic Dynamics &amp; Control</em>, <strong>84</strong>, 43-57.
</p>
</li></ul>


<hr>
<h2 id='pick_weightpars'>Pick transition weight parameters</h2><span id='topic+pick_weightpars'></span>

<h3>Description</h3>

<p><code>pick_weightpars</code> picks the transition weight parameters from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_weightpars(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_weightpars_+3A_p">p</code></td>
<td>
<p>the autoregressive order of the model</p>
</td></tr>
<tr><td><code id="pick_weightpars_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="pick_weightpars_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="pick_weightpars_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime. If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean
<code class="reqn">\mu_{m}</code>.</p>
</td></tr>
<tr><td><code id="pick_weightpars_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="pick_weightpars_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_weightpars_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>If <code>weight_function = "relative_dens"</code>:</dt><dd><p>Returns a length <code class="reqn">M</code> vector containing the transition weight
parameters <code class="reqn">\alpha_{m}, m=1,...,M</code>, including the non-parametrized <code class="reqn">\alpha_{M}</code>.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p>Returns a length two vector <code class="reqn">(c,\gamma)</code>, where
<code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>If <code>weight_function = "mlogit"</code>:</dt><dd><p>Returns a length <code class="reqn">(M-1)k</code> vector <code class="reqn">(\gamma_1,...,\gamma_M)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> (<code class="reqn">\gamma_M=0</code>) contains the mlogit-regression
coefficients of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in
<code class="reqn">J\subset\lbrace 1,...,d\rbrace</code>, and with <code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included,
<code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{j,t-1},...,y_{j,t-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p>Returns a length two vector <code class="reqn">(c,\gamma)</code>, where
<code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p>Returns a length <code class="reqn">M-1</code> vector <code class="reqn">(r_1,...,r_{M-1})</code>, where
<code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Returns <code>numeric(0)</code>.</p>
</dd>
</dl>



<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='plot_struct_shocks'>Plot structural shock time series of a STVAR model</h2><span id='topic+plot_struct_shocks'></span>

<h3>Description</h3>

<p><code>plot_struct_shocks</code> plots structural shock time series of a structural STVAR model.
For reduced form models (not identified by non-Gaussianity), recursive identification is assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_struct_shocks(stvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_struct_shocks_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot the time series of the structural shocks of a structural STVAR model.
</p>


<h3>Value</h3>

<p>No return value, called for its side effect of plotting the structural shock time series.
</p>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation.
<em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>International Economic Review</em>, <strong>35</strong>:3, 407-414.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+fitSSTVAR">fitSSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gaussian STVAR p=1, M=2 model, with weighted relative stationary densities
# of the regimes as the transition weight function:
theta_122relg &lt;- c(0.734054, 0.225598, 0.705744, 0.187897, 0.259626, -0.000863,
  -0.3124, 0.505251, 0.298483, 0.030096, -0.176925, 0.838898, 0.310863, 0.007512,
  0.018244, 0.949533, -0.016941, 0.121403, 0.573269)
mod122 &lt;- STVAR(data=gdpdef, p=1, M=2, params=theta_122relg)

# Plot the times series structural shocks assuming recursive identification:
plot_struct_shocks(mod122)
</code></pre>

<hr>
<h2 id='plot.stvarpred'>Predict method for class 'stvar' objects</h2><span id='topic+plot.stvarpred'></span><span id='topic+predict.stvar'></span><span id='topic+print.stvarpred'></span>

<h3>Description</h3>

<p><code>predict.stvar</code> is a predict method for class <code>'stvar'</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stvarpred'
plot(x, ..., nt, trans_weights = TRUE)

## S3 method for class 'stvar'
predict(
  object,
  ...,
  nsteps,
  nsim = 1000,
  pi = c(0.95, 0.8),
  pred_type = c("mean", "median"),
  exo_weights = NULL
)

## S3 method for class 'stvarpred'
print(x, ..., digits = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.stvarpred_+3A_x">x</code></td>
<td>
<p>object of class <code>'stvarpred'</code></p>
</td></tr>
<tr><td><code id="plot.stvarpred_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="plot.stvarpred_+3A_nt">nt</code></td>
<td>
<p>a positive integer specifying the number of observations to be plotted
along with the forecast.</p>
</td></tr>
<tr><td><code id="plot.stvarpred_+3A_trans_weights">trans_weights</code></td>
<td>
<p>should forecasts for transition weights be plotted?</p>
</td></tr>
<tr><td><code id="plot.stvarpred_+3A_object">object</code></td>
<td>
<p>an object of class <code>'stvar'</code>.</p>
</td></tr>
<tr><td><code id="plot.stvarpred_+3A_nsteps">nsteps</code></td>
<td>
<p>how many steps ahead should be predicted?</p>
</td></tr>
<tr><td><code id="plot.stvarpred_+3A_nsim">nsim</code></td>
<td>
<p>to how many independent simulations should the forecast be based on?</p>
</td></tr>
<tr><td><code id="plot.stvarpred_+3A_pi">pi</code></td>
<td>
<p>a numeric vector specifying the confidence levels of the prediction intervals.</p>
</td></tr>
<tr><td><code id="plot.stvarpred_+3A_pred_type">pred_type</code></td>
<td>
<p>should the pointforecast be based on sample &quot;median&quot; or &quot;mean&quot;?</p>
</td></tr>
<tr><td><code id="plot.stvarpred_+3A_exo_weights">exo_weights</code></td>
<td>
<p>if <code>weight_function="exogenous"</code>, provide a size <code class="reqn">(nsteps x M)</code> matrix of exogenous
transition weights for the regimes: <code>[step, m]</code> for <code class="reqn">step</code> steps ahead and regime <code class="reqn">m</code> weight. Ignored
if <code>weight_function!="exogenous"</code>.</p>
</td></tr>
<tr><td><code id="plot.stvarpred_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forecasts are computed by simulating multiple sample paths of the future observations and
using the sample medians or means as point forecasts and empirical quantiles as prediction intervals.
</p>


<h3>Value</h3>

<p>Returns a class '<code>stvarpred</code>' object containing, among the specifications,...
</p>

<dl>
<dt>$pred</dt><dd><p>Point forecasts</p>
</dd>
<dt>$pred_ints</dt><dd><p>Prediction intervals, as <code>[, , d]</code>.</p>
</dd>
<dt>$trans_pred</dt><dd><p>Point forecasts for the transition weights</p>
</dd>
<dt>$trans_pred_ints</dt><dd><p>Individual prediction intervals for transition weights, as <code>[, , m]</code>, m=1,..,M.</p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(stvarpred)</code>: predict method
</p>
</li>
<li> <p><code>print(stvarpred)</code>: print method
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation.
<em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>International Economic Review</em>, <strong>35</strong>:3, 407-414.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+simulate.stvar">simulate.stvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # p=2, M=2, d=2, Gaussian relative dens weights
 theta_222relg &lt;- c(0.356914, 0.107436, 0.356386, 0.08633, 0.13996, 0.035172,
   -0.164575, 0.386816, 0.451675, 0.013086, 0.227882, 0.336084, 0.239257, 0.024173,
   -0.021209, 0.707502, 0.063322, 0.027287, 0.009182, 0.197066, 0.205831, 0.005157,
   0.025877, 1.092094, -0.009327, 0.116449, 0.592446)
 mod222relg &lt;- STVAR(data=gdpdef, p=2, M=2, d=2, params=theta_222relg,
   weight_function="relative_dens")

 # Predict 10 steps ahead, point forecast based on the conditional
 # mean and 90% prediction intervals; prediction based on 100 sample paths:
 pred1 &lt;- predict(mod222relg, nsteps=10, nsim=100, pi=0.9, pred_type="mean")
 pred1
 plot(pred1)

 # Predict 7 steps ahead, point forecast based on median and  90%, 80%,
 # and 70% prediction intervals; prediction based on 80 sample paths:
 pred2 &lt;- predict(mod222relg, nsteps=7, nsim=80, pi=c(0.9, 0.8, 0.7),
  pred_type="median")
 pred2
 plot(pred2)
</code></pre>

<hr>
<h2 id='Portmanteau_test'>Perform adjusted Portmanteau test for a STVAR model</h2><span id='topic+Portmanteau_test'></span>

<h3>Description</h3>

<p><code>Portmanteau_test</code> performs adjusted Portmanteau test for remaining autocorrelation
(or heteroskedasticity) in the residuals of a STVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Portmanteau_test(stvar, nlags = 20, which_test = c("autocorr", "het.sked"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Portmanteau_test_+3A_stvar">stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code> generated by <code>fitSTVAR</code> or <code>STVAR</code>.</p>
</td></tr>
<tr><td><code id="Portmanteau_test_+3A_nlags">nlags</code></td>
<td>
<p>a strictly positive integer specifying the number of lags to be tested.</p>
</td></tr>
<tr><td><code id="Portmanteau_test_+3A_which_test">which_test</code></td>
<td>
<p>should test for remaining autocorrelation or heteroskedasticity be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented adjusted Portmanteau test is based on Lütkepohl (2005), Section 4.4.3.
When testing for remaining heteroskedasticity, the Portmanteau test is applied to squared
standardized residuals that are centered to have zero mean. Note that the validity of the
heteroskedasticity test requires that the residuals are not autocorrelated.
</p>


<h3>Value</h3>

<p>A list with class &quot;hypotest&quot; containing the test results and arguments used to calculate the test.
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Rao_test">Rao_test</a></code>, <code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>,
<code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+profile_logliks">profile_logliks</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian STVAR p=2, M=2, model with weighted relative stationary densities
# of the regimes as the transition weight function:
theta_222relg &lt;- c(0.357, 0.107, 0.356, 0.086, 0.14, 0.035, -0.165, 0.387, 0.452,
 0.013, 0.228, 0.336, 0.239, 0.024, -0.021, 0.708, 0.063, 0.027, 0.009, 0.197,
 0.206, 0.005, 0.026, 1.092, -0.009, 0.116, 0.592)
mod222relg &lt;- STVAR(data=gdpdef, p=2, M=2, d=2, params=theta_222relg,
 weight_function="relative_dens")

# Test for remaining autocorrelation taking into account the first 20 lags:
Portmanteau_test(mod222relg, nlags=20)

# Test for remaining heteroskedasticity taking into account the first 20 lags:
Portmanteau_test(mod222relg, nlags=20, which_test="het.sked")

# Two-regime Student's t Threhold VAR p=3 model with the first lag of the second
# variable as the switching variable:
theta_322thres &lt;- c(0.527, 0.039, 1.922, 0.154, 0.284, 0.053, 0.033, 0.453, 0.291,
 0.024, -0.108, 0.153, -0.108, 0.003, -0.128, 0.219, 0.195, -0.03, -0.893, 0.686,
 0.047, 0.016, 0.524, 0.068, -0.025, 0.044, -0.435, 0.119, 0.359, 0.002, 0.038,
 1.252, -0.041, 0.151, 1.196, 12.312)
mod322thres &lt;- STVAR(data=gdpdef, p=3, M=2, d=2, params=theta_322thres,
 weight_function="threshold", weightfun_pars=c(2, 1), cond_dist="Student")

# Test for remaining autocorrelation taking into account the first 25 lags:
Portmanteau_test(mod322thres, nlags=25)

# Test for remaining heteroskedasticity taking into account the first 25 lags:
Portmanteau_test(mod322thres, nlags=25, which_test="het.sked")
</code></pre>

<hr>
<h2 id='print.hypotest'>Print method for the class hypotest</h2><span id='topic+print.hypotest'></span>

<h3>Description</h3>

<p><code>print.hypotest</code> is the print method for the class hypotest
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hypotest'
print(x, ..., digits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.hypotest_+3A_x">x</code></td>
<td>
<p>object of class <code>'hypotest'</code> generated by the function <code>Wald_test</code>, <code>LR_test</code>,
<code>Rao_test</code>, or <code>Portmenteau_test</code>.</p>
</td></tr>
<tr><td><code id="print.hypotest_+3A_...">...</code></td>
<td>
<p>currently not in use.</p>
</td></tr>
<tr><td><code id="print.hypotest_+3A_digits">digits</code></td>
<td>
<p>how many significant digits to print?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input object <code>x</code> invisibly.
</p>

<hr>
<h2 id='print.stvarsum'>Summary print method from objects of class 'stvarsum'</h2><span id='topic+print.stvarsum'></span>

<h3>Description</h3>

<p><code>print.stvarsum</code> is a print method for object <code>'stvarsum'</code> generated
by <code>summary.stvar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stvarsum'
print(x, ..., digits, standard_error_print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.stvarsum_+3A_x">x</code></td>
<td>
<p>object of class 'stvarsum' generated by <code>summary.stvar</code>.</p>
</td></tr>
<tr><td><code id="print.stvarsum_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="print.stvarsum_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>
<tr><td><code id="print.stvarsum_+3A_standard_error_print">standard_error_print</code></td>
<td>
<p>if set to <code>TRUE</code>, instead of printing the estimates,
prints the approximate standard errors using square roots of the diagonal of inverse
of the observed information matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input object <code>x</code> invisibly.
</p>

<hr>
<h2 id='profile_logliks'>Plot profile log-likelihood functions about the estimates</h2><span id='topic+profile_logliks'></span>

<h3>Description</h3>

<p><code>profile_logliks</code> plots profile log-likelihood functions about the estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile_logliks(
  stvar,
  which_pars,
  scale = 0.1,
  nrows,
  ncols,
  precision = 50,
  stab_tol = 0.001,
  posdef_tol = 1e-08,
  distpar_tol = 1e-08,
  weightpar_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profile_logliks_+3A_stvar">stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code>, created by, e.g., <code>fitSTVAR</code> or <code>fitSSTVAR</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_which_pars">which_pars</code></td>
<td>
<p>the profile log-likelihood function of which parameters should be plotted? An integer
vector specifying the positions of the parameters in the parameter vector. The parameter vector has the
form...</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_scale">scale</code></td>
<td>
<p>a numeric scalar specifying the interval plotted for each estimate:
the estimate plus-minus <code>abs(scale*estimate)</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_nrows">nrows</code></td>
<td>
<p>how many rows should be in the plot-matrix? The default is <code>max(ceiling(log2(length(which_pars)) - 1), 1)</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_ncols">ncols</code></td>
<td>
<p>how many columns should be in the plot-matrix? The default is <code>ceiling(length(which_pars)/nrows)</code>.
Note that <code>nrows*ncols</code> should not be smaller than the length of <code>which_pars</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_precision">precision</code></td>
<td>
<p>at how many points should each profile log-likelihood function be evaluated at?</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_stab_tol">stab_tol</code></td>
<td>
<p>numerical tolerance for stability of condition of the regimes: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the parameter is considered to be outside the parameter space.
Note that if tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the parameter is considered
to be outside the parameter space. Note that if the tolerance is too small, numerical evaluation of the
log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_distpar_tol">distpar_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if the degrees of
freedom parameters is not larger than <code>2 + distpar_tol</code> (applies only if <code>cond_dist="Student"</code>).</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_weightpar_tol">weightpar_tol</code></td>
<td>
<p>numerical tolerance for weight parameters being in the parameter space. Values closer to
to the border of the parameter space than this are considered to be &quot;outside&quot; the parameter space.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the number of parameters is large, it might be better to plot a smaller number of profile
log-likelihood functions at a time using the argument <code>which_pars</code>.
</p>
<p>The red vertical line points the estimate.
</p>


<h3>Value</h3>

<p>Only plots to a graphical device and doesn't return anything.
</p>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation.
<em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>International Economic Review</em>, <strong>35</strong>:3, 407-414.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+get_foc">get_foc</a></code>, <code><a href="#topic+get_soc">get_soc</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Threshold STVAR with p=1, M=2, the first lag of the second variable as switching variable:
pars &lt;- c(0.5231, 0.1015, 1.9471, 0.3253, 0.3476, 0.0649, -0.035, 0.7513, 0.1651,
 -0.029, -0.7947, 0.7925, 0.4233, 5e-04, 0.0439, 1.2332, -0.0402, 0.1481, 1.2036)
mod12thres &lt;- STVAR(data=gdpdef, p=1, M=2, params=pars, weight_function="threshold",
  weightfun_pars=c(2, 1))

# Plot the profile log-likelihood functions of all parameters:
profile_logliks(mod12thres, precision=50) # Plots fast with precision=50

# Plot only the profile log-likelihood function of the threshold parameter
# (which is the last parameter in the parameter vector):
profile_logliks(mod12thres, which_pars=length(pars), precision=100)

# Plot only the profile log-likelihood functions of the intercept parameters
# (which are the first four parameters in the parameter vector, as d=2 and M=2):
profile_logliks(mod12thres, which_pars=1:4, precision=100)
</code></pre>

<hr>
<h2 id='random_coefmats'>Create random VAR model <code class="reqn">(dxd)</code> coefficient matrices <code class="reqn">A</code>.</h2><span id='topic+random_coefmats'></span>

<h3>Description</h3>

<p><code>random_coefmats</code> generates random VAR model coefficient matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_coefmats(d, how_many, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_coefmats_+3A_how_many">how_many</code></td>
<td>
<p>how many <code class="reqn">(dxd)</code> coefficient matrices <code class="reqn">A</code> should be drawn?</p>
</td></tr>
<tr><td><code id="random_coefmats_+3A_scale">scale</code></td>
<td>
<p>non-diagonal elements will be drawn from mean zero normal distribution
with <code>sd=0.3/scale</code> and diagonal elements from one with <code>sd=0.6/scale</code>.
Larger scale will hence more likely result stationary coefficient matrices, but
will explore smaller area of the parameter space. Can be for example
<code>1 + log(2*mean(c((p-0.2)^(1.25), d)))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code class="reqn">((how_many*d^2)x1)</code> vector containing vectorized coefficient
matrices <code class="reqn">(vec(A_{1}),...,vec(A_{how_many}))</code>. Note that if <code>how_many==p</code>,
then the returned vector equals <strong><code class="reqn">\phi_{m}</code></strong>.
</p>

<hr>
<h2 id='random_coefmats2'>Create random stationary VAR model <code class="reqn">(dxd)</code> coefficient matrices <code class="reqn">A</code>.</h2><span id='topic+random_coefmats2'></span>

<h3>Description</h3>

<p><code>random_coefmats2</code> generates random VAR model coefficient matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_coefmats2(p, d, ar_scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_coefmats2_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="random_coefmats2_+3A_ar_scale">ar_scale</code></td>
<td>
<p>a positive real number. Larger values will typically result larger AR coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficient matrices are generated using the algorithm proposed by Ansley
and Kohn (1986) which forces stationarity. It's not clear in detail how <code>ar_scale</code>
affects the coefficient matrices. Read the cited article by Ansley and Kohn (1986) and
the source code for more information.
</p>
<p>Note that when using large <code>ar_scale</code> with large <code>p</code> or <code>d</code>, numerical
inaccuracies caused by the imprecision of the float-point presentation may result in errors
or nonstationary AR-matrices. Using smaller <code>ar_scale</code> facilitates the usage of larger
<code>p</code> or <code>d</code>.
</p>


<h3>Value</h3>

<p>Returns <code class="reqn">((pd^2)x1)</code> vector containing stationary vectorized coefficient
matrices <code class="reqn">(vec(A_{1}),...,vec(A_{p})</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Ansley C.F., Kohn R. 1986. A note on reparameterizing a vector autoregressive
moving average model to enforce stationarity.
<em>Journal of statistical computation and simulation</em>, <strong>24</strong>:2, 99-106.
</p>
</li></ul>


<hr>
<h2 id='random_covmat'>Create random VAR model error term covariance matrix</h2><span id='topic+random_covmat'></span>

<h3>Description</h3>

<p><code>random_covmat</code> generates random VAR model <code class="reqn">(dxd)</code> error term covariance matrix <code class="reqn">\Omega</code>
from (scaled) Wishart distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_covmat(d, omega_scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_covmat_+3A_omega_scale">omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
<code>cond_dist == "ind_Student"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">(d(d+1)/2x1)</code> vector containing vech-vectorized covariance matrix
<code class="reqn">\Omega</code>.
</p>

<hr>
<h2 id='random_distpars'>Create random distribution parameter values</h2><span id='topic+random_distpars'></span>

<h3>Description</h3>

<p><code>random_distpars</code> generates random distribution parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_distpars(d, cond_dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_distpars_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector ...
</p>

<dl>
<dt>If <code>cond_dist == "Gaussian"</code>:</dt><dd><p>of length zero.</p>
</dd>
<dt>If <code>cond_dist == "Student"</code>:</dt><dd><p>of length one containing a df param strictly larger than two.</p>
</dd>
<dt>If <code>cond_dist == "ind_Student"</code>:</dt><dd><p>of length d containing df params strictly larger than two.</p>
</dd>
<dt>If <code>cond_dist == "ind_skewed_t"</code>:</dt><dd><p>of length 2d containing df params strictly larger than two in the first d
elements and skewness params strictly between -1 and 1 in the rest d elements.</p>
</dd>
</dl>


<hr>
<h2 id='random_impactmat'>Create random VAR model impact matrix</h2><span id='topic+random_impactmat'></span>

<h3>Description</h3>

<p><code>random_impactmat</code> generates random VAR model <code class="reqn">(dxd)</code> impact matrix <code class="reqn">B</code>
with its elements drawn from specific normal distributions (see the source code). If not the first
regime, will create the matrix <code class="reqn">B_m*</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_impactmat(d, B_scale, is_regime1 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_impactmat_+3A_b_scale">B_scale</code></td>
<td>
<p>a size <code class="reqn">(d \times 1)</code> strictly positive vector specifying the mean and variability of the
random impact matrices in random mutations. In Regime 1, the mean of the error term covariance matrix
implied by the random impact matrix will be <code>0.95*diag(B_scale)</code> and in the rest of the regimes <code>diag(B_scale)</code>,
whereas the variability increases with <code>B_scale</code>.
Default in <code>GAfit</code> is <code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>.
This argument is ignored if <code>cond_dist != "ind_Student"</code>.</p>
</td></tr>
<tr><td><code id="random_impactmat_+3A_is_regime1">is_regime1</code></td>
<td>
<p>is the impact matrix for Regime 1? Regime 1 impact matrix is constrained so the elements
in its first row are in a decreasing ordering and the diagonal elements are strictly positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the impact matrix is not for Regime 1, will create the matrix <code class="reqn">B_m*</code>, which is related
to the impact matrix <code class="reqn">B_m</code> of Regime m as <code class="reqn">B_m* = B_m - B_1</code>.
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">(d^2 \times 1)</code> vector containing the vectorized impact matrix <code class="reqn">B</code>.
</p>

<hr>
<h2 id='random_ind'>Create random mean parametrized parameter vector</h2><span id='topic+random_ind'></span>

<h3>Description</h3>

<p><code>random_ind</code> generates random mean parametrized parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_ind(
  p,
  M,
  d,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  force_stability = is.null(AR_constraints),
  mu_scale,
  mu_scale2,
  omega_scale,
  B_scale,
  weight_scale,
  ar_scale = 1,
  ar_scale2 = 1,
  fixed_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_ind_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="random_ind_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="random_ind_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="random_ind_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="random_ind_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="random_ind_+3A_force_stability">force_stability</code></td>
<td>
<p>Should the algorithm proposed by Ansley and Kohn (1986) be used to generate
AR matrices that always satisfy the stability condition? Not supported if AR constraints are
employed.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> vector defining <strong>means</strong> of the normal distributions from which each
mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations. Default is <code>colMeans(data)</code>. Note that
mean-parametrization is always used for optimization in <code>GAfit</code> - even when <code>parametrization=="intercept"</code>.
However, input (in <code>initpop</code>) and output (return value) parameter vectors can be intercept-parametrized.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_mu_scale2">mu_scale2</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector defining <strong>standard deviations</strong> of the normal
distributions from which each mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations.
Default is <code>vapply(1:d, function(i1) sd(data[,i1]), numeric(1))</code>.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_omega_scale">omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
<code>cond_dist == "ind_Student"</code>.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_b_scale">B_scale</code></td>
<td>
<p>a size <code class="reqn">(d \times 1)</code> strictly positive vector specifying the mean and variability of the
random impact matrices in random mutations. In Regime 1, the mean of the error term covariance matrix
implied by the random impact matrix will be <code>0.95*diag(B_scale)</code> and in the rest of the regimes <code>diag(B_scale)</code>,
whereas the variability increases with <code>B_scale</code>.
Default in <code>GAfit</code> is <code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>.
This argument is ignored if <code>cond_dist != "ind_Student"</code>.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_weight_scale">weight_scale</code></td>
<td>
<p>For...
</p>

<dl>
<dt><code>weight_function %in% c("relative_dens", "exogenous")</code>:</dt><dd><p>not used.</p>
</dd>
<dt><code>weight_function %in% c("logistic", "exponential")</code>:</dt><dd><p>length three vector with the mean (in the first element)
and standard deviation (in the second element) of the normal distribution the location parameter is drawn from
in random mutations. The third element is the standard deviation of the normal distribution from whose absolute value
the location parameter is drawn from.</p>
</dd>
<dt><code>weight_function == "mlogit"</code>:</dt><dd><p>length two vector with the mean (in the first element)
and standard deviation (in the second element) of the normal distribution the coefficients of the logit sub model's
constant terms are drawn from in random mutations. The third element is the standard deviation of the normal distribution
from which the non-constant regressors' coefficients are drawn from.</p>
</dd>
<dt><code>weight_function == "threshold"</code>:</dt><dd><p>a lenght two vector with the lower bound, in the first element
and the upper bound, in the second element, of the uniform distribution threshold parameters are drawn from
in random mutations.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="random_ind_+3A_ar_scale">ar_scale</code></td>
<td>
<p>a positive real number between zero and one adjusting how large AR parameter values are typically
proposed in construction of the initial population: larger value implies larger coefficients (in absolute value).
After construction of the initial population, a new scale is drawn from <code>(0, upper_ar_scale)</code> uniform
distribution in each iteration.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_ar_scale2">ar_scale2</code></td>
<td>
<p>a positive real number adjusting how large AR parameter values are typically proposed in some
random mutations (if AR constraints are employed, in all random mutations): larger value implies <strong>smaller</strong>
coefficients (in absolute value). <strong>Values larger than 1 can be used if the AR coefficients are expected to
be very small. If set smaller than 1, be careful as it might lead to failure in the creation of parameter candidates
that satisfy the stability condition.</strong></p>
</td></tr>
<tr><td><code id="random_ind_+3A_fixed_params">fixed_params</code></td>
<td>
<p>a vector containing fixed parameter values for intercept, autoregressive, and weight parameters
that should be fixed in the <strong>initial population</strong>. Should have the form:
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code>, where
</p>

<ul>
<li><p><code class="reqn">(\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li><p><code class="reqn">\alpha</code> vector of the weight parameters.
</p>
</li></ul>

<p>For models with...
</p>

<dl>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
</dl>

<p>Note that <code>fixed_params</code> should always be in the intercept parametrization (and <code>parametrization="intercept"</code> should always be used).
<strong>Passing this argument from fitSTVAR in does not do anything, as it is designed to be used with the three-phase estimation
procedure only. Also, this argument does not do anything if the initial population is specified in the argument initpop.</strong></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Structural models are not supported!
</p>


<h3>Value</h3>

<p>Returns random mean parametrized parameter vector that has the same form as the argument <code>params</code>
in the other functions, for instance, in the function <code>loglikelihood</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Ansley C.F., Kohn R. 1986. A note on reparameterizing a vector autoregressive
moving average model to enforce stationarity.
<em>Journal of statistical computation and simulation</em>, <strong>24</strong>:2, 99-106.
</p>
</li></ul>


<hr>
<h2 id='random_weightpars'>Create random transition weight parameter values</h2><span id='topic+random_weightpars'></span>

<h3>Description</h3>

<p><code>random_weightpars</code> generates random transition weight parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_weightpars(
  M,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  weight_scale
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_weightpars_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="random_weightpars_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="random_weightpars_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="random_weightpars_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="random_weightpars_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="random_weightpars_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="random_weightpars_+3A_weight_scale">weight_scale</code></td>
<td>
<p>For...
</p>

<dl>
<dt><code>weight_function %in% c("relative_dens", "exogenous")</code>:</dt><dd><p>not used.</p>
</dd>
<dt><code>weight_function %in% c("logistic", "exponential")</code>:</dt><dd><p>length three vector with the mean (in the first element)
and standard deviation (in the second element) of the normal distribution the location parameter is drawn from
in random mutations. The third element is the standard deviation of the normal distribution from whose absolute value
the location parameter is drawn from.</p>
</dd>
<dt><code>weight_function == "mlogit"</code>:</dt><dd><p>length two vector with the mean (in the first element)
and standard deviation (in the second element) of the normal distribution the coefficients of the logit sub model's
constant terms are drawn from in random mutations. The third element is the standard deviation of the normal distribution
from which the non-constant regressors' coefficients are drawn from.</p>
</dd>
<dt><code>weight_function == "threshold"</code>:</dt><dd><p>a lenght two vector with the lower bound, in the first element
and the upper bound, in the second element, of the uniform distribution threshold parameters are drawn from
in random mutations.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector ...
</p>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>a length <code>M-1</code> vector <code class="reqn">(\alpha_1,...,\alpha_{M-1})</code>.</p>
</dd>
<dt>If <code>weight_function == "logistic"</code>:</dt><dd><p>a length two vector <code class="reqn">(c,\gamma)</code>,
where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a length <code class="reqn">((M-1)k\times 1)</code> vector <code class="reqn">(\gamma_1,...,\gamma_{M-1})</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the mlogit-regression coefficients of the <code class="reqn">m</code>th
regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt>If <code>weight_function == "exponential"</code>:</dt><dd><p>a length two vector <code class="reqn">(c,\gamma)</code>,
where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>If <code>weight_function == "threshold"</code>:</dt><dd><p>a length <code class="reqn">M-1</code> vector <code class="reqn">(r_1,...,r_{M-1})</code>,
where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values in an increasing order.</p>
</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>of length zero.</p>
</dd>
</dl>


<hr>
<h2 id='Rao_test'>Perform Rao's score test for a STVAR model</h2><span id='topic+Rao_test'></span>

<h3>Description</h3>

<p><code>Rao_test</code> performs Rao's score test for a STVAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rao_test(stvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rao_test_+3A_stvar">stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code> generated by <code>fitSTVAR</code> or <code>STVAR</code>, containing
the model specified by the null hypothesis (i.e., <strong>the constrained model</strong>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests the constraints imposed in the model given in the argument <code>stvar</code>.
This implementation uses the outer product of gradients approximation in the test statistic.
</p>
<p><strong>The test is based on the assumption of the standard result of asymptotic normality!</strong>
</p>


<h3>Value</h3>

<p>A list with class &quot;hypotest&quot; containing the test results and arguments used to calculate the test.
</p>


<h3>References</h3>


<ul>
<li><p> Buse A. (1982). The Likelihood Ratio, Wald, and Lagrange Multiplier Tests: An Expository Note.
<em>The American Statistician</em>, 36(3a), 153-157.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>, <code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>,
<code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+Portmanteau_test">Portmanteau_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples that take approximately 10 seconds to run.

# Logistic Student's t STVAR with p=1, M=2, and the first lag of the second variable
# as the switching variable.

## Test whether the location parameter equal 1:

# The model imposing the constraint on the location parameter (parameter values
# were obtained by maximum likelihood estimation; fitSTVAR is not used here
# because the estimation is computationally demanding):
params12w &lt;- c(0.6592583, 0.16162866, 1.7811393, 0.38876396, 0.35499367, 0.0576433,
  -0.43570508, 0.57337706, 0.16449607, -0.01910167, -0.70747014, 0.75386158, 0.3612087,
  0.00241419, 0.03202824, 1.07459924, -0.03432236, 0.14982445, 6.22717097, 8.18575651)
fit12w &lt;- STVAR(data=gdpdef, p=1, M=2, params=params12w, weight_function="logistic",
 weightfun_pars=c(2, 1), cond_dist="Student",
 weight_constraints=list(R=matrix(c(0, 1), nrow=2), r=c(1, 0)))
fit12w

# Test the null hypothesis of the location parameter equal 1:
Rao_test(fit12w)

## Test whether the means and AR matrices are identical across the regimes:

# The model imposing the constraint on the location parameter (parameter values
# were obtained by maximum likelihood estimation; fitSTVAR is not used here
# because the estimation is computationally demanding):
params12cm &lt;- c(0.76892423, 0.67128089, 0.30824474, 0.03530802, -0.11498402, 0.85942541,
 0.39106754, 0.0049437, 0.03897287, 1.44457723, -0.05939876, 0.20885008, 1.23568782,
 6.42128475, 7.28733557)
fit12cm &lt;- STVAR(data=gdpdef, p=1, M=2, params=params12cm, weight_function="logistic",
 weightfun_pars=c(2, 1), parametrization="mean", cond_dist="Student",
 mean_constraints=list(1:2), AR_constraints=rbind(diag(4), diag(4)))

# Test the null hypothesis of the means and AR matrices being identical across the regimes:
Rao_test(fit12cm)

</code></pre>

<hr>
<h2 id='redecompose_Omegas'>In the decomposition of the covariance matrices (Muirhead, 1982, Theorem A9.9), change
the ordering of the covariance matrices.</h2><span id='topic+redecompose_Omegas'></span>

<h3>Description</h3>

<p><code>redecompose_Omegas</code> exchanges the order of the covariance matrices in
the decomposition of Muirhead (1982, Theorem A9.9) and returns the new decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redecompose_Omegas(M, d, W, lambdas, perm = 1:M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redecompose_Omegas_+3A_m">M</code></td>
<td>
<p>the number of regimes in the model</p>
</td></tr>
<tr><td><code id="redecompose_Omegas_+3A_d">d</code></td>
<td>
<p>the number of time series in the system</p>
</td></tr>
<tr><td><code id="redecompose_Omegas_+3A_w">W</code></td>
<td>
<p>a length <code>d^2</code> vector containing the vectorized W matrix.</p>
</td></tr>
<tr><td><code id="redecompose_Omegas_+3A_lambdas">lambdas</code></td>
<td>
<p>a length <code>d*(M-1)</code> vector of the form <strong><code class="reqn">\lambda_{2}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\lambda_{M}</code></strong>
where <strong><code class="reqn">\lambda_{m}</code></strong><code class="reqn">=(\lambda_{m1},...,\lambda_{md})</code></p>
</td></tr>
<tr><td><code id="redecompose_Omegas_+3A_perm">perm</code></td>
<td>
<p>a vector of length <code>M</code> giving the new order of the covariance matrices
(relative to the current order)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider the following decomposition of positive definite covariannce matrices:
<code class="reqn">\Omega_1 = WW'</code>, <code class="reqn">\Omega_m = W\Lambda_{m}W'</code>, <code class="reqn">m=2,..,M</code> where
<code class="reqn">\Lambda_{m} = diag(\lambda_{m1},...,\lambda_{md})</code> contains the strictly postive eigenvalues of
<code class="reqn">\Omega_m\Omega_1^{-1}</code> and the column of the invertible <code class="reqn">W</code> are the corresponding eigenvectors.
Note that this decomposition does not necessarily exists for <code class="reqn">M &gt; 2</code>.
</p>
<p>See Muirhead (1982), Theorem A9.9 for more details on the decomposition and the source code for more details on the
reparametrization.
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">d^2 + (M - 1)d \times 1</code> vector of the form <code>c(vec(new_W), new_lambdas)</code>
where the lambdas parameters are in the regimewise order (first regime 2, then 3, etc) and the
&quot;new W&quot; and &quot;new lambdas&quot; are constitute the new decomposition with the order of the covariance
matrices given by the argument <code>perm</code>. Notice that if the first element of <code>perm</code>
is one, the W matrix will be the same and the lambdas are just re-ordered.
</p>
<p><strong>Note that unparametrized zero elements ARE present in the returned W!</strong>
</p>


<h3>Warning</h3>

<p>No argument checks! Does not work with dimension <code class="reqn">d=1</code> or with only
one mixture component <code class="reqn">M=1</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Muirhead R.J. 1982. Aspects of Multivariate Statistical Theory, <em>Wiley</em>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create two (2x2) coviance matrices:
d &lt;- 2 # The dimension
M &lt;- 2 # The number of covariance matrices
Omega1 &lt;- matrix(c(2, 0.5, 0.5, 2), nrow=d)
Omega2 &lt;- matrix(c(1, -0.2, -0.2, 1), nrow=d)

# The decomposition with Omega1 as the first covariance matrix:
decomp1 &lt;- diag_Omegas(Omega1, Omega2)
W &lt;- matrix(decomp1[1:d^2], nrow=d, ncol=d) # Recover W
lambdas &lt;- decomp1[(d^2 + 1):length(decomp1)] # Recover lambdas
tcrossprod(W) # = Omega1
W%*%tcrossprod(diag(lambdas), W) # = Omega2

# Reorder the covariance matrices in the decomposition so that now
# the first covariance matrix is Omega2:
decomp2 &lt;- redecompose_Omegas(M=M, d=d, W=as.vector(W), lambdas=lambdas,
                              perm=2:1)
new_W &lt;- matrix(decomp2[1:d^2], nrow=d, ncol=d) # Recover W
new_lambdas &lt;- decomp2[(d^2 + 1):length(decomp2)] # Recover lambdas
tcrossprod(new_W) # = Omega2
new_W%*%tcrossprod(diag(new_lambdas), new_W) # = Omega1
</code></pre>

<hr>
<h2 id='reform_constrained_pars'>Reform constrained parameter vector into the &quot;standard&quot; form</h2><span id='topic+reform_constrained_pars'></span>

<h3>Description</h3>

<p><code>reform_constrained_pars</code> reforms constrained parameter vector
into the form that corresponds to unconstrained parameter vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reform_constrained_pars(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL,
  other_constraints = NULL,
  change_na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reform_constrained_pars_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_other_constraints">other_constraints</code></td>
<td>
<p>A list containing internally used additional type of constraints (see the options below).
</p>

<dl>
<dt>$fixed_lambdas (only if <code>identification="heteroskedasticity"</code>):</dt><dd><p>a length <code class="reqn">d(M-1)</code> numeric vector
(<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger
than zero specifying the fixed parameter values for the parameters <code class="reqn">\lambda_{mi}</code> should be constrained to.</p>
</dd>
<dt>$B1_constraints (only if <code>identification="non-Gaussianity"</code>):</dt><dd><p>set to the string &quot;fixed_sign_and_order&quot;
to impose the constraints that the elements of the first impact matrix <code class="reqn">B_1</code> are strictly positive and that they
are in a decreasing order.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_change_na">change_na</code></td>
<td>
<p>change NA parameter values of constrained models to -9.999?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns &quot;regular model&quot; parameter vector corresponding to the constraints.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='reform_data'>Reform data</h2><span id='topic+reform_data'></span>

<h3>Description</h3>

<p><code>reform_data</code> reforms the data into a form that is
easier to use when calculating log-likelihood values etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reform_data(data, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reform_data_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="reform_data_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes the observed data is <code class="reqn">y_{-p+1},...,y_0,y_1,...,y_{T}</code>.
</p>


<h3>Value</h3>

<p>Returns the data reformed into a <code class="reqn">((n_{obs}-p+1)\times dp)</code> matrix. The i:th row
of the matrix contains the vector <code class="reqn">(y_{i-1},...,y_{i-p})</code> <code class="reqn">(dp\times 1)</code>, where
<code class="reqn">y_{i}=(y_{1i},...,y_{di})</code> <code class="reqn">(d \times 1)</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='regime_distance'>Calculate &quot;distance&quot; between two (scaled) regimes
<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code></h2><span id='topic+regime_distance'></span>

<h3>Description</h3>

<p><code>regime_distance</code> calculates &quot;distance&quot; between two scaled regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regime_distance(regime_pars1, regime_pars2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regime_distance_+3A_regime_pars1">regime_pars1</code></td>
<td>
<p>a length <code class="reqn">pd^2+d+d(d+1)/2</code> vector
<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code>.</p>
</td></tr>
<tr><td><code id="regime_distance_+3A_regime_pars2">regime_pars2</code></td>
<td>
<p>a length <code class="reqn">pd^2+d+d(d+1)/2</code> vector
<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns &quot;distance&quot; between <code>regime_pars1</code> and <code>regime_pars2</code>. Values are scaled
before calculating the &quot;distance&quot;. Read the source code for more details.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='reorder_B_columns'>Reorder columns of impact matrix B of a structural STVAR model
that is identified by heteroskedasticity or non-Gaussianity.</h2><span id='topic+reorder_B_columns'></span>

<h3>Description</h3>

<p><code>reorder_B_columns</code> reorder columns of impact matrix B of a structural STVAR model that is
identified by heteroskedasticity or non-Gaussianity. For models identified by heteroskedasticity, also the
lambda parameters are reordered accordingly. For models with ind Student or skewed t shocks, also the degrees
of freedom and skewness parameters (latter for skewed t) are reordered accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_B_columns(stvar, perm, calc_std_errors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reorder_B_columns_+3A_stvar">stvar</code></td>
<td>
<p>a class 'stvar' object defining a structural STVAR model that is identified by heteroskedasticity
or non-Gaussianity, typically created with <code>fitSSTVAR</code>.</p>
</td></tr>
<tr><td><code id="reorder_B_columns_+3A_perm">perm</code></td>
<td>
<p>an integer vector of length <code class="reqn">d</code> specifying the new order of the columns of the impact matrix.
For model identified by...
</p>

<dl>
<dt>heteroskedasticity</dt><dd><p>also lambda parameters of each regime will be reordered accordingly.</p>
</dd>
<dt>non-Gaussianity</dt><dd><p>the columns of the impact matrices of all the regimes and the component specific distribution
parameters (degrees of freedom and skewness parameters) are reordered accordingly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="reorder_B_columns_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of the columns of the impact matrix can be changed without changing the implied reduced
form model (as long as, for models identified by heteroskedasticity, the order of lambda parameters is also changed accordingly;
and for model identified by non-Gaussianity, ordering of the columns of all the impact matrices and the component specific
distribution  parameters is also changed accordingly). Note that constraints imposed on the impact matrix via <code>B_constraints</code>
will also be modified accordingly.
</p>
<p>Also all signs in any column of impact matrix can be swapped (without changing the implied reduced form model, as long as signs of
any skewness parameters are also swapped accordingly) with the function <code>swap_B_signs</code>. This obviously also swaps the sign constraints
(if any) in the corresponding columns of the impact matrix.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td></tr>
<tr><td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td></tr>
<tr><td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td></tr>
<tr><td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td></tr>
<tr><td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td></tr>
<tr><td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td></tr>
<tr><td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td></tr>
<tr><td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td></tr>
<tr><td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td></tr>
<tr><td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td></tr>
<tr><td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td></tr>
<tr><td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>The seeds used in the estimation in <code>fitSTVAR</code>, if applicable.</p>
</td></tr>
<tr><td><code>LS_estimates</code></td>
<td>
<p>The least squares estimates of the parameters in the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code> (intercepts replaced by unconditional means
if mean parametrization is used), if applicable.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H., Netšunajev A. 2018. Structural vector autoregressions with smooth transition in variances.
<em>Journal of Economic Dynamics &amp; Control</em>, <strong>84</strong>, 43-57.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+fitSSTVAR">fitSSTVAR</a></code>, <code><a href="#topic+swap_B_signs">swap_B_signs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a structural two-variate Student's t STVAR p=2, M=2 model with logistic transition
# weights and the first lag of the second variable  as the switching variable, and shocks
# identified by heteroskedasticity:
theta_222logt &lt;- c(0.356914, 0.107436, 0.356386, 0.086330, 0.139960, 0.035172, -0.164575,
  0.386816, 0.451675, 0.013086, 0.227882, 0.336084, 0.239257, 0.024173, -0.021209, 0.707502,
  0.063322, 0.027287, 0.009182, 0.197066, -0.03, 0.24, -0.76, -0.02, 3.36, 0.86, 0.1, 0.2, 7)
mod222logt &lt;- STVAR(p=2, M=2, d=2, params=theta_222logt, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student", identification="heteroskedasticity")

# Print the parameter values, W and lambdas are printed in the bottom:
mod222logt

# Reverse the ordering of the columns of W (or equally the impact matrix):
mod222logt_rev &lt;- reorder_B_columns(mod222logt, perm=c(2, 1))
mod222logt_rev # The columns of the impact matrix are in a reversed order

# Swap the ordering of the columns of the impact matrix back to the original:
mod222logt_rev2 &lt;- reorder_B_columns(mod222logt_rev, perm=c(2, 1))
mod222logt_rev2 # The columns of the impact matrix are back in the original ordering

# Below code does not do anything, as perm=1:2, so the ordering does not change:
mod222logt3 &lt;- reorder_B_columns(mod222logt, perm=c(1, 2))
mod222logt3 # The ordering of the columns did not change from the original
</code></pre>

<hr>
<h2 id='simulate_from_regime'>Simulate observations from a regime of a STVAR model</h2><span id='topic+simulate_from_regime'></span>

<h3>Description</h3>

<p><code>simulate_from_regime</code> allows to simulate observations from a single
regime of a STVAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_from_regime(
  stvar,
  regime = 1,
  nsim = 1,
  init_values = NULL,
  use_transweights = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_from_regime_+3A_stvar">stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code>.</p>
</td></tr>
<tr><td><code id="simulate_from_regime_+3A_regime">regime</code></td>
<td>
<p>an integer in <code class="reqn">1,...,M</code> determining the regime from which to simulate observations from</p>
</td></tr>
<tr><td><code id="simulate_from_regime_+3A_nsim">nsim</code></td>
<td>
<p>number of observations to be simulated.</p>
</td></tr>
<tr><td><code id="simulate_from_regime_+3A_init_values">init_values</code></td>
<td>
<p>a size <code class="reqn">(p\times d)</code> matrix specifying the initial values, where d is the number
of time series in the system. The <strong>last</strong> row will be used as initial values for the first lag,
the second last row for second lag etc. If not specified, initial values are set to the unconditional
mean of the regime.</p>
</td></tr>
<tr><td><code id="simulate_from_regime_+3A_use_transweights">use_transweights</code></td>
<td>
<p>if <code>TRUE</code> will calculate the transition weights of the provided model, simulate
<code class="reqn">p + 100</code> observations more, calculate the transition weights for the last <code class="reqn">100</code> observations, and
return the the consecutive <code class="reqn">p</code> observations have the highest transition weight for the specified regime.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not take random number generator seed as an argument to avoid unwanted behavior,
because <code>simulate_from_regime</code> is mostly called from <code>simulate.stvar</code>
that takes a seed as its argument, and <code>simulate_from_regime</code> calls <code>simulate.stvar</code> to simulate the observations.
Specifically, <code>simulate_from_regime</code> generates a STVAR model from the given regime, sets up the initial values to the
(if not specified), and then calls <code>simulate.stvar</code> accordingly.
</p>


<h3>Value</h3>


<dl>
<dt>If <code>use_transweights=FALSE</code>:</dt><dd><p>Returns a <code class="reqn">(nsim \times d)</code> matrix such that the <code class="reqn">t</code>th row
contains the <code class="reqn">t</code>th simulated observation.</p>
</dd>
<dt>If <code>use_transweights=TRUE</code>:</dt><dd><p>Returns a <code class="reqn">(p \times d)</code> such that the <code class="reqn">t</code>th row constrains
the <code class="reqn">t</code>th observations.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation.
<em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>International Economic Review</em>, <strong>35</strong>:3, 407-414.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+simulate.stvar">simulate.stvar</a></code>
</p>

<hr>
<h2 id='simulate.stvar'>Simulate method for class 'stvar' objects</h2><span id='topic+simulate.stvar'></span>

<h3>Description</h3>

<p><code>simulate.stvar</code> is a simulate method for class 'stvar' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stvar'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  ...,
  init_values = NULL,
  init_regime,
  ntimes = 1,
  use_stat_for_Gaus = FALSE,
  burn_in = 1000,
  exo_weights = NULL,
  drop = TRUE,
  girf_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.stvar_+3A_object">object</code></td>
<td>
<p>an object of class <code>'stvar'</code>.</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_nsim">nsim</code></td>
<td>
<p>number of observations to be simulated.</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_seed">seed</code></td>
<td>
<p>set seed for the random number generator?</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_...">...</code></td>
<td>
<p>currently not in use.</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_init_values">init_values</code></td>
<td>
<p>a size <code class="reqn">(p\times d)</code> matrix specifying the initial values, where d is the number
of time series in the system. The <strong>last</strong> row will be used as initial values for the first lag,
the second last row for second lag etc. If not specified, initial values will be drawn from
the regime specified in <code>init_regimes</code> (for Gaussian models only).</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_init_regime">init_regime</code></td>
<td>
<p>an integer in <code class="reqn">1,...,M</code> specifying the regime from which
the initial values should be generated from (using a simulation procedure with a burn-in period).
For models with Gaussian conditional distribution, it is also possible to generate the starting
values from the stationary distribution of a regime. See the details section.</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_ntimes">ntimes</code></td>
<td>
<p>how many sets of simulations should be performed?</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_use_stat_for_gaus">use_stat_for_Gaus</code></td>
<td>
<p>if <code>TRUE</code> and <code>cond_dist=="Gaussian"</code>, uses the stationary distribution
of a regime to generate the initial values for the simulation. Note that if stationary distribution is used,
unlike with out simulation procedure, it is not guaranteed that the regime of interest has high transition weights
at the given points of time. Note that if the model allows for unstable estimates (<code>stvar$allow_unstab=TRUE</code>),
simulation procedure is always used.</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_burn_in">burn_in</code></td>
<td>
<p>Burn-in period for simulating initial values from a regime when <code>cond_dist!="Gaussian"</code>.
See the details section.</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_exo_weights">exo_weights</code></td>
<td>
<p>if <code>weight_function="exogenous"</code>, provide a size <code class="reqn">(nsim \times M)</code> matrix of exogenous
transition weights for the regimes: <code>[t, m]</code> for a time <code class="reqn">t</code> and regime <code class="reqn">m</code> weight. Ignored
if <code>weight_function!="exogenous"</code>.</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> (default) then the components of the returned list are coerced to lower dimension if
<code>ntimes==1</code>, i.e., <code>$sample</code> and <code>$transition_weights</code> will be matrices, and <code>$component</code>
will be vector.</p>
</td></tr>
<tr><td><code id="simulate.stvar_+3A_girf_pars">girf_pars</code></td>
<td>
<p>This argument is used internally in the estimation of generalized impulse response functions
(see <code>?GIRF</code>). You should ignore it (specifying something else than null to it will change how the function behaves).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>init_regime</code> to simulate the initial values from a given regime, we employ the following simulation
procedure to obtain the initial values (unless <code>use_stat_for_Gaus=TRUE</code> and Gaussian model is considered).
First, we set the initial values to the unconditional mean of the specified regime. Then,
we simulate a large number observations from that regime as specified in the argument <code>burn_in</code>. Then, we simulate
<code class="reqn">p + 100</code> observations more after the burn in period, and for the <code class="reqn">100</code> observations calculate the transition
weights for them and take the consecutive <code class="reqn">p</code> observations that yield the highest transition weight for the given regime.
For models with exogenous transition weights, takes just the last <code class="reqn">p</code> observations after the burn-in period.
</p>
<p>The argument <code>ntimes</code> is intended for forecasting, which is used by the predict method (see <code>?predict.stvar</code>).
</p>


<h3>Value</h3>

<p>Returns a list containing the simulation results. If <code>drop==TRUE</code> and <code>ntimes==1</code> (default),
contains the following entries:
</p>
<table role = "presentation">
<tr><td><code>sample</code></td>
<td>
<p>a size (<code>nsim</code><code class="reqn">\times d</code>) matrix containing the simulated time series.</p>
</td></tr>
<tr><td><code>transition weights:</code></td>
<td>
<p>a size (<code>nsim</code><code class="reqn">\times M</code>) matrix containing the transition weights corresponding
to the simulated sample.</p>
</td></tr>
</table>
<p>Otherwise, returns a list with the following entries:
</p>
<table role = "presentation">
<tr><td><code>$sample</code></td>
<td>
<p>a size (<code>nsim</code><code class="reqn">\times d\times</code><code>ntimes</code>) array containing the samples: the dimension
<code>[t, , ]</code> is the time index, the dimension <code>[, d, ]</code> indicates the marginal time series, and the dimension
<code>[, , i]</code> indicates the i:th set of simulations.</p>
</td></tr>
<tr><td><code>$transition_weights</code></td>
<td>
<p>a size (<code>nsim</code><code class="reqn">\times M \times</code><code>ntimes</code>) array containing the transition weights
corresponding to the sample: the dimension <code>[t, , ]</code> is the time index, the dimension <code>[, m, ]</code> indicates the
regime, and the dimension <code>[, , i]</code> indicates the i:th set of simulations.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation.
<em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>International Economic Review</em>, <strong>35</strong>:3, 407-414.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Kilian L., Lütkepohl H. 20017. Structural Vector Autoregressive Analysis. 1st edition.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+predict.stvar">predict.stvar</a></code>,<code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+GFEVD">GFEVD</a></code>,  <code><a href="#topic+fitSTVAR">fitSTVAR</a></code>,
<code><a href="#topic+fitSSTVAR">fitSSTVAR</a></code> <code><a href="#topic+STVAR">STVAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Gaussian STVAR(p=2, M=2) model with weighted relative stationary densities
 # of the regimes as the transition weight function:
 theta_222relg &lt;- c(0.356914, 0.107436, 0.356386, 0.08633, 0.13996, 0.035172,
   -0.164575, 0.386816, 0.451675, 0.013086, 0.227882, 0.336084, 0.239257, 0.024173,
   -0.021209, 0.707502, 0.063322, 0.027287, 0.009182, 0.197066, 0.205831, 0.005157,
   0.025877, 1.092094, -0.009327, 0.116449, 0.592446)
 mod222relg &lt;- STVAR(data=gdpdef, p=2, M=2, d=2, params=theta_222relg,
   weight_function="relative_dens")

 # Simulate T=200 observations using given initial values:
 init_vals &lt;- matrix(c(0.5, 1.0, 0.5, 1), nrow=2)
 sim1 &lt;- simulate(mod222relg, nsim=200, seed=1, init_values=init_vals)
 plot.ts(sim1$sample) # Sample
 plot.ts(sim1$transition_weights) # Transition weights

 # Simulate T=100 observations, with initial values drawn from the stationary
 # distribution of the 1st regime:
 sim2 &lt;- simulate(mod222relg, nsim=200, seed=1, init_regime=1)
 plot.ts(sim2$sample) # Sample
 plot.ts(sim2$transition_weights) # Transition weights

# Logistic Student's t STVAR with p=1, M=2, and the first lag of the second variable
# as the switching variable.
params12 &lt;- c(0.62906848, 0.14245295, 2.41245785, 0.66719269, 0.3534745, 0.06041779, -0.34909745,
  0.61783824, 0.125769, -0.04094521, -0.99122586, 0.63805416, 0.371575, 0.00314754, 0.03440824,
  1.29072533, -0.06067807, 0.18737385, 1.21813844, 5.00884263, 7.70111672)
fit12 &lt;- STVAR(data=gdpdef, p=1, M=2, params=params12, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student")

# Simulate T=100 observations with initial values drawn from the second regime.
# Since the stationary distribution of the Student's regime is not known, we
# use a simulation procedure that starts from the unconditional mean of the regime,
# then simulates a number of observations from the regime for a "burn-in" period,
# and finally takes the last p observations generated from the regime as the initial
# values for the simulation from the STVAR model:
sim3 &lt;- simulate(fit12, nsim=100, init_regime=1, burn_in=1000)
plot.ts(sim3$sample) # Sample
plot.ts(sim3$transition_weights) # Transition weights
</code></pre>

<hr>
<h2 id='skewed_t_dens'>The density function of the univariate skewed t distribution</h2><span id='topic+skewed_t_dens'></span>

<h3>Description</h3>

<p><code>skewed_t_dens</code> calculates the density of the univariate skewed t distribution described in Hansen (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewed_t_dens(y, nu, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skewed_t_dens_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the values at which the density is to be evaluated.</p>
</td></tr>
<tr><td><code id="skewed_t_dens_+3A_nu">nu</code></td>
<td>
<p>the degrees of freedom parameter value, a numeric scalar strictly larger than two.</p>
</td></tr>
<tr><td><code id="skewed_t_dens_+3A_lambda">lambda</code></td>
<td>
<p>the skewness parameter value, a numeric scalar strictly between -1 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Hansen (1994, Section 2.4) for the details of the skewed t distribution.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of the same length as <code>y</code> containing the density values.
</p>


<h3>References</h3>


<ul>
<li><p> Hansen B.E. 1994. Autoregressive Conditional Density estimation. <em>Journal of Econometrics</em>, <strong>35</strong>:3, 705-730.
</p>
</li></ul>


<hr>
<h2 id='smart_covmat'>Create random VAR model <code class="reqn">(dxd)</code> error term covariance matrix <code class="reqn">\Omega</code>
fairly close to the given <strong>positive definite</strong> covariance matrix using (scaled)
Wishart distribution</h2><span id='topic+smart_covmat'></span>

<h3>Description</h3>

<p><code>smart_covmat</code> generates random VAR model <code class="reqn">(dxd)</code> error term covariance matrix <code class="reqn">\Omega</code>
from (scaled) Wishart distribution that is fairly close to the given matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smart_covmat(d, Omega, accuracy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smart_covmat_+3A_omega">Omega</code></td>
<td>
<p>a symmetric positive definite <code class="reqn">(dxd)</code> covariance matrix specifying
expected value of the matrix to be generated.</p>
</td></tr>
<tr><td><code id="smart_covmat_+3A_accuracy">accuracy</code></td>
<td>
<p>a positive real number adjusting how close to the given covariance matrix
the returned individual should be.
</p>
<p>The standard deviation of each diagonal element is...
</p>

<ul>
<li> <p><code class="reqn">\omega_{i,i}/</code><code>accuracy</code> when <code>accuracy &gt; d/2</code>
</p>
</li>
<li><p> and <code>sqrt(2/d)*</code><code class="reqn">\omega_{i,i}</code> when <code>accuracy &lt;= d/2</code>.
</p>
</li></ul>

<p>Wishart distribution is used for reduced form models, but for more details read the source code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">(d(d+1)/2x1)</code> vector containing vech-vectorized covariance matrix
<code class="reqn">\Omega</code>.
</p>

<hr>
<h2 id='smart_distpars'>Create random distribution parameter values close to given values</h2><span id='topic+smart_distpars'></span>

<h3>Description</h3>

<p><code>smart_distpars</code> generates random degrees of freedom parameter values
close to given values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smart_distpars(distpars, accuracy, cond_dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smart_distpars_+3A_distpars">distpars</code></td>
<td>
<p>the old distribution parameters (of all regimes)</p>
</td></tr>
<tr><td><code id="smart_distpars_+3A_accuracy">accuracy</code></td>
<td>
<p>a positive real number adjusting how close to the given distribution parameters
the returned values should be.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector ...
</p>

<dl>
<dt>If <code>cond_dist == "Gaussian"</code>:</dt><dd><p>of length zero.</p>
</dd>
<dt>If <code>cond_dist == "Student"</code>:</dt><dd><p>of length one containing a degrees of freedom parameter value
(strictly larger than two).</p>
</dd>
<dt>If <code>cond_dist == "ind_Student"</code>:</dt><dd><p>of length d containing a degrees of freedom parameter values
(strictly larger than two).</p>
</dd>
<dt>If <code>cond_dist == "ind_skewed_t"</code>:</dt><dd><p>of length 2d containing df params strictly larger than two in the first d
elements and skewness params strictly between -1 and 1 in the rest d elements.</p>
</dd>
</dl>


<hr>
<h2 id='smart_impactmat'>Create a random VAR model <code class="reqn">(dxd)</code> error impact matrix <code class="reqn">B</code>
fairly close to the given <strong>invertible</strong> impact matrix.</h2><span id='topic+smart_impactmat'></span>

<h3>Description</h3>

<p><code>smart_impactmat</code> generates a random VAR model <code class="reqn">(dxd)</code> error impact matrix <code class="reqn">B</code>
fairly close to the given <strong>invertible</strong> impact matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smart_impactmat(d, B, accuracy, is_regime1 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smart_impactmat_+3A_b">B</code></td>
<td>
<p>an invertible <code class="reqn">(dxd)</code> impact matrix specifying
expected value of the matrix to be generated. Should have strictly positive diagonal entries in
a decreasing order.</p>
</td></tr>
<tr><td><code id="smart_impactmat_+3A_accuracy">accuracy</code></td>
<td>
<p>a positive real number adjusting how close to the given impact matrix
the returned individual should be. Larger value implies higher accuracy.</p>
</td></tr>
<tr><td><code id="smart_impactmat_+3A_is_regime1">is_regime1</code></td>
<td>
<p>is the impact matrix for Regime 1? Regime 1 impact matrix is constrained so the elements
in its first row are in a decreasing ordering and the diagonal elements are strictly positive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">(d^2 \times 1)</code> vector containing the vectorized impact matrix <code class="reqn">B</code>.
</p>

<hr>
<h2 id='smart_ind'>Create random parameter vector that is fairly close to a given parameter vector</h2><span id='topic+smart_ind'></span>

<h3>Description</h3>

<p><code>smart_ind</code> creates random mean parametrized parameter vector that is
model fairly close to a given parameter vector. The result may not be satisfy the stability
condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smart_ind(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  accuracy = 1,
  which_random = numeric(0),
  mu_scale,
  mu_scale2,
  omega_scale,
  B_scale,
  ar_scale = 1,
  ar_scale2 = 1,
  fixed_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smart_ind_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="smart_ind_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_accuracy">accuracy</code></td>
<td>
<p>a positive real number adjusting how close to the given parameter vector the returned individual should be.
Larger number means larger accuracy. Read the source code for details.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_which_random">which_random</code></td>
<td>
<p>a vector with length between 1 and M specifying the mixture components that should be random instead of
close to the given parameter vector. This does not consider constrained AR or lambda parameters.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> vector defining <strong>means</strong> of the normal distributions from which each
mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations. Default is <code>colMeans(data)</code>. Note that
mean-parametrization is always used for optimization in <code>GAfit</code> - even when <code>parametrization=="intercept"</code>.
However, input (in <code>initpop</code>) and output (return value) parameter vectors can be intercept-parametrized.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_mu_scale2">mu_scale2</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector defining <strong>standard deviations</strong> of the normal
distributions from which each mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations.
Default is <code>vapply(1:d, function(i1) sd(data[,i1]), numeric(1))</code>.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_omega_scale">omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
<code>cond_dist == "ind_Student"</code>.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_b_scale">B_scale</code></td>
<td>
<p>a size <code class="reqn">(d \times 1)</code> strictly positive vector specifying the mean and variability of the
random impact matrices in random mutations. In Regime 1, the mean of the error term covariance matrix
implied by the random impact matrix will be <code>0.95*diag(B_scale)</code> and in the rest of the regimes <code>diag(B_scale)</code>,
whereas the variability increases with <code>B_scale</code>.
Default in <code>GAfit</code> is <code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>.
This argument is ignored if <code>cond_dist != "ind_Student"</code>.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_ar_scale">ar_scale</code></td>
<td>
<p>a positive real number between zero and one adjusting how large AR parameter values are typically
proposed in construction of the initial population: larger value implies larger coefficients (in absolute value).
After construction of the initial population, a new scale is drawn from <code>(0, upper_ar_scale)</code> uniform
distribution in each iteration.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_ar_scale2">ar_scale2</code></td>
<td>
<p>a positive real number adjusting how large AR parameter values are typically proposed in some
random mutations (if AR constraints are employed, in all random mutations): larger value implies <strong>smaller</strong>
coefficients (in absolute value). <strong>Values larger than 1 can be used if the AR coefficients are expected to
be very small. If set smaller than 1, be careful as it might lead to failure in the creation of parameter candidates
that satisfy the stability condition.</strong></p>
</td></tr>
<tr><td><code id="smart_ind_+3A_fixed_params">fixed_params</code></td>
<td>
<p>a vector containing fixed parameter values for intercept, autoregressive, and weight parameters
that should be fixed in the <strong>initial population</strong>. Should have the form:
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code>, where
</p>

<ul>
<li><p><code class="reqn">(\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li><p><code class="reqn">\alpha</code> vector of the weight parameters.
</p>
</li></ul>

<p>For models with...
</p>

<dl>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
</dl>

<p>Note that <code>fixed_params</code> should always be in the intercept parametrization (and <code>parametrization="intercept"</code> should always be used).
<strong>Passing this argument from fitSTVAR in does not do anything, as it is designed to be used with the three-phase estimation
procedure only. Also, this argument does not do anything if the initial population is specified in the argument initpop.</strong></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Structural models are not supported!
</p>


<h3>Value</h3>

<p>Returns random mean parametrized parameter vector that has the same form as the argument <code>params</code>
in the other functions, for instance, in the function <code>loglikelihood</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Ansley C.F., Kohn R. 1986. A note on reparameterizing a vector autoregressive
moving average model to enforce stationarity.
<em>Journal of statistical computation and simulation</em>, <strong>24</strong>:2, 99-106.
</p>
</li></ul>


<hr>
<h2 id='smart_weightpars'>Create random transition weight parameter values</h2><span id='topic+smart_weightpars'></span>

<h3>Description</h3>

<p><code>smart_weightpars</code> generates random transition weight parameter values
relatively close to the ones given in <code>weight_pars</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smart_weightpars(
  M,
  weight_pars,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weight_constraints = NULL,
  accuracy
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smart_weightpars_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="smart_weightpars_+3A_weight_pars">weight_pars</code></td>
<td>
<p>a vector containing transition weight parameter values.
</p>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>a length <code>M-1</code> vector <code class="reqn">(\alpha_1,...,\alpha_{M-1})</code>.</p>
</dd>
<dt>If <code>weight_function == "logistic"</code>:</dt><dd><p>a length two vector <code class="reqn">(c,\gamma)</code>,
where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a length <code class="reqn">((M-1)k\times 1)</code> vector <code class="reqn">(\gamma_1,...,\gamma_{M-1})</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the mlogit-regression coefficients of the <code class="reqn">m</code>th
regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt>If <code>weight_function == "exponential"</code>:</dt><dd><p>a length two vector <code class="reqn">(c,\gamma)</code>,
where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>If <code>weight_function == "threshold"</code>:</dt><dd><p>a length <code class="reqn">M-1</code> vector <code class="reqn">(r_1,...,r_{M-1})</code>,
where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values in an increasing order.</p>
</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>of length zero.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="smart_weightpars_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="smart_weightpars_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="smart_weightpars_+3A_accuracy">accuracy</code></td>
<td>
<p>a positive real number adjusting how close to the given parameter vector the returned individual should be.
Larger number means larger accuracy. Read the source code for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector ...
</p>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>a length <code>M-1</code> vector <code class="reqn">(\alpha_1,...,\alpha_{M-1})</code>.</p>
</dd>
<dt>If <code>weight_function == "logistic"</code>:</dt><dd><p>a length two vector <code class="reqn">(c,\gamma)</code>,
where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a length <code class="reqn">((M-1)k\times 1)</code> vector <code class="reqn">(\gamma_1,...,\gamma_{M-1})</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the mlogit-regression coefficients of the <code class="reqn">m</code>th
regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt>If <code>weight_function == "exponential"</code>:</dt><dd><p>a length two vector <code class="reqn">(c,\gamma)</code>,
where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt>If <code>weight_function == "threshold"</code>:</dt><dd><p>a length <code class="reqn">M-1</code> vector <code class="reqn">(r_1,...,r_{M-1})</code>,
where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values in an increasing order.</p>
</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>of length zero.</p>
</dd>
</dl>


<hr>
<h2 id='sort_impactmats'>Sort and sign change the columns of the impact matrices of the regimes so that the first element in each column of <code class="reqn">B_1</code>
is positive and in a decreasing order.</h2><span id='topic+sort_impactmats'></span>

<h3>Description</h3>

<p><code>sort_impactmats</code> sorts and sign changes the columns of the impact matrices of the regimes so that the first element
in each column of <code class="reqn">B_1</code> is positive and in a decreasing order. The same reordering and sign changes performed to the columns of
<code class="reqn">B_1</code> are applied to the rest of the impact matrices to obtain an observationally equivalent model. For skewed t models, also
the signs of the skewness parameters corresponding to the columns whose signs are changed are changed accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_impactmats(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort_impactmats_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="sort_impactmats_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="sort_impactmats_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="sort_impactmats_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="sort_impactmats_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sort_impactmats_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="sort_impactmats_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="sort_impactmats_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="sort_impactmats_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally used by <code>GAfit</code> and <code>fitSTVAR</code>, so structural models or <code>B_constraints</code>
are not supported.
</p>


<h3>Value</h3>

<p>Returns sorted parameter vector of the form described for the argument <code>params</code>,
with the regimes sorted so that...
</p>

<dl>
<dt>If <code>cond_dist == "ind_Student"</code>:</dt><dd><p>The parameter vector with the columns of the impact
matrices sorted and sign changed so that the first element in each column of <code class="reqn">B_1</code> is
positive and in a decreasing order. Sorts also the degrees of freedom parameters accordingly.</p>
</dd>
<dt>If <code>cond_dist == "ind_skewed_t"</code>:</dt><dd><p>The parameter vector with the columns of the impact
matrices sorted so that the first element in each column of <code class="reqn">B_1</code> are in a decreasing order.
Also sorts the degrees of freedom and skewness parameters accordingly. Moreover, if signs of any column
are changed, the signs of the corresponding skewness parameter values are also changed accordingly.</p>
</dd>
<dt>Otherwise:</dt><dd><p>Nothing to sort, so returns the original parameter vector given in <code>param</code>.</p>
</dd>
</dl>


<hr>
<h2 id='sort_regimes'>Sort regimes in parameter vector according to transition weights into a decreasing order</h2><span id='topic+sort_regimes'></span>

<h3>Description</h3>

<p><code>sort_regimes</code> sorts regimes in the parameter vector according to
the transition weight parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_regimes(
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  B_constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort_regimes_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="sort_regimes_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="sort_regimes_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="sort_regimes_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="sort_regimes_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sort_regimes_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="sort_regimes_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sort_regimes_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constrained parameter vectors are not supported (except <code>B_constraints</code> for structural models identified
by heteroskedasticity).
</p>


<h3>Value</h3>

<p>Returns sorted parameter vector of the form described for the argument <code>params</code>,
with the regimes sorted so that...
</p>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{1}&gt;...&gt;\alpha_{M}</code>.</p>
</dd>
<dt>If <code>weight_function == "logistic"</code>:</dt><dd><p>Nothing to sort, so returns the original parameter vector given in <code>param</code>.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>Does not currently sort, so returns the original parameter vector given in
<code>param</code>.</p>
</dd>
<dt>If <code>weight_function == "exponential"</code>:</dt><dd><p>Nothing to sort, so returns the original parameter vector given in
<code>param</code>.</p>
</dd>
<dt>If <code>weight_function == "threshold"</code>:</dt><dd><p>The increasing ordering of the thresholds is imposed in the parameter space,
so nothing to sort and thereby returns the original parameter vector given in <code>param</code>.</p>
</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>Does not sort but returns the original parameter vector.</p>
</dd>
</dl>


<hr>
<h2 id='stab_conds_satisfied'>Check the stability condition for each of the regimes</h2><span id='topic+stab_conds_satisfied'></span>

<h3>Description</h3>

<p><code>stab_conds_satisfied</code> checks whether the stability condition is satisfied
for each of the regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stab_conds_satisfied(p, M, d, params, all_boldA = NULL, tolerance = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stab_conds_satisfied_+3A_p">p</code></td>
<td>
<p>the autoregressive order of the model</p>
</td></tr>
<tr><td><code id="stab_conds_satisfied_+3A_m">M</code></td>
<td>
<p>the number of regimes</p>
</td></tr>
<tr><td><code id="stab_conds_satisfied_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="stab_conds_satisfied_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the threshold values.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime. If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean
<code class="reqn">\mu_{m}</code>.</p>
</td></tr>
<tr><td><code id="stab_conds_satisfied_+3A_all_bolda">all_boldA</code></td>
<td>
<p>3D array containing the <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; (companion form) matrices of each regime,
obtained from <code>form_boldA</code>. Will be computed if not given.</p>
</td></tr>
<tr><td><code id="stab_conds_satisfied_+3A_tolerance">tolerance</code></td>
<td>
<p>Returns <code>FALSE</code> if modulus of any eigenvalue of &quot;bold A&quot; is larger or equal to <code>1-tolerance</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the stability condition is satisfied for all regimes and <code>FALSE</code> if not.
According to the argument <code>tolerance</code>, <code>stab_conds_satisfied</code> may return <code>FALSE</code> when the parameter
vector satisfies the stability conditions but is very close to the boundary (this is used to ensure numerical stability
in the estimation of the model parameters).
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li></ul>


<hr>
<h2 id='stand_t_dens'>The density function of the univariate t distribution with zero mean and unit variance</h2><span id='topic+stand_t_dens'></span>

<h3>Description</h3>

<p><code>stand_t_dens</code> calculates the density of the univariate t distribution with zero mean and unit variance,
described, for example, in Virolainen (2025).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stand_t_dens(y, nu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stand_t_dens_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the values at which the density is to be evaluated.</p>
</td></tr>
<tr><td><code id="stand_t_dens_+3A_nu">nu</code></td>
<td>
<p>the degrees of freedom parameter value, a numeric scalar strictly larger than two.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Virolainen (2025) and the references therein, for example, for the details of the density function of
t-distribution with zero mean and unit variance (assume the skewness parameter value is zero to obtain the
non-skewed version of the t-distribution).
</p>


<h3>Value</h3>

<p>Returns a numeric vector of the same length as <code>y</code> containing the density values.
</p>


<h3>References</h3>


<ul>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>


<hr>
<h2 id='standard_errors'>Calculate standard errors for estimates of a smooth transition VAR model</h2><span id='topic+standard_errors'></span>

<h3>Description</h3>

<p><code>standard_errors</code> calculates approximate standard errors for the smooth transition
VAR model using square roots of the diagonal of inverse of observed information matrix
and central-difference approximation for the differentiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standard_errors(
  data,
  p,
  M,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL,
  penalized = FALSE,
  penalty_params = c(0.05, 0.2),
  allow_unstab = FALSE,
  minval
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standard_errors_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. Missing values are not supported.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="standard_errors_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="standard_errors_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_penalized">penalized</code></td>
<td>
<p>Perform penalized LS estimation that minimizes penalized RSS in which estimates close to breaking or not satisfying the
usual stability condition are penalized? If <code>TRUE</code>, the tuning parameter is set by the argument <code>penalty_params[2]</code>,
and the penalization starts when the eigenvalues of the companion form AR matrix are larger than <code>1 - penalty_params[1]</code>.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_penalty_params">penalty_params</code></td>
<td>
<p>a numeric vector with two positive elements specifying the penalization parameters:
the first element determined how far from the boundary of the stability region the penalization starts
(a number between zero and one, smaller number starts penalization closer to the boundary) and the second element
is a tuning parameter for the penalization (a positive real number, a higher value penalizes non-stability more).</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_minval">minval</code></td>
<td>
<p>the value that will be returned if the parameter vector does not lie in the parameter space
(excluding the identification condition).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes the standard asymptotic distribution of the estimator
</p>


<h3>Value</h3>

<p>A vector containing the approximate standard errors of the estimates.
</p>


<h3>References</h3>


<ul>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis, <em>Springer</em>.
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='Student_densities_Cpp'>Calculate log multivariate Student's t densities</h2><span id='topic+Student_densities_Cpp'></span>

<h3>Description</h3>

<p>Calculates logs of multivariate Student t densities with varying mean
and varying covariance matrix AND EXCLUDING the constant term of the density
(the constant is calculated and added in R code). The varying conditional covariance
matrix is calculated within the function from the regime covariance matrices and
transition weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Student_densities_Cpp(obs, means, covmats, alpha_mt, df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Student_densities_Cpp_+3A_obs">obs</code></td>
<td>
<p>a <code class="reqn">(T \times d)</code> matrix such that the <code class="reqn">i</code>th row contains the vector
<code class="reqn">y_{i}=(y_{1i},...,y_{di})</code> <code class="reqn">(dx1)</code>. That is, the initial values are
excluded but the last observations is included.</p>
</td></tr>
<tr><td><code id="Student_densities_Cpp_+3A_means">means</code></td>
<td>
<p>a <code class="reqn">(T \times d)</code> matrix such that the <code class="reqn">i</code>th row contains the
conditional mean of the process <code class="reqn">\mu_{y,i}</code>.</p>
</td></tr>
<tr><td><code id="Student_densities_Cpp_+3A_covmats">covmats</code></td>
<td>
<p>a <code class="reqn">(d \times d \times M)</code> array such that the slice <code>[, , m]</code>
contains the conditional covariance matrix of regime m.</p>
</td></tr>
<tr><td><code id="Student_densities_Cpp_+3A_alpha_mt">alpha_mt</code></td>
<td>
<p>a <code class="reqn">(T \times M)</code> matrix such that <code>[t, m]</code> contains the time t
transition weights of the <code class="reqn">m</code>th regime.</p>
</td></tr>
<tr><td><code id="Student_densities_Cpp_+3A_df">df</code></td>
<td>
<p>the degrees of freedom parameter value (assumed larger than two).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the parametrization is with the covariance matrix and not the scale matrix.
</p>


<h3>Value</h3>

<p>a numeric vector containing the multivariate Student's t densities, excluding the constant term.
</p>

<hr>
<h2 id='STVAR'>Create a class 'stvar' object defining a reduced form or structural smooth transition VAR model</h2><span id='topic+STVAR'></span><span id='topic+logLik.stvar'></span><span id='topic+residuals.stvar'></span><span id='topic+summary.stvar'></span><span id='topic+plot.stvar'></span><span id='topic+print.stvar'></span>

<h3>Description</h3>

<p><code>STVAR</code> creates a class <code>'stvar'</code> object that defines
a reduced form or structural smooth transition VAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STVAR(
  data,
  p,
  M,
  d,
  params,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold",
    "exogenous"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student", "ind_Student", "ind_skewed_t"),
  parametrization = c("intercept", "mean"),
  identification = c("reduced_form", "recursive", "heteroskedasticity",
    "non-Gaussianity"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  B_constraints = NULL,
  penalized = FALSE,
  penalty_params = c(0.05, 1),
  allow_unstab = FALSE,
  calc_std_errors = FALSE
)

## S3 method for class 'stvar'
logLik(object, ...)

## S3 method for class 'stvar'
residuals(object, ...)

## S3 method for class 'stvar'
summary(object, ..., digits = 2, standard_error_print = FALSE)

## S3 method for class 'stvar'
plot(x, ..., plot_type = c("trans_weights", "cond_mean"))

## S3 method for class 'stvar'
print(x, ..., digits = 2, summary_print = FALSE, standard_error_print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STVAR_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a single times series. <code>NA</code> values are not supported. Ignore if defining a model without data is desired.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="STVAR_+3A_m">M</code></td>
<td>
<p>a positive integer specifying the number of regimes</p>
</td></tr>
<tr><td><code id="STVAR_+3A_d">d</code></td>
<td>
<p>number of times series in the system, i.e. <code>ncol(data)</code>. This can be
used to define STVAR models without data and can be ignored if <code>data</code> is provided.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
Should have the form <code class="reqn">\theta = (\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\sigma,\alpha,\nu)</code>,
where (see exceptions below):
</p>

<ul>
<li><p><code class="reqn">\phi_{m,0} = </code> the <code class="reqn">(d \times 1)</code> intercept (or mean) vector of the <code class="reqn">m</code>th regime.
</p>
</li>
<li><p><code class="reqn">\varphi_m = (vec(A_{m,1}),...,vec(A_{m,p}))</code> <code class="reqn">(pd^2 \times 1)</code>.
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist="Gaussian"</code> or <code>"Student"</code>:</dt><dd><p><code class="reqn">\sigma = (vech(\Omega_1),...,vech(\Omega_M))</code>
<code class="reqn">(Md(d + 1)/2 \times 1)</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code> or <code>"ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(B_1),...,vec(B_M)</code> <code class="reqn">(Md^2 \times 1)</code>.</p>
</dd>
</dl>


</li>
<li><p><code class="reqn">\alpha = </code> the <code class="reqn">(a\times 1)</code> vector containing the transition weight parameters (see below).
</p>
</li>
<li>
<dl>
<dt>if <code>cond_dist = "Gaussian")</code>:</dt><dd><p>Omit <code class="reqn">\nu</code> from the parameter vector.</p>
</dd>
<dt>if <code>cond_dist="Student"</code>:</dt><dd><p><code class="reqn">\nu &gt; 2</code> is the single degrees of freedom parameter.</p>
</dd>
<dt>if <code>cond_dist="ind_Student"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d)</code> <code class="reqn">(d \times 1)</code>, <code class="reqn">\nu_i &gt; 2</code>.</p>
</dd>
<dt>if <code>cond_dist="ind_skewed_t"</code>:</dt><dd><p><code class="reqn">\nu = (\nu_1,...,\nu_d,\lambda_1,...,\lambda_d)</code> <code class="reqn">(2d \times 1)</code>,
<code class="reqn">\nu_i &gt; 2</code> and <code class="reqn">\lambda_i \in (0, 1)</code>.</p>
</dd>
</dl>


</li></ul>

<p>For models with...
</p>

<dl>
<dt><code>weight_function="relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha = (\alpha_1,...,\alpha_{M-1})</code>
<code class="reqn">(M - 1 \times 1)</code>, where <code class="reqn">\alpha_m</code> <code class="reqn">(1\times 1), m=1,...,M-1</code> are the transition weight parameters.</p>
</dd>
<dt><code>weight_function="logistic"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="mlogit"</code>:</dt><dd><p><code class="reqn">\alpha = (\gamma_1,...,\gamma_M)</code> <code class="reqn">((M-1)k\times 1)</code>,
where <code class="reqn">\gamma_m</code> <code class="reqn">(k\times 1)</code>, <code class="reqn">m=1,...,M-1</code> contains the multinomial logit-regression coefficients
of the <code class="reqn">m</code>th regime. Specifically, for switching variables with indices in <code class="reqn">I\subset\lbrace 1,...,d\rbrace</code>, and with
<code class="reqn">\tilde{p}\in\lbrace 1,...,p\rbrace</code> lags included, <code class="reqn">\gamma_m</code> contains the coefficients for the vector
<code class="reqn">z_{t-1} = (1,\tilde{z}_{\min\lbrace I\rbrace},...,\tilde{z}_{\max\lbrace I\rbrace})</code>, where
<code class="reqn">\tilde{z}_{i} =(y_{it-1},...,y_{it-\tilde{p}})</code>, <code class="reqn">i\in I</code>. So <code class="reqn">k=1+|I|\tilde{p}</code>
where <code class="reqn">|I|</code> denotes the number of elements in <code class="reqn">I</code>.</p>
</dd>
<dt><code>weight_function="exponential"</code>:</dt><dd><p><code class="reqn">\alpha = (c,\gamma)</code>
<code class="reqn">(2 \times 1)</code>, where <code class="reqn">c\in\mathbb{R}</code> is the location parameter and <code class="reqn">\gamma &gt;0</code> is the scale parameter.</p>
</dd>
<dt><code>weight_function="threshold"</code>:</dt><dd><p><code class="reqn">\alpha = (r_1,...,r_{M-1})</code>
<code class="reqn">(M-1 \times 1)</code>, where <code class="reqn">r_1,...,r_{M-1}</code> are the thresholds.</p>
</dd>
<dt><code>weight_function="exogenous"</code>:</dt><dd><p>Omit <code class="reqn">\alpha</code> from the parameter vector.</p>
</dd>
<dt>AR_constraints:</dt><dd><p>Replace <code class="reqn">\varphi_1,...,\varphi_M</code> with <code class="reqn">\psi</code> as described in the argument <code>AR_constraints</code>.</p>
</dd>
<dt>mean_constraints:</dt><dd><p>Replace <code class="reqn">\phi_{1,0},...,\phi_{M,0}</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_i, \ (d\times 1)</code> is the mean parameter for group <code class="reqn">i</code> and <code class="reqn">g</code> is the number of groups.</p>
</dd>
<dt>weight_constraints:</dt><dd><p>If linear constraints are imposed, replace <code class="reqn">\alpha</code> with <code class="reqn">\xi</code> as described in the
argument <code>weigh_constraints</code>. If weight functions parameters are imposed to be fixed values, simply drop <code class="reqn">\alpha</code>
from the parameter vector.</p>
</dd>
<dt><code>identification="heteroskedasticity"</code>:</dt><dd><p><code class="reqn">\sigma = (vec(W),\lambda_2,...,\lambda_M)</code>, where
<code class="reqn">W</code> <code class="reqn">(d\times d)</code> and <code class="reqn">\lambda_m</code> <code class="reqn">(d\times 1)</code>, <code class="reqn">m=2,...,M</code>, satisfy
<code class="reqn">\Omega_1=WW'</code> and <code class="reqn">\Omega_m=W\Lambda_mW'</code>, <code class="reqn">\Lambda_m=diag(\lambda_{m1},...,\lambda_{md})</code>,
<code class="reqn">\lambda_{mi}&gt;0</code>, <code class="reqn">m=2,...,M</code>, <code class="reqn">i=1,...,d</code>.</p>
</dd>
<dt>B_constraints:</dt><dd><p>For models identified by heteroskedasticity, replace <code class="reqn">vec(W)</code> with <code class="reqn">\tilde{vec}(W)</code>
that stacks the columns of the matrix <code class="reqn">W</code> in to vector so that the elements that are constrained to zero
are not included. For models identified by non-Gaussianity, replace <code class="reqn">vec(B_1),...,vec(B_M)</code> with
similarly with vectorized versions <code class="reqn">B_m</code> so that the elements that are constrained to zero are not included.</p>
</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
regime, <code class="reqn">\Omega_{m}</code> denotes the positive definite error term covariance matrix of the <code class="reqn">m</code>th regime, and <code class="reqn">B_m</code>
is the invertible <code class="reqn">(d\times d)</code> impact matrix of the <code class="reqn">m</code>th regime. <code class="reqn">\nu_m</code> is the degrees of freedom parameter
of the <code class="reqn">m</code>th regime.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector. <code class="reqn">Bvec()</code>
is a vectorization operator that stacks the columns of a given impact matrix <code class="reqn">B_m</code> into a vector so that the elements
that are constrained to zero by the argument <code>B_constraints</code> are excluded.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_weight_function">weight_function</code></td>
<td>
<p>What type of transition weights <code class="reqn">\alpha_{m,t}</code> should be used?
</p>

<dl>
<dt><code>"relative_dens"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}</code>, where
<code class="reqn">\alpha_m\in (0,1)</code> are weight parameters that satisfy <code class="reqn">\sum_{m=1}^M\alpha_m=1</code> and
<code class="reqn">f_{m,dp}(\cdot)</code> is the <code class="reqn">dp</code>-dimensional stationary density of the <code class="reqn">m</code>th regime corresponding to <code class="reqn">p</code>
consecutive observations. Available for Gaussian conditional distribution only.</p>
</dd>
<dt><code>"logistic"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"mlogit"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}</code>, where <code class="reqn">\gamma_m</code> are coefficient vectors, <code class="reqn">\gamma_M=0</code>,
and <code class="reqn">z_{t-1}</code> <code class="reqn">(k\times 1)</code> is the vector containing a constant and the (lagged) switching variables.</p>
</dd>
<dt><code>"exponential"</code>:</dt><dd><p><code class="reqn">M=2</code>, <code class="reqn">\alpha_{1,t}=1-\alpha_{2,t}</code>,
and <code class="reqn">\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace</code>, where <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable, <code class="reqn">c</code> is a location parameter, and <code class="reqn">\gamma &gt; 0</code> is a scale parameter.</p>
</dd>
<dt><code>"threshold"</code>:</dt><dd><p><code class="reqn">\alpha_{m,t} = 1</code> if <code class="reqn">r_{m-1}&lt;y_{it-j}\leq r_{m}</code> and <code class="reqn">0</code> otherwise, where
<code class="reqn">-\infty\equiv r_0&lt;r_1&lt;\cdots &lt;r_{M-1}&lt;r_M\equiv\infty</code> are thresholds <code class="reqn">y_{it-j}</code> is the lag <code class="reqn">j</code>
observation of the <code class="reqn">i</code>th variable.</p>
</dd>
<dt><code>"exogenous"</code>:</dt><dd><p>Exogenous nonrandom transition weights, specify the weight series in <code>weightfun_pars</code>.</p>
</dd>
</dl>

<p>See the vignette for more details about the weight functions.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_weightfun_pars">weightfun_pars</code></td>
<td>

<dl>
<dt>If <code>weight_function == "relative_dens"</code>:</dt><dd><p>Not used.</p>
</dd>
<dt>If <code>weight_function %in% c("logistic", "exponential", "threshold")</code>:</dt><dd><p>a numeric vector with the switching variable
<code class="reqn">i\in\lbrace 1,...,d \rbrace</code> in the first and the lag <code class="reqn">j\in\lbrace 1,...,p \rbrace</code> in the second element.</p>
</dd>
<dt>If <code>weight_function == "mlogit"</code>:</dt><dd><p>a list of two elements:
</p>

<dl>
<dt>The first element <code>$vars</code>:</dt><dd><p>a numeric vector containing the variables that should used as switching variables
in the weight function in an increasing order, i.e., a vector with unique elements in <code class="reqn">\lbrace 1,...,d \rbrace</code>.</p>
</dd>
<dt>The second element <code>$lags</code>:</dt><dd><p>an integer in <code class="reqn">\lbrace 1,...,p \rbrace</code> specifying the number of lags to be
used in the weight function.</p>
</dd>
</dl>

</dd>
<dt>If <code>weight_function == "exogenous"</code>:</dt><dd><p>a size (<code>nrow(data) - p</code> x <code>M</code>) matrix containing the exogenous
transition weights as <code>[t, m]</code> for time <code class="reqn">t</code> and regime <code class="reqn">m</code>. Each row needs to sum to one and only weakly positive
values are allowed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="STVAR_+3A_cond_dist">cond_dist</code></td>
<td>
<p>specifies the conditional distribution of the model as <code>"Gaussian"</code>, <code>"Student"</code>, <code>"ind_Student"</code>,
or <code>"ind_skewed_t"</code>, where <code>"ind_Student"</code> the Student's <code class="reqn">t</code> distribution with independent components, and
<code>"ind_skewed_t"</code> is the skewed <code class="reqn">t</code> distribution with independent components (see Hansen, 1994).</p>
</td></tr>
<tr><td><code id="STVAR_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_identification">identification</code></td>
<td>
<p>is it reduced form model or an identified structural model; if the latter, how is it identified
(see the vignette or the references for details)?
</p>

<dl>
<dt><code>"reduced_form"</code>:</dt><dd><p>Reduced form model.</p>
</dd>
<dt><code>"recursive"</code>:</dt><dd><p>The usual lower-triangular recursive identification of the shocks via their impact responses.</p>
</dd>
<dt><code>"heteroskedasticity"</code>:</dt><dd><p>Identification by conditional heteroskedasticity, which imposes constant relative
impact responses for each shock.</p>
</dd>
<dt><code>"non-Gaussianity"</code>:</dt><dd><p>Identification by non-Gaussianity; requires mutually independent non-Gaussian shocks, thus,
currently available only with the conditional distribution <code>"ind_Student"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="STVAR_+3A_ar_constraints">AR_constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 \times q)</code> constraint matrix <code class="reqn">C</code> specifying linear constraints
to the autoregressive parameters. The constraints are of the form
<code class="reqn">(\varphi_{1},...,\varphi_{M}) = C\psi</code>, where <code class="reqn">\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 \times 1),\ m=1,...,M</code>,
contains the coefficient matrices and <code class="reqn">\psi</code> <code class="reqn">(q \times 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set <code class="reqn">C =</code>
[<code>I:...:I</code>]' <code class="reqn">(Mpd^2 \times pd^2)</code> where <code>I = diag(p*d^2)</code>.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_mean_constraints">mean_constraints</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a list of two elements, <code class="reqn">R</code> in the first element and <code class="reqn">r</code> in the second element,
specifying linear constraints on the transition weight parameters <code class="reqn">\alpha</code>.
The constraints are of the form <code class="reqn">\alpha = R\xi + r</code>, where <code class="reqn">R</code> is a known <code class="reqn">(a\times l)</code>
constraint matrix of full column rank (<code class="reqn">a</code> is the dimension of <code class="reqn">\alpha</code>), <code class="reqn">r</code> is a known <code class="reqn">(a\times 1)</code> constant,
and <code class="reqn">\xi</code> is an unknown <code class="reqn">(l\times 1)</code> parameter. <strong>Alternatively</strong>, set <code class="reqn">R=0</code> to constrain the
weight parameters to the constant <code class="reqn">r</code> (in this case, <code class="reqn">\alpha</code> is dropped from the constrained parameter vector).</p>
</td></tr>
<tr><td><code id="STVAR_+3A_b_constraints">B_constraints</code></td>
<td>
<p>a <code class="reqn">(d \times d)</code> matrix with its entries imposing constraints on the impact matrix <code class="reqn">B_t</code>:
<code>NA</code> indicating that the element is unconstrained, a positive value indicating strict positive sign constraint,
a negative value indicating strict negative sign constraint, and zero indicating that the element is constrained to zero.
Currently only available for models with <code>identification="heteroskedasticity"</code> or <code>"non-Gaussianity"</code> due to the
(in)availability of appropriate parametrizations that allow such constraints to be imposed.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_penalized">penalized</code></td>
<td>
<p>Perform penalized LS estimation that minimizes penalized RSS in which estimates close to breaking or not satisfying the
usual stability condition are penalized? If <code>TRUE</code>, the tuning parameter is set by the argument <code>penalty_params[2]</code>,
and the penalization starts when the eigenvalues of the companion form AR matrix are larger than <code>1 - penalty_params[1]</code>.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_penalty_params">penalty_params</code></td>
<td>
<p>a numeric vector with two positive elements specifying the penalization parameters:
the first element determined how far from the boundary of the stability region the penalization starts
(a number between zero and one, smaller number starts penalization closer to the boundary) and the second element
is a tuning parameter for the penalization (a positive real number, a higher value penalizes non-stability more).</p>
</td></tr>
<tr><td><code id="STVAR_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
<tr><td><code id="STVAR_+3A_object">object</code></td>
<td>
<p>object of class <code>'stvar'</code>.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_digits">digits</code></td>
<td>
<p>number of digits to be printed.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_standard_error_print">standard_error_print</code></td>
<td>
<p>if set to <code>TRUE</code>, instead of printing the estimates,
prints the approximate standard errors using square roots of the diagonal of inverse
of the observed information matrix.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_x">x</code></td>
<td>
<p>an object of class <code>'stvar'</code>.</p>
</td></tr>
<tr><td><code id="STVAR_+3A_plot_type">plot_type</code></td>
<td>
<p>should the series be plotted with the estimated transition weights
or conditional means?</p>
</td></tr>
<tr><td><code id="STVAR_+3A_summary_print">summary_print</code></td>
<td>
<p>if set to <code>TRUE</code> then the print
will include log-likelihood and information criteria values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is provided, then also residuals are computed and included in the returned object.
</p>
<p>The plot displays the time series together with estimated transition weights.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td></tr>
<tr><td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td></tr>
<tr><td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td></tr>
<tr><td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td></tr>
<tr><td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td></tr>
<tr><td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td></tr>
<tr><td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td></tr>
<tr><td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td></tr>
<tr><td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td></tr>
<tr><td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td></tr>
<tr><td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td></tr>
<tr><td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>The seeds used in the estimation in <code>fitSTVAR</code>, if applicable.</p>
</td></tr>
<tr><td><code>LS_estimates</code></td>
<td>
<p>The least squares estimates of the parameters in the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code> (intercepts replaced by unconditional means
if mean parametrization is used), if applicable.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>logLik(stvar)</code>: Log-likelihood method
</p>
</li>
<li> <p><code>residuals(stvar)</code>: residuals method to extract Pearson residuals
</p>
</li>
<li> <p><code>summary(stvar)</code>: summary method
</p>
</li>
<li> <p><code>plot(stvar)</code>: plot method for class 'stvar'
</p>
</li>
<li> <p><code>print(stvar)</code>: print method
</p>
</li></ul>


<h3>About S3 methods</h3>

<p>If data is not provided, only the <code>print</code> and <code>simulate</code> methods are available.
If data is provided, then in addition to the ones listed above, <code>predict</code> method is also available.
See <code>?simulate.stvar</code> and <code>?predict.stvar</code> for details about the usage.
</p>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hubrich K., Teräsvirta. T. 2013. Thresholds and Smooth Transitions in Vector Autoregressive Models.
<em>CREATES Research Paper 2013-18, Aarhus University.</em>
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H., Netšunajev A. 2017. Structural vector autoregressions with smooth transition in variances.
<em>Journal of Economic Dynamics &amp; Control</em>, <strong>84</strong>, 43-57.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+swap_parametrization">swap_parametrization</a></code>, <code><a href="#topic+alt_stvar">alt_stvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Below examples use the example data "gdpdef", which is a two-variate quarterly data
# of U.S. GDP and GDP implicit price deflator covering the period from 1959Q1 to 2019Q4.

# Gaussian STVAR p=1, M=2, model with the weighted relative stationary densities
# of the regimes as the transition weight function:
theta_122relg &lt;- c(0.734054, 0.225598, 0.705744, 0.187897, 0.259626, -0.000863,
  -0.3124, 0.505251, 0.298483, 0.030096, -0.176925, 0.838898, 0.310863, 0.007512,
  0.018244, 0.949533, -0.016941, 0.121403, 0.573269)
mod122 &lt;- STVAR(data=gdpdef, p=1, M=2, params=theta_122relg)
print(mod122) # Printout of the model
summary(mod122) # Summary printout
plot(mod122) # Plot the transition weights
plot(mod122, plot_type="cond_mean") # Plot one-step conditional means

# Logistic Student's t STVAR with p=1, M=2, and the first lag of the second variable
# as the switching variable:
params12 &lt;- c(0.62906848, 0.14245295, 2.41245785, 0.66719269, 0.3534745, 0.06041779, -0.34909745,
  0.61783824, 0.125769, -0.04094521, -0.99122586, 0.63805416, 0.371575, 0.00314754, 0.03440824,
  1.29072533, -0.06067807, 0.18737385, 1.21813844, 5.00884263, 7.70111672)
fit12 &lt;- STVAR(data=gdpdef, p=1, M=2, params=params12, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student")
summary(fit12) # Summary printout
plot(fit12) # Plot the transition weights

# Threshold STVAR with p=1, M=2, the first lag of the second variable as switching variable:
params12thres &lt;- c(0.5231, 0.1015, 1.9471, 0.3253, 0.3476, 0.0649, -0.035, 0.7513, 0.1651,
 -0.029, -0.7947, 0.7925, 0.4233, 5e-04, 0.0439, 1.2332, -0.0402, 0.1481, 1.2036)
mod12thres &lt;- STVAR(data=gdpdef, p=1, M=2, params=params12thres, weight_function="threshold",
  weightfun_pars=c(2, 1))
mod12thres # Printout of the model

# Student's t logistic STVAR with p=2, M=2 with the second lag of the second variable
# as the switching variable and structural shocks identified by heteroskedasticity;
# the model created without data:
params22log &lt;- c(0.357, 0.107, 0.356, 0.086, 0.14, 0.035, -0.165, 0.387, 0.452,
 0.013, 0.228, 0.336, 0.239, 0.024, -0.021, 0.708, 0.063, 0.027, 0.009, 0.197,
  -0.03, 0.24, -0.76, -0.02, 3.36, 0.86, 0.1, 0.2, 7)
mod222logtsh &lt;- STVAR(p=2, M=2, d=2, params=params22log, weight_function="logistic",
 weightfun_pars=c(2, 2), cond_dist="Student", identification="heteroskedasticity")
print(mod222logtsh) # Printout of the model

# STVAR p=2, M=2, model with exogenous transition weights and mutually independent
# Student's t shocks:
set.seed(1); tw1 &lt;- runif(nrow(gdpdef)-2) # Transition weights of Regime 1
params22exoit &lt;- c(0.357, 0.107, 0.356, 0.086, 0.14, 0.035, -0.165, 0.387, 0.452,
 0.013, 0.228, 0.336, 0.239, 0.024, -0.021, 0.708, 0.063, 0.027, 0.009, 0.197,
 -0.1, 0.2, -0.15, 0.13, 0.21, 0.15, 0.11, -0.09, 3, 4)
mod222exoit &lt;- STVAR(p=2, M=2, d=2, params=params22exoit, weight_function="exogenous",
 weightfun_pars=cbind(tw1, 1-tw1), cond_dist="ind_Student")
print(mod222exoit) # Printout of the model

# Linear Gaussian VAR(p=1) model:
theta_112 &lt;- c(0.649526, 0.066507, 0.288526, 0.021767, -0.144024, 0.897103,
  0.601786, -0.002945, 0.067224)
mod112 &lt;- STVAR(data=gdpdef, p=1, M=1, params=theta_112)
summary(mod112) # Summary printout
</code></pre>

<hr>
<h2 id='stvar_to_sstvars110'>Update STVAR model estimated with a version of the package &lt;1.1.0 to
be compatible with the versions &gt;=1.1.0.</h2><span id='topic+stvar_to_sstvars110'></span>

<h3>Description</h3>

<p><code>update_stvar_to_sstvar110</code> updates a STVAR model estimated with a version of
the package &lt;1.1.0 to be compatible with the versions &gt;=1.1.0 by adding the elements
<code>$penalized</code>, <code>$penalty_params</code>, and <code>$allow_unstab</code> to the model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stvar_to_sstvars110(stvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stvar_to_sstvars110_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is useful when a STVAR model estimated with a version of the package &lt;1.1.0.
Does not do anything if the elements <code>$penalized</code>, <code>$penalty_params</code>, and <code>$allow_unstab</code>
are already containing in the model object.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'stvar'</code> with the elements <code>$penalized</code>,
<code>$penalty_params</code>, and <code>$allow_unstab</code> added to it if they were missing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Linear Gaussian VAR(p=1) model:
theta_112 &lt;- c(0.649526, 0.066507, 0.288526, 0.021767, -0.144024, 0.897103,
  0.601786, -0.002945, 0.067224)
mod112 &lt;- STVAR(data=gdpdef, p=1, M=1, params=theta_112)

# Update to include the new elements (does not do anything if they are already
# included):
mod112 &lt;- stvar_to_sstvars110(mod112)
</code></pre>

<hr>
<h2 id='swap_B_signs'>Swap all signs in pointed columns of the impact matrix of a structural STVAR model
that is identified by heteroskedasticity or non-Gaussianity</h2><span id='topic+swap_B_signs'></span>

<h3>Description</h3>

<p><code>swap_B_signs</code> swaps all signs in pointed columns of the impact matrix of
a structural STVAR model that is identified by heteroskedasticity or non-Gaussianity. For ind skewed t
models, also the signs of the skewness parameters are swapped accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_B_signs(stvar, which_to_swap, calc_std_errors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swap_B_signs_+3A_stvar">stvar</code></td>
<td>
<p>a class 'stvar' object defining a structural STVAR model that is identified by heteroskedasticity
or non-Gaussianity, typically created with <code>fitSSTVAR</code>.</p>
</td></tr>
<tr><td><code id="swap_B_signs_+3A_which_to_swap">which_to_swap</code></td>
<td>
<p>a numeric vector of length at most <code class="reqn">d</code> and elemnts in <code class="reqn">1,..,d</code>
specifying the columns of the impact matrix whose sign should be swapped.</p>
</td></tr>
<tr><td><code id="swap_B_signs_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All signs in any column of the impact matrix can be swapped without changing the implied reduced form model,
but for ind skewed t models, also the signs of the corresponding skewness parameter values need to be swapped.
For model identified by non-Gaussianity, the signs of the columns of the impact matrices of all the regimes are
swapped accordingly. Note that the sign constraints imposed on the impact matrix via <code>B_constraints</code> are also
swapped in the corresponding columns accordingly.
</p>
<p>Also the order of the columns of the impact matrix can be changed (without changing the implied reduced
form model) as long as the ordering of other related parameters is also changed accordingly. This can be
done with the function <code>reorder_B_columns</code>.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td></tr>
<tr><td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td></tr>
<tr><td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td></tr>
<tr><td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td></tr>
<tr><td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td></tr>
<tr><td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td></tr>
<tr><td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td></tr>
<tr><td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td></tr>
<tr><td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td></tr>
<tr><td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td></tr>
<tr><td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td></tr>
<tr><td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>The seeds used in the estimation in <code>fitSTVAR</code>, if applicable.</p>
</td></tr>
<tr><td><code>LS_estimates</code></td>
<td>
<p>The least squares estimates of the parameters in the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code> (intercepts replaced by unconditional means
if mean parametrization is used), if applicable.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Lütkepohl H., Netšunajev A. 2018. Structural vector autoregressions with smooth transition in variances.
<em>Journal of Economic Dynamics &amp; Control</em>, <strong>84</strong>, 43-57.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+fitSSTVAR">fitSSTVAR</a></code>, <code><a href="#topic+reorder_B_columns">reorder_B_columns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a structural two-variate Student's t STVAR p=2, M=2, model with logistic transition
# weights and the first lag of the second variable as the switching variable, and shocks
# identified by heteroskedasticity:
theta_222logt &lt;- c(0.356914, 0.107436, 0.356386, 0.086330, 0.139960, 0.035172, -0.164575,
  0.386816, 0.451675, 0.013086, 0.227882, 0.336084, 0.239257, 0.024173, -0.021209, 0.707502,
  0.063322, 0.027287, 0.009182, 0.197066, -0.03, 0.24, -0.76, -0.02, 3.36, 0.86, 0.1, 0.2, 7)
mod222logt &lt;- STVAR(p=2, M=2, d=2, params=theta_222logt, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student", identification="heteroskedasticity")

# Print the parameter values, W and lambdas are printed in the bottom:
mod222logt

# Swap the signs of the first column of W (or equally the impact matrix):
mod222logt2 &lt;- swap_B_signs(mod222logt, which_to_swap=1)
mod222logt2 # The signs of the first column of the impact matrix are swapped

# Swap the signs of the second column of the impact matrix:
mod222logt3 &lt;- swap_B_signs(mod222logt, which_to_swap=2)
mod222logt3 # The signs of the second column of the impact matrix are swapped

# Swap the signs of both columns of the impact matrix:
mod222logt4 &lt;- swap_B_signs(mod222logt, which_to_swap=1:2)
mod222logt4 # The signs of both columns of the impact matrix are swapped
</code></pre>

<hr>
<h2 id='swap_parametrization'>Swap the parametrization of a STVAR model</h2><span id='topic+swap_parametrization'></span>

<h3>Description</h3>

<p><code>swap_parametrization</code> swaps the parametrization of a STVAR model
to <code>"mean"</code> if the current parametrization is <code>"intercept"</code>, and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_parametrization(stvar, calc_std_errors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swap_parametrization_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
<tr><td><code id="swap_parametrization_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>swap_parametrization</code> is a convenient tool if you have estimated the model in
&quot;intercept&quot; parametrization but wish to work with &quot;mean&quot; parametrization in the future, or vice versa.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>'stvar'</code> defining a smooth transition VAR model. The returned list
contains the following components (some of which may be <code>NULL</code> depending on the use case):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list describing the model structure.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>The parameters of the model.</p>
</td></tr>
<tr><td><code>std_errors</code></td>
<td>
<p>Approximate standard errors of the parameters, if calculated.</p>
</td></tr>
<tr><td><code>transition_weights</code></td>
<td>
<p>The transition weights of the model.</p>
</td></tr>
<tr><td><code>regime_cmeans</code></td>
<td>
<p>Conditional means of the regimes, if data is provided.</p>
</td></tr>
<tr><td><code>total_cmeans</code></td>
<td>
<p>Total conditional means of the model, if data is provided.</p>
</td></tr>
<tr><td><code>total_ccovs</code></td>
<td>
<p>Total conditional covariances of the model, if data is provided.</p>
</td></tr>
<tr><td><code>uncond_moments</code></td>
<td>
<p>A list of unconditional moments including regime autocovariances, variances, and means.</p>
</td></tr>
<tr><td><code>residuals_raw</code></td>
<td>
<p>Raw residuals, if data is provided.</p>
</td></tr>
<tr><td><code>residuals_std</code></td>
<td>
<p>Standardized residuals, if data is provided.</p>
</td></tr>
<tr><td><code>structural_shocks</code></td>
<td>
<p>Recovered structural shocks, if applicable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood of the model, if data is provided.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The values of the information criteria (AIC, HQIC, BIC) for the model, if data is provided.</p>
</td></tr>
<tr><td><code>all_estimates</code></td>
<td>
<p>The parameter estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>all_logliks</code></td>
<td>
<p>The log-likelihood of the estimates from all estimation rounds, if applicable.</p>
</td></tr>
<tr><td><code>which_converged</code></td>
<td>
<p>Indicators of which estimation rounds converged, if applicable.</p>
</td></tr>
<tr><td><code>which_round</code></td>
<td>
<p>Indicators of which round of optimization each estimate belongs to, if applicable.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>The seeds used in the estimation in <code>fitSTVAR</code>, if applicable.</p>
</td></tr>
<tr><td><code>LS_estimates</code></td>
<td>
<p>The least squares estimates of the parameters in the form
<code class="reqn">(\phi_{1,0},...,\phi_{M,0},\varphi_1,...,\varphi_M,\alpha</code> (intercepts replaced by unconditional means
if mean parametrization is used), if applicable.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Anderson H., Vahid F. 1998. Testing multiple equation systems for common nonlinear components.
<em>Journal of Econometrics</em>, <strong>84</strong>:1, 1-36.
</p>
</li>
<li><p> Hubrich K., Teräsvirta. T. 2013. Thresholds and Smooth Transitions in Vector Autoregressive Models.
<em>CREATES Research Paper 2013-18, Aarhus University.</em>
</p>
</li>
<li><p> Lanne M., Virolainen S. 2025. A Gaussian smooth transition vector autoregressive model:
An application to the macroeconomic effects of severe weather shocks. Unpublished working
paper, available as arXiv:2403.14216.
</p>
</li>
<li><p> Kheifets I.L., Saikkonen P.J. 2020. Stationarity and ergodicity of Vector STAR models.
<em>Econometric Reviews</em>, <strong>39</strong>:4, 407-414.
</p>
</li>
<li><p> Lütkepohl H., Netšunajev A. 2017. Structural vector autoregressions with smooth transition in variances.
<em>Journal of Economic Dynamics &amp; Control</em>, <strong>84</strong>, 43-57.
</p>
</li>
<li><p> Tsay R. 1998. Testing and Modeling Multivariate Threshold Models.
<em>Journal of the American Statistical Association</em>, <strong>93</strong>:443, 1188-1202.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and
smooth transition vector autoregressive models. Unpublished working
paper, available as arXiv:2404.19707.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Create a Gaussian STVAR p=1, M=2 model with the weighted relative stationary densities
# of the regimes as the transition weight function; use the intercept parametrization:
theta_122relg &lt;- c(0.734054, 0.225598, 0.705744, 0.187897, 0.259626, -0.000863,
  -0.3124, 0.505251, 0.298483, 0.030096, -0.176925, 0.838898, 0.310863, 0.007512,
  0.018244, 0.949533, -0.016941, 0.121403, 0.573269)
mod122 &lt;- STVAR(p=1, M=2, d=2, params=theta_122relg, parametrization="intercept")
mod122$params[1:4] # The intercept parameters

# Swap from the intercept parametrization to mean parametrization:
mod122mu &lt;- swap_parametrization(mod122)
mod122mu$params[1:4] # The mean parameters

# Swap back to the intercept parametrization:
mod122int &lt;- swap_parametrization(mod122mu)
mod122int$params[1:4] # The intercept parameters

## Create a linear VAR(p=1) model with the intercept parametrization, include
# the two-variate data gdpdef to the model and calculate approximate standard errors:
theta_112 &lt;- c(0.649526, 0.066507, 0.288526, 0.021767, -0.144024, 0.897103,
  0.601786, -0.002945, 0.067224)
mod112 &lt;- STVAR(data=gdpdef, p=1, M=1, params=theta_112, parametrization="intercept",
  calc_std_errors=TRUE)
print(mod112, standard_error_print=TRUE) # Standard errors are printed for the intercepts

# To obtain standard errors for the unconditional means instead of the intercepts,
# swap to mean parametrization:
mod112mu &lt;- swap_parametrization(mod112, calc_std_errors=TRUE)
print(mod112mu, standard_error_print=TRUE) # Standard errors are printed for the means
</code></pre>

<hr>
<h2 id='uncond_moments'>Calculate the unconditional means, variances, the first p autocovariances, and the first p autocorrelations
of the regimes of the model.</h2><span id='topic+uncond_moments'></span>

<h3>Description</h3>

<p><code>uncond_moments</code> calculates the unconditional means, variances, the first p autocovariances,
and the first p autocorrelations of the regimes of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncond_moments(stvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uncond_moments_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with three components:
</p>

<dl>
<dt><code>$regime_means</code></dt><dd><p>a <code class="reqn">M \times d</code> matrix vector containing the unconditional mean of the regime
<code class="reqn">m</code> in the <code class="reqn">m</code>th column.</p>
</dd>
<dt><code>$regime_vars</code></dt><dd><p>a <code class="reqn">M \times d</code> matrix vector containing the unconditional marginal variances
of the regime <code class="reqn">m</code> in the <code class="reqn">m</code>th column.</p>
</dd>
<dt><code>$regime_autocovs</code></dt><dd><p>an <code class="reqn">(d x d x p+1, M)</code> array containing the lag 0,1,...,p autocovariances of the process.
The subset <code>[, , j, m]</code> contains the lag <code>j-1</code> autocovariance matrix (lag zero for the variance) for
the regime <code class="reqn">m</code>.</p>
</dd>
<dt><code>$regime_autocors</code></dt><dd><p>the autocovariance matrices scaled to autocorrelation matrices.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Lütkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Two-variate Gaussian STVAR p=1, M=2 model with the weighted relative stationary
# densities of the regimes as the transition weight function:
theta_122relg &lt;- c(0.734054, 0.225598, 0.705744, 0.187897, 0.259626, -0.000863,
-0.3124, 0.505251, 0.298483, 0.030096, -0.176925, 0.838898, 0.310863, 0.007512,
0.018244, 0.949533, -0.016941, 0.121403, 0.573269)
mod122 &lt;- STVAR(data=gdpdef, p=1, M=2, params=theta_122relg, weight_function="relative_dens")

# Calculate the unconditional moments of model:
tmp122 &lt;- uncond_moments(mod122)

# Print the various unconditional moments calculated:
tmp122$regime_means[,1] # Unconditional means of the first regime
tmp122$regime_means[,2] # Unconditional means of the second regime
tmp122$regime_vars[,1] # Unconditional variances of the first regime
tmp122$regime_vars[,2] # Unconditional variances of the second regime
tmp122$regime_autocovs[, , , 1] # a.cov. matrices of the first regime
tmp122$regime_autocovs[, , , 2] # a.cov. matrices of the second regime
tmp122$regime_autocors[, , , 1] # a.cor. matrices of the first regime
tmp122$regime_autocors[, , , 2] # a.cor. matrices of the second regime

# A two-variate linear Gaussian VAR p=1 model:
theta_112 &lt;- c(0.649526, 0.066507, 0.288526, 0.021767, -0.144024, 0.897103,
 0.601786, -0.002945, 0.067224)
mod112 &lt;- STVAR(data=gdpdef, p=1, M=1, params=theta_112)

# Calculate the unconditional moments of model:
tmp112 &lt;- uncond_moments(mod112)

# Print the various unconditional moments calculated:
tmp112$regime_means # Unconditional means
tmp112$regime_vars # Unconditional variances
tmp112$regime_autocovs # Unconditional autocovariance matrices
tmp112$regime_autocovs[, , 1, 1] # a.cov. matrix of lag zero (of the first regime)
tmp112$regime_autocovs[, , 2, 1] # a.cov. matrix of lag one (of the first regime)
tmp112$regime_autocors # Unconditional autocorrelation matrices
</code></pre>

<hr>
<h2 id='unvec'>Reverse vectorization operator</h2><span id='topic+unvec'></span>

<h3>Description</h3>

<p><code>unvec</code> forms a square matrix from a vector of
stacked columns, stacked by <code>vec</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unvec(d, a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unvec_+3A_d">d</code></td>
<td>
<p>the number of rows in the square matrix to be formed.</p>
</td></tr>
<tr><td><code id="unvec_+3A_a">a</code></td>
<td>
<p>a size <code class="reqn">(d^2x1)</code> vector to be unvectorized into a <code class="reqn">(dxd)</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of size <code class="reqn">(dxd)</code>.
</p>

<hr>
<h2 id='unvech'>Reverse operator of the parsimonious vectorization operator <code>vech</code></h2><span id='topic+unvech'></span>

<h3>Description</h3>

<p><code>unvech</code> creates a symmetric matrix from the given vector by
copying the lower triangular part to be the upper triangular part as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unvech(d, a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unvech_+3A_d">d</code></td>
<td>
<p>number of rows the square matrix to be formed.</p>
</td></tr>
<tr><td><code id="unvech_+3A_a">a</code></td>
<td>
<p>a size <code class="reqn">(d(d+1)/2x1)</code> vector to be unvectorized into a symmetric <code class="reqn">(dxd)</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a symmetric matrix of size <code class="reqn">(dxd)</code>.
</p>

<hr>
<h2 id='unWvec'>Reverse vectorization operator that restores zeros</h2><span id='topic+unWvec'></span>

<h3>Description</h3>

<p><code>unWvec</code> forms a square matrix from a vector of
stacked columns where zeros are removed according to impact
matrix constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unWvec(Wvector, d, B_constraints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unWvec_+3A_wvector">Wvector</code></td>
<td>
<p>a length <code class="reqn">d^2 - n_zeros</code> vector where <code class="reqn">n_zeros</code> is the
number of zero entries in the impact matrix.</p>
</td></tr>
<tr><td><code id="unWvec_+3A_d">d</code></td>
<td>
<p>the number of rows in the square matrix to be formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code class="reqn">(d x d)</code> impact matrix <code class="reqn">W</code>.
</p>

<hr>
<h2 id='usacpu'>A monthly  U.S. data covering the period from 1987:4 to 2024:12 (453 observations) and consisting six variables.
First, the climate policy uncertainty index (CPUI) (Gavridiilis, 2021), which is a news based measure of climate policy uncertainty.
Second, the economic policy uncertainty index (EPUI), which is a news based measure of economic policy uncertainty, including also
components quantifying the present value of future scheduled tax code expirations and disagreement among professional forecasters
over future goverment purchases and consumer prices.
Third, the log-difference of real indsitrial production index (IPI).
Fourth, the log-difference of the consumer price index (CPI).
Fifth, the log-difference of the producer price index (PPI).
Sixth, an interest rate variable, which is the effective federal funds rate that is replaced by the
the Wu and Xia (2016) shadow rate during zero-lower-bound periods. The Wu and Xia (2016) shadow rate is not bounded by the zero
lower bound and also quantifies unconventional monetary policy measures, while it closely follows the federal funds rate when the
zero lower bound does not bind. This is the dataset used in Virolainen (2025)</h2><span id='topic+usacpu'></span>

<h3>Description</h3>

<p>A monthly  U.S. data covering the period from 1987:4 to 2024:12 (453 observations) and consisting six variables.
First, the climate policy uncertainty index (CPUI) (Gavridiilis, 2021), which is a news based measure of climate policy uncertainty.
Second, the economic policy uncertainty index (EPUI), which is a news based measure of economic policy uncertainty, including also
components quantifying the present value of future scheduled tax code expirations and disagreement among professional forecasters
over future goverment purchases and consumer prices.
Third, the log-difference of real indsitrial production index (IPI).
Fourth, the log-difference of the consumer price index (CPI).
Fifth, the log-difference of the producer price index (PPI).
Sixth, an interest rate variable, which is the effective federal funds rate that is replaced by the
the Wu and Xia (2016) shadow rate during zero-lower-bound periods. The Wu and Xia (2016) shadow rate is not bounded by the zero
lower bound and also quantifies unconventional monetary policy measures, while it closely follows the federal funds rate when the
zero lower bound does not bind. This is the dataset used in Virolainen (2025)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usacpu
</code></pre>


<h3>Format</h3>

<p>A numeric matrix of class <code>'ts'</code> with 443 rows and 4 columns with one time series in each column:
</p>

<dl>
<dt>First column (CPUI):</dt><dd><p>The climate policy uncertainty index, <a href="https://www.policyuncertainty.com/climate_uncertainty.html">https://www.policyuncertainty.com/climate_uncertainty.html</a>.</p>
</dd>
<dt>Second column (EPUI):</dt><dd><p>The economic policy uncertainty index, <a href="https://www.policyuncertainty.com/us_monthly.html">https://www.policyuncertainty.com/us_monthly.html</a>.</p>
</dd>
<dt>Third column (IPI):</dt><dd><p>The log-difference of real indsitrial production index, <a href="https://fred.stlouisfed.org/series/INDPRO">https://fred.stlouisfed.org/series/INDPRO</a>.</p>
</dd>
<dt>Fourth column (CPI):</dt><dd><p>The log-difference of the consumer price index, <a href="https://fred.stlouisfed.org/series/CPIAUCSL">https://fred.stlouisfed.org/series/CPIAUCSL</a>.</p>
</dd>
<dt>Fifth column (PPI):</dt><dd><p>The log-difference of the producer price index, <a href="https://fred.stlouisfed.org/series/PPIACO">https://fred.stlouisfed.org/series/PPIACO</a>.</p>
</dd>
<dt>Sixth column (RATE):</dt><dd><p>The Federal funds rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016) shadow rate,
<a href="https://fred.stlouisfed.org/series/FEDFUNDS">https://fred.stlouisfed.org/series/FEDFUNDS</a>, <a href="https://www.atlantafed.org/cqer/research/wu-xia-shadow-federal-funds-rate">https://www.atlantafed.org/cqer/research/wu-xia-shadow-federal-funds-rate</a>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Federal Reserve Bank of St. Louis database and the Federal Reserve Bank of Atlanta's website
</p>


<h3>References</h3>


<ul>
<li><p> K. Gavriilidis, 2021. Measuring climate policy uncertainty. <a href="https://www.ssrn.com/abstract=3847388">https://www.ssrn.com/abstract=3847388</a>.
</p>
</li>
<li><p> Federal Reserve Bank of Chicago. 2023. Monthly GDP Growth Rate Data. <a href="https://www.chicagofed.org/publications/bbki/index">https://www.chicagofed.org/publications/bbki/index</a>.
</p>
</li>
<li><p> Virolainen S. 2025. Identification by non-Gaussianity in structural threshold and smooth transition vector
autoregressive models. Unpublished working paper, available as arXiv.2404.19707.
</p>
</li>
<li><p> Wu J. and Xia F. 2016. Measuring the macroeconomic impact of monetary policy at the zero lower bound.
<em>Journal of Money, Credit and Banking</em>, 48(2-3): 253-291.
</p>
</li></ul>


<hr>
<h2 id='usamone'>A quarterly U.S. data covering the period from 1954Q3 to 2021Q4 (270 observations) and consisting three variables:
cyclical component of the log of real GDP, the log-difference of GDP implicit price deflator, and an interest rate variable.
The interest rate variable is the effective federal funds rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016)
shadow rate, which is not constrained by the zero lower bound and also quantifies unconventional monetary policy measures.
The log-differences of the GDP deflator and producer price index are multiplied by hundred.</h2><span id='topic+usamone'></span>

<h3>Description</h3>

<p>The cyclical component of the log of real GDP was obtained by applying a one-sided Hodrick-Prescott (HP) filter with the
standard smoothing parameter lambda=1600. The one-sided filter was obtained from the two-sided HP filter by applying the
filter up to horizon t, taking the last observation, and repeating this procedure for the full sample t=1,...,T.
In order to allow the series to start from any phase of the cycle, we applied the one-sided filter to the full available
sample from 1947Q1 to 2021Q1 before extracting our sample period from it. We computed the two-sided HP filters with the R
package lpirfs (Adämmer, 2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usamone
</code></pre>


<h3>Format</h3>

<p>A numeric matrix of class <code>'ts'</code> with 270 rows and 4 columns with one time series in each column:
</p>

<dl>
<dt>First column (GDP):</dt><dd><p>The cyclical component of the log of real GDP, <a href="https://fred.stlouisfed.org/series/GDPC1">https://fred.stlouisfed.org/series/GDPC1</a>.</p>
</dd>
<dt>Second column (GDPDEF):</dt><dd><p>The log-difference of GDP implicit price deflator, <a href="https://fred.stlouisfed.org/series/GDPDEF">https://fred.stlouisfed.org/series/GDPDEF</a>.</p>
</dd>
<dt>Third column (RATE):</dt><dd><p>The Federal funds rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016) shadow rate,
<a href="https://fred.stlouisfed.org/series/FEDFUNDS">https://fred.stlouisfed.org/series/FEDFUNDS</a>, <a href="https://www.atlantafed.org/cqer/research/wu-xia-shadow-federal-funds-rate">https://www.atlantafed.org/cqer/research/wu-xia-shadow-federal-funds-rate</a>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Federal Reserve Bank of St. Louis database and the Federal Reserve Bank of Atlanta's website
</p>


<h3>References</h3>


<ul>
<li><p> Adämmer P. 2021. lprfs: Local Projections Impulse Response Functions. R package version: 0.2.0,
<a href="https://CRAN.R-project.org/package=lpirfs">https://CRAN.R-project.org/package=lpirfs</a>.
</p>
</li>
<li><p> Wu J. and Xia F. 2016. Measuring the macroeconomic impact of monetary policy at the zero lower bound.
<em>Journal of Money, Credit and Banking</em>, 48(2-3): 253-291.
</p>
</li></ul>


<hr>
<h2 id='VAR_pcovmat'>Calculate the dp-dimensional covariance matrix of p consecutive
observations of a VAR process</h2><span id='topic+VAR_pcovmat'></span>

<h3>Description</h3>

<p><code>VAR_pcovmat</code> calculate the dp-dimensional covariance matrix of p consecutive
observations of a VAR process with the algorithm proposed by McElroy (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAR_pcovmat(p, d, all_Am, Omega_m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VAR_pcovmat_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order</p>
</td></tr>
<tr><td><code id="VAR_pcovmat_+3A_d">d</code></td>
<td>
<p>the number of time series in the system, i.e., the dimension</p>
</td></tr>
<tr><td><code id="VAR_pcovmat_+3A_all_am">all_Am</code></td>
<td>
<p><code>[d, d, p]</code> array containing the AR coefficient matrices</p>
</td></tr>
<tr><td><code id="VAR_pcovmat_+3A_omega_m">Omega_m</code></td>
<td>
<p>the <code class="reqn">(d\times d)</code> positive definite error term covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the code in this function is adapted from the one provided in the
supplementary material of McElroy (2017). Reproduced under GNU General
Public License, Copyright (2015) Tucker McElroy.
</p>


<h3>Value</h3>

<p>Returns the <code class="reqn">(dp \times dp)</code> covariance matrix.
</p>


<h3>References</h3>


<ul>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li></ul>


<hr>
<h2 id='vec'>Vectorization operator</h2><span id='topic+vec'></span>

<h3>Description</h3>

<p><code>vec</code> stacks columns of the given matrix to form a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vec_+3A_a">A</code></td>
<td>
<p>a size <code class="reqn">(dxd)</code> square matrix to be vectorized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of size <code class="reqn">(d^2x1)</code>.
</p>

<hr>
<h2 id='vech'>Parsimonious vectorization operator for symmetric matrices</h2><span id='topic+vech'></span>

<h3>Description</h3>

<p><code>vech</code> stacks columns of the given matrix from
the principal diagonal downwards (including elements on the diagonal) to form a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vech(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vech_+3A_a">A</code></td>
<td>
<p>a size <code class="reqn">(dxd)</code> symmetric matrix to be vectorized parsimoniously.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of size <code class="reqn">(d(d+1)/2x1)</code>.
</p>

<hr>
<h2 id='Wald_test'>Perform Wald test for a STVAR model</h2><span id='topic+Wald_test'></span>

<h3>Description</h3>

<p><code>Wald_test</code> performs a Wald test for a STVAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wald_test(stvar, A, c)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Wald_test_+3A_stvar">stvar</code></td>
<td>
<p>an object of class <code>'stvar'</code> generated by <code>fitSTVAR</code> or <code>STVAR</code>, containing
the model specified by the alternative hypothesis (i.e., <strong>the unconstrained model</strong>).</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_a">A</code></td>
<td>
<p>a size <code class="reqn">(k\times</code><code>n_params</code><code class="reqn">)</code> matrix with full row rank specifying a part of the null hypothesis
where <code>n_params</code> is the number of parameters in the (unconstrained) model.
See details for more information.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_c">c</code></td>
<td>
<p>a length <code class="reqn">k</code> vector specifying a part of the null hypothesis. See details for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denoting the true parameter value by <code class="reqn">\theta_{0}</code>, we test the null hypothesis <code class="reqn">A\theta_{0}=c</code>.
Under the null, the test statistic is asymptotically <code class="reqn">\chi^2</code>-distributed with <code class="reqn">k</code>
(<code>=nrow(A)</code>) degrees of freedom. The parameter <code class="reqn">\theta_{0}</code> is assumed to have the same form as in
the model supplied in the argument <code>stvar</code> and it is presented in the documentation of the argument
<code>params</code> in the function <code>STVAR</code> (see <code>?STVAR</code>).
</p>
<p><strong>The test is based on the assumption of the standard result of asymptotic normality!</strong>
Also note that this function does <strong>not</strong> check whether the model assumptions hold under the null.
</p>


<h3>Value</h3>

<p>A list with class &quot;hypotest&quot; containing the test results and arguments used to calculate the test.
</p>


<h3>References</h3>


<ul>
<li><p> Buse A. (1982). The Likelihood Ratio, Wald, and Lagrange Multiplier Tests: An Expository Note.
<em>The American Statistician</em>, 36(3a), 153-157.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Rao_test">Rao_test</a></code>, <code><a href="#topic+fitSTVAR">fitSTVAR</a></code>, <code><a href="#topic+STVAR">STVAR</a></code>,
<code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+Portmanteau_test">Portmanteau_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Logistic Student's t STVAR with p=1, M=2, and the first lag of the second variable
 # as the switching variable (parameter values were obtained by maximum likelihood estimation;
 # fitSTVAR is not used here because the estimation is computationally demanding).
 params12 &lt;- c(0.62906848, 0.14245295, 2.41245785, 0.66719269, 0.3534745, 0.06041779, -0.34909745,
  0.61783824, 0.125769, -0.04094521, -0.99122586, 0.63805416, 0.371575, 0.00314754, 0.03440824,
  1.29072533, -0.06067807, 0.18737385, 1.21813844, 5.00884263, 7.70111672)
 fit12 &lt;- STVAR(data=gdpdef, p=1, M=2, params=params12, weight_function="logistic",
  weightfun_pars=c(2, 1), cond_dist="Student")
 fit12

 # Test whether the location parameter equals 1.
 # For this model, the parameter vector has the length 21 and
 # location parameter is in the 19th element:
 A &lt;- matrix(c(rep(0, times=18), 1, 0, 0), nrow=1, ncol=21)
 c &lt;- 1
 Wald_test(fit12, A=A, c=c)

 # Test whether the intercepts and autoregressive matrices are identical across the regimes:
 # fit12 has parameter vector of length 21. In the first regime, the intercepts are in the
 # elements 1,2 and the AR parameters in the elements 5,...,8. In the second regime,
 # the intercepts are in the elements 3,4, and the AR parameters the elements 9,...,12.
 A &lt;- rbind(cbind(diag(2), -diag(2), matrix(0, nrow=2, ncol=17)), # intercepts
            cbind(matrix(0, nrow=4, ncol=4), diag(4), -diag(4), matrix(0, nrow=4, ncol=9))) # AR
 c &lt;- rep(0, times=6)
 Wald_test(fit12, A=A, c=c)
</code></pre>

<hr>
<h2 id='warn_eigens'>Warn about near-unit-roots in some regimes</h2><span id='topic+warn_eigens'></span>

<h3>Description</h3>

<p><code>warn_eigens</code> warns if the model contains near-unit-roots in some regimes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warn_eigens(stvar, tol = 0.002, allow_unstab = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="warn_eigens_+3A_stvar">stvar</code></td>
<td>
<p>object of class <code>"stvar"</code></p>
</td></tr>
<tr><td><code id="warn_eigens_+3A_tol">tol</code></td>
<td>
<p>if eigenvalue is closer than <code>tol</code> to its bound, a warning is thrown</p>
</td></tr>
<tr><td><code id="warn_eigens_+3A_allow_unstab">allow_unstab</code></td>
<td>
<p>If <code>TRUE</code>, estimates not satisfying the stability condition are allowed. Always <code>FALSE</code> if
<code>weight_function="relative_dens"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warns if, for some regime, some moduli of &quot;bold A&quot; eigenvalues are larger than <code>1 - tol</code> or
some eigenvalue of the error term covariance matrix is smaller than <code>tol</code>.
</p>


<h3>Value</h3>

<p>Doesn't return anything.
</p>

<hr>
<h2 id='Wvec'>Vectorization operator that removes zeros</h2><span id='topic+Wvec'></span>

<h3>Description</h3>

<p><code>Wvec</code> stacks columns of the given matrix to form a vector
and removes elements that are zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wvec(W)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Wvec_+3A_w">W</code></td>
<td>
<p>a size <code class="reqn">(dxd)</code> square matrix to be vectorized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length <code class="reqn">d^2 - n_zeros</code> where <code class="reqn">n_zeros</code> is the
number of zero entries in the matrix <code>W</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
