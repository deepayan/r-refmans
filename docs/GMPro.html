<!DOCTYPE html><html><head><title>Help for package GMPro</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GMPro}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DP_SBM'><p>Degree profile graph matching with community detection.</p></a></li>
<li><a href='#DPdistance'><p>calculate degree profile distances between 2 graphs.</p></a></li>
<li><a href='#DPedge'><p>The edge-exploited version of DPmatching.</p></a></li>
<li><a href='#DPmatching'><p>calculate degree profile distances between two graphs and match nodes.</p></a></li>
<li><a href='#EE_SBM'><p>Edge exploited degree profile graph matching with community detection.</p></a></li>
<li><a href='#EEpost'><p>Post-processing step for edge-exploited graph matching.</p></a></li>
<li><a href='#EEpre'><p>Edge exploited degree profile graph matching with preprocessing.</p></a></li>
<li><a href='#SCORE'><p>Spectral Clustering On Ratios-of-Eigenvectors.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graph Matching with Degree Profiles</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Yaofang Hu [aut, cre],
  Wanjie Wang [aut],
  Yi Yu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yaofang Hu &lt;yaofang.hu@u.nus.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for graph matching via nodes' degree profiles are provided in this package. The models we can handle include Erdos-Renyi random graphs and stochastic block models(SBM). More details are in the reference paper: Yaofang Hu, Wanjie Wang and Yi Yu (2020) &lt;<a href="https://arxiv.org/abs/2006.03284">arXiv:2006.03284</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>combinat, stats, transport, igraph</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://arxiv.org/abs/2006.03284">https://arxiv.org/abs/2006.03284</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-23 15:35:42 UTC; yaofang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-25 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DP_SBM'>Degree profile graph matching with community detection.</h2><span id='topic+DP_SBM'></span>

<h3>Description</h3>

<p>Given two community-structured networks, this function first
applies a spectral clustering method <em>SCORE</em> to detect perceivable
communities and then applies <em>DPmatching</em> or <em>EEpost</em> to match
different communities. More details are in <em>SCORE</em>, <em>DPmatching</em>
and <em>EEpost</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DP_SBM(
  A,
  B,
  K,
  fun = c("DPmatching", "EEpost"),
  rep = NULL,
  tau = NULL,
  d = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DP_SBM_+3A_a">A</code>, <code id="DP_SBM_+3A_b">B</code></td>
<td>
<p>Two 0/1 addjacency matrices.</p>
</td></tr>
<tr><td><code id="DP_SBM_+3A_k">K</code></td>
<td>
<p>A positive integer, the number of communities in <code>A</code> and <code>B</code>.</p>
</td></tr>
<tr><td><code id="DP_SBM_+3A_fun">fun</code></td>
<td>
<p>A graph matching algorithm. Choices include
<em>DPmatching</em> and <em>EEpost</em>.</p>
</td></tr>
<tr><td><code id="DP_SBM_+3A_rep">rep</code></td>
<td>
<p>A parameter if choosing <em>EEpost</em> as the initial graph matching algorithm.</p>
</td></tr>
<tr><td><code id="DP_SBM_+3A_tau">tau</code></td>
<td>
<p>Optional parameter if choosing <em>EEpost</em> as the initial graph matching
algorithm. The default value is <code class="reqn">rep/10</code>.</p>
</td></tr>
<tr><td><code id="DP_SBM_+3A_d">d</code></td>
<td>
<p>Optional parameter if choosing <em>EEpost</em> as the initial graph
matching algorithm. The default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graphs to be matched are expected to have community structures.
The result is the collection of all possible permutations on
<code>{1,...,K}</code>.
</p>


<h3>Value</h3>

<p>A list of matching results for all possible permutations on <code>{1,...,K}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Here we use graphs under stochastic block model(SBM).
set.seed(2020)
K = 2; n = 30; s = 1;
P  = matrix(c(1/2, 1/4, 1/4, 1/2), byrow = TRUE, nrow = K)
### define community label matrix Pi
distribution = c(1, 2);
l = sample(distribution, n, replace=TRUE, prob = c(1/2, 1/2))
Pi = matrix(0, n, 2) # label matrix
for (i in 1:n){
  Pi[i, l[i]] = 1
  }
### define the expectation of the parent graph's adjacency matrix
Omega = Pi %*% P %*% t(Pi)
### construct the parent graph G
G = matrix(runif(n*n, 0, 1), nrow = n)
G = G - Omega
temp = G
G[which(temp &gt;0)] = 0
G[which(temp &lt;=0)] = 1
diag(G) = 0
G[lower.tri(G)] = t(G)[lower.tri(G)];
### Sample Graphs Generation
### generate graph A from G
dA = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n)
dA[lower.tri(dA)] = t(dA)[lower.tri(dA)]
A1 = G*dA
indA = sample(1:n, n, replace = FALSE)
labelA = l[indA]
A = A1[indA, indA]
### similarly, generate graph B from G
dB = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n)
dB[lower.tri(dB)] = t(dB)[lower.tri(dB)]
B1 = G*dB
indB = sample(1:n, n, replace = FALSE)
labelB = l[indB]
B = B1[indB, indB]
DP_SBM(A = A, B = B, K = 2, fun = "EEpost", rep = 10, d = 3)

</code></pre>

<hr>
<h2 id='DPdistance'>calculate degree profile distances between 2 graphs.</h2><span id='topic+DPdistance'></span>

<h3>Description</h3>

<p>This function constructs empirical distributions of degree profiles for each
vertex and then calculate distances between each pair of vertices, one from
graph <em>A</em> and the other from graph <em>B</em>. The default distance used is the
1-Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DPdistance(A, B, fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DPdistance_+3A_a">A</code>, <code id="DPdistance_+3A_b">B</code></td>
<td>
<p>Two 0/1 adjacency matrices.</p>
</td></tr>
<tr><td><code id="DPdistance_+3A_fun">fun</code></td>
<td>
<p>Optional function that computes distance between two distributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix. Rows represent nodes in graph <em>A</em> and columns
represent nodes in graph <em>B</em>. Its <em>(i, j)</em> element is the
distance between <code class="reqn">i \in A</code> and <code class="reqn">i \in B</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2020)
n = 10; q = 1/2; s = 1; p = 1
Parent = matrix(rbinom(n*n, 1, q), nrow = n, ncol = n)
Parent[lower.tri(Parent)] = t(Parent)[lower.tri(Parent)]
diag(Parent) &lt;- 0
### Generate graph A
dA = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n);
dA[lower.tri(dA)] = t(dA)[lower.tri(dA)]
A1 = Parent*dA
tmp = rbinom(n, 1, p)
n.A = length(which(tmp == 1))
indA = sample(1:n, n.A, replace = FALSE)
A = A1[indA, indA]
### Generate graph B
dB = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n);
dB[lower.tri(dB)] = t(dB)[lower.tri(dB)]
B1 = Parent*dB
tmp = rbinom(n, 1, p)
n.B = length(which(tmp == 1))
indB = sample(1:n, n.B, replace = FALSE)
B = B1[indB, indB]
DPdistance(A, B)
</code></pre>

<hr>
<h2 id='DPedge'>The edge-exploited version of DPmatching.</h2><span id='topic+DPedge'></span>

<h3>Description</h3>

<p>This functions is based on <em>DPmatching</em>. Instead of
allowing each vertex in <em>A</em> to connect to one and only one vertex in
<em>B</em>, here by introducing parameter <code>d</code>, this function allows for
<code>d</code> edges for each vertex in <em>A</em>. More details are in
<em>DPmatching</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DPedge(A = NULL, B = NULL, d, W = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DPedge_+3A_a">A</code>, <code id="DPedge_+3A_b">B</code></td>
<td>
<p>Two symmetric 0/1 addjacency matrices.</p>
</td></tr>
<tr><td><code id="DPedge_+3A_d">d</code></td>
<td>
<p>A positive integer, indicating the number of candidate matching.</p>
</td></tr>
<tr><td><code id="DPedge_+3A_w">W</code></td>
<td>
<p>A distance matrix between <code>A</code> and <code>B</code>. This argumnet can
be null. If <code>W</code> is null, <code>A</code> and <code>B</code> cannot be null.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Dist</code></td>
<td>
<p>The distance matrix between two graphs.</p>
</td></tr> <tr><td><code>Z</code></td>
<td>
<p>An
indicator matrix. Entry <code class="reqn">Z_{i, j} = 1</code> indicates a matching between
node <code>i</code> in graph <code>A</code> and node <code>j</code> in graph <code>B</code>, 0
otherwise.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2020)
n = 10; q = 1/2; s = 1; p = 1
Parent = matrix(rbinom(n*n, 1, q), nrow = n, ncol = n)
Parent[lower.tri(Parent)] = t(Parent)[lower.tri(Parent)]
diag(Parent) &lt;- 0
### Generate graph A
dA = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n);
dA[lower.tri(dA)] = t(dA)[lower.tri(dA)]
A1 = Parent*dA
tmp = rbinom(n, 1, p)
n.A = length(which(tmp == 1))
indA = sample(1:n, n.A, replace = FALSE)
A = A1[indA, indA]
### Generate graph B
dB = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n);
dB[lower.tri(dB)] = t(dB)[lower.tri(dB)]
B1 = Parent*dB
tmp = rbinom(n, 1, p)
n.B = length(which(tmp == 1))
indB = sample(1:n, n.B, replace = FALSE)
B = B1[indB, indB]
DPmatching(A, B)
W = DPdistance(A, B)
DPedge(A, B, d = 5)
</code></pre>

<hr>
<h2 id='DPmatching'>calculate degree profile distances between two graphs and match nodes.</h2><span id='topic+DPmatching'></span>

<h3>Description</h3>

<p>This function constructs empirical distributions of degree
profiles for each vertex and then calculate distances between each pair of
vertices, one from graph <em>A</em> and the other from graph <em>B</em>. The
default used is the 1-Wasserstein distance. This function also matches
vertices in <em>A</em> with vertices in <em>B</em> via the distance matrix
between <em>A</em> and <em>B</em>. The distance matrix can be null and
<em>DPmatching</em> will calculate it. <em>A</em> and <em>B</em> cannot be null
when the distance matrix is null.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DPmatching(A, B, W = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DPmatching_+3A_a">A</code>, <code id="DPmatching_+3A_b">B</code></td>
<td>
<p>Two 0/1 adjacency matrices.</p>
</td></tr>
<tr><td><code id="DPmatching_+3A_w">W</code></td>
<td>
<p>A distance matrix between <code>A</code> and <code>B</code>, which can be null.
If null, this function will calculate it. More details in
<em>DPdistance</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Dist</code></td>
<td>
<p>The distance matrix between two graphs.</p>
</td></tr> <tr><td><code>match</code></td>
<td>
<p>A
vector containing matching results.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2020)
n = 10; q = 1/2; s = 1; p = 1
Parent = matrix(rbinom(n*n, 1, q), nrow = n, ncol = n)
Parent[lower.tri(Parent)] = t(Parent)[lower.tri(Parent)]
diag(Parent) &lt;- 0
### Generate graph A
dA = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n);
dA[lower.tri(dA)] = t(dA)[lower.tri(dA)]
A1 = Parent*dA
tmp = rbinom(n, 1, p)
n.A = length(which(tmp == 1))
indA = sample(1:n, n.A, replace = FALSE)
A = A1[indA, indA]
### Generate graph B
dB = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n);
dB[lower.tri(dB)] = t(dB)[lower.tri(dB)]
B1 = Parent*dB
tmp = rbinom(n, 1, p)
n.B = length(which(tmp == 1))
indB = sample(1:n, n.B, replace = FALSE)
B = B1[indB, indB]
DPmatching(A, B)
W = DPdistance(A, B)
DPmatching(A, B, W)

</code></pre>

<hr>
<h2 id='EE_SBM'>Edge exploited degree profile graph matching with community detection.</h2><span id='topic+EE_SBM'></span>

<h3>Description</h3>

<p>Given two community-structured networks, this function first
applies a spectral clustering method <em>SCORE</em> to detect perceivable
communities and then applies a certain graph matching method to match
different communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EE_SBM(
  A,
  B,
  K,
  fun = c("DPmatching", "EEpost"),
  rep = NULL,
  tau = NULL,
  d = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EE_SBM_+3A_a">A</code>, <code id="EE_SBM_+3A_b">B</code></td>
<td>
<p>Two 0/1 addjacency matrices.</p>
</td></tr>
<tr><td><code id="EE_SBM_+3A_k">K</code></td>
<td>
<p>A positive integer, indicating the number of communities in <code>A</code>
and <code>B</code>.</p>
</td></tr>
<tr><td><code id="EE_SBM_+3A_fun">fun</code></td>
<td>
<p>A graph matching algorithm. Choices include <em>DPmatching</em> and
<code>EEpost</code>.</p>
</td></tr>
<tr><td><code id="EE_SBM_+3A_rep">rep</code></td>
<td>
<p>Optional parameter if <em>EEpost</em> is the initial graph matching algorithm.</p>
</td></tr>
<tr><td><code id="EE_SBM_+3A_tau">tau</code></td>
<td>
<p>Optional parameter if <em>EEpost</em> is the initial graph matching
algorithm. The default value is <code class="reqn">rep/10</code>.</p>
</td></tr>
<tr><td><code id="EE_SBM_+3A_d">d</code></td>
<td>
<p>Optional parameter if <em>EEpost</em> is the initial graph matching
algorithm. The default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>EE_SBM</em> can be regarded as a post processing version of
<em>DP_SBM</em> using <em>EEpost</em>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>match</code></td>
<td>
<p>A vector containing matching results.</p>
</td></tr> <tr><td><code>FLAG</code></td>
<td>
<p>An
indicator vector indicating whether the matching result is converged, 0 for
No and 1 for Yes.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>### Here we use graphs under stochastic block model(SBM).
set.seed(2020)
K = 2; n = 30; s = 1;
P  = matrix(c(1/2, 1/4, 1/4, 1/2), byrow = TRUE, nrow = K)
### define community label matrix Pi
distribution = c(1, 2);
l = sample(distribution, n, replace=TRUE, prob = c(1/2, 1/2))
Pi = matrix(0, n, 2) # label matrix
for (i in 1:n){
  Pi[i, l[i]] = 1
  }
### define the expectation of the parent graph's adjacency matrix
Omega = Pi %*% P %*% t(Pi)
### construct the parent graph G
G = matrix(runif(n*n, 0, 1), nrow = n)
G = G - Omega
temp = G
G[which(temp &gt;0)] = 0
G[which(temp &lt;=0)] = 1
diag(G) = 0
G[lower.tri(G)] = t(G)[lower.tri(G)];
### Sample Graphs Generation
### generate graph A from G
dA = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n)
dA[lower.tri(dA)] = t(dA)[lower.tri(dA)]
A1 = G*dA
indA = sample(1:n, n, replace = FALSE)
labelA = l[indA]
A = A1[indA, indA]
### similarly, generate graph B from G
dB = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n)
dB[lower.tri(dB)] = t(dB)[lower.tri(dB)]
B1 = G*dB
indB = sample(1:n, n, replace = FALSE)
labelB = l[indB]
B = B1[indB, indB]
EE_SBM(A = A, B = B, K = 2, fun = "EEpost", rep = 10, d = 3)
</code></pre>

<hr>
<h2 id='EEpost'>Post-processing step for edge-exploited graph matching.</h2><span id='topic+EEpost'></span>

<h3>Description</h3>

<p>Funtions <em>DPmatching</em> or <em>DPedge</em> can produce a
preliminary graph matching result. This function, <em>EEPost</em> works on
refining the result iteratively. In addition, <em>EEpost</em> is able to
provide a convergence indicator vector <em>FLAG</em> for each matching as a
reference for the certainty about the matching since in practice,it has
been observed that the true matches usually reach the convergence and stay
the same after a few iterations, while the false matches may keep changing
in the iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EEpost(W = NULL, A, B, rep, tau = NULL, d = NULL, matching = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EEpost_+3A_w">W</code></td>
<td>
<p>A distance matrix.</p>
</td></tr>
<tr><td><code id="EEpost_+3A_a">A</code>, <code id="EEpost_+3A_b">B</code></td>
<td>
<p>Two 0/1 adjacency matrices.</p>
</td></tr>
<tr><td><code id="EEpost_+3A_rep">rep</code></td>
<td>
<p>A positive integer, indicating the number of iterations.</p>
</td></tr>
<tr><td><code id="EEpost_+3A_tau">tau</code></td>
<td>
<p>A positive threshold. The default value is <code class="reqn">rep/10</code>.</p>
</td></tr>
<tr><td><code id="EEpost_+3A_d">d</code></td>
<td>
<p>A positive integer, indicating the number of candidate matching. The
default value is 1.</p>
</td></tr>
<tr><td><code id="EEpost_+3A_matching">matching</code></td>
<td>
<p>A preliminary matching result for <em>EEpost</em>. If
<code>matching</code> is null, <em>EEpost</em> will apply <em>DPedge</em> accordingly
to generate the initial matching.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to function <em>EEpre</em>, <em>EEpost</em> uses maximum
bipartite matching to maximize the number of common neighbours for the
matched vertices with the knowledge of a preliminary matching result by
defining the similarity between <code class="reqn">i \in A</code> and <code class="reqn">j \in B</code> as the
number of common neighbours between <code class="reqn">i</code> and <code class="reqn">j</code> according to the
preliminary matching. Then, given a matching result <code class="reqn">\Pi_t</code>, post
processing step is to seek a refinement <code class="reqn">\Pi_{t+1}</code> satisfying
<code class="reqn">\Pi_{t+1} \in</code> argmax <code class="reqn">\langle \Pi, A \Pi_t B \rangle</code>, where
<code class="reqn">\Pi</code> is a permutation matrix of dimension <code class="reqn">(n_A, n_B)</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Dist</code></td>
<td>
<p>The distance matrix between two graphs.</p>
</td></tr> <tr><td><code>match</code></td>
<td>
<p>A
vector containing matching results.</p>
</td></tr> <tr><td><code>FLAG</code></td>
<td>
<p>An indicator vector
indicating whether the matching result is converged. 0 for No and 1 for
Yes.</p>
</td></tr> <tr><td><code>converged.match</code></td>
<td>
<p>Converged match result. <code>NA</code> indicates
the matching result for a certain node is not v=convergent.</p>
</td></tr>
<tr><td><code>converged.size</code></td>
<td>
<p>The number of converged nodes.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2020)
n = 10;p = 1; q = 1/2; s = 1
Parent = matrix(rbinom(n*n, 1, q), nrow = n, ncol = n)
Parent[lower.tri(Parent)] = t(Parent)[lower.tri(Parent)]
diag(Parent) &lt;- 0
### Generate graph A
dA = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n)
dA[lower.tri(dA)] = t(dA)[lower.tri(dA)]
A1 = Parent*dA;
tmp = rbinom(n, 1, p)
n.A = length(which(tmp == 1))
indA = sample(1:n, n.A, replace = FALSE)
A = A1[indA, indA]
### Generate graph B
dB = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n)
dB[lower.tri(dB)] = t(dB)[lower.tri(dB)]
B1 = Parent*dB
tmp = rbinom(n, 1, p)
n.B = length(which(tmp == 1))
indB = sample(1:n, n.B, replace = FALSE)
B = B1[indB, indB]
matching1= DPmatching(A, B)$Dist
EEpost(A = A, B = B, rep = 10, d = 5)
EEpost(A = A, B = B, rep = 10, d = 5, matching = matching1)

</code></pre>

<hr>
<h2 id='EEpre'>Edge exploited degree profile graph matching with preprocessing.</h2><span id='topic+EEpre'></span>

<h3>Description</h3>

<p>This function uses seeds to compute edge-exploited matching
results. Seeds are nodes with high degrees. <em>EEpre</em> uses seeds to
extend the matching of seeds to the matching of all nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EEpre(A, B, d, seed = NULL, AB_dist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EEpre_+3A_a">A</code>, <code id="EEpre_+3A_b">B</code></td>
<td>
<p>Two 0/1 addjacency matrices.</p>
</td></tr>
<tr><td><code id="EEpre_+3A_d">d</code></td>
<td>
<p>A positive integer, indicating the number of candicate matching.</p>
</td></tr>
<tr><td><code id="EEpre_+3A_seed">seed</code></td>
<td>
<p>A matrix indicating pair of seeds. <code>seed</code> can be null.</p>
</td></tr>
<tr><td><code id="EEpre_+3A_ab_dist">AB_dist</code></td>
<td>
<p>A nonnegative distance matrix, which can be null. If
<code>AB_dist</code> is null, <em>EEpre</em> will apply <em>DPdistance</em> to find
it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The high degree vertices have many neighbours and enjoy ample
information for a successful matching. Thereforem, this function employ
these high degree vertices to match other nodes. If the information of
seeds is unavailable, <em>EEpre</em> will conduct a grid search grid search
to find the optimal collection of seeds. These vertices are expected to
have high degress and their distances are supposed to be the smallest among
the pairs in consideration.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Dist</code></td>
<td>
<p>The distance matrix between two graphs</p>
</td></tr> <tr><td><code>Z</code></td>
<td>
<p>An
indicator matrix. Entry <code class="reqn">Z_{i, j} = 1</code> indicates a matching between
node <code class="reqn">i \in A</code> and node <code class="reqn">j \in B</code>, 0
otherwise.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2020)
n = 10;p = 1; q = 1/2; s = 1
Parent = matrix(rbinom(n*n, 1, q), nrow = n, ncol = n)
Parent[lower.tri(Parent)] = t(Parent)[lower.tri(Parent)]
diag(Parent) &lt;- 0
### Generate graph A
dA = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n)
dA[lower.tri(dA)] = t(dA)[lower.tri(dA)]
A1 = Parent*dA;
tmp = rbinom(n, 1, p)
n.A = length(which(tmp == 1))
indA = sample(1:n, n.A, replace = FALSE)
A = A1[indA, indA]
### Generate graph B
dB = matrix(rbinom(n*n, 1, s), nrow = n, ncol=n)
dB[lower.tri(dB)] = t(dB)[lower.tri(dB)]
B1 = Parent*dB
tmp = rbinom(n, 1, p)
n.B = length(which(tmp == 1))
indB = sample(1:n, n.B, replace = FALSE)
B = B1[indB, indB]
EEpre(A = A, B = B, d = 5)
</code></pre>

<hr>
<h2 id='SCORE'>Spectral Clustering On Ratios-of-Eigenvectors.</h2><span id='topic+SCORE'></span>

<h3>Description</h3>

<p>Using ratios-of-eigenvectors to detect underlying communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCORE(G, K, itermax = NULL, startn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCORE_+3A_g">G</code></td>
<td>
<p>A 0/1 adjacency matrix.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_k">K</code></td>
<td>
<p>A positive integer, indictaing the number of underlying communities in graph <code>G</code>.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_itermax">itermax</code></td>
<td>
<p><code>k-means</code> parameter, indicating the maximum number of
iterations allowed. The default value is 100.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_startn">startn</code></td>
<td>
<p><code>k-means</code> parameter. If centers is a number, how many
random sets should be chosen? The default value is 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>SCORE</em> is fully established in <em>Fast community detection by
SCORE</em> of Jin (2015). <em>SCORE</em> uses the entry-wise ratios between the
first leading eigenvector and each of the other leading eigenvectors for
clustering.
</p>


<h3>Value</h3>

<p>A label vector.
</p>


<h3>References</h3>

<p>Jin, J. (2015) <em>Fast community detection by score</em>,
<em>The Annals of Statistics 43 (1),
57â€“89</em><br /><a href="https://projecteuclid.org/euclid.aos/1416322036">https://projecteuclid.org/euclid.aos/1416322036</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2020)
n = 10; K = 2
P  = matrix(c(1/2, 1/4, 1/4, 1/2), byrow = TRUE, nrow = K)
distribution = c(1, 2)
l = sample(distribution, n, replace=TRUE, prob = c(1/2, 1/2))
Pi = matrix(0, n, 2)
for (i in 1:n){
  Pi[i, l[i]] = 1
  }
### define the expectation of the parent graph's adjacency matrix
Omega = Pi %*% P %*% t(Pi)
### construct the parent graph G
G = matrix(runif(n*n, 0, 1), nrow = n)
G = G - Omega
temp = G
G[which(temp &gt;0)] = 0
G[which(temp &lt;=0)] = 1
diag(G) = 0
G[lower.tri(G)] = t(G)[lower.tri(G)]
SCORE(G, 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
