<!DOCTYPE html><html><head><title>Help for package permutations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {permutations}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allperms'><p>All permutations of a given size and all cycles of a given length</p></a></li>
<li><a href='#as.function.permutation'>
<p>Coerce a permutation to a function</p></a></li>
<li><a href='#c'>
<p>Concatenation of permutations</p></a></li>
<li><a href='#capply'><p>Apply functions to elements of a cycle</p></a></li>
<li><a href='#cayley'><p>Cayley tables for permutation groups</p></a></li>
<li><a href='#commutator'><p>Group-theoretic commutator and group action; the dot object</p></a></li>
<li><a href='#conjugate'>
<p>Are two permutations conjugate?</p></a></li>
<li><a href='#cyclist'><p>details of cyclists</p></a></li>
<li><a href='#derangement'><p>Tests for a permutation being a derangement</p></a></li>
<li><a href='#dodecahedron'>
<p>The dodecahedron group</p></a></li>
<li><a href='#faro'><p>Faro shuffles</p></a></li>
<li><a href='#fbin'>
<p>The fundamental bijection</p></a></li>
<li><a href='#fixed'>
<p>Fixed elements</p></a></li>
<li><a href='#get1'>
<p>Retrieve particular cycles or components of cycles</p></a></li>
<li><a href='#id'>
<p>The identity permutation</p></a></li>
<li><a href='#inverse'><p>Inverse of a permutation</p></a></li>
<li><a href='#length'>
<p>Various vector-like utilities for permutation objects.</p></a></li>
<li><a href='#megaminx'>
<p>megaminx</p></a></li>
<li><a href='#megaminx_plotter'><p>Plotting routine for megaminx sequences</p></a></li>
<li><a href='#nullperm'>
<p>Null permutations</p></a></li>
<li><a href='#Ops.permutation'><p>Arithmetic Ops Group Methods for permutations</p></a></li>
<li><a href='#orbit'>
<p>Orbits of integers</p></a></li>
<li><a href='#perm_matrix'><p>Permutation matrices</p></a></li>
<li><a href='#permorder'>
<p>The order of a permutation</p></a></li>
<li><a href='#permutation'>
<p>Functions to create and coerce word objects and cycle objects</p></a></li>
<li><a href='#permutations-package'>
<p>The Symmetric Group: Permutations of a Finite Set</p></a></li>
<li><a href='#print'>
<p>Print methods for permutation objects</p></a></li>
<li><a href='#rperm'>
<p>Random permutations</p></a></li>
<li><a href='#sgn'>
<p>Sign of a permutation</p></a></li>
<li><a href='#shape'><p>Shape of a permutation</p></a></li>
<li><a href='#size'>
<p>Gets or sets the size of a permutation</p></a></li>
<li><a href='#tidy'>
<p>Utilities to neaten permutation objects</p></a></li>
<li><a href='#valid'>
<p>Functions to validate permutations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Symmetric Group: Permutations of a Finite Set</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Imports:</td>
<td>magic,numbers,partitions (&ge; 1.9-17),freealg (&ge;
1.0-4),mathjaxr</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>Manipulates invertible functions from a finite set to
             itself.  Can transform from word form to cycle form and
             back.  To cite the package in publications please use
             Hankin (2020) "Introducing the permutations R package",
             SoftwareX, volume 11 &lt;<a href="https://doi.org/10.1016%2Fj.softx.2020.100453">doi:10.1016/j.softx.2020.100453</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown,testthat,knitr,magrittr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/permutations">https://github.com/RobinHankin/permutations</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/permutations/issues">https://github.com/RobinHankin/permutations/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-21 19:23:12 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Paul Egeler <a href="https://orcid.org/0000-0001-6948-9498"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-22 00:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='allperms'>All permutations of a given size and all cycles of a given length</h2><span id='topic+allperms'></span><span id='topic+allcyc'></span><span id='topic+allcycles'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Function <code>allperms()</code> returns all \(n\) factorial permutations
of a set.  Function <code>allcyc()</code> returns all \((n-1)!\)
permutations comprising a single cycle of length \(n\).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allperms(n)
allcyc(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allperms_+3A_n">n</code></td>
<td>
<p>The size of the set, integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>allperms()</code> is very basic (the idiom is
<code>word(t(partitions::perms(n)))</code>) but is here for completeness.
</p>


<h3>Note</h3>

<p>Function <code>allcyc()</code> is taken directly from Er's
&ldquo;fine-tuned&rdquo; algorithm.  It should really be implemented in
C as part of the <span class="pkg">partitions</span> package but I have not
yet got round to this.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. C. Er 1989 &ldquo;Efficient
enumeration of cyclic permutations in situ&rdquo;.  <em>International
Journal of Computer Mathematics</em>, volume 29:2-4, pp121-129.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allperms">allperms</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
allperms(5)

allcyc(5)

</code></pre>

<hr>
<h2 id='as.function.permutation'>
Coerce a permutation to a function
</h2><span id='topic+as.function.permutation'></span><span id='topic+as.function.word'></span><span id='topic+as.function.cycle'></span>

<h3>Description</h3>

<p>Coerce a permutation to an executable function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'permutation'
as.function(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.function.permutation_+3A_x">x</code></td>
<td>
<p>permutation</p>
</td></tr>
<tr><td><code id="as.function.permutation_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Multiplication of permutations loses associativity when using functional
notation; see examples.
</p>
<p>Also, note that the coerced function will not take an argument greater
than the size (qv) of the permutation.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cyc_len(3)
y &lt;- cyc_len(5)

xfun &lt;- as.function(x)
yfun &lt;- as.function(y)

stopifnot(xfun(yfun(2)) == as.function(y*x)(2)) # note transposition of x &amp; y

# written in postfix notation one has the very appealing form x(fg) = (xf)g

# it's vectorized:
as.function(rperm(10,9))(1)   
as.function(as.cycle(1:9))(sample(9))
</code></pre>

<hr>
<h2 id='c'>
Concatenation of permutations
</h2><span id='topic+c'></span><span id='topic+c.word'></span><span id='topic+c.cycle'></span><span id='topic+rep.permutation'></span>

<h3>Description</h3>

<p>Concatenate words or cycles together 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'word'
c(...)
## S3 method for class 'cycle'
c(...)
## S3 method for class 'permutation'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_+3A_...">...</code></td>
<td>
<p>In the methods for <code>c()</code>, objects to be
concatenated.  Must all be of the same type: either all
<code>word</code>, or all <code>cycle</code></p>
</td></tr>
<tr><td><code id="c_+3A_x">x</code></td>
<td>
<p>In the method for <code>rep()</code>, a permutation object</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The methods for <code>c()</code> do not attempt to detect which type (word or
cycle) you want as conversion is expensive.
</p>
<p>Function <code>rep.permutation()</code> behaves like <code>base::rep()</code> and
takes the same arguments, eg <code>times</code> and <code>each</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+size">size</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.cycle(1:5)
y &lt;- cycle(list(list(1:4,8:9),list(1:2)))


# concatenate cycles:
c(x,y)

# concatenate words:
c(rperm(5,3),rperm(6,9))   # size adjusted to maximum size of args


# repeat words:
rep(x, times=3)



</code></pre>

<hr>
<h2 id='capply'>Apply functions to elements of a cycle</h2><span id='topic+capply'></span>

<h3>Description</h3>

<p>Function <code>capply()</code> means &ldquo;cycle apply&rdquo; and is modelled on
<code>lapply()</code>.  It applies a function to every element in the cycles
of its argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capply(X, fun, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capply_+3A_x">X</code></td>
<td>
<p>Permutation, coerced to cycle</p>
</td></tr>
<tr><td><code id="capply_+3A_fun">fun</code></td>
<td>
<p>Function to be applied to each element of <code>X</code></p>
</td></tr>
<tr><td><code id="capply_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>fun()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is just a convenience wrapper really.</p>


<h3>Value</h3>

<p>Returns a permutation in cycle form</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>

(x &lt;- rperm())
capply(x,function(x){x+100})
capply(x,rev)

all(is.id(capply(x,rev)*x))  # should be TRUE

capply(rcyc(20,5,9),order)

capply(rcyc(20,5,9),sample)  # still 5-cycles




</code></pre>

<hr>
<h2 id='cayley'>Cayley tables for permutation groups</h2><span id='topic+cayley'></span><span id='topic+Cayley'></span>

<h3>Description</h3>

<p>Produces a nice Cayley table for a subgroup of the symmetric group on
n elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cayley(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cayley_+3A_x">x</code></td>
<td>
<p>A vector of permutations in cycle form</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cayley's theorem states that every group G is isomorphic to a subgroup
of the symmetric group acting on G.  In this context it means that if we
have a vector of permutations that comprise a group, then we can nicely
represent its structure using a table.
</p>
<p>If the set <code>x</code> is not closed under multiplication and inversion
(that is, if <code>x</code> is not a group) then the function may misbehave.  No
argument checking is performed, and in particular there is no check that
the elements of <code>x</code> are unique, or even that they include an
identity.
</p>


<h3>Value</h3>

<p>A square matrix giving the group operation</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## cyclic group of order 4:
cayley(as.cycle(1:4)^(0:3))

## Klein group:
K4 &lt;- as.cycle(c("()","(12)(34)","(13)(24)","(14)(23)"))
names(K4) &lt;- c("00","01","10","11")
cayley(K4)


## S3, the symmetric group on 3 elements:
S3 &lt;- as.cycle(c(
    "()",
    "(12)(35)(46)", "(13)(26)(45)",
    "(14)(25)(36)", "(156)(243)", "(165)(234)"
))
names(S3) &lt;- c("()","(ab)","(ac)","(bc)","(abc)","(acb)")
cayley(S3)


## Now an example from the onion package, the quaternion group:
## Not run: 
 library(onion)
 a &lt;- c(H1,-H1,Hi,-Hi,Hj,-Hj,Hk,-Hk)
 X &lt;- word(sapply(1:8,function(k){sapply(1:8,function(l){which((a*a[k])[l]==a)})}))
 cayley(X)  # a bit verbose; rename the vector:
 names(X) &lt;- letters[1:8]
 cayley(X)  # more compact

## End(Not run)

</code></pre>

<hr>
<h2 id='commutator'>Group-theoretic commutator and group action; the dot object</h2><span id='topic+commutator'></span><span id='topic+dot'></span><span id='topic+.'></span><span id='topic+dot-class'></span><span id='topic+permutation-class'></span><span id='topic+extract'></span><span id='topic+commutator'></span><span id='topic+jacobi'></span><span id='topic+dot_error'></span><span id='topic++5B.dot'></span><span id='topic++5B+2Cdot-method'></span><span id='topic++5B+2Cdot+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2CANY+2Cmissing-method'></span><span id='topic++5B+2Cdot+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cdot+2Cmatrix+2Cmatrix-method'></span><span id='topic++5B+2Cdot+2Cpermutation+2Cpermutation-method'></span><span id='topic++5B+2Cdot+2Cpermutation+2Cpermutation+2CANY-method'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>In the <span class="pkg">permutations</span> package, the dot is defined as the
<strong>Group-theoretic commutator</strong>:
\([x,y]=x^{-1}y^{-1}xy\).  This is a bit of an
exception to the usual definition of <code>xy-yx</code> (along with the
<span class="pkg">freegroup</span> package).  Package idiom is <code>commutator(x,y)</code> or
<code>.[x,y]</code>.
</p>
<p>The Jacobi identity does not make sense in the context of the
<span class="pkg">permutations</span> package, but the Hall-Witt identity is obeyed.
</p>
<p>The &ldquo;dot&rdquo; object is defined and discussed in <code>inst/dot.Rmd</code>,
which creates file <code>data/dot.rda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commutator(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commutator_+3A_x">x</code>, <code id="commutator_+3A_y">y</code></td>
<td>
<p>Permutation objects, coerced to word</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group_action">group_action</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

.[as.cycle("123456789"),as.cycle("12")]


x &lt;- rperm(10,7)
y &lt;- rperm(10,8)
z &lt;- rperm(10,9)

uu &lt;- 
commutator(commutator(x,y),z^x) *
commutator(commutator(z,x),y^z) *
commutator(commutator(y,z),x^y) 

stopifnot(all(is.id(uu)))  # this is the  Hall-Witt identity


.[x,y]

is.id(.[.[x,y],z^x] * .[.[z,x],y^z] * .[.[y,z],x^y])
is.id(.[.[x,-y],z]^y * .[.[y,-z],x]^z * .[.[z,-x],y]^x)
</code></pre>

<hr>
<h2 id='conjugate'>
Are two permutations conjugate?
</h2><span id='topic+conjugate'></span><span id='topic+are_conjugate'></span><span id='topic+are_conjugate'></span><span id='topic+are_conjugate_single'></span><span id='topic++25~+25'></span><span id='topic++25~+25.permutation'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if two permutations are conjugate and <code>FALSE</code>
otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_conjugate(x, y)
are_conjugate_single(a,b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conjugate_+3A_x">x</code>, <code id="conjugate_+3A_y">y</code>, <code id="conjugate_+3A_a">a</code>, <code id="conjugate_+3A_b">b</code></td>
<td>
<p>Objects of class permutation, coerced to cycle form</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two permutations are conjugate if and only if they have the same shape.
Function <code>are_conjugate()</code> is vectorized and user-friendly;
function <code>are_conjugate_single()</code> is lower-level and operates
only on length-one permutations.
</p>
<p>The reason  that <code>are_conjugate_single()</code> is a separate function
and not bundled inside <code>are_conjugate()</code> is that dealing with the
identity permutation is a pain in the arse.
</p>


<h3>Value</h3>

<p>Returns a vector of Booleans
</p>


<h3>Note</h3>

<p>The functionality detects conjugateness by comparing the shapes of two
permutations; permutations are coerced to cycle form because function
<code>shape()</code> does.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group_action">group_action</a></code>,<code><a href="#topic+shape">shape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

as.cycle("(123)(45)") %~% as.cycle("(89)(712)")  # same shape
as.cycle("(123)(45)") %~% as.cycle("(89)(7124)") # different shape

are_conjugate(rperm(20,3),rperm(20,3))

rperm(20,3) %~% as.cycle(1:3)

z &lt;- rperm(300,4)
stopifnot(all(are_conjugate(z,id)==is.id(z)))

data(megaminx)
stopifnot(all(are_conjugate(megaminx,megaminx^as.cycle(sample(129)))))
</code></pre>

<hr>
<h2 id='cyclist'>details of cyclists</h2><span id='topic+cyclist'></span><span id='topic+vec2cyclist_single'></span><span id='topic+vec2cyclist_single_cpp'></span><span id='topic+char2cyclist_single'></span><span id='topic+cyclist2word_single'></span><span id='topic+nicify_cyclist'></span><span id='topic+nicify'></span><span id='topic+remove_length_one'></span>

<h3>Description</h3>

<p>Various functionality to deal with cyclists</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2cyclist_single(p)
vec2cyclist_single_cpp(p)
remove_length_one(x)
cyclist2word_single(cyc,n)
nicify_cyclist(x,rm1=TRUE, smallest_first=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyclist_+3A_p">p</code></td>
<td>
<p>Integer vector, interpreted as a word</p>
</td></tr>
<tr><td><code id="cyclist_+3A_x">x</code>, <code id="cyclist_+3A_cyc">cyc</code></td>
<td>
<p>A cyclist</p>
</td></tr>
<tr><td><code id="cyclist_+3A_n">n</code></td>
<td>
<p>In function <code>cycle2word_single()</code>, the size of
the permutation to induce</p>
</td></tr>
<tr><td><code id="cyclist_+3A_rm1">rm1</code>, <code id="cyclist_+3A_smallest_first">smallest_first</code></td>
<td>
<p>In function <code>nicify_cyclist()</code>,
Boolean, governing whether or not to remove length-1 cycles, and
whether or not to place the smallest element in each cycle first
(non-default values are used by <code>standard_cyclist()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <dfn>cyclist</dfn> is an object corresponding to a permutation P.  It is a
list with elements that are integer vectors corresponding to the cycles
of P.  This object is informally known as a cyclist, but there is no S3
class corresponding to it.  In general use, one should not usually deal
with cyclists at all: they are internal low-level objects not intended
for the user.
</p>
<p>An object of S3 class <dfn>cycle</dfn> is a (possibly named) list of
cyclists.  NB: there is an unavoidable notational clash here.  When
considering a single permutation, &ldquo;cycle&rdquo; means group-theoretic
cycle [eg \(1\longrightarrow 2\longrightarrow 3\longrightarrow 1\)]; when considering <span class="rlang"><b>R</b></span> objects, &ldquo;cycle&rdquo; means
&ldquo;an <span class="rlang"><b>R</b></span> object of class <dfn>cycle</dfn> whose elements are permutations
written in cycle form&rdquo;.
</p>
<p>The elements of a cyclist are the disjoint group-theoretic cycles.  Note
the redundancies inherent: firstly, because the cycles commute, their
order is immaterial (and a list is ordered); and secondly, the cycles
themselves are invariant under cyclic permutation.  Heigh ho.
</p>
<p>A cyclist may be poorly formed in a number of ways: the cycles may
include repeats, or contain elements which are common to more than one
cycle.  Such problems are detected by <code>cyclist_valid()</code>.  Also,
there are less serious problems: the cycles may include length-one
cycles; the cycles may start with an element that is not the smallest.
These issues are dealt with by <code>nicify_cyclist()</code>.
</p>

<ul>
<li><p> Function <code>nicify_cyclist()</code> takes a cyclist and puts it in
a nice form but does not alter the permutation.  It takes a cyclist
and removes length-one cycles; then orders each cycle so that the
smallest element appears first (that is, it changes <code>(523)</code> to
<code>(235)</code>).  It then orders the cycles by the smallest element.
</p>
</li>
<li><p> Function <code>remove_length_one()</code> takes a cyclist and removes
length-one cycles from it.
</p>
</li>
<li><p> Function <code>vec2cyclist_single()</code> takes a vector of integers,
interpreted as a word, and converts it into a cyclist.  Length-one
cycles are discarded.
</p>
</li>
<li><p> Function <code>vec2cyclist_single_cpp()</code> is a placeholder for a
function that is not yet written.
</p>
</li>
<li><p> Function <code>cyclist2word_single()</code> takes a cyclist and
returns a vector corresponding to a single word.  This function is not
intended for everyday use; function <code>cycle2word()</code> is much more
user-friendly.
</p>
</li>
<li><p> Function <code>char2cyclist_single()</code> takes a character string
like &ldquo;<code>(342)(19)</code>&rdquo; and turns it into a cyclist, in this
case <code>list(c(3,4,2),c(1,9))</code>.  This function returns a cyclist
which is not necessarily canonicalized: it might have length-one
cycles, and the cycles themselves might start with the wrong number or
be incorrectly ordered.  It attempts to deal with absence of commas in
a sensible way, so &ldquo;<code>(18,19)(2,5)</code>&rdquo; is dealt with
appropriately too.  The function is insensitive to spaces.  Also, one
can give it an argument which does not correspond to a cycle object,
eg <code>char2cyclist_single("(94)(32)(19)(1)")</code> (in which &ldquo;9&rdquo;
is repeated).  The function does not return an error, but to catch
this kind of problem use <code>char2cycle()</code> which calls the validity
checks.
</p>
<p>The user should use <code>char2cycle()</code> which executes validity checks
and coerces to a cycle object.
</p>
</li></ul>

<p>See also the 'cyclist' vignette which contains more details and examples.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.cycle">as.cycle</a></code>,<code><a href="#topic+fbin">fbin</a></code>,<code><a href="#topic+valid">valid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec2cyclist_single(c(7,9,3,5,8,6,1,4,2))

char2cyclist_single("(342)(19)")

nicify_cyclist(list(c(4, 6), c(7), c(2, 5, 1), c(8, 3)))
nicify_cyclist(list(c(4, 6), c(7), c(2, 5, 1), c(8, 3)),rm1=TRUE)


cyclist2word_single(list(c(1,4,3),c(7,8)))


</code></pre>

<hr>
<h2 id='derangement'>Tests for a permutation being a derangement</h2><span id='topic+derangement'></span><span id='topic+is.derangement'></span>

<h3>Description</h3>

<p>A <dfn>derangement</dfn> is a permutation which leaves no element fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.derangement(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derangement_+3A_x">x</code></td>
<td>
<p>Object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of Booleans corresponding to whether the permutations are
derangements or not.
</p>


<h3>Note</h3>

<p>The identity permutation is problematic because it potentially has zero
size.
</p>
<p>The identity element is not a derangement, although the (zero-size) identity
cycle and permutation both return <code>TRUE</code> under the natural <span class="rlang"><b>R</b></span> idiom
<code>all(P != seq_len(size(P)))</code>. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code>id</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
allperms(4)
is.derangement(allperms(4))

M &lt;- matrix(c(1,2,3,4, 2,3,4,1, 3,2,4,1),byrow=TRUE,ncol=4)
M
is.derangement(word(M))

is.derangement(rperm(16,4))

</code></pre>

<hr>
<h2 id='dodecahedron'>
The dodecahedron group
</h2><span id='topic+dodecahedron'></span><span id='topic+dodecahedron_face'></span><span id='topic+dodecahedron_edge'></span><span id='topic+full_dodecahedron_face'></span><span id='topic+full_dodecahedron_edge'></span>

<h3>Description</h3>

<p>Permutations comprising the dodecahedron group on either its faces or
its edges; also the full dodecahedron group
</p>


<h3>Details</h3>

<p>The package provides a number of objects for investigating dodecahedral
groups:
</p>
<p>Object <code>dodecahedron_face</code> is a cycle object with 60 elements
corresponding to the permutations of the faces of a dodecahedron,
numbered 1-12 as in the megaminx net.  Object <code>dodecahedron_edge</code>
is the corresponding object for permuting the edges of a dodecahedron.
The edges are indexed by the lower of the two adjoining facets on the
megaminx net.
</p>
<p>Objects <code>full_dodecahedron_face</code> and <code>full_dodecahedron_edge</code>
give the 120 elements of the full dodecahedron group, that is, the
dodecahedron group including reflections.  NB: these objects are
<strong>not</strong> isomorphic to S5.
</p>


<h3>Note</h3>

<p>File <code>zzz_dodecahedron.R</code> is not really intended to be
human-readable.  The source file is in <code>inst/dodecahedron_group.py</code>
and <code>inst/full_dodecahedron_group.py</code> which contain documented
python source code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
permprod(dodecahedron_face)

</code></pre>

<hr>
<h2 id='faro'>Faro shuffles</h2><span id='topic+faro'></span><span id='topic+faro_gen'></span><span id='topic+riffle'></span><span id='topic+shuffle'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>A <dfn>faro shuffle</dfn>, <code>faro()</code>,is a permutation of a deck of
\(2n\) cards.  The cards are split into two packs, <code>1:n</code> and
<code>(n+1):2n</code>, and interleaved: cards are taken alternately from top
of each pack and placed face down on the table.  A <dfn>faro
out-shuffle</dfn> takes the first card from <code>1:n</code> and a <dfn>faro
in-shuffle</dfn> takes the first card from <code>(n+1):(2*n)</code>.
</p>
<p>A <dfn>generalized faro shuffle</dfn>, <code>faro_gen()</code>, splits the pack
into <code>m</code> equal parts and applies the same permutation to each pack,
and the same permutation to each set of packs, before interleaving.
The interleaving itself is simply a matrix transpose; it is possible to
omit this step by passing <code>interleave=FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faro(n, out = TRUE)
faro_gen(n,m,p1=id,p2=id,interleave=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faro_+3A_n">n</code></td>
<td>
<p>Number of cards in each pack</p>
</td></tr>
<tr><td><code id="faro_+3A_m">m</code></td>
<td>
<p>Number of packs</p>
</td></tr>
<tr><td><code id="faro_+3A_p1">p1</code>, <code id="faro_+3A_p2">p2</code></td>
<td>
<p>Permutations for cards and packs respectively, coerced to
word form</p>
</td></tr>
<tr><td><code id="faro_+3A_interleave">interleave</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to
actually perform the interleaving and <code>FALSE</code> meaning not to</p>
</td></tr>
<tr><td><code id="faro_+3A_out">out</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return an
out-shuffle and <code>FALSE</code> meaning to return an in-shuffle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a permutation in word form</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>faro(4)
faro(4,FALSE)

faro_gen(9,3)
faro_gen(7,4,cyc_len(7),cyc_len(4))
faro_gen(7,4,cyc_len(7),cyc_len(4),interleave=FALSE)

sapply(seq_len(10),function(n){permorder(faro(n,FALSE))}) # OEIS  A002326

plot(as.vector(as.word(faro(10))),type='b')
plot(as.vector(faro_gen(8,5,p1=cyc_len(8)^2,interleave=FALSE)))

</code></pre>

<hr>
<h2 id='fbin'>
The fundamental bijection
</h2><span id='topic+fbin'></span><span id='topic+fbin_single'></span><span id='topic+fbin_inv'></span><span id='topic+standard'></span><span id='topic+standard_cyclist'></span>

<h3>Description</h3>

<p>Stanley defines the <dfn>fundamental bijection</dfn> on page 30. 
</p>
<p>Given <code class="reqn">w=(14)(2)(375)(6)</code>, Stanley writes it in standard form
(specifically: each cycle is written with its largest element first;
cycles are written in increasing order of their largest element).  Thus
we obtain <code class="reqn">(2)(41)(6)(753)</code>.
</p>
<p>Then we obtain <code class="reqn">w^*</code> from <code class="reqn">w</code> by writing it in standard form
an erasing the parentheses (that is, viewing the numbers as a
<em>word</em>); here <code class="reqn">w^*=2416753</code>.
</p>
<p>Given this, <code class="reqn">w</code> may be recovered by inserting a left parenthesis
preceding every left-to-right maximum, and right parentheses where
appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standard(cyc,n=NULL)
standard_cyclist(x,n=NULL)
fbin_single(vec)
fbin(W)
fbin_inv(cyc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbin_+3A_vec">vec</code></td>
<td>
<p>In function <code>fbin_single()</code>, an integer vector</p>
</td></tr>
<tr><td><code id="fbin_+3A_w">W</code></td>
<td>
<p>In functions <code>fbin()</code> and <code>fbin_inv()</code>, an object
of class permutation, coerced to word and cycle form respectively</p>
</td></tr>
<tr><td><code id="fbin_+3A_cyc">cyc</code></td>
<td>
<p>In functions <code>fbin_single()</code> and <code>standard()</code>,
permutation object coerced to cycle form</p>
</td></tr>
<tr><td><code id="fbin_+3A_n">n</code></td>
<td>
<p>In function <code>standard()</code> and <code>standard_cyclist()</code>,
size of the partition to assume, with default <code>NULL</code> meaning to
use the largest element of any cycle</p>
</td></tr>
<tr><td><code id="fbin_+3A_x">x</code></td>
<td>
<p>In function <code>standard_cyclist()</code>, a cyclist</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user-friendly functions are <code>fbin()</code> and <code>fbin_inv()</code>
which perform Stanley's &ldquo;fundamental bijection&rdquo;.  Function
<code>fbin()</code> takes a word object and returns a cycle; function
<code>fbin_inv()</code> takes a cycle and returns a word.
</p>
<p>The other functions are low-level helper functions that are not really
intended for the user (except possibly <code>standard()</code>, which puts a
cycle object in standard order in list form).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>References</h3>

<p>R. P. Stanley 2011 <em>Enumerative Combinatorics</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nicify_cyclist">nicify_cyclist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Stanley's example w:
standard(cycle(list(list(c(1,4),c(3,7,5)))))

w_hat &lt;- c(2,4,1,6,7,5,3)

fbin(w_hat)
fbin_inv(fbin(w_hat))


x &lt;- rperm(40,9)
stopifnot(all(fbin(fbin_inv(x))==x))
stopifnot(all(fbin_inv(fbin(x))==x))

</code></pre>

<hr>
<h2 id='fixed'>
Fixed elements
</h2><span id='topic+fixed'></span><span id='topic+fixed.word'></span><span id='topic+fixed.cycle'></span>

<h3>Description</h3>

<p>Finds which elements of a permutation object are fixed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'word'
fixed(x)
## S3 method for class 'cycle'
fixed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_+3A_x">x</code></td>
<td>
<p>Object of class <code>word</code> or <code>cycle</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Boolean vector corresponding to the fixed elements of a permutation.
</p>


<h3>Note</h3>

<p>The function is vectorized; if given a vector of permutations,
<code>fixed()</code> returns a Boolean vector showing which elements are fixed
by <em>all</em> of the permutations.
</p>
<p>This function has two methods: <code>fixed.word()</code> and
<code>fixed.cycle()</code>, neither of which coerce.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fixed(as.cycle(1:3)+as.cycle(8:9))   # elements 4,5,6,7 are fixed
fixed(id)


data(megaminx)
fixed(megaminx)


</code></pre>

<hr>
<h2 id='get1'>
Retrieve particular cycles or components of cycles
</h2><span id='topic+get1'></span><span id='topic+get_cyc'></span>

<h3>Description</h3>

<p>Given an object of class <code>cycle</code>, function <code>get1()</code> returns a
representative of each of the disjoint cycles in the object's elements.
Function <code>get_cyc()</code> returns the cycle containing a specific element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get1(x,drop=TRUE)
get_cyc(x,elt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get1_+3A_x">x</code></td>
<td>
<p>permutation object (coerced to <code>cycle</code> class)</p>
</td></tr>
<tr><td><code id="get1_+3A_drop">drop</code></td>
<td>
<p>In function <code>get1()</code>, argument <code>drop</code> controls
the behaviour if <code>x</code> is length 1.  If <code>drop</code> is
<code>TRUE</code>, then a vector of representative elements is returned;
if <code>FALSE</code>, then a list with one vector element is returned</p>
</td></tr>
<tr><td><code id="get1_+3A_elt">elt</code></td>
<td>
<p>Length-one vector interpreted as a permutation object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(megaminx)
get1(megaminx)
get1(megaminx[1])
get1(megaminx[1],drop=TRUE)

get_cyc(megaminx,11) 

</code></pre>

<hr>
<h2 id='id'>
The identity permutation
</h2><span id='topic+id'></span><span id='topic+is.id'></span><span id='topic+is.id.cycle'></span><span id='topic+is.id_single_cycle'></span><span id='topic+is.id.list'></span><span id='topic+is.id.word'></span>

<h3>Description</h3>

<p>The <dfn>identity permutation</dfn> leaves every element fixed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.id(x)
is.id_single_cycle(x)
## S3 method for class 'cycle'
is.id(x)
## S3 method for class 'list'
is.id(x)
## S3 method for class 'word'
is.id(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_+3A_x">x</code></td>
<td>
<p>Object to be tested</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The identity permutation is problematic because it potentially has zero size.
</p>


<h3>Value</h3>

<p>The variable <code>id</code> is a <em>cycle</em> as this is more convenient
than a zero-by-one matrix.
</p>
<p>Function <code>is.id()</code> returns a Boolean with <code>TRUE</code> if the
corresponding element is the identity, and <code>FALSE</code> otherwise.  It
dispatches to either <code>is.id.cycle()</code> or <code>is.id.word()</code> as
appropriate. 
</p>
<p>Function <code>is.id.list()</code> tests a cyclist for identityness.
</p>


<h3>Note</h3>

<p>The identity permutations documented here are distinct from the null
permutations documented at <code>nullperm.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.derangement">is.derangement</a></code>,<code><a href="#topic+nullperm">nullperm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>is.id(id)

as.word(id)  # weird

x &lt;- rperm(10,4)
x[3] &lt;- id
is.id(x*inverse(x))
</code></pre>

<hr>
<h2 id='inverse'>Inverse of a permutation</h2><span id='topic+inverse'></span><span id='topic+inverse_word_single'></span><span id='topic+inverse_cyclist_single'></span><span id='topic+inverse.word'></span><span id='topic+inverse.cycle'></span>

<h3>Description</h3>

<p>Calculates the inverse of a permutation in either word or cycle form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse(x)
## S3 method for class 'word'
inverse(x)
## S3 method for class 'cycle'
inverse(x)
inverse_word_single(W)
inverse_cyclist_single(cyc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_+3A_x">x</code></td>
<td>
<p>Object of class <code>permutation</code> to be inverted</p>
</td></tr>
<tr><td><code id="inverse_+3A_w">W</code></td>
<td>
<p>In function <code>inverse_word_single()</code>, a vector
corresponding to a permutation in word form (that is, one row of a
<code>word</code> object)</p>
</td></tr>
<tr><td><code id="inverse_+3A_cyc">cyc</code></td>
<td>
<p>In function <code>inverse_cyclist_single()</code>, a cyclist to
be inverted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package provides methods to invert objects of class <code>word</code>
(the <span class="rlang"><b>R</b></span> idiom is <code>W[W] &lt;- seq_along(W)</code>) and also objects of class
<code>cycle</code> (the idiom is
<code>lapply(cyc,function(o){c(o[1],rev(o[-1]))})</code>).
</p>
<p>The user should use <code>inverse()</code> directly, which dispatches to
either <code>inverse.word()</code> or <code>inverse.cycle()</code> as appropriate.
</p>
<p>Sometimes, using idiom such as <code>x^-1</code> or <code>id/x</code> gives neater
code, although these may require coercion between word form and cycle
form.
</p>


<h3>Value</h3>

<p>Function <code>inverse()</code> returns an object of the same class as its argument.
</p>


<h3>Note</h3>

<p>Inversion of words is ultimately performed by function
<code>inverse_word_single()</code>:
</p>
<pre>
inverse_word_single &lt;- function(W){
    W[W] &lt;- seq_along(W)
    return(W)
}
</pre>
<p>which can be replaced by <code>order()</code> although this is considerably
less efficient, especially for small sizes of permutations.  One of my
longer-term plans is to implement this in C, although it is
not clear that this will be any faster.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+cycle_power">cycle_power</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rperm(10,6)
x
inverse(x)

all(is.id(x*inverse(x)))  # should be TRUE

inverse(as.cycle(matrix(1:8,9,8)))

</code></pre>

<hr>
<h2 id='length'>
Various vector-like utilities for permutation objects.
</h2><span id='topic+length.word'></span><span id='topic+length.permutation'></span><span id='topic+length+3C-.permutation'></span><span id='topic+names'></span><span id='topic+names.word'></span><span id='topic+names+3C-.word'></span>

<h3>Description</h3>

<p>Various vector-like utilities for permutation objects such as
<code>length</code>, <code>names()</code>, etc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'word'
length(x)
## S3 replacement method for class 'permutation'
length(x) &lt;- value
## S3 method for class 'word'
names(x)
## S3 replacement method for class 'word'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length_+3A_x">x</code></td>
<td>
<p>permutation object</p>
</td></tr>
<tr><td><code id="length_+3A_value">value</code></td>
<td>
<p>In function <code>names&lt;-.word()</code>, the new names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions have methods only for word objects; cycle objects use
the methods for lists.  It is easy to confuse the <em>length</em> of a
permutation with its <code>size</code>.
</p>
<p>It is not possible to set the length of a permutation; this is more
trouble than it is worth.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+size">size</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rperm(5,9)
x
names(x) &lt;- letters[1:5]
x

megaminx
length(megaminx)   # the megaminx group has 12 generators, one per face.
size(megaminx)     # the megaminx group is a subgroup of S_129.

names(megaminx) &lt;- NULL   # prints more nicely.
megaminx
</code></pre>

<hr>
<h2 id='megaminx'>
megaminx
</h2><span id='topic+megaminx'></span><span id='topic+megaminx_colours'></span><span id='topic+superflip'></span><span id='topic+W'></span><span id='topic+Pu'></span><span id='topic+DY'></span><span id='topic+DB'></span><span id='topic+R'></span><span id='topic+DG'></span><span id='topic+LG'></span><span id='topic+O'></span><span id='topic+LB'></span><span id='topic+LY'></span><span id='topic+Pi'></span><span id='topic+Gy'></span>

<h3>Description</h3>

<p>A set of generators for the megaminx group
</p>


<h3>Details</h3>

<p>Each element of <code>megaminx</code> corresponds to a clockwise turn of 72
degrees.  See the vignette for more details.
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>megaminx[, 1]</code> </td><td style="text-align: left;"> W   </td><td style="text-align: left;"> White        </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[, 2]</code> </td><td style="text-align: left;"> Pu  </td><td style="text-align: left;"> Purple       </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[, 3]</code> </td><td style="text-align: left;"> DY  </td><td style="text-align: left;"> Dark Yellow  </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[, 4]</code> </td><td style="text-align: left;"> DB  </td><td style="text-align: left;"> Dark Blue    </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[, 5]</code> </td><td style="text-align: left;"> R   </td><td style="text-align: left;"> Red          </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[, 6]</code> </td><td style="text-align: left;"> DG  </td><td style="text-align: left;"> Dark Green   </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[, 7]</code> </td><td style="text-align: left;"> LG  </td><td style="text-align: left;"> Light Green  </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[, 8]</code> </td><td style="text-align: left;"> O   </td><td style="text-align: left;"> Orange       </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[, 9]</code> </td><td style="text-align: left;"> LB  </td><td style="text-align: left;"> Light Blue   </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[,10]</code> </td><td style="text-align: left;"> LY  </td><td style="text-align: left;"> Light Yellow </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[,11]</code> </td><td style="text-align: left;"> Pi  </td><td style="text-align: left;"> Pink         </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>megaminx[,12]</code> </td><td style="text-align: left;"> Gy  </td><td style="text-align: left;"> Gray 
  </td>
</tr>

</table>

<p>Vector <code>megaminx_colours</code> shows what colour each facet has at
<abbr><span class="acronym">start</span></abbr>.  Object <code>superflip</code> is a megaminx operation that
flips each of the 30 edges.
</p>
<p>These objects can be generated by running script
<code>inst/megaminx.R</code>, which includes some further discussion and
technical documentation and creates file <code>megaminx.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+megaminx_plotter">megaminx_plotter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(megaminx)
megaminx
megaminx^5  # should be the identity
inverse(megaminx)  # turn each face anticlockwise


megaminx_colours[permprod(megaminx)]  # risky but elegant...

W    # turn the White face one click clockwise (colour names as per the
     # table above)


megaminx_colours[as.word(W,129)]      # it is safer to ensure a size-129 word;
megaminx_colours[as.word(W)]          # but the shorter version will work


# Now some superflip stuff:

X &lt;- W * Pu^(-1) * W * Pu^2 * DY^(-2) 
Y &lt;- LG^(-1) * DB^(-1) * LB * DG      
Z &lt;- Gy^(-2) * LB * LG^(-1) * Pi^(-1) * LY^(-1)


sjc3 &lt;- (X^6)^Y * Z^9  # superflip (Jeremy Clark)


p1 &lt;- (DG^2 * W^4 * DB^3 * W^3 * DB^2 * W^2 * DB^2 * R * W * R)^3
m1 &lt;- p1^(Pi^3)

p2 &lt;- (O^2 * LG^4 * DB^3 * LG^3 * DB^2 * LG^2 * DB^2 * DY * LG * DY)^3
m2 &lt;- p2^(DB^2)

p3 &lt;- (LB^2 * LY^4 * Gy * Pi^3 * LY * Gy^4)^3
m3 &lt;- p3^LB

# m1,m2 are 32 moves, p3 is 20, total = 84

stopifnot(m1+m2+m3==sjc3)




</code></pre>

<hr>
<h2 id='megaminx_plotter'>Plotting routine for megaminx sequences</h2><span id='topic+megaminx_plotter'></span><span id='topic+megaminx_pentagons'></span><span id='topic+megaminx_triangles'></span><span id='topic+megaminx_quads'></span>

<h3>Description</h3>

<p>Plots a coloured diagram of a dodecahedron net representing a megaminx
</p>


<h3>Usage</h3>

<pre><code class='language-R'>megaminx_plotter(megperm=id,offset=c(0,0),M=diag(2),setup=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="megaminx_plotter_+3A_megperm">megperm</code></td>
<td>
<p>Permutation to be plotted</p>
</td></tr>
<tr><td><code id="megaminx_plotter_+3A_offset">offset</code>, <code id="megaminx_plotter_+3A_m">M</code></td>
<td>
<p>Offset and transformation matrix, see details</p>
</td></tr>
<tr><td><code id="megaminx_plotter_+3A_setup">setup</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to set up the
plot with a <code>plot()</code> statement, and <code>FALSE</code> meaning to
plot the points on a pre-existing canvas</p>
</td></tr>
<tr><td><code id="megaminx_plotter_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>polygon()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>megaminx_plotter()</code> plots a coloured diagram of a
dodecahedron net representing a megaminx.  The argument may be
specified as a sequence of turns that are applied to the megaminx from
<var>START</var>.
</p>
<p>The function uses rather complicated internal variables
<code>pentagons</code>, <code>triangles</code>, and <code>quads</code> whose meaning and
genesis is discussed in heavily-documented file <code>inst/guide.R</code>.
</p>
<p>The diagram is centered so that the common vertex of triangles 28 and
82 is at <code class="reqn">(0,0)</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("megaminx")

megaminx_plotter()  # START
megaminx_plotter(W) # after turning the White face one click
megaminx_plotter(superflip)

size &lt;- 0.95
o &lt;- 290

## Not run: 
pdf(file="fig1.pdf")
megaminx_plotter(M=size*diag(2),offset=c(-o,0),setup=TRUE)
megaminx_plotter(W,M=size*diag(2),offset=c(+o,0),setup=FALSE)
dev.off()

pdf(file="fig2.pdf")
p &lt;- permprod(sample(megaminx,100,replace=TRUE))
megaminx_plotter(p,M=size*diag(2),offset=c(-o,0),setup=TRUE)
megaminx_plotter(superflip,M=size*diag(2),offset=c(+o,0),setup=FALSE)
dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='nullperm'>
Null permutations
</h2><span id='topic+nullperm'></span><span id='topic+nullword'></span><span id='topic+nullcycle'></span>

<h3>Description</h3>

<p>Null permutations are the equivalent of <code>NULL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullcycle
nullword
</code></pre>


<h3>Format</h3>

<p>Object <code>nullcycle</code> is an empty list coerced to class
<code>cycle</code>, specifically <code>cycle(list())</code>
</p>
<p>Object <code>nullword</code> is a zero-row matrix, coerced to <code>word</code>,
specifically <code>word(matrix(integer(0),0,0))</code>  
</p>


<h3>Details</h3>

<p>These objects are here to deal with the case where a length-zero
permutation is extracted.  The behaviour of these null objects is not
entirely consistent.
</p>


<h3>Note</h3>

<p>The objects documented here are distinct from the identity
permutation, <code>id</code>, documented separately.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+id">id</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rperm(10,4)[0]  # null word

as.cycle(1:5)[0]  # null cycle

data(megaminx)
c(NULL,megaminx)      # probably not what the user intended...
c(nullcycle,megaminx) # more useful.
c(id,megaminx)        # also useful.

</code></pre>

<hr>
<h2 id='Ops.permutation'>Arithmetic Ops Group Methods for permutations</h2><span id='topic+Ops.permutation'></span><span id='topic+Ops.permutations'></span><span id='topic+Ops'></span><span id='topic+cycle_sum'></span><span id='topic+group_action'></span><span id='topic+word_equal'></span><span id='topic+word_prod'></span><span id='topic+word_prod_single'></span><span id='topic+permprod'></span><span id='topic+cycle_sum_single'></span><span id='topic+cycle_power'></span><span id='topic+cycle_power_single'></span><span id='topic+vps'></span><span id='topic+ccps'></span><span id='topic+helper'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Allows arithmetic operators to be used for manipulation of permutation objects
such as addition, multiplication, division, integer powers, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'permutation'
Ops(e1, e2)
cycle_power(x,pow)
cycle_power_single(x,pow)
cycle_sum(e1,e2)
cycle_sum_single(c1,c2)
group_action(e1,e2)
word_equal(e1,e2)
word_prod(e1,e2)
word_prod_single(e1,e2)
permprod(x)
vps(vec,pow)
ccps(n,pow)
helper(e1,e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.permutation_+3A_x">x</code>, <code id="Ops.permutation_+3A_e1">e1</code>, <code id="Ops.permutation_+3A_e2">e2</code></td>
<td>
<p>Objects of class &ldquo;<code>permutation</code>&rdquo;</p>
</td></tr>
<tr><td><code id="Ops.permutation_+3A_c1">c1</code>, <code id="Ops.permutation_+3A_c2">c2</code></td>
<td>
<p>Objects of class <code>cycle</code></p>
</td></tr>
<tr><td><code id="Ops.permutation_+3A_pow">pow</code></td>
<td>
<p>Integer vector of powers</p>
</td></tr>
<tr><td><code id="Ops.permutation_+3A_vec">vec</code></td>
<td>
<p>In function <code>vps()</code>, a vector of integers
corresponding to a cycle</p>
</td></tr>
<tr><td><code id="Ops.permutation_+3A_n">n</code></td>
<td>
<p>In function <code>ccps()</code>, the integer power to which
<code>cycle(seq_len(n))</code> is to be raised; may be positive or
negative.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Ops.permutation()</code> passes binary arithmetic
operators (&ldquo;<code>+</code>&rdquo;, &ldquo;<code>*</code>&rdquo;, &ldquo;<code>/</code>&rdquo;,
&ldquo;<code>^</code>&rdquo;, and &ldquo;<code>==</code>&rdquo;) to the appropriate
specialist function.
</p>
<p>Multiplication, as in <code>a*b</code>, is effectively
<code>word_prod(a,b)</code>; it coerces its arguments to word form (because
<code>a*b = b[a]</code>).
</p>
<p>Raising permutations to integer powers, as in <code>a^n</code>, is
<code>cycle_power(a,n)</code>; it coerces <code>a</code> to cycle form and returns
a cycle (even if \(n=1\)).  Negative and zero values of <code>n</code>
operate as expected.  Function <code>cycle_power()</code> is vectorized; it
calls <code>cycle_power_single()</code>, which is not.  This calls
<code>vps()</code> (&ldquo;Vector Power Single&rdquo;), which checks for simple
cases such as <code>pow=0</code> or the identity permutation; and function
<code>vps()</code> calls function <code>ccps()</code> which performs the actual
number-theoretic manipulation to raise a cycle to a power.
</p>
<p>Raising a permutation to the power of another permutation, as in
<code>a^b</code>, is idiom for <code>inverse(b)*a*b</code>, sometimes known as
<dfn>group action</dfn>; the notation is motivated by the identities
<code>x^(yz)=(x^y)^z</code> and <code>(xy)^z=x^z*y^z</code>.
</p>
<p>Permutation addition, as in <code>a+b</code>, is defined if the cycle
representations of the addends are disjoint.  The sum is defined as
the permutation given by juxtaposing the cycles of <code>a</code> with those
of <code>b</code>.  Note that this operation is commutative.  If <code>a</code>
and <code>b</code> do not have disjoint cycle representations, an error is
returned.  This is useful if you want to guarantee that two
permutations commute (NB: permutation <code>a</code> commutes with
<code>a^i</code> for <code>i</code> any integer, and in particular <code>a</code>
commutes with itself.  But <code>a+a</code> returns an error: the operation
checks for disjointness, not commutativity).
</p>
<p>Permutation &ldquo;division&rdquo;, as in <code>a/b</code>, is
<code>a*inverse(b)</code>.  Note that <code>a/b*c</code> is evaluated left to
right so is equivalent to <code>a*inverse(b)*c</code>.  See note.
</p>
<p>Function <code>helper()</code> sorts out recycling for binary functions, the
behaviour of which is inherited from <code>cbind()</code>, which also
handles the names of the returned permutation.
</p>


<h3>Value</h3>

<p>None of these functions are really intended for the end user:
use the ops as shown in the examples section.
</p>


<h3>Note</h3>

<p>The class of the returned object is the appropriate one.
</p>
<p>Unary operators to invert a permutation are problematic in the
package.  I do not like using &ldquo;<code>id/x</code>&rdquo; to represent a
permutation inverse: the idiom introduces an utterly redundant
object (&ldquo;<code>id</code>&rdquo;), and forces the use of a binary operator
where a unary operator is needed.  Similar comments apply to
&ldquo;<code>x^-1</code>&rdquo;, which again introduces a redundant object
(<code>-1</code>) and uses a binary operator.
</p>
<p>Currently, &ldquo;<code>-x</code>&rdquo; returns the multiplicative inverse of
<code>x</code>, but this is not entirely satisfactory either, as it uses
additive notation: the rest of the package uses multiplicative
notation.  Thus <code>x*-x == id</code>, which looks a little odd but OTOH
noone has a problem with <code>x^-1</code> for inverses.
</p>
<p>I would like to follow APL and use &ldquo;<code>/x</code>&rdquo;,
but this does not seem to be possible in R.  The natural
unary operator would be the exclamation mark &ldquo;<code>!x</code>&rdquo;.
However, redefining the exclamation mark to give permutation
inverses, while possible, is not desirable because its precedence is
too low.  One would like <code>!x*y</code> to return <code>inverse(x)*y</code>
but instead standard precedence rules means that it returns
<code>inverse(x*y)</code>.  Earlier versions of the package interpreted
<code>!x</code> as <code>inverse(x)</code>, but it was a disaster: to implement
the commutator \([x,y]=x^{-1}y^{-1}xy\),
for example, one would like to use <code>!x*!y*x*y</code>, but this is
interpreted as <code>!(x*(!y*(x*y)))</code>; one has to use
<code>(!x)*(!y)*x*y</code>.  I found myself having to use heaps of
brackets everywhere.  This caused such severe cognitive dissonance
that I removed exclamation mark for inverses from the package.  I
might reinstate it in the future.  There does not appear to be a way
to define a new unary operator due to the construction of the
parser.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- rperm(10,9) # word form
y &lt;- rperm(10,9) # word form

x*y  # products are given in word form but the print method coerces to cycle form
print_word(x*y)

x^5  # powers are given in cycle form

x^as.cycle(1:5)  # group action (not integer power!); coerced to word.

x*inverse(x) == id  # all TRUE


# the 'sum' of two permutations is defined if their cycles are disjoint:
as.cycle(1:4) + as.cycle(7:9)

data(megaminx)
megaminx[1] + megaminx[7:12] 

</code></pre>

<hr>
<h2 id='orbit'>
Orbits of integers
</h2><span id='topic+orbit'></span><span id='topic+orbit_single'></span>

<h3>Description</h3>

<p>Finds the orbit of a given integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orbit_single(c1,n1)
orbit(cyc,n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orbit_+3A_c1">c1</code>, <code id="orbit_+3A_n1">n1</code></td>
<td>
<p>In (low-level) function <code>orbit_single()</code>, a cyclist
and an integer vector respectively</p>
</td></tr>
<tr><td><code id="orbit_+3A_cyc">cyc</code>, <code id="orbit_+3A_n">n</code></td>
<td>
<p>In (vectorized) function <code>orbit()</code>, <code>cyc</code> is
coerced to a cycle, and <code>n</code> is an integer vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Given a cyclist <code>c1</code> and integer <code>n1</code>, function
<code>orbit_single()</code> returns the single cycle containing integer
<code>n1</code>.  This is a low-level function, not intended for the
end-user.
</p>
<p>Function <code>orbit()</code> is the vectorized equivalent of
<code>orbit_single()</code>.  Vectorization is inherited from
<code>cbind()</code>. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixed">fixed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
orbit(as.cycle("(123)"),1:5)
orbit(as.cycle(c("(12)","(123)(45)","(2345)")),1)
orbit(as.cycle(c("(12)","(123)(45)","(2345)")),1:3)

data(megaminx)
orbit(megaminx,13)

</code></pre>

<hr>
<h2 id='perm_matrix'>Permutation matrices</h2><span id='topic+perm_matrix'></span><span id='topic+permmatrix'></span><span id='topic+permutation_matrix'></span><span id='topic+is.perm_matrix'></span><span id='topic+as.perm_matrix'></span><span id='topic+pm_to_perm'></span>

<h3>Description</h3>

<p>Given a permutation, coerce to word form and return the corresponding
permutation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm_matrix(p,s=size(p))
is.perm_matrix(M)
pm_to_perm(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perm_matrix_+3A_p">p</code></td>
<td>
<p>Permutation, coerced to word form, of length 1</p>
</td></tr>
<tr><td><code id="perm_matrix_+3A_s">s</code></td>
<td>
<p>Size of permutation matrix or permutation</p>
</td></tr>
<tr><td><code id="perm_matrix_+3A_m">M</code></td>
<td>
<p>Permutation matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a permutation <code>p</code> of size <code class="reqn">s</code>, function
<code>perm_matrix()</code> returns a square matrix with <code class="reqn">s</code> rows and
<code class="reqn">s</code> columns.  Entries are either 0 or 1; each row and each column
has exactly one entry of 1 and the rest zero.
</p>
<p>Row and column names of the permutation matrix are integers; this
makes the printed version more compact.
</p>
<p>Function <code>pm_to_perm()</code> takes a permutation matrix and returns
the equivalent permutation in word form.
</p>


<h3>Note</h3>

<p>Given a word <code>p</code> with size <code>s</code>, the idiom for
<code>perm_matrix()</code> boils down to
</p>
<pre>
    M &lt;- diag(s)
    M[p,]
  </pre>
<p>This is used explicitly in the <code>representations</code> vignette.  There
is another way:
</p>
<pre>
    M &lt;- diag(s)
    M[cbind(seq_len(s),p)] &lt;- 1
    M
  </pre>
<p>which might be useful sometime.
</p>
<p>See also the <code>representation</code> and <code>order_of_ops</code> vignettes, which
discuss permutation matrices.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+permutation">permutation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
perm_matrix(rperm(1,9))


p1 &lt;- rperm(1,40)
M1 &lt;- perm_matrix(p1)
p2 &lt;- rperm(1,40)
M2 &lt;- perm_matrix(p2)

stopifnot(is.perm_matrix(M1))

stopifnot(all(solve(M1) == perm_matrix(inverse(p1))))
stopifnot(all(M1 %*% M2 == perm_matrix(p1*p2)))


stopifnot(p1 == pm_to_perm(perm_matrix(p1)))

data("megaminx")
image(perm_matrix(permprod(megaminx)),asp=1,axes=FALSE)

</code></pre>

<hr>
<h2 id='permorder'>
The order of a permutation
</h2><span id='topic+permorder'></span>

<h3>Description</h3>

<p>Returns the order of a permutation <code class="reqn">P</code>: the smallest strictly
positive integer <code class="reqn">n</code> for which <code class="reqn">P^n</code> is the identity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permorder(x, singly = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permorder_+3A_x">x</code></td>
<td>
<p>Permutation, coerced to <code>cycle</code> form</p>
</td></tr>
<tr><td><code id="permorder_+3A_singly">singly</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return the
order of each element of the vector, and <code>FALSE</code> meaning to
return the order of the vector itself (that is, the smallest
strictly positive integer for which <code>all(x^n==id)</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces its argument to cycle form.
</p>
<p>The order of the identity permutation is 1.
</p>


<h3>Note</h3>

<p>Uses <code>mLCM()</code> from the <code>numbers</code> package.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sgn">sgn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rperm(5,20)
permorder(x)
permorder(x,FALSE)

stopifnot(all(is.id(x^permorder(x))))
stopifnot(is.id(x^permorder(x,FALSE)))
</code></pre>

<hr>
<h2 id='permutation'>
Functions to create and coerce word objects and cycle objects
</h2><span id='topic+permutation'></span><span id='topic+is.permutation'></span><span id='topic+cycle'></span><span id='topic+as.cycle'></span><span id='topic+is.cycle'></span><span id='topic+word'></span><span id='topic+as.word'></span><span id='topic+is.word'></span><span id='topic+cycle2word'></span><span id='topic+char2cycle'></span><span id='topic+cyc_len'></span><span id='topic+shift_cycle'></span><span id='topic+as.matrix'></span><span id='topic+as.matrix.word'></span>

<h3>Description</h3>

<p>Functions to create permutation objects.  <code>permutation</code> is a
virtual class. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>word(M)
permutation(x)
is.permutation(x)
cycle(x)
is.word(x)
is.cycle(x)
as.word(x,n=NULL)
as.cycle(x)
cycle2word(x,n=NULL)
char2cycle(char)
cyc_len(n)
shift_cycle(n)
## S3 method for class 'word'
as.matrix(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutation_+3A_m">M</code></td>
<td>
<p>In function <code>word()</code>, a matrix with rows corresponding
to permutations in word form</p>
</td></tr>
<tr><td><code id="permutation_+3A_x">x</code></td>
<td>
<p>See details</p>
</td></tr>
<tr><td><code id="permutation_+3A_n">n</code></td>
<td>
<p>In functions <code>as.word()</code> and <code>cycle2word()</code>, the
size of the word to return; in function <code>cyc_len()</code>, the length
of the cycle to return</p>
</td></tr>
<tr><td><code id="permutation_+3A_char">char</code></td>
<td>
<p>In function <code>char2cycle()</code> a character vector which
is coerced to a cycle object</p>
</td></tr>
<tr><td><code id="permutation_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>as.matrix()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>word()</code> and <code>cycle()</code> are rather formal functions
which make no attempt to coerce their arguments into sensible forms.
The user should use <code>permutation()</code>, which detects the form of the
input and dispatches to <code>as.word()</code> or <code>as.cycle()</code>, which
are much more user-friendly.
</p>
<p>Functions <code>word()</code> and <code>cycle()</code> are the only functions in the
package which assign class <code>word</code> or <code>cycle</code> to an
object.   
</p>
<p>A <em>word</em> is a matrix whose rows correspond to permutations in word
format.  
</p>
<p>A <dfn>cycle</dfn> is a list whose elements correspond to permutations in
cycle form.  A <code>cycle</code> object comprises elements which are
informally dubbed &lsquo;cyclists&rsquo;.  A cyclist is a list of integer
vectors corresponding to the cycles of the permutation.
</p>
<p>Function  <code>cycle2word()</code> converts cycle objects to word objects.
</p>
<p>Function <code>shift_cycle()</code> is a convenience wrapper for
<code>as.cycle(seq_len(n))</code>; <code>cyc_len()</code> is a synonym.
</p>
<p>It is a very common error (at least, it is for me) to use <code>cycle()</code>
when you meant <code>as.cycle()</code>.
</p>
<p>The print method is sensitive to the value of option
&lsquo;<code>print_word_as_cycle</code>&rsquo;, documented at <code>print.Rd</code>.
</p>
<p>Function <code>as.matrix.word()</code> coerces a vector of permutations in word form to
a matrix, each row of which is a word.  To get a permutation matrix (that is, a
square matrix of ones and zeros with exactly one entry of 1 in each row and each column),
use <code>perm_matrix()</code>.                                            
</p>


<h3>Value</h3>

<p>Returns a <code>cycle</code> object or a <code>word object</code>
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+cyclist">cyclist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
word(matrix(1:8,7,8)) # default print method coerces to cycle form

cycle(list(list(c(1,8,2),c(3,6)),list(1:2, 4:8)))

char2cycle(c("(1,4)(6,7)","(3,4,2)(8,19)", "(56)","(12345)(78)","(78)"))

jj &lt;- c(4,2,3,1)

as.word(jj)
as.cycle(jj)

as.cycle(1:2)*as.cycle(1:8) == as.cycle(1:8)*as.cycle(1:2)  # FALSE!

x &lt;- rperm(10,7)
y &lt;- rperm(10,7)
as.cycle(commutator(x,y))

cycle(sapply(seq_len(9),cyc_len))

</code></pre>

<hr>
<h2 id='permutations-package'>
The Symmetric Group: Permutations of a Finite Set
</h2><span id='topic+permutations-package'></span><span id='topic+permutations'></span>

<h3>Description</h3>

<p>Manipulates invertible functions from a finite set to
             itself.  Can transform from word form to cycle form and
             back.  To cite the package in publications please use
             Hankin (2020) &quot;Introducing the permutations R package&quot;,
             SoftwareX, volume 11 &lt;doi:10.1016/j.softx.2020.100453&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> permutations</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> The Symmetric Group: Permutations of a Finite Set</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> magic,numbers,partitions (&gt;= 1.9-17),freealg (&gt;= 1.0-4),mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(
    person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415")),
    person("Paul", "Egeler", email = "paulegeler@gmail.com", role = c("ctb"), comment = c(ORCID = "0000-0001-6948-9498"))
    )</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0), methods</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Manipulates invertible functions from a finite set to
             itself.  Can transform from word form to cycle form and
             back.  To cite the package in publications please use
             Hankin (2020) "Introducing the permutations R package",
             SoftwareX, volume 11 &lt;doi:10.1016/j.softx.2020.100453&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> rmarkdown,testthat,knitr,magrittr</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/permutations</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/permutations/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;),
  Paul Egeler [ctb] (&lt;https://orcid.org/0000-0001-6948-9498&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Ops.permutation         Arithmetic Ops Group Methods for permutations
allperms                All permutations of a given size and all cycles
                        of a given length
as.function.permutation
                        Coerce a permutation to a function
c                       Concatenation of permutations
capply                  Apply functions to elements of a cycle
cayley                  Cayley tables for permutation groups
commutator              Group-theoretic commutator and group action;
                        the dot object
conjugate               Are two permutations conjugate?
cyclist                 details of cyclists
derangement             Tests for a permutation being a derangement
dodecahedron            The dodecahedron group
faro                    Faro shuffles
fbin                    The fundamental bijection
fixed                   Fixed elements
get1                    Retrieve particular cycles or components of
                        cycles
id                      The identity permutation
inverse                 Inverse of a permutation
length.word             Various vector-like utilities for permutation
                        objects.
megaminx                megaminx
megaminx_plotter        Plotting routine for megaminx sequences
nullperm                Null permutations
orbit                   Orbits of integers
perm_matrix             Permutation matrices
permorder               The order of a permutation
permutation             Functions to create and coerce word objects and
                        cycle objects
permutations-package    The Symmetric Group: Permutations of a Finite
                        Set
print.permutation       Print methods for permutation objects
rperm                   Random permutations
sgn                     Sign of a permutation
shape                   Shape of a permutation
size                    Gets or sets the size of a permutation
tidy                    Utilities to neaten permutation objects
valid                   Functions to validate permutations
</pre>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rperm(10,5)
b &lt;- rperm(10,5)

a*b

inverse(a)


</code></pre>

<hr>
<h2 id='print'>
Print methods for permutation objects
</h2><span id='topic+print.permutation'></span><span id='topic+print.word'></span><span id='topic+print.cycle'></span><span id='topic+print_word'></span><span id='topic+print_cycle'></span><span id='topic+as.character.cycle'></span><span id='topic+as.character_cyclist'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Print methods for permutation objects with matrix-like printing for
words and bracket notation for cycle objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cycle'
print(x, ...)
## S3 method for class 'word'
print(x, h = getOption("print_word_as_cycle"), ...)
as.character_cyclist(y,comma=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Object of class <code>permutation</code> with <code>word</code> objects
dispatched to <code>print.word()</code> and <code>cycle</code> objects dispatched to
<code>print.cycle()</code></p>
</td></tr>
<tr><td><code id="print_+3A_h">h</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to coerce words
to cycle form before printing.  See details</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="print_+3A_y">y</code>, <code id="print_+3A_comma">comma</code></td>
<td>
<p>In <code>as.character.cyclist()</code>, argument <code>y</code>
is a list of cycles (a cyclist); and <code>comma</code> is Boolean,
specifying whether to include a comma in the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Printing of word objects is controlled by
<code>options("print_word_as_cycle")</code>.  The default behaviour is to
coerce a word to cycle form and print that, with a notice that the
object itself was coerced from word.
</p>
<p>If <code>options("print_word_as_cycle")</code> is <code>FALSE</code>, then objects
of class word are printed as a matrix with rows being the permutations
and fixed points indicated with a dot.
</p>
<p>Function <code>as.character_cyclist()</code> is an internal function used by
<code>print.cycle()</code>, and is not really designed for the end-user.  It
takes a cyclist and returns a character string.
</p>
<p>Function <code>print_word()</code> and <code>print_cycle()</code> are provided for
power users.  These functions print their argument directly as word or
cycle form; they coerce to the appropriate form.  Use
<code>print_word()</code> if you have a permutation in word form and want to
inspect it as a word form but (for some reason) do not want to set
<code>options("print_word_as_cycle")</code>.  See <code>size.Rd</code> for a
use-case.
</p>
<p>The print method includes experimental functionality to display
permutations of sets other than the default of integers
\(1,2,\ldots, n\).  Both cycle and word print methods
are sensitive to option <code>perm_set</code>: the default value of
<code>NULL</code> means to use integers.  The symbols may be the elements of
any character vector; use idiom such as
</p>
<pre>options("perm_set" = letters)</pre>
<p>to override the default.  But beware!  If the permutation includes
numbers greater than the length of <code>perm_set</code>, then <code>NA</code>
will be printed.  It is possible to use vectors with elements of more
than one character (e.g. <code>state.abb</code>).
</p>
<p>In the printing of cycle objects, commas are controlled with option
<code>"comma"</code>.  The default <code>NULL</code> means including commas in the
representation if the size of the permutation exceeds 9.  This works
well for integers but is less suitable when using letters or state
abbreviations.  Force the use of commas by setting the option to
<code>TRUE</code> or <code>FALSE</code>, e.g.
</p>
<pre>options("comma" = TRUE)</pre>
<p>The print method does not change the internal representation of word
or cycle objects, it only affects how they are printed.
</p>
<p>There is a package vignette (type <code>vignette("print")</code> at the
command line) which gives more details and long-form documentation.
</p>


<h3>Value</h3>

<p>Returns its argument invisibly, after printing it.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nicify_cyclist">nicify_cyclist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate a permutation in *word* form:
x &lt;- rperm(4,9)

# default behaviour is to print in cycle form irregardless:
x

# change default using options():
options(print_word_as_cycle=FALSE)

# objects in word form now printed using matrix notation:
x

# printing of cycle form objects not altered:
as.cycle(x)

# restore default:
options(print_word_as_cycle=TRUE)

as.character_cyclist(list(1:4,10:11,20:33))  # x a cyclist;
as.character_cyclist(list(c(1,5,4),c(2,2)))  # does not check for consistency
as.character_cyclist(list(c(1,5,4),c(2,9)),comma=FALSE)

options("perm_set" = letters)
rperm(r=9)
options("perm_set" = NULL)  # restore default
</code></pre>

<hr>
<h2 id='rperm'>
Random permutations
</h2><span id='topic+rperm'></span><span id='topic+rword'></span><span id='topic+rcycle'></span><span id='topic+rcyc'></span><span id='topic+r1cyc'></span>

<h3>Description</h3>

<p>Function <code>rperm()</code> creates a word object of random permutations.
Function <code>rcyc()</code> creates random permutations comprising a single
(group-theoretic) cycle of a specified length (<code>r1cyc()</code> is a
low-level helper function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rperm(n=10,r=7,moved=NA)
rcyc(n,len,r=len)
r1cyc(len,r=len)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rperm_+3A_n">n</code></td>
<td>
<p>Number of permutations to create</p>
</td></tr>
<tr><td><code id="rperm_+3A_r">r</code></td>
<td>
<p>Size of permutations</p>
</td></tr>
<tr><td><code id="rperm_+3A_len">len</code></td>
<td>
<p>Length of cycles in <code>rcyc()</code> and <code>r1cyc()</code></p>
</td></tr>
<tr><td><code id="rperm_+3A_moved">moved</code></td>
<td>
<p>In function <code>rperm()</code>, integer specifying how many
elements can move (that is, how many elements do not map to
themselves), with default <code>NA</code> meaning to choose a permutation
at random.  This is useful if you want a permutation that has a
compact cycle representation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>word</code>
</p>


<h3>Note</h3>

<p>Argument <code>moved</code> specifies a <em>maximum</em> number of elements
that do not map to themselves; the actual number of non-fixed elements
might be lower (as some elements might map to themselves).  You can
control the number of non-fixed elements precisely with argument
<code>len</code> of function <code>rcyc()</code>, although this will give only
permutations with a single (group-theoretic) cycle.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+size">size</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rperm()
as.cycle(rperm(30,9))
rperm(10,9,2)

rcyc(20,5)
rcyc(20,5,9)
</code></pre>

<hr>
<h2 id='sgn'>
Sign of a permutation
</h2><span id='topic+sgn'></span><span id='topic+is.even'></span><span id='topic+is.odd'></span>

<h3>Description</h3>

<p>The sign of a permutation is <code class="reqn">\pm 1</code> depending on whether it
is even or odd
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgn(x)
is.even(x)
is.odd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgn_+3A_x">x</code></td>
<td>
<p>permutation object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces to cycle form
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shape">shape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sgn(id)  # always problematic

sgn(rperm(10,5))

x &lt;- rperm(40,6)
y &lt;- rperm(40,6)


stopifnot(all(sgn(x*y) == sgn(x)*sgn(y)))   # sgn() is a homomorphism


z &lt;- as.cycle(rperm(20,9,5))
z[is.even(z)]
z[is.odd(z)]

</code></pre>

<hr>
<h2 id='shape'>Shape of a permutation</h2><span id='topic+shape'></span><span id='topic+padshape'></span><span id='topic+shape_cyclist'></span><span id='topic+shapepart'></span><span id='topic+shapepart_cyclist'></span>

<h3>Description</h3>

<p>Returns the shape of a permutation.  If given a word, it coerces to
cycle form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape(x, drop = TRUE,id1=TRUE)
shape_cyclist(cyc,id1=TRUE)
padshape(x, drop = TRUE, n=NULL)
shapepart(x)
shapepart_cyclist(cyc,n=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape_+3A_x">x</code></td>
<td>
<p>Object of class <code>cycle</code> (if not, coerced)</p>
</td></tr>
<tr><td><code id="shape_+3A_cyc">cyc</code></td>
<td>
<p>A cyclist</p>
</td></tr>
<tr><td><code id="shape_+3A_n">n</code></td>
<td>
<p>Integer governing the size of the partition assumed, with
default <code>NULL</code> meaning to use the largest element</p>
</td></tr>
<tr><td><code id="shape_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to unlist if
possible</p>
</td></tr>
<tr><td><code id="shape_+3A_id1">id1</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> in function
<code>shape_cyclist()</code> meaning that the shape of the identity is
&ldquo;1&rdquo; and <code>FALSE</code> meaning that the shape is <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>shape()</code> returns a list with elements representing the
lengths of the component cycles.
</p>
<p>Function <code>shapepart()</code> returns an object of class
<code>partition</code> showing the permutation as a set partition of
disjoint cycles.
</p>


<h3>Note</h3>

<p>Function <code>shape()</code> returns the lengths of the cycles in the order
returned by <code>nicify_cyclist()</code>, so not necessarily in increasing
or decreasing order.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+size">size</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
jj &lt;- as.cycle(c("123","","(12)(34)","12345"))
jj
shape(jj)



shape(rperm(10,9)) # coerced to cycle


data(megaminx)

shape(megaminx)
jj &lt;- megaminx*megaminx[1]

identical(shape(jj),shape(tidy(jj)))  #tidy() does not change shape


allperms(3)
shapepart(allperms(3))
shapepart(rperm(10,5))

shape_cyclist(list(1:4,8:9))
shapepart_cyclist(list(1:4,8:9))

</code></pre>

<hr>
<h2 id='size'>
Gets or sets the size of a permutation
</h2><span id='topic+size'></span><span id='topic+size.cycle'></span><span id='topic+size+3C-.cycle'></span><span id='topic+size.word'></span><span id='topic+size+3C-'></span><span id='topic+size+3C-.word'></span><span id='topic+addcols'></span>

<h3>Description</h3>

<p>The &lsquo;size&rsquo; of a permutation is the cardinality of the set for
which it is a bijection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(x)
addcols(M,n)
## S3 method for class 'word'
size(x)
## S3 method for class 'cycle'
size(x)
## S3 replacement method for class 'word'
size(x) &lt;- value
## S3 replacement method for class 'cycle'
size(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_+3A_x">x</code></td>
<td>
<p>A permutation object</p>
</td></tr>
<tr><td><code id="size_+3A_m">M</code></td>
<td>
<p>A matrix that may be coerced to a word</p>
</td></tr>
<tr><td><code id="size_+3A_n">n</code>, <code id="size_+3A_value">value</code></td>
<td>
<p>the size to set to, an integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a <code>word</code> object, the <dfn>size</dfn> is equal to the number of columns.
For a <code>cycle</code> object, it is equal to the largest element of any
cycle.
</p>
<p>Function <code>addcols()</code> is a low-level function that operates on, and
returns, a matrix.  It just adds columns to the right of <code>M</code>, with
values equal to their column numbers, thus corresponding to fixed
elements.  The resulting matrix has <code>n</code> columns.  This function
cannot remove columns, so if <code>n&lt;ncol(M)</code> an error is returned.
</p>
<p>Setting functions cannot decrease the size of a permutation; use
<code>trim()</code> for this.
</p>
<p>It is meaningless to change the size of a <code>cycle</code> object.  Trying
to do so will result in an error.  But you can coerce cycle objects to
<code>word</code> form, and change the size of that.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixed">fixed</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
size(as.cycle(c("(17)","(123)(45)")))  # should be 7

x &lt;- as.word(as.cycle("123"))
print_word(x)
size(x) &lt;- 9
print_word(x)


size(as.cycle(1:5) + as.cycle(100:101))

size(id)
</code></pre>

<hr>
<h2 id='tidy'>
Utilities to neaten permutation objects
</h2><span id='topic+tidy'></span><span id='topic+trim'></span>

<h3>Description</h3>

<p>Various utilities to neaten word objects by removing fixed elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy(x)
trim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_+3A_x">x</code></td>
<td>
<p>Object of class <code>word</code>, or in the case of
<code>tidy()</code>, coerced to class <code>word</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>trim()</code> takes a <code>word</code> and, starting from the right,
strips off columns corresponding to fixed elements until it finds a
non-fixed element.  This makes no sense for <code>cycle</code> objects; if
<code>x</code> is of class <code>cycle</code>, an error is returned.
</p>
<p>Function <code>tidy()</code> is more aggressive.  This firstly removes
<em>all</em> fixed elements, then renames the non-fixed ones to match the
new column numbers.  The map is an isomorphism (sic) with respect to
composition.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>word</code>
</p>


<h3>Note</h3>

<p>Results in empty (that is, zero-column) words if a vector of identity
permutations is given
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixed">fixed</a></code>,<code><a href="#topic+size">size</a></code>,<code><a href="#topic+nicify_cyclist">nicify_cyclist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.cycle(5:3)+as.cycle(7:9)
tidy(as.cycle(5:3)+as.cycle(7:9))

as.cycle(tidy(c(as.cycle(1:2),as.cycle(6:7))))


nicify_cyclist(list(c(4,6), c(7), c(2,5,1), c(8,3)))

data(megaminx)
tidy(megaminx)  # has 120 columns, not 129
stopifnot(all(unique(sort(unlist(as.cycle(tidy(megaminx)),recursive=TRUE)))==1:120))

jj &lt;- megaminx*megaminx[1]
stopifnot(identical(shape(jj),shape(tidy(jj))))  #tidy() does not change shape

</code></pre>

<hr>
<h2 id='valid'>
Functions to validate permutations
</h2><span id='topic+valid'></span><span id='topic+validity'></span><span id='topic+singleword_valid'></span><span id='topic+cyclist_valid'></span>

<h3>Description</h3>

<p>Functions to validate permutation objects: if valid, return <code>TRUE</code>
and if not valid, generate a <code>warning()</code> and return <code>FALSE</code>.
</p>
<p>Function <code>singleword.valid()</code> takes an integer vector, interpreted
as a word, and checks that it is a permutation of
<code>seq_len(max(x))</code>.
</p>
<p>Function <code>cycle.valid()</code> takes a cyclist and checks for disjoint
cycles of strictly positive integers with no repeats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singleword_valid(w)
cyclist_valid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid_+3A_x">x</code></td>
<td>
<p>In function <code>cycle_valid()</code>, a cyclist</p>
</td></tr>
<tr><td><code id="valid_+3A_w">w</code></td>
<td>
<p>In function <code>singleword_valid()</code>, an integer vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either <code>TRUE</code>, or stops with an informative error message
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+cyclist">cyclist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
singleword_valid(sample(1:9))      # TRUE
singleword_valid(c(3L,4L,2L,1L))   # TRUE
singleword_valid(c(3,4,2,1))       # FALSE (not integer)
singleword_valid(c(3L,3L,2L,1L))   # FALSE (3 repeated)

cyclist_valid(list(c(1,8,2),c(3,6))) # TRUE
cyclist_valid(list(c(1,8,2),c(3,6))) # FALSE ('8' is repeated)
cyclist_valid(list(c(1,8,1),c(3,6))) # FALSE ('1' is repeated)
cyclist_valid(list(c(0,8,2),c(3,6))) # FALSE (zero element)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
