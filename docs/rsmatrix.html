<!DOCTYPE html><html lang="en"><head><title>Help for package rsmatrix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rsmatrix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rsmatrix-package'><p>rsmatrix: Matrices for Repeat-Sales Price Indexes</p></a></li>
<li><a href='#rs_matrix'><p>Shiller's repeat-sales matrices</p></a></li>
<li><a href='#rs_pairs'><p>Sales pairs</p></a></li>
<li><a href='#rs_var'><p>Robust variance matrix for repeat-sales indexes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Matrices for Repeat-Sales Price Indexes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.9</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate the matrices in
    Shiller (1991, &lt;<a href="https://doi.org/10.1016%2FS1051-1377%2805%2980028-2">doi:10.1016/S1051-1377(05)80028-2</a>&gt;) that serve as the
    foundation for many repeat-sales price indexes.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.5-0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), gpindex, piar (&ge;
0.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://marberts.github.io/rsmatrix/">https://marberts.github.io/rsmatrix/</a>,
<a href="https://github.com/marberts/rsmatrix">https://github.com/marberts/rsmatrix</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/marberts/rsmatrix/issues">https://github.com/marberts/rsmatrix/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-14 03:13:50 UTC; steve</td>
</tr>
<tr>
<td>Author:</td>
<td>Steve Martin <a href="https://orcid.org/0000-0003-2544-9480"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steve Martin &lt;marberts@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-14 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rsmatrix-package'>rsmatrix: Matrices for Repeat-Sales Price Indexes</h2><span id='topic+rsmatrix'></span><span id='topic+rsmatrix-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Calculate the matrices in Shiller (1991, <a href="https://doi.org/10.1016/S1051-1377%2805%2980028-2">doi:10.1016/S1051-1377(05)80028-2</a>) that serve as the foundation for many repeat-sales price indexes.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Steve Martin <a href="mailto:marberts@protonmail.com">marberts@protonmail.com</a> (<a href="https://orcid.org/0000-0003-2544-9480">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://marberts.github.io/rsmatrix/">https://marberts.github.io/rsmatrix/</a>
</p>
</li>
<li> <p><a href="https://github.com/marberts/rsmatrix">https://github.com/marberts/rsmatrix</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/marberts/rsmatrix/issues">https://github.com/marberts/rsmatrix/issues</a>
</p>
</li></ul>


<hr>
<h2 id='rs_matrix'>Shiller's repeat-sales matrices</h2><span id='topic+rs_matrix'></span>

<h3>Description</h3>

<p>Create a function to compute the <code class="reqn">Z</code>, <code class="reqn">X</code>, <code class="reqn">y</code>, and <code class="reqn">Y</code>
matrices in Shiller (1991, sections I-II) from sales-pair data in order to
calculate a repeat-sales price index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rs_matrix(t2, t1, p2, p1, f = NULL, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rs_matrix_+3A_t2">t2</code>, <code id="rs_matrix_+3A_t1">t1</code></td>
<td>
<p>A pair of vectors giving the time period of the second and
first sale, respectively. Usually a vector of dates, but other values are
possible if they can be coerced to character vectors and sorted in
chronological order (i.e., with <code><a href="base.html#topic+order">order()</a></code>).</p>
</td></tr>
<tr><td><code id="rs_matrix_+3A_p2">p2</code>, <code id="rs_matrix_+3A_p1">p1</code></td>
<td>
<p>A pair of numeric vectors giving the price of the second and
first sale, respectively.</p>
</td></tr>
<tr><td><code id="rs_matrix_+3A_f">f</code></td>
<td>
<p>An optional factor the same length as <code>t1</code> and <code>t2</code>, or a
vector to be turned into a factor, that is used to group sales.</p>
</td></tr>
<tr><td><code id="rs_matrix_+3A_sparse">sparse</code></td>
<td>
<p>Should sparse matrices from the <span class="pkg">Matrix</span> package be used
(faster for large datasets), or regular dense matrices (the default)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returned by <code>rs_matrix()</code> computes a generalization of the
matrices in Shiller (1991, sections I-II) that are applicable to grouped
data. These are useful for calculating separate indexes for many, say,
cities without needing an explicit loop.
</p>
<p>The <code class="reqn">Z</code>, <code class="reqn">X</code>, and <code class="reqn">Y</code> matrices are not well defined if either
<code>t1</code> or <code>t2</code> have missing values, and an error is thrown in this
case. Similarly, it should always be the case that <code>t2 &gt; t1</code>, otherwise
a warning is given.
</p>


<h3>Value</h3>

<p>A function that takes a single argument naming the desired matrix.
It returns one of two matrices (<code class="reqn">Z</code> and <code class="reqn">X</code>) or two vectors
(<code class="reqn">y</code> and <code class="reqn">Y</code>), either regular matrices if <code>sparse = FALSE</code>, or sparse
matrices of class <code>dgCMatrix</code> if <code>sparse = TRUE</code>.
</p>


<h3>References</h3>

<p>Bailey, M. J., Muth, R. F., and Nourse, H. O. (1963). A regression method
for real estate price index construction.
<em>Journal of the American Statistical Association</em>, 53(304):933-942.
</p>
<p>Shiller, R. J. (1991). Arithmetic repeat sales price estimators.
<em>Journal of Housing Economics</em>, 1(1):110-126.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rs_pairs">rs_pairs()</a></code> for turning sales data into sales pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make some data
x &lt;- data.frame(
  date = c(3, 2, 3, 2, 3, 3),
  date_prev = c(1, 1, 2, 1, 2, 1),
  price = 6:1,
  price_prev = 1
)

# Calculate matrices
mat &lt;- with(x, rs_matrix(date, date_prev, price, price_prev))
Z &lt;- mat("Z") # Z matrix
X &lt;- mat("X") # X matrix
y &lt;- mat("y") # y vector
Y &lt;- mat("Y") # Y vector

# Calculate the GRS index in Bailey, Muth, and Nourse (1963)
b &lt;- solve(crossprod(Z), crossprod(Z, y))[, 1]
# or b &lt;- qr.coef(qr(Z), y)
(grs &lt;- exp(b) * 100)

# Standard errors
vcov &lt;- rs_var(y - Z %*% b, Z)
sqrt(diag(vcov)) * grs # delta method

# Calculate the ARS index in Shiller (1991)
b &lt;- solve(crossprod(Z, X), crossprod(Z, Y))[, 1]
# or b &lt;- qr.coef(qr(crossprod(Z, X)), crossprod(Z, Y))
(ars &lt;- 100 / b)

# Standard errors
vcov &lt;- rs_var(Y - X %*% b, Z, X)
sqrt(diag(vcov)) * ars^2 / 100 # delta method

# Works with grouped data
x &lt;- data.frame(
  date = c(3, 2, 3, 2),
  date_prev = c(2, 1, 2, 1),
  price = 4:1,
  price_prev = 1,
  group = c("a", "a", "b", "b")
)

mat &lt;- with(x, rs_matrix(date, date_prev, price, price_prev, group))
b &lt;- solve(crossprod(mat("Z"), mat("X")), crossprod(mat("Z"), mat("Y")))[, 1]
100 / b

</code></pre>

<hr>
<h2 id='rs_pairs'>Sales pairs</h2><span id='topic+rs_pairs'></span>

<h3>Description</h3>

<p>Turn repeat-sales data into sales pairs that are suitable for making
repeat-sales matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rs_pairs(period, product, match_first = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rs_pairs_+3A_period">period</code></td>
<td>
<p>A vector that gives the time period for each sale. Usually a
date vector, or a factor with the levels in chronological order, but other
values are possible if they can be sorted in chronological order (i.e., with
<code><a href="base.html#topic+order">order()</a></code>).</p>
</td></tr>
<tr><td><code id="rs_pairs_+3A_product">product</code></td>
<td>
<p>A vector that gives the product identifier for each sale.
Usually a factor or vector of integer codes for each product.</p>
</td></tr>
<tr><td><code id="rs_pairs_+3A_match_first">match_first</code></td>
<td>
<p>Should products in the first period match with
themselves (the default)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of indices giving the position of the previous sale
for each <code>product</code>, with the convention that the previous sale for the
first sale is itself if <code>match_first = TRUE</code>, <code>NA</code> otherwise. Ties are
resolved according to the order they appear in <code>period</code>.
</p>


<h3>Note</h3>

<p><code><a href="base.html#topic+order">order()</a></code> is the workhorse of <code>rs_pairs()</code>, so performance can be
sensitive to the types of <code>period</code> and <code>product</code>, and can be slow for large
character vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rs_matrix">rs_matrix()</a></code> for using sales pairs to make a repeat-sales index.
</p>
<p><code>rtCreateTrans()</code> in the <span class="pkg">hpiR</span> package for a feature-rich but
slower and less flexible function to make sales pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make sales pairs
x &lt;- data.frame(
  id = c(1, 1, 1, 3, 2, 2, 3, 3),
  date = c(1, 2, 3, 2, 1, 3, 4, 1),
  price = c(1, 3, 2, 3, 1, 1, 1, 2)
)

pairs &lt;- rs_pairs(x$date, x$id)

x[c("date_prev", "price_prev")] &lt;- x[c("date", "price")][pairs, ]

x

</code></pre>

<hr>
<h2 id='rs_var'>Robust variance matrix for repeat-sales indexes</h2><span id='topic+rs_var'></span>

<h3>Description</h3>

<p>Convenience function to compute a cluster-robust variance matrix for a
linear regression, with or without instruments, where clustering occurs
along one dimension. Useful for calculating a variance matrix when a
regression is calculated manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rs_var(u, Z, X = Z, ids = seq_len(nrow(X)), df = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rs_var_+3A_u">u</code></td>
<td>
<p>An <code class="reqn">n \times 1</code> vector of residuals from a linear
regression.</p>
</td></tr>
<tr><td><code id="rs_var_+3A_z">Z</code></td>
<td>
<p>An <code class="reqn">n \times k</code> matrix of instruments.</p>
</td></tr>
<tr><td><code id="rs_var_+3A_x">X</code></td>
<td>
<p>An <code class="reqn">n \times k</code> matrix of covariates.</p>
</td></tr>
<tr><td><code id="rs_var_+3A_ids">ids</code></td>
<td>
<p>A factor of length <code class="reqn">n</code>, or something that can be coerced into
one, that groups observations in <code>u</code>. By default each observation
belongs to its own group.</p>
</td></tr>
<tr><td><code id="rs_var_+3A_df">df</code></td>
<td>
<p>An optional degrees of freedom correction. Default is Stata's
small sample degrees of freedom correction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the standard robust variance matrix for a linear
regression, as in Manski (1988, section 8.1.2) or White (2001, Theorem 6.3);
that is, <code class="reqn">(Z'X)^{-1} V (X'Z)^{-1}</code>. It is useful
when a regression is calculated by hand. This generalizes the variance
matrix proposed by Shiller (1991, section II) when a property sells more
than twice.
</p>
<p>This function gives the same result as <code>vcovHC(x, type = 'sss', cluster = 'group')</code> from the <span class="pkg">plm</span> package.
</p>


<h3>Value</h3>

<p>A <code class="reqn">k \times k</code> covariance matrix.
</p>


<h3>References</h3>

<p>Manski, C. (1988). <em>Analog Estimation Methods in Econometrics</em>.
Chapman and Hall.
</p>
<p>Shiller, R. J. (1991). Arithmetic repeat sales price estimators.
<em>Journal of Housing Economics</em>, 1(1):110-126.
</p>
<p>White, H. (2001). <em>Asymptotic Theory for Econometricians</em> (revised
edition). Emerald Publishing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Makes some groups in mtcars
mtcars$clust &lt;- letters[1:4]

# Matrices for regression
x &lt;- model.matrix(~ cyl + disp, mtcars)
y &lt;- matrix(mtcars$mpg)

# Regression coefficients
b &lt;- solve(crossprod(x), crossprod(x, y))

# Residuals
r &lt;- y - x %*% b

# Robust variance matrix
vcov &lt;- rs_var(r, x, ids = mtcars$clust)

## Not run: 
# Same as plm
library(plm)
mdl &lt;- plm(mpg ~ cyl + disp, mtcars, model = "pooling", index = "clust")
vcov2 &lt;- vcovHC(mdl, type = "sss", cluster = "group")
vcov - vcov2

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
