<!DOCTYPE html><html><head><title>Help for package viraldomain</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {viraldomain}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#knn_domain_score'><p>Calculate the K-Nearest Neighbor model domain applicability score</p></a></li>
<li><a href='#mars_domain_score'><p>Calculate the MARS model domain applicability score</p></a></li>
<li><a href='#nn_domain_score'><p>Calculate the Neural Network model domain applicability score</p></a></li>
<li><a href='#normalized_domain_plot'><p>Create a Normalized Domain Plot</p></a></li>
<li><a href='#sero'><p>Seropositive Data for Applicability Domain Testing</p></a></li>
<li><a href='#simple_domain_plot'><p>Create a Simple Domain Plot</p></a></li>
<li><a href='#train'><p>Training Data for Applicability Domain Analysis</p></a></li>
<li><a href='#viral'><p>Predictive Modeling Data for Viral Load and CD4 Lymphocyte Counts</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Applicability Domain Methods of Viral Load and CD4 Lymphocytes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for assessing the applicability domain of models that predict viral load and CD4 (Cluster of Differentiation 4) lymphocyte counts. These methods help determine the extent of extrapolation when making predictions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>applicable, dplyr, earth, ggplot2, kknn, nnet, parsnip,
recipes, stats, vdiffr, workflows</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-21 07:46:40 UTC; jp</td>
</tr>
<tr>
<td>Author:</td>
<td>Juan Pablo Acuña González
    <a href="https://orcid.org/0009-0003-6029-6560"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan Pablo Acuña González &lt;22253567@uagro.mx&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 13:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='knn_domain_score'>Calculate the K-Nearest Neighbor model domain applicability score</h2><span id='topic+knn_domain_score'></span>

<h3>Description</h3>

<p>This function fits a K-Nearest Neighbor (KNN) model to the provided data
and computes a domain applicability score based on PCA distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_domain_score(
  featured,
  train_data,
  knn_hyperparameters,
  test_data,
  threshold_value
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_domain_score_+3A_featured">featured</code></td>
<td>
<p>The name of the response variable to predict.</p>
</td></tr>
<tr><td><code id="knn_domain_score_+3A_train_data">train_data</code></td>
<td>
<p>The training dataset containing predictor variables and the response variable.</p>
</td></tr>
<tr><td><code id="knn_domain_score_+3A_knn_hyperparameters">knn_hyperparameters</code></td>
<td>
<p>A list of hyperparameters for the KNN model, including:
</p>

<ul>
<li> <p><code>neighbors</code>: The number of neighbors to consider.
</p>
</li>
<li> <p><code>weight_func</code>: The weight function to use.
</p>
</li>
<li> <p><code>dist_power</code>: The distance power parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="knn_domain_score_+3A_test_data">test_data</code></td>
<td>
<p>The test dataset for making predictions.</p>
</td></tr>
<tr><td><code id="knn_domain_score_+3A_threshold_value">threshold_value</code></td>
<td>
<p>The threshold value used for computing domain scores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the computed domain scores for each observation in the test dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
library(dplyr)
featured &lt;- "cd_2022"
# Adding jitter to original features
train_data = viral |&gt;
transmute(cd_2022 = jitter(cd_2022), vl_2022 = jitter(vl_2022))
test_data = sero |&gt;
transmute(cd_2022 = jitter(cd_2022), vl_2022 = jitter(vl_2022))
knn_hyperparameters &lt;- list(neighbors = 5, weight_func = "optimal", dist_power = 0.3304783)
threshold_value &lt;- 0.99
# Call the function
knn_domain_score(featured, train_data, knn_hyperparameters, test_data, threshold_value)
</code></pre>

<hr>
<h2 id='mars_domain_score'>Calculate the MARS model domain applicability score</h2><span id='topic+mars_domain_score'></span>

<h3>Description</h3>

<p>This function fits a MARS (Multivariate Adaptive Regression Splines) model to
the provided data and computes a domain applicability score based on PCA distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mars_domain_score(
  featured_col,
  train_data,
  mars_hyperparameters,
  test_data,
  threshold_value
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mars_domain_score_+3A_featured_col">featured_col</code></td>
<td>
<p>The name of the featured column.</p>
</td></tr>
<tr><td><code id="mars_domain_score_+3A_train_data">train_data</code></td>
<td>
<p>A data frame containing the training data.</p>
</td></tr>
<tr><td><code id="mars_domain_score_+3A_mars_hyperparameters">mars_hyperparameters</code></td>
<td>
<p>A list of hyperparameters for the MARS model, including:
</p>

<ul>
<li> <p><code>num_terms</code>: The number of terms to include in the MARS model.
</p>
</li>
<li> <p><code>prod_degree</code>: The degree of interaction terms to include.
</p>
</li>
<li> <p><code>prune_method</code>: The method used for pruning the MARS model.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mars_domain_score_+3A_test_data">test_data</code></td>
<td>
<p>A data frame containing the test data.</p>
</td></tr>
<tr><td><code id="mars_domain_score_+3A_threshold_value">threshold_value</code></td>
<td>
<p>The threshold value for the domain score.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the domain applicability scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(viraldomain)
library(dplyr)

# Set the seed for reproducibility
set.seed(1234)

# Create a tibble with the training data
data(viral)

# Number of imputations needed
num_imputations &lt;- sum(viral$vl_2022 &lt;= 40)  # Count values below 40 cpm

# Impute unique values
imputed_values &lt;- unique(rexp(num_imputations, rate = 1/13))

# Create a new tibble with mutated/imputed viral load
imputed_viral &lt;- viral |&gt;
  mutate(imputed_vl_2022 = ifelse(vl_2022 &lt;= 40, imputed_values, vl_2022),
         log10_imputed_vl_2022 = log10(ifelse(vl_2022 &lt;= 40, imputed_values, vl_2022)),
         jittered_log10_imputed_vl_2022 = jitter(log10_imputed_vl_2022))

# Create a new tibble with mutated/imputed cd4 counts
imputed_viral &lt;- imputed_viral |&gt;
  mutate(
    jittered_cd_2022 = ifelse(
    duplicated(cd_2022),
    cd_2022 + sample(1:100, length(cd_2022), replace = TRUE),
    cd_2022
    )
  )

# New data frame with mutated/imputed columns
imp_viral &lt;- imputed_viral |&gt;
select(jittered_cd_2022, jittered_log10_imputed_vl_2022) |&gt;
scale() |&gt;
as.data.frame()

# Set the seed for reproducibility
set.seed(1234)

# Create a tibble with the testing data
data(sero)

# Number of imputations needed
num_imputations &lt;- sum(sero$vl_2022 &lt;= 40)  # Count values below 40 cpm

# Impute unique values
imputed_values &lt;- unique(rexp(num_imputations, rate = 1/13))

# Create a new tibble with mutated/imputed viral load
imputed_sero &lt;- sero |&gt;
  mutate(imputed_vl_2022 = ifelse(vl_2022 &lt;= 40, imputed_values, vl_2022),
         log10_imputed_vl_2022 = log10(ifelse(vl_2022 &lt;= 40, imputed_values, vl_2022)),
         jittered_log10_imputed_vl_2022 = jitter(log10_imputed_vl_2022))

# Create a new tibble with mutated/imputed cd
imputed_sero &lt;- imputed_sero |&gt;
  mutate(
    jittered_cd_2022 = ifelse(
    duplicated(cd_2022),
    cd_2022 + sample(1:100, length(cd_2022), replace = TRUE),
    cd_2022
    )
  )

# New data frame with mutated/imputed columns
imp_sero &lt;- imputed_sero |&gt;
select(jittered_cd_2022, jittered_log10_imputed_vl_2022) |&gt;
scale() |&gt;
as.data.frame()

# Specify your function parameters
featured_col &lt;- "jittered_cd_2022"
train_data &lt;- imp_viral
mars_hyperparameters &lt;- list(num_terms = 3, prod_degree = 1, prune_method = "none")
test_data &lt;- imp_sero
threshold_value &lt;- 0.99

# Call the function
mars_domain_score(featured_col, train_data, mars_hyperparameters, test_data, threshold_value)
</code></pre>

<hr>
<h2 id='nn_domain_score'>Calculate the Neural Network model domain applicability score</h2><span id='topic+nn_domain_score'></span>

<h3>Description</h3>

<p>This function fits a Neural Network model to the provided data and computes a
domain applicability score based on PCA distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nn_domain_score(
  featured_col,
  train_data,
  nn_hyperparameters,
  test_data,
  threshold_value
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nn_domain_score_+3A_featured_col">featured_col</code></td>
<td>
<p>The name of the featured column in the training data.</p>
</td></tr>
<tr><td><code id="nn_domain_score_+3A_train_data">train_data</code></td>
<td>
<p>The training data used to fit the Neural Network model.</p>
</td></tr>
<tr><td><code id="nn_domain_score_+3A_nn_hyperparameters">nn_hyperparameters</code></td>
<td>
<p>A list of Neural Network hyperparameters, including hidden_units, penalty, and epochs.</p>
</td></tr>
<tr><td><code id="nn_domain_score_+3A_test_data">test_data</code></td>
<td>
<p>The testing domain data used to calculate the domain applicability score.</p>
</td></tr>
<tr><td><code id="nn_domain_score_+3A_threshold_value">threshold_value</code></td>
<td>
<p>The threshold value for domain applicability scoring.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the domain applicability scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(viraldomain)
library(dplyr)

# Set the seed for reproducibility
set.seed(1234)

# Create a tibble with the training data
data(viral)

# Number of imputations needed
num_imputations &lt;- sum(viral$vl_2022 &lt;= 40)  # Count values below 40 cpm

# Impute unique values
imputed_values &lt;- unique(rexp(num_imputations, rate = 1/13))

# Create a new tibble with mutated/imputed viral load
imputed_viral &lt;- viral |&gt;
  mutate(imputed_vl_2022 = ifelse(vl_2022 &lt;= 40, imputed_values, vl_2022),
         log10_imputed_vl_2022 = log10(ifelse(vl_2022 &lt;= 40, imputed_values, vl_2022)),
         jittered_log10_imputed_vl_2022 = jitter(log10_imputed_vl_2022))

# Create a new tibble with mutated/imputed cd4 counts
imputed_viral &lt;- imputed_viral |&gt;
  mutate(
    jittered_cd_2022 = ifelse(
    duplicated(cd_2022),
    cd_2022 + sample(1:100, length(cd_2022), replace = TRUE),
    cd_2022
    )
  )

# New data frame with mutated/imputed columns
imp_viral &lt;- imputed_viral |&gt;
select(jittered_cd_2022, jittered_log10_imputed_vl_2022) |&gt;
scale() |&gt;
as.data.frame()

# Set the seed for reproducibility
set.seed(1234)

# Create a tibble with the testing data
data(sero)

# Number of imputations needed
num_imputations &lt;- sum(sero$vl_2022 &lt;= 40)  # Count values below 40 cpm

# Impute unique values
imputed_values &lt;- unique(rexp(num_imputations, rate = 1/13))

# Create a new tibble with mutated/imputed viral load
imputed_sero &lt;- sero |&gt;
  mutate(imputed_vl_2022 = ifelse(vl_2022 &lt;= 40, imputed_values, vl_2022),
         log10_imputed_vl_2022 = log10(ifelse(vl_2022 &lt;= 40, imputed_values, vl_2022)),
         jittered_log10_imputed_vl_2022 = jitter(log10_imputed_vl_2022))

# Create a new tibble with mutated/imputed cd
imputed_sero &lt;- imputed_sero |&gt;
  mutate(
    jittered_cd_2022 = ifelse(
    duplicated(cd_2022),
    cd_2022 + sample(1:100, length(cd_2022), replace = TRUE),
    cd_2022
    )
  )

# New data frame with mutated/imputed columns
imp_sero &lt;- imputed_sero |&gt;
select(jittered_cd_2022, jittered_log10_imputed_vl_2022) |&gt;
scale() |&gt;
as.data.frame()

# Specify your function parameters
featured_col &lt;- "jittered_cd_2022"
train_data &lt;- imp_viral
nn_hyperparameters &lt;- list(hidden_units = 1, penalty = 0.3746312,  epochs =  480)
test_data &lt;- imp_sero
threshold_value &lt;- 0.99

# Call the function
nn_domain_score(featured_col, train_data, nn_hyperparameters, test_data, threshold_value)
</code></pre>

<hr>
<h2 id='normalized_domain_plot'>Create a Normalized Domain Plot</h2><span id='topic+normalized_domain_plot'></span>

<h3>Description</h3>

<p>This function generates a domain plot for a normalized model based on PCA
distances of the provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalized_domain_plot(
  features,
  train_data,
  test_data,
  treshold_value,
  impute_hyperparameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalized_domain_plot_+3A_features">features</code></td>
<td>
<p>A list containing the following elements:
</p>

<ul>
<li> <p><code>featured_col</code>: The name of the featured column.
</p>
</li>
<li> <p><code>features_vl</code>: A character vector of feature names related to viral load.
</p>
</li>
<li> <p><code>features_cd</code>: A character vector of feature names related to cluster of differentiation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="normalized_domain_plot_+3A_train_data">train_data</code></td>
<td>
<p>A data frame containing the training data.</p>
</td></tr>
<tr><td><code id="normalized_domain_plot_+3A_test_data">test_data</code></td>
<td>
<p>A data frame containing the test data.</p>
</td></tr>
<tr><td><code id="normalized_domain_plot_+3A_treshold_value">treshold_value</code></td>
<td>
<p>The threshold value for the domain plot.</p>
</td></tr>
<tr><td><code id="normalized_domain_plot_+3A_impute_hyperparameters">impute_hyperparameters</code></td>
<td>
<p>A list of hyperparameters for imputation, including:
</p>

<ul>
<li> <p><code>indetect</code>: The undetectable viral load level.
</p>
</li>
<li> <p><code>tasa_exp</code>: The exponential distribution rate of undetectable values.
</p>
</li>
<li> <p><code>semi</code>: The seed for random number generation (for reproducibility).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A domain plot visualizing the distances of imputed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(viral)
data(sero)
 # Adding "jitter_" prefix to original variable
features &lt;- list(
  featured_col = "jittered_cd_2022",
  features_vl = "vl_2022",
  features_cd = "cd_2022"
  )
train_data = viral |&gt;
dplyr::select("cd_2022", "vl_2022")
test_data = sero
treshold_value = 0.99
impute_hyperparameters = list(indetect = 40, tasa_exp = 1/13, semi = 123)
normalized_domain_plot(features, train_data, test_data, treshold_value, impute_hyperparameters)
</code></pre>

<hr>
<h2 id='sero'>Seropositive Data for Applicability Domain Testing</h2><span id='topic+sero'></span>

<h3>Description</h3>

<p>This dataset is designed for testing the applicability domain of methods
related to HIV research. It provides a tibble with 53 rows and 2 columns
containing numeric measurements of CD4 lymphocyte counts (cd_2022) and viral
load (vl_2022) for seropositive individuals in 2022. These measurements are
vital indicators of HIV disease status. This dataset is ideal for evaluating
the performance and suitability of various HIV-predictive models and as an
aid in developing diagnostic tools within a seropositive context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sero)
</code></pre>


<h3>Format</h3>

<p>A tibble (data frame) with 53 rows and 2 columns.
</p>


<h3>Note</h3>

<p>To explore more rows of this dataset, you can use the <code>print(n = ...)</code> function.
</p>


<h3>Author(s)</h3>

<p>Juan Pablo Acuña González <a href="mailto:22253567@uagro.mx">22253567@uagro.mx</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sero)
sero
</code></pre>

<hr>
<h2 id='simple_domain_plot'>Create a Simple Domain Plot</h2><span id='topic+simple_domain_plot'></span>

<h3>Description</h3>

<p>This function generates a domain plot for a simple model based on PCA
distances of the provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_domain_plot(
  features,
  train_data,
  test_data,
  treshold_value,
  impute_hyperparameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_domain_plot_+3A_features">features</code></td>
<td>
<p>A list of features according to their modeling roles. It should contain the following elements:
</p>

<ul>
<li><p> 'featured_col': Name of the featured column in the training data. When specifying the featured column, use &quot;jitter_*&quot; as a prefix to the featured variable of interest.
</p>
</li>
<li><p> 'features_vl': Names of the columns containing viral load data (numeric values).
</p>
</li>
<li><p> 'features_cd': Names of the columns containing CD4 data (numeric values).
</p>
</li></ul>
</td></tr>
<tr><td><code id="simple_domain_plot_+3A_train_data">train_data</code></td>
<td>
<p>The training data used to fit the MARS model.</p>
</td></tr>
<tr><td><code id="simple_domain_plot_+3A_test_data">test_data</code></td>
<td>
<p>The testing domain data used to calculate PCA distances.</p>
</td></tr>
<tr><td><code id="simple_domain_plot_+3A_treshold_value">treshold_value</code></td>
<td>
<p>The threshold for domain applicability scoring.</p>
</td></tr>
<tr><td><code id="simple_domain_plot_+3A_impute_hyperparameters">impute_hyperparameters</code></td>
<td>
<p>A list of parameters for imputation including 'indetect' (undetectable viral load level), 'tasa_exp' (exponential distribution rate of undetectable values), and 'semi' (set a seed for reproducibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A domain plot showing PCA distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(viral)
data(sero)
 # Adding "jitter_" prefix to original variable
features &lt;- list(
  featured_col = "jittered_cd_2022",
  features_vl = "vl_2022",
  features_cd = "cd_2022"
  )
train_data = viral |&gt;
dplyr::select("cd_2022", "vl_2022")
test_data = sero
treshold_value = 0.99
impute_hyperparameters = list(indetect = 40, tasa_exp = 1/13, semi = 123)
simple_domain_plot(features, train_data, test_data, treshold_value, impute_hyperparameters)
</code></pre>

<hr>
<h2 id='train'>Training Data for Applicability Domain Analysis</h2><span id='topic+train'></span>

<h3>Description</h3>

<p>This dataset contains training data for viral load models applicability
domain analysis. It includes CD4 and viral load measurements for different years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(train)
</code></pre>


<h3>Format</h3>

<p>A tibble (data frame) with 26 rows and 6 columns.
</p>


<h3>Note</h3>

<p>To explore more rows of this dataset, you can use the <code>print(n = ...)</code> function.
</p>


<h3>Author(s)</h3>

<p>Juan Pablo Acuña González <a href="mailto:22253567@uagro.mx">22253567@uagro.mx</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(train)
train
</code></pre>

<hr>
<h2 id='viral'>Predictive Modeling Data for Viral Load and CD4 Lymphocyte Counts</h2><span id='topic+viral'></span>

<h3>Description</h3>

<p>This dataset serves as input for predictive modeling tasks related to HIV
research. It contains numeric measurements of CD4 lymphocyte counts (cd) and
viral load (vl) at three different time points: 2019, 2021, and 2022. These
measurements are crucial indicators of HIV disease progression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(viral)
</code></pre>


<h3>Format</h3>

<p>A tibble (data frame) with 35 rows and 6 columns.
</p>


<h3>Note</h3>

<p>To explore more rows of this dataset, you can use the <code>print(n = ...)</code> function.
</p>


<h3>Author(s)</h3>

<p>Juan Pablo Acuña González <a href="mailto:22253567@uagro.mx">22253567@uagro.mx</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(viral)
viral
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
