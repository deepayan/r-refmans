<!DOCTYPE html><html><head><title>Help for package PACLasso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PACLasso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#generate.data'><p>Function to Randomly Generate Data (with Constraints)</p></a></li>
<li><a href='#lars.c'><p>Constrained LARS Coefficient Function (Equality Constraints)</p></a></li>
<li><a href='#lars.ineq'><p>Constrained LARS Coefficient Function with Inequality Constraints</p></a></li>
<li><a href='#lasso.c'><p>Complete Run of Constrained LASSO Path Function (Equality Constraints)</p></a></li>
<li><a href='#lasso.ineq'><p>Complete Run of Constrained LASSO Path Function with Inequality Constraints</p></a></li>
<li><a href='#lin.int'><p>Initialize Linear Programming Fit (Equality Constraints)</p></a></li>
<li><a href='#lin.int.ineq'><p>Initialize Linear Programming Fit with Inequality Constraints</p></a></li>
<li><a href='#quad.int'><p>Initialize Quadratic Programming Fit (Equality Constraints)</p></a></li>
<li><a href='#quad.int.ineq'><p>Initialize Quadratic Programming Fit with Inequality Constraints</p></a></li>
<li><a href='#transformed'><p>Transform Data to Fit PaC Implementation (Equality Constraints)</p></a></li>
<li><a href='#transformed.ineq'><p>Transform Data to Fit PaC Implementation for Inequality Constraints</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Penalized and Constrained Lasso Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-4-11</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Courtney Paulson &lt;cpaulson@rhsmith.umd.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of both the equality and inequality constrained lasso
    functions for the algorithm described in "Penalized and Constrained Optimization"
    by James, Paulson, and Rusmevichientong (Journal of the American Statistical Association, 2019;
    see <a href="http://www-bcf.usc.edu/~gareth/research/PAC.pdf">http://www-bcf.usc.edu/~gareth/research/PAC.pdf</a> for a full-text version of the paper). 
    The algorithm here is designed to allow users to define linear constraints (either equality
    or inequality constraints) and use a penalized regression approach to solve the constrained
    problem. The functions here are used specifically for constraints with the lasso formulation,
    but the method described in the PaC paper can be used for a variety of scenarios. In addition
    to the simple examples included here with the corresponding functions, complete code to 
    entirely reproduce the results of the paper is available online through the Journal of the
    American Statistical Association. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), methods (&ge; 3.4.4), penalized (&ge; 0.9)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS (&ge; 7.3), lars (&ge; 1.2), quadprog (&ge; 1.5), limSolve (&ge;
1.5.5.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www-bcf.usc.edu/~gareth/research/PAC.pdf">http://www-bcf.usc.edu/~gareth/research/PAC.pdf</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-29 19:41:30 UTC; cpaulson</td>
</tr>
<tr>
<td>Author:</td>
<td>Courtney Paulson [aut, cre],
  Gareth James [ctb],
  Paat Rusmevichientong [ctb]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-29 21:30:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='generate.data'>Function to Randomly Generate Data (with Constraints)</h2><span id='topic+generate.data'></span>

<h3>Description</h3>

<p>This function is primarily used for reproducibility. It will generate a data set of
a given size with a given number of constraints for testing function code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.data(n = 1000, p = 10, m = 5, cov.mat = NULL, s = 5,
  sigma = 1, glasso = F, err = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.data_+3A_n">n</code></td>
<td>
<p>number of rows in randomly-generated data set (default is 1000)</p>
</td></tr>
<tr><td><code id="generate.data_+3A_p">p</code></td>
<td>
<p>number of variables in randomly-generated data set (default is 10)</p>
</td></tr>
<tr><td><code id="generate.data_+3A_m">m</code></td>
<td>
<p>number of constraints in randomly-generated constraint matrix (default is 5)</p>
</td></tr>
<tr><td><code id="generate.data_+3A_cov.mat">cov.mat</code></td>
<td>
<p>a covariance matrix applied in the generation of data to impose a correlation structure. Default is NULL (no correlation)</p>
</td></tr>
<tr><td><code id="generate.data_+3A_s">s</code></td>
<td>
<p>number of true non-zero elements in coefficient vector beta1 (default is 5)</p>
</td></tr>
<tr><td><code id="generate.data_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of noise in response (default is 1, indicating standard normal)</p>
</td></tr>
<tr><td><code id="generate.data_+3A_glasso">glasso</code></td>
<td>
<p>should the generalized Lasso be used (TRUE) or standard Lasso (FALSE). Default is FALSE</p>
</td></tr>
<tr><td><code id="generate.data_+3A_err">err</code></td>
<td>
<p>error to be introduced in random generation of coefficient values. Default is no error (err = 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> generated <code>x</code> data
</p>
<p><code>y</code> generated response <code>y</code> vector
</p>
<p><code>C.full</code> generated full constraint matrix (with constraints of the form <code>C.full</code>*<code>beta</code>=<code>b</code>)
</p>
<p><code>b</code> generated constraint vector <code>b</code>
</p>
<p><code>b.run</code> if error was included, the error-adjusted value of <code>b</code>
</p>
<p><code>beta</code> the complete beta vector, including generated <code>beta1</code> and <code>beta2</code>
</p>


<h3>References</h3>

<p>Gareth M. James, Courtney Paulson, and Paat Rusmevichientong (JASA, 2019) &quot;Penalized and Constrained Optimization.&quot;
(Full text available at http://www-bcf.usc.edu/~gareth/research/PAC.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
dim(random_data$x)
head(random_data$y)
dim(random_data$C.full)
random_data$beta
</code></pre>

<hr>
<h2 id='lars.c'>Constrained LARS Coefficient Function (Equality Constraints)</h2><span id='topic+lars.c'></span>

<h3>Description</h3>

<p>This function computes the PaC constrained LASSO
coefficient paths following the methodology laid out in the PaC
paper. This function could be called directly as a standalone
function, but the authors recommend using <code>lasso.c</code> for any
implementation. This is because <code>lasso.c</code> has additional checks for
errors across the coefficient paths and allows for users to go
forwards and backwards through the paths if the paths are unable
to compute in a particular direction for a particular run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lars.c(x, y, C.full, b, l.min = -2, l.max = 6, step = 0.2,
  beta0 = NULL, verbose = F, max.it = 12, intercept = T,
  normalize = T, forwards = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lars.c_+3A_x">x</code></td>
<td>
<p>independent variable matrix of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="lars.c_+3A_y">y</code></td>
<td>
<p>response vector of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="lars.c_+3A_c.full">C.full</code></td>
<td>
<p>complete constraint matrix C (with constraints of the form <code>C.full</code>*<code>beta</code>=<code>b</code>)</p>
</td></tr>
<tr><td><code id="lars.c_+3A_b">b</code></td>
<td>
<p>constraint vector b</p>
</td></tr>
<tr><td><code id="lars.c_+3A_l.min">l.min</code></td>
<td>
<p>lowest value of lambda to consider (used as 10^<code>l.min</code>). Default is -2</p>
</td></tr>
<tr><td><code id="lars.c_+3A_l.max">l.max</code></td>
<td>
<p>largest value of lambda to consider (used as 10^<code>l.max</code>). Default is 6</p>
</td></tr>
<tr><td><code id="lars.c_+3A_step">step</code></td>
<td>
<p>step size increase in lambda attempted at each iteration (by a factor of 10^<code>step</code>). Default is 0.2</p>
</td></tr>
<tr><td><code id="lars.c_+3A_beta0">beta0</code></td>
<td>
<p>initial guess for beta coefficient vector. Default is NULL (indicating
initial vector should be calculated by algorithm)</p>
</td></tr>
<tr><td><code id="lars.c_+3A_verbose">verbose</code></td>
<td>
<p>should function print output at each iteration (TRUE) or not (FALSE). Default is FALSE</p>
</td></tr>
<tr><td><code id="lars.c_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of times step size is halved before the algorithm terminates and gives a warning. Default is 12</p>
</td></tr>
<tr><td><code id="lars.c_+3A_intercept">intercept</code></td>
<td>
<p>should intercept be included in modeling (TRUE) or not (FALSE). Default is TRUE.</p>
</td></tr>
<tr><td><code id="lars.c_+3A_normalize">normalize</code></td>
<td>
<p>should <code>x</code> data be normalized. Default is TRUE</p>
</td></tr>
<tr><td><code id="lars.c_+3A_forwards">forwards</code></td>
<td>
<p>if <code>forwards</code> = F, then the algorithm starts at 10^<code>l.max</code> and
moves backwards (without the forward step). If <code>forwards</code> = T,
algorithm starts at 10^<code>l.min</code> and works forward. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coefs</code> A <code>p</code> by length(<code>lambda</code>) matrix with each column corresponding to the beta estimate for that lambda
</p>
<p><code>lambda</code> the grid of lambdas used to calculate the coefficients on the coefficient path
</p>
<p><code>intercept</code> vector with each element corresponding to intercept for corresponding lambda
</p>
<p><code>error</code> did the algorithm terminate due to too many iterations (TRUE or FALSE)
</p>
<p><code>b2index</code> the index of the <code>beta2</code> values identified by the algorithm at each lambda
</p>


<h3>References</h3>

<p>Gareth M. James, Courtney Paulson, and Paat Rusmevichientong (JASA, 2019) &quot;Penalized and Constrained Optimization.&quot;
(Full text available at http://www-bcf.usc.edu/~gareth/research/PAC.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
lars_fit = lars.c(random_data$x, random_data$y, random_data$C.full, random_data$b)
lars_fit$lambda
lars_fit$error
### The coefficients for the first lambda value
lars_fit$coefs[1,]
### Example of code where path is unable
### to be finished (only one iteration)
lars_err = lars.c(random_data$x, random_data$y, random_data$C.full,
random_data$b, max.it = 1)
lars_err$error
lars_err$lambda
</code></pre>

<hr>
<h2 id='lars.ineq'>Constrained LARS Coefficient Function with Inequality Constraints</h2><span id='topic+lars.ineq'></span>

<h3>Description</h3>

<p>This function computes the PaC constrained LASSO
coefficient paths following the methodology laid out in the PaC
paper but with inequality constraints. This function could be called directly as a standalone
function, but the authors recommend using <code>lasso.ineq</code> for any
implementation. This is because <code>lasso.ineq</code> has additional checks for
errors across the coefficient paths and allows for users to go
forwards and backwards through the paths if the paths are unable
to compute in a particular direction for a particular run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lars.ineq(x, y, C.full, b, l.min = -2, l.max = 6, step = 0.2,
  beta0 = NULL, verbose = F, max.it = 12, intercept = T,
  normalize = T, forwards = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lars.ineq_+3A_x">x</code></td>
<td>
<p>independent variable matrix of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_y">y</code></td>
<td>
<p>response vector of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_c.full">C.full</code></td>
<td>
<p>complete inequality constraint matrix C (with inequality constraints of the form <code>C.full</code>*<code>beta</code> &gt;= <code>b</code>))</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_b">b</code></td>
<td>
<p>constraint vector b</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_l.min">l.min</code></td>
<td>
<p>lowest value of lambda to consider (used as 10^<code>l.min</code>). Default is -2</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_l.max">l.max</code></td>
<td>
<p>largest value of lambda to consider (used as 10^<code>l.max</code>). Default is 6</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_step">step</code></td>
<td>
<p>step size increase in lambda attempted at each iteration (by a factor of 10^<code>step</code>). Default is 0.2</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_beta0">beta0</code></td>
<td>
<p>initial guess for <code>beta</code> coefficient vector. Default is NULL (indicating
initial vector should be calculated by algorithm)</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_verbose">verbose</code></td>
<td>
<p>should function print output at each iteration (TRUE) or not (FALSE). Default is FALSE</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of times step size is halved before the algorithm terminates and gives a warning. Default is 12</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_intercept">intercept</code></td>
<td>
<p>should intercept be included in modeling (TRUE) or not (FALSE). Default is TRUE.</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_normalize">normalize</code></td>
<td>
<p>should <code>x</code> data be normalized. Default is TRUE</p>
</td></tr>
<tr><td><code id="lars.ineq_+3A_forwards">forwards</code></td>
<td>
<p>if <code>forwards</code> = F, then the algorithm starts at 10^<code>l.max</code> and
moves backwards (without the forward step). If <code>forwards</code> = T,
algorithm starts at 10^<code>l.min</code> and works forward. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coefs</code> A <code>p</code> by length(<code>lambda</code>) matrix with each column corresponding to the beta estimate for that lambda
</p>
<p><code>lambda</code> the grid of lambdas used to calculate the coefficients on the coefficient path
</p>
<p><code>intercept</code> vector with each element corresponding to intercept for corresponding lambda
</p>
<p><code>error</code> did the algorithm terminate due to too many iterations (TRUE or FALSE)
</p>
<p><code>b2index</code> the index of the <code>beta2</code> values identified by the algorithm at each lambda
</p>


<h3>References</h3>

<p>Gareth M. James, Courtney Paulson, and Paat Rusmevichientong (JASA, 2019) &quot;Penalized and Constrained Optimization.&quot;
(Full text available at http://www-bcf.usc.edu/~gareth/research/PAC.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
lars_fit = lars.ineq(random_data$x, random_data$y, random_data$C.full, random_data$b)
lars_fit$lambda
lars_fit$error
### The coefficients for the first lambda value
lars_fit$coefs[1,]
### Example of code where path is unable to be finished
### (only one iteration)
lars_err = lars.ineq(random_data$x, random_data$y, random_data$C.full,
random_data$b, max.it = 1)
lars_err$error
lars_err$lambda
</code></pre>

<hr>
<h2 id='lasso.c'>Complete Run of Constrained LASSO Path Function (Equality Constraints)</h2><span id='topic+lasso.c'></span>

<h3>Description</h3>

<p>This is a wrapper function for the <code>lars.c</code> PaC
constrained Lasso function. <code>lasso.c</code> controls the overall path,
providing checks for the path and allowing the user to control
how the path is computed (and what to do in the case of a stopped path).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso.c(x, y, C.full, b, l.min = -2, l.max = 6, step = 0.2,
  beta0 = NULL, verbose = F, max.it = 12, intercept = T,
  normalize = T, backwards = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lasso.c_+3A_x">x</code></td>
<td>
<p>independent variable matrix of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_y">y</code></td>
<td>
<p>response vector of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_c.full">C.full</code></td>
<td>
<p>complete constraint matrix C (with constraints of the form <code>C.full</code>*<code>beta</code>=<code>b</code>)</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_b">b</code></td>
<td>
<p>constraint vector b</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_l.min">l.min</code></td>
<td>
<p>lowest value of lambda to consider (used as 10^<code>l.min</code>). Default is -2</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_l.max">l.max</code></td>
<td>
<p>largest value of lambda to consider (used as 10^<code>l.max</code>). Default is 6</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_step">step</code></td>
<td>
<p>step size increase in lambda attempted at each iteration (by a factor of 10^<code>step</code>). Default is 0.2</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_beta0">beta0</code></td>
<td>
<p>initial guess for beta coefficient vector. Default is NULL (indicating
initial vector should be calculated by algorithm)</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_verbose">verbose</code></td>
<td>
<p>should function print output at each iteration (TRUE) or not (FALSE). Default is FALSE</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of times step size is halved before the algorithm terminates and gives a warning. Default is 12</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_intercept">intercept</code></td>
<td>
<p>should intercept be included in modeling (TRUE) or not (FALSE). Default is TRUE.</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_normalize">normalize</code></td>
<td>
<p>should X data be normalized. Default is TRUE</p>
</td></tr>
<tr><td><code id="lasso.c_+3A_backwards">backwards</code></td>
<td>
<p>which direction should algorithm go, backwards from lambda = 10^<code>l.max</code> (TRUE)
or forwards from 10^<code>l.max</code> and then backwards if algorithm gets stuck (FALSE).
Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coefs</code> A <code>p</code> by length(<code>lambda</code>) matrix with each column corresponding to the beta estimate for that lambda
</p>
<p><code>lambda</code> vector of values of lambda that were fit
</p>
<p><code>intercept</code> vector with each element corresponding to intercept for corresponding lambda
</p>
<p><code>error</code> Indicator of whether the algorithm terminated early because max.it was reached
</p>


<h3>References</h3>

<p>Gareth M. James, Courtney Paulson, and Paat Rusmevichientong (JASA, 2019) &quot;Penalized and Constrained Optimization.&quot;
(Full text available at http://www-bcf.usc.edu/~gareth/research/PAC.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
lasso_fit = lasso.c(random_data$x, random_data$y, random_data$C.full, random_data$b)
lasso_fit$lambda
lasso_fit$error
### The coefficients for the first lambda value
lasso_fit$coefs[1,]
### Example of code where path is unable to be finished
### (only one iteration), so both directions will be tried
lasso_err = lasso.c(random_data$x, random_data$y, random_data$C.full,
random_data$b, max.it = 1)
lasso_err$error
lasso_err$lambda
</code></pre>

<hr>
<h2 id='lasso.ineq'>Complete Run of Constrained LASSO Path Function with Inequality Constraints</h2><span id='topic+lasso.ineq'></span>

<h3>Description</h3>

<p>This is a wrapper function for the <code>lars.c</code> PaC
constrained Lasso function. <code>lasso.c</code> controls the overall path,
providing checks for the path and allowing the user to control
how the path is computed (and what to do in the case of a stopped path).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso.ineq(x, y, C.full, b, l.min = -2, l.max = 6, step = 0.2,
  beta0 = NULL, verbose = F, max.it = 12, intercept = T,
  normalize = T, backwards = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lasso.ineq_+3A_x">x</code></td>
<td>
<p>independent variable matrix of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_y">y</code></td>
<td>
<p>response vector of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_c.full">C.full</code></td>
<td>
<p>complete constraint matrix C (with inequality constraints of the form <code>C.full</code>*<code>beta</code> &gt;= <code>b</code>))</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_b">b</code></td>
<td>
<p>constraint vector b</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_l.min">l.min</code></td>
<td>
<p>lowest value of lambda to consider (used as 10^<code>l.min</code>). Default is -2</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_l.max">l.max</code></td>
<td>
<p>largest value of lambda to consider (used as 10^<code>l.max</code>). Default is 6</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_step">step</code></td>
<td>
<p>step size increase in lambda attempted at each iteration (by a factor of 10^<code>step</code>). Default is 0.2</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_beta0">beta0</code></td>
<td>
<p>initial guess for beta coefficient vector. Default is NULL (indicating
initial vector should be calculated by algorithm)</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_verbose">verbose</code></td>
<td>
<p>should function print output at each iteration (TRUE) or not (FALSE). Default is FALSE</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of times step size is halved before the algorithm terminates and gives a warning. Default is 12</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_intercept">intercept</code></td>
<td>
<p>should intercept be included in modeling (TRUE) or not (FALSE). Default is TRUE.</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_normalize">normalize</code></td>
<td>
<p>should X data be normalized. Default is TRUE</p>
</td></tr>
<tr><td><code id="lasso.ineq_+3A_backwards">backwards</code></td>
<td>
<p>which direction should algorithm go, backwards from lambda = 10^<code>l.max</code> (TRUE)
or forwards from 10^<code>l.max</code> and then backwards if algorithm gets stuck (FALSE).
Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coefs</code> A <code>p</code> by length(<code>lambda</code>) matrix with each column corresponding to the beta estimate for that lambda
</p>
<p><code>lambda</code> vector of values of lambda that were fit
</p>
<p><code>intercept</code> vector with each element corresponding to intercept for corresponding lambda
</p>
<p><code>error</code> Indicator of whether the algorithm terminated early because max.it was reached
</p>


<h3>References</h3>

<p>Gareth M. James, Courtney Paulson, and Paat Rusmevichientong (JASA, 2019) &quot;Penalized and Constrained Optimization.&quot;
(Full text available at http://www-bcf.usc.edu/~gareth/research/PAC.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
lasso_fit = lasso.ineq(random_data$x, random_data$y, random_data$C.full, random_data$b)
lasso_fit$lambda
lasso_fit$error
### The coefficients for the first lambda value
lasso_fit$coefs[1,]
### Example of code where path is unable to be finished
### (only one iteration), so both directions will be tried
lasso_err = lasso.ineq(random_data$x, random_data$y, random_data$C.full,
random_data$b, max.it = 1)
lasso_err$error
lasso_err$lambda
</code></pre>

<hr>
<h2 id='lin.int'>Initialize Linear Programming Fit (Equality Constraints)</h2><span id='topic+lin.int'></span>

<h3>Description</h3>

<p>This function is called internally by <code>lars.c</code>
to get the linear programming initial fit if the user requests
implementation of the algorithm starting at the largest lambda
value and proceeding backwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin.int(C.full, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin.int_+3A_c.full">C.full</code></td>
<td>
<p>complete constraint matrix C (with constraints of the form <code>C.full</code>*<code>beta</code>=<code>b</code>)</p>
</td></tr>
<tr><td><code id="lin.int_+3A_b">b</code></td>
<td>
<p>constraint vector b</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>beta</code> the initial beta vector of coefficients to use for the PaC algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
lin_start = lin.int(random_data$C.full, random_data$b)
lin_start
</code></pre>

<hr>
<h2 id='lin.int.ineq'>Initialize Linear Programming Fit with Inequality Constraints</h2><span id='topic+lin.int.ineq'></span>

<h3>Description</h3>

<p>This function is called internally by <code>lars.ineq</code>
to get the linear programming initial fit if the user requests
implementation of the algorithm starting at the largest lambda
value and proceeding backwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin.int.ineq(C.full, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin.int.ineq_+3A_c.full">C.full</code></td>
<td>
<p>complete constraint matrix C (with inequality constraints of the form <code>C.full</code>*<code>beta</code> &gt;= <code>b</code>))</p>
</td></tr>
<tr><td><code id="lin.int.ineq_+3A_b">b</code></td>
<td>
<p>constraint vector b</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>beta</code> the initial beta vector of coefficients to use for the PaC algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
lin_start = lin.int.ineq(random_data$C.full, random_data$b)
lin_start

</code></pre>

<hr>
<h2 id='quad.int'>Initialize Quadratic Programming Fit (Equality Constraints)</h2><span id='topic+quad.int'></span>

<h3>Description</h3>

<p>This function is called internally by <code>lars.c</code>
to get the quadratic programming fit if the user requests
implementation of the algorithm starting at the smallest lambda
value and proceeding forwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quad.int(x, y, C.full, b, lambda, d = 10^-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quad.int_+3A_x">x</code></td>
<td>
<p>independent variable matrix of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="quad.int_+3A_y">y</code></td>
<td>
<p>response vector of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="quad.int_+3A_c.full">C.full</code></td>
<td>
<p>complete constraint matrix C (with constraints of the form <code>C.full</code>*<code>beta</code>=<code>b</code>)</p>
</td></tr>
<tr><td><code id="quad.int_+3A_b">b</code></td>
<td>
<p>constraint vector b</p>
</td></tr>
<tr><td><code id="quad.int_+3A_lambda">lambda</code></td>
<td>
<p>value of lambda</p>
</td></tr>
<tr><td><code id="quad.int_+3A_d">d</code></td>
<td>
<p>very small diagonal term to allow for SVD (default 10^-7)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>beta</code> the initial beta vector of coefficients to use for the PaC algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
quad_start = quad.int(random_data$x, random_data$y, random_data$C.full,
random_data$b, lambda = 0.01)
quad_start
</code></pre>

<hr>
<h2 id='quad.int.ineq'>Initialize Quadratic Programming Fit with Inequality Constraints</h2><span id='topic+quad.int.ineq'></span>

<h3>Description</h3>

<p>This function is called internally by <code>lars.ineq</code>
to get the quadratic programming fit if the user requests
implementation of the algorithm starting at the smallest lambda
value and proceeding forwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quad.int.ineq(x, y, C.full, b, lambda, d = 10^-5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quad.int.ineq_+3A_x">x</code></td>
<td>
<p>independent variable matrix of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="quad.int.ineq_+3A_y">y</code></td>
<td>
<p>response vector of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="quad.int.ineq_+3A_c.full">C.full</code></td>
<td>
<p>complete constraint matrix C (with inequality constraints of the form <code>C.full</code>*<code>beta</code> &gt;= <code>b</code>))</p>
</td></tr>
<tr><td><code id="quad.int.ineq_+3A_b">b</code></td>
<td>
<p>constraint vector b</p>
</td></tr>
<tr><td><code id="quad.int.ineq_+3A_lambda">lambda</code></td>
<td>
<p>value of lambda</p>
</td></tr>
<tr><td><code id="quad.int.ineq_+3A_d">d</code></td>
<td>
<p>very small diagonal term to allow for SVD (default 10^-7)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>beta</code> the initial beta vector of coefficients to use for the PaC algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
quad_start = quad.int.ineq(random_data$x, random_data$y,
random_data$C.full, random_data$b, lambda = 0.01)
quad_start
</code></pre>

<hr>
<h2 id='transformed'>Transform Data to Fit PaC Implementation (Equality Constraints)</h2><span id='topic+transformed'></span>

<h3>Description</h3>

<p>This function is called internally by <code>lars.c</code>
to compute the transformed versions of the X, Y, and constraint
matrix data, as shown in the PaC paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformed(x, y, C.full, b, lambda, beta0, eps = 10^-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformed_+3A_x">x</code></td>
<td>
<p>independent variable matrix of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="transformed_+3A_y">y</code></td>
<td>
<p>response vector of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="transformed_+3A_c.full">C.full</code></td>
<td>
<p>complete constraint matrix C (with constraints of the form <code>C.full</code>*<code>beta</code>=<code>b</code>)</p>
</td></tr>
<tr><td><code id="transformed_+3A_b">b</code></td>
<td>
<p>constraint vector b</p>
</td></tr>
<tr><td><code id="transformed_+3A_lambda">lambda</code></td>
<td>
<p>value of lambda</p>
</td></tr>
<tr><td><code id="transformed_+3A_beta0">beta0</code></td>
<td>
<p>initial guess for beta coefficient vector</p>
</td></tr>
<tr><td><code id="transformed_+3A_eps">eps</code></td>
<td>
<p>value close to zero used to verify SVD decomposition. Default is 10^-8</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> transformed x data to be used in the PaC algorithm
</p>
<p><code>y</code> transformed y data to be used in the PaC algorithm
</p>
<p><code>Y_star</code> transformed Y* value to be used in the PaC algorithm
</p>
<p><code>a2</code> index of A used in the calculation of beta2 (the non-zero coefficients)
</p>
<p><code>beta1</code> beta1 values
</p>
<p><code>beta2</code> beta2 values
</p>
<p><code>C</code> constraint matrix
</p>
<p><code>C2</code> subset of constraint matrix corresponding to non-zero coefficients
</p>
<p><code>active.beta</code> index of non-zero coefficient values
</p>
<p><code>beta2.index</code> index of non-zero coefficient values
</p>


<h3>References</h3>

<p>Gareth M. James, Courtney Paulson, and Paat Rusmevichientong (JASA, 2019) &quot;Penalized and Constrained Optimization.&quot;
(Full text available at http://www-bcf.usc.edu/~gareth/research/PAC.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
transform_fit = transformed(random_data$x, random_data$y, random_data$C.full,
random_data$b, lambda = 0.01, beta0 = rep(0,20))
dim(transform_fit$x)
head(transform_fit$y)
dim(transform_fit$C)
transform_fit$active.beta
</code></pre>

<hr>
<h2 id='transformed.ineq'>Transform Data to Fit PaC Implementation for Inequality Constraints</h2><span id='topic+transformed.ineq'></span>

<h3>Description</h3>

<p>This function is called internally by <code>lars.c</code>
to compute the transformed versions of the X, Y, and constraint
matrix data, as shown in the PaC paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformed.ineq(x, y, C.full, b, lambda, beta0, eps = 10^-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformed.ineq_+3A_x">x</code></td>
<td>
<p>independent variable matrix of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="transformed.ineq_+3A_y">y</code></td>
<td>
<p>response vector of data to be used in calculating PaC coefficient paths</p>
</td></tr>
<tr><td><code id="transformed.ineq_+3A_c.full">C.full</code></td>
<td>
<p>complete constraint matrix C (with inequality constraints of the form <code>C.full</code>*<code>beta</code> &gt;= <code>b</code>))</p>
</td></tr>
<tr><td><code id="transformed.ineq_+3A_b">b</code></td>
<td>
<p>constraint vector b</p>
</td></tr>
<tr><td><code id="transformed.ineq_+3A_lambda">lambda</code></td>
<td>
<p>value of lambda</p>
</td></tr>
<tr><td><code id="transformed.ineq_+3A_beta0">beta0</code></td>
<td>
<p>initial guess for beta coefficient vector</p>
</td></tr>
<tr><td><code id="transformed.ineq_+3A_eps">eps</code></td>
<td>
<p>value close to zero used to verify SVD decomposition. Default is 10^-8</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> transformed x data to be used in the PaC algorithm
</p>
<p><code>y</code> transformed y data to be used in the PaC algorithm
</p>
<p><code>Y_star</code> transformed Y* value to be used in the PaC algorithm
</p>
<p><code>a2</code> index of A used in the calculation of beta2 (the non-zero coefficients)
</p>
<p><code>beta1</code> beta1 values
</p>
<p><code>beta2</code> beta2 values
</p>
<p><code>C</code> constraint matrix
</p>
<p><code>C2</code> subset of constraint matrix corresponding to non-zero coefficients
</p>
<p><code>active.beta</code> index of non-zero coefficient values
</p>
<p><code>beta2.index</code> index of non-zero coefficient values
</p>


<h3>References</h3>

<p>Gareth M. James, Courtney Paulson, and Paat Rusmevichientong (JASA, 2019) &quot;Penalized and Constrained Optimization.&quot;
(Full text available at http://www-bcf.usc.edu/~gareth/research/PAC.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_data = generate.data(n = 500, p = 20, m = 10)
transform_fit = transformed.ineq(random_data$x, random_data$y,
random_data$C.full, random_data$b, lambda = 0.01, beta0 = rep(0,20))
dim(transform_fit$x)
head(transform_fit$y)
dim(transform_fit$C)
transform_fit$active.beta

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
