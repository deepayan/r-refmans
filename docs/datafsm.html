<!DOCTYPE html><html><head><title>Help for package datafsm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {datafsm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#action_vec'><p>Extracts slot of action_vec</p></a></li>
<li><a href='#add_interact_num'><p>Add interaction numbers for panel data</p></a></li>
<li><a href='#best_performance'><p>Extracts performance</p></a></li>
<li><a href='#build_bitstring'><p>Builds Bitstring</p></a></li>
<li><a href='#compare_fsm'><p>Compares FSMs</p></a></li>
<li><a href='#datafsm'><p>datafsm: A package for estimating FSM models.</p></a></li>
<li><a href='#decode_action_vec'><p>Decodes Action Vector</p></a></li>
<li><a href='#decode_state_mat'><p>Decodes State Matrix</p></a></li>
<li><a href='#degeneracy_check'><p>Determines if State Matrix is Degenerate for Given Data Set.</p></a></li>
<li><a href='#estimation_details'><p>Extracts slot relevant to estimating the fsm</p></a></li>
<li><a href='#evolve_model'><p>Use a Genetic Algorithm to Estimate a Finite-state Machine Model</p></a></li>
<li><a href='#evolve_model_cv'><p>Estimate Optimal Number of States of a Finite-state Machine Model</p></a></li>
<li><a href='#evolve_model_ntimes'><p>Use a Genetic Algorithm to Estimate a Finite-state Machine Model n-times</p></a></li>
<li><a href='#find_wildcards'><p>Find Indices for Non-identifiable Elements of State Matrix.</p></a></li>
<li><a href='#fitnessCPP'><p>Fitness Function in C++</p></a></li>
<li><a href='#ga_fsm-class'><p>An S4 class to return the results of using a GA to estimate a FSM with</p>
<code>evolve_model</code>.</a></li>
<li><a href='#NV_games'><p>Empirical prisoner's dilemma games from Nay and Vorobeychik</p></a></li>
<li><a href='#performance'><p>Measure Model Performance</p></a></li>
<li><a href='#states'><p>Extracts number of states</p></a></li>
<li><a href='#var_imp'><p>Variable Importance Measure for A FSM Model</p></a></li>
<li><a href='#varImp'><p>Extracts slot of variable importances</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Estimating Finite State Machine Models from Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Automatic generation of finite state machine models of dynamic 
    decision-making that both have strong predictive power and are 
    interpretable in human terms. We use an efficient model representation and 
    a genetic algorithm-based estimation process to generate simple 
    deterministic approximations that explain most of the structure of complex 
    stochastic processes. We have applied the software to empirical data, and 
    demonstrated it's ability to recover known data-generating processes by 
    simulating data with agent-based models and correctly deriving the 
    underlying decision models for multiple agent models and degrees of
    stochasticity.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jonathan-g.github.io/datafsm/">https://jonathan-g.github.io/datafsm/</a>,
<a href="https://github.com/jonathan-g/datafsm">https://github.com/jonathan-g/datafsm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jonathan-g/datafsm/issues">https://github.com/jonathan-g/datafsm/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), methods (&ge; 4.0), stats (&ge; 4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel (&ge; 1.0), foreach (&ge; 1.5), testthat (&ge; 3.0),
diagram (&ge; 1.6), knitr (&ge; 1.33), rmarkdown (&ge; 2.8), pander
(&ge; 0.6), dplyr (&ge; 1.0), tidyr (&ge; 1.0), purrr (&ge; 0.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret (&ge; 6.0), GA (&ge; 3.2), Rcpp (&ge; 1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-29 00:21:31 UTC; Jonathan</td>
</tr>
<tr>
<td>Author:</td>
<td>John J. Nay [aut],
  Jonathan M. Gilligan
    <a href="https://orcid.org/0000-0003-1375-6686"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan M. Gilligan &lt;jonathan.gilligan@vanderbilt.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-29 23:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='action_vec'>Extracts slot of action_vec</h2><span id='topic+action_vec'></span>

<h3>Description</h3>

<p>Extracts slot of action_vec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>action_vec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="action_vec_+3A_x">x</code></td>
<td>
<p>S4 ga_fsm object</p>
</td></tr>
</table>

<hr>
<h2 id='add_interact_num'>Add interaction numbers for panel data</h2><span id='topic+add_interact_num'></span>

<h3>Description</h3>

<p><code>add_interact_num</code> takes in data and returns a vector of interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_interact_num(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_interact_num_+3A_d">d</code></td>
<td>
<p>data.frame of panel data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector specifying interactions
</p>

<hr>
<h2 id='best_performance'>Extracts performance</h2><span id='topic+best_performance'></span>

<h3>Description</h3>

<p>Extracts performance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_performance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best_performance_+3A_x">x</code></td>
<td>
<p>S4 ga_fsm object</p>
</td></tr>
</table>

<hr>
<h2 id='build_bitstring'>Builds Bitstring</h2><span id='topic+build_bitstring'></span>

<h3>Description</h3>

<p><code>build_bitstring</code> creates a bitstring from an action vector, state
matrix, and number of actions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_bitstring(action_vec, state_mat, actions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_bitstring_+3A_action_vec">action_vec</code></td>
<td>
<p>Numeric vector indicating what action to take for each
state.</p>
</td></tr>
<tr><td><code id="build_bitstring_+3A_state_mat">state_mat</code></td>
<td>
<p>Numeric matrix with rows as states and columns as
predictors.</p>
</td></tr>
<tr><td><code id="build_bitstring_+3A_actions">actions</code></td>
<td>
<p>Numeric vector length one with the number of actions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns numeric vector bitstring.
</p>

<hr>
<h2 id='compare_fsm'>Compares FSMs</h2><span id='topic+compare_fsm'></span>

<h3>Description</h3>

<p><code>compare_fsm</code> uses a specified distance measure to compare FSMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_fsm(users, gas, comparison = "manhattan")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_fsm_+3A_users">users</code></td>
<td>
<p>Numeric vector or numeric matrix with a predefined FSM</p>
</td></tr>
<tr><td><code id="compare_fsm_+3A_gas">gas</code></td>
<td>
<p>Numeric vector or numeric matrix with an evolved FSM</p>
</td></tr>
<tr><td><code id="compare_fsm_+3A_comparison">comparison</code></td>
<td>
<p>Character string of length one with either &quot;manhattan&quot;,
&quot;euclidean&quot;, or &quot;binary&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compares a user-defined FSM to a decoded estimated FSM. If you have have FSMs
that may have values in the matrices that are not all simple integers, you can
use the distance metric that is most appropriate. Euclidean does
sqrt(sum((x_i - y_i)^2)) - the L2 norm. Manhattan takes abs diff between
them - the L1 norm. Binary treats non-zero elements as &quot;on&quot; and zero
elements as &quot;off&quot; and distance is the proportion of bits in which only one is
on amongst those in which at least one is on.
</p>


<h3>Value</h3>

<p>Numeric vector of length one for the distance between the two
supplied FSMs, calculated according to the comparison argument.
</p>

<hr>
<h2 id='datafsm'>datafsm: A package for estimating FSM models.</h2><span id='topic+datafsm'></span><span id='topic+datafsm-package'></span>

<h3>Description</h3>

<p>It relies on the <strong>GA</strong> package:
Luca Scrucca (2013). GA: A Package for Genetic Algorithms in R.
Journal of Statistical Software, 53 (4), 1-37.
URL <a href="https://www.jstatsoft.org/v53/i04/">https://www.jstatsoft.org/v53/i04/</a>.
</p>


<h3>datafsm functions</h3>

<p><code>datafsm</code>'s main function for estimating a fsm decision
model:
</p>

<ol>
<li> <p><code><a href="#topic+evolve_model">evolve_model</a></code>
</p>
</li></ol>

<p><code>datafsm</code>'s helper functions:
</p>

<ol>
<li> <p><code><a href="#topic+evolve_model_cv">evolve_model_cv</a></code>
</p>
</li>
<li> <p><code><a href="#topic+var_imp">var_imp</a></code>
</p>
</li>
<li> <p><code><a href="#topic+decode_state_mat">decode_state_mat</a></code>
</p>
</li>
<li> <p><code><a href="#topic+decode_action_vec">decode_action_vec</a></code>
</p>
</li>
<li> <p><code><a href="#topic+fitnessCPP">fitnessCPP</a></code>
</p>
</li>
<li> <p><code><a href="#topic+build_bitstring">build_bitstring</a></code>
</p>
</li>
<li> <p><code><a href="#topic+compare_fsm">compare_fsm</a></code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jonathan M. Gilligan <a href="mailto:jonathan.gilligan@vanderbilt.edu">jonathan.gilligan@vanderbilt.edu</a> (<a href="https://orcid.org/0000-0003-1375-6686">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> John J. Nay <a href="mailto:john.j.nay@gmail.com">john.j.nay@gmail.com</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jonathan-g.github.io/datafsm/">https://jonathan-g.github.io/datafsm/</a>
</p>
</li>
<li> <p><a href="https://github.com/jonathan-g/datafsm">https://github.com/jonathan-g/datafsm</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jonathan-g/datafsm/issues">https://github.com/jonathan-g/datafsm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='decode_action_vec'>Decodes Action Vector</h2><span id='topic+decode_action_vec'></span>

<h3>Description</h3>

<p><code>decode_action_vec</code> decodes action vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_action_vec(string, states, inputs, actions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_action_vec_+3A_string">string</code></td>
<td>
<p>Numeric (integer) vector of only 1's and 0's.</p>
</td></tr>
<tr><td><code id="decode_action_vec_+3A_states">states</code></td>
<td>
<p>Numeric vector with the number of states, which is the number
of rows.</p>
</td></tr>
<tr><td><code id="decode_action_vec_+3A_inputs">inputs</code></td>
<td>
<p>Numeric vector length one, with the number of columns.</p>
</td></tr>
<tr><td><code id="decode_action_vec_+3A_actions">actions</code></td>
<td>
<p>Numeric vector with the number of actions. Actions (and
states) determine how many binary elements we need to represent an element
of the action (or state) matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a solution string of binary values in Gray
representation, transforms it to a decimal representation, then puts it in
matrix form with the correct sized matrices, given the specified numbers of
states, inputs, and actions.
</p>


<h3>Value</h3>

<p>Returns numeric (integer) vector.
</p>

<hr>
<h2 id='decode_state_mat'>Decodes State Matrix</h2><span id='topic+decode_state_mat'></span>

<h3>Description</h3>

<p><code>decode_state_mat</code> decodes state matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_state_mat(string, states, inputs, actions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_state_mat_+3A_string">string</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="decode_state_mat_+3A_states">states</code></td>
<td>
<p>Numeric vector with the number of states, which is the number
of rows.</p>
</td></tr>
<tr><td><code id="decode_state_mat_+3A_inputs">inputs</code></td>
<td>
<p>Numeric vector length one, with the number of columns.</p>
</td></tr>
<tr><td><code id="decode_state_mat_+3A_actions">actions</code></td>
<td>
<p>Numeric vector with the number of actions. Actions (and
states) determine how many binary elements we need to represent an element
of the action (or state) matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a solution string of binary values in Gray
representation, transforms it to a decimal representation, then puts it in
matrix form with the correct sized matrices, given the specified numbers of
states, inputs, and actions.
</p>


<h3>Value</h3>

<p>Returns numeric (integer) matrix.
</p>

<hr>
<h2 id='degeneracy_check'>Determines if State Matrix is Degenerate for Given Data Set.</h2><span id='topic+degeneracy_check'></span>

<h3>Description</h3>

<p><code>degeneracy_check</code> finds indices for non-identifiable elements of state
matrix and then flips values for those elements and checks changes in
resulting fitness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degeneracy_check(state_mat, action_vec, cols, data, outcome)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degeneracy_check_+3A_state_mat">state_mat</code></td>
<td>
<p>Numeric matrix with rows as states and columns as
predictors.</p>
</td></tr>
<tr><td><code id="degeneracy_check_+3A_action_vec">action_vec</code></td>
<td>
<p>Numeric vector indicating what action to take for each
state.</p>
</td></tr>
<tr><td><code id="degeneracy_check_+3A_cols">cols</code></td>
<td>
<p>Optional numeric vector same length as number of columns of the
state matrix (<code>state_mat</code>) with the action that each column of the
state matrix corresponds to the decision model taking in the previous
period. This is only relevant when the predictor variables of the FSM are
lagged outcomes that include the previous actions taken by that decision
model.</p>
</td></tr>
<tr><td><code id="degeneracy_check_+3A_data">data</code></td>
<td>
<p>Numeric matrix that has first col period and rest of cols are
predictors.</p>
</td></tr>
<tr><td><code id="degeneracy_check_+3A_outcome">outcome</code></td>
<td>
<p>Numeric vector same length as the number of rows as data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>degeneracy_check</code> finds indices for non-identifiable elements of state
matrix and then flips values for those elements and checks changes in
resulting fitness. Being in state/row k (e.g. 2) corresponds to taking action
j (e.g. D). For row k, all entries in the matrix that corresponds to taking
action j last period (e.g. columns 2 and 4 for D) are identifiable; however,
columns that correspond to not taking action j last period (e.g. columns 1
and 3 for D) for the row $k$ that corresponds to taking action j are not
identifiable for a deterministic play of the strategy. For all elements of
the matrix that are not identifiable, the value of the element can be any
integer in the inclusive range of the number of rows of the matrix (e.g. 1 or
2). With empirical data, where the probability that a single deterministic
model generated the data is effectively zero, it is useful to find every
entry in the matrix that would be unidentifiable if the strategy were played
deterministically and then for each element flip it to its opposite value and
test for any change in fitness of the strategy on the data. This function
implements this idea. If there is no change, a sparse matrix is returned
where the the elements in that matrix with a 0 are unidentifiable because
their value makes no difference to the fit of the strategy to the provided
data. If, for each element in the matrix, switching its value led to a
decrease in fitness the following message is displayed, &ldquo;Your strategy is a
deterministic approximation of a stochastic process and all of the elements
of the state matrix can be identified.&rdquo; If the model is fine, then
<code>sparse_state_mat</code> and <code>corrected_state_mat</code> should be equal to
<code>state_mat</code>.
</p>


<h3>Value</h3>

<p>Returns a list of with sparse and corrected state matrix.  If the
model is fine, then<br />
<code>sparse_state_mat</code> and <code>corrected_state_mat</code>
should be equal to <code>state_mat</code>.
</p>

<hr>
<h2 id='estimation_details'>Extracts slot relevant to estimating the fsm</h2><span id='topic+estimation_details'></span>

<h3>Description</h3>

<p>Extracts slot relevant to estimating the fsm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimation_details(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimation_details_+3A_x">x</code></td>
<td>
<p>S4 ga_fsm object</p>
</td></tr>
</table>

<hr>
<h2 id='evolve_model'>Use a Genetic Algorithm to Estimate a Finite-state Machine Model</h2><span id='topic+evolve_model'></span>

<h3>Description</h3>

<p><code>evolve_model</code> uses a genetic algorithm to estimate a finite-state
machine model, primarily for understanding and predicting decision-making.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evolve_model(data, test_data = NULL, drop_nzv = FALSE,
        measure = c("accuracy", "sens", "spec", "ppv"),
        states = NULL, cv = FALSE, max_states = NULL, k = 2,
        actions = NULL, seed = NULL, popSize = 75,
        pcrossover = 0.8, pmutation = 0.1, maxiter = 50,
        run = 25, parallel = FALSE, priors = NULL,
        verbose = TRUE, return_best = TRUE, ntimes = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evolve_model_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> that has columns named &quot;period&quot; and &quot;outcome&quot;
(period is the time period that the outcome action was taken), and one to
three additional columns, containing predictors.
All of the 3-5 columns should be named.
The period and outcome columns should be integer vectors and the columns
with the predictor variable data should be logical vectors
(<code>TRUE, FALSE</code>).
If the predictor variable data is not  logical, it will coerced to logical
with <br />
<code>base::as.logical()</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_test_data">test_data</code></td>
<td>
<p>Optional <code>data.frame</code> that has &quot;period&quot; and &quot;outcome&quot;
columns, with one to three additional columns containing predictors.
All of the (3-5 columns) should be named. The outcome variable is the
decision the decision-maker took for that period.
This <code>data.frame</code> should be in the same format and have the same order
of columns as the data.frame passed to the required <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_drop_nzv">drop_nzv</code></td>
<td>
<p>Optional logical vector length one specifying whether
predictors variables with variance in provided data near zero should be
dropped before model building. Default is <code>FALSE</code>. See
<code>caret::nearZeroVar()</code>, which calls:<br />
<code>caret::nzv()</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_measure">measure</code></td>
<td>
<p>Optional length one character vector that is either:
&quot;accuracy&quot;, &quot;sens&quot;, &quot;spec&quot;, or &quot;ppv&quot;. This specifies what measure of
predictive performance to use for training and evaluating the model. The
default measure is <code>"accuracy"</code>. However, accuracy can be a problematic
measure when the classes are imbalanced in the samples, i.e. if a class the
model is trying to predict is very rare. Alternatives to accuracy are
available that illuminate different aspects of predictive power. Sensitivity
answers the question, &ldquo; given that a result is truly an event, what is the
probability that the model will predict an event?&rdquo; Specificity answers the
question, &ldquo;given that a result is truly not an event, what is the
probability that the model will predict a negative?&rdquo; Positive predictive
value answers, &ldquo;what is the percent of predicted positives that are
actually positive?&rdquo;</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_states">states</code></td>
<td>
<p>Optional numeric vector with the number of states.
If not provided, will be set to <code>max(data$outcome)</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_cv">cv</code></td>
<td>
<p>Optional logical vector length one for whether cross-validation
should be conducted on training data to select optimal number of states.
This can drastically increase computation time because if <code>TRUE</code>, it
will run <code>evolve_model</code> <code>k*max_states</code> times to estimate optimal
value for states. Ties are broken by choosing the smaller number of states.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_max_states">max_states</code></td>
<td>
<p>Optional numeric vector length one only relevant if
<code>cv==TRUE</code>. It specifies how up to how many states that
cross-validation should search through.
If not provided, will be set to <code>states + 1</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_k">k</code></td>
<td>
<p>Optional numeric vector length one only relevant if cv==TRUE,
specifying number of folds for cross-validation.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_actions">actions</code></td>
<td>
<p>Optional numeric vector with the number of actions. If not
provided, then actions will be set as the number of unique values in the
outcome vector.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_seed">seed</code></td>
<td>
<p>Optional numeric vector length one.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_popsize">popSize</code></td>
<td>
<p>Optional numeric vector length one specifying the size of the
GA population. A larger number will increase the probability of finding a
very good solution but will also increase the computation time. This is
passed to the GA::ga() function of the <strong>GA</strong> package.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_pcrossover">pcrossover</code></td>
<td>
<p>Optional numeric vector length one specifying probability of
crossover for GA. This is passed to the GA::ga() function of the <strong>GA</strong>
package.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_pmutation">pmutation</code></td>
<td>
<p>Optional numeric vector length one specifying probability of
mutation for GA. This is passed to the GA::ga() function of the <strong>GA</strong>
package.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional numeric vector length one specifying max number of
iterations for stopping the GA evolution. A larger number will increase the
probability of finding a very good solution but will also increase the
computation time. This is passed to the GA::ga() function of the <strong>GA</strong>
package. <code>maxiter</code> is scaled by how many parameters are in the model:<br />
<code>maxiter &lt;- maxiter + ((maxiter*(nBits^2)) / maxiter)</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_run">run</code></td>
<td>
<p>Optional numeric vector length one specifying max number of
consecutive iterations without improvement in best fitness score for
stopping the GA evolution. A larger number will increase the probability of
finding a very good solution but will also increase the computation time.
This is passed to the GA::ga() function of the <strong>GA</strong> package.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_parallel">parallel</code></td>
<td>
<p>Optional logical vector length one. For running the GA
evolution in parallel. Depending on the number of cores registered and the
memory on your machine, this can make the process much faster, but only works
for Unix-based machines that can fork the processes.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_priors">priors</code></td>
<td>
<p>Optional numeric matrix of solutions strings to be included in
the initialization. User needs to use a decoder function to translate prior
decision models into bits and then provide them. If this is not specified,
then random priors are automatically created.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_verbose">verbose</code></td>
<td>
<p>Optional logical vector length one specifying whether helpful
messages should be displayed on the user's console or not.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_return_best">return_best</code></td>
<td>
<p>Optional logical vector length one specifying whether to
return just the best model or all models. Only relevant if ntimes &gt; 1.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="evolve_model_+3A_ntimes">ntimes</code></td>
<td>
<p>Optional integer vector length one specifying the number of
times to estimate model. Default is 1 time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function of the <strong>datafsm</strong> package. It relies on the
<strong>GA</strong> package for genetic algorithm optimization. <code>evolve_model</code>
takes data on predictors and data on the outcome. It automatically creates a
fitness function that takes the data, an action vector <code>evolve_model</code>
generates, and a state matrix <code>evolve_model</code> generates as input and
returns numeric vector of the same length as the <code>outcome</code>.
<code>evolve_model</code> then computes a fitness score for that potential solution
FSM by comparing it to the provided <code>outcome</code>. This is repeated for every
FSM in the population and then the probability of selection for the next
generation is proportional to the fitness scores. The default is also for the
function to call itself recursively while varying the number of states inside
a cross-validation loop in order to estimate the optimal number of states.
</p>
<p>If parallel is set to TRUE, then these evaluations are distributed across the
available processors of the computer using the <strong>doParallel</strong> package,
otherwise, the evaluations of fitness are conducted sequentially. Because
this fitness function that <code>evolve_model</code> creates must loop through all
the data every time it is evaluated and we need to evaluate many possible
solution FSMs, the fitness function is implemented in C++ so it is very fast.
</p>
<p><code>evolve_model</code> uses a stochastic meta-heuristic optimization routine to
estimate the parameters that define a FSM model. Generalized simulated
annealing, or tabu search could work, but they are more difficult to
parallelize. The current version uses the <strong>GA</strong> package's genetic
algorithm because GAs perform well in rugged search spaces to solve integer
optimization problems, are a natural complement to our binary string
representation of FSMs, and are easily parallelized.
</p>
<p>This function evolves the models on training data and then, if a test set is
provided, uses the best solution to make predictions on test data. Finally,
the function returns the GA object and the decoded version of the best string
in the population. See <a href="#topic+ga_fsm-class">ga_fsm</a> for the details of the slots
(objects) that this type of object will have.
</p>


<h3>Value</h3>

<p>Returns an S4 object of class ga_fsm. See <a href="#topic+ga_fsm-class">ga_fsm</a> for the
details of the slots (objects) that this type of object will have and for
information on the methods that can be used to summarize the calling and
execution of <code>evolve_model()</code>, including <code>summary</code>, <code>print</code>,
and <code>plot</code>. Timing measurement is in seconds.
</p>


<h3>References</h3>

<p>Luca Scrucca (2013). GA: A Package for Genetic Algorithms in R.
Journal of Statistical Software, 53(4), 1-37. URL
<a href="https://www.jstatsoft.org/v53/i04/">https://www.jstatsoft.org/v53/i04/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create data:
cdata &lt;- data.frame(period = rep(1:10, 1000),
                   outcome = rep(1:2, 5000),
                   my.decision1 = sample(1:0, 10000, TRUE),
                   other.decision1 = sample(1:0, 10000, TRUE))
(res &lt;- evolve_model(cdata, cv=FALSE))
summary(res)
plot(res, action_label = c("C", "D"))
library(GA)
plot(estimation_details(res))

## End(Not run)

# In scripts, it can makes sense to set parallel to
# 'as.logical(Sys.info()['sysname'] != 'Windows')'.

</code></pre>

<hr>
<h2 id='evolve_model_cv'>Estimate Optimal Number of States of a Finite-state Machine Model</h2><span id='topic+evolve_model_cv'></span>

<h3>Description</h3>

<p><code>evolve_model_cv</code> calls <code>evolve_model</code> with varied numbers of
states and compares their performance with cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evolve_model_cv(data, measure, k, actions, max_states, seed,
        popSize, pcrossover, pmutation, maxiter, run,  parallel,
        verbose, ntimes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evolve_model_cv_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> that has columns named &quot;period&quot; and &quot;outcome&quot;
(period is the time period that the outcome action was taken), and one to
three additional columns, containing predictors.
All of the 3-5 columns should be named.
The period and outcome columns should be integer vectors and the columns
with the predictor variable data should be logical vectors
(<code>TRUE, FALSE</code>).
If the predictor variable data is not  logical, it will coerced to logical
with <br />
<code>base::as.logical()</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_measure">measure</code></td>
<td>
<p>Optional length one character vector that is either:
&quot;accuracy&quot;, &quot;sens&quot;, &quot;spec&quot;, or &quot;ppv&quot;. This specifies what measure of
predictive performance to use for training and evaluating the model. The
default measure is <code>"accuracy"</code>. However, accuracy can be a problematic
measure when the classes are imbalanced in the samples, i.e. if a class the
model is trying to predict is very rare. Alternatives to accuracy are
available that illuminate different aspects of predictive power. Sensitivity
answers the question, &ldquo; given that a result is truly an event, what is the
probability that the model will predict an event?&rdquo; Specificity answers the
question, &ldquo;given that a result is truly not an event, what is the
probability that the model will predict a negative?&rdquo; Positive predictive
value answers, &ldquo;what is the percent of predicted positives that are
actually positive?&rdquo;</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_k">k</code></td>
<td>
<p>Optional numeric vector length one only relevant if cv==TRUE,
specifying number of folds for cross-validation.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_actions">actions</code></td>
<td>
<p>Optional numeric vector with the number of actions. If not
provided, then actions will be set as the number of unique values in the
outcome vector.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_max_states">max_states</code></td>
<td>
<p>Optional numeric vector length one only relevant if
<code>cv==TRUE</code>. It specifies how up to how many states that
cross-validation should search through.
If not provided, will be set to <code>states + 1</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_seed">seed</code></td>
<td>
<p>Optional numeric vector length one.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_popsize">popSize</code></td>
<td>
<p>Optional numeric vector length one specifying the size of the
GA population. A larger number will increase the probability of finding a
very good solution but will also increase the computation time. This is
passed to the GA::ga() function of the <strong>GA</strong> package.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_pcrossover">pcrossover</code></td>
<td>
<p>Optional numeric vector length one specifying probability of
crossover for GA. This is passed to the GA::ga() function of the <strong>GA</strong>
package.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_pmutation">pmutation</code></td>
<td>
<p>Optional numeric vector length one specifying probability of
mutation for GA. This is passed to the GA::ga() function of the <strong>GA</strong>
package.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional numeric vector length one specifying max number of
iterations for stopping the GA evolution. A larger number will increase the
probability of finding a very good solution but will also increase the
computation time. This is passed to the GA::ga() function of the <strong>GA</strong>
package. <code>maxiter</code> is scaled by how many parameters are in the model:<br />
<code>maxiter &lt;- maxiter + ((maxiter*(nBits^2)) / maxiter)</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_run">run</code></td>
<td>
<p>Optional numeric vector length one specifying max number of
consecutive iterations without improvement in best fitness score for
stopping the GA evolution. A larger number will increase the probability of
finding a very good solution but will also increase the computation time.
This is passed to the GA::ga() function of the <strong>GA</strong> package.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_parallel">parallel</code></td>
<td>
<p>Optional logical vector length one. For running the GA
evolution in parallel. Depending on the number of cores registered and the
memory on your machine, this can make the process much faster, but only works
for Unix-based machines that can fork the processes.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_verbose">verbose</code></td>
<td>
<p>Optional logical vector length one specifying whether helpful
messages should be displayed on the user's console or not.</p>
</td></tr>
<tr><td><code id="evolve_model_cv_+3A_ntimes">ntimes</code></td>
<td>
<p>Optional integer vector length one specifying the number of
times to estimate model. Default is 1 time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the number of states that maximizes the <code>measure</code>, e.g.
accuracy.
</p>


<h3>References</h3>

<p>Luca Scrucca (2013). GA: A Package for Genetic Algorithms in R.
Journal of Statistical Software, 53(4), 1-37. URL
<a href="https://www.jstatsoft.org/v53/i04/">https://www.jstatsoft.org/v53/i04/</a>.
</p>
<p>Hastie, T., R. Tibshirani, and J. Friedman. (2009). The Elements of
Statistical Learning: Data Mining, Inference, and Prediction, Second
Edition. 2nd ed. New York, NY: Springer.
</p>

<hr>
<h2 id='evolve_model_ntimes'>Use a Genetic Algorithm to Estimate a Finite-state Machine Model n-times</h2><span id='topic+evolve_model_ntimes'></span>

<h3>Description</h3>

<p><code>evolve_model</code> uses a genetic algorithm to estimate a finite-state
machine model, primarily for understanding and predicting decision-making.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evolve_model_ntimes(data, test_data = NULL, drop_nzv = FALSE,
        measure = c("accuracy", "sens", "spec", "ppv"),
        states = NULL, cv = FALSE, max_states = NULL, k = 2,
        actions = NULL, seed = NULL, popSize = 75,
        pcrossover = 0.8, pmutation = 0.1, maxiter = 50,
        run = 25, parallel = FALSE, priors = NULL,
        verbose = TRUE, return_best = TRUE, ntimes = 10,
        cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evolve_model_ntimes_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> that has columns named &quot;period&quot; and &quot;outcome&quot;
(period is the time period that the outcome action was taken), and one to
three additional columns, containing predictors.
All of the 3-5 columns should be named.
The period and outcome columns should be integer vectors and the columns
with the predictor variable data should be logical vectors
(<code>TRUE, FALSE</code>).
If the predictor variable data is not  logical, it will coerced to logical
with <br />
<code>base::as.logical()</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_test_data">test_data</code></td>
<td>
<p>Optional <code>data.frame</code> that has &quot;period&quot; and &quot;outcome&quot;
columns, with one to three additional columns containing predictors.
All of the (3-5 columns) should be named. The outcome variable is the
decision the decision-maker took for that period.
This <code>data.frame</code> should be in the same format and have the same order
of columns as the data.frame passed to the required <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_drop_nzv">drop_nzv</code></td>
<td>
<p>Optional logical vector length one specifying whether
predictors variables with variance in provided data near zero should be
dropped before model building. Default is <code>FALSE</code>. See
<code>caret::nearZeroVar()</code>, which calls:<br />
<code>caret::nzv()</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_measure">measure</code></td>
<td>
<p>Optional length one character vector that is either:
&quot;accuracy&quot;, &quot;sens&quot;, &quot;spec&quot;, or &quot;ppv&quot;. This specifies what measure of
predictive performance to use for training and evaluating the model. The
default measure is <code>"accuracy"</code>. However, accuracy can be a problematic
measure when the classes are imbalanced in the samples, i.e. if a class the
model is trying to predict is very rare. Alternatives to accuracy are
available that illuminate different aspects of predictive power. Sensitivity
answers the question, &ldquo; given that a result is truly an event, what is the
probability that the model will predict an event?&rdquo; Specificity answers the
question, &ldquo;given that a result is truly not an event, what is the
probability that the model will predict a negative?&rdquo; Positive predictive
value answers, &ldquo;what is the percent of predicted positives that are
actually positive?&rdquo;</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_states">states</code></td>
<td>
<p>Optional numeric vector with the number of states.
If not provided, will be set to <code>max(data$outcome)</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_cv">cv</code></td>
<td>
<p>Optional logical vector length one for whether cross-validation
should be conducted on training data to select optimal number of states.
This can drastically increase computation time because if <code>TRUE</code>, it
will run <code>evolve_model</code> <code>k*max_states</code> times to estimate optimal
value for states. Ties are broken by choosing the smaller number of states.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_max_states">max_states</code></td>
<td>
<p>Optional numeric vector length one only relevant if
<code>cv==TRUE</code>. It specifies how up to how many states that
cross-validation should search through.
If not provided, will be set to <code>states + 1</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_k">k</code></td>
<td>
<p>Optional numeric vector length one only relevant if cv==TRUE,
specifying number of folds for cross-validation.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_actions">actions</code></td>
<td>
<p>Optional numeric vector with the number of actions. If not
provided, then actions will be set as the number of unique values in the
outcome vector.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_seed">seed</code></td>
<td>
<p>Optional numeric vector length one.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_popsize">popSize</code></td>
<td>
<p>Optional numeric vector length one specifying the size of the
GA population. A larger number will increase the probability of finding a
very good solution but will also increase the computation time. This is
passed to the GA::ga() function of the <strong>GA</strong> package.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_pcrossover">pcrossover</code></td>
<td>
<p>Optional numeric vector length one specifying probability of
crossover for GA. This is passed to the GA::ga() function of the <strong>GA</strong>
package.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_pmutation">pmutation</code></td>
<td>
<p>Optional numeric vector length one specifying probability of
mutation for GA. This is passed to the GA::ga() function of the <strong>GA</strong>
package.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional numeric vector length one specifying max number of
iterations for stopping the GA evolution. A larger number will increase the
probability of finding a very good solution but will also increase the
computation time. This is passed to the GA::ga() function of the <strong>GA</strong>
package. <code>maxiter</code> is scaled by how many parameters are in the model:<br />
<code>maxiter &lt;- maxiter + ((maxiter*(nBits^2)) / maxiter)</code>.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_run">run</code></td>
<td>
<p>Optional numeric vector length one specifying max number of
consecutive iterations without improvement in best fitness score for
stopping the GA evolution. A larger number will increase the probability of
finding a very good solution but will also increase the computation time.
This is passed to the GA::ga() function of the <strong>GA</strong> package.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_parallel">parallel</code></td>
<td>
<p>Optional logical vector length one. For running the GA
evolution in parallel. Depending on the number of cores registered and the
memory on your machine, this can make the process much faster, but only works
for Unix-based machines that can fork the processes.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_priors">priors</code></td>
<td>
<p>Optional numeric matrix of solutions strings to be included in
the initialization. User needs to use a decoder function to translate prior
decision models into bits and then provide them. If this is not specified,
then random priors are automatically created.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_verbose">verbose</code></td>
<td>
<p>Optional logical vector length one specifying whether helpful
messages should be displayed on the user's console or not.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_return_best">return_best</code></td>
<td>
<p>Optional logical vector length one specifying whether to
return just the best model or all models. Only relevant if ntimes &gt; 1.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_ntimes">ntimes</code></td>
<td>
<p>Optional integer vector length one specifying the number of
times to estimate model. Default is 1 time.</p>
</td></tr>
<tr><td><code id="evolve_model_ntimes_+3A_cores">cores</code></td>
<td>
<p>integer vector length one specifying number of cores to use if
parallel is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function of the <strong>datafsm</strong> package applies the <code>evolve_model</code>
function multiple times and then returns a list with either all the models or
the best one.
</p>
<p><code>evolve_model</code> uses a stochastic meta-heuristic optimization routine to
estimate the parameters that define a FSM model. Because this is not
guaranteed to return the best result, we run it many times.
</p>


<h3>Value</h3>

<p>Returns a list where each element is an S4 object of class ga_fsm. See
<a href="#topic+ga_fsm-class">ga_fsm</a> for the details of the slots (objects) that this type
of object will have and for information on the methods that can be used to
summarize the calling and execution of <code>evolve_model()</code>, including
<code>summary</code>, <code>print</code>, and <code>plot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create data:
cdata &lt;- data.frame(period = rep(1:10, 1000),
                   outcome = rep(1:2, 5000),
                   my.decision1 = sample(1:0, 10000, TRUE),
                   other.decision1 = sample(1:0, 10000, TRUE))
(res &lt;- evolve_model_ntimes(cdata, ntimes=2))
(res &lt;- evolve_model_ntimes(cdata, return_best = FALSE, ntimes=2))

## End(Not run)

</code></pre>

<hr>
<h2 id='find_wildcards'>Find Indices for Non-identifiable Elements of State Matrix.</h2><span id='topic+find_wildcards'></span>

<h3>Description</h3>

<p><code>find_wildcards</code> finds indices for non-identifiable elements of state
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_wildcards(state_mat, action_vec, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_wildcards_+3A_state_mat">state_mat</code></td>
<td>
<p>Numeric matrix with rows as states and columns as
predictors.</p>
</td></tr>
<tr><td><code id="find_wildcards_+3A_action_vec">action_vec</code></td>
<td>
<p>Numeric vector indicating what action to take for each
state.</p>
</td></tr>
<tr><td><code id="find_wildcards_+3A_cols">cols</code></td>
<td>
<p>Numeric vector same length as number of columns of the
state matrix<br />
(<code>state_mat</code>) 
with the action that each column of the
state matrix corresponds to the decision model taking in the previous
period. This is only relevant when the predictor variables of the FSM are
lagged outcomes that include the previous actions taken by that decision
model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for <code><a href="#topic+degeneracy_check">degeneracy_check</a></code>.
</p>


<h3>Value</h3>

<p>Returns a list of indices (tuples specifying row and column of a
matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tft_state &lt;- matrix(c(1, 1, 1, 1, 2, 2, 2, 2), 2, 4)
tft_action &lt;- matrix(c(1, 2))
find_wildcards(tft_state, tft_action,  c(1, 2, 1, 2))

</code></pre>

<hr>
<h2 id='fitnessCPP'>Fitness Function in C++</h2><span id='topic+fitnessCPP'></span>

<h3>Description</h3>

<p>A generated action vector and state matrix are input and this function
returns a numeric vector of the same length as the <code>outcome</code>.
<code>evolve_model</code> then computes a fitness score for that potential
solution FSM by comparing it to the provided <code>outcome</code>. This is
repeated for every FSM in the population and then the probability of
selection for the next generation is set to be proportional to the fitness
scores. This function is also used in the predict method for the resulting
final model that is returned. The function aborts if the user aborts in R,
checking every 1000 iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitnessCPP(action_vec, state_mat, covariates, period)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitnessCPP_+3A_action_vec">action_vec</code></td>
<td>
<p>Integer Vector.</p>
</td></tr>
<tr><td><code id="fitnessCPP_+3A_state_mat">state_mat</code></td>
<td>
<p>Integer Matrix.</p>
</td></tr>
<tr><td><code id="fitnessCPP_+3A_covariates">covariates</code></td>
<td>
<p>Integer Matrix.</p>
</td></tr>
<tr><td><code id="fitnessCPP_+3A_period">period</code></td>
<td>
<p>Integer Vector.</p>
</td></tr>
</table>

<hr>
<h2 id='ga_fsm-class'>An S4 class to return the results of using a GA to estimate a FSM with
<code><a href="#topic+evolve_model">evolve_model</a></code>.</h2><span id='topic+ga_fsm-class'></span><span id='topic+print+2Cga_fsm-method'></span><span id='topic+show+2Cga_fsm-method'></span><span id='topic+summary+2Cga_fsm-method'></span><span id='topic+plot+2Cga_fsm+2CANY-method'></span><span id='topic+plot+2Cga_fsm-method'></span><span id='topic+barplot+2Cga_fsm-method'></span><span id='topic+dotchart+2Cga_fsm-method'></span><span id='topic+estimation_details+2Cga_fsm-method'></span><span id='topic+best_performance+2Cga_fsm-method'></span><span id='topic+varImp+2Cga_fsm-method'></span><span id='topic+action_vec+2Cga_fsm-method'></span><span id='topic+states+2Cga_fsm-method'></span><span id='topic+predict+2Cga_fsm-method'></span>

<h3>Description</h3>

<p>An S4 class to return the results of using a GA to estimate a FSM with
<code><a href="#topic+evolve_model">evolve_model</a></code>.
</p>
<p>Turns ga_fsm S4 object into list of summaries for printing and then prints it.
</p>
<p>Plots ga_fsm S4 object's state transition matrix
</p>
<p>Plots ga_fsm S4 object's variable importances
</p>
<p>Plots ga_fsm S4 object's variable importances
</p>
<p>Extracts slot relevant to estimating the fsm
</p>
<p>Extracts performance
</p>
<p>Extracts slot of variable importances
</p>
<p>Extracts slot of action_vec
</p>
<p>Extracts number of states
</p>
<p>Predicts new data with estimated model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ga_fsm'
print(x, ...)

## S4 method for signature 'ga_fsm'
show(object)

## S4 method for signature 'ga_fsm'
summary(object, digits = 3)

## S4 method for signature 'ga_fsm,ANY'
plot(x, y, maintitle = "Transition Diagram",
          action_label = NULL, transition_label = NULL, 
          curvature = c(0.3, 0.6, 0.8))

## S4 method for signature 'ga_fsm'
barplot(height, ...)

## S4 method for signature 'ga_fsm'
dotchart(x, labels)

## S4 method for signature 'ga_fsm'
estimation_details(x)

## S4 method for signature 'ga_fsm'
best_performance(x)

## S4 method for signature 'ga_fsm'
varImp(x)

## S4 method for signature 'ga_fsm'
action_vec(x)

## S4 method for signature 'ga_fsm'
states(x)

## S4 method for signature 'ga_fsm'
predict(object, data, type = "prob", na.action = stats::na.omit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ga_fsm-class_+3A_x">x</code></td>
<td>
<p>S4 ga_fsm object.
@export</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_...">...</code></td>
<td>
<p>arguments to be passed to/from other methods.</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_object">object</code></td>
<td>
<p>S4 ga_fsm object</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_digits">digits</code></td>
<td>
<p>Optional numeric vector length one for how many significant digits to
print, default is 3.
</p>
<p>@export</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_y">y</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_maintitle">maintitle</code></td>
<td>
<p>optional character vector</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_action_label">action_label</code></td>
<td>
<p>optional character vector same length as action vector,
where each ith element corresponds to what that ith element in the action
vector represents. This will be used to fill in the states (circles) of the
state transition matrix to be plotted.</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_transition_label">transition_label</code></td>
<td>
<p>optional character vector same length as number of
columns of state transition matrix.</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_curvature">curvature</code></td>
<td>
<p>optional numeric vector specifying the curvature of the
lines for a diagram of 2 or more states.</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_height">height</code></td>
<td>
<p>ga_fsm S4 object</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_labels">labels</code></td>
<td>
<p>vector of labels for each point. For vectors the default is to
use names(x) and for matrices the row labels dimnames(x)[[1]].</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> that has columns named &quot;period&quot; and &quot;outcome&quot;
(period is the time period that the outcome action was taken), and one to
three additional columns, containing predictors.
All of the 3-5 columns should be named.
The period and outcome columns should be integer vectors and the columns
with the predictor variable data should be logical vectors
(<code>TRUE, FALSE</code>).
If the predictor variable data is not  logical, it will coerced to logical
with <br />
<code>base::as.logical()</code>.</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_type">type</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="ga_fsm-class_+3A_na.action">na.action</code></td>
<td>
<p>Optional function.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print</code>: An S4 method for printing a ga_fsm S4 object
</p>
</li>
<li> <p><code>show</code>: An S4 method for showing a ga_fsm S4 object
</p>
</li>
<li> <p><code>summary</code>: An S4 method for summarizing a ga_fsm S4 object
</p>
</li>
<li> <p><code>plot</code>: 
</p>
</li>
<li> <p><code>barplot</code>: 
</p>
</li>
<li> <p><code>dotchart</code>: Plots ga_fsm S4 object's variable importances
</p>
</li>
<li> <p><code>estimation_details</code>: @export
</p>
</li>
<li> <p><code>best_performance</code>: @export
</p>
</li>
<li> <p><code>varImp</code>: @export
</p>
</li>
<li> <p><code>action_vec</code>: @export
</p>
</li>
<li> <p><code>states</code>: @export
</p>
</li>
<li> <p><code>predict</code>: Predicts new data with estimated model
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>Language from the call of the function <code><a href="#topic+evolve_model">evolve_model</a></code>.</p>
</dd>
<dt><code>actions</code></dt><dd><p>Numeric vector with the number of actions.</p>
</dd>
<dt><code>states</code></dt><dd><p>Numeric vector with the number of states.</p>
</dd>
<dt><code>GA</code></dt><dd><p>S4 object created by ga() from the GA package.</p>
</dd>
<dt><code>state_mat</code></dt><dd><p>Numeric matrix with rows as states and columns as predictors.</p>
</dd>
<dt><code>action_vec</code></dt><dd><p>Numeric vector indicating what action to take for each
state.</p>
</dd>
<dt><code>predictive</code></dt><dd><p>Numeric vector of length one with test data accuracy if test
data was supplied; otherwise, a character vector with a message that the
user should provide test data for better estimate of performance.</p>
</dd>
<dt><code>varImp</code></dt><dd><p>Numeric vector same length as number of columns of state matrix
with relative importance scores for each predictor.</p>
</dd>
<dt><code>varImp2</code></dt><dd><p>Numeric matrix same size as state matrix
with relative importance scores for each transition.</p>
</dd>
<dt><code>timing</code></dt><dd><p>Numeric vector length one with the total elapsed seconds it took
<code><a href="#topic+evolve_model">evolve_model</a></code> to execute.</p>
</dd>
<dt><code>diagnostics</code></dt><dd><p>Character vector length one, to be printed with base::cat().</p>
</dd>
</dl>

<hr>
<h2 id='NV_games'>Empirical prisoner's dilemma games from Nay and Vorobeychik</h2><span id='topic+NV_games'></span>

<h3>Description</h3>

<p>A dataset containing 168,386 total rounds of play in 30 different
variations on the iterated prisoner's dilemma games.
The data comes from J.J. Nay and Y. Vorobeychik, &quot;Predicting Human
Cooperation,&quot; PLOS ONE 11(5), e0155656 (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NV_games
</code></pre>


<h3>Format</h3>

<p>A data frame with 168,386 rows and 51 variables:
</p>

<dl>
<dt>period</dt><dd><p>Which turn of the given game</p>
</dd>
<dt>my.decision</dt><dd><p>The player's move in this turn</p>
</dd>
<dt>risk</dt><dd><p>Boolean variable: 1 indicates stochastic payoffs, 0
deterministic payoffs</p>
</dd>
<dt>delta</dt><dd><p>Probability the game ends after each round</p>
</dd>
<dt>r1</dt><dd><p>Normalized difference in payoff between both players cooperating
and both defecting</p>
</dd>
<dt>r2</dt><dd><p>Normalized difference in payoff between both players cooperating
and the payoff for being a sucker (cooperating when the opponent
defects)</p>
</dd>
<dt>error</dt><dd><p>Probability that the player's intended move is switched to
the opposite move</p>
</dd>
<dt>data</dt><dd><p>Which dataset did this game come from:
AM = Andreoni &amp; Miller;
BR = Bereby-Meyer &amp; Roth;
DB = Dal Bo;
DF = Dal Bo &amp; Frechette;
DO = Duffy &amp; Ochs;
FO = Friedman &amp; Oprea;
FR = Fudenberg, Rand, &amp; Dreber;
and KS = Kunreuther, Silvasi, Bradlow &amp; Small</p>
</dd>
<dt>my.decision1</dt><dd><p>The player's move in the previous turn</p>
</dd>
<dt>my.decision2</dt><dd><p>The player's move two turns ago</p>
</dd>
<dt>my.decision3</dt><dd><p>The player's move three turns ago</p>
</dd>
<dt>my.decision4</dt><dd><p>The player's move four turns ago</p>
</dd>
<dt>my.decision5</dt><dd><p>The player's move five turns ago</p>
</dd>
<dt>my.decision6</dt><dd><p>The player's move six turns ago</p>
</dd>
<dt>my.decision7</dt><dd><p>The player's move seven turns ago</p>
</dd>
<dt>my.decision8</dt><dd><p>The player's move eight turns ago</p>
</dd>
<dt>my.decision9</dt><dd><p>The player's move nine turns ago</p>
</dd>
<dt>other.decision1</dt><dd><p>The opponent's move in the previous turn</p>
</dd>
<dt>other.decision2</dt><dd><p>The opponent's move two turns ago</p>
</dd>
<dt>other.decision3</dt><dd><p>The opponent's move three turns ago</p>
</dd>
<dt>other.decision4</dt><dd><p>The opponent's move four turns ago</p>
</dd>
<dt>other.decision5</dt><dd><p>The opponent's move five turns ago</p>
</dd>
<dt>other.decision6</dt><dd><p>The opponent's move six turns ago</p>
</dd>
<dt>other.decision7</dt><dd><p>The opponent's move seven turns ago</p>
</dd>
<dt>other.decision8</dt><dd><p>The opponent's move eight turns ago</p>
</dd>
<dt>other.decision9</dt><dd><p>The opponent's move nine turns ago</p>
</dd>
<dt>my.payoff1</dt><dd><p>The player's payoff in the previous turn</p>
</dd>
<dt>my.payoff2</dt><dd><p>The player's payoff two turns ago</p>
</dd>
<dt>my.payoff3</dt><dd><p>The player's payoff three turns ago</p>
</dd>
<dt>my.payoff4</dt><dd><p>The player's payoff four turns ago</p>
</dd>
<dt>my.payoff5</dt><dd><p>The player's payoff five turns ago</p>
</dd>
<dt>my.payoff6</dt><dd><p>The player's payoff six turns ago</p>
</dd>
<dt>my.payoff7</dt><dd><p>The player's payoff seven turns ago</p>
</dd>
<dt>my.payoff8</dt><dd><p>The player's payoff eight turns ago</p>
</dd>
<dt>my.payoff9</dt><dd><p>The player's payoff nine turns ago</p>
</dd>
<dt>other.payoff1</dt><dd><p>The opponent's payoff in the previous turn</p>
</dd>
<dt>other.payoff2</dt><dd><p>The opponent's payoff two turns ago</p>
</dd>
<dt>other.payoff3</dt><dd><p>The opponent's payoff three turns ago</p>
</dd>
<dt>other.payoff4</dt><dd><p>The opponent's payoff four turns ago</p>
</dd>
<dt>other.payoff5</dt><dd><p>The opponent's payoff five turns ago</p>
</dd>
<dt>other.payoff6</dt><dd><p>The opponent's payoff six turns ago</p>
</dd>
<dt>other.payoff7</dt><dd><p>The opponent's payoff seven turns ago</p>
</dd>
<dt>other.payoff8</dt><dd><p>The opponent's payoff eight turns ago</p>
</dd>
<dt>other.payoff9</dt><dd><p>The opponent's payoff nine turns ago</p>
</dd>
<dt>r</dt><dd><p>Reward: payoff when both players cooperate</p>
</dd>
<dt>t</dt><dd><p>Temptation: payoff when player defects and opponent cooperates</p>
</dd>
<dt>s</dt><dd><p>Sucker: Payoff when player cooperates and opponent defects</p>
</dd>
<dt>p</dt><dd><p>Punishment: payoff when both players defect</p>
</dd>
<dt>infin</dt><dd><p>Boolean: 1 indicates infinite game with probability delta of ending at each round; 0 indicates pre-determined number of rounds</p>
</dd>
<dt>contin</dt><dd><p>Boolean: 1 indicates the game is played in continuous time; 0 indicates discrete rounds</p>
</dd>
<dt>group</dt><dd><p>Which group (version of the game) is being played?</p>
</dd>
</dl>



<h3>Source</h3>

<p>doi: <a href="https://doi.org/10.1371/journal.pone.0155656">10.1371/journal.pone.0155656</a>
</p>

<hr>
<h2 id='performance'>Measure Model Performance</h2><span id='topic+performance'></span>

<h3>Description</h3>

<p><code>performance</code> measures difference between predictions and data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance(results, outcome, measure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performance_+3A_results">results</code></td>
<td>
<p>Numeric vector with predictions</p>
</td></tr>
<tr><td><code id="performance_+3A_outcome">outcome</code></td>
<td>
<p>Numeric vector same length as results with real data to compare to.</p>
</td></tr>
<tr><td><code id="performance_+3A_measure">measure</code></td>
<td>
<p>Optional length one character vector that is either:
&quot;accuracy&quot;, &quot;sens&quot;, &quot;spec&quot;, or &quot;ppv&quot;. This specifies what measure of
predictive performance to use for training and evaluating the model. The
default measure is <code>"accuracy"</code>. However, accuracy can be a problematic
measure when the classes are imbalanced in the samples, i.e. if a class the
model is trying to predict is very rare. Alternatives to accuracy are
available that illuminate different aspects of predictive power. Sensitivity
answers the question, &ldquo; given that a result is truly an event, what is the
probability that the model will predict an event?&rdquo; Specificity answers the
question, &ldquo;given that a result is truly not an event, what is the
probability that the model will predict a negative?&rdquo; Positive predictive
value answers, &ldquo;what is the percent of predicted positives that are
actually positive?&rdquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the function of the <strong>datafsm</strong> package used to measure the fsm model performance. It uses the caret package.
</p>


<h3>Value</h3>

<p>Returns a numeric vector length one.
</p>

<hr>
<h2 id='states'>Extracts number of states</h2><span id='topic+states'></span>

<h3>Description</h3>

<p>Extracts number of states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>states(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="states_+3A_x">x</code></td>
<td>
<p>S4 ga_fsm object</p>
</td></tr>
</table>

<hr>
<h2 id='var_imp'>Variable Importance Measure for A FSM Model</h2><span id='topic+var_imp'></span>

<h3>Description</h3>

<p><code>var_imp</code> calculates the importance of the covariates of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_imp(state_mat, action_vec, data, outcome, period, measure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_imp_+3A_state_mat">state_mat</code></td>
<td>
<p>Numeric matrix with rows as states and columns as
predictors.</p>
</td></tr>
<tr><td><code id="var_imp_+3A_action_vec">action_vec</code></td>
<td>
<p>Numeric vector indicating what action to take for each
state.</p>
</td></tr>
<tr><td><code id="var_imp_+3A_data">data</code></td>
<td>
<p>Data frame that has &quot;period&quot; and &quot;outcome&quot; columns and rest of
cols are predictors, ranging from one to three predictors. All of the (3-5
columns) should be named.</p>
</td></tr>
<tr><td><code id="var_imp_+3A_outcome">outcome</code></td>
<td>
<p>Numeric vector same length as the number of rows as data.</p>
</td></tr>
<tr><td><code id="var_imp_+3A_period">period</code></td>
<td>
<p>Numeric vector same length as the number of rows as data.</p>
</td></tr>
<tr><td><code id="var_imp_+3A_measure">measure</code></td>
<td>
<p>Optional length one character vector that is either:
&quot;accuracy&quot;, &quot;sens&quot;, &quot;spec&quot;, or &quot;ppv&quot;. This specifies what measure of
predictive performance to use for training and evaluating the model. The
default measure is <code>"accuracy"</code>. However, accuracy can be a problematic
measure when the classes are imbalanced in the samples, i.e. if a class the
model is trying to predict is very rare. Alternatives to accuracy are
available that illuminate different aspects of predictive power. Sensitivity
answers the question, &ldquo; given that a result is truly an event, what is the
probability that the model will predict an event?&rdquo; Specificity answers the
question, &ldquo;given that a result is truly not an event, what is the
probability that the model will predict a negative?&rdquo; Positive predictive
value answers, &ldquo;what is the percent of predicted positives that are
actually positive?&rdquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes the state matrix and action vector from an already evolved model and
the fitness function and data used to evolve the model (or this could be test
data), flips the values of each of the elements in the state matrix and
measures the change in fitness (prediction of data) relative to the original
model. Then these changes are summed across columns to provide the importance
of each of the columns of the state matrix.
</p>


<h3>Value</h3>

<p>Numeric vector the same length as the number of columns of the
provided state matrix (the number of predictors in the model) with relative
importance scores for each predictor.
</p>

<hr>
<h2 id='varImp'>Extracts slot of variable importances</h2><span id='topic+varImp'></span>

<h3>Description</h3>

<p>Extracts slot of variable importances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varImp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varImp_+3A_x">x</code></td>
<td>
<p>S4 ga_fsm object</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
