<!DOCTYPE html><html lang="en"><head><title>Help for package bqror</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bqror}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alcdf'><p>cdf of an asymmetric Laplace distribution</p></a></li>
<li><a href='#alcdfstd'><p>cdf of a standard asymmetric Laplace distribution</p></a></li>
<li><a href='#bqror'><p>Bayesian quantile regression for ordinal models</p></a></li>
<li><a href='#covEffectOR1'><p>Covariate effect in the OR1 model</p></a></li>
<li><a href='#covEffectOR2'><p>Covariate effect in the OR2 model</p></a></li>
<li><a href='#data25j3'><p>Simulated data from the OR2 model for <code class="reqn">p = 0.25</code> (i.e., 25th quantile)</p></a></li>
<li><a href='#data25j4'><p>Simulated data from the OR1 model for <code class="reqn">p = 0.25</code> (i.e., 25th quantile)</p></a></li>
<li><a href='#data50j3'><p>Simulated data from the OR2 model for <code class="reqn">p = 0.5</code> (i.e., 50th quantile)</p></a></li>
<li><a href='#data50j4'><p>Simulated data from the OR1 model for <code class="reqn">p = 0.5</code> (i.e., 50th quantile)</p></a></li>
<li><a href='#data75j3'><p>Simulated data from the OR2 model for <code class="reqn">p = 0.75</code> (i.e., 75th quantile)</p></a></li>
<li><a href='#data75j4'><p>Simulated data from the OR1 model for <code class="reqn">p = 0.75</code> (i.e., 75th quantile)</p></a></li>
<li><a href='#dicOR1'><p>Deviance Information Criterion in the OR1 model</p></a></li>
<li><a href='#dicOR2'><p>Deviance Information Criterion in the OR2 model</p></a></li>
<li><a href='#drawbetaOR1'><p>Samples <code class="reqn">\beta</code> in the OR1 model</p></a></li>
<li><a href='#drawbetaOR2'><p>Samples <code class="reqn">\beta</code> in the OR2 model</p></a></li>
<li><a href='#drawdeltaOR1'><p>Samples <code class="reqn">\delta</code> in the OR1 model</p></a></li>
<li><a href='#drawlatentOR1'><p>Samples latent variable z in the OR1 model</p></a></li>
<li><a href='#drawlatentOR2'><p>Samples latent variable z in the OR2 model</p></a></li>
<li><a href='#drawnuOR2'><p>Samples scale factor <code class="reqn">\nu</code> in the OR2 model</p></a></li>
<li><a href='#drawsigmaOR2'><p>Samples <code class="reqn">\sigma</code> in the OR2 model</p></a></li>
<li><a href='#drawwOR1'><p>Samples latent weight w in the OR1 model</p></a></li>
<li><a href='#Educational_Attainment'><p>Educational Attainment study based on data from the National Longitudinal Study of Youth (NLSY, 1979) survey.</p></a></li>
<li><a href='#ineffactorOR1'><p>Inefficiency factor in the OR1 model</p></a></li>
<li><a href='#ineffactorOR2'><p>Inefficiency factor in the OR2 model</p></a></li>
<li><a href='#logMargLikeOR1'><p>Marginal likelihood in the OR1 model</p></a></li>
<li><a href='#logMargLikeOR2'><p>Marginal likelihood in the OR2 model</p></a></li>
<li><a href='#Policy_Opinion'><p>Data contains public opinion on the proposal to raise federal income taxes for couples (individuals) earning more than $250,000 ($200,000) per year and a host of other covariates. The data is taken from the 2010-2012 American National Election Studies (ANES) on the Evaluation of Government and Society Study I (EGSS 1)</p></a></li>
<li><a href='#qrminfundtheorem'><p>Minimizes the negative of log-likelihood in the OR1 model</p></a></li>
<li><a href='#qrnegLogLikensumOR1'><p>Negative log-likelihood in the OR1 model</p></a></li>
<li><a href='#qrnegLogLikeOR2'><p>Negative sum of log-likelihood in the OR2 model</p></a></li>
<li><a href='#quantregOR1'><p>Bayesian quantile regression in the OR1 model</p></a></li>
<li><a href='#quantregOR2'><p>Bayesian quantile regression in the OR2 model</p></a></li>
<li><a href='#rndald'><p>Generates random numbers from an AL distribution</p></a></li>
<li><a href='#summary.bqrorOR1'><p>Extractor function for summary</p></a></li>
<li><a href='#summary.bqrorOR2'><p>Extractor function for summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Quantile Regression for Ordinal Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/prajual/bqror">https://github.com/prajual/bqror</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, pracma, GIGrvg, truncnorm, NPflow, invgamma, stats,
progress</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Prajual Maheshwari &lt;prajual1391@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Package provides functions for estimation and inference in Bayesian quantile regression with ordinal outcomes. An ordinal model with 3 or more outcomes (labeled OR1 model) is estimated by a combination of Gibbs sampling and Metropolis-Hastings (MH) algorithm. Whereas an ordinal model with exactly 3 outcomes (labeled OR2 model) is estimated using a Gibbs sampling algorithm. The summary output presents the posterior mean, posterior standard deviation, 95% credible intervals, and the inefficiency factors along with the two model comparison measures – logarithm of marginal likelihood and the deviance information criterion (DIC). The package also provides functions for computing the covariate effects and other functions that aids either the estimation or inference in quantile ordinal models.
    Rahman, M. A. (2016).“Bayesian Quantile Regression for Ordinal Models.” Bayesian Analysis, 11(1): 1-24 &lt;<a href="https://doi.org/10.1214%2F15-BA939">doi:10.1214/15-BA939</a>&gt;.
    Yu, K., and Moyeed, R. A. (2001). “Bayesian Quantile Regression.” Statistics and Probability Letters, 54(4): 437–447 &lt;<a href="https://doi.org/10.1016%2FS0167-7152%2801%2900124-9">doi:10.1016/S0167-7152(01)00124-9</a>&gt;.
    Koenker, R., and Bassett, G. (1978).“Regression Quantiles.” Econometrica, 46(1): 33-50 &lt;<a href="https://doi.org/10.2307%2F1913643">doi:10.2307/1913643</a>&gt;.
    Chib, S. (1995). “Marginal likelihood from the Gibbs output.” Journal of the American Statistical Association, 90(432):1313–1321, 1995. &lt;<a href="https://doi.org/10.1080%2F01621459.1995.10476635">doi:10.1080/01621459.1995.10476635</a>&gt;.
    Chib, S., and Jeliazkov, I. (2001). “Marginal likelihood from the Metropolis-Hastings output.” Journal of the American Statistical Association, 96(453):270–281, 2001. &lt;<a href="https://doi.org/10.1198%2F016214501750332848">doi:10.1198/016214501750332848</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-14 05:51:31 UTC; prajualmaheshwari</td>
</tr>
<tr>
<td>Author:</td>
<td>Mohammad Arshad Rahman Developer [aut],
  Prajual Maheshwari [cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-14 07:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='alcdf'>cdf of an asymmetric Laplace distribution</h2><span id='topic+alcdf'></span>

<h3>Description</h3>

<p>This function computes the cumulative distribution function (cdf) of
an asymmetric Laplace (AL) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alcdf(x, mu, sigma, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alcdf_+3A_x">x</code></td>
<td>
<p>scalar value.</p>
</td></tr>
<tr><td><code id="alcdf_+3A_mu">mu</code></td>
<td>
<p>location parameter of an AL distribution.</p>
</td></tr>
<tr><td><code id="alcdf_+3A_sigma">sigma</code></td>
<td>
<p>scale parameter of an AL distribution.</p>
</td></tr>
<tr><td><code id="alcdf_+3A_p">p</code></td>
<td>
<p>quantile or skewness parameter, p in (0,1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the cdf of
an AL distribution.
</p>
<p style="text-align: center;"><code class="reqn">CDF(x) = F(x) = P(X \le x)</code>
</p>
<p> where X is a
random variable that follows AL(<code class="reqn">\mu</code>, <code class="reqn">\sigma</code>, p)
</p>


<h3>Value</h3>

<p>Returns the cumulative probability value at
point '&quot;x&quot;'.
</p>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Yu, K., and Zhang, J. (2005). '&quot;A Three-Parameter Asymmetric Laplace Distribution.&quot;'
Communications in Statistics - Theory and Methods, 34(9-10), 1867-1879. DOI: 10.1080/03610920500199018
</p>


<h3>See Also</h3>

<p>cumulative distribution function, asymmetric Laplace distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
x &lt;- -0.5428573
mu &lt;- 0.5
sigma &lt;- 1
p &lt;- 0.25
output &lt;- alcdf(x, mu, sigma, p)

# output
#   0.1143562

</code></pre>

<hr>
<h2 id='alcdfstd'>cdf of a standard asymmetric Laplace distribution</h2><span id='topic+alcdfstd'></span>

<h3>Description</h3>

<p>This function computes the cdf of a standard AL
distribution i.e. AL<code class="reqn">(0, 1 ,p)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alcdfstd(x, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alcdfstd_+3A_x">x</code></td>
<td>
<p>scalar value.</p>
</td></tr>
<tr><td><code id="alcdfstd_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the cdf of a standard AL distribution.
</p>
<p style="text-align: center;"><code class="reqn">cdf(x) = F(x) = P(X \le x)</code>
</p>
<p> where X is a
random variable that follows AL<code class="reqn">(0, 1 ,p)</code>.
</p>


<h3>Value</h3>

<p>Returns the cumulative probability value at point x for a standard
AL distribution.
</p>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Yu, K., and Zhang, J. (2005). '&quot;A Three-Parameter Asymmetric Laplace Distribution.&quot;'
Communications in Statistics - Theory and Methods, 34(9-10), 1867-1879. DOI: 10.1080/03610920500199018
</p>


<h3>See Also</h3>

<p>asymmetric Laplace distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
x &lt;-  -0.5428573
p &lt;- 0.25
output &lt;- alcdfstd(x, p)

# output
#   0.1663873

</code></pre>

<hr>
<h2 id='bqror'>Bayesian quantile regression for ordinal models</h2><span id='topic+bqror'></span>

<h3>Description</h3>

<p>Package provides functions for estimation and inference in Bayesian quantile regression with
ordinal outcomes. An ordinal model with 3 or more outcomes (labeled OR1 model) is estimated by
a combination of Gibbs sampling and Metropolis-Hastings (MH) algorithm. Whereas an ordinal model
with exactly 3 outcomes (labeled OR2 model) is estimated using a Gibbs sampling algorithm.
The summary output presents the posterior mean, posterior standard deviation, 95% credible
intervals, and the inefficiency factors along with the two model comparison measures logarithm of
marginal likelihood and the deviance information criterion (DIC). The package also provides
functions for computing the covariate effects and other functions that aids either the estimation
or inference in quantile ordinal models.
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">Package: bqror</code>
</p>

<p style="text-align: center;"><code class="reqn">Type: Package</code>
</p>

<p style="text-align: center;"><code class="reqn">Version: 1.7.0</code>
</p>

<p style="text-align: center;"><code class="reqn">License: GPL (&gt;=2)</code>
</p>

<p>Package <strong>bqror</strong> provides the following functions:
</p>

<ul>
<li><p>For an ordinal model with three or more outcomes:
</p>
</li></ul>

<p><code><a href="#topic+quantregOR1">quantregOR1</a></code>, <code><a href="#topic+covEffectOR1">covEffectOR1</a></code>,
<code><a href="#topic+logMargLikeOR1">logMargLikeOR1</a></code>, <code><a href="#topic+dicOR1">dicOR1</a></code>,
<code><a href="#topic+qrnegLogLikensumOR1">qrnegLogLikensumOR1</a></code>, <code><a href="#topic+ineffactorOR1">ineffactorOR1</a></code>,
<code><a href="#topic+qrminfundtheorem">qrminfundtheorem</a></code>, <code><a href="#topic+drawbetaOR1">drawbetaOR1</a></code>,
<code><a href="#topic+drawwOR1">drawwOR1</a></code>, <code><a href="#topic+drawlatentOR1">drawlatentOR1</a></code>,
<code><a href="#topic+drawdeltaOR1">drawdeltaOR1</a></code>, <code><a href="#topic+alcdfstd">alcdfstd</a></code>,
<code><a href="#topic+alcdf">alcdf</a></code>
</p>

<ul>
<li><p>For an ordinal model with three outcomes:
</p>
</li></ul>

<p><code><a href="#topic+quantregOR2">quantregOR2</a></code>, <code><a href="#topic+covEffectOR2">covEffectOR2</a></code>,
<code><a href="#topic+logMargLikeOR2">logMargLikeOR2</a></code>, <code><a href="#topic+dicOR2">dicOR2</a></code>,
<code><a href="#topic+qrnegLogLikeOR2">qrnegLogLikeOR2</a></code>, <code><a href="#topic+ineffactorOR2">ineffactorOR2</a></code>,
<code><a href="#topic+drawlatentOR2">drawlatentOR2</a></code>, <code><a href="#topic+drawbetaOR2">drawbetaOR2</a></code>,
<code><a href="#topic+drawsigmaOR2">drawsigmaOR2</a></code>, <code><a href="#topic+drawnuOR2">drawnuOR2</a></code>,
<code><a href="#topic+rndald">rndald</a></code>
</p>

<ul>
<li><p>Extractor Functions:
</p>
</li></ul>

<p><code><a href="#topic+summary.bqrorOR1">summary.bqrorOR1</a></code>, <code><a href="#topic+summary.bqrorOR2">summary.bqrorOR2</a></code>
</p>


<h3>Author(s)</h3>

<p>Mohammad Arshad Rahman
</p>
<p>Prajual Maheshwari &lt;prajual1391@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Yu, K., and Moyeed, R. A. (2001). '&quot;Bayesian Quantile Regression.&quot;' Statistics and
Probability Letters, 54(4): 437 - 447. DOI:10.1016/S0167-7152(01)00124-9
</p>
<p>Koenker, R., and Bassett, G. (1978).'&quot;Regression Quantiles.&quot;' Econometrica,
46(1): 33-50. DOI: 10.2307/1913643
</p>
<p>Greenberg, E. (2012). '&quot;Introduction to Bayesian Econometrics.&quot;'
Cambridge University Press. Cambridge, DOI: 10.1017/CBO9781139058414
</p>


<h3>See Also</h3>

<p><a href="GIGrvg.html#topic+rgig">rgig</a>, <a href="MASS.html#topic+mvrnorm">mvrnorm</a>, <a href="MASS.html#topic+ginv">ginv</a>,
<a href="truncnorm.html#topic+rtruncnorm">rtruncnorm</a>, <a href="NPflow.html#topic+mvnpdf">mvnpdf</a>,
<a href="invgamma.html#topic+rinvgamma">rinvgamma</a>, <a href="pracma.html#topic+mldivide">mldivide</a>,
<a href="pracma.html#topic+rand">rand</a>, <a href="stats.html#topic+qnorm">qnorm</a>,
<a href="stats.html#topic+rexp">rexp</a>, <a href="stats.html#topic+rnorm">rnorm</a>,
<a href="pracma.html#topic+std">std</a>, <a href="stats.html#topic+sd">sd</a>, <a href="stats.html#topic+acf">acf</a>,
<a href="pracma.html#topic+Reshape">Reshape</a>, <a href="progress.html#topic+progress_bar">progress_bar</a>,
<a href="invgamma.html#topic+dinvgamma">dinvgamma</a>, <a href="stats.html#topic+logLik">logLik</a>
</p>

<hr>
<h2 id='covEffectOR1'>Covariate effect in the OR1 model</h2><span id='topic+covEffectOR1'></span>

<h3>Description</h3>

<p>This function computes the average covariate effect for different
outcomes of the OR1 model at a specified quantile. The covariate
effects are calculated marginally of the parameters and the remaining covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covEffectOR1(modelOR1, y, xMat1, xMat2, p, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covEffectOR1_+3A_modelor1">modelOR1</code></td>
<td>
<p>output from the quantregOR1 function.</p>
</td></tr>
<tr><td><code id="covEffectOR1_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="covEffectOR1_+3A_xmat1">xMat1</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.
If the covariate of interest is continuous, then the column for the covariate of interest remains unchanged (xMat1 = x).
If it is an indicator variable then replace the column for the covariate of interest with a
column of zeros.</p>
</td></tr>
<tr><td><code id="covEffectOR1_+3A_xmat2">xMat2</code></td>
<td>
<p>covariate matrix x with suitable modification to an independent variable including a column of ones with
or without column names. If the covariate of interest is continuous, then add the incremental change
to each observation in the column for the covariate of interest. If the covariate is an indicator variable,
then replace the column for the covariate of interest with a column of ones.</p>
</td></tr>
<tr><td><code id="covEffectOR1_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
<tr><td><code id="covEffectOR1_+3A_verbose">verbose</code></td>
<td>
<p>whether to print the final output and provide additional information or not, default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the average covariate effect for different
outcomes of the OR1 model at a specified quantile. The covariate
effects are computed, using the MCMC draws, marginally of the parameters
and the remaining covariates.
</p>


<h3>Value</h3>

<p>Returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>avgDiffProb:</code></td>
<td>
<p>vector with change in predicted
probability for each outcome category.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Jeliazkov, I., Graves, J., and Kutzbach, M. (2008). '&quot;Fitting and Comparison of Models for Multivariate Ordinal Outcomes.&quot;'
Advances in Econometrics: Bayesian Econometrics, 23: 115'-'156. DOI: 10.1016/S0731-9053(08)23004-5
</p>
<p>Jeliazkov, I. and Rahman, M. A. (2012). '&quot;Binary and Ordinal Data Analysis in Economics: Modeling and Estimation&quot;'
in Mathematical Modeling with Multidisciplinary
Applications, edited by X.S. Yang, 123-150. John Wiley '&amp;' Sons Inc, Hoboken, New Jersey. DOI: 10.1002/9781118462706.ch6
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j4")
y &lt;- data25j4$y
xMat1 &lt;- data25j4$x
k &lt;- dim(xMat1)[2]
J &lt;- dim(as.array(unique(y)))[1]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
d0 &lt;- array(0, dim = c(J-2, 1))
D0 &lt;- 0.25*diag(J - 2)
modelOR1 &lt;- quantregOR1(y = y, x = xMat1, b0, B0, d0, D0,
burn = 10, mcmc = 40, p = 0.25, tune = 1, accutoff = 0.5, maxlags = 400, verbose = FALSE)
xMat2 &lt;- xMat1
xMat2[,3] &lt;- xMat2[,3] + 0.02
res &lt;- covEffectOR1(modelOR1, y, xMat1, xMat2, p = 0.25, verbose = TRUE)

# Summary of Covariate Effect:

#               Covariate Effect
# Category_1          -0.0072
# Category_2          -0.0012
# Category_3          -0.0009
# Category_4           0.0093

</code></pre>

<hr>
<h2 id='covEffectOR2'>Covariate effect in the OR2 model</h2><span id='topic+covEffectOR2'></span>

<h3>Description</h3>

<p>This function computes the average covariate effect for different
outcomes of the OR2 model at a specified quantile. The covariate
effects are calculated marginally of the parameters and the remaining covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covEffectOR2(modelOR2, y, xMat1, xMat2, gammacp2, p, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covEffectOR2_+3A_modelor2">modelOR2</code></td>
<td>
<p>output from the quantregOR2 function.</p>
</td></tr>
<tr><td><code id="covEffectOR2_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="covEffectOR2_+3A_xmat1">xMat1</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.
If the covariate of interest is continuous, then the column for the covariate of interest remains unchanged.
If it is an indicator variable then replace the column for the covariate of interest with a
column of zeros.</p>
</td></tr>
<tr><td><code id="covEffectOR2_+3A_xmat2">xMat2</code></td>
<td>
<p>covariate matrix x with suitable modification to an independent variable including a column of ones with
or without column names. If the covariate of interest is continuous, then add the incremental change
to each observation in the column for the covariate of interest. If the covariate is an indicator variable,
then replace the column for the covariate of interest with a column of ones.</p>
</td></tr>
<tr><td><code id="covEffectOR2_+3A_gammacp2">gammacp2</code></td>
<td>
<p>one and only cut-point other than 0.</p>
</td></tr>
<tr><td><code id="covEffectOR2_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
<tr><td><code id="covEffectOR2_+3A_verbose">verbose</code></td>
<td>
<p>whether to print the final output and provide additional information or not, default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the average covariate effect for different
outcomes of the OR2 model at a specified quantile. The covariate
effects are computed, using the Gibbs draws, marginally of the parameters
and the remaining covariates.
</p>


<h3>Value</h3>

<p>Returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>avgDiffProb:</code></td>
<td>
<p>vector with change in predicted
probability for each outcome category.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Jeliazkov, I., Graves, J., and Kutzbach, M. (2008). '&quot;Fitting and Comparison of Models for Multivariate Ordinal Outcomes.&quot;'
Advances in Econometrics: Bayesian Econometrics, 23: 115'-'156. DOI: 10.1016/S0731-9053(08)23004-5
</p>
<p>Jeliazkov, I., and Rahman, M. A. (2012). '&quot;Binary and Ordinal Data Analysis in Economics: Modeling and Estimation&quot;'
in Mathematical Modeling with Multidisciplinary
Applications, edited by X.S. Yang, 123-150. John Wiley '&amp;' Sons Inc, Hoboken, New Jersey. DOI: 10.1002/9781118462706.ch6
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j3")
y &lt;- data25j3$y
xMat1 &lt;- data25j3$x
k &lt;- dim(xMat1)[2]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
n0 &lt;- 5
d0 &lt;- 8
output &lt;- quantregOR2(y, xMat1, b0, B0, n0, d0, gammacp2 = 3,
burn = 10, mcmc = 40, p = 0.25, accutoff = 0.5, maxlags = 400, verbose = FALSE)
xMat2 &lt;- xMat1
xMat2[,3] &lt;- xMat2[,3] + 0.02
res &lt;- covEffectOR2(output, y, xMat1, xMat2, gammacp2 = 3, p = 0.25, verbose = TRUE)

# Summary of Covariate Effect:

#               Covariate Effect
# Category_1          -0.0073
# Category_2          -0.0030
# Category_3           0.0103

</code></pre>

<hr>
<h2 id='data25j3'>Simulated data from the OR2 model for <code class="reqn">p = 0.25</code> (i.e., 25th quantile)</h2><span id='topic+data25j3'></span>

<h3>Description</h3>

<p>Simulated data from the OR2 model for <code class="reqn">p = 0.25</code> (i.e., 25th quantile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data25j3)
</code></pre>


<h3>Details</h3>

<p>This data contains 500 observations generated from a quantile
ordinal model with 3 outcomes at the 25th quantile (i.e., <code class="reqn">p = 0.25</code>).
The model specifics for generating the data are as follows: <code class="reqn">\beta = (-4, 6, 5)</code>, X ~ Unif(0, 1), and
<code class="reqn">\epsilon</code> ~ AL(<code class="reqn">0, \sigma = 1, p = 0.25</code>). The cut-points <code class="reqn">(0, 3)</code> are used to classify the
continuous values of the dependent variable into 3 categories, which form the ordinal outcomes.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>x:</code></td>
<td>
<p>a matrix of covariates, including a column of ones.</p>
</td></tr>
<tr><td><code>y:</code></td>
<td>
<p>a column vector of ordinal outcomes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Yu, K., and Zhang, J. (2005). '&quot;A Three-Parameter Asymmetric Laplace Distribution.&quot;'
Communications in Statistics - Theory and Methods, 34(9-10), 1867-1879. DOI: 10.1080/03610920500199018
</p>


<h3>See Also</h3>

<p><a href="MASS.html#topic+mvrnorm">mvrnorm</a>, Asymmetric Laplace Distribution
</p>

<hr>
<h2 id='data25j4'>Simulated data from the OR1 model for <code class="reqn">p = 0.25</code> (i.e., 25th quantile)</h2><span id='topic+data25j4'></span>

<h3>Description</h3>

<p>Simulated data from the OR1 model for <code class="reqn">p = 0.25</code> (i.e., 25th quantile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data25j4)
</code></pre>


<h3>Details</h3>

<p>This data contains 500 observations generated from a quantile
ordinal model with 4 outcomes at the 25th quantile (i.e., <code class="reqn">p = 0.25</code>).
The model specifics for generating the data are as follows: <code class="reqn">\beta = (-4, 5, 6)</code>, X ~ Unif(0, 1), and
<code class="reqn">\epsilon</code> ~ AL(<code class="reqn">0, \sigma = 1, p = 0.25</code>). The cut-points <code class="reqn">(0, 2, 4)</code> are used to classify the
continuous values of the dependent variable into 4 categories, which form the ordinal outcomes.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>x:</code></td>
<td>
<p>a matrix of covariates, including a column of ones.</p>
</td></tr>
<tr><td><code>y:</code></td>
<td>
<p>a column vector of ordinal outcomes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Yu, K., and Zhang, J. (2005). '&quot;A Three-Parameter Asymmetric Laplace Distribution.&quot;'
Communications in Statistics - Theory and Methods, 34(9-10), 1867-1879. DOI: 10.1080/03610920500199018
</p>


<h3>See Also</h3>

<p><a href="MASS.html#topic+mvrnorm">mvrnorm</a>, Asymmetric Laplace Distribution
</p>

<hr>
<h2 id='data50j3'>Simulated data from the OR2 model for <code class="reqn">p = 0.5</code> (i.e., 50th quantile)</h2><span id='topic+data50j3'></span>

<h3>Description</h3>

<p>Simulated data from the OR2 model for <code class="reqn">p = 0.5</code> (i.e., 50th quantile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data50j3)
</code></pre>


<h3>Details</h3>

<p>This data contains 500 observations generated from a quantile
ordinal model with 3 outcomes at the 50th quantile (i.e., <code class="reqn">p = 0.5</code>).
The model specifics for generating the data are as follows: <code class="reqn">\beta = (-4, 6, 5)</code>, X ~ Unif(0, 1), and
<code class="reqn">\epsilon</code> ~ AL(<code class="reqn">0, \sigma = 1, p = 0.5</code>). The cut-points <code class="reqn">(0, 3)</code> are used to classify the
continuous values of the dependent variable into 3 categories, which form the ordinal outcomes.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>x:</code></td>
<td>
<p>a matrix of covariates, including a column of ones.</p>
</td></tr>
<tr><td><code>y:</code></td>
<td>
<p>a column vector of ordinal outcomes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Yu, K., and Zhang, J. (2005). '&quot;A Three-Parameter Asymmetric Laplace Distribution.&quot;'
Communications in Statistics - Theory and Methods, 34(9-10), 1867-1879. DOI: 10.1080/03610920500199018
</p>


<h3>See Also</h3>

<p><a href="MASS.html#topic+mvrnorm">mvrnorm</a>, Asymmetric Laplace Distribution
</p>

<hr>
<h2 id='data50j4'>Simulated data from the OR1 model for <code class="reqn">p = 0.5</code> (i.e., 50th quantile)</h2><span id='topic+data50j4'></span>

<h3>Description</h3>

<p>Simulated data from the OR1 model for <code class="reqn">p = 0.5</code> (i.e., 50th quantile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data50j4)
</code></pre>


<h3>Details</h3>

<p>This data contains 500 observations generated from a quantile
ordinal model with 4 outcomes at the 50th quantile (i.e., <code class="reqn">p = 0.5</code>).
The model specifics for generating the data are as follows: <code class="reqn">\beta = (-4, 5, 6)</code>, X ~ Unif(0, 1), and
<code class="reqn">\epsilon</code> ~ AL(<code class="reqn">0, \sigma = 1, p = 0.5</code>). The cut-points <code class="reqn">(0, 2, 4)</code> are used to classify the
continuous values of the dependent variable into 4 categories, which form the ordinal outcomes.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>x:</code></td>
<td>
<p>a matrix of covariates, including a column of ones.</p>
</td></tr>
<tr><td><code>y:</code></td>
<td>
<p>a column vector of ordinal outcomes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Yu, K., and Zhang, J. (2005). '&quot;A Three-Parameter Asymmetric Laplace Distribution.&quot;'
Communications in Statistics - Theory and Methods, 34(9-10), 1867-1879. DOI: 10.1080/03610920500199018
</p>


<h3>See Also</h3>

<p><a href="MASS.html#topic+mvrnorm">mvrnorm</a>, Asymmetric Laplace Distribution
</p>

<hr>
<h2 id='data75j3'>Simulated data from the OR2 model for <code class="reqn">p = 0.75</code> (i.e., 75th quantile)</h2><span id='topic+data75j3'></span>

<h3>Description</h3>

<p>Simulated data from the OR2 model for <code class="reqn">p = 0.75</code> (i.e., 75th quantile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data75j3)
</code></pre>


<h3>Details</h3>

<p>This data contains 500 observations generated from a quantile
ordinal model with 3 outcomes at the 75th quantile (i.e., <code class="reqn">p = 0.75</code>).
The model specifics for generating the data are as follows: <code class="reqn">\beta = (-4, 6, 5)</code>, X ~ Unif(0, 1), and
<code class="reqn">\epsilon</code> ~ AL(<code class="reqn">0, \sigma = 1, p = 0.75</code>). The cut-points <code class="reqn">(0, 3)</code> are used to classify the
continuous values of the dependent variable into 3 categories, which form the ordinal outcomes.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>x:</code></td>
<td>
<p>a matrix of covariates, including a column of ones.</p>
</td></tr>
<tr><td><code>y:</code></td>
<td>
<p>a column vector of ordinal outcomes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Yu, K., and Zhang, J. (2005). '&quot;A Three-Parameter Asymmetric Laplace Distribution.&quot;'
Communications in Statistics - Theory and Methods, 34(9-10), 1867-1879. DOI: 10.1080/03610920500199018
</p>


<h3>See Also</h3>

<p><a href="MASS.html#topic+mvrnorm">mvrnorm</a>, Asymmetric Laplace Distribution
</p>

<hr>
<h2 id='data75j4'>Simulated data from the OR1 model for <code class="reqn">p = 0.75</code> (i.e., 75th quantile)</h2><span id='topic+data75j4'></span>

<h3>Description</h3>

<p>Simulated data from the OR1 model for <code class="reqn">p = 0.75</code> (i.e., 75th quantile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data75j4)
</code></pre>


<h3>Details</h3>

<p>This data contains 500 observations generated from a quantile
ordinal model with 4 outcomes at the 75th quantile (i.e., <code class="reqn">p = 0.75</code>).
The model specifics for generating the data are as follows: <code class="reqn">\beta = (-4, 5, 6)</code>, X ~ Unif(0, 1), and
<code class="reqn">\epsilon</code> ~ AL(<code class="reqn">0, \sigma = 1, p = 0.75</code>). The cut-points <code class="reqn">(0, 2, 4)</code> are used to classify the
continuous values of the dependent variable into 4 categories, which form the ordinal outcomes.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>x:</code></td>
<td>
<p>a matrix of covariates, including a column of ones.</p>
</td></tr>
<tr><td><code>y:</code></td>
<td>
<p>a column vector of ordinal outcomes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Yu, K., and Zhang, J. (2005). '&quot;A Three-Parameter Asymmetric Laplace Distribution.&quot;'
Communications in Statistics - Theory and Methods, 34(9-10), 1867-1879. DOI: 10.1080/03610920500199018
</p>


<h3>See Also</h3>

<p><a href="MASS.html#topic+mvrnorm">mvrnorm</a>, Asymmetric Laplace Distribution
</p>

<hr>
<h2 id='dicOR1'>Deviance Information Criterion in the OR1 model</h2><span id='topic+dicOR1'></span>

<h3>Description</h3>

<p>Function for computing the Deviance Information Criterion (DIC) in the OR1 model (ordinal quantile
model with 3 or more outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicOR1(y, x, betadraws, deltadraws, postMeanbeta, postMeandelta, burn, mcmc, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dicOR1_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="dicOR1_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="dicOR1_+3A_betadraws">betadraws</code></td>
<td>
<p>dataframe of the MCMC draws of <code class="reqn">\beta</code>, size is <code class="reqn">(k x nsim)</code>.</p>
</td></tr>
<tr><td><code id="dicOR1_+3A_deltadraws">deltadraws</code></td>
<td>
<p>dataframe of the MCMC draws of <code class="reqn">\delta</code>, size is <code class="reqn">((J-2) x nsim)</code>.</p>
</td></tr>
<tr><td><code id="dicOR1_+3A_postmeanbeta">postMeanbeta</code></td>
<td>
<p>posterior mean of the MCMC draws of <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="dicOR1_+3A_postmeandelta">postMeandelta</code></td>
<td>
<p>posterior mean of the MCMC draws of <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="dicOR1_+3A_burn">burn</code></td>
<td>
<p>number of burn-in MCMC iterations.</p>
</td></tr>
<tr><td><code id="dicOR1_+3A_mcmc">mcmc</code></td>
<td>
<p>number of MCMC iterations, post burn-in.</p>
</td></tr>
<tr><td><code id="dicOR1_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deviance is -2*(log likelihood) and has an important role in
statistical model comparison because of its relation with Kullback-Leibler
information criterion.
</p>
<p>This function provides the DIC, which can be used to compare two or more models at the
same quantile. The model with a lower DIC provides a better fit.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<p style="text-align: center;"><code class="reqn">DIC = 2*avgdDeviance - dev</code>
</p>

<p style="text-align: center;"><code class="reqn">pd = avgdDeviance - dev</code>
</p>

<p style="text-align: center;"><code class="reqn">dev = -2*(logLikelihood)</code>
</p>
<p>.
</p>


<h3>References</h3>

<p>Spiegelhalter, D. J., Best, N. G., Carlin, B. P. and Linde, A. (2002).
'&quot;Bayesian Measures of Model Complexity and Fit.&quot;' Journal of the
Royal Statistical Society B, Part 4: 583-639. DOI: 10.1111/1467-9868.00353
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., and Rubin, D. B.
'&quot;Bayesian Data Analysis.&quot;' 2nd Edition, Chapman and Hall. DOI: 10.1002/sim.1856
</p>


<h3>See Also</h3>

<p>decision criteria
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j4")
y &lt;- data25j4$y
xMat &lt;- data25j4$x
k &lt;- dim(xMat)[2]
J &lt;- dim(as.array(unique(y)))[1]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
d0 &lt;- array(0, dim = c(J-2, 1))
D0 &lt;- 0.25*diag(J - 2)
output &lt;- quantregOR1(y = y, x = xMat, b0, B0, d0, D0,
burn = 10, mcmc = 40, p = 0.25, tune = 1, accutoff = 0.5, maxlags = 400, verbose = FALSE)
mcmc &lt;- 40
deltadraws &lt;- output$deltadraws
betadraws &lt;- output$betadraws
burn &lt;- 0.25*mcmc
nsim &lt;- burn + mcmc
postMeanbeta &lt;- output$postMeanbeta
postMeandelta &lt;- output$postMeandelta
dic &lt;- dicOR1(y, xMat, betadraws, deltadraws,
postMeanbeta, postMeandelta, burn, mcmc, p = 0.25)

# DIC
#   1375.329
# pd
#   139.1751
# dev
#   1096.979

</code></pre>

<hr>
<h2 id='dicOR2'>Deviance Information Criterion in the OR2 model</h2><span id='topic+dicOR2'></span>

<h3>Description</h3>

<p>Function for computing the DIC in the OR2 model (ordinal quantile
model with exactly 3 outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicOR2(y, x, betadraws, sigmadraws, gammacp, postMeanbeta,
postMeansigma, burn, mcmc, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dicOR2_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="dicOR2_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="dicOR2_+3A_betadraws">betadraws</code></td>
<td>
<p>dataframe of the MCMC draws of <code class="reqn">\beta</code>, size is <code class="reqn">(k x nsim)</code>.</p>
</td></tr>
<tr><td><code id="dicOR2_+3A_sigmadraws">sigmadraws</code></td>
<td>
<p>dataframe of the MCMC draws of <code class="reqn">\sigma</code>, size is <code class="reqn">(nsim x 1)</code>.</p>
</td></tr>
<tr><td><code id="dicOR2_+3A_gammacp">gammacp</code></td>
<td>
<p>row vector of cut-points including -Inf and Inf.</p>
</td></tr>
<tr><td><code id="dicOR2_+3A_postmeanbeta">postMeanbeta</code></td>
<td>
<p>posterior mean of the MCMC draws of <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="dicOR2_+3A_postmeansigma">postMeansigma</code></td>
<td>
<p>posterior mean of the MCMC draws of <code class="reqn">\sigma</code>.</p>
</td></tr>
<tr><td><code id="dicOR2_+3A_burn">burn</code></td>
<td>
<p>number of burn-in MCMC iterations.</p>
</td></tr>
<tr><td><code id="dicOR2_+3A_mcmc">mcmc</code></td>
<td>
<p>number of MCMC iterations, post burn-in.</p>
</td></tr>
<tr><td><code id="dicOR2_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deviance is -2*(log likelihood) and has an important role in
statistical model comparison because of its relation with Kullback-Leibler
information criterion.
</p>
<p>This function provides the DIC, which can be used to compare two or more models at the
same quantile. The model with a lower DIC provides a better fit.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<p style="text-align: center;"><code class="reqn">DIC = 2*avgdeviance - dev</code>
</p>

<p style="text-align: center;"><code class="reqn">pd = avgdeviance - dev</code>
</p>

<p style="text-align: center;"><code class="reqn">dev = -2*(logLikelihood)</code>
</p>
<p>.
</p>


<h3>References</h3>

<p>Spiegelhalter, D. J., Best, N. G., Carlin, B. P. and Linde, A. (2002).
'&quot;Bayesian Measures of Model Complexity and Fit.&quot;' Journal of the
Royal Statistical Society B, Part 4: 583-639. DOI: 10.1111/1467-9868.00353
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., and Rubin, D. B.
'&quot;Bayesian Data Analysis.&quot;' 2nd Edition, Chapman and Hall. DOI: 10.1002/sim.1856
</p>


<h3>See Also</h3>

<p>decision criteria
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j3")
y &lt;- data25j3$y
xMat &lt;- data25j3$x
k &lt;- dim(xMat)[2]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
n0 &lt;- 5
d0 &lt;- 8
output &lt;- quantregOR2(y = y, x = xMat, b0, B0, n0, d0, gammacp2 = 3,
burn = 10, mcmc = 40, p = 0.25, accutoff = 0.5, maxlags = 400, verbose = FALSE)
betadraws &lt;- output$betadraws
sigmadraws &lt;- output$sigmadraws
gammacp &lt;- c(-Inf, 0, 3, Inf)
postMeanbeta &lt;- output$postMeanbeta
postMeansigma &lt;- output$postMeansigma
mcmc = 40
burn &lt;- 10
nsim &lt;- burn + mcmc
dic &lt;- dicOR2(y, xMat, betadraws, sigmadraws, gammacp,
postMeanbeta, postMeansigma, burn, mcmc, p = 0.25)

# DIC
#   801.8191
# pd
#   6.608594
# dev
#   788.6019

</code></pre>

<hr>
<h2 id='drawbetaOR1'>Samples <code class="reqn">\beta</code> in the OR1 model</h2><span id='topic+drawbetaOR1'></span>

<h3>Description</h3>

<p>This function samples <code class="reqn">\beta</code> from its conditional
posterior distribution in the OR1 model (ordinal quantile model with 3 or more
outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawbetaOR1(z, x, w, tau2, theta, invB0, invB0b0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawbetaOR1_+3A_z">z</code></td>
<td>
<p>continuous latent values, vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawbetaOR1_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="drawbetaOR1_+3A_w">w</code></td>
<td>
<p>latent weights, column vector of size size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawbetaOR1_+3A_tau2">tau2</code></td>
<td>
<p>2/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawbetaOR1_+3A_theta">theta</code></td>
<td>
<p>(1-2p)/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawbetaOR1_+3A_invb0">invB0</code></td>
<td>
<p>inverse of prior covariance matrix of normal distribution.</p>
</td></tr>
<tr><td><code id="drawbetaOR1_+3A_invb0b0">invB0b0</code></td>
<td>
<p>prior mean pre-multiplied by invB0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples <code class="reqn">\beta</code>, a vector, from its conditional posterior distribution
which is an updated multivariate normal distribution.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>beta:</code></td>
<td>
<p><code class="reqn">\beta</code>, a column vector of size <code class="reqn">(k x 1)</code>, sampled from its
condtional posterior distribution.</p>
</td></tr>
<tr><td><code>Btilde:</code></td>
<td>
<p>variance parameter for the posterior multivariate normal
distribution.</p>
</td></tr>
<tr><td><code>btilde:</code></td>
<td>
<p>mean parameter for the
posterior multivariate normal distribution.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>


<h3>See Also</h3>

<p>Gibbs sampling, normal distribution,
<a href="MASS.html#topic+mvrnorm">mvrnorm</a>, <a href="pracma.html#topic+inv">inv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j4")
xMat &lt;- data25j4$x
p &lt;- 0.25
n &lt;- dim(xMat)[1]
k &lt;- dim(xMat)[2]
w &lt;- array( (abs(rnorm(n, mean = 2, sd = 1))), dim = c (n, 1))
theta &lt;- 2.666667
tau2 &lt;- 10.66667
z &lt;- array( (rnorm(n, mean = 0, sd = 1)), dim = c(n, 1))
b0 &lt;- array(0, dim = c(k, 1))
B0 &lt;- diag(k)
invB0 &lt;- matrix(c(
     1, 0, 0,
     0, 1, 0,
     0, 0, 1),
     nrow = 3, ncol = 3, byrow = TRUE)
invB0b0 &lt;- invB0 %*% b0
output &lt;- drawbetaOR1(z, xMat, w, tau2, theta, invB0, invB0b0)

# output$beta
#   -0.2481837 0.7837995 -3.4680418
</code></pre>

<hr>
<h2 id='drawbetaOR2'>Samples <code class="reqn">\beta</code> in the OR2 model</h2><span id='topic+drawbetaOR2'></span>

<h3>Description</h3>

<p>This function samples <code class="reqn">\beta</code> from its conditional
posterior distribution in the OR2 model (ordinal quantile model with exactly 3
outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawbetaOR2(z, x, sigma, nu, tau2, theta, invB0, invB0b0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawbetaOR2_+3A_z">z</code></td>
<td>
<p>continuous latent values, vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawbetaOR2_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="drawbetaOR2_+3A_sigma">sigma</code></td>
<td>
<p><code class="reqn">\sigma</code>, a scalar value.</p>
</td></tr>
<tr><td><code id="drawbetaOR2_+3A_nu">nu</code></td>
<td>
<p>modified latent weight, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawbetaOR2_+3A_tau2">tau2</code></td>
<td>
<p>2/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawbetaOR2_+3A_theta">theta</code></td>
<td>
<p>(1-2p)/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawbetaOR2_+3A_invb0">invB0</code></td>
<td>
<p>inverse of prior covariance matrix of normal distribution.</p>
</td></tr>
<tr><td><code id="drawbetaOR2_+3A_invb0b0">invB0b0</code></td>
<td>
<p>prior mean pre-multiplied by invB0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples <code class="reqn">\beta</code>, a vector, from its conditional posterior distribution
which is an updated multivariate normal distribution.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>beta:</code></td>
<td>
<p><code class="reqn">\beta</code>, a column vector of size <code class="reqn">(k x 1)</code>, sampled from its
condtional posterior distribution.</p>
</td></tr>
<tr><td><code>Btilde:</code></td>
<td>
<p>variance parameter for the posterior
multivariate normal distribution.</p>
</td></tr>
<tr><td><code>btilde:</code></td>
<td>
<p>mean parameter for the
posterior multivariate normal distribution.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>


<h3>See Also</h3>

<p>Gibbs sampling, normal distribution
, <a href="GIGrvg.html#topic+rgig">rgig</a>, <a href="pracma.html#topic+inv">inv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
z &lt;- c(21.01744, 33.54702, 33.09195, -3.677646,
 21.06553, 1.490476, 0.9618205, -6.743081, 21.02186, 0.6950479)
x &lt;- matrix(c(
     1, -0.3010490, 0.8012506,
     1,  1.2764036, 0.4658184,
     1,  0.6595495, 1.7563655,
     1, -1.5024607, -0.8251381,
     1, -0.9733585, 0.2980610,
     1, -0.2869895, -1.0130274,
     1,  0.3101613, -1.6260663,
     1, -0.7736152, -1.4987616,
     1,  0.9961420, 1.2965952,
     1, -1.1372480, 1.7537353),
     nrow = 10, ncol = 3, byrow = TRUE)
sigma &lt;- 1.809417
n &lt;- dim(x)[1]
nu &lt;- array(5 * rep(1,n), dim = c(n, 1))
tau2 &lt;- 10.6667
theta &lt;- 2.6667
invB0 &lt;- matrix(c(
     1, 0, 0,
     0, 1, 0,
     0, 0, 1),
     nrow = 3, ncol = 3, byrow = TRUE)
invB0b0 &lt;- c(0, 0, 0)

output &lt;- drawbetaOR2(z, x, sigma, nu, tau2, theta, invB0, invB0b0)

# output$beta
#   -0.74441 1.364846 0.7159231

</code></pre>

<hr>
<h2 id='drawdeltaOR1'>Samples <code class="reqn">\delta</code> in the OR1 model</h2><span id='topic+drawdeltaOR1'></span>

<h3>Description</h3>

<p>This function samples the cut-point vector <code class="reqn">\delta</code> using a
random-walk Metropolis-Hastings algorithm in the OR1 model (ordinal
quantile model with 3 or more outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawdeltaOR1(y, x, beta, delta0, d0, D0, tune, Dhat, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawdeltaOR1_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawdeltaOR1_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="drawdeltaOR1_+3A_beta">beta</code></td>
<td>
<p>Gibbs draw of <code class="reqn">\beta</code>, column vector of size <code class="reqn">(k x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawdeltaOR1_+3A_delta0">delta0</code></td>
<td>
<p>initial value for <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="drawdeltaOR1_+3A_d0">d0</code></td>
<td>
<p>prior mean for <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="drawdeltaOR1_+3A_d0">D0</code></td>
<td>
<p>prior covariance matrix for <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="drawdeltaOR1_+3A_tune">tune</code></td>
<td>
<p>tuning parameter to adjust MH acceptance rate.</p>
</td></tr>
<tr><td><code id="drawdeltaOR1_+3A_dhat">Dhat</code></td>
<td>
<p>negative inverse Hessian from maximization of log-likelihood.</p>
</td></tr>
<tr><td><code id="drawdeltaOR1_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples the cut-point vector <code class="reqn">\delta</code> using a random-walk Metropolis-Hastings algorithm.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>deltaReturn:</code></td>
<td>
<p><code class="reqn">\delta</code>, a column vector of size <code class="reqn">((J-2) x 1)</code>, sampled using MH algorithm.</p>
</td></tr>
<tr><td><code>accept:</code></td>
<td>
<p>indicator for acceptance of the proposed value of <code class="reqn">\delta</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Chib, S., and Greenberg, E. (1995). '&quot;Understanding the Metropolis-Hastings Algorithm.&quot;'
The American Statistician, 49(4): 327-335. DOI: 10.2307/2684568
</p>
<p>Jeliazkov, I., and Rahman, M. A. (2012). '&quot;Binary and Ordinal Data Analysis in Economics: Modeling and Estimation&quot;'
in Mathematical Modeling with Multidisciplinary
Applications, edited by X.S. Yang, 123-150. John Wiley &amp; Sons Inc, Hoboken, New Jersey. DOI: 10.1002/9781118462706.ch6
</p>


<h3>See Also</h3>

<p>NPflow, Gibbs sampling, <a href="NPflow.html#topic+mvnpdf">mvnpdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j4")
y &lt;- data25j4$y
xMat &lt;- data25j4$x
p &lt;- 0.25
beta &lt;- c(0.3990094, 0.8168991, 2.8034963)
delta0 &lt;- c(-0.9026915, -2.2488833)
d0 &lt;- matrix(c(0, 0),
                 nrow = 2, ncol = 1, byrow = TRUE)
D0 &lt;- matrix(c(0.25, 0.00, 0.00, 0.25),
                    nrow = 2, ncol = 2, byrow = TRUE)
tune &lt;- 0.1
Dhat &lt;- matrix(c(0.046612180, -0.001954257, -0.001954257, 0.083066204),
             nrow = 2, ncol = 2, byrow = TRUE)
p &lt;- 0.25
output &lt;- drawdeltaOR1(y, xMat, beta, delta0, d0, D0, tune, Dhat, p)

# deltareturn
#   -0.9025802 -2.229514
# accept
#   1

</code></pre>

<hr>
<h2 id='drawlatentOR1'>Samples latent variable z in the OR1 model</h2><span id='topic+drawlatentOR1'></span>

<h3>Description</h3>

<p>This function samples the latent variable z from a univariate truncated
normal distribution in the OR1 model (ordinal quantile model with 3 or more outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawlatentOR1(y, x, beta, w, theta, tau2, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawlatentOR1_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawlatentOR1_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="drawlatentOR1_+3A_beta">beta</code></td>
<td>
<p>Gibbs draw of <code class="reqn">\beta</code>, a column vector of size <code class="reqn">(k x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawlatentOR1_+3A_w">w</code></td>
<td>
<p>latent weights, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawlatentOR1_+3A_theta">theta</code></td>
<td>
<p>(1-2p)/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawlatentOR1_+3A_tau2">tau2</code></td>
<td>
<p>2/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawlatentOR1_+3A_delta">delta</code></td>
<td>
<p>column vector of cutpoints including (-Inf, Inf).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples the latent variable z from a univariate truncated normal
distribution.
</p>


<h3>Value</h3>

<p>latent variable z of size <code class="reqn">(n x 1)</code> sampled from a univariate truncated distribution.
</p>


<h3>References</h3>

<p>Albert, J., and Chib, S. (1993). '&quot;Bayesian Analysis of Binary and Polychotomous Response Data.&quot;'
Journal of the American Statistical Association, 88(422): 669'-'679. DOI: 10.1080/01621459.1993.10476321
</p>
<p>Robert, C. P. (1995). '&quot;Simulation of truncated normal variables.&quot;' Statistics and
Computing, 5: 121'-'125. DOI: 10.1007/BF00143942
</p>


<h3>See Also</h3>

<p>Gibbs sampling, truncated normal distribution,
<a href="truncnorm.html#topic+rtruncnorm">rtruncnorm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j4")
y &lt;- data25j4$y
xMat &lt;- data25j4$x
p &lt;- 0.25
beta &lt;- c(0.3990094, 0.8168991, 2.8034963)
w &lt;- 1.114347
theta &lt;- 2.666667
tau2 &lt;- 10.66667
delta &lt;- c(-0.002570995,  1.044481071)
output &lt;- drawlatentOR1(y, xMat, beta, w, theta, tau2, delta)

# output
#   0.6261896 3.129285 2.659578 8.680291
#   13.22584 2.545938 1.507739 2.167358
#   15.03059 -3.963201 9.237466 -1.813652
#   2.718623 -3.515609 8.352259 -0.3880043
#   -0.8917078 12.81702 -0.2009296 1.069133 ... soon

</code></pre>

<hr>
<h2 id='drawlatentOR2'>Samples latent variable z in the OR2 model</h2><span id='topic+drawlatentOR2'></span>

<h3>Description</h3>

<p>This function samples the latent variable z from a univariate truncated
normal distribution in the OR2 model (ordinal quantile model with exactly 3 outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawlatentOR2(y, x, beta, sigma, nu, theta, tau2, gammacp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawlatentOR2_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawlatentOR2_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="drawlatentOR2_+3A_beta">beta</code></td>
<td>
<p>Gibbs draw of <code class="reqn">\beta</code>, a column vector of size <code class="reqn">(k x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawlatentOR2_+3A_sigma">sigma</code></td>
<td>
<p><code class="reqn">\sigma</code>, a scalar value.</p>
</td></tr>
<tr><td><code id="drawlatentOR2_+3A_nu">nu</code></td>
<td>
<p>modified latent weight, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawlatentOR2_+3A_theta">theta</code></td>
<td>
<p>(1-2p)/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawlatentOR2_+3A_tau2">tau2</code></td>
<td>
<p>2/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawlatentOR2_+3A_gammacp">gammacp</code></td>
<td>
<p>row vector of cut-points including -Inf and Inf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples the latent variable z from a univariate truncated normal
distribution.
</p>


<h3>Value</h3>

<p>latent variable z of size <code class="reqn">(n x 1)</code> from a univariate truncated distribution.
</p>


<h3>References</h3>

<p>Albert, J., and Chib, S. (1993). '&quot;Bayesian Analysis of Binary and Polychotomous Response Data.&quot;'
Journal of the American Statistical Association, 88(422): 669'-'679. DOI: 10.1080/01621459.1993.10476321
</p>
<p>Devroye, L. (2014). '&quot;Random variate generation for the generalized inverse Gaussian distribution.&quot;'
Statistics and Computing, 24(2): 239'-'246. DOI: 10.1007/s11222-012-9367-z
</p>


<h3>See Also</h3>

<p>Gibbs sampling, truncated normal distribution,
<a href="truncnorm.html#topic+rtruncnorm">rtruncnorm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j3")
y &lt;- data25j3$y
xMat &lt;- data25j3$x
beta &lt;- c(1.810504, 1.850332, 6.181163)
sigma &lt;- 0.9684741
n &lt;- dim(xMat)[1]
nu &lt;- array(5 * rep(1,n), dim = c(n, 1))
theta &lt;- 2.6667
tau2 &lt;- 10.6667
gammacp &lt;- c(-Inf, 0, 3, Inf)
output &lt;- drawlatentOR2(y, xMat, beta, sigma, nu,
theta, tau2, gammacp)

# output
#   1.257096 10.46297 4.138694
#   28.06432 4.179275 19.21582
#   11.17549 13.79059 28.3650 .. soon

</code></pre>

<hr>
<h2 id='drawnuOR2'>Samples scale factor <code class="reqn">\nu</code> in the OR2 model</h2><span id='topic+drawnuOR2'></span>

<h3>Description</h3>

<p>This function samples <code class="reqn">\nu</code> from a generalized inverse Gaussian (GIG)
distribution in the OR2 model (ordinal quantile model with exactly 3 outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawnuOR2(z, x, beta, sigma, tau2, theta, indexp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawnuOR2_+3A_z">z</code></td>
<td>
<p>Gibbs draw of continuous latent values, a column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawnuOR2_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones.</p>
</td></tr>
<tr><td><code id="drawnuOR2_+3A_beta">beta</code></td>
<td>
<p>Gibbs draw of <code class="reqn">\beta</code>, a column vector of size <code class="reqn">(k x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawnuOR2_+3A_sigma">sigma</code></td>
<td>
<p><code class="reqn">\sigma</code>, a scalar value.</p>
</td></tr>
<tr><td><code id="drawnuOR2_+3A_tau2">tau2</code></td>
<td>
<p>2/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawnuOR2_+3A_theta">theta</code></td>
<td>
<p>(1-2p)/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawnuOR2_+3A_indexp">indexp</code></td>
<td>
<p>index parameter of the GIG distribution which is equal to 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples <code class="reqn">\nu</code> from a GIG
distribution.
</p>


<h3>Value</h3>

<p><code class="reqn">\nu</code>, a column vector of size <code class="reqn">(n x 1)</code>, sampled from a GIG distribution.
</p>


<h3>References</h3>

<p>Rahman, M. A. (2016), '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1), 1-24. DOI: 10.1214/15-BA939
</p>
<p>Devroye, L. (2014). '&quot;Random variate generation for the generalized inverse Gaussian distribution.&quot;'
Statistics and Computing, 24(2): 239'-'246. DOI: 10.1007/s11222-012-9367-z
</p>


<h3>See Also</h3>

<p>GIGrvg, Gibbs sampling, <a href="GIGrvg.html#topic+rgig">rgig</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
z &lt;- c(21.01744, 33.54702, 33.09195, -3.677646,
 21.06553, 1.490476, 0.9618205, -6.743081, 21.02186, 0.6950479)
x &lt;- matrix(c(
     1, -0.3010490, 0.8012506,
     1,  1.2764036, 0.4658184,
     1,  0.6595495, 1.7563655,
     1, -1.5024607, -0.8251381,
     1, -0.9733585, 0.2980610,
     1, -0.2869895, -1.0130274,
     1,  0.3101613, -1.6260663,
     1, -0.7736152, -1.4987616,
     1, 0.9961420, 1.2965952,
     1, -1.1372480, 1.7537353),
     nrow = 10, ncol = 3, byrow = TRUE)
beta &lt;- c(-0.74441, 1.364846, 0.7159231)
sigma &lt;- 3.749524
tau2 &lt;- 10.6667
theta &lt;- 2.6667
indexp &lt;- 0.5
output &lt;- drawnuOR2(z, x, beta, sigma, tau2, theta, indexp)

# output
#   5.177456 4.042261 8.950365
#   1.578122 6.968687 1.031987
#   4.13306 0.4681557 5.109653
#   0.1725333

</code></pre>

<hr>
<h2 id='drawsigmaOR2'>Samples <code class="reqn">\sigma</code> in the OR2 model</h2><span id='topic+drawsigmaOR2'></span>

<h3>Description</h3>

<p>This function samples <code class="reqn">\sigma</code> from an inverse-gamma distribution
in the OR2 model (ordinal quantile model with exactly 3 outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawsigmaOR2(z, x, beta, nu, tau2, theta, n0, d0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawsigmaOR2_+3A_z">z</code></td>
<td>
<p>Gibbs draw of continuous latent values, a column vector of size <code class="reqn">n x 1</code>.</p>
</td></tr>
<tr><td><code id="drawsigmaOR2_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="drawsigmaOR2_+3A_beta">beta</code></td>
<td>
<p>Gibbs draw of <code class="reqn">\beta</code>, a column vector of size <code class="reqn">(k x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawsigmaOR2_+3A_nu">nu</code></td>
<td>
<p>modified latent weight, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawsigmaOR2_+3A_tau2">tau2</code></td>
<td>
<p>2/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawsigmaOR2_+3A_theta">theta</code></td>
<td>
<p>(1-2p)/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawsigmaOR2_+3A_n0">n0</code></td>
<td>
<p>prior hyper-parameter for <code class="reqn">\sigma</code>.</p>
</td></tr>
<tr><td><code id="drawsigmaOR2_+3A_d0">d0</code></td>
<td>
<p>prior hyper-parameter for <code class="reqn">\sigma</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples <code class="reqn">\sigma</code> from an inverse-gamma distribution.
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>sigma:</code></td>
<td>
<p><code class="reqn">\sigma</code>, a scalar, sampled
from an inverse gamma distribution.</p>
</td></tr>
<tr><td><code>dtilde:</code></td>
<td>
<p>scale parameter of the inverse-gamma distribution.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24.  DOI: 10.1214/15-BA939
</p>
<p>Devroye, L. (2014). '&quot;Random variate generation for the generalized inverse Gaussian distribution.&quot;'
Statistics and Computing, 24(2): 239'-'246. DOI: 10.1007/s11222-012-9367-z
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+rgamma">rgamma</a>, Gibbs sampling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
z &lt;- c(21.01744, 33.54702, 33.09195, -3.677646,
 21.06553, 1.490476, 0.9618205, -6.743081, 21.02186, 0.6950479)
x &lt;- matrix(c(
     1, -0.3010490, 0.8012506,
     1,  1.2764036, 0.4658184,
     1,  0.6595495, 1.7563655,
     1, -1.5024607, -0.8251381,
     1, -0.9733585, 0.2980610,
     1, -0.2869895, -1.0130274,
     1,  0.3101613, -1.6260663,
     1, -0.7736152, -1.4987616,
     1,  0.9961420, 1.2965952,
     1, -1.1372480, 1.7537353),
     nrow = 10, ncol = 3, byrow = TRUE)
beta &lt;- c(-0.74441, 1.364846, 0.7159231)
n &lt;- dim(x)[1]
nu &lt;- array(5 * rep(1,n), dim = c(n, 1))
tau2 &lt;- 10.6667
theta &lt;- 2.6667
n0 &lt;- 5
d0 &lt;- 8
output &lt;- drawsigmaOR2(z, x, beta, nu, tau2, theta, n0, d0)

# output$sigma
#   3.749524

</code></pre>

<hr>
<h2 id='drawwOR1'>Samples latent weight w in the OR1 model</h2><span id='topic+drawwOR1'></span>

<h3>Description</h3>

<p>This function samples latent weight w from a generalized
inverse-Gaussian distribution (GIG) in the OR1 model (ordinal quantile model with 3 or more
outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawwOR1(z, x, beta, tau2, theta, indexp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawwOR1_+3A_z">z</code></td>
<td>
<p>continuous latent values, vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawwOR1_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="drawwOR1_+3A_beta">beta</code></td>
<td>
<p>Gibbs draw of <code class="reqn">\beta</code>, a column vector of size <code class="reqn">(k x 1)</code>.</p>
</td></tr>
<tr><td><code id="drawwOR1_+3A_tau2">tau2</code></td>
<td>
<p>2/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawwOR1_+3A_theta">theta</code></td>
<td>
<p>(1-2p)/(p(1-p)).</p>
</td></tr>
<tr><td><code id="drawwOR1_+3A_indexp">indexp</code></td>
<td>
<p>index parameter of GIG distribution which is equal to 0.5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples a vector of latent weight w from a GIG distribution.
</p>


<h3>Value</h3>

<p>w, a column vector of size <code class="reqn">(n x 1)</code>, sampled from a GIG distribution.
</p>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24.  DOI: 10.1214/15-BA939
</p>
<p>Devroye, L. (2014). '&quot;Random variate generation for the generalized inverse Gaussian distribution.&quot;'
Statistics and Computing, 24(2): 239'-'246. DOI: 10.1007/s11222-012-9367-z
</p>


<h3>See Also</h3>

<p>GIGrvg, Gibbs sampling, <a href="GIGrvg.html#topic+rgig">rgig</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
z &lt;- c(0.9812363, -1.09788, -0.9650175, 8.396556,
 1.39465, -0.8711435, -0.5836833, -2.792464,
 0.1540086, -2.590724, 0.06169976, -1.823058,
 0.06559151, 0.1612763, 0.161311, 4.908488,
 0.6512113, 0.1560708, -0.883636, -0.5531435)
x &lt;- matrix(c(
     1, 1.4747905363, 0.167095186,
     1, -0.3817326861, 0.041879526,
     1, -0.1723095575, -1.414863777,
     1, 0.8266428137, 0.399722073,
     1, 0.0514888733, -0.105132425,
     1, -0.3159992662, -0.902003846,
     1, -0.4490888878, -0.070475600,
     1, -0.3671705251, -0.633396477,
     1, 1.7655601639, -0.702621934,
     1, -2.4543678120, -0.524068780,
     1,  0.3625025618,  0.698377504,
     1, -1.0339179063,  0.155746376,
     1,  1.2927374692, -0.155186911,
     1, -0.9125108094, -0.030513775,
     1,  0.8761233001,  0.988171587,
     1,  1.7379728231,  1.180760114,
     1,  0.7820635770, -0.338141095,
     1, -1.0212853209, -0.113765067,
     1,  0.6311364051, -0.061883874,
     1,  0.6756039688,  0.664490143),
     nrow = 20, ncol = 3, byrow = TRUE)
beta &lt;- c(-1.583533, 1.407158, 2.259338)
tau2 &lt;- 10.66667
theta &lt;- 2.666667
indexp &lt;- 0.5
output &lt;- drawwOR1(z, x, beta, tau2, theta, indexp)

# output
#   0.16135732
#   0.39333080
#   0.80187227
#   2.27442898
#   0.90358310
#   0.99886987
#   0.41515947 ... soon

</code></pre>

<hr>
<h2 id='Educational_Attainment'>Educational Attainment study based on data from the National Longitudinal Study of Youth (NLSY, 1979) survey.</h2><span id='topic+Educational_Attainment'></span>

<h3>Description</h3>

<p>Educational Attainment study based on data from the National Longitudinal Study of Youth (NLSY, 1979) survey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Educational_Attainment)
</code></pre>


<h3>Details</h3>

<p>This data is taken from the National Longitudinal Study of Youth (NLSY, 1979)
survey and corresponds to 3,923 individuals. The objective is to study the
effect of family background, individual, and school level variables on the
quantiles of educational attainment conditional on the covariates. The dependent variable
i.e. the educational degree, has four categories given as less than high school, high school degree,
some college or associate's degree, and college or graduate degree. The independent
variables include intercept, square root of family income, mother's education,
father's education, mother's working status, gender, race, and whether the youth
lived in an urban area at the age of 14, and indicator variables to control for age-cohort
effects.
</p>


<h3>Value</h3>

<p>Returns data with components
</p>
<table role = "presentation">
<tr><td><code>mother_work:</code></td>
<td>
<p>Indicator for working female at the age of 14.</p>
</td></tr>
<tr><td><code>urban:</code></td>
<td>
<p>Indicator for the youth living in urban area at the age of 14.</p>
</td></tr>
<tr><td><code>south:</code></td>
<td>
<p>Indicator for the youth living in South at the age of 14.</p>
</td></tr>
<tr><td><code>father_educ:</code></td>
<td>
<p>Number of years of father's education.</p>
</td></tr>
<tr><td><code>mother_educ:</code></td>
<td>
<p>Number of years of mother's education.</p>
</td></tr>
<tr><td><code>fam_income:</code></td>
<td>
<p>Family income of the household in $1000.</p>
</td></tr>
<tr><td><code>female:</code></td>
<td>
<p>Indicator for individual's gender.</p>
</td></tr>
<tr><td><code>black:</code></td>
<td>
<p>Indicator for black race.</p>
</td></tr>
<tr><td><code>age_cohort_2:</code></td>
<td>
<p>Indicator variable for age 15.</p>
</td></tr>
<tr><td><code>age_cohort_3:</code></td>
<td>
<p>Indicator variable for age 16.</p>
</td></tr>
<tr><td><code>age_cohort_4:</code></td>
<td>
<p>Indicator variable for age 17.</p>
</td></tr>
<tr><td><code>dep_edu_level:</code></td>
<td>
<p>Four categories of educational attainment: less than high school, high school degree,
some college or associate's degree, and college or graduate degree.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>
<p>Jeliazkov, I., Graves, J., and Kutzbach, M. (2008). '&quot;Fitting and Comparison of Models for Multivariate Ordinal Outcomes.&quot;'
Advances in Econometrics: Bayesian Econometrics, 23: 115'-'156. DOI: 10.1016/S0731-9053(08)23004-5
</p>
<p>Jeliazkov, I., and Rahman, M. A. (2012). '&quot;Binary and Ordinal Data Analysis in Economics: Modeling and Estimation&quot;'
in Mathematical Modeling with Multidisciplinary Applications, edited by X.S. Yang,
123-150. John Wiley '&amp;' Sons Inc, Hoboken, New Jersey. DOI: 10.1002/9781118462706.ch6
</p>


<h3>See Also</h3>

<p><a href="https://www.bls.gov/nls/nlsy97.htm">Survey Process</a>.
</p>

<hr>
<h2 id='ineffactorOR1'>Inefficiency factor in the OR1 model</h2><span id='topic+ineffactorOR1'></span>

<h3>Description</h3>

<p>This function calculates the inefficiency factor from the MCMC draws
of <code class="reqn">(\beta, \delta)</code> in the OR1 model (ordinal quantile model with 3 or more outcomes). The
inefficiency factor is calculated using the batch-means method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ineffactorOR1(x, betadraws, deltadraws, accutoff, maxlags, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ineffactorOR1_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.
This input is used to extract column names, if available, but not used in calculation.</p>
</td></tr>
<tr><td><code id="ineffactorOR1_+3A_betadraws">betadraws</code></td>
<td>
<p>dataframe of the MCMC draws of <code class="reqn">\beta</code>, size <code class="reqn">(k x nsim)</code>.</p>
</td></tr>
<tr><td><code id="ineffactorOR1_+3A_deltadraws">deltadraws</code></td>
<td>
<p>dataframe of the MCMC draws of <code class="reqn">\delta</code>, size <code class="reqn">((J-2) x nsim)</code>.</p>
</td></tr>
<tr><td><code id="ineffactorOR1_+3A_accutoff">accutoff</code></td>
<td>
<p>cut-off to identify the number of lags and form batches, default is 0.05.</p>
</td></tr>
<tr><td><code id="ineffactorOR1_+3A_maxlags">maxlags</code></td>
<td>
<p>maximum lag at which to calculate the acf, default is 400.</p>
</td></tr>
<tr><td><code id="ineffactorOR1_+3A_verbose">verbose</code></td>
<td>
<p>whether to print the final output and provide additional information or not, default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the inefficiency factor of <code class="reqn">(\beta, \delta)</code> using the batch-means
method based on MCMC draws. Inefficiency factor can be interpreted as the cost of
working with correlated draws. A low inefficiency factor indicates better mixing
and an efficient algorithm.
</p>


<h3>Value</h3>

<p>Returns a column vector of inefficiency factors for each component of <code class="reqn">\beta</code> and <code class="reqn">\delta</code>.
</p>


<h3>References</h3>

<p>Greenberg, E. (2012). '&quot;Introduction to Bayesian Econometrics.&quot;' Cambridge University
Press, Cambridge. DOI: 10.1017/CBO9780511808920
</p>
<p>Chib, S. (2012), '&quot;Introduction to simulation and MCMC methods.&quot;' In Geweke J., Koop G., and Dijk, H.V.,
editors, '&quot;The Oxford Handbook of Bayesian Econometrics&quot;', pages 183&ndash;218. Oxford University Press,
Oxford. DOI: 10.1093/oxfordhb/9780199559084.013.0006
</p>


<h3>See Also</h3>

<p>pracma, <a href="stats.html#topic+acf">acf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j4")
y &lt;- data25j4$y
xMat &lt;- data25j4$x
k &lt;- dim(xMat)[2]
J &lt;- dim(as.array(unique(y)))[1]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
d0 &lt;- array(0, dim = c(J-2, 1))
D0 &lt;- 0.25*diag(J - 2)
output &lt;- quantregOR1(y = y, x = xMat, b0, B0, d0, D0,
burn = 10, mcmc = 40, p = 0.25, tune = 1, accutoff = 0.5, maxlags = 400, verbose = FALSE)
betadraws &lt;- output$betadraws
deltadraws &lt;- output$deltadraws
inefficiency &lt;- ineffactorOR1(xMat, betadraws, deltadraws, 0.5, 400, TRUE)

# Summary of Inefficiency Factor:

#             Inef Factor
# beta_1        1.1008
# beta_2        3.0024
# beta_3        2.8543
# delta_1       3.6507
# delta_2       3.1784

</code></pre>

<hr>
<h2 id='ineffactorOR2'>Inefficiency factor in the OR2 model</h2><span id='topic+ineffactorOR2'></span>

<h3>Description</h3>

<p>This function calculates the inefficiency factor from the MCMC draws
of <code class="reqn">(\beta, \sigma)</code> in the OR2 model (ordinal quantile model with exactly 3 outcomes). The
inefficiency factor is calculated using the batch-means method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ineffactorOR2(x, betadraws, sigmadraws, accutoff, maxlags, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ineffactorOR2_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.
This input is used to extract column names, if available, but not used in calculation.</p>
</td></tr>
<tr><td><code id="ineffactorOR2_+3A_betadraws">betadraws</code></td>
<td>
<p>dataframe of the Gibbs draws of <code class="reqn">\beta</code>, size <code class="reqn">(k x nsim)</code>.</p>
</td></tr>
<tr><td><code id="ineffactorOR2_+3A_sigmadraws">sigmadraws</code></td>
<td>
<p>dataframe of the Gibbs draws of <code class="reqn">\sigma</code>, size <code class="reqn">(1 x nsim)</code>.</p>
</td></tr>
<tr><td><code id="ineffactorOR2_+3A_accutoff">accutoff</code></td>
<td>
<p>cut-off to identify the number of lags and form batches, default is 0.05.</p>
</td></tr>
<tr><td><code id="ineffactorOR2_+3A_maxlags">maxlags</code></td>
<td>
<p>maximum lag at which to calculate the acf, default is 400.</p>
</td></tr>
<tr><td><code id="ineffactorOR2_+3A_verbose">verbose</code></td>
<td>
<p>whether to print the final output and provide additional information or not, default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the inefficiency factor of <code class="reqn">(\beta, \sigma)</code> using the batch-means
method based on the Gibbs draws. Inefficiency factor can be interpreted as the cost of
working with correlated draws. A low inefficiency factor indicates better mixing
and an efficient algorithm.
</p>


<h3>Value</h3>

<p>Returns a column vector of inefficiency factors for each component of <code class="reqn">\beta</code> and <code class="reqn">\sigma</code>.
</p>


<h3>References</h3>

<p>Greenberg, E. (2012). '&quot;Introduction to Bayesian Econometrics.&quot;' Cambridge University
Press, Cambridge. DOI: 10.1017/CBO9780511808920
</p>
<p>Chib, S. (2012), '&quot;Introduction to simulation and MCMC methods.&quot;' In Geweke J., Koop G., and Dijk, H.V.,
editors, '&quot;The Oxford Handbook of Bayesian Econometrics&quot;', pages 183&ndash;218. Oxford University Press,
Oxford. DOI: 10.1093/oxfordhb/9780199559084.013.0006
</p>


<h3>See Also</h3>

<p>pracma, <a href="stats.html#topic+acf">acf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j3")
y &lt;- data25j3$y
xMat &lt;- data25j3$x
k &lt;- dim(xMat)[2]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
n0 &lt;- 5
d0 &lt;- 8
output &lt;- quantregOR2(y = y, x = xMat, b0, B0, n0, d0, gammacp2 = 3,
burn = 10, mcmc = 40, p = 0.25, accutoff = 0.5, maxlags = 400, verbose = FALSE)
betadraws &lt;- output$betadraws
sigmadraws &lt;- output$sigmadraws

inefficiency &lt;- ineffactorOR2(xMat, betadraws, sigmadraws, 0.5, 400, TRUE)

# Summary of Inefficiency Factor:
#            Inef Factor
# beta_1       1.5686
# beta_2       1.5240
# beta_3       1.4807
# sigma        2.4228

</code></pre>

<hr>
<h2 id='logMargLikeOR1'>Marginal likelihood in the OR1 model</h2><span id='topic+logMargLikeOR1'></span>

<h3>Description</h3>

<p>This function computes the logarithm of marginal likelihood in the OR1 model (ordinal
quantile model with 3 or more outcomes) using the MCMC outputs from the
complete and reduced runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logMargLikeOR1(y, x, b0, B0, d0, D0, postMeanbeta,
postMeandelta, betadraws, deltadraws, tune, Dhat, p, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logMargLikeOR1_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_b0">b0</code></td>
<td>
<p>prior mean for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_b0">B0</code></td>
<td>
<p>prior covariance matrix for <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_d0">d0</code></td>
<td>
<p>prior mean for <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_d0">D0</code></td>
<td>
<p>prior covariance matrix for <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_postmeanbeta">postMeanbeta</code></td>
<td>
<p>posterior mean of <code class="reqn">\beta</code> from the complete MCMC run.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_postmeandelta">postMeandelta</code></td>
<td>
<p>posterior mean of <code class="reqn">\delta</code> from the complete MCMC run.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_betadraws">betadraws</code></td>
<td>
<p>a dataframe with all the sampled values for <code class="reqn">\beta</code> from the complete MCMC run.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_deltadraws">deltadraws</code></td>
<td>
<p>a dataframe with all the sampled values for <code class="reqn">\delta</code> from the complete MCMC run.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_tune">tune</code></td>
<td>
<p>tuning parameter to adjust the MH acceptance rate.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_dhat">Dhat</code></td>
<td>
<p>negative inverse Hessian from the maximization of log-likelihood.</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
<tr><td><code id="logMargLikeOR1_+3A_verbose">verbose</code></td>
<td>
<p>whether to print the final output and provide additional information or not, default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the logarithm of marginal likelihood in the OR1 model using the MCMC outputs from complete and
reduced runs.
</p>


<h3>Value</h3>

<p>Returns an estimate of log marginal likelihood
</p>


<h3>References</h3>

<p>Chib, S. (1995). '&quot;Marginal likelihood from the Gibbs output.&quot;' Journal of the American
Statistical Association, 90(432):1313 to 1321, 1995. DOI: 10.1080/01621459.1995.10476635
</p>
<p>Chib, S., and Jeliazkov, I. (2001). '&quot;Marginal likelihood from the Metropolis-Hastings output.&quot;' Journal of the
American Statistical Association, 96(453):270'-'281, 2001. DOI: 10.1198/016214501750332848
</p>


<h3>See Also</h3>

<p><a href="NPflow.html#topic+mvnpdf">mvnpdf</a>, <a href="stats.html#topic+dnorm">dnorm</a>,
Gibbs sampling, Metropolis-Hastings algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j4")
y &lt;- data25j4$y
xMat &lt;- data25j4$x
k &lt;- dim(xMat)[2]
J &lt;- dim(as.array(unique(y)))[1]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
d0 &lt;- array(0, dim = c(J-2, 1))
D0 &lt;- 0.25*diag(J - 2)
output &lt;- quantregOR1(y = y, x = xMat, b0, B0, d0, D0,
burn = 10, mcmc = 40, p = 0.25, tune = 1, accutoff = 0.5, maxlags = 400, verbose = FALSE)
# output$logMargLike
#   -559.73

</code></pre>

<hr>
<h2 id='logMargLikeOR2'>Marginal likelihood in the OR2 model</h2><span id='topic+logMargLikeOR2'></span>

<h3>Description</h3>

<p>This function computes the logarithm of marginal likelihood in the OR2 model (ordinal
quantile model with exactly 3 outcomes) using the Gibbs output from the
complete and reduced runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logMargLikeOR2(y, x, b0, B0, n0, d0, postMeanbeta, postMeansigma,
btildeStore, BtildeStore, gammacp2, p, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logMargLikeOR2_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_b0">b0</code></td>
<td>
<p>prior mean for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_b0">B0</code></td>
<td>
<p>prior covariance matrix for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_n0">n0</code></td>
<td>
<p>prior shape parameter of inverse-gamma distribution for <code class="reqn">\sigma</code>.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_d0">d0</code></td>
<td>
<p>prior scale parameter of inverse-gamma distribution for <code class="reqn">\sigma</code>.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_postmeanbeta">postMeanbeta</code></td>
<td>
<p>posterior mean of <code class="reqn">\beta</code> from the complete Gibbs run.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_postmeansigma">postMeansigma</code></td>
<td>
<p>posterior mean of <code class="reqn">\delta</code> from the complete Gibbs run.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_btildestore">btildeStore</code></td>
<td>
<p>a storage matrix for btilde from the complete Gibbs run.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_btildestore">BtildeStore</code></td>
<td>
<p>a storage matrix for Btilde from the complete Gibbs run.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_gammacp2">gammacp2</code></td>
<td>
<p>one and only cut-point other than 0.</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
<tr><td><code id="logMargLikeOR2_+3A_verbose">verbose</code></td>
<td>
<p>whether to print the final output and provide additional information or not, default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the logarithm of marginal likelihood in the OR2 model using the Gibbs output from the complete
and reduced runs.
</p>


<h3>Value</h3>

<p>Returns an estimate of log marginal likelihood
</p>


<h3>References</h3>

<p>Chib, S. (1995). '&quot;Marginal likelihood from the Gibbs output.&quot;' Journal of the American
Statistical Association, 90(432):1313'-'1321, 1995. DOI: 10.1080/01621459.1995.10476635
</p>


<h3>See Also</h3>

<p><a href="invgamma.html#topic+dinvgamma">dinvgamma</a>, <a href="NPflow.html#topic+mvnpdf">mvnpdf</a>, <a href="stats.html#topic+dnorm">dnorm</a>,
Gibbs sampling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j3")
y &lt;- data25j3$y
xMat &lt;- data25j3$x
k &lt;- dim(xMat)[2]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
n0 &lt;- 5
d0 &lt;- 8
output &lt;- quantregOR2(y = y, x = xMat, b0, B0, n0, d0, gammacp2 = 3,
burn = 10, mcmc = 40, p = 0.25, accutoff = 0.5, maxlags = 400, verbose = FALSE)
# output$logMargLike
#   -404.57

</code></pre>

<hr>
<h2 id='Policy_Opinion'>Data contains public opinion on the proposal to raise federal income taxes for couples (individuals) earning more than $250,000 ($200,000) per year and a host of other covariates. The data is taken from the 2010-2012 American National Election Studies (ANES) on the Evaluation of Government and Society Study I (EGSS 1)</h2><span id='topic+Policy_Opinion'></span>

<h3>Description</h3>

<p>Data contains public opinion on the proposal to raise federal income taxes for couples (individuals) earning more than $250,000 ($200,000) per year and a host of other covariates. The data is taken from the 2010-2012 American National Election Studies (ANES) on the Evaluation of Government and Society Study I (EGSS 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Policy_Opinion)
</code></pre>


<h3>Details</h3>

<p>The data consists of 1,164 observations taken from the 2010-2012 American National Election
Studies (ANES) on the Evaluations of Government and Society Study 1 (EGSS 1). The objective
is to analyze public opinion on the proposal to raise federal income taxes for couples (individuals)
earning more than $250,000 ($200,000) per year. The responses were recorded as oppose, neither
favor nor oppose, or favor the tax increase, and forms the dependent variable in the study. The
independent variables include indicator variables (or dummy) for employment, income above
$75,000, bachelor's and post-bachelor's degree, computer ownership, cellphone ownership, and white race.
</p>


<h3>Value</h3>

<p>Returns data with components
</p>
<table role = "presentation">
<tr><td><code>Intercept:</code></td>
<td>
<p>Column of ones.</p>
</td></tr>
<tr><td><code>EmpCat:</code></td>
<td>
<p>Indicator for employment status.</p>
</td></tr>
<tr><td><code>IncomeCat:</code></td>
<td>
<p>Indicator for household income &gt; $75,000.</p>
</td></tr>
<tr><td><code>Bachelors:</code></td>
<td>
<p>Individual's highest degree is Bachelors.</p>
</td></tr>
<tr><td><code>Post.Bachelors:</code></td>
<td>
<p>Indicator for highest degree is Masters, Professional or Doctorate.</p>
</td></tr>
<tr><td><code>Computers:</code></td>
<td>
<p>Indicator for computer ownership by individual or household.</p>
</td></tr>
<tr><td><code>CellPhone:</code></td>
<td>
<p>Indicator for cellphone ownership by individual or household.</p>
</td></tr>
<tr><td><code>White:</code></td>
<td>
<p>Indicator for White race.</p>
</td></tr>
<tr><td><code>y:</code></td>
<td>
<p>Public opinion on the proposal to raise federal income taxes. The three categories are: oppose, neither
favor nor oppose, or favor the tax increase.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>


<h3>See Also</h3>

<p><a href="https://electionstudies.org/data-center/">ANES</a>,  <a href="https://georgewbush-whitehouse.archives.gov/cea/progrowth.html">Tax Policy</a>
</p>

<hr>
<h2 id='qrminfundtheorem'>Minimizes the negative of log-likelihood in the OR1 model</h2><span id='topic+qrminfundtheorem'></span>

<h3>Description</h3>

<p>This function minimizes the negative of log-likelihood in the OR1 model
with respect to the cut-points <code class="reqn">\delta</code> using the
fundamental theorem of calculus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qrminfundtheorem(deltaIn, y, x, beta, cri0, cri1, stepsize, maxiter, h, dh, sw, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qrminfundtheorem_+3A_deltain">deltaIn</code></td>
<td>
<p>initialization of cut-points.</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code>, a column vector of size <code class="reqn">(k x 1)</code>.</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_cri0">cri0</code></td>
<td>
<p>initial criterion, <code class="reqn">cri0 = 1</code>.</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_cri1">cri1</code></td>
<td>
<p>criterion lies between (0.001 to 0.0001).</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_stepsize">stepsize</code></td>
<td>
<p>learning rate lies between (0.1, 1).</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iteration.</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_h">h</code></td>
<td>
<p>change in each value of <code class="reqn">\delta</code>, holding other <code class="reqn">\delta</code>
constant for first derivatives.</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_dh">dh</code></td>
<td>
<p>change in each value of <code class="reqn">\delta</code>, holding other <code class="reqn">\delta</code> constant
for second derivaties.</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_sw">sw</code></td>
<td>
<p>iteration to switch from BHHH to inv(-H) algorithm.</p>
</td></tr>
<tr><td><code id="qrminfundtheorem_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First derivative from first principle
</p>
<p style="text-align: center;"><code class="reqn">dy/dx=[f(x+h)-f(x-h)]/2h</code>
</p>

<p>Second derivative from first principle
</p>
<p style="text-align: center;"><code class="reqn">f'(x-h)=(f(x)-f(x-h))/h</code>
</p>

<p style="text-align: center;"><code class="reqn">f''(x)= [{(f(x+h)-f(x))/h} - (f(x)-f(x-h))/h]/h</code>
</p>

<p style="text-align: center;"><code class="reqn">= [(f(x+h)+f(x-h)-2 f(x))]/h^2</code>
</p>

<p>cross partial derivatives
</p>
<p style="text-align: center;"><code class="reqn">f(x) = [f(x+dh,y)-f(x-dh,y)]/2dh</code>
</p>

<p style="text-align: center;"><code class="reqn">f(x,y)=[{(f(x+dh,y+dh) - f(x+dh,y-dh))/2dh} - {(f(x-dh,y+dh) -
f(x-dh,y-dh))/2dh}]/2dh</code>
</p>

<p style="text-align: center;"><code class="reqn">= 0.25* [{(f(x+dh,y+dh)-f(x+dh,y-dh))} -{(f(x-dh,y+dh)-f(x-dh,y-dh))}]/dh2</code>
</p>



<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>deltamin:</code></td>
<td>
<p>cutpoint vector that minimizes the log-likelihood function.</p>
</td></tr>
<tr><td><code>negsum:</code></td>
<td>
<p>negative sum of log-likelihood.</p>
</td></tr>
<tr><td><code>logl:</code></td>
<td>
<p>log-likelihood values.</p>
</td></tr>
<tr><td><code>G:</code></td>
<td>
<p>gradient vector, <code class="reqn">(n x k)</code> matrix with i-th row as the score
for the i-th unit.</p>
</td></tr>
<tr><td><code>H:</code></td>
<td>
<p>Hessian matrix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>differential calculus, functional maximization,
<a href="pracma.html#topic+mldivide">mldivide</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
deltaIn &lt;- c(-0.002570995,  1.044481071)
data("data25j4")
y &lt;- data25j4$y
xMat &lt;- data25j4$x
p &lt;- 0.25
beta &lt;- c(0.3990094, 0.8168991, 2.8034963)
cri0     &lt;- 1
cri1     &lt;- 0.001
stepsize &lt;- 1
maxiter  &lt;- 10
h        &lt;- 0.002
dh       &lt;- 0.0002
sw       &lt;- 20
output &lt;- qrminfundtheorem(deltaIn, y, xMat, beta, cri0, cri1, stepsize, maxiter, h, dh, sw, p)

# deltamin
#   0.8266967 0.3635708
# negsum
#   645.4911
# logl
#    -0.7136999
#    -1.5340787
#    -1.1072447
#    -1.4423124
#    -1.3944677
#    -0.7941271
#    -1.6544072
#    -0.3246632
#    -1.8582422
#    -0.9220822
#    -2.1117739 .. soon
# G
#    0.803892784  0.00000000
#   -0.420190546  0.72908381
#   -0.421776117  0.72908341
#   -0.421776117 -0.60184063
#   -0.421776117 -0.60184063
#    0.151489598  0.86175120
#    0.296995920  0.96329114
#   -0.421776117  0.72908341
#   -0.340103190 -0.48530164
#    0.000000000  0.00000000
#   -0.421776117 -0.60184063.. soon
# H
#   -338.21243  -41.10775
#   -41.10775 -106.32758

</code></pre>

<hr>
<h2 id='qrnegLogLikensumOR1'>Negative log-likelihood in the OR1 model</h2><span id='topic+qrnegLogLikensumOR1'></span>

<h3>Description</h3>

<p>This function computes the negative of log-likelihood for each individual and
negative sum of log-likelihood in the OR1 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qrnegLogLikensumOR1(y, x, betaOne, deltaOne, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qrnegLogLikensumOR1_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="qrnegLogLikensumOR1_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="qrnegLogLikensumOR1_+3A_betaone">betaOne</code></td>
<td>
<p>a sample draw of <code class="reqn">\beta</code> of size <code class="reqn">(k x 1)</code>.</p>
</td></tr>
<tr><td><code id="qrnegLogLikensumOR1_+3A_deltaone">deltaOne</code></td>
<td>
<p>a sample draw of <code class="reqn">\delta</code> of size <code class="reqn">((J-2) x 1)</code>.</p>
</td></tr>
<tr><td><code id="qrnegLogLikensumOR1_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the negative of log-likelihood for each individual and
negative sum of log-likelihood in the OR1 model.
</p>
<p>The latter when evaluated at postMeanbeta and postMeandelta is used to calculate the DIC
and may also be utilized to calculate the Akaike information criterion (AIC) and the Bayesian information
criterion (BIC).
</p>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>nlogl:</code></td>
<td>
<p>vector of negative log-likelihood values.</p>
</td></tr>
<tr><td><code>negsumlogl:</code></td>
<td>
<p>negative sum of log-likelihood.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>


<h3>See Also</h3>

<p>likelihood maximization
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
deltaOne &lt;- c(-0.002570995, 1.044481071)
data("data25j4")
y &lt;- data25j4$y
xMat &lt;- data25j4$x
p &lt;- 0.25
betaOne &lt;- c(0.3990094, 0.8168991, 2.8034963)
output &lt;- qrnegLogLikensumOR1(y, xMat, betaOne, deltaOne, p)

# nlogl
#   0.7424858
#   1.1649645
#   2.1344390
#   0.9881085
#   2.7677386
#   0.8229129
#   0.8854911
#   0.3534490
#   1.8582422
#   0.9508680 .. soon

# negsumlogl
#   663.5475

</code></pre>

<hr>
<h2 id='qrnegLogLikeOR2'>Negative sum of log-likelihood in the OR2 model</h2><span id='topic+qrnegLogLikeOR2'></span>

<h3>Description</h3>

<p>This function computes the negative sum of log-likelihood in the OR2 model (ordinal quantile
model with exactly 3 outcomes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qrnegLogLikeOR2(y, x, gammacp, betaOne, sigmaOne, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qrnegLogLikeOR2_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="qrnegLogLikeOR2_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="qrnegLogLikeOR2_+3A_gammacp">gammacp</code></td>
<td>
<p>a row vector of cutpoints including (-Inf, Inf).</p>
</td></tr>
<tr><td><code id="qrnegLogLikeOR2_+3A_betaone">betaOne</code></td>
<td>
<p>a sample draw of <code class="reqn">\beta</code> of size <code class="reqn">(k x 1)</code>.</p>
</td></tr>
<tr><td><code id="qrnegLogLikeOR2_+3A_sigmaone">sigmaOne</code></td>
<td>
<p>a sample draw of <code class="reqn">\sigma</code>, a scalar value.</p>
</td></tr>
<tr><td><code id="qrnegLogLikeOR2_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the negative sum of log-likelihood in the OR2 model where the error is assumed to follow
an AL distribution.
</p>


<h3>Value</h3>

<p>Returns the negative sum of log-likelihood.
</p>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>


<h3>See Also</h3>

<p>likelihood maximization
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j3")
y &lt;- data25j3$y
xMat &lt;- data25j3$x
p &lt;- 0.25
gammacp &lt;- c(-Inf, 0, 3, Inf)
betaOne &lt;- c(1.810504, 1.850332, 6.18116)
sigmaOne &lt;- 0.9684741
output &lt;- qrnegLogLikeOR2(y, xMat, gammacp, betaOne, sigmaOne, p)

# output
#   902.4045

</code></pre>

<hr>
<h2 id='quantregOR1'>Bayesian quantile regression in the OR1 model</h2><span id='topic+quantregOR1'></span>

<h3>Description</h3>

<p>This function estimates Bayesian quantile regression in the OR1 model (ordinal quantile model with 3
or more outcomes) and reports the posterior mean, posterior standard deviation, 95
percent posterior credible intervals, and inefficiency factor of <code class="reqn">(\beta, \delta)</code>. The output
also displays the log of marginal likelihood and the DIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantregOR1(y, x, b0, B0, d0, D0, burn, mcmc, p, tune, accutoff, maxlags, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantregOR1_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_b0">b0</code></td>
<td>
<p>prior mean for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_b0">B0</code></td>
<td>
<p>prior covariance matrix for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_d0">d0</code></td>
<td>
<p>prior mean for <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_d0">D0</code></td>
<td>
<p>prior covariance matrix for <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_burn">burn</code></td>
<td>
<p>number of burn-in MCMC iterations.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_mcmc">mcmc</code></td>
<td>
<p>number of MCMC iterations, post burn-in.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_tune">tune</code></td>
<td>
<p>tuning parameter to adjust MH acceptance rate, default is 0.1.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_accutoff">accutoff</code></td>
<td>
<p>autocorrelation cut-off to identify the number of lags and form batches to compute the inefficiency factor, default is 0.05.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_maxlags">maxlags</code></td>
<td>
<p>maximum lag at which to calculate the acf in inefficiency factor calculation, default is 400.</p>
</td></tr>
<tr><td><code id="quantregOR1_+3A_verbose">verbose</code></td>
<td>
<p>whether to print the final output and provide additional information or not, default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates Bayesian quantile regression for the
OR1 model using a combination of Gibbs sampling
and Metropolis-Hastings algorithm. The function takes the prior distributions and
other information as inputs and then iteratively samples <code class="reqn">\beta</code>, latent weight w,
<code class="reqn">\delta</code>, and latent variable z from their respective
conditional distributions.
</p>
<p>The function also provides the logarithm of marginal likelihood and the DIC. These
quantities can be utilized to compare two or more competing models at the same quantile.
The model with a higher (lower) log marginal likelihood (DIC) provides a
better model fit.
</p>


<h3>Value</h3>

<p>Returns a bqrorOR1 object with components:
</p>
<table role = "presentation">
<tr><td><code>summary:</code></td>
<td>
<p>summary of the MCMC draws.</p>
</td></tr>
<tr><td><code>postMeanbeta:</code></td>
<td>
<p>posterior mean of <code class="reqn">\beta</code> from the complete MCMC run.</p>
</td></tr>
<tr><td><code>postMeandelta:</code></td>
<td>
<p>posterior mean of <code class="reqn">\delta</code> from the complete MCMC run.</p>
</td></tr>
<tr><td><code>postStdbeta:</code></td>
<td>
<p>posterior standard deviation of <code class="reqn">\beta</code> from the complete MCMC run.</p>
</td></tr>
<tr><td><code>postStddelta:</code></td>
<td>
<p>posterior standard deviation of <code class="reqn">\delta</code> from the complete MCMC run.</p>
</td></tr>
<tr><td><code>gammacp:</code></td>
<td>
<p>vector of cut points including (Inf, -Inf).</p>
</td></tr>
<tr><td><code>catprob:</code></td>
<td>
<p>probability for each category, calculated at the posterior mean and the mean of x.</p>
</td></tr>
<tr><td><code>acceptancerate:</code></td>
<td>
<p>acceptance rate of the proposed draws of <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code>dicQuant:</code></td>
<td>
<p>all quantities of DIC.</p>
</td></tr>
<tr><td><code>logMargLike:</code></td>
<td>
<p>an estimate of the log marginal likelihood.</p>
</td></tr>
<tr><td><code>ineffactor:</code></td>
<td>
<p>inefficiency factor for each component of <code class="reqn">\beta</code> and <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code>betadraws:</code></td>
<td>
<p>dataframe of the <code class="reqn">\beta</code> draws from the complete MCMC run, size is <code class="reqn">(k x nsim)</code>.</p>
</td></tr>
<tr><td><code>deltadraws:</code></td>
<td>
<p>dataframe of the <code class="reqn">\delta</code> draws from the complete MCMC run, size is <code class="reqn">((J-2) x nsim)</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24. DOI: 10.1214/15-BA939
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+rnorm">rnorm</a>, <a href="stats.html#topic+qnorm">qnorm</a>,
Gibbs sampler, Metropolis-Hastings algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(101)
 data("data25j4")
 y &lt;- data25j4$y
 xMat &lt;- data25j4$x
 k &lt;- dim(xMat)[2]
 J &lt;- dim(as.array(unique(y)))[1]
 b0 &lt;- array(rep(0, k), dim = c(k, 1))
 B0 &lt;- 10*diag(k)
 d0 &lt;- array(0, dim = c(J-2, 1))
 D0 &lt;- 0.25*diag(J - 2)
 output &lt;- quantregOR1(y = y, x = xMat, b0 ,B0, d0, D0,
 burn = 10, mcmc = 40, p = 0.25, tune = 1, accutoff = 0.5, maxlags = 400, verbose = TRUE)

 # Summary of MCMC draws:


 #             Post Mean  Post Std   Upper Credible Lower Credible Inef Factor
 # beta_1       -2.6202   0.3588        -2.0560        -3.3243       1.1008
 # beta_2        3.1670   0.5894         4.1713         2.1423       3.0024
 # beta_3        4.2800   0.9141         5.7142         2.8625       2.8534
 # delta_1       0.2188   0.4043         0.6541        -0.4384       3.6507
 # delta_2       0.4567   0.3055         0.7518        -0.2234       3.1784

 # MH acceptance rate: 50%
 # Log of Marginal Likelihood: -559.73
 # DIC: 1133.11

</code></pre>

<hr>
<h2 id='quantregOR2'>Bayesian quantile regression in the OR2 model</h2><span id='topic+quantregOR2'></span>

<h3>Description</h3>

<p>This function estimates Bayesian quantile regression in the OR2 model (ordinal quantile model with
exactly 3 outcomes) and reports the posterior mean, posterior standard deviation, 95
percent posterior credible intervals and inefficiency factor of <code class="reqn">(\beta, \sigma)</code>. The output also displays the log of
marginal likelihood and the DIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantregOR2(y, x, b0, B0 , n0, d0, gammacp2, burn, mcmc, p, accutoff, maxlags, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantregOR2_+3A_y">y</code></td>
<td>
<p>observed ordinal outcomes, column vector of size <code class="reqn">(n x 1)</code>.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_x">x</code></td>
<td>
<p>covariate matrix of size <code class="reqn">(n x k)</code> including a column of ones with or without column names.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_b0">b0</code></td>
<td>
<p>prior mean for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_b0">B0</code></td>
<td>
<p>prior covariance matrix for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_n0">n0</code></td>
<td>
<p>prior shape parameter of the inverse-gamma distribution for <code class="reqn">\sigma</code>, default is 5.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_d0">d0</code></td>
<td>
<p>prior scale parameter of the inverse-gamma distribution for <code class="reqn">\sigma</code>, default is 8.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_gammacp2">gammacp2</code></td>
<td>
<p>one and only cut-point other than 0, default is 3.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_burn">burn</code></td>
<td>
<p>number of burn-in MCMC iterations.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_mcmc">mcmc</code></td>
<td>
<p>number of MCMC iterations, post burn-in.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_p">p</code></td>
<td>
<p>quantile level or skewness parameter, p in (0,1).</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_accutoff">accutoff</code></td>
<td>
<p>autocorrelation cut-off to identify the number of lags and form batches to compute the inefficiency factor, default is 0.05.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_maxlags">maxlags</code></td>
<td>
<p>maximum lag at which to calculate the acf in inefficiency factor calculation, default is 400.</p>
</td></tr>
<tr><td><code id="quantregOR2_+3A_verbose">verbose</code></td>
<td>
<p>whether to print the final output and provide additional information or not, default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates Bayesian quantile regression for the
OR2 model using a Gibbs sampling procedure. The function takes the prior distributions
and other information as inputs and then iteratively samples <code class="reqn">\beta</code>, <code class="reqn">\sigma</code>,
latent weight <code class="reqn">\nu</code>, and latent variable z from their respective
conditional distributions.
</p>
<p>The function also provides the logarithm of marginal likelihood and the DIC. These
quantities can be utilized to compare two or more competing models at the same quantile.
The model with a higher (lower) log marginal likelihood (DIC) provides a
better model fit.
</p>


<h3>Value</h3>

<p>Returns a bqrorOR2 object with components
</p>
<table role = "presentation">
<tr><td><code>summary:</code></td>
<td>
<p>summary of the MCMC draws.</p>
</td></tr>
<tr><td><code>postMeanbeta:</code></td>
<td>
<p>posterior mean of <code class="reqn">\beta</code> from the complete Gibbs run.</p>
</td></tr>
<tr><td><code>postMeansigma:</code></td>
<td>
<p>posterior mean of <code class="reqn">\sigma</code> from the complete Gibbs run.</p>
</td></tr>
<tr><td><code>postStdbeta:</code></td>
<td>
<p>posterior standard deviation of <code class="reqn">\beta</code> from the complete Gibbs run.</p>
</td></tr>
<tr><td><code>postStdsigma:</code></td>
<td>
<p>posterior standard deviation of <code class="reqn">\sigma</code> from the complete Gibbs run.</p>
</td></tr>
<tr><td><code>dicQuant:</code></td>
<td>
<p>all quantities of DIC.</p>
</td></tr>
<tr><td><code>logMargLike:</code></td>
<td>
<p>an estimate of log marginal likelihood.</p>
</td></tr>
<tr><td><code>ineffactor:</code></td>
<td>
<p>inefficiency factor for each component of <code class="reqn">\beta</code> and <code class="reqn">\sigma</code>.</p>
</td></tr>
<tr><td><code>betadraws:</code></td>
<td>
<p>dataframe of the <code class="reqn">\beta</code> draws from the complete Gibbs run, size is <code class="reqn">(k x nsim)</code>.</p>
</td></tr>
<tr><td><code>sigmadraws:</code></td>
<td>
<p>dataframe of the <code class="reqn">\sigma</code> draws from the complete Gibbs run, size is <code class="reqn">(1 x nsim)</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahman, M. A. (2016). '&quot;Bayesian Quantile Regression for Ordinal Models.&quot;'
Bayesian Analysis, 11(1): 1-24.  DOI: 10.1214/15-BA939
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+rnorm">rnorm</a>, <a href="stats.html#topic+qnorm">qnorm</a>,
Gibbs sampling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j3")
y &lt;- data25j3$y
xMat &lt;- data25j3$x
k &lt;- dim(xMat)[2]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
n0 &lt;- 5
d0 &lt;- 8
output &lt;- quantregOR2(y = y, x = xMat, b0, B0, n0, d0, gammacp2 = 3,
burn = 10, mcmc = 40, p = 0.25, accutoff = 0.5, maxlags = 400, verbose = TRUE)

# Summary of MCMC draws :

#            Post Mean Post Std Upper Credible Lower Credible Inef Factor
#    beta_1   -4.5185   0.9837        -3.1726        -6.2000     1.5686
#    beta_2    6.1825   0.9166         7.6179         4.8619     1.5240
#    beta_3    5.2984   0.9653         6.9954         4.1619     1.4807
#    sigma     1.0879   0.2073         1.5670         0.8436     2.4228

# Log of Marginal Likelihood: -404.57
# DIC: 801.82

</code></pre>

<hr>
<h2 id='rndald'>Generates random numbers from an AL distribution</h2><span id='topic+rndald'></span>

<h3>Description</h3>

<p>This function generates a vector of random numbers from an AL
distribution at quantile p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rndald(sigma, p, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rndald_+3A_sigma">sigma</code></td>
<td>
<p>scale factor, a scalar value.</p>
</td></tr>
<tr><td><code id="rndald_+3A_p">p</code></td>
<td>
<p>quantile or skewness parameter, p in (0,1).</p>
</td></tr>
<tr><td><code id="rndald_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a vector of random numbers from an AL distribution
as a mixture of normal'–'exponential distributions.
</p>


<h3>Value</h3>

<p>Returns a vector <code class="reqn">(n x 1)</code> of random numbers from an AL(0, <code class="reqn">\sigma</code>, p)
</p>


<h3>References</h3>

<p>Kozumi, H., and Kobayashi, G. (2011). '&quot;Gibbs Sampling Methods for Bayesian Quantile Regression.&quot;'
Journal of Statistical Computation and Simulation, 81(11): 1565'-'1578. DOI: 10.1080/00949655.2010.496117
</p>
<p>Yu, K., and Zhang, J. (2005). '&quot;A Three-Parameter Asymmetric Laplace Distribution.&quot;'
Communications in Statistics - Theory and Methods, 34(9-10), 1867'-'1879. DOI: 10.1080/03610920500199018
</p>


<h3>See Also</h3>

<p>asymmetric Laplace distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
sigma &lt;- 2.503306
p &lt;- 0.25
n &lt;- 1
output &lt;- rndald(sigma, p, n)

# output
#   1.07328

</code></pre>

<hr>
<h2 id='summary.bqrorOR1'>Extractor function for summary</h2><span id='topic+summary.bqrorOR1'></span>

<h3>Description</h3>

<p>This function extracts the summary from the bqrorOR1 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bqrorOR1'
summary(object, digits, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bqrorOR1_+3A_object">object</code></td>
<td>
<p>bqrorOR1 object from which the summary is extracted.</p>
</td></tr>
<tr><td><code id="summary.bqrorOR1_+3A_digits">digits</code></td>
<td>
<p>controls the number of digits after the decimal.</p>
</td></tr>
<tr><td><code id="summary.bqrorOR1_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an extractor function for the summary
</p>


<h3>Value</h3>

<p>the summarized information object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j4")
y &lt;- data25j4$y
xMat &lt;- data25j4$x
k &lt;- dim(xMat)[2]
J &lt;- dim(as.array(unique(y)))[1]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
d0 &lt;- array(0, dim = c(J-2, 1))
D0 &lt;- 0.25*diag(J - 2)
output &lt;- quantregOR1(y = y, x = xMat, b0, B0, d0, D0,
burn = 10, mcmc = 40, p = 0.25, tune = 1, accutoff = 0.5, maxlags = 400, verbose = FALSE)
summary(output, 4)

 #            Post Mean  Post Std   Upper Credible Lower Credible Inef Factor
 # beta_1       -2.6202   0.3588        -2.0560        -3.3243       1.1008
 # beta_2        3.1670   0.5894         4.1713         2.1423       3.0024
 # beta_3        4.2800   0.9141         5.7142         2.8625       2.8534
 # delta_1       0.2188   0.4043         0.6541        -0.4384       3.6507
 # delta_2       0.4567   0.3055         0.7518        -0.2234       3.1784

</code></pre>

<hr>
<h2 id='summary.bqrorOR2'>Extractor function for summary</h2><span id='topic+summary.bqrorOR2'></span>

<h3>Description</h3>

<p>This function extracts the summary from the bqrorOR2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bqrorOR2'
summary(object, digits, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bqrorOR2_+3A_object">object</code></td>
<td>
<p>bqrorOR2 object from which the summary is extracted.</p>
</td></tr>
<tr><td><code id="summary.bqrorOR2_+3A_digits">digits</code></td>
<td>
<p>controls the number of digits after the decimal</p>
</td></tr>
<tr><td><code id="summary.bqrorOR2_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an extractor function for the summary
</p>


<h3>Value</h3>

<p>the summarized information object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
data("data25j3")
y &lt;- data25j3$y
xMat &lt;- data25j3$x
k &lt;- dim(xMat)[2]
b0 &lt;- array(rep(0, k), dim = c(k, 1))
B0 &lt;- 10*diag(k)
n0 &lt;- 5
d0 &lt;- 8
output &lt;- quantregOR2(y = y, x = xMat, b0, B0, n0, d0, gammacp2 = 3,
burn = 10, mcmc = 40, p = 0.25, accutoff = 0.5, maxlags = 400, FALSE)
summary(output, 4)

#            Post Mean Post Std Upper Credible Lower Credible Inef Factor
#    beta_1   -4.5185   0.9837        -3.1726        -6.2000     1.5686
#    beta_2    6.1825   0.9166         7.6179         4.8619     1.5240
#    beta_3    5.2984   0.9653         6.9954         4.1619     1.4807
#    sigma     1.0879   0.2073         1.5670         0.8436     2.4228

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
