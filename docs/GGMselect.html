<!DOCTYPE html><html><head><title>Help for package GGMselect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GGMselect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#convertGraph'><p>Convert graphs into adjacency matrices</p></a></li>
<li><a href='#GGMselect-package'><p>Gaussian Graphs Models selection</p></a></li>
<li><a href='#penalty'><p> Penalty function</p></a></li>
<li><a href='#selectFast'><p>  Estimate a graph in a Gaussian  Graphical Model: Fast procedure</p></a></li>
<li><a href='#selectMyFam'><p>Select a graph within a given family of graphs in  Gaussian Graphical Modeling.</p></a></li>
<li><a href='#selectQE'><p>  Estimate a graph in a Gaussian  Graphical Model: Quasi Exhaustive search</p></a></li>
<li><a href='#simulateGraph'><p> Generate sparse Gaussian Graphical Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Gaussian Graphs Models Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-12.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Annie Bouvier, Christophe Giraud, Sylvie Huet, Nicolas Verzelen.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Auder &lt;benjamin.auder@universite-paris-saclay.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Graph estimation in Gaussian Graphical Models, following the method
  developed by C. Giraud, S. Huet and N. Verzelen (2012) &lt;<a href="https://doi.org/10.1515%2F1544-6115.1625">doi:10.1515/1544-6115.1625</a>&gt;.
  The main functions return the adjacency matrix of an undirected graph
  estimated from a data matrix.</td>
</tr>
<tr>
<td>Imports:</td>
<td>lars, gtools, stats</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>network, glasso</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-31 09:07:52 UTC; auder</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-31 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='convertGraph'>Convert graphs into adjacency matrices </h2><span id='topic+convertGraph'></span>

<h3>Description</h3>

<p>Convert into adjacency matrices <code>NG</code> graphs (expressed as
lists of connected nodes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertGraph(Graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertGraph_+3A_graph">Graph</code></td>
<td>
<p>array of dimension <code>p x Dmax x NG</code>, where
<code>Dmax</code> is the degree of the graph and <code>NG</code>  the
number of graphs. If <code>NG</code>  is equal to 1, <code>Graph</code>
can be a matrix
of dimension <code>p x Dmax</code>.
</p>
<p><code>Graph[a,,iG]</code> should be the indices of the nodes connected to the node <code>a</code>,   for the graph <code>iG</code>;<br />
<code>Graph[a,1,iG]</code> should be equal to 0 if there is no node connected to the node <code>a</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of dimension <code>p x p x NG</code>, or,
when <code>NG</code>  is equal to 1, a matrix
of dimension <code>p x p</code>.
</p>
<p>The entry <code>[,,iG]</code> is a symmetric matrix, with diagonal equal to
zero. The entry <code>[a,b,iG]</code> is equal to 1 if <code>a</code> is connected to <code>b</code>,
0 otherwise.
</p>


<h3>Note</h3>

<p>This function is  useful to generate the entry
<code>MyFamily</code> of the function <code><a href="#topic+selectMyFam">selectMyFam</a></code>.
Actually, the list of adjacency matrices <code>MyFamily</code>
can be generated from lists of connected nodes with
<code>convertGraph</code>.</p>


<h3>Author(s)</h3>

<p>Bouvier A, Giraud C, Huet S, Verzelen N </p>


<h3>References</h3>

<p> Please use <code>citation("GGMselect")</code> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+selectQE">selectQE</a></code>, <code><a href="#topic+selectMyFam">selectMyFam</a></code>,
<code><a href="#topic+selectFast">selectFast</a></code>, <code><a href="#topic+simulateGraph">simulateGraph</a></code>,
<code><a href="#topic+penalty">penalty</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>p=30
n=30
# simulate graph
eta=0.11
Gr &lt;- simulateGraph(p,eta)
X &lt;- rmvnorm(n, mean=rep(0,p), sigma=Gr$C)
# estimate graph
GRest &lt;- selectFast(X, family="C01")
# Neighb and G are 2 forms of the same result
a &lt;- convertGraph(GRest$C01$Neighb)
print(all.equal(a, GRest$C01$G)) # TRUE
# recalculate the graph with selectMyFam
GMF &lt;- selectMyFam(X, list(a))
print(all.equal(a,GMF$G)) # TRUE
</code></pre>

<hr>
<h2 id='GGMselect-package'>Gaussian Graphs Models selection</h2><span id='topic+GGMselect-package'></span><span id='topic+GGMselect'></span>

<h3>Description</h3>

<p>GGMselect is a package dedicated to graph estimation in Gaussian
Graphical Models. The main functions return the adjacency matrix of an
undirected graph estimated from a data matrix.
</p>
<p>This package is developed in the Applied Mathematics and Informatics
(<a href="https://maiage.inrae.fr/">https://maiage.inrae.fr/</a>) Lab of INRA - Jouy-en-Josas, France.
</p>
<p>To cite GGMselect, please use <code>citation("GGMselect")</code>.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GGMselect</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=GGMselect">https://CRAN.R-project.org/package=GGMselect</a></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Author(s)</h3>

<p>Annie Bouvier, Christophe Giraud, Sylvie Huet, Verzelen Nicolas
</p>
<p>Maintainer: Benjamin Auder &lt;benjamin.auder@universite-paris-saclay.fr&gt;
</p>
<p>More details are available on <a href="../doc/Notice.pdf">../doc/Notice.pdf</a><br />
</p>


<h3>References</h3>

<p>Please use <code>citation("GGMselect")</code>.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+selectFast">selectFast</a></code>, <code><a href="#topic+selectQE">selectQE</a></code>,
<code><a href="#topic+selectMyFam">selectMyFam</a></code>,<code><a href="#topic+convertGraph">convertGraph</a></code>,
<code><a href="#topic+simulateGraph">simulateGraph</a></code>, <code><a href="#topic+penalty">penalty</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>p=30
n=30
# simulate graph
eta=0.11
Gr &lt;- simulateGraph(p,eta)
# simulate data
X &lt;- rmvnorm(n, mean=rep(0,p), sigma=Gr$C)
# estimate graph
## Not run: GRest &lt;- selectFast(X)

# plot result
## Not run: library(network)
## Not run: par(mfrow=c(1,2))
## Not run: gV &lt;- network(Gr$G)
## Not run: plot(gV,jitter=TRUE, usearrows = FALSE, label=1:p,displaylabels=TRUE)
## Not run: g &lt;- network(GRest$EW$G)
## Not run: plot(g, jitter=TRUE, usearrows = FALSE,  label=1:p,displaylabels=TRUE)
</code></pre>

<hr>
<h2 id='penalty'> Penalty function</h2><span id='topic+penalty'></span>

<h3>Description</h3>

<p>Compute the penalty function of GGMselect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalty(p,n, dmax=min(3,n-3,p-1), K=2.5) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalty_+3A_p">p</code></td>
<td>
<p> the number of variables. <code>p</code> should be greater than <code>1</code>.</p>
</td></tr>
<tr><td><code id="penalty_+3A_n">n</code></td>
<td>
<p> the sample size. <code>n</code> should be greater than
<code>3</code>.</p>
</td></tr>
<tr><td><code id="penalty_+3A_dmax">dmax</code></td>
<td>
<p> integer or <code>p</code>-dimensional vector of integers
smaller or equal to
<code>min(n-3, p-1)</code>. When <code>dmax</code> is a scalar, it gives the maximum
degree of the estimated graph. When  <code>dmax</code> is a vector,
<code>dmax[a]</code> gives the maximum degree of the node <code>a</code>. Default
value: <code>min(3,n-3,p-1)</code>.</p>
</td></tr>
<tr><td><code id="penalty_+3A_k">K</code></td>
<td>
<p>scalar or vector of real numbers larger than 1. Tuning parameter of the penalty function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available on <a href="../doc/Notice.pdf">../doc/Notice.pdf</a>
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>(max(Dmax)+1) x length(K)</code>. 
The entry <code>[d+1,k]</code> gives the value of the penalty for the dimension <code>d</code> and the parameter
<code>K[k]</code>. 
</p>


<h3>Author(s)</h3>

<p>Bouvier A, Giraud C, Huet S, Verzelen N </p>


<h3>References</h3>

<p> Please use <code>citation("GGMselect")</code> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+selectQE">selectQE</a></code>, <code><a href="#topic+selectMyFam">selectMyFam</a></code>,
<code><a href="#topic+selectFast">selectFast</a></code>, <code><a href="#topic+simulateGraph">simulateGraph</a></code>,
<code><a href="#topic+convertGraph">convertGraph</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>p=30
n=30
pen &lt;- penalty(p,n, 3)
</code></pre>

<hr>
<h2 id='selectFast'>  Estimate a graph in a Gaussian  Graphical Model: Fast procedure</h2><span id='topic+selectFast'></span>

<h3>Description</h3>

<p>Select a graph within the (data-driven) families of graphs <code>EW</code>, <code>C01</code>, and <code>LA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectFast(X, dmax=min(floor(nrow(X)/3),nrow(X)-3,ncol(X)-1),
           K=2.5, family="EW",
           min.ev=10**(-8), max.iter=200, eps=0.01,
           beta=nrow(X)*nrow(X)/2, tau=1/sqrt(nrow(X)*(ncol(X)-1)), h=0.001, T0=10,
           verbose=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectFast_+3A_x">X</code></td>
<td>
 <p><code>n x p</code> matrix where <code>n</code> is the sample size and
<code>p</code> the number of variables. <code>n</code> should be greater than
<code>3</code> and <code>p</code> greater than <code>1</code>.</p>
</td></tr>
<tr><td><code id="selectFast_+3A_dmax">dmax</code></td>
<td>
<p> integer or <code>p</code>-dimensional vector of integers
smaller or equal to
<code>min(n-3, p-1)</code>. When <code>dmax</code> is a scalar, it gives the maximum
degree of the estimated graph. When  <code>dmax</code> is a vector,
<code>dmax[a]</code> gives the maximum degree of the node <code>a</code>.</p>
</td></tr>
<tr><td><code id="selectFast_+3A_k">K</code></td>
<td>
<p> scalar or vector  with values greater than 1. Tuning
parameter of the penalty 
function.</p>
</td></tr>
<tr><td><code id="selectFast_+3A_family">family</code></td>
<td>
<p>character string or vector of character strings, among <code>"EW"</code>, <code>"LA"</code>, <code>"C01"</code>,
<code>c("C01","LA")</code> or <code>c("C01","LA","EW")</code>.  
</p>
</td></tr>
<tr><td><code id="selectFast_+3A_min.ev">min.ev</code></td>
<td>
<p> minimum eigenvalue for matrix inversion. </p>
</td></tr>
<tr><td><code id="selectFast_+3A_max.iter">max.iter</code>, <code id="selectFast_+3A_eps">eps</code>, <code id="selectFast_+3A_beta">beta</code>, <code id="selectFast_+3A_tau">tau</code>, <code id="selectFast_+3A_h">h</code>, <code id="selectFast_+3A_t0">T0</code></td>
<td>
<p> tuning parameters for the
Langevin Monte Carlo algorithm. Only used when
<code>family</code> is <code>"EW"</code> or <code>c("C01","LA","EW")</code>.</p>
</td></tr>
<tr><td><code id="selectFast_+3A_verbose">verbose</code></td>
<td>
<p> logical. If <code>TRUE</code> a trace of the current process is displayed in real time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available on <a href="../doc/Notice.pdf">../doc/Notice.pdf</a>
</p>


<h3>Value</h3>

<p>A list with components <code>"EW"</code>, <code>"LA"</code>, <code>"C01"</code>,
<code>"C01.LA"</code> and <code>"C01.LA.EW"</code>, according to the
<code>family</code> argument, each one with components:
</p>
<table>
<tr><td><code>Neighb</code></td>
<td>
<p>array of dimension  <code>p x max(dmax) x
      length(K)</code> or, when <code>length(K)</code> equals 1,
matrix of dimension <code>p x max(dmax)</code>.
<code>Neighb[a, , k ]</code> contains the indices
of the nodes connected
to node <code>a</code> for <code>K[k]</code>.</p>
</td></tr>
<tr><td><code>crit.min</code></td>
<td>
<p>vector of dimension <code>length(K)</code>.
It gives the minimal values of the selection criterion
for each value of <code>K</code></p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>array of dimension <code>p x p x length(K)</code> or, when
<code>length(K)</code> equals 1, matrix of dimension <code>p x p</code>.
<code>G[,,k]</code> gives the adjacency matrix for <code>K[k]</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bouvier A, Giraud C, Huet S, Verzelen N.</p>


<h3>References</h3>

<p>Please use <code>citation("GGMselect")</code>.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+selectQE">selectQE</a></code>, <code><a href="#topic+selectMyFam">selectMyFam</a></code>,
<code><a href="#topic+simulateGraph">simulateGraph</a></code>, <code><a href="#topic+penalty">penalty</a></code>,
<code><a href="#topic+convertGraph">convertGraph</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>p=30
n=30
# simulate graph
eta=0.11
Gr &lt;- simulateGraph(p,eta)
# simulate data
X &lt;- rmvnorm(n, mean=rep(0,p), sigma=Gr$C)
# estimate graph
GRest &lt;- selectFast(X, family="C01")

# plot result
library(network)
par(mfrow=c(1,2))
gV &lt;- network(Gr$G)
plot(gV,jitter=TRUE, usearrows = FALSE, label=1:p,displaylabels=TRUE)
g &lt;- network(GRest$C01$G)
plot(g, jitter=TRUE, usearrows = FALSE,  label=1:p,displaylabels=TRUE)
</code></pre>

<hr>
<h2 id='selectMyFam'>Select a graph within a given family of graphs in  Gaussian Graphical Modeling.</h2><span id='topic+selectMyFam'></span>

<h3>Description</h3>

<p>Select a graph within a given family of graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectMyFam(X, MyFamily, K=2.5, min.ev=10**(-8))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectMyFam_+3A_x">X</code></td>
<td>
 <p><code>n x p</code> matrix where <code>n</code> is the sample size and
<code>p</code> the number of variables. <code>n</code> should be greater than
<code>3</code> and <code>p</code> greater than <code>1</code>.</p>
</td></tr>
<tr><td><code id="selectMyFam_+3A_myfamily">MyFamily</code></td>
<td>
<p> list of pxp adjacency matrices corresponding to
graphs with degree less or equal to <code>n-3</code>.</p>
</td></tr>
<tr><td><code id="selectMyFam_+3A_k">K</code></td>
<td>
<p> scalar or vector with values larger than 1. Tuning
parameter of the penalty 
function.</p>
</td></tr>
<tr><td><code id="selectMyFam_+3A_min.ev">min.ev</code></td>
<td>
<p> minimum eigenvalue for matrix inversion. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available on <a href="../doc/Notice.pdf">../doc/Notice.pdf</a>
</p>


<h3>Value</h3>

<table>
<tr><td><code>Neighb</code></td>
<td>
<p>array of dimension  <code>p x dmax x
       length(K)</code> where <code>dmax</code> is the maximum degree of the graphs
in <code>MyFamily</code>. When <code>K</code> is of length 1, matrix of
dimension <code>p x dmax</code>.
<code>Neighb[a, , k ]</code> contains the indices
of the nodes connected
to node <code>a</code> for <code>K[k]</code>.</p>
</td></tr>
<tr><td><code>crit.min</code></td>
<td>
<p>vector of dimension <code>length(K)</code>.
The minimal values of the selection criterion
for each value of <code>K</code>.</p>
</td></tr>
<tr><td><code>ind.min</code></td>
<td>
<p>vector of dimension <code>length(K)</code>.
Indices of the families for which the  criterion is minimum.</p>
</td></tr> 	 
<tr><td><code>G</code></td>
<td>
<p>array of dimension <code>p x p x length(K)</code> or,
when <code>length(K)</code> equals 1, matrix of
dimension <code>p x p</code>.
<code>G[,,k]</code> gives the adjacency matrix for <code>K[k]</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Adjacency matrices can be generated from lists of connected nodes
by using the function <code><a href="#topic+convertGraph">convertGraph</a></code></p>


<h3>Author(s)</h3>

<p>Bouvier A, Giraud C, Huet S, Verzelen N.</p>


<h3>References</h3>

<p>Please use <code>citation("GGMselect")</code>.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+selectFast">selectFast</a></code>, <code><a href="#topic+selectQE">selectQE</a></code>,
<code><a href="#topic+simulateGraph">simulateGraph</a></code>, <code><a href="#topic+penalty">penalty</a></code>,
<code><a href="#topic+convertGraph">convertGraph</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>p=30
n=30
# generate graph
eta=0.11
Gr &lt;- simulateGraph(p,eta)
# generate data
X &lt;- rmvnorm(n, mean=rep(0,p), sigma=Gr$C)
# generate a family of candidate graphs with glasso
library("glasso")
MyFamily &lt;- NULL
for (j in 1:3){
  MyFamily[[j]] &lt;- abs(sign(glasso(cov(X),rho=j/5)$wi))
  diag(MyFamily[[j]]) &lt;- 0
}
# select a graph within MyFamily
GMF &lt;- selectMyFam(X,MyFamily)
# plot the result
library(network)
par(mfrow=c(1,2))
gV &lt;- network(Gr$G)
plot(gV,jitter=TRUE, usearrows = FALSE, label=1:p,displaylabels=TRUE)
gMyFam &lt;- network(GMF$G)
plot(gMyFam, jitter=TRUE, usearrows = FALSE,  label=1:p,displaylabels=TRUE)
</code></pre>

<hr>
<h2 id='selectQE'>  Estimate a graph in a Gaussian  Graphical Model: Quasi Exhaustive search</h2><span id='topic+selectQE'></span>

<h3>Description</h3>

<p>Select a graph within the family of graphs <code>QE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectQE(X, dmax=min(3,nrow(X)-3,ncol(X)-1), K=2.5,
   min.ev=10**(-8), max.iter=10**6, max.nG=10**8, max.size=10**8,
   verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectQE_+3A_x">X</code></td>
<td>
 <p><code>n x p</code> matrix where <code>n</code> is the sample size and
<code>p</code> the number of variables. <code>n</code> should be greater than
<code>3</code> and <code>p</code> greater than <code>1</code>.</p>
</td></tr>
<tr><td><code id="selectQE_+3A_dmax">dmax</code></td>
<td>
<p> integer or <code>p</code>-dimensional vector of integers
smaller or equal to
<code>min(n-3, p-1)</code>. When <code>dmax</code> is a scalar, it gives the maximum
degree of the estimated graph. When  <code>dmax</code> is a vector,
<code>dmax[a]</code> gives the maximum degree of the node <code>a</code>.</p>
</td></tr>
<tr><td><code id="selectQE_+3A_k">K</code></td>
<td>
<p> scalar or vector with values greater than 1. Tuning
parameter in the penalty 
function.</p>
</td></tr>
<tr><td><code id="selectQE_+3A_min.ev">min.ev</code></td>
<td>
<p> minimum eigenvalue for matrix inversion. </p>
</td></tr>
<tr><td><code id="selectQE_+3A_max.iter">max.iter</code></td>
<td>
<p> integer. Maximum number of stepwise
iterations.</p>
</td></tr>
<tr><td><code id="selectQE_+3A_max.ng">max.nG</code></td>
<td>
<p> integer.  Maximum number of graphs considered in the 
exhaustive search. Stepwise procedure beyond. </p>
</td></tr>
<tr><td><code id="selectQE_+3A_max.size">max.size</code></td>
<td>
<p> integer. Maximum number of calculations of the
residuals sums of squares. Execution stopped beyond.</p>
</td></tr>
<tr><td><code id="selectQE_+3A_verbose">verbose</code></td>
<td>
<p> logical. If <code>TRUE</code> a trace of the current process is displayed in real time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available on <a href="../doc/Notice.pdf">../doc/Notice.pdf</a>
</p>


<h3>Value</h3>

<table>
<tr><td><code>Neighb</code></td>
<td>
<p>array of dimension  <code>p x max(dmax) x length(K)</code> or, when
<code>length(K)</code> equals 1, matrix of dimension <code>p x max(dmax)</code>. <code>Neighb[a, , k ]</code> contains the indices of the nodes connected
to node <code>a</code> for <code>K[k]</code>.</p>
</td></tr>
<tr><td><code>crit.min</code></td>
<td>
<p>vector of dimension <code>length(K)</code>.
The minimal values of the selection criterion
for each value of <code>K</code>.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>array of dimension <code>p x p x length(K)</code> or, when
<code>length(K)</code> equals 1, matrix of dimension <code>p x p</code>.
<code>G[,,k]</code> gives the adjacency matrix for <code>K[k]</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bouvier A, Giraud C, Huet S, Verzelen N.</p>


<h3>References</h3>

<p>Please use <code>citation("GGMselect")</code>.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+selectFast">selectFast</a></code>, <code><a href="#topic+selectMyFam">selectMyFam</a></code>,
<code><a href="#topic+simulateGraph">simulateGraph</a></code>, <code><a href="#topic+penalty">penalty</a></code>,
<code><a href="#topic+convertGraph">convertGraph</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>p=30
n=30
# simulate graph
eta=0.11
Gr &lt;- simulateGraph(p,eta)
# simulate data
X &lt;- rmvnorm(n, mean=rep(0,p), sigma=Gr$C)
# estimate graph
## Not run: GQE &lt;- selectQE(X)

# plot the result
## Not run: library(network)
## Not run: par(mfrow=c(1,2))
## Not run: gV &lt;- network(Gr$G)
## Not run: plot(gV,jitter=TRUE, usearrows = FALSE, label=1:p,displaylabels=TRUE)
## Not run: gQE &lt;- network(GQE$G)
## Not run: plot(gQE, jitter=TRUE, usearrows = FALSE,  label=1:p,displaylabels=TRUE)
</code></pre>

<hr>
<h2 id='simulateGraph'> Generate sparse Gaussian Graphical Models</h2><span id='topic+simulateGraph'></span>

<h3>Description</h3>

<p>Generate random covariance matrices <code>C</code> with sparse inverse. The
Gaussian law <code>N(0,C)</code> is then a sparse
(non-uniform) Gaussian Graphical Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateGraph(p, eta, extraeta = eta/5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateGraph_+3A_p">p</code></td>
<td>
<p> integer. Number of rows and columns  of <code>C</code>. Should be
greater than <code>1</code>.</p>
</td></tr>
<tr><td><code id="simulateGraph_+3A_eta">eta</code></td>
<td>
<p> real number in (0,1). Proportion of edges in
subgroups. Small values of <code>eta</code> give  sparse graphs. </p>
</td></tr>
<tr><td><code id="simulateGraph_+3A_extraeta">extraeta</code></td>
<td>
<p> real number in (0,1). Proportion of edges inter groups. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available on <a href="../doc/Notice.pdf">../doc/Notice.pdf</a>
</p>


<h3>Value</h3>

<table>
<tr><td><code>G</code></td>
<td>
<p> p x p matrix. Adjacency matrix of the graph.</p>
</td></tr>
<tr><td><code>Dmax</code></td>
<td>
<p>integer. Maximum degree of the graph.</p>
</td></tr>
<tr><td><code>Neighb</code></td>
<td>
<p>array of dimension  <code>p x Dmax</code>.
<code>Neighb[a, ]</code> contains the indices
of the nodes connected
to node <code>a</code>.</p>
</td></tr>
<tr><td><code>Nnodes</code></td>
<td>
<p> integer. Number of nodes.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p> p x p matrix. Covariance matrix.</p>
</td></tr>
<tr><td><code>PCor</code></td>
<td>
<p> p x p matrix. Partial correlation matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bouvier A, Giraud C, Huet S, Verzelen N </p>


<h3>References</h3>

<p>Please use <code>citation("GGMselect")</code>.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+selectQE">selectQE</a></code>, <code><a href="#topic+selectMyFam">selectMyFam</a></code>,
<code><a href="#topic+selectFast">selectFast</a></code>, <code><a href="#topic+penalty">penalty</a></code>,
<code><a href="#topic+convertGraph">convertGraph</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a graph
p=30
eta=0.13
Gr &lt;- simulateGraph(p,eta)

# plot the graph
library(network)
par(mfrow=c(1,1))
gV &lt;- network(Gr$G)
plot(gV,jitter=TRUE, usearrows = FALSE, label=1:p,displaylabels=TRUE)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
