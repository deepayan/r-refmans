<!DOCTYPE html><html lang="en"><head><title>Help for package hacksig</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hacksig}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hacksig'><p>hacksig: A Tidy Framework to Hack Gene Expression Signatures</p></a></li>
<li><a href='#check_sig'><p>Check signatures feasibility</p></a></li>
<li><a href='#get_sig_genes'><p>Get signature gene identifiers</p></a></li>
<li><a href='#get_sig_info'><p>Display available gene signatures</p></a></li>
<li><a href='#hack_cinsarc'><p>Hack the CINSARC classification</p></a></li>
<li><a href='#hack_class'><p>Hack signature classes</p></a></li>
<li><a href='#hack_estimate'><p>Hack the ESTIMATE scores</p></a></li>
<li><a href='#hack_immunophenoscore'><p>Hack the Immunophenoscore</p></a></li>
<li><a href='#hack_sig'><p>Score samples by gene signatures</p></a></li>
<li><a href='#ss_methods'><p>Single sample scoring methods</p></a></li>
<li><a href='#test_expr'><p>A toy gene expression matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Tidy Framework to Hack Gene Expression Signatures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of cancer transcriptomics gene signatures as well as a 
    simple and tidy interface to compute single sample enrichment scores either 
    with the original procedure or with three alternatives:
    the "combined z-score" of Lee et al. (2008) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1000217">doi:10.1371/journal.pcbi.1000217</a>&gt;,
    the "single sample GSEA" of Barbie et al. (2009) &lt;<a href="https://doi.org/10.1038%2Fnature08460">doi:10.1038/nature08460</a>&gt; and 
    the "singscore" of Foroutan et al. (2018) &lt;<a href="https://doi.org/10.1186%2Fs12859-018-2435-4">doi:10.1186/s12859-018-2435-4</a>&gt;.
    The 'get_sig_info()' function can be used to retrieve information about each 
    signature implemented.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Acare/hacksig">https://github.com/Acare/hacksig</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Acare/hacksig/issues">https://github.com/Acare/hacksig/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.7), future.apply (&ge; 1.8.1), rlang (&ge; 0.4.11),
stats (&ge; 4.0.5), tibble (&ge; 3.1.5), tidyr (&ge; 1.1.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, future (&ge; 1.22.1), ggplot2 (&ge; 3.3.5), knitr (&ge;
1.36), msigdbr (&ge; 7.4.1), purrr (&ge; 0.3.4), rmarkdown (&ge;
2.11)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-17 13:57:19 UTC; andrea</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrea Carenzo <a href="https://orcid.org/0000-0001-6804-9984"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Loris De Cecco <a href="https://orcid.org/0000-0002-7066-473X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Federico Pistore [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrea Carenzo &lt;andrea.carenzo@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-17 14:22:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hacksig'>hacksig: A Tidy Framework to Hack Gene Expression Signatures</h2><span id='topic+hacksig'></span><span id='topic+_PACKAGE'></span><span id='topic+hacksig-package'></span>

<h3>Description</h3>

<p>The <code>hacksig</code> package has been designed for the purpose of simplifying the way
in which gene expression signatures scores are computed. It is a manually
curated collection of gene expression signatures found in literature and makes
use of three different single sample score calculation methods. Moreover,
parallel computation is supported through the <code>future</code> framework.
</p>


<h3>Get gene signatures scores in different ways</h3>

<p>The main function of the package is <code><a href="#topic+hack_sig">hack_sig()</a></code> and it can be used to:
</p>

<ul>
<li><p> obtain single sample scores with one of three methods (z-score, ssGSEA,
singscore) for a custom list of gene signatures;
</p>
</li>
<li><p> obtain single sample scores for a number of manually curated gene signatures
either with the original publication method or with one of the three single
sample methods.
</p>
</li></ul>

<p>Once single sample scores are obtained, you can assign your samples into
signature classes with <code><a href="#topic+hack_class">hack_class()</a></code>.
</p>
<p>In addition, other more complex methods are implemented through:
</p>

<ul>
<li> <p><code><a href="#topic+hack_cinsarc">hack_cinsarc()</a></code>, for the CINSARC classification;
</p>
</li>
<li> <p><code><a href="#topic+hack_estimate">hack_estimate()</a></code>, for the ESTIMATE method;
</p>
</li>
<li> <p><code><a href="#topic+hack_immunophenoscore">hack_immunophenoscore()</a></code>, for the Immunophenoscore.
</p>
</li></ul>

<p>Information about implemented signatures can be obtained with <code><a href="#topic+get_sig_info">get_sig_info()</a></code>.
</p>


<h3>Check if gene signatures are applicable to your data</h3>

<p>Sometimes your gene expression matrix can miss some genes due to some prior
filtering procedure. The function <code><a href="#topic+check_sig">check_sig()</a></code> can be used to check how many
genes your expression matrix contain for every input signature.
</p>


<h3>Author(s)</h3>

<p>Andrea Carenzo, Loris De Cecco, Federico Pistore
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Acare/hacksig">https://github.com/Acare/hacksig</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Acare/hacksig/issues">https://github.com/Acare/hacksig/issues</a>
</p>
</li></ul>


<hr>
<h2 id='check_sig'>Check signatures feasibility</h2><span id='topic+check_sig'></span>

<h3>Description</h3>

<p><code>check_sig()</code> is a helper function that shows useful information about signatures
that you want to test on your gene expression matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_sig(expr_data, signatures = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_sig_+3A_expr_data">expr_data</code></td>
<td>
<p>A normalized gene expression matrix (or data frame) with
gene symbols as row names and samples as columns.</p>
</td></tr>
<tr><td><code id="check_sig_+3A_signatures">signatures</code></td>
<td>
<p>It can be a list of signatures or a character vector indicating
keywords for a group of signatures. The default (<code>"all"</code>) will cause the
function to check for all the signatures implemented in <code>hacksig</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with a number of rows equal to the number of input signatures
and five columns:
</p>

<ul>
<li> <p><code>n_genes</code> gives the number of genes composing a signature;
</p>
</li>
<li> <p><code>n_present</code> and <code>frac_present</code> are the number and fraction of genes in a
signature which are present in <code>expr_data</code>, respectively;
</p>
</li>
<li> <p><code>missing_genes</code> returns a named list of missing gene symbols for each signature.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+get_sig_info">get_sig_info()</a></code>, <code><a href="#topic+hack_sig">hack_sig()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_sig(test_expr)
check_sig(test_expr, "estimate")
</code></pre>

<hr>
<h2 id='get_sig_genes'>Get signature gene identifiers</h2><span id='topic+get_sig_genes'></span>

<h3>Description</h3>

<p>Obtain gene signatures implemented in <code>hacksig</code> as a named list of gene symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sig_genes(keywords = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sig_genes_+3A_keywords">keywords</code></td>
<td>
<p>A character vector indicating keywords for a group of signatures.
The default (<code>"all"</code>) will cause the function to check for all the signatures
implemented in <code>hacksig</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of gene signatures.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_sig_info">get_sig_info()</a></code> to get valid keywords for signatures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_sig_genes()
get_sig_genes("estimate")
</code></pre>

<hr>
<h2 id='get_sig_info'>Display available gene signatures</h2><span id='topic+get_sig_info'></span>

<h3>Description</h3>

<p><code>get_sig_info()</code> returns information about all gene signatures implemented in
<code>hacksig</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sig_info()
</code></pre>


<h3>Value</h3>

<p>A tibble with one row per signature and four columns:
</p>

<ul>
<li> <p><code>signature_id</code>, a unique identifier associated to a signature;
</p>
</li>
<li> <p><code>signature_keywords</code>, valid keywords to use in the <code>signatures</code> argument of
<code>hack_sig()</code> and <code>check_sig()</code> as well as in the <code>keywords</code> argument of
<code>get_sig_genes()</code>;
</p>
</li>
<li> <p><code>publication_doi</code>, the original publication DOI;
</p>
</li>
<li> <p><code>description</code>, a brief description about the signature.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+check_sig">check_sig()</a></code>, <code><a href="#topic+hack_sig">hack_sig()</a></code>, <code><a href="#topic+get_sig_genes">get_sig_genes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_sig_info()
</code></pre>

<hr>
<h2 id='hack_cinsarc'>Hack the CINSARC classification</h2><span id='topic+hack_cinsarc'></span>

<h3>Description</h3>

<p>Given a gene expression matrix and a 0-1 vector indicating the distant metastasis
status of samples, <code>hack_cinsarc()</code> classifies samples into one of two risk
classes, C1 or C2, using the CINSARC signature as implemented in
<em>Chibon et al., 2010</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hack_cinsarc(expr_data, dm_status)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hack_cinsarc_+3A_expr_data">expr_data</code></td>
<td>
<p>A normalized gene expression matrix (or data frame) with
gene symbols as row names and samples as columns.</p>
</td></tr>
<tr><td><code id="hack_cinsarc_+3A_dm_status">dm_status</code></td>
<td>
<p>A numeric vector specifying whether a sample has either (1)
or not (0) developed distant metastasis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CINSARC (<em>Complexity INdex in SARComas</em>) is a prognostic 67-gene signature
related to mitosis and control of chromosome integrity.
It was developed to improve metastatic outcome prediction in soft tissue
sarcomas over the FNCLCC (<em>Fédération Francaise des Centres de Lutte Contre
le Cancer</em>) grading system.
</p>


<h3>Value</h3>

<p>A tibble with one row for each sample in <code>expr_data</code> and two columns:
<code>sample_id</code> and <code>cinsarc_class</code>.
</p>


<h3>Algorithm</h3>

<p>The CINSARC method implemented in <code>hacksig</code> makes use of leave-one-out cross
validation (LOOCV) to classify samples into C1/C2 risk groups (see <em>Lesluyes &amp; Chibon, 2020</em>).
First, gene expression values are centered by their mean across samples.
Then, for each iteration of the LOOCV, mean normalized gene values are computed
by metastasis group (i.e. compute the metastatic centroids). Then, one minus the
Spearman's correlation between centered samples and metastatic centroids are computed.
Finally, if a sample is more correlated to the non-metastatic centroid, then
it is assigned to the C1 class (low risk). Conversely, if a sample is more
correlated to the metastatic centroid, then it is assigned to the C2 class (high risk).
</p>


<h3>Source</h3>

<p><a href="https://codeocean.com/capsule/4933686/tree/v4">codeocean.com/capsule/4933686/tree/v4</a>
</p>


<h3>References</h3>

<p>Chibon, F., Lagarde, P., Salas, S., Pérot, G., Brouste, V., Tirode, F.,
Lucchesi, C., de Reynies, A., Kauffmann, A., Bui, B., Terrier, P.,
Bonvalot, S., Le Cesne, A., Vince-Ranchère, D., Blay, J. Y., Collin, F.,
Guillou, L., Leroux, A., Coindre, J. M., &amp; Aurias, A. (2010). Validated
prediction of clinical outcome in sarcomas and multiple types of cancer on
the basis of a gene expression signature related to genome complexity.
<em>Nature medicine</em>, 16(7), 781–787. doi: <a href="https://doi.org/10.1038/nm.2174">10.1038/nm.2174</a>.
</p>
<p>Lesluyes, T., &amp; Chibon, F. (2020). A Global and Integrated
Analysis of CINSARC-Associated Genetic Defects. <em>Cancer research</em>, 80(23),
5282–5290. doi: <a href="https://doi.org/10.1158/0008-5472.CAN-20-0512">10.1158/0008-5472.CAN-20-0512</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random distant metastasis outcome
set.seed(123)
test_dm_status &lt;- sample(c(0, 1), size = ncol(test_expr), replace = TRUE)

hack_cinsarc(test_expr, test_dm_status)
</code></pre>

<hr>
<h2 id='hack_class'>Hack signature classes</h2><span id='topic+hack_class'></span>

<h3>Description</h3>

<p><code>hack_class()</code> is supposed to be used in combination after <code><a href="#topic+hack_sig">hack_sig()</a></code> in
order to classify your samples in one of two or more signature classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hack_class(sig_data, cutoff = "original")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hack_class_+3A_sig_data">sig_data</code></td>
<td>
<p>A tibble result of a call to <code><a href="#topic+hack_sig">hack_sig()</a></code>.</p>
</td></tr>
<tr><td><code id="hack_class_+3A_cutoff">cutoff</code></td>
<td>
<p>A character specifying which function to use to categorize
samples by signature scores. Can be one of:
</p>

<ul>
<li> <p><code>"original"</code> (default), apply the original publication method; if
categorization is not expected, the median score is used as a threshold;
</p>
</li>
<li> <p><code>"mean"/"median"</code>, samples will be classified as <code>"low"</code> or <code>"high"</code> with
respect to the mean/median signature score, respectively;
</p>
</li>
<li> <p><code>"tertiles"</code>, samples will be classified as <code>"&lt;= T1"</code> (score lower than
first tertile), <code>"(T1, T2]"</code> (score between first and second tertiles),
<code>"&gt; T2"</code> (score higher than second tertile);
</p>
</li>
<li> <p><code>"quartiles"</code>, samples will be classified as <code>"&lt;= Q1"</code> (score lower than
first quartile), <code>"(Q1, Q2]"</code> (score between first and second quartiles),
<code>"(Q2, Q3]"</code> (score between second and third quartiles), <code>"&gt; Q3"</code> (score
higher than third quartile).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the same dimension as <code>sig_data</code>, a column <code>sample_id</code>
indicating sample identifiers and one column for each input signature giving
signature classes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hack_sig">hack_sig()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
hack_sig(test_expr, "immune") %&gt;% hack_class()
</code></pre>

<hr>
<h2 id='hack_estimate'>Hack the ESTIMATE scores</h2><span id='topic+hack_estimate'></span>

<h3>Description</h3>

<p>Obtain <em>Immune</em>, <em>Stroma</em>, <em>ESTIMATE</em> and <em>Tumor Purity</em> scores from a cohort
of samples, using the method implemented in <em>Yoshihara et al., 2013</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hack_estimate(expr_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hack_estimate_+3A_expr_data">expr_data</code></td>
<td>
<p>A normalized gene expression matrix (or data frame) with
gene symbols as row names and samples as columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ESTIMATE (<em>Estimation of STromal and Immune cells in MAlignant Tumors
using Expression data</em>) method was developed with the aim to estimate the
fraction of tumor cells in a sample by using gene expression instead of copy
number data. The fundamental assumption of this method is that the tumor
microenvironment is a very rich and dynamic ecosystem, in which immune
infiltrating cells and stroma play a major role. The ESTIMATE score is
defined as the combination (i.e. sum) of immune and stroma scores and can be
thought of as a <em>&quot;non-tumor score&quot;</em>. Consequently, a high ESTIMATE enrichment
gives a low tumor purity score and viceversa.
</p>


<h3>Value</h3>

<p>A tibble with one row for each sample in <code>expr_data</code> and five columns:
<code>sample_id</code>, <code>immune_score</code>, <code>stroma_score</code>, <code>estimate_score</code> and <code>purity_score</code>.
</p>


<h3>Algorithm</h3>

<p>Raw immune and stromal signatures scores are computed using single sample GSEA
with rank normalization (<em>Barbie et al., 2009</em>).
Then, the ESTIMATE score is computed by summing the immune and stroma scores.
Finally, the tumor purity score is obtained with the following formula:
</p>
<p style="text-align: center;"><code class="reqn">Purity = cos(0.6049872018 + 0.0001467884 * ESTIMATE)</code>
</p>



<h3>Source</h3>

<p><a href="https://bioinformatics.mdanderson.org/public-software/estimate/">bioinformatics.mdanderson.org/public-software/estimate/</a>
</p>


<h3>References</h3>

<p>Barbie, D. A., Tamayo, P., Boehm, J. S., Kim, S. Y., Moody, S. E., Dunn, I. F.,
Schinzel, A. C., Sandy, P., Meylan, E., Scholl, C., Fröhling, S., Chan, E. M.,
Sos, M. L., Michel, K., Mermel, C., Silver, S. J., Weir, B. A., Reiling, J. H.,
Sheng, Q., Gupta, P. B., … Hahn, W. C. (2009). Systematic RNA interference
reveals that oncogenic KRAS-driven cancers require TBK1. <em>Nature</em>, 462(7269),
108–112. doi: <a href="https://doi.org/10.1038/nature08460">10.1038/nature08460</a>.
</p>
<p>Yoshihara, K., Shahmoradgoli, M., Martínez, E., Vegesna, R.,
Kim, H., Torres-Garcia, W., Treviño, V., Shen, H., Laird, P. W., Levine, D. A.,
Carter, S. L., Getz, G., Stemke-Hale, K., Mills, G. B., &amp; Verhaak, R. G. (2013).
Inferring tumour purity and stromal and immune cell admixture from
expression data. <em>Nature communications</em>, 4, 2612. doi: <a href="https://doi.org/10.1038/ncomms3612">10.1038/ncomms3612</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hack_estimate(test_expr)
</code></pre>

<hr>
<h2 id='hack_immunophenoscore'>Hack the Immunophenoscore</h2><span id='topic+hack_immunophenoscore'></span>

<h3>Description</h3>

<p>Obtain various immune biomarkers scores, which combined together give the
immunophenoscore (<em>Charoentong et al., 2017</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hack_immunophenoscore(expr_data, extract = "ips")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hack_immunophenoscore_+3A_expr_data">expr_data</code></td>
<td>
<p>A normalized gene expression matrix (or data frame) with
gene symbols as row names and samples as columns.</p>
</td></tr>
<tr><td><code id="hack_immunophenoscore_+3A_extract">extract</code></td>
<td>
<p>A string controlling which type of biomarker scores you want
to obtain. Possible choices are:
</p>

<ul>
<li> <p><code>"ips"</code> (default), only raw and discrete IPS scores;
</p>
</li>
<li> <p><code>"class"</code>, IPS scores together with the four summary class scores;
</p>
</li>
<li> <p><code>"all"</code>, all possible biomarker scores.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The immunophenoscore is conceived as a quantification of tumor immunogenicity.
It is obtained by aggregating multiple immune biomarkers scores, which are
grouped into four major classes:
</p>

<ul>
<li> <p><em>MHC molecules</em> (<strong>MHC</strong>), expression of MHC class I, class II, and non-classical molecules;
</p>
</li>
<li> <p><em>Immunomodulators</em> (<strong>CP</strong>), expression of certain co-inhibitory and co-stimulatory molecules;
</p>
</li>
<li> <p><em>Effector cells</em> (<strong>EC</strong>), infiltration of activated CD8+/CD4+ T cells and Tem (effector memory) CD8+/CD4+ cells;
</p>
</li>
<li> <p><em>Suppressor cells</em> (<strong>SC</strong>), infiltration of immunosuppressive cells (Tregs and MDSCs).
</p>
</li></ul>

<p>The table below shows in detail the 26 immune biomarkers and cell types grouped
by class together with the number of genes which represent them:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Class</strong> | </td><td style="text-align: center;"> <strong>Biomarker/cell type</strong> | </td><td style="text-align: center;"> <strong>No. genes</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   MHC </td><td style="text-align: center;"> B2M </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MHC </td><td style="text-align: center;"> HLA-A </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MHC </td><td style="text-align: center;"> HLA-B </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MHC </td><td style="text-align: center;"> HLA-C </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MHC </td><td style="text-align: center;"> HLA-DPA1 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MHC </td><td style="text-align: center;"> HLA-DPB1 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MHC </td><td style="text-align: center;"> HLA-E </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MHC </td><td style="text-align: center;"> HLA-F </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MHC </td><td style="text-align: center;"> TAP1 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MHC </td><td style="text-align: center;"> TAP2 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CP </td><td style="text-align: center;"> CD27 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CP </td><td style="text-align: center;"> CTLA-4 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CP </td><td style="text-align: center;"> ICOS </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CP </td><td style="text-align: center;"> IDO1 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CP </td><td style="text-align: center;"> LAG3 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CP </td><td style="text-align: center;"> PD1 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CP </td><td style="text-align: center;"> PD-L1 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CP </td><td style="text-align: center;"> PD-L2 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CP </td><td style="text-align: center;"> TIGIT </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CP </td><td style="text-align: center;"> TIM3 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   EC </td><td style="text-align: center;"> Act CD4 </td><td style="text-align: center;"> 24 </td>
</tr>
<tr>
 <td style="text-align: left;">
   EC </td><td style="text-align: center;"> Act CD8 </td><td style="text-align: center;"> 26 </td>
</tr>
<tr>
 <td style="text-align: left;">
   EC </td><td style="text-align: center;"> Tem CD4 </td><td style="text-align: center;"> 27 </td>
</tr>
<tr>
 <td style="text-align: left;">
   EC </td><td style="text-align: center;"> Tem CD8 </td><td style="text-align: center;"> 25 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SC </td><td style="text-align: center;"> MDSC </td><td style="text-align: center;"> 20 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SC </td><td style="text-align: center;"> Treg </td><td style="text-align: center;"> 20 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A tibble with one row for each sample in <code>expr_data</code>, a column <code>sample_id</code>
indicating sample identifiers and a number of additional columns depending
on the choice of <code>extract</code>.
</p>


<h3>Algorithm</h3>

<p>Samplewise gene expression z-scores are obtained for each of 26 immune cell
types and biomarkers. Then, weighted averaged z-scores are computed for each
class and the raw immunophenoscore (<code class="reqn">IPS-raw</code>) results as the sum of the
four class scores. Finally, the immunophenoscore (<code class="reqn">IPS</code>) is given as an
integer value between 0 and 10 in the following way:
</p>

<ul>
<li> <p><code class="reqn">IPS = 0</code>, if <code class="reqn">IPS-raw \le 0</code>;
</p>
</li>
<li> <p><code class="reqn">IPS = [10 * (IPS-raw / 3)]</code>, if <code class="reqn">0 &lt; IPS-raw &lt; 3</code>;
</p>
</li>
<li> <p><code class="reqn">IPS = 10</code>, if <code class="reqn">IPS-raw \ge 3</code>.
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://github.com/icbi-lab/Immunophenogram">github.com/icbi-lab/Immunophenogram</a>
</p>


<h3>References</h3>

<p>Charoentong, P., Finotello, F., Angelova, M., Mayer, C.,
Efremova, M., Rieder, D., Hackl, H., &amp; Trajanoski, Z. (2017). Pan-cancer
Immunogenomic Analyses Reveal Genotype-Immunophenotype Relationships and
Predictors of Response to Checkpoint Blockade. <em>Cell reports</em>, 18(1), 248–262.
doi: <a href="https://doi.org/10.1016/j.celrep.2016.12.019">10.1016/j.celrep.2016.12.019</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hack_sig">hack_sig()</a></code> to compute Immunophenoscore biomarkers in different
ways (e.g. use <code>signatures = "ips"</code> and <code>method = "singscore"</code>).
</p>
<p><code><a href="#topic+check_sig">check_sig()</a></code> to check if all/most of the Immunophenoscore biomarkers are
present in your expression matrix (use <code>signatures = "ips"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hack_immunophenoscore(test_expr)
hack_immunophenoscore(test_expr, extract = "class")
</code></pre>

<hr>
<h2 id='hack_sig'>Score samples by gene signatures</h2><span id='topic+hack_sig'></span>

<h3>Description</h3>

<p>Compute gene signature single sample scores in one of different ways.
You can choose to apply either the <em>original</em> procedure or one of three single
sample scoring methods: the combined z-score (<em>Lee et al., 2008</em>), the single
sample GSEA (<em>Barbie et al., 2009</em>) or the singscore method (<em>Foroutan et al., 2018</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hack_sig(
  expr_data,
  signatures = "all",
  method = "original",
  direction = "none",
  sample_norm = "raw",
  rank_norm = "none",
  alpha = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hack_sig_+3A_expr_data">expr_data</code></td>
<td>
<p>A normalized gene expression matrix (or data frame) with
gene symbols as row names and samples as columns.</p>
</td></tr>
<tr><td><code id="hack_sig_+3A_signatures">signatures</code></td>
<td>
<p>It can be a list of signatures or a character vector indicating
keywords for a group of signatures. The default (<code>"all"</code>) will cause the
function to compute single sample scores for all the signatures implemented
in <code>hacksig</code>.</p>
</td></tr>
<tr><td><code id="hack_sig_+3A_method">method</code></td>
<td>
<p>A character string specifying which method to use for computing
the single sample score for each signature. You can choose one of:
</p>

<ul>
<li> <p><code>"original"</code>, the original method used by the authors of the signature;
</p>
</li>
<li> <p><code>"zscore"</code>, the combined z-score method;
</p>
</li>
<li> <p><code>"ssgsea"</code>, the single sample GSEA method;
</p>
</li>
<li> <p><code>"singscore"</code>, the singscore method;
</p>
</li></ul>
</td></tr>
<tr><td><code id="hack_sig_+3A_direction">direction</code></td>
<td>
<p>A character string specifying the <strong>singscore</strong> computation
method depending on the direction of the signatures. Can be on of:
</p>

<ul>
<li> <p><code>"none"</code> (default), undirected signatures, that is you do not know whether
the genes are up- or down-regulated;
</p>
</li>
<li> <p><code>"up"</code>, all genes in the signature are supposed to be up-regulated;
</p>
</li>
<li> <p><code>"down"</code>, all genes in the signature are supposed to be down-regulated;
</p>
</li></ul>
</td></tr>
<tr><td><code id="hack_sig_+3A_sample_norm">sample_norm</code></td>
<td>
<p>A character string specifying the type of normalization
affecting the <strong>single sample GSEA</strong> scores. Can be one of:
</p>

<ul>
<li> <p><code>"raw"</code> (default), obtain raw scores;
</p>
</li>
<li> <p><code>"separate"</code>, normalize raw scores in <code class="reqn">[0, 1]</code> across samples for
each signature separately.
</p>
</li>
<li> <p><code>"all"</code>, normalize raw scores both across samples and signatures.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hack_sig_+3A_rank_norm">rank_norm</code></td>
<td>
<p>A character string specifying how gene expression ranks should
be normalized in the <strong>single sample GSEA</strong> procedure. Valid choices are:
</p>

<ul>
<li> <p><code>"none"</code> (default), no rank normalization;
</p>
</li>
<li> <p><code>"rank"</code>, ranks are multiplied by <code>10000 / nrow(expr_data)</code>;
</p>
</li>
<li> <p><code>"logrank"</code>, normalized ranks are logged.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hack_sig_+3A_alpha">alpha</code></td>
<td>
<p>A numeric scalar. Exponent in the running sum of the <strong>single sample GSEA</strong>
score calculation which weighs the gene ranks. Defaults to <code class="reqn">\alpha = 0.25</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>"original"</code> method, it is intended the procedure used in the original
publication by the authors for computing the signature score.
<code>hack_sig()</code> can compute signature scores with the original method only if
this is a relatively simple procedure (e.g weighted sum of fitted model
coefficients and expression values).
For more complex methods, such as CINSARC, ESTIMATE and Immunophenoscore,
use the dedicated functions.
</p>
<p>If <code>signatures</code> is a custom list of gene signatures, then the <code>"ssgsea"</code>
method will be applied by default.
</p>


<h3>Value</h3>

<p>A tibble with one row for each sample in <code>expr_data</code>, a column <code>sample_id</code>
indicating sample identifiers and one column for each input signature giving
single sample scores.
</p>


<h3>Algorithm</h3>

<p>This section gives a brief explanation of how single sample scores are obtained
from different methods.
</p>


<h4>Combined z-score</h4>

<p>Gene expression values are centered by their mean value and scaled by their
standard deviation across samples for each gene (z-scores). Then, for each
sample and signature, corresponding z-scores are added up and divided by the
square root of the signature size (i.e. the number of genes composing a signature).
</p>
<p>The combined z-score method is also implemented in the R package <code>GSVA</code>
(<em>Hänzelmann et al., 2013</em>).
</p>



<h4>Single sample GSEA</h4>

<p>For each sample, genes are ranked by expression value in increasing order and
rank normalization may follow (see argument <code>rank_norm</code>). Then, two probability-like
vectors are computed for each sample and signature:
</p>

<ul>
<li> <p><code class="reqn">P_{in}</code>, the cumulative sum of weighted ranks divided by their total
sum for genes in the signature;
</p>
</li>
<li> <p><code class="reqn">P_{out}</code>, the cumulative sum of ones (indicating genes not in the signature)
divided by the number of genes not in the signature.
</p>
</li></ul>

<p>The single sample GSEA score is obtained by adding up the elements of the
vector difference <code class="reqn">P_{in} - P_{out}</code>.
Finally, single sample scores could be normalized either across samples or across
gene signatures and samples.
</p>
<p>The single sample GSEA method is also implemented in the R package <code>GSVA</code>
(<em>Hänzelmann et al., 2013</em>).
</p>



<h4>Singscore</h4>

<p>For signatures whose genes are supposed to be up- or down-regulated, genes
are ranked by expression value in increasing or decreasing order, respectively.
For signatures whose direction is unknown, genes are ranked by absolute expression
in increasing order and are median-centered.
Enrichment scores are then computed for each sample and signature by averaging
gene ranks for genes in the signature.
Finally, normalized scores are obtained by subtracting the theoretical minimum
mean rank from the score and dividing by the difference between the theoretical
maximum and minimum mean ranks.
</p>
<p>The <code>hacksig</code> implementation of this method works only with unidirectional (i.e.
all genes up- or down-regulated) and undirected gene signatures.
If you want to get single sample scores for bidirectional gene signatures (i.e.
signatures composed of both up- and down-regulated genes), please use the R
package <code>singscore</code> (<em>Foroutan et al., 2018</em>).
</p>



<h3>References</h3>

<p>Barbie, D. A., Tamayo, P., Boehm, J. S., Kim, S. Y., Moody, S. E., Dunn, I. F.,
Schinzel, A. C., Sandy, P., Meylan, E., Scholl, C., Fröhling, S., Chan, E. M.,
Sos, M. L., Michel, K., Mermel, C., Silver, S. J., Weir, B. A., Reiling, J. H.,
Sheng, Q., Gupta, P. B., … Hahn, W. C. (2009). Systematic RNA interference
reveals that oncogenic KRAS-driven cancers require TBK1. <em>Nature</em>, 462(7269),
108–112. doi: <a href="https://doi.org/10.1038/nature08460">10.1038/nature08460</a>.
</p>
<p>Foroutan, M., Bhuva, D. D., Lyu, R., Horan, K., Cursons, J., &amp;
Davis, M. J. (2018). Single sample scoring of molecular phenotypes.
<em>BMC bioinformatics</em>, 19(1), 404. doi: <a href="https://doi.org/10.1186/s12859-018-2435-4">10.1186/s12859-018-2435-4</a>.
</p>
<p>Hänzelmann, S., Castelo, R., &amp; Guinney, J. (2013). GSVA: gene set variation
analysis for microarray and RNA-seq data. <em>BMC bioinformatics</em>, 14, 7.
doi: <a href="https://doi.org/10.1186/1471-2105-14-7">10.1186/1471-2105-14-7</a>.
</p>
<p>Lee, E., Chuang, H. Y., Kim, J. W., Ideker, T., &amp; Lee, D. (2008). Inferring
pathway activity toward precise disease classification.
<em>PLoS computational biology</em>, 4(11), e1000217.
doi: <a href="https://doi.org/10.1371/journal.pcbi.1000217">10.1371/journal.pcbi.1000217</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_sig_info">get_sig_info()</a></code> to get information about all implemented signatures.
</p>
<p><code><a href="#topic+check_sig">check_sig()</a></code> to check if signatures are applicable to your data.
</p>
<p><code><a href="#topic+hack_cinsarc">hack_cinsarc()</a></code> to apply the original CINSARC procedure.
</p>
<p><code><a href="#topic+hack_estimate">hack_estimate()</a></code> to obtain the original ESTIMATE scores.
</p>
<p><code><a href="#topic+hack_immunophenoscore">hack_immunophenoscore()</a></code> to apply the original Immunophenoscore procedure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Raw ssGSEA scores for all implemented signatures can be obtained with:
hack_sig(test_expr, method = "ssgsea")

# To obtain 0-1 normalized ssGSEA scores, use:
hack_sig(test_expr, method = "ssgsea", sample_norm = "separate")

# You can also change the exponent of the ssGSEA running sum with:
hack_sig(test_expr, method = "ssgsea", sample_norm = "separate", alpha = 0.5)

# To obtain combined z-scores for custom gene signatures, use:
custom_list &lt;- list(rand_sig1 = rownames(test_expr)[1:5],
                    rand_sig2 = c(rownames(test_expr)[6:8], "RANDOMGENE"))
hack_sig(test_expr, custom_list, method = "zscore")
</code></pre>

<hr>
<h2 id='ss_methods'>Single sample scoring methods</h2><span id='topic+ss_methods'></span><span id='topic+compute_zscore'></span><span id='topic+compute_ssgsea'></span><span id='topic+compute_singscore'></span>

<h3>Description</h3>

<p>These are internal functions to compute single sample scores from a list of
gene signatures in three different ways:
</p>

<ul>
<li> <p><strong>combined z-score</strong> (<em>Lee et al., 2008</em>);
</p>
</li>
<li> <p><strong>single sample GSEA</strong> (<em>Barbie et al., 2009</em>);
</p>
</li>
<li> <p><strong>singscore</strong> (<em>Foroutan et al., 2018</em>).
</p>
</li></ul>

<p><code>compute_ssgsea()</code> is called by <code><a href="#topic+hack_estimate">hack_estimate()</a></code> whereas all the three
methods are called by <code><a href="#topic+hack_sig">hack_sig()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_zscore(expr_data, signatures)

compute_ssgsea(
  expr_data,
  signatures,
  sample_norm = "raw",
  rank_norm = "none",
  alpha = 0.25
)

compute_singscore(expr_data, signatures, direction = "none")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ss_methods_+3A_expr_data">expr_data</code></td>
<td>
<p>A normalized gene expression matrix (or data frame) with
gene symbols as row names and samples as columns.</p>
</td></tr>
<tr><td><code id="ss_methods_+3A_signatures">signatures</code></td>
<td>
<p>A named list of gene signatures.</p>
</td></tr>
<tr><td><code id="ss_methods_+3A_sample_norm">sample_norm</code></td>
<td>
<p>A character string specifying the type of normalization
affecting the <strong>single sample GSEA</strong> scores. Can be one of:
</p>

<ul>
<li> <p><code>"raw"</code> (default), obtain raw scores;
</p>
</li>
<li> <p><code>"separate"</code>, normalize raw scores in <code class="reqn">[0, 1]</code> across samples for
each signature separately.
</p>
</li>
<li> <p><code>"all"</code>, normalize raw scores both across samples and signatures.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ss_methods_+3A_rank_norm">rank_norm</code></td>
<td>
<p>A character string specifying how gene expression ranks should
be normalized in the <strong>single sample GSEA</strong> procedure. Valid choices are:
</p>

<ul>
<li> <p><code>"none"</code> (default), no rank normalization;
</p>
</li>
<li> <p><code>"rank"</code>, ranks are multiplied by <code>10000 / nrow(expr_data)</code>;
</p>
</li>
<li> <p><code>"logrank"</code>, normalized ranks are logged.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ss_methods_+3A_alpha">alpha</code></td>
<td>
<p>A numeric scalar. Exponent in the running sum of the <strong>single sample GSEA</strong>
score calculation which weighs the gene ranks. Defaults to <code class="reqn">\alpha = 0.25</code>.</p>
</td></tr>
<tr><td><code id="ss_methods_+3A_direction">direction</code></td>
<td>
<p>A character string specifying the <strong>singscore</strong> computation
method depending on the direction of the signatures. Can be on of:
</p>

<ul>
<li> <p><code>"none"</code> (default), undirected signatures, that is you do not know whether
the genes are up- or down-regulated;
</p>
</li>
<li> <p><code>"up"</code>, all genes in the signature are supposed to be up-regulated;
</p>
</li>
<li> <p><code>"down"</code>, all genes in the signature are supposed to be down-regulated;
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with one row for each sample in <code>expr_data</code>, a column <code>sample_id</code>
indicating sample identifiers and one column for each input signature giving
single sample scores.
</p>


<h3>Algorithm</h3>

<p>This section gives a brief explanation of how single sample scores are obtained
from different methods.
</p>


<h4>Combined z-score</h4>

<p>Gene expression values are centered by their mean value and scaled by their
standard deviation across samples for each gene (z-scores). Then, for each
sample and signature, corresponding z-scores are added up and divided by the
square root of the signature size (i.e. the number of genes composing a signature).
</p>
<p>The combined z-score method is also implemented in the R package <code>GSVA</code>
(<em>Hänzelmann et al., 2013</em>).
</p>



<h4>Single sample GSEA</h4>

<p>For each sample, genes are ranked by expression value in increasing order and
rank normalization may follow (see argument <code>rank_norm</code>). Then, two probability-like
vectors are computed for each sample and signature:
</p>

<ul>
<li> <p><code class="reqn">P_{in}</code>, the cumulative sum of weighted ranks divided by their total
sum for genes in the signature;
</p>
</li>
<li> <p><code class="reqn">P_{out}</code>, the cumulative sum of ones (indicating genes not in the signature)
divided by the number of genes not in the signature.
</p>
</li></ul>

<p>The single sample GSEA score is obtained by adding up the elements of the
vector difference <code class="reqn">P_{in} - P_{out}</code>.
Finally, single sample scores could be normalized either across samples or across
gene signatures and samples.
</p>
<p>The single sample GSEA method is also implemented in the R package <code>GSVA</code>
(<em>Hänzelmann et al., 2013</em>).
</p>



<h4>Singscore</h4>

<p>For signatures whose genes are supposed to be up- or down-regulated, genes
are ranked by expression value in increasing or decreasing order, respectively.
For signatures whose direction is unknown, genes are ranked by absolute expression
in increasing order and are median-centered.
Enrichment scores are then computed for each sample and signature by averaging
gene ranks for genes in the signature.
Finally, normalized scores are obtained by subtracting the theoretical minimum
mean rank from the score and dividing by the difference between the theoretical
maximum and minimum mean ranks.
</p>
<p>The <code>hacksig</code> implementation of this method works only with unidirectional (i.e.
all genes up- or down-regulated) and undirected gene signatures.
If you want to get single sample scores for bidirectional gene signatures (i.e.
signatures composed of both up- and down-regulated genes), please use the R
package <code>singscore</code> (<em>Foroutan et al., 2018</em>).
</p>



<h3>References</h3>

<p>Barbie, D. A., Tamayo, P., Boehm, J. S., Kim, S. Y., Moody, S. E., Dunn, I. F.,
Schinzel, A. C., Sandy, P., Meylan, E., Scholl, C., Fröhling, S., Chan, E. M.,
Sos, M. L., Michel, K., Mermel, C., Silver, S. J., Weir, B. A., Reiling, J. H.,
Sheng, Q., Gupta, P. B., … Hahn, W. C. (2009). Systematic RNA interference
reveals that oncogenic KRAS-driven cancers require TBK1. <em>Nature</em>, 462(7269),
108–112. doi: <a href="https://doi.org/10.1038/nature08460">10.1038/nature08460</a>.
</p>
<p>Foroutan, M., Bhuva, D. D., Lyu, R., Horan, K., Cursons, J., &amp;
Davis, M. J. (2018). Single sample scoring of molecular phenotypes.
<em>BMC bioinformatics</em>, 19(1), 404. doi: <a href="https://doi.org/10.1186/s12859-018-2435-4">10.1186/s12859-018-2435-4</a>.
</p>
<p>Hänzelmann, S., Castelo, R., &amp; Guinney, J. (2013). GSVA: gene set variation
analysis for microarray and RNA-seq data. <em>BMC bioinformatics</em>, 14, 7.
doi: <a href="https://doi.org/10.1186/1471-2105-14-7">10.1186/1471-2105-14-7</a>.
</p>
<p>Lee, E., Chuang, H. Y., Kim, J. W., Ideker, T., &amp; Lee, D. (2008). Inferring
pathway activity toward precise disease classification.
<em>PLoS computational biology</em>, 4(11), e1000217.
doi: <a href="https://doi.org/10.1371/journal.pcbi.1000217">10.1371/journal.pcbi.1000217</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hack_sig">hack_sig()</a></code>, <code><a href="#topic+hack_estimate">hack_estimate()</a></code>, <code>GSVA::gsva()</code>, <code>singscore::multiScore()</code>
</p>

<hr>
<h2 id='test_expr'>A toy gene expression matrix</h2><span id='topic+test_expr'></span>

<h3>Description</h3>

<p>A gene expression matrix simulating expression profiles of 20 samples. It should
be used only for testing purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_expr
</code></pre>


<h3>Format</h3>

<p>A random normal data matrix with 20000 genes as rows and 20 samples as columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class(test_expr)
dim(test_expr)
check_sig(test_expr)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
