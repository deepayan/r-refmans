<!DOCTYPE html><html lang="en"><head><title>Help for package coenocliner</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coenocliner}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coenocliner'><p>A coenocline simulation package for R</p></a></li>
<li><a href='#coenocline'><p>Simulate species abundance (counts) or occurrence along one or two</p>
gradients</a></li>
<li><a href='#distributions'><p>Wrappers to random number generators for use with coenocliner</p></a></li>
<li><a href='#expand'><p>An <code>expand.grid</code>-like function that repeats sets of</p>
vectors for every value in a reference vector.</a></li>
<li><a href='#locations'><p>Extract Gradient Locations</p></a></li>
<li><a href='#persp.coenocline'><p>Perspective Plot of Species Simulations Along Gradients</p></a></li>
<li><a href='#plot.coenocline'><p>Plot species simulations along gradients</p></a></li>
<li><a href='#prettyHead'><p>Pretty Display of a Matrix or Data Frame</p></a></li>
<li><a href='#showParams'><p>List parameters of species response models</p></a></li>
<li><a href='#simJamil'><p>Simulate species abundance data following Jamil &amp; ter Braak</p>
(2013)</a></li>
<li><a href='#species-response'><p>Species response models for coenocline simulation</p></a></li>
<li><a href='#stack.coenocline'><p>Stack columns of a species coenocline simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Coenocline Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gavin L. Simpson &lt;ucfagls@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate species occurrence and abundances (counts) along
    gradients.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gavinsimpson/coenocliner/">https://github.com/gavinsimpson/coenocliner/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gavinsimpson/coenocliner/issues">https://github.com/gavinsimpson/coenocliner/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-13 17:38:07 UTC; gavin</td>
</tr>
<tr>
<td>Author:</td>
<td>Gavin L. Simpson [aut, cre],
  Jari Oksanen [ctb],
  Francisco Rodriguez-Sanchez [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-14 16:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='coenocliner'>A coenocline simulation package for R</h2><span id='topic+coenocliner'></span><span id='topic+coenocliner-package'></span>

<h3>Description</h3>

<p><span class="pkg">coenocliner</span> provides a simple, easy interface for simulating species abundance (counts) or occurrence along gradients.
</p>


<h3>Details</h3>

<p>One of the key ways quantitative ecologists attempt to understand the properties and behaviour of the methods they use or dream up is through the use of simulated data. <span class="pkg">coenocliner</span> is an R package that provides a simple interface to coenocline simulation.
</p>
<p>Species data can be simulated from a number of species response models
</p>

<ul>
<li><p> Gaussian response
</p>
</li>
<li><p> Generalised Beta response
</p>
</li></ul>

<p>and random count or occurrence data can be simulated from suitably parameterised response models by using the output from the response model as the mean or expectation of one of a number of statistical distributions
</p>

<ul>
<li><p> Poisson
</p>
</li>
<li><p> Negative Binomial
</p>
</li>
<li><p> Bernoulli
</p>
</li>
<li><p> Binomial
</p>
</li>
<li><p> Beta-Binomial
</p>
</li>
<li><p> Zero-inflated Poisson (ZIP)
</p>
</li>
<li><p> Zero-inflated Negative Binomial (ZINB)
</p>
</li>
<li><p> Zero-inflated Binomial (ZIB)
</p>
</li>
<li><p> Zero-inflated Beta-Binomial (ZIBB)
</p>
</li></ul>

<p>from which random draws are made.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coenocline">coenocline</a></code> for simulating species data, <code><a href="#topic+distributions">distributions</a></code> for details of the error distributions tha can be used for simulations, and <code><a href="#topic+species-response">species-response</a></code> for details on the available species response models and the parameters required to use them.
</p>

<hr>
<h2 id='coenocline'>Simulate species abundance (counts) or occurrence along one or two
gradients</h2><span id='topic+coenocline'></span>

<h3>Description</h3>

<p>Simulate species abundance (counts) or occurrence along one or two gradients using well-known ecological response models and random draws from one of a Poisson, negative binomial, Bernoulli, binomial, beta-binomial, zero-inflated Poisson, or zero-inflated neative binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coenocline(
  x,
  responseModel = c("gaussian", "beta"),
  params,
  extraParams = NULL,
  countModel = c("poisson", "negbin", "bernoulli", "binary", "binomial",
    "betabinomial", "ZIP", "ZINB", "ZIB", "ZIBB"),
  countParams = NULL,
  expectation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coenocline_+3A_x">x</code></td>
<td>
<p>one of a numeric vector, a list with two components, each a numeric vector, or a matrix with two columns. The vectors are the locations along the gradient(s) at which species responses are to be simulated.</p>
</td></tr>
<tr><td><code id="coenocline_+3A_responsemodel">responseModel</code></td>
<td>
<p>character; which species response model to use.</p>
</td></tr>
<tr><td><code id="coenocline_+3A_params">params</code></td>
<td>
<p>a list of vectors each of which are parameters for the response model for each species. Alternatively, a matrix with one column per parameter and a row for each species.</p>
</td></tr>
<tr><td><code id="coenocline_+3A_extraparams">extraParams</code></td>
<td>
<p>a list containing additional parameters required for the response model. Examples include the correlation between gradients in the bivariate Gaussian response model. Components need to be named.</p>
</td></tr>
<tr><td><code id="coenocline_+3A_countmodel">countModel</code></td>
<td>
<p>character; if <code>expectation</code> is <code>FALSE</code>, the default, counts (occurrence) are generated using random deviates from the specified distribution.</p>
</td></tr>
<tr><td><code id="coenocline_+3A_countparams">countParams</code></td>
<td>
<p>a list of additional parameters required to specify the distribution. An example is the parameter <code class="reqn">\alpha</code> in the negative binomial distribution. Components need to be named.</p>
</td></tr>
<tr><td><code id="coenocline_+3A_expectation">expectation</code></td>
<td>
<p>logical; should the expectation (mean) response be returned (<code>TRUE</code>)? If <code>FALSE</code> random counts or occurrences are generated using random draws from a suitably parameterised distribution, as stated in <code>countModel</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coenocline()</code> is a generic interface to coenocline simulation allowing for easy extension and a consistent interface to a range of species response models and statistical distributions.
</p>
<p>Two species response models are currently available; the Gaussian response and the generalized beta response model. Random count or occurrence data can be produced via random draws from a suitable distribution; in which case the values obtained from the specoes response function are used as the expectation of the distribution from which random draws are made.
</p>
<p>Parameters for each species in the response model are supplied via argument <code>params</code> and can be provided in one of two ways: i) as a list with named components, each of which is a vector containing values for a single parameter for each species, or ii) as a matrix where each column contains the values for a single parameter and the rows represent species. In each case, the names of the list components or the column names of the matrix must be named for the arguments of the function implementing the species distribution model. See the examples.
</p>
<p>Some species response models may require additional parameters not specified at the per species level. An example is the correlation between gradients in the bivariate Gaussian response model. Such parameters are passed via list <code>extraParams</code> and must be named accordingly so that they are passed to the corrct argument in the species response function.
</p>
<p>The species response model defines the mean of expected response. (In the case of a species occurrence, the probability of occurrence is the expectation.) These represent paramterterised distributions. Random count or occurence data can be produced from these distributions by simulation from those distributions. In this case, a count or probability of occurence model is used and random draws from the distribution are made. The following distriubutions are available:
</p>

<ul>
<li><p> Poisson,
</p>
</li>
<li><p> Negative binomial,
</p>
</li>
<li><p> Bernoulli,
</p>
</li>
<li><p> Binomial,
</p>
</li>
<li><p> Beta-Binomial,
</p>
</li>
<li><p> Zero-inflated Poisson,
</p>
</li>
<li><p> Zero-inflated Negative binomial,
</p>
</li>
<li><p> Zero-inflated Binomial, and
</p>
</li>
<li><p> Zero-inflated Beta-Binomial
</p>
</li></ul>

<p>Some distributions may need additional parameters beyond the expectation; an example is the <code class="reqn">\alpha</code> parameter of (one parameterisation of) the negative binomial distribution. These parameters are specied via the list <code>countParams</code>.
</p>


<h3>Value</h3>

<p>a matrix of simulated count or occurrence data, one row per gradient location, one column per species. The object is of class <code>"coenocline"</code>, which inherits from the <code>"matrix"</code> class.
</p>
<p>Additional attributes attached to the matrix are:
</p>

<dl>
<dt><code>locations</code></dt><dd><p> the gradient locations at which response curves were evaluated or for which counts were simulated.</p>
</dd>
<dt><code>expectations</code></dt><dd><p> the passed value of the <code>expection</code>.</p>
</dd>
<dt><code>responseModel</code></dt><dd><p> the species response model.</p>
</dd>
<dt><code>countModel</code></dt><dd><p> the count distribution used to simulate counts from.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Poisson counts along a single gradient, Gaussian response
## =========================================================

x &lt;- seq(from = 4, to = 6, length = 100)
opt &lt;- c(3.75, 4, 4.55, 5, 5.5) + 0.5
tol &lt;- rep(0.25, 5)
h &lt;- rep(20, 5)

## simulate
set.seed(1)
y &lt;- coenocline(x, responseModel = "gaussian",
                params = cbind(opt = opt, tol = tol, h = h),
                countModel = "poisson")
head(y)

y &lt;- coenocline(x, responseModel = "gaussian",
                params = cbind(opt = opt, tol = tol, h = h),
                countModel = "poisson",
                expectation = TRUE)
plot(y, type = "l", lty = "solid")

## Bernoulli distribution (occurrence)
## ===================================

h &lt;- c(1,3,5,7,9) / 10
y &lt;- coenocline(x, responseModel = "gaussian",
                params = cbind(opt = opt, tol = tol, h = h),
                countModel = "bernoulli")
head(y)
## probability of occurrence...
pi &lt;- coenocline(x, responseModel = "gaussian",
                 params = cbind(opt = opt, tol = tol, h = h),
                 countModel = "bernoulli", expectation = TRUE)
## plot
plot(y, type = "p", pch = 1) # a random realisation
lines(pi, lty = "solid")     # probability of occurrence

## Correlated bivariate Gaussian response, two species
## ===================================================

## gradient locations
x &lt;- seq(3.5, 7, length = 30)
y &lt;- seq(1, 10, length = 30)
xy &lt;- expand.grid(x = x, y = y)

## species parameters on gradients x and y
parx &lt;- list(opt = c(5,6), tol = c(0.5,0.3), h = c(50, 75))
pary &lt;- list(opt = c(5,7), tol = c(1.5, 1.5))

## evaluate response curves at gradient locations
sim &lt;- coenocline(xy, params = list(px = parx, py = pary),
                  responseModel = "gaussian", expectation = TRUE,
                  extraParams = list(corr = 0.5))

## Perspective plots the bivariate responses of the two species
## 'sim' is a matrix 1 column per species with prod(length(x), length(y))
## rows. Need to reshape each species (column) vector into a matrix
## with as many rows as length(x) (number of gradient locations) and
## fill *column*-wise (the default)
persp(x, y, matrix(sim[,1], ncol = length(x)), # spp1
      theta = 45, phi = 30)
persp(x, y, matrix(sim[,2], ncol = length(x)), # spp2
      theta = 45, phi = 30)

## Poisson counts along two correlated gradients, Gaussian response
## ================================================================

set.seed(1)
N &lt;-  100
x1 &lt;- seq(from = 4, to = 6, length = N)
opt1 &lt;- seq(4, 6, length = 5)
tol1 &lt;- rep(0.25, 5)
x2 &lt;- seq(from = 2, to = 20, length = N)
opt2 &lt;- seq(2, 20, length = 5)
tol2 &lt;- rep(1, 5)
h &lt;- rep(30, 5)
xy &lt;- expand.grid(x = x1, y = x2)

set.seed(1)
params &lt;- list(px = list(opt = opt1, tol = tol1, h = h),
               py = list(opt = opt2, tol = tol2))
y &lt;- coenocline(xy,
                responseModel = "gaussian",
                params = params,
                extraParams = list(corr = 0.5),
                countModel = "poisson")

head(y)
tail(y)

## Visualise one species' bivariate count data
persp(x1, x2, matrix(y[,3], ncol = length(x1)),
      ticktype = "detailed", zlab = "Abundance")

## Recreate beta responses in Fig. 2 of Minchin (1987)
## ===================================================

A0 &lt;- c(5,4,7,5,9,8) * 10
m &lt;- c(25,85,10,60,45,60)
r &lt;- c(3,3,4,4,6,5) * 10
alpha &lt;- c(0.1,1,2,4,1.5,1)
gamma &lt;- c(0.1,1,2,4,0.5,4)
x &lt;- 1:100
params &lt;- list(m = m, A0 = A0, r = r, alpha = alpha, gamma = gamma)

## Expectations
set.seed(2)
y &lt;- coenocline(x, responseModel = "beta",
                params = params,
                countModel = "poisson")
head(y)
plot(y, type = "l", lty = "solid")

y &lt;- coenocline(x, responseModel = "beta",
                params = params,
                countModel = "poisson", expectation = TRUE)
plot(y, type = "l", lty = "solid")

## Zero-inflated Poisson, constant zero-inflation
## ==============================================

y &lt;- coenocline(x, responseModel = "beta", params = params,
                countModel = "ZIP", countParams = list(zprobs = 0.2))
plot(y, type = "l", lty = "solid")

## Zero-inflated Negative binomial, constant zero-inflation
y &lt;- coenocline(x, responseModel = "beta",
                params = params,
                countModel = "ZINB",
                countParams = list(alpha = 0.75, zprobs = 0.2))
plot(y, type = "l", lty = "solid")

## Binomial counts, constant size (m) of 100
## =========================================

## note: A0 must be in range, (0,1)
params[["A0"]] &lt;- c(5,4,7,5,9,8) / 10
y &lt;- coenocline(x, responseModel = "beta",
                params = params,
                countModel = "binomial",
                countParams = list(size = 100))
plot(y, type = "l", lty = "solid")

## Beta-Binomial counts, constant size (m) of 100
## ==============================================

## note: A0 must be in range, (0,1)
params[["A0"]] &lt;- c(5,4,7,5,9,8) / 10
y &lt;- coenocline(x, responseModel = "beta",
                params = params,
                countModel = "betabinomial",
                countParams = list(size = 100, theta = 0.1))
plot(y, type = "l", lty = "solid")
</code></pre>

<hr>
<h2 id='distributions'>Wrappers to random number generators for use with coenocliner</h2><span id='topic+distributions'></span><span id='topic+NegBin'></span><span id='topic+Poisson'></span><span id='topic+Bernoulli'></span><span id='topic+Binomial'></span><span id='topic+BetaBinomial'></span><span id='topic+ZIP'></span><span id='topic+ZINB'></span><span id='topic+ZIB'></span><span id='topic+ZIBB'></span>

<h3>Description</h3>

<p>These functions are simple wrappers around existing random number generators in R to provide stochastic count data for simulated species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NegBin(n, mu, alpha)

Poisson(n, mu)

Bernoulli(n, mu)

Binomial(n, mu, size)

BetaBinomial(n, mu, size, theta)

ZIP(n, mu, zprobs)

ZINB(n, mu, alpha, zprobs)

ZIB(n, mu, size, zprobs)

ZIBB(n, mu, size, theta, zprobs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distributions_+3A_n">n</code></td>
<td>
<p>the number of random draws, equal to number of species times the number of gradient locations.</p>
</td></tr>
<tr><td><code id="distributions_+3A_mu">mu</code></td>
<td>
<p>the mean or expectation of the distribution. For <code>Bernoulli</code>, <code>Binomial</code>, and <code>BetaBinomial()</code> this is the probability of occurrence as given by the response function.</p>
</td></tr>
<tr><td><code id="distributions_+3A_alpha">alpha</code></td>
<td>
<p>numeric; dispersion parameter for the negative binomial distribution. May be a vector of length <code>length(mu)</code>. The NB2 parametrization of the negative binomial is used here, in which <code class="reqn">\alpha</code> is positively related to the amount of extra dispersion in the simulated data. As such, where <code class="reqn">\alpha = 0</code>, we would have a Poisson distribution. <code>alpha</code> can be supplied a value of <code>0</code>, in which case <code>NegBin</code> and <code>ZINB</code> return random draws from the Poisson or zero-inflated Poisson distributions, respectively. Negative values of <code>alpha</code> are not allowed and will generate an error.</p>
</td></tr>
<tr><td><code id="distributions_+3A_size">size</code></td>
<td>
<p>numeric; binomial denominator, the total number of individuals counted for example</p>
</td></tr>
<tr><td><code id="distributions_+3A_theta">theta</code></td>
<td>
<p>numeric; a positive <em>inverse</em> overdispersion parameter for the Beta-Binomial distribution. Low values give high overdispersion. The variance is  <code>size*mu*(1-mu)*(1+(size-1)/(theta+1))</code> (Bolker, 2008)</p>
</td></tr>
<tr><td><code id="distributions_+3A_zprobs">zprobs</code></td>
<td>
<p>numeric; zero-inflation parameter giving the proportion of extraneous zeros. Must be in range <code class="reqn">0 \dots 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of random draws from the stated distribution.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>References</h3>

<p>Bolker, B.M. (2008) <em>Ecological Models and Data
in R.</em> Princeton University Press.
</p>

<hr>
<h2 id='expand'>An <code>expand.grid</code>-like function that repeats sets of
vectors for every value in a reference vector.</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>The values of <code>x</code> are repeated for each combination
of elements in the vectors supplied via <code>...</code>, with the first
elements of each vector in <code>...</code> being taken as a set, the
second elements as another set, and so on. <code>x</code> is repeated for
each of these sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_+3A_x">x</code></td>
<td>
<p>numeric; vector of data points which are to be replicated
for each of the sets of vectors supplied to <code>...</code>.</p>
</td></tr>
<tr><td><code id="expand_+3A_...">...</code></td>
<td>
<p>additional vector arguments to be expanded to the correct
length. These are taken to be a set of values to be replicated for
each of the elements of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of replicated vectors, with column names for <code>x</code>
and named arguments passed as <code>...</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>References</h3>

<p>Minchin P.R. (1987) Simulation of multidimensional
community patterns: towards a comprehensive model. <em>Vegetatio</em>
<strong>71</strong>, 145&ndash;156.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Recreate Fig. 2 of Minchin (1987)
# Parameters for each of 6 six species
A0 &lt;- c(5,4,7,5,9,8) * 10
m &lt;- c(25,85,10,60,45,60)
r &lt;- c(3,3,4,4,6,5) * 10
alpha &lt;- c(0.1,1,2,4,1.5,1)
gamma &lt;- c(0.1,1,2,4,0.5,4)
# Gradient locations
x &lt;- 1:100

# expand parameter set
pars &lt;- expand(x, m = m, A0 = A0, r = r, alpha = alpha,
               gamma = gamma)
head(pars)
</code></pre>

<hr>
<h2 id='locations'>Extract Gradient Locations</h2><span id='topic+locations'></span><span id='topic+locations.default'></span>

<h3>Description</h3>

<p>Extract the gradient locations at which response curves were evaluated or for which counts were simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locations(x, ...)

## Default S3 method:
locations(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locations_+3A_x">x</code></td>
<td>
<p>an object with <code>locations</code> as an attribute or a component, such as the object returned by <code><a href="#topic+coenocline">coenocline</a></code>.</p>
</td></tr>
<tr><td><code id="locations_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix of gradient locations. For single-gradient simulations, a vector is returned, whereas for two-gradient simulations, a matrix of location pairs is returned.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Poisson counts along a single gradient, Gaussian response
## =========================================================

x &lt;- seq(from = 4, to = 6, length = 100)
opt &lt;- c(3.75, 4, 4.55, 5, 5.5) + 0.5
tol &lt;- rep(0.25, 5)
h &lt;- rep(20, 5)

## simulate
set.seed(1)
y &lt;- coenocline(x, responseModel = "gaussian",
                params = cbind(opt = opt, tol = tol, h = h),
                countModel = "poisson")
head(locations(y))
</code></pre>

<hr>
<h2 id='persp.coenocline'>Perspective Plot of Species Simulations Along Gradients</h2><span id='topic+persp.coenocline'></span>

<h3>Description</h3>

<p>A simple S3 <code><a href="graphics.html#topic+persp">persp</a></code> method for coenocline simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coenocline'
persp(x, species = NULL, theta = 45, phi = 30, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="persp.coenocline_+3A_x">x</code></td>
<td>
<p>an object of class <code>"coenocline"</code>, the result of a call to <code><a href="#topic+coenocline">coenocline</a></code>.</p>
</td></tr>
<tr><td><code id="persp.coenocline_+3A_species">species</code></td>
<td>
<p>vector indicating which species to plot. This can be any vector that you can use to subset a matrix, but numeric or logical vectors would be mostly commonly used.</p>
</td></tr>
<tr><td><code id="persp.coenocline_+3A_theta">theta</code>, <code id="persp.coenocline_+3A_phi">phi</code></td>
<td>
<p>angles defining the viewing direction. <code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude. See <code><a href="graphics.html#topic+persp">persp</a></code> for further details.</p>
</td></tr>
<tr><td><code id="persp.coenocline_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is drawn on the current device.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Poisson counts along two correlated gradients, Gaussian response
## ================================================================

set.seed(1)
N &lt;-  40
x1 &lt;- seq(from = 4, to = 6, length = N)
opt1 &lt;- seq(4, 6, length = 5)
tol1 &lt;- rep(0.25, 5)
x2 &lt;- seq(from = 2, to = 20, length = N)
opt2 &lt;- seq(2, 20, length = 5)
tol2 &lt;- rep(1, 5)
h &lt;- rep(30, 5)
xy &lt;- expand.grid(x = x1, y = x2)

set.seed(1)
params &lt;- list(px = list(opt = opt1, tol = tol1, h = h),
               py = list(opt = opt2, tol = tol2))
y &lt;- coenocline(xy,
                responseModel = "gaussian",
                params = params,
                extraParams = list(corr = 0.5),
                countModel = "poisson")

## perspective plot(s) of simulated counts
layout(matrix(1:6, ncol = 3))
op &lt;- par(mar = rep(1, 4))
persp(y)
par(op)
layout(1)

## as before but now just expectations
y &lt;- coenocline(xy,
                responseModel = "gaussian",
                params = params,
                extraParams = list(corr = 0.5),
                countModel = "poisson",
                expectation = TRUE)

## perspective plots of response curves
layout(matrix(1:6, ncol = 3))
op &lt;- par(mar = rep(1, 4))
persp(y)
par(op)
layout(1)

## Same plots generated using the `plot` method
layout(matrix(1:6, ncol = 3))
op &lt;- par(mar = rep(1, 4))
persp(y)
par(op)
layout(1)
</code></pre>

<hr>
<h2 id='plot.coenocline'>Plot species simulations along gradients</h2><span id='topic+plot.coenocline'></span><span id='topic+lines.coenocline'></span>

<h3>Description</h3>

<p>A simple S3 <code><a href="base.html#topic+plot">plot</a></code> method for coenocline simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coenocline'
plot(x, type = "p", pch = 1, ...)

## S3 method for class 'coenocline'
lines(x, lty = "solid", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.coenocline_+3A_x">x</code></td>
<td>
<p>an object of class <code>"coenocline"</code>, the result of a call to <code><a href="#topic+coenocline">coenocline</a></code>.</p>
</td></tr>
<tr><td><code id="plot.coenocline_+3A_type">type</code></td>
<td>
<p>character; the type of plot to produce. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.coenocline_+3A_pch">pch</code></td>
<td>
<p>the plotting character to use. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.coenocline_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.coenocline_+3A_lty">lty</code></td>
<td>
<p>the line type to use. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is drawn on the current device.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Poisson counts along a single gradient, Gaussian response
## =========================================================

x &lt;- seq(from = 4, to = 6, length = 100)
opt &lt;- c(3.75, 4, 4.55, 5, 5.5) + 0.5
tol &lt;- rep(0.25, 5)
h &lt;- rep(20, 5)

## simulate
set.seed(1)
y &lt;- coenocline(x, responseModel = "gaussian",
                params = cbind(opt = opt, tol = tol, h = h),
                countModel = "poisson")
head(y)

y &lt;- coenocline(x, responseModel = "gaussian",
                params = cbind(opt = opt, tol = tol, h = h),
                countModel = "poisson",
                expectation = TRUE)
plot(y, type = "l", lty = "solid")
</code></pre>

<hr>
<h2 id='prettyHead'>Pretty Display of a Matrix or Data Frame</h2><span id='topic+prettyHead'></span>

<h3>Description</h3>

<p>Pretty display of the first <code>n</code> rows of a data frame or matrix-like object, with variables/columns that cannot fit on a single screen width removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettyHead(x, n = 10, width = getOption("width"), zapsmall = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prettyHead_+3A_x">x</code></td>
<td>
<p>an R object for which <code><a href="utils.html#topic+head">head</a></code> and <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> methods exist.</p>
</td></tr>
<tr><td><code id="prettyHead_+3A_n">n</code></td>
<td>
<p>numeric; the number of rows to display</p>
</td></tr>
<tr><td><code id="prettyHead_+3A_width">width</code></td>
<td>
<p>numeric; the display width to assume when formatting the data frame. The default is given by <code>getOption("width")</code></p>
</td></tr>
<tr><td><code id="prettyHead_+3A_zapsmall">zapsmall</code></td>
<td>
<p>logical; should values close to zero be zapped to zero? See <code><a href="base.html#topic+zapsmall">zapsmall</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+format">format</a></code>-ed data frame with <code>n</code> rows (or <code>n+1</code> rows if only a subset is shown) and as many columns/components that can be printed on a single screen width.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from = 4, to = 6, length = 30)
opt &lt;- seq(4, 7, length = 100)
tol &lt;- rep(0.25, 100)
h &lt;- rep(20, 100)

## simulate
set.seed(1)
y &lt;- coenocline(x, responseModel = "gaussian",
                params = cbind(opt = opt, tol = tol, h = h),
                countModel = "poisson")

prettyHead(y)

</code></pre>

<hr>
<h2 id='showParams'>List parameters of species response models</h2><span id='topic+showParams'></span>

<h3>Description</h3>

<p>Returns the parameters of the indicated response model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showParams(model = c("gaussian", "beta"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showParams_+3A_model">model</code></td>
<td>
<p>character; the species response model for which parameters will be listed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of parameters. The species response model is returned as attribute <code>"model"</code>. Attribute <code>"onlyx"</code> is a logical vector indicating which, if any, of the parameters are intended to be supplied only once per species and not for both gradients.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gaussian">Gaussian</a></code> and <code><a href="#topic+Beta">Beta</a></code> for the species response model functions themselves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showParams("gaussian")
</code></pre>

<hr>
<h2 id='simJamil'>Simulate species abundance data following Jamil &amp; ter Braak
(2013)</h2><span id='topic+simJamil'></span>

<h3>Description</h3>

<p>Simulate species probability of occurrence data according
to the method used by Tahira Jamil and Cajo ter Braak in their recent
paper <em>Generalized linear mixed models can detect unimodal
species-environment relationships</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simJamil(
  n,
  m,
  x,
  gl = 4,
  randx = TRUE,
  tol = 0.5,
  tau = gl/2,
  randm = TRUE,
  expectation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simJamil_+3A_n">n</code></td>
<td>
<p>numeric; the number of samples/sites.</p>
</td></tr>
<tr><td><code id="simJamil_+3A_m">m</code></td>
<td>
<p>numeric, the number of species/variables.</p>
</td></tr>
<tr><td><code id="simJamil_+3A_x">x</code></td>
<td>
<p>numeric; values for the environmental gradient. Can be
missing, in which case suitable values are generated. See Details.</p>
</td></tr>
<tr><td><code id="simJamil_+3A_gl">gl</code></td>
<td>
<p>numeric; gradient length in arbitrary units. The default
is 4 units with gradient values ranging from -2 to 2.</p>
</td></tr>
<tr><td><code id="simJamil_+3A_randx">randx</code></td>
<td>
<p>logical; should locations along the gradient (<code>x</code>)
be located randomly or equally-spaced?</p>
</td></tr>
<tr><td><code id="simJamil_+3A_tol">tol</code></td>
<td>
<p>numeric; the species tolerances. Can be a vector of
length <code>m</code>, hence allowing for varying tolerances along the
gradient <code>x</code>.</p>
</td></tr>
<tr><td><code id="simJamil_+3A_tau">tau</code></td>
<td>
<p>numeric; constant that ensures some of the optima are
located beyond the observed gradient end points.</p>
</td></tr>
<tr><td><code id="simJamil_+3A_randm">randm</code></td>
<td>
<p>logical; should species optima along the gradient be
located randomly or equally-spaced?</p>
</td></tr>
<tr><td><code id="simJamil_+3A_expectation">expectation</code></td>
<td>
<p>logical; if <code>TRUE</code> the binomial probabilities
<code class="reqn">p_{ij}</code> from the response curve are returned directly. If
<code>FALSE</code>, the default, random draws from a Bernoulli distribution
with probability <code class="reqn">p_{ij}</code> are made.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of <code>n</code> rows and <code>m</code> columns containing the
simulated species abundance data.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>References</h3>

<p>Jamil and ter Braak (2013) Generalized linear mixed models can detect unimodal species-environment relationships. <em>PeerJ</em> <strong>1:e95</strong>; DOI doi: <a href="https://doi.org/10.7717/peerj.95">10.7717/peerj.95</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
N &lt;- 100   # Number of locations on gradient (samples)
glen &lt;- 4  # Gradient length
grad &lt;- sort(runif(N, -glen/2, glen/2)) # sample locations
M &lt;- 10    # Number of species
sim &lt;- simJamil(n = N, m = M, x = grad, gl = glen, randx = FALSE,
                randm = FALSE, expectation = TRUE)
## visualise the response curves
matplot(grad, sim, type = "l", lty = "solid")

## simulate binomial responses from those response curves
sim &lt;- simJamil(n = N, m = M, x = grad, gl = glen, randx = FALSE,
                randm = FALSE)

</code></pre>

<hr>
<h2 id='species-response'>Species response models for coenocline simulation</h2><span id='topic+species-response'></span><span id='topic+Gaussian'></span><span id='topic+Beta'></span>

<h3>Description</h3>

<p>Parameterise species response curves along one or two gradients according to a Gaussian or generalised beta response model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian(x, y = NULL, px, py = NULL, corr = 0)

Beta(x, y = NULL, px, py = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="species-response_+3A_x">x</code></td>
<td>
<p>numeric; locations of observations on the primary gradient.</p>
</td></tr>
<tr><td><code id="species-response_+3A_y">y</code></td>
<td>
<p>numeric; locations of observations on the secondary gradient. Can be missing is only a single gradient is required.</p>
</td></tr>
<tr><td><code id="species-response_+3A_px">px</code></td>
<td>
<p>a list of named elements, each of which is a vector of numeric parameter values for the species response on the primary gradient <code>x</code>. See Details for further information on the required parameters.</p>
</td></tr>
<tr><td><code id="species-response_+3A_py">py</code></td>
<td>
<p>a list of named elements, each of which is a vector of numeric parameter values for the species response on the secondary gradient <code>y</code>. See Details for further information on the required parameters.</p>
</td></tr>
<tr><td><code id="species-response_+3A_corr">corr</code></td>
<td>
<p>numeric; the correlation between gradients <code>x</code> and <code>y</code>. Only applies to <code>Gaussian()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Gaussian()</code> and <code>Beta()</code> return values from appropriately parameterised Gaussian or generalised beta response models respectively. Parameters for the primary (<code>x</code>) and secondary (<code>y</code>) gradients are supplied as lists via arguments <code>px</code> and <code>py</code>. Parameters are supplied in the form of vectors, one per parameter. These vectors must be supplied to named components in the respective lists. The names of the components must match the parameters of the required response model.
</p>
<p>For <code>Gaussian()</code> the following named components must be supplied:
</p>

<dl>
<dt>opt</dt><dd><p>the species optima</p>
</dd>
<dt>tol</dt><dd><p>the species tolerances</p>
</dd>
<dt>h</dt><dd><p>the heights of the response curves at the optima. This parameter should only be supplied to <code>px</code>; in the case of simulations along two gradients, the height of the response curve applies to both gradients and is the hieght of a bivariate Guassian distribution at the bivariate optima.</p>
</dd>
</dl>

<p>For <code>Beta()</code> the following named components must be supplied:
</p>

<dl>
<dt>A0</dt><dd><p>The heights of the species response curves at their modes. Like the parameter <code>h</code> for the Gaussian response, this parameter should only be passed via <code>px</code>; in the case of simulations along two gradients, the height of the response curve applies to both gradients and is the height of a bivariate generalised beta distribution at the bivariate mode.</p>
</dd>
<dt>m</dt><dd><p>the locations on the gradient of the modal abundance (the species optima)</p>
</dd>
<dt>r</dt><dd><p>the ranges of occurrence of species on the gradient</p>
</dd>
<dt>alpha</dt><dd><p>a shape parameter. With <code>gamma</code>, <code>alpha</code> informs the shape of the response curve and control the skewness and kurtosis of the curve. Only positive values are allowed, which lead to unimodal response curves. If <code>alpha</code> is equal to <code>gamma</code>, the species response curve is symmetric, otherwise an asymmetric curve is generated.</p>
</dd>
<dt>gamma</dt><dd><p>a shape parameter. With <code>alpha</code>, <code>gamma</code> informs the shape of the response curve and control the skewness and kurtosis of the curve. Only positive values are allowed, which lead to unimodal response curves. If <code>gamma</code> is equal to <code>alpha</code>, the species response curve is symmetric, otherwise an asymmetric curve is generated.</p>
</dd>
</dl>

<p>See the examples here and in <code><a href="#topic+coenocline">coenocline</a></code> for details on how to set up calls to these species response functions.
</p>


<h3>Value</h3>

<p>A numeric vector of species &quot;abundances&quot; of length equal to <code>length(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple example with a single species
x &lt;- seq(from = 4, to = 6, length = 100)
px &lt;- list(opt = 4.5, tol = 0.25, h = 20)
G &lt;- Gaussian(x, px = px)
head(G)
length(G)

# A more complex example with 6 species, which needs the parameters
# repeating for each gradient location:

# Recreate Fig. 2 of Minchin (1987)
# Parameters for each of 6 six species
A0 &lt;- c(5,4,7,5,9,8) * 10
m &lt;- c(25,85,10,60,45,60)
r &lt;- c(3,3,4,4,6,5) * 10
alpha &lt;- c(0.1,1,2,4,1.5,1)
gamma &lt;- c(0.1,1,2,4,0.5,4)
# Gradient locations
x &lt;- 1:100

# expand parameter set
pars &lt;- expand(x, m = m, A0 = A0, r = r, alpha = alpha,
gamma = gamma)
head(pars)

xvec &lt;- pars[, "x"]
px &lt;- as.list(data.frame(pars[, -1]))
spprc &lt;- Beta(xvec, px = px)
matplot(matrix(spprc, ncol = 6), ## 6 species
        type = "l", lty = "solid")

# Bivariate beta, single species
xx &lt;- 1:100
yy &lt;- 1:100
xy &lt;- expand.grid(x = xx, y = yy)
parx &lt;- expand(xy[, "x"], A0 = 50, m = 60, r = 40, alpha = 4, gamma = 4)
pary &lt;- expand(xy[, "y"], m = 60, r = 40, alpha = 4, gamma = 4)

x &lt;- parx[,1]
px &lt;- as.list(as.list(data.frame(parx[, -1])))
y &lt;- pary[,1]
py &lt;- as.list(as.list(data.frame(pary[, -1])))

spprc &lt;- Beta(x, y, px = px, py = py)
persp(xx, yy, matrix(spprc, ncol = length(xx)))
</code></pre>

<hr>
<h2 id='stack.coenocline'>Stack columns of a species coenocline simulation</h2><span id='topic+stack.coenocline'></span>

<h3>Description</h3>

<p>Stacks columns of a species coenocline simulation into long format suitable for use in statistical modeling or ggplot/lattice plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coenocline'
stack(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stack.coenocline_+3A_x">x</code></td>
<td>
<p>an object of class <code>"coenocline"</code></p>
</td></tr>
<tr><td><code id="stack.coenocline_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods (not used).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+coenocline">coenocline</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
