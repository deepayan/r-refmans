<!DOCTYPE html><html lang="en"><head><title>Help for package tscount</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tscount}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tscount-package'>
<p>Analysis of Count Time Series</p></a></li>
<li><a href='#campy'>
<p>Campylobacter Infections Time Series</p></a></li>
<li><a href='#countdistr'>
<p>Count Data Distributions</p></a></li>
<li><a href='#ecoli'>
<p>E. coli Infections Time Series</p></a></li>
<li><a href='#ehec'>
<p>EHEC Infections Time Series</p></a></li>
<li><a href='#influenza'>
<p>Influenza Infections Time Series</p></a></li>
<li><a href='#ingarch.analytical'>
<p>Analytical Mean, Variance and Autocorrelation of an INGARCH Process</p></a></li>
<li><a href='#interv_covariate'>
<p>Describing Intervention Effects for Time Series with Deterministic Covariates</p></a></li>
<li><a href='#interv_detect.tsglm'>
<p>Detecting an Intervention in Count Time Series Following Generalised Linear Models</p></a></li>
<li><a href='#interv_multiple.tsglm'>
<p>Detecting Multiple Interventions in Count Time Series Following Generalised Linear Models</p></a></li>
<li><a href='#interv_test.tsglm'>
<p>Testing for Interventions in Count Time Series Following Generalised Linear Models</p></a></li>
<li><a href='#invertinfo'>
<p>Compute a Covariance Matrix from a Fisher Information Matrix</p></a></li>
<li><a href='#marcal'>
<p>Predictive Model Assessment with a Marginal Calibration Plot</p></a></li>
<li><a href='#measles'>
<p>Measles Infections Time Series</p></a></li>
<li><a href='#pit'>
<p>Predictive Model Assessment with a Probability Integral Transform Histogram</p></a></li>
<li><a href='#plot.interv_detect'>
<p>Plot Test Statistic of Intervention Detection Procedure for Count Time Series Following Generalised Linear Models</p></a></li>
<li><a href='#plot.interv_multiple'>
<p>Plot for Iterative Intervention Detection Procedure for Count Time Series following Generalised Linear Models</p></a></li>
<li><a href='#plot.tsglm'>
<p>Diagnostic Plots for a Fitted GLM-type Model for Time Series of Counts</p></a></li>
<li><a href='#predict.tsglm'>
<p>Predicts Method for Time Series of Counts Following Generalised Linear Models</p></a></li>
<li><a href='#QIC'>
<p>Quasi Information Criterion of a Generalised Linear Model for Time Series of Counts</p></a></li>
<li><a href='#residuals.tsglm'>
<p>Residuals of a Generalised Linear Model for Time Series of Counts</p></a></li>
<li><a href='#scoring'>
<p>Predictive Model Assessment with Proper Scoring Rules</p></a></li>
<li><a href='#se.tsglm'>
<p>Standard Errors of a Fitted Generalised Linear Model for Time Series of Counts</p></a></li>
<li><a href='#summary.tsglm'>
<p>Summarising Fits of Count Time Series following Generalised Linear Models</p></a></li>
<li><a href='#tsglm'>
<p>Count Time Series Following Generalised Linear Models</p></a></li>
<li><a href='#tsglm.sim'>
<p>Simulate a Time Series Following a Generalised Linear Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Count Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-09-07</td>
</tr>
<tr>
<td>Description:</td>
<td>Likelihood-based methods for model fitting and assessment, prediction and intervention analysis of count time series following generalized linear models are provided. Models with the identity and with the logarithmic link function are allowed. The conditional distribution can be Poisson or Negative Binomial.</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, ltsa</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix, xtable, gamlss.data, surveillance</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://tscount.r-forge.r-project.org">http://tscount.r-forge.r-project.org</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-07 20:29:11 UTC; Tobias</td>
</tr>
<tr>
<td>Author:</td>
<td>Tobias Liboschik [aut, cre],
  Roland Fried [aut],
  Konstantinos Fokianos [aut],
  Philipp Probst [aut],
  Jonathan Rathjens [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tobias Liboschik &lt;liboschik@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-08 07:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='tscount-package'>
Analysis of Count Time Series
</h2><span id='topic+tscount-package'></span><span id='topic+tscount'></span>

<h3>Description</h3>

<p>Collection of R functions for analysis of count time series. Currently the focus is on count time series following generalised linear models.
</p>


<h3>Details</h3>

<p>See the main function <code><a href="#topic+tsglm">tsglm</a></code> for more details on the usage of the package. There is a vignette available which introduces the functionality of the package and its underlying statistical methods (<code>vignette("tsglm", package="tscount")</code>).
</p>


<h3>Author(s)</h3>

<p>Tobias Liboschik &lt;liboschik@statistik.tu-dortmund.de&gt;
</p>


<h3>References</h3>

<p>Christou, V. and Fokianos, K. (2014) Quasi-likelihood inference for negative binomial time series models. <em>Journal of Time Series Analysis</em> <b>35(1)</b>, 55&ndash;78, <a href="http://dx.doi.org/10.1002/jtsa.12050">http://dx.doi.org/10.1002/jtsa.12050</a>.
</p>
<p>Christou, V. and Fokianos, K. (2015) Estimation and testing linearity for non-linear mixed poisson autoregressions. <em>Electronic Journal of Statistics</em> <b>9</b>, 1357&ndash;1377, <a href="http://dx.doi.org/10.1214/15-EJS1044">http://dx.doi.org/10.1214/15-EJS1044</a>.
</p>
<p>Ferland, R., Latour, A. and Oraichi, D. (2006) Integer-valued GARCH process. <em>Journal of Time Series Analysis</em> <b>27(6)</b>, 923&ndash;942, <a href="http://dx.doi.org/10.1111/j.1467-9892.2006.00496.x">http://dx.doi.org/10.1111/j.1467-9892.2006.00496.x</a>.
</p>
<p>Fokianos, K. and Fried, R. (2010) Interventions in INGARCH processes. <em>Journal of Time Series Analysis</em> <b>31(3)</b>, 210&ndash;225, <a href="http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x">http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x</a>.
</p>
<p>Fokianos, K., and Fried, R. (2012) Interventions in log-linear Poisson autoregression. <em>Statistical Modelling</em> <b>12(4)</b>, 299&ndash;322. <a href="http://dx.doi.org/10.1177/1471082X1201200401">http://dx.doi.org/10.1177/1471082X1201200401</a>.
</p>
<p>Fokianos, K., Rahbek, A. and Tjostheim, D. (2009) Poisson autoregression. <em>Journal of the American Statistical Association</em> <b>104(488)</b>, 1430&ndash;1439, <a href="http://dx.doi.org/10.1198/jasa.2009.tm08270">http://dx.doi.org/10.1198/jasa.2009.tm08270</a>.
</p>
<p>Fokianos, K. and Tjostheim, D. (2011) Log-linear Poisson autoregression. <em>Journal of Multivariate Analysis</em> <b>102(3)</b>, 563&ndash;578, <a href="http://dx.doi.org/10.1016/j.jmva.2010.11.002">http://dx.doi.org/10.1016/j.jmva.2010.11.002</a>.
</p>
<p>Liboschik, T. (2016) Modelling count time series following generalized linear models. <em>PhD Thesis TU Dortmund University</em>, <a href="http://dx.doi.org/10.17877/DE290R-17191">http://dx.doi.org/10.17877/DE290R-17191</a>.
</p>
<p>Liboschik, T., Kerschke, P., Fokianos, K. and Fried, R. (2016) Modelling interventions in INGARCH processes. <em>International Journal of Computer Mathematics</em> <b>93(4)</b>, 640&ndash;657, <a href="http://dx.doi.org/10.1080/00207160.2014.949250">http://dx.doi.org/10.1080/00207160.2014.949250</a>.
</p>
<p>Liboschik, T., Fokianos, K. and Fried, R. (2017) tscount: An R package for analysis of count time series following generalized linear models. <em>Journal of Statistical Software</em> <b>82(5)</b>, 1&ndash;51, <a href="http://dx.doi.org/10.18637/jss.v082.i05">http://dx.doi.org/10.18637/jss.v082.i05</a>.
</p>

<hr>
<h2 id='campy'>
Campylobacter Infections Time Series
</h2><span id='topic+campy'></span>

<h3>Description</h3>

<p>Time series with the number of cases of campylobacter infections in the north of the province Quebec (Canada) in four week intervals from January 1990 to the end of October 2000. It has 13 observations per year and 140 observations in total.
Campylobacterosis is an acute bacterial infectious disease attacking the digestive system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>campy
</code></pre>


<h3>Format</h3>

<p>A time series of class <code>"ts"</code>.
</p>


<h3>Source</h3>

<p>Ferland, R., Latour, A. and Oraichi, D. (2006) Integer-valued GARCH process. <em>Journal of Time Series Analysis</em> <b>27(6)</b>, 923&ndash;942, <a href="http://dx.doi.org/10.1111/j.1467-9892.2006.00496.x">http://dx.doi.org/10.1111/j.1467-9892.2006.00496.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecoli">ecoli</a></code>, <code><a href="#topic+ehec">ehec</a></code>, <code><a href="#topic+influenza">influenza</a></code>, <code><a href="#topic+measles">measles</a></code> in this package, <code><a href="gamlss.data.html#topic+polio">polio</a></code> in package <code>gamlss.data</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(campy)

#Fit the INGARCH model used in Ferland et al. (2006):
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
summary(campyfit)
plot(campyfit)
#Note that these parameter estimations differ from those obtained by
#Ferland et al. (2006). This might be due to a different initialisation
#of pre-sample values and different optimisation algorithms (they use
#Microsoft Excel Solver Macro). 
</code></pre>

<hr>
<h2 id='countdistr'>
Count Data Distributions 
</h2><span id='topic+countdistr'></span><span id='topic+ddistr'></span><span id='topic+pdistr'></span><span id='topic+qdistr'></span><span id='topic+rdistr'></span><span id='topic+sddistr'></span><span id='topic+ardistr'></span><span id='topic+checkdistr'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation, standard deviation and Anscombe residuals for some count data distributions. These auxiliary functions are used by several functions of the <code>tscount</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddistr(x, meanvalue, distr=c("poisson", "nbinom"), distrcoefs, ...)
pdistr(q, meanvalue, distr=c("poisson", "nbinom"), distrcoefs, ...)
qdistr(p, meanvalue, distr=c("poisson", "nbinom"), distrcoefs, ...)
rdistr(n, meanvalue, distr=c("poisson", "nbinom"), distrcoefs)
sddistr(meanvalue, distr=c("poisson", "nbinom"), distrcoefs)
ardistr(response, meanvalue, distr=c("poisson", "nbinom"), distrcoefs)
checkdistr(distr=c("poisson", "nbinom"), distrcoefs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countdistr_+3A_x">x</code></td>
<td>

<p>vector of (non-negative integer) quantiles.
</p>
</td></tr>
<tr><td><code id="countdistr_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="countdistr_+3A_p">p</code></td>
<td>

<p>vector of probabilities.
</p>
</td></tr>
<tr><td><code id="countdistr_+3A_n">n</code></td>
<td>

<p>positive integer value giving the number of random values to return.
</p>
</td></tr>
<tr><td><code id="countdistr_+3A_response">response</code></td>
<td>

<p>vector of true observations for calculation of residuals.
</p>
</td></tr>
<tr><td><code id="countdistr_+3A_meanvalue">meanvalue</code></td>
<td>

<p>non-negative numeric vector of means.
</p>
</td></tr>
<tr><td><code id="countdistr_+3A_distr">distr</code></td>
<td>

<p>character value giving the distribution. Possible values are currently <code>"poisson"</code> (the default) for the <code><a href="stats.html#topic+Poisson">Poisson</a></code> distribution and <code>"nbinom"</code> for the <code><a href="stats.html#topic+NegBinomial">NegBinomial</a></code> distribution.
</p>
</td></tr>
<tr><td><code id="countdistr_+3A_distrcoefs">distrcoefs</code></td>
<td>

<p>vector of additional distribution coefficients. For the Poisson distribution this argument can be omitted. For the negative binomial distribution it needs to be a vector of length one giving the value for the parameter <code>size</code> as specified in <code><a href="stats.html#topic+NegBinomial">NegBinomial</a></code>.
</p>
</td></tr>
<tr><td><code id="countdistr_+3A_...">...</code></td>
<td>

<p>additional arguments <code>logt</code>, <code>lower.tail</code> or <code>log.p</code> to be passed to other functions (see <code><a href="stats.html#topic+Poisson">Poisson</a></code> or <code><a href="stats.html#topic+NegBinomial">NegBinomial</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, these function are wrappers for specific functions for the respective distribution. The function <code>ddistr</code> gives the density of the specified distribution, <code>pdistr</code> the distribution function, <code>qdistr</code> the quantile function and <code>rdistr</code> generates random deviates from this distribution. These functions are a generalisation of the respective functions where <code>distr</code> is replaced by either <code>pois</code> or <code>nbinom</code>. The function <code>sddistr</code> returns the standard deviation of the specified distribution. The function <code>ardistr</code> calculates Anscombe residuals for given values of the response. The function <code>checkdistr</code> is for verification of the arguments <code>distr</code> and <code>distrcoefs</code>. 
</p>


<h3>Author(s)</h3>

<p>Tobias Liboschik
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Poisson">Poisson</a></code> for the Poisson distribution and <code><a href="stats.html#topic+NegBinomial">NegBinomial</a></code> for the negative binomial distribution.
</p>
<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a more genereal GLM for time series of counts.
</p>

<hr>
<h2 id='ecoli'>
E. coli Infections Time Series
</h2><span id='topic+ecoli'></span>

<h3>Description</h3>

<p>Weekly number of reported disease cases caused by Escherichia coli in the state of North Rhine-Westphalia (Germany) from January 2001 to May 2013, excluding cases of EHEC and HUS. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecoli
</code></pre>


<h3>Format</h3>

<p>A data frame with variables <code>year</code> and <code>week</code> giving the year and calendar week of observation, and with a variable <code>cases</code> giving the number of reported cases in the respective week.
</p>


<h3>Source</h3>

<p>Robert Koch Institute: SurvStat@RKI, <a href="https://survstat.rki.de">https://survstat.rki.de</a>, accessed on 10th June 2013.
</p>
<p>The data are provided with kind permission of the Robert Koch Institute. Further details and terms of usage are given at <a href="https://survstat.rki.de">https://survstat.rki.de</a>. More data reported under the German Infectious Diseases Protection Act is available via the SurvStat@RKI web application linked above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+campy">campy</a></code>, <code><a href="#topic+ehec">ehec</a></code>, <code><a href="#topic+influenza">influenza</a></code>, <code><a href="#topic+measles">measles</a></code> in this package, <code><a href="gamlss.data.html#topic+polio">polio</a></code> in package <code>gamlss.data</code>
</p>

<hr>
<h2 id='ehec'>
EHEC Infections Time Series
</h2><span id='topic+ehec'></span>

<h3>Description</h3>

<p>Weekly number of reported EHEC/HUS infections in the state of North Rhine-Westphalia (Germany) from January 2001 to May 2013. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ehec
</code></pre>


<h3>Format</h3>

<p>A data frame with variables <code>year</code> and <code>week</code> giving the year and calendar week of observation, and with a variable <code>cases</code> giving the number of reported cases in the respective week.
</p>


<h3>Source</h3>

<p>Robert Koch Institute: SurvStat@RKI, <a href="https://survstat.rki.de">https://survstat.rki.de</a>, accessed on 10th June 2013.
</p>
<p>The data are provided with kind permission of the Robert Koch Institute. Further details and terms of usage are given at <a href="https://survstat.rki.de">https://survstat.rki.de</a>. More data reported under the German Infectious Diseases Protection Act is available via the SurvStat@RKI web application linked above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+campy">campy</a></code>, <code><a href="#topic+ecoli">ecoli</a></code>, <code><a href="#topic+influenza">influenza</a></code>, <code><a href="#topic+measles">measles</a></code> in this package, <code><a href="gamlss.data.html#topic+polio">polio</a></code> in package <code>gamlss.data</code>
</p>

<hr>
<h2 id='influenza'>
Influenza Infections Time Series
</h2><span id='topic+influenza'></span>

<h3>Description</h3>

<p>Weekly number of reported influenza cases in the state of North Rhine-Westphalia (Germany) from January 2001 to May 2013. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>influenza
</code></pre>


<h3>Format</h3>

<p>A data frame with variables <code>year</code> and <code>week</code> giving the year and calendar week of observation, and with a variable <code>cases</code> giving the number of reported cases in the respective week.
</p>


<h3>Source</h3>

<p>Robert Koch Institute: SurvStat@RKI, <a href="https://survstat.rki.de">https://survstat.rki.de</a>, accessed on 10th June 2013.
</p>
<p>The data are provided with kind permission of the Robert Koch Institute. Further details and terms of usage are given at <a href="https://survstat.rki.de">https://survstat.rki.de</a>. More data reported under the German Infectious Diseases Protection Act is available via the SurvStat@RKI web application linked above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+campy">campy</a></code>, <code><a href="#topic+ecoli">ecoli</a></code>, <code><a href="#topic+ehec">ehec</a></code>, <code><a href="#topic+measles">measles</a></code> in this package, <code><a href="gamlss.data.html#topic+polio">polio</a></code> in package <code>gamlss.data</code>
</p>

<hr>
<h2 id='ingarch.analytical'>
Analytical Mean, Variance and Autocorrelation of an INGARCH Process 
</h2><span id='topic+ingarch.analytical'></span><span id='topic+ingarch.mean'></span><span id='topic+ingarch.acf'></span><span id='topic+ingarch.var'></span>

<h3>Description</h3>

<p>Functions to calculate the analytical mean, variance and autocorrelation / partial autocorrelation / autocovariance function of an integer-valued generalised autoregressive conditional heteroscedasticity (INGARCH) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ingarch.mean(intercept, past_obs=NULL, past_mean=NULL)
ingarch.var(intercept, past_obs=NULL, past_mean=NULL)
ingarch.acf(intercept, past_obs=NULL, past_mean=NULL, lag.max=10,
        type=c("acf", "pacf", "acvf"), plot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ingarch.analytical_+3A_intercept">intercept</code></td>
<td>

<p>numeric positive value for the intercept <code class="reqn">\beta_0</code>.
</p>
</td></tr>
<tr><td><code id="ingarch.analytical_+3A_past_obs">past_obs</code></td>
<td>

<p>numeric non-negative vector containing the coefficients <code class="reqn">\beta_1,\ldots, \beta_p</code> for regression on previous observations (see Details).
</p>
</td></tr>
<tr><td><code id="ingarch.analytical_+3A_past_mean">past_mean</code></td>
<td>

<p>numeric non-negative vector containing the coefficients <code class="reqn">\alpha_1,\ldots, \alpha_q</code> for regression on previous conditional means (see Details).
</p>
</td></tr>
<tr><td><code id="ingarch.analytical_+3A_lag.max">lag.max</code></td>
<td>

<p>integer value indicating how many lags of the (partial) autocorrelation / autocovariance function should be calculated.
</p>
</td></tr>
<tr><td><code id="ingarch.analytical_+3A_type">type</code></td>
<td>

<p>character. If <code>type="acf"</code> (the default) the autocorrelation function is calculated, <code>"pacf"</code> gives the partial autocorrelation function and <code>"acvf"</code> the autocovariance function.
</p>
</td></tr>
<tr><td><code id="ingarch.analytical_+3A_plot">plot</code></td>
<td>

<p>logical. If <code>plot=TRUE</code> (the default) the values are plotted and returned invisible. 
</p>
</td></tr>
<tr><td><code id="ingarch.analytical_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to function <code><a href="base.html#topic+plot">plot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The INGARCH model of order <code class="reqn">p</code> and <code class="reqn">q</code> used here follows the definition
</p>
<p style="text-align: center;"><code class="reqn">Z_{t}|{\cal{F}}_{t-1} \sim \mathrm{Poi}(\kappa_{t}),</code>
</p>

<p>where <code class="reqn">{\cal{F}}_{t-1}</code> is the history of the process up to time <code class="reqn">t-1</code> and <code class="reqn">\mathrm{Poi}</code> is the Poisson distribution parametrised by its mean (cf. Ferland et al., 2006).
The conditional mean <code class="reqn">\kappa_t</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\kappa_t = \beta_0 + \beta_1 Z_{t-1} + \ldots + \beta_p Z_{t-p}
    + \alpha_1 \kappa_{t-1} + \ldots  + \alpha_q \kappa_{t-q}.</code>
</p>

<p>The function <code>ingarch.acf</code> depends on the function <code><a href="ltsa.html#topic+tacvfARMA">tacvfARMA</a></code> from package <code>ltsa</code>, which needs to be installed.
</p>


<h3>Author(s)</h3>

<p>Tobias Liboschik
</p>


<h3>References</h3>

<p>Ferland, R., Latour, A. and Oraichi, D. (2006) Integer-valued GARCH process. <em>Journal of Time Series Analysis</em> <b>27(6)</b>, 923&ndash;942, <a href="http://dx.doi.org/10.1111/j.1467-9892.2006.00496.x">http://dx.doi.org/10.1111/j.1467-9892.2006.00496.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a more genereal GLM for time series of counts of which this INGARCH model is a special case. <code><a href="#topic+tsglm.sim">tsglm.sim</a></code> for simulation from such a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ingarch.mean(0.3, c(0.1,0.1), 0.1)
## Not run: 
ingarch.var(0.3, c(0.1,0.1), 0.1)
ingarch.acf(0.3, c(0.1,0.1,0.1), 0.1, type="acf", lag.max=15)
## End(Not run)
</code></pre>

<hr>
<h2 id='interv_covariate'>
Describing Intervention Effects for Time Series with Deterministic Covariates
</h2><span id='topic+interv_covariate'></span>

<h3>Description</h3>

<p>Generates covariates describing certain types of intervention effects according to the definition by Fokianos and Fried (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interv_covariate(n, tau, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interv_covariate_+3A_n">n</code></td>
<td>

<p>integer value giving the number of observations the covariates should have.
</p>
</td></tr>
<tr><td><code id="interv_covariate_+3A_tau">tau</code></td>
<td>

<p>integer vector giving the times where intervention effects occur.
</p>
</td></tr>
<tr><td><code id="interv_covariate_+3A_delta">delta</code></td>
<td>

<p>numeric vector with constants specifying the type of intervention (see Details). Must be of the same length as <code>tau</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intervention effect occuring at time <code class="reqn">\tau</code> is described by the covariate
</p>
<p style="text-align: center;"><code class="reqn">X_t = \delta^{t-\tau} I_{[\tau,\infty)}(t),</code>
</p>

<p>where <code class="reqn">I_{[\tau,\infty)}(t)</code> is the indicator function which is 0 for <code class="reqn">t &lt; \tau</code> and 1 for <code class="reqn">t \geq \tau</code>. The constant <code class="reqn">\delta</code> with <code class="reqn">0 \leq \delta \leq 1</code> specifies the type of intervention. For <code class="reqn">\delta = 0</code> the intervention has an effect only at the time of its occurence, for <code class="reqn">0 &lt; \delta &lt; 1</code> the effect decays exponentially and for <code class="reqn">\delta = 1</code> there is a persistent effect of the intervention after its occurence.
</p>
<p>If <code>tau</code> and <code>delta</code> are vectors, one covariate is generated with <code>tau[1]</code> as <code class="reqn">\tau</code> and <code>delta[1]</code> as <code class="reqn">\delta</code>, another covariate for the second elements and so on.
</p>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>length(tau)</code> columns. The generated covariates describing the interventions are the columns of the matrix.
</p>


<h3>Author(s)</h3>

<p>Tobias Liboschik
</p>


<h3>References</h3>

<p>Fokianos, K. and Fried, R. (2010) Interventions in INGARCH processes. <em>Journal of Time Series Analysis</em> <b>31(3)</b>, 210&ndash;225, <a href="http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x">http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x</a>.
</p>
<p>Fokianos, K., and Fried, R. (2012) Interventions in log-linear Poisson autoregression. <em>Statistical Modelling</em> <b>12(4)</b>, 299&ndash;322. <a href="http://dx.doi.org/10.1177/1471082X1201200401">http://dx.doi.org/10.1177/1471082X1201200401</a>.
</p>
<p>Liboschik, T. (2016) Modelling count time series following generalized linear models. <em>PhD Thesis TU Dortmund University</em>, <a href="http://dx.doi.org/10.17877/DE290R-17191">http://dx.doi.org/10.17877/DE290R-17191</a>.
</p>
<p>Liboschik, T., Kerschke, P., Fokianos, K. and Fried, R. (2016) Modelling interventions in INGARCH processes. <em>International Journal of Computer Mathematics</em> <b>93(4)</b>, 640&ndash;657, <a href="http://dx.doi.org/10.1080/00207160.2014.949250">http://dx.doi.org/10.1080/00207160.2014.949250</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
<code><a href="#topic+interv_test.tsglm">interv_test</a></code>, <code><a href="#topic+interv_detect.tsglm">interv_detect</a></code> and <code><a href="#topic+interv_multiple.tsglm">interv_multiple</a></code> for tests and detection procedures for intervention effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>interv_covariate(n=140, tau=c(84,100), delta=c(1,0))
</code></pre>

<hr>
<h2 id='interv_detect.tsglm'>
Detecting an Intervention in Count Time Series Following Generalised Linear Models
</h2><span id='topic+interv_detect.tsglm'></span><span id='topic+interv_detect'></span>

<h3>Description</h3>

<p>Detection procedure for an intervention of given type occuring at unknown time as proposed by Fokianos and Fried (2010, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
interv_detect(fit, taus=2:length(fit$ts), delta, external=FALSE, 
              B=NULL, info=c("score"), start.control_bootstrap, 
              final.control_bootstrap, inter.control_bootstrap, 
              parallel=FALSE, est_interv=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interv_detect.tsglm_+3A_fit">fit</code></td>
<td>

<p>an object of class <code>"tsglm"</code>. Usually the result of a call to <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code id="interv_detect.tsglm_+3A_taus">taus</code></td>
<td>

<p>integer vector of time points which are considered for the possible intervention to occur.
Default is to consider all possible time points.
</p>
</td></tr>
<tr><td><code id="interv_detect.tsglm_+3A_delta">delta</code></td>
<td>

<p>numeric value that determines the type of intervention (see Details).
</p>
</td></tr>
<tr><td><code id="interv_detect.tsglm_+3A_external">external</code></td>
<td>

<p>logical value specifying wether the intervention's effect is external or not (see Details).
</p>
</td></tr> 
<tr><td><code id="interv_detect.tsglm_+3A_b">B</code></td>
<td>

<p>positive integer value giving the number of bootstrap samples for estimation of the p-value. For <code>B=NULL</code> (the default) no p-value is returned.
</p>
</td></tr>
<tr><td><code id="interv_detect.tsglm_+3A_info">info</code></td>
<td>

<p>character value that determines how to calculate the information matrix, see <code><a href="#topic+tsglm">tsglm</a></code>. Currently <code>"score"</code> is the only possible choice.
</p>
</td></tr>
<tr><td><code id="interv_detect.tsglm_+3A_start.control_bootstrap">start.control_bootstrap</code></td>
<td>

<p>named list that determines how to make initial estimation in the bootstrap, see argument <code>start.control</code> in <code><a href="#topic+tsglm">tsglm</a></code>. If missing, the same settings as for the regular estimation are used.
</p>
</td></tr>
<tr><td><code id="interv_detect.tsglm_+3A_final.control_bootstrap">final.control_bootstrap</code></td>
<td>

<p>named list that determines how to make final maximum likelihood estimation in the bootstrap, see argument <code>final.control</code> in <code><a href="#topic+tsglm">tsglm</a></code>. If missing, the same settings as for the regular estimation are used. If <code>final.control_bootstrap=NULL</code>, then the model is not re-fitted for each bootstrap sample. Instead the parameters of the original fit which have been used for simulating the bootstrap samples are used. This approach saves computation time at the cost of a more conservative procedure, see Fokianos and Fried (2012).
</p>
</td></tr>
<tr><td><code id="interv_detect.tsglm_+3A_inter.control_bootstrap">inter.control_bootstrap</code></td>
<td>

<p>named list  determining how to maximise the log-likelihood function in an intermediate step, see argument <code>inter.control</code> in <code><a href="#topic+tsglm">tsglm</a></code>. If missing, the same settings as for the regular estimation are used.
</p>
</td></tr>
<tr><td><code id="interv_detect.tsglm_+3A_parallel">parallel</code></td>
<td>

<p>logical value. If <code>parallel=TRUE</code>, the bootstrap is distributed to multiple cores parallely. Requires a computing cluster to be initialised and registered as the default cluster by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> and <code><a href="parallel.html#topic+setDefaultCluster">setDefaultCluster</a></code> from package <code>parallel</code>.
</p>
</td></tr>
<tr><td><code id="interv_detect.tsglm_+3A_est_interv">est_interv</code></td>
<td>

<p>logical value. If <code>est_interv=TRUE</code> a fit for the model with the intervention effect with the largest test statistic is computed and additionally returned.
</p>
</td></tr>
<tr><td><code id="interv_detect.tsglm_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the fitting function <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each time in <code>taus</code> the score test statistic for an intervention effect occuring at that time is computed, see <code><a href="#topic+interv_test.tsglm">interv_test</a></code>. The time with the maximum test statistic is considered as a candidate for a possible intervention effect at that time. The type of the intervention effect is specified by <code>delta</code> as described in <code><a href="#topic+interv_covariate">interv_covariate</a></code>.  The intervention is included as an additional covariate according to the definition in <code><a href="#topic+tsglm">tsglm</a></code>. It can have an internal (the default) or external (<code>external=TRUE</code>) effect (see Liboschik et al., 2014).
</p>
<p>If argument <code>B</code> is not <code>NULL</code>, the null hypothesis that there is no intervention effect at any time is tested. Test statistic for this test is the maximum test statistic of the score test (see above). The p-value is computed by a parametric bootstrap with <code>B</code> bootstrap samples. It is recommended to use at least several hundred bootstrap samples. Note that this bootstrap procedure is very time-consuming.
</p>


<h3>Value</h3>

<p>An object of class <code>"interv_detect"</code>, which is a list with at least the following components:
</p>
<table role = "presentation">
<tr><td><code>test_statistic</code></td>
<td>

<p>maximum value of the score test statistics for all considered times in <code>taus</code>.
</p>
</td></tr>
<tr><td><code>test_statistic_tau</code></td>
<td>

<p>numeric vector of all score test statistics at the considered times in <code>taus</code>.
</p>
</td></tr>
<tr><td><code>tau_max</code></td>
<td>

<p>time at which the score test statistic has its maximum.
</p>
</td></tr>
<tr><td><code>fit_H0</code></td>
<td>

<p>object of class <code>"tsglm"</code> with the fitted model under the null hypothesis of no intervention, see <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code>model_interv</code></td>
<td>

<p>model specification of the model with the specified intervention at time <code>tau_max</code>.
</p>
</td></tr>
</table>
<p>If argument <code>est_interv=TRUE</code> (the default), the following component is additionally returned:
</p>
<table role = "presentation">
<tr><td><code>fit_interv</code></td>
<td>

<p>object of class <code>"tsglm"</code> with the fitted model with the specified intervention at time <code>tau_max</code>, see <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Liboschik, Philipp Probst, Konstantinos Fokianos and Roland Fried
</p>


<h3>References</h3>

<p>Fokianos, K. and Fried, R. (2010) Interventions in INGARCH processes. <em>Journal of Time Series Analysis</em> <b>31(3)</b>, 210&ndash;225, <a href="http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x">http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x</a>.
</p>
<p>Fokianos, K., and Fried, R. (2012) Interventions in log-linear Poisson autoregression. <em>Statistical Modelling</em> <b>12(4)</b>, 299&ndash;322. <a href="http://dx.doi.org/10.1177/1471082X1201200401">http://dx.doi.org/10.1177/1471082X1201200401</a>.
</p>
<p>Liboschik, T. (2016) Modelling count time series following generalized linear models. <em>PhD Thesis TU Dortmund University</em>, <a href="http://dx.doi.org/10.17877/DE290R-17191">http://dx.doi.org/10.17877/DE290R-17191</a>.
</p>
<p>Liboschik, T., Kerschke, P., Fokianos, K. and Fried, R. (2016) Modelling interventions in INGARCH processes. <em>International Journal of Computer Mathematics</em> <b>93(4)</b>, 640&ndash;657, <a href="http://dx.doi.org/10.1080/00207160.2014.949250">http://dx.doi.org/10.1080/00207160.2014.949250</a>.
</p>


<h3>See Also</h3>

<p>S3 methods <code><a href="base.html#topic+print">print</a></code> and <code><a href="#topic+plot.interv_detect">plot</a></code>.
</p>
<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
<code><a href="#topic+interv_test.tsglm">interv_test</a></code> for testing on intervention effects and <code><a href="#topic+interv_multiple.tsglm">interv_multiple</a></code> for iterative detection of multiple interventions of unknown types. <code><a href="#topic+interv_covariate">interv_covariate</a></code> for generation of deterministic covariates describing intervention effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Campylobacter infections in Canada (see help("campy"))
#Searching for a potential intervention effect:
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
campyfit_intervdetect &lt;- interv_detect(fit=campyfit, taus=80:120, delta=1)
campyfit_intervdetect
plot(campyfit_intervdetect)
#Additionally computing a p-value with the bootstrap procedure based on 500
#replications would take about 20 minutes in this example on a single
#processing unit, of course depending on its speed.

## Not run: 
#Parallel computation for shorter run time on a cluster:
library(parallel)
ntasks &lt;- 3
clust &lt;- makeCluster(ntasks)
setDefaultCluster(cl=clust)
interv_detect(fit=campyfit, taus=80:120, delta=1, B=500, parallel=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='interv_multiple.tsglm'>
Detecting Multiple Interventions in Count Time Series Following Generalised Linear Models
</h2><span id='topic+interv_multiple.tsglm'></span><span id='topic+interv_multiple'></span>

<h3>Description</h3>

<p>Iterative detection procedure for multiple interventions of unknown types occuring at unknown times as proposed by Fokianos and Fried (2010, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
interv_multiple(fit, taus=2:length(fit$ts), deltas=c(0,0.8,1),
                external=FALSE, B=10, signif_level=0.05,
                start.control_bootstrap, final.control_bootstrap,
                inter.control_bootstrap, parallel=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interv_multiple.tsglm_+3A_fit">fit</code></td>
<td>

<p>an object of class <code>"tsglm"</code>. Usually the result of a call to <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code id="interv_multiple.tsglm_+3A_taus">taus</code></td>
<td>

<p>integer vector of times which are considered for the possible intervention to occur.
Default is to consider all times.
</p>
</td></tr>
<tr><td><code id="interv_multiple.tsglm_+3A_deltas">deltas</code></td>
<td>

<p>numeric vector that determines the types of intervention to be considered (see Details).
</p>
</td></tr>
<tr><td><code id="interv_multiple.tsglm_+3A_external">external</code></td>
<td>

<p>logical value specifying wether the interventions effect is external or not (see Details).
</p>
</td></tr> 
<tr><td><code id="interv_multiple.tsglm_+3A_b">B</code></td>
<td>

<p>positive integer value giving the number of bootstrap samples for estimation of the p-value.
</p>
</td></tr>
<tr><td><code id="interv_multiple.tsglm_+3A_signif_level">signif_level</code></td>
<td>

<p>numeric value with <code>0 &lt;= signif_level &lt;= 1</code> giving a significance level for the procedure.
</p>
</td></tr>
<tr><td><code id="interv_multiple.tsglm_+3A_start.control_bootstrap">start.control_bootstrap</code></td>
<td>

<p>named list that determines how to make initial estimation in the bootstrap, see argument <code>start.control</code> in <code><a href="#topic+tsglm">tsglm</a></code>. If missing, the same settings as for the regular estimation are used.
</p>
</td></tr>
<tr><td><code id="interv_multiple.tsglm_+3A_final.control_bootstrap">final.control_bootstrap</code></td>
<td>

<p>named list that determines how to make final maximum likelihood estimation in the bootstrap, see argument <code>final.control</code> in <code><a href="#topic+tsglm">tsglm</a></code>. If missing, the same settings as for the regular estimation are used. If <code>final.control_bootstrap=NULL</code>, then the model is not re-fitted for each bootstrap sample. Instead the parameters of the original fit which have been used for simulating the bootstrap samples are used. This approach saves computation time at the cost of a more conservative procedure, see Fokianos and Fried (2012).
</p>
</td></tr>
<tr><td><code id="interv_multiple.tsglm_+3A_inter.control_bootstrap">inter.control_bootstrap</code></td>
<td>

<p>named list  determining how to maximise the log-likelihood function in an intermediate step, see argument <code>inter.control</code> in <code><a href="#topic+tsglm">tsglm</a></code>. If missing, the same settings as for the regular estimation are used.
</p>
</td></tr>
<tr><td><code id="interv_multiple.tsglm_+3A_parallel">parallel</code></td>
<td>

<p>logical value. If <code>parallel=TRUE</code>, the bootstrap is distributed to multiple cores parallely. Requires a computing cluster to be initialised and registered as the default cluster by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> and <code><a href="parallel.html#topic+setDefaultCluster">setDefaultCluster</a></code> from package <code>parallel</code>.
</p>
</td></tr>
<tr><td><code id="interv_multiple.tsglm_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the function for detection of single intervention effects <code><a href="#topic+interv_detect.tsglm">interv_detect</a></code> and via this function some of the arguments are passed to the fitting function <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs an iterative procedure for detection of multiple intervention effects. In each step the function <code><a href="#topic+interv_detect.tsglm">interv_detect</a></code> is applied for each of the possible intervention types provided in the argument <code>deltas</code>. If there is (after a Bonferroni correction) no significant intervention effect the procedure stops. Otherwise the type of intervention with the minimum p-value is chosen. In case of equal p-values preference is given to a level shift (i.e. <code class="reqn">\delta=1</code>) and then to the type of intervention with the largest test statistic. The effect of the chosen intervention is removed from the time series. The time series cleaned from the intervention effect is tested for further interventions in a next step.
</p>
<p>For each time in <code>taus</code> the test statistic of a score test on an intervention effect occuring at that time is computed, see <code><a href="#topic+interv_test.tsglm">interv_test</a></code>. The time with the maximum test statistic is considered as a candidate for a possible intervention effect at that time. The type of the intervention effect is specified by <code>delta</code> as described in <code><a href="#topic+interv_covariate">interv_covariate</a></code>. The intervention is included as an additional covariate according to the definition in <code><a href="#topic+tsglm">tsglm</a></code>. It can have an internal (the default) or external (<code>external=TRUE</code>) effect (see Liboschik et al., 2014).
</p>
<p>All p-values given in the output are multiplied by the number of intervention types considered to account for the multiple testing in each step by a Bonferroni correction. Note that this correction can lead to p-values greater than one.
</p>
<p>Note that this bootstrap procedure is very time-consuming.
</p>


<h3>Value</h3>

<p>An object of class <code>"interv_multiple"</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>interventions</code></td>
<td>

<p>data frame giving the detected interventions, which has the variables <code>tau</code>, <code>delta</code>, <code>size</code>, <code>test_statistic</code> and <code>p-value</code>. 
</p>
</td></tr>
<tr><td><code>fit_H0</code></td>
<td>

<p>object of class <code>"tsglm"</code> with the fitted model under the null hypothesis of no intervention, see <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code>fit_cleaned</code></td>
<td>

<p>object of class <code>"tsglm"</code> with the fitted model for the cleanded time series after the last step of the iterative procedure, see <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code>model_interv</code></td>
<td>

<p>model specification of the model with all detected interventions at their respective times.
</p>
</td></tr>
<tr><td><code>fit_interv</code></td>
<td>

<p>object of class <code>"tsglm"</code> with the fitted model with all detected interventions at their respective times, see <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code>track</code></td>
<td>

<p>named list of matrices with the detailed results of the iterative detection procedure. Element <code>tau_max</code> gives the times where the test statistic has its maximum for each type of intervention and in each iteration step and element <code>size</code> gives the estimated sizes of the respective intervention effects. Elements <code>test_statistic</code> and <code>p_value</code> require no further explanation.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Liboschik, Philipp Probst, Konstantinos Fokianos and Roland Fried
</p>


<h3>References</h3>

<p>Fokianos, K. and Fried, R. (2010) Interventions in INGARCH processes. <em>Journal of Time Series Analysis</em> <b>31(3)</b>, 210&ndash;225, <a href="http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x">http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x</a>.
</p>
<p>Fokianos, K., and Fried, R. (2012) Interventions in log-linear Poisson autoregression. <em>Statistical Modelling</em> <b>12(4)</b>, 299&ndash;322. <a href="http://dx.doi.org/10.1177/1471082X1201200401">http://dx.doi.org/10.1177/1471082X1201200401</a>.
</p>
<p>Liboschik, T. (2016) Modelling count time series following generalized linear models. <em>PhD Thesis TU Dortmund University</em>, <a href="http://dx.doi.org/10.17877/DE290R-17191">http://dx.doi.org/10.17877/DE290R-17191</a>.
</p>
<p>Liboschik, T., Kerschke, P., Fokianos, K. and Fried, R. (2016) Modelling interventions in INGARCH processes. <em>International Journal of Computer Mathematics</em> <b>93(4)</b>, 640&ndash;657, <a href="http://dx.doi.org/10.1080/00207160.2014.949250">http://dx.doi.org/10.1080/00207160.2014.949250</a>.
</p>


<h3>See Also</h3>

<p>S3 methods <code><a href="base.html#topic+print">print</a></code> and <code><a href="#topic+plot.interv_multiple">plot</a></code>.
</p>
<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
<code><a href="#topic+interv_test.tsglm">interv_test</a></code> for testing for intervention effects and <code><a href="#topic+interv_detect.tsglm">interv_detect</a></code> for detection of single interventions of given type. <code><a href="#topic+interv_covariate">interv_covariate</a></code> for generation of deterministic covariates describing intervention effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
###Campylobacter infections in Canada (see help("campy"))
#Searching for potential intervention effects (runs several hours!):
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
campyfit_intervmultiple &lt;- interv_multiple(fit=campyfit, taus=80:120,
                              deltas=c(0,0.8,1), B=500, signif_level=0.05)
campyfit_intervmultiple
plot(campyfir_intervmultiple)
#Parallel computation for shorter run time on a cluster:
library(parallel)
ntasks &lt;- 3
clust &lt;- makeCluster(ntasks)
setDefaultCluster(cl=clust)
interv_multiple(fit=campyfit, taus=80:120, deltas=c(0,0.8,1), B=500,
                signif_level=0.05, parallel=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='interv_test.tsglm'>
Testing for Interventions in Count Time Series Following Generalised Linear Models
</h2><span id='topic+interv_test.tsglm'></span><span id='topic+interv_test'></span>

<h3>Description</h3>

<p>Test for one or more interventions of given type at given time as proposed by Fokianos and Fried (2010, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
interv_test(fit, tau, delta, external, 
            info=c("score"), est_interv=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interv_test.tsglm_+3A_fit">fit</code></td>
<td>

<p>an object of class <code>"tsglm"</code>. Usually the result of a call to <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code id="interv_test.tsglm_+3A_tau">tau</code></td>
<td>

<p>integer vector of times at which the interventions occur which are tested for.
</p>
</td></tr>
<tr><td><code id="interv_test.tsglm_+3A_delta">delta</code></td>
<td>

<p>numeric vector that determines the types of the interventions (see Details). Must be of the same length as <code>tau</code>.
</p>
</td></tr>
<tr><td><code id="interv_test.tsglm_+3A_external">external</code></td>
<td>

<p>logical vector of length <code>length(tau)</code> specifying for each intervention wether its effect is external or not (see Details). If this is only a scalar this choice will be used for all interventions. If this is only a scalar this choice will be used for all interventions. If omitted all interventions will have an internal effect (i.e. <code>external=FALSE</code>).
</p>
</td></tr> 
<tr><td><code id="interv_test.tsglm_+3A_info">info</code></td>
<td>

<p>character value that determines how to calculate the information matrix, see <code><a href="#topic+tsglm">tsglm</a></code>. Currently <code>"score"</code> is the only possible choice.
</p>
</td></tr>
<tr><td><code id="interv_test.tsglm_+3A_est_interv">est_interv</code></td>
<td>

<p>logical value. If <code>est_interv=TRUE</code> a fit for the model with all specified interventions is computed and additionally returned.
</p>
</td></tr>
<tr><td><code id="interv_test.tsglm_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the fitting function <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A score test on the null hypothesis of no interventions is done. The null hypothesis is that the data are generated from the model specified in the argument <code>model</code>, see definition in <code><a href="#topic+tsglm">tsglm</a></code>. Under the alternative there are one or more intervention effects occuring at times <code>tau</code>. The types of the intervention effects are specified by <code>delta</code> as defined in <code><a href="#topic+interv_covariate">interv_covariate</a></code>. The interventions are included as additional covariates according to the definition in <code><a href="#topic+tsglm">tsglm</a></code>. It can have an internal (the default) or external (<code>external=TRUE</code>) effect (see Liboschik et al., 2014).
</p>
<p>Under the null hypothesis the test statistic has asymptotically a chi-square distribution with <code>length(tau)</code> (i.e. the number of breaks) degrees of freedom. The returned p-value is based on this and approximately valid for long time series, i.e. when <code>length(ts)</code> large.
</p>


<h3>Value</h3>

<p>An object of class <code>"interv_test"</code>, which is a list with at least the following components:
</p>
<table role = "presentation">
<tr><td><code>test_statistic</code></td>
<td>

<p>value of the test statistic.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>degrees of freedom of the chi-squared distribution the test statistic is compared with.
</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>

<p>p-value of the test.
</p>
</td></tr>
<tr><td><code>fit_H0</code></td>
<td>

<p>object of class <code>"tsglm"</code> with the fitted model under the null hypothesis of no intervention, see <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code>model_interv</code></td>
<td>

<p>model specification of the model with the specified interventions.
</p>
</td></tr>
</table>
<p>If argument <code>est_interv=TRUE</code>, the following component is additionally returned:
</p>
<table role = "presentation">
<tr><td><code>fit_interv</code></td>
<td>

<p>object of class <code>"tsglm"</code> with the fitted model with the specified interventions, see <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Liboschik, Philipp Probst, Konstantinos Fokianos and Roland Fried
</p>


<h3>References</h3>

<p>Fokianos, K. and Fried, R. (2010) Interventions in INGARCH processes. <em>Journal of Time Series Analysis</em> <b>31(3)</b>, 210&ndash;225, <a href="http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x">http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x</a>.
</p>
<p>Fokianos, K., and Fried, R. (2012) Interventions in log-linear Poisson autoregression. <em>Statistical Modelling</em> <b>12(4)</b>, 299&ndash;322. <a href="http://dx.doi.org/10.1177/1471082X1201200401">http://dx.doi.org/10.1177/1471082X1201200401</a>.
</p>
<p>Liboschik, T. (2016) Modelling count time series following generalized linear models. <em>PhD Thesis TU Dortmund University</em>, <a href="http://dx.doi.org/10.17877/DE290R-17191">http://dx.doi.org/10.17877/DE290R-17191</a>.
</p>
<p>Liboschik, T., Kerschke, P., Fokianos, K. and Fried, R. (2016) Modelling interventions in INGARCH processes. <em>International Journal of Computer Mathematics</em> <b>93(4)</b>, 640&ndash;657, <a href="http://dx.doi.org/10.1080/00207160.2014.949250">http://dx.doi.org/10.1080/00207160.2014.949250</a>.
</p>


<h3>See Also</h3>

<p>S3 method <code><a href="base.html#topic+print">print</a></code>.
</p>
<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
<code><a href="#topic+interv_detect.tsglm">interv_detect</a></code> for detection of single interventions of given type and <code><a href="#topic+interv_multiple.tsglm">interv_multiple</a></code> for iterative detection of multiple interventions of unknown types. <code><a href="#topic+interv_covariate">interv_covariate</a></code> for generation of deterministic covariates describing intervention effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Campylobacter infections in Canada (see help("campy"))
#Test for the intervention effects which were found in Fokianos und Fried (2010):
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
campyfit_intervtest &lt;- interv_test(fit=campyfit, tau=c(84,100), delta=c(1,0))
campyfit_intervtest
</code></pre>

<hr>
<h2 id='invertinfo'>
Compute a Covariance Matrix from a Fisher Information Matrix
</h2><span id='topic+invertinfo'></span>

<h3>Description</h3>

<p>Stable function for computing a covariance matrix from a given Fisher information matrix by inversion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertinfo(mat, silent=TRUE, stopOnError=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invertinfo_+3A_mat">mat</code></td>
<td>

<p>a Fisher Information Matrix.
</p>
</td></tr>
<tr><td><code id="invertinfo_+3A_silent">silent</code></td>
<td>

<p>logical value. If <code>FALSE</code>, errors in the computation of the inverse while using the Cholesky decomposition algorithm are printed.
If <code>TRUE</code>, errors can be seen only in the value <code>error_message</code>.
</p>
</td></tr>
<tr><td><code id="invertinfo_+3A_stoponerror">stopOnError</code></td>
<td>

<p>logical value. If <code>TRUE</code> only an error message is printed in case of error. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Cholesky decomposition is used to obtain the covariance matrix. This can be done because the Fisher information matrix is symmetric and positive definite.
</p>
<p>This function is meant to be a more stable alternative to the function <code><a href="base.html#topic+solve">solve</a></code>, which does not take into account, that the matrix is symmetric and positive definite.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>vcov</code></td>
<td>
<p>the covariance matrix.</p>
</td></tr>
<tr><td><code>error_message</code></td>
<td>
<p>possible error messages that occured when inverting the Fisher information matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Liboschik and Philipp Probst
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chol">chol</a></code> and <code><a href="base.html#topic+chol2inv">chol2inv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
invertinfo(Hilbert(5), stopOnError=TRUE)
invertinfo(Hilbert(100))
invertinfo(Hilbert(100), silent=FALSE)
## Not run: invertinfo(Hilbert(100), stopOnError=TRUE)
</code></pre>

<hr>
<h2 id='marcal'>
Predictive Model Assessment with a Marginal Calibration Plot
</h2><span id='topic+marcal'></span><span id='topic+marcal.default'></span><span id='topic+marcal.tsglm'></span>

<h3>Description</h3>

<p>The function produces a marginal calibration plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
marcal(object, plot=TRUE, ...)
## Default S3 method:
marcal(response, pred, distr=c("poisson", "nbinom"), distrcoefs, plot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marcal_+3A_object">object</code></td>
<td>

<p>an object of class <code>"tsglm"</code>.
</p>
</td></tr>
<tr><td><code id="marcal_+3A_plot">plot</code></td>
<td>

<p>logical. If <code>plot=TRUE</code> (the default), the marginal calibration is plotted and the underlying data are returned invisibly only. 
</p>
</td></tr>
<tr><td><code id="marcal_+3A_response">response</code></td>
<td>

<p>integer vector. Vector of observed values.
</p>
</td></tr>
<tr><td><code id="marcal_+3A_pred">pred</code></td>
<td>

<p>numeric vector. Vector of predicted values.
</p>
</td></tr>
<tr><td><code id="marcal_+3A_distr">distr</code></td>
<td>

<p>character giving the conditional distribution. Currently implemented are the Poisson (<code>"poisson"</code>)and the Negative Binomial (<code>"nbinom"</code>) distribution.
</p>
</td></tr>
<tr><td><code id="marcal_+3A_distrcoefs">distrcoefs</code></td>
<td>

<p>numeric vector of additional coefficients specifying the conditional distribution. For <code>distr="poisson"</code> no additional parameters need to be provided. For <code>distr="nbinom"</code> the additional parameter <code>size</code> needs to be specified (e.g. by <code>distrcoefs=2</code>), see <code><a href="#topic+tsglm">tsglm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="marcal_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <code><a href="base.html#topic+plot">plot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Marginal Calibration can be assessed by taking the difference between the average predictive cumulative distribution function (c.d.f.) and the empirical c.d.f. of the observations. Minor fluctuations about zero are expected if the marginal calibration hypothesis is true. For more information about marginal calibration see the refererences listed below.
</p>


<h3>Value</h3>

<p>Produces a plot of the difference between the average predictive cumulative distribution function (c.d.f.) and the empirical c.d.f. of the observations at each value between the highest and lowest observation of the time series (only for <code>plot=TRUE</code>).
</p>
<p>Returns a list with elements <code>x</code> and <code>y</code>, where <code>x</code> are the threshold values and <code>y</code> the respective differences of predictive and empirical cumulative distribution function (invisibly for <code>plot=TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Philipp Probst and Tobias Liboschik
</p>


<h3>References</h3>

<p>Christou, V. and Fokianos, K. (2013) On count time series prediction. <em>Journal of Statistical Computation and Simulation</em> (published online), <a href="http://dx.doi.org/10.1080/00949655.2013.823612">http://dx.doi.org/10.1080/00949655.2013.823612</a>.
</p>
<p>Czado, C., Gneiting, T. and Held, L. (2009) Predictive model assessment for count data. <em>Biometrics</em> <b>65</b>, 1254&ndash;1261, <a href="http://dx.doi.org/10.1111/j.1541-0420.2009.01191.x">http://dx.doi.org/10.1111/j.1541-0420.2009.01191.x</a>.
</p>
<p>Gneiting, T., Balabdaoui, F. and Raftery, A.E. (2007) Probabilistic forecasts, calibration and sharpness. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> <b>69</b>, 243&ndash;268, <a href="http://dx.doi.org/10.1111/j.1467-9868.2007.00587.x">http://dx.doi.org/10.1111/j.1467-9868.2007.00587.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
</p>
<p><code><a href="#topic+pit">pit</a></code> and <code><a href="#topic+scoring">scoring</a></code> for other predictive model assessment tools.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Campylobacter infections in Canada (see help("campy"))
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
marcal(campyfit)
</code></pre>

<hr>
<h2 id='measles'>
Measles Infections Time Series
</h2><span id='topic+measles'></span>

<h3>Description</h3>

<p>Weekly number of reported measles infections in the state of North Rhine-Westphalia (Germany) from January 2001 to May 2013. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measles
</code></pre>


<h3>Format</h3>

<p>A data frame with variables <code>year</code> and <code>week</code> giving the year and calendar week of observation, and with a variable <code>cases</code> giving the number of reported cases in the respective week.
</p>


<h3>Source</h3>

<p>Robert Koch Institute: SurvStat@RKI, <a href="https://survstat.rki.de">https://survstat.rki.de</a>, accessed on 10th June 2013.
</p>
<p>The data are provided with kind permission of the Robert Koch Institute. Further details and terms of usage are given at <a href="https://survstat.rki.de">https://survstat.rki.de</a>. More data reported under the German Infectious Diseases Protection Act is available via the SurvStat@RKI web application linked above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+campy">campy</a></code>, <code><a href="#topic+ecoli">ecoli</a></code>, <code><a href="#topic+ehec">ehec</a></code>, <code><a href="#topic+influenza">influenza</a></code> in this package, <code><a href="gamlss.data.html#topic+polio">polio</a></code> in package <code>gamlss.data</code>
</p>

<hr>
<h2 id='pit'>
Predictive Model Assessment with a Probability Integral Transform Histogram
</h2><span id='topic+pit'></span><span id='topic+pit.default'></span><span id='topic+pit.tsglm'></span>

<h3>Description</h3>

<p>The function allows a probabilistic calibration check with a Probability Integral Transform (PIT) histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
pit(object, bins=10, ...)
## Default S3 method:
pit(response, pred, distr=c("poisson", "nbinom"), distrcoefs, bins=10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pit_+3A_object">object</code></td>
<td>

<p>an object of class <code>"tsglm"</code>.
</p>
</td></tr>
<tr><td><code id="pit_+3A_bins">bins</code></td>
<td>

<p>number of bins in the histogram. Default value is 10.
</p>
</td></tr>
<tr><td><code id="pit_+3A_response">response</code></td>
<td>

<p>integer vector. Vector of observed values.
</p>
</td></tr>
<tr><td><code id="pit_+3A_pred">pred</code></td>
<td>

<p>numeric vector. Vector of predicted values.
</p>
</td></tr>
<tr><td><code id="pit_+3A_distr">distr</code></td>
<td>

<p>character giving the conditional distribution. Currently implemented are the Poisson (<code>"poisson"</code>)and the Negative Binomial (<code>"nbinom"</code>) distribution.
</p>
</td></tr>
<tr><td><code id="pit_+3A_distrcoefs">distrcoefs</code></td>
<td>

<p>numeric vector of additional coefficients specifying the conditional distribution. For <code>distr="poisson"</code> no additional parameters need to be provided. For <code>distr="nbinom"</code> the additional parameter <code>size</code> needs to be specified (e.g. by <code>distrcoefs=2</code>), see <code><a href="#topic+tsglm">tsglm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="pit_+3A_...">...</code></td>
<td>

<p>additional arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A PIT histogram is a tool for evaluating the statistical consistency between the probabilistic forecast and the observation. The predictive distributions of the observations are compared with the actual observations. If the predictive distribution is ideal the result should be a flat PIT histogram with no bin having an extraordinary high or low level. For more information about PIT histograms see the references listed below.
</p>


<h3>Author(s)</h3>

<p>Philipp Probst and Tobias Liboschik
</p>


<h3>References</h3>

<p>Christou, V. and Fokianos, K. (2013) On count time series prediction. <em>Journal of Statistical Computation and Simulation</em> (published online), <a href="http://dx.doi.org/10.1080/00949655.2013.823612">http://dx.doi.org/10.1080/00949655.2013.823612</a>.
</p>
<p>Czado, C., Gneiting, T. and Held, L. (2009) Predictive model assessment for count data. <em>Biometrics</em> <b>65</b>, 1254&ndash;1261, <a href="http://dx.doi.org/10.1111/j.1541-0420.2009.01191.x">http://dx.doi.org/10.1111/j.1541-0420.2009.01191.x</a>.
</p>
<p>Gneiting, T., Balabdaoui, F. and Raftery, A.E. (2007) Probabilistic forecasts, calibration and sharpness. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> <b>69</b>, 243&ndash;268, <a href="http://dx.doi.org/10.1111/j.1467-9868.2007.00587.x">http://dx.doi.org/10.1111/j.1467-9868.2007.00587.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
</p>
<p><code><a href="#topic+marcal">marcal</a></code> and <code><a href="#topic+scoring">scoring</a></code> for other predictive model assessment tools.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Campylobacter infections in Canada (see help("campy"))
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
pit(campyfit)
</code></pre>

<hr>
<h2 id='plot.interv_detect'>
Plot Test Statistic of Intervention Detection Procedure for Count Time Series Following Generalised Linear Models
</h2><span id='topic+plot.interv_detect'></span>

<h3>Description</h3>

<p>Provides a plot of the test statistics of a test on an intervention in GLM-type count time series (as returned by <code>interv_detect.tsglm</code>) against time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interv_detect'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.interv_detect_+3A_x">x</code></td>
<td>

<p>an object of class <code>"interv_detect"</code>, usually a result of a call to <code><a href="#topic+interv_detect.tsglm">interv_detect.tsglm</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.interv_detect_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to function <code><a href="base.html#topic+plot">plot</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Liboschik and Philipp Probst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interv_detect.tsglm">interv_detect</a></code> for detecting an intervention effect in GLM-type count time series and <code><a href="#topic+tsglm">tsglm</a></code> for fitting such a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
###Campylobacter infections in Canada (see help("campy"))
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
campyfit_intervdetect &lt;- interv_detect(fit=campyfit, taus=80:120,
                        delta=1, external=FALSE)
#This example runs about 20 minutes on a single processing unit,
#of course depending on its speed.
plot(campyfit_intervdetect)
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.interv_multiple'>
Plot for Iterative Intervention Detection Procedure for Count Time Series following Generalised Linear Models
</h2><span id='topic+plot.interv_multiple'></span>

<h3>Description</h3>

<p>Provides a plot with the intervention effects detected by an iterative procedure (as returned by <code><a href="#topic+interv_multiple.tsglm">interv_multiple.tsglm</a></code>) and the time series cleaned from these intervention effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interv_multiple'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.interv_multiple_+3A_x">x</code></td>
<td>

<p>an object of class <code>"interv_multiple"</code>, usually a result of a call to <code><a href="#topic+interv_detect.tsglm">interv_detect</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.interv_multiple_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to function <code><a href="base.html#topic+plot">plot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vertical red lines indicate where possible interventions were found and the dashed blue line is the time series cleaned from all detected intervention effects.
</p>


<h3>Author(s)</h3>

<p>Tobias Liboschik and Philipp Probst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interv_multiple.tsglm">interv_multiple</a></code> for detecting multiple intervention effects in GLM-type count time series and <code><a href="#topic+tsglm">tsglm</a></code> for fitting such a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
###Campylobacter infections in Canada (see help("campy"))
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
campyfit_intervmultiple &lt;- interv_multiple(fit=campyfit, taus=80:120,
                              deltas=c(0,0.8,1), external=FALSE, B=2,
                              signif_level=0.05) #runs several hours!
plot(campyfit_intervmultiple)
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.tsglm'>
Diagnostic Plots for a Fitted GLM-type Model for Time Series of Counts
</h2><span id='topic+plot.tsglm'></span>

<h3>Description</h3>

<p>Produces several diagnostic plots to asses the fit of a GLM-type model for time series of counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
plot(x, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tsglm_+3A_x">x</code></td>
<td>

<p>an object of class <code>"tsglm"</code>. Usually the result of a call to <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.tsglm_+3A_ask">ask</code></td>
<td>

<p>logical value. If <code>TRUE</code> (and the R session is interactive) the user is asked for input, before a new figure is drawn (see <code><a href="grDevices.html#topic+devAskNewPage">devAskNewPage</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.tsglm_+3A_...">...</code></td>
<td>

<p>further arguments are currently ignored. Only for compatibility with generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces plots of the acf of the Pearson residuals, the Pearson residuals plotted against time, a cumulative periodogramm of the Pearson residuals, a probability integral transform (PIT) histogram (see function <code><a href="#topic+pit">pit</a></code>) and a marginal calibration plot (see function <code><a href="#topic+marcal">marcal</a></code>). The cumulative periodogramm is plotted with the function <code><a href="stats.html#topic+cpgram">cpgram</a></code> from package <code>MASS</code> and is omitted with a warning if this package is not available.
</p>


<h3>Author(s)</h3>

<p>Tobias Liboschik and Philipp Probst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Campylobacter infections in Canada (see help("campy"))
interventions &lt;- interv_covariate(n=length(campy), tau=c(84, 100),
  delta=c(1, 0)) #detected by Fokianos and Fried (2010, 2012)
#Linear link function with Negative Binomial distribution:
campyfit &lt;- tsglm(campy, model=list(past_obs=1, past_mean=13),
  xreg=interventions, dist="nbinom")
plot(campyfit)
</code></pre>

<hr>
<h2 id='predict.tsglm'>
Predicts Method for Time Series of Counts Following Generalised Linear Models
</h2><span id='topic+predict.tsglm'></span>

<h3>Description</h3>

<p>Predict future observations based on a fitted GLM-type model for time series of counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
predict(object, n.ahead=1, newobs=NULL, newxreg=NULL, level=0.95,
        global=FALSE, type=c("quantiles", "shortest", "onesided"),
        method=c("conddistr", "bootstrap"), B=1000,
        estim=c("ignore", "bootstrap", "normapprox", "given"), B_estim=B,
        coefs_given, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.tsglm_+3A_object">object</code></td>
<td>

<p>an object of class <code>"tsglm"</code>. Usually the result of a call to <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_n.ahead">n.ahead</code></td>
<td>

<p>positive integer value giving the number of steps ahead for which predictions should be made.
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_newobs">newobs</code></td>
<td>

<p>integer vector of known future observations of the time series. This argument is only relevant if more than one observation ahead is to be predicted (<code>n.ahead</code> greater than 1). The <code class="reqn">h</code>-step-ahead prediction for <code class="reqn">h&gt;1</code> is computed as a 1-step-ahead prediction given all previous values, which can be observations of the original time series or new observations provided in this argument. Previous observations which are not available are replaced by their respective 1-step-ahead prediction.
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_newxreg">newxreg</code></td>
<td>

<p>matrix or vector containing new values for the covariates to be used for prediction. If <code>newxreg</code> is omitted or contains less rows than the value of <code>n.ahead</code>, the last known values of the covariates are used for prediction. This is usually not reasonable and it is strongly advised to explicitely make assumptions on future covariates and to specify the argument <code>xreg</code> accordingly. 
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_level">level</code></td>
<td>

<p>numeric value determining the desired coverage rate of prediction intervals. If <code>level=0</code> no prediction intervals are computed.
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_global">global</code></td>
<td>

<p>logical value saying whether the coverage rate for <code class="reqn">Y_{n+1},...,Y_{n+h}</code> specified by argument <code>level</code> holds globally (<code>global=TRUE</code>) or for each of the <code>n.ahead</code> prediction intervals individually (<code>global=FALSE</code>, the default). In the former case the individual coverage rate for a single prediction interval is Bonferroni adjusted to a level of <code>1-(1-level)/n.ahead</code>.
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_type">type</code></td>
<td>

<p>character value saying how the prediction interval shall be constructed. If <code>type="quantiles"</code> (the default), its limits are chosen to be the <code>a</code>- and <code>(1-a)</code>-quantiles of the respective (approximated) distribution, with <code>a=(1-level)/2</code>. If <code>type="shortest"</code> it is chosen such that it has minimal length. Note that these two types of construction principles frequently lead to the same result. If <code>type="onesided"</code> a one-sided prediction interval is constructed where the lower boundary is always zero.
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_method">method</code></td>
<td>

<p>character value saying which method to be used for computing the prediction intervals. If <code>method="conddistr"</code> the prediction intervals are based on the conditional distribution given by the model with the unknown parameters being replaced by their respective estimations. This is only possible if only 1-step-ahead predictions are to be computed (possibly recursively using the new observations given in argument <code>newobs</code>). If <code>method="bootstrap"</code> the predictive distribution is approximated by a parametric bootstrap where <code>B</code> trajectories of the process are simulated from the fitted model. This is currently only possible if no new observations are given in argument <code>newobs</code>. By default the method <code>"conddistr"</code> is prefered whenever it is appliccable.
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_b">B</code></td>
<td>

<p>positive integer value giving the number of samples of a parametric bootstrap to use for numerical determination of prediction intervals (only necessary if argument <code>method="bootstrap"</code>).
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_estim">estim</code></td>
<td>

<p>character value saying how the prediction intervals shall account for the additional uncertainty induced by the parameter estimation. This is particularly important if the model was fitted on a short time series. If <code>estim="ignore"</code> (the default), this additional uncertainty is ignored. The other two options (<code>estim="bootstrap"</code> and <code>estim="normapprox"</code>) are only possible if <code>method="bootstrap"</code>. If these are selected the bootstrap samples are not generated from a model with the parameters of the original fit. Instead, each of the <code>B</code> bootstrap samples is generated from a model with parameters which are itself randomly generated. This two-stage approach should take into account the additional estimation uncertainty.
If <code>estim="bootstrap"</code>, the parameters are obtained from a fit to a parametric bootstrap replication of the original time series.
If <code>estim="normapprox"</code>, the regression parameters are generated from a multivariate normal distribution which is based on the normal approximation of the original quasi maximum likelihood estimator and reflects the estimation uncertainty. In that case the additional distribution coefficients are not randomly generated such that their estimation uncertainty is ignored.
If <code>estim="given"</code>, the parameters are resampled from a table of possible parameters which need to be given in argument <code>coefs_given</code>.
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_b_estim">B_estim</code></td>
<td>

<p>positive integer value giving the number of parameters used for resampling to account for estimation uncertainty. Only necessary for <code>estim="bootstrap"</code> and <code>estim="normapprox"</code>. If <code>B_estim</code> is smaller than <code>B</code>, the parameters are resampled with replacement.
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_coefs_given">coefs_given</code></td>
<td>

<p>table with parameters in the rows. Only necessary for <code>estim="given"</code>). If <code>nrow(coefs_given)</code> is smaller than <code>B</code>, the parameters are resampled with replacement.
</p>
</td></tr>
<tr><td><code id="predict.tsglm_+3A_...">...</code></td>
<td>

<p>further arguments are currently ignored. Only for compatibility with generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns predictions for the <code>n.ahead</code> observations following the fitted time series contained in argument <code>object</code>. The 1-step-ahead prediction is the conditional expectation of the observation to be predicted given the past. The true parameters are replaced by their estimations given in argument <code>object</code>. For a 2-step-ahead-prediction the true previous observation is used when given in argument <code>newobs</code>, otherwise it is replaced by the 1-step-ahead prediction computed before. For a 3-step-prediction this holds for the previous two observations, which are replaced by their respective predictions if not available, and so on.
</p>
<p>Unless <code>level=0</code>, the function also returns prediction intervals. Read the description of the arguments <code>type</code> and<code>method</code> for further details on the computation. Note that the prediction intervals do not reflect the additional uncertainty induced by the parameter estimation. However, for sufficiently long time series used for model fitting, it is expected that this uncertainty is negligible compared to the uncertainty of the predictive distribution. The argument <code>estim</code> allows to account fot this additional estimation uncertainty if <code>method="bootstrap"</code>, see the description of this argument.
</p>
<p>If prediction intervals are computed the function additionally returns the median of the predictive distribution. If <code>method="conddistr"</code> this is the analytical median of the conditional distribution, otherwise the empirical median of the simulated distribution.
</p>


<h3>Value</h3>

<p>A list with at least the following element:
</p>
<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>a numeric vector of the predictions. Has class <code>"ts"</code> if the response used for fitting has this class.</p>
</td></tr>
</table>
<p>If prediction intervals are calculated, the list has the additional element:
</p>
<table role = "presentation">
<tr><td><code>interval</code></td>
<td>
<p>a matrix with the columns <code>"lower"</code> and <code>"upper"</code> giving the lower and upper boundaries of prediction intervals for the future time points, each with an intended coverage rate as given in argument <code>level</code>. Has class <code>"ts"</code> if the response used for fitting has this class.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>a numeric value determining the desired coverage rate of prediction intervals.</p>
</td></tr>
<tr><td><code>global</code></td>
<td>
<p>a logical value saying whether the coverage rate <code>level</code> holds globally or for each of the prediction intervals individually.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a character value saying how the prediction intervals were computed. Possible values are <code>"quantiles"</code> and <code>"shortest"</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character value saying which method were used for computation of prediction intervals. Possible values are <code>"conddistr"</code> and <code>"bootstrap"</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>an integer value giving the number of bootstrap samples which were used for computing prediction intervals. Is <code>NULL</code> if computation was done by <code>method="conddistr"</code>.</p>
</td></tr>
<tr><td><code>estim</code></td>
<td>
<p>a character value saying how the prediction intervals account for estimation uncertainty of the model parameters. Possible values are <code>"ignore"</code>, <code>"bootstrap"</code>, <code>"normapprox"</code> and <code>"given"</code>.</p>
</td></tr>
<tr><td><code>B_estim</code></td>
<td>
<p>an integer value giving the number of parameter values used for resampling to account for estimation uncertainty. This value is zero if the estimation uncertainty is ignored.</p>
</td></tr>
<tr><td><code>warning_messages</code></td>
<td>
<p>a character vector containing warning messages. This should be <code>NULL</code> if no warning messages occured.</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>a vector giving the median of the predictive distribution for each of the future time points. Has class <code>"ts"</code> if the response used for fitting has this class.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Liboschik and Philipp Probst
</p>


<h3>References</h3>

<p>Liboschik, T., Fokianos, K. and Fried, R. (2017) tscount: An R package for analysis of count time series following generalized linear models. <em>Journal of Statistical Software</em> <b>82(5)</b>, 1&ndash;51, <a href="http://dx.doi.org/10.18637/jss.v082.i05">http://dx.doi.org/10.18637/jss.v082.i05</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Campylobacter infections in Canada (see help("campy"))
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
predict(campyfit, n.ahead=1) #prediction interval using conditional distribution
predict(campyfit, n.ahead=5, global=TRUE) #prediction intervals using parametric bootstrap
</code></pre>

<hr>
<h2 id='QIC'>
Quasi Information Criterion of a Generalised Linear Model for Time Series of Counts
</h2><span id='topic+QIC'></span><span id='topic+QIC.tsglm'></span>

<h3>Description</h3>

<p>The function computes the Quasi Information Criterion (QIC) of a generalised linear model for time series of counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
QIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QIC_+3A_object">object</code></td>
<td>

<p>an object of class <code>"tsglm"</code>.
</p>
</td></tr>
<tr><td><code id="QIC_+3A_...">...</code></td>
<td>

<p>additional arguments passed to <code>tscount:::tsglm.loglik</code>. These can be the arguments <code>init.method</code> and <code>init.drop</code> which are explained on the help page of the function <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quasi information criterion (QIC) has been proposed by Pan (2001) as alternative to Akaike's information criterion (AIC) which is properly adjusted for regression analysis based on the generalized estimating equations (GEE).
</p>
<p>This function computes the QIC of a generalised linear model for time series of counts. In case of models with the Poisson distribution the QIC has approximately the same value as the AIC. However, in case of models with another distribution it can be a more adequate alternative to the AIC.
</p>


<h3>Author(s)</h3>

<p>Tobias Liboschik
</p>


<h3>References</h3>

<p>Pan, W. (2001) Akaike's Information Criterion in Generalized Estimating Equations. <em>Biometrics</em> <b>57</b>, 120&ndash;125, <a href="http://dx.doi.org/10.1111/j.0006-341X.2001.00120.x">http://dx.doi.org/10.1111/j.0006-341X.2001.00120.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
</p>
<p><code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code> for other information criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Campylobacter infections in Canada (see help("campy"))
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)), distr="nbinom")
QIC(campyfit)
AIC(campyfit)
</code></pre>

<hr>
<h2 id='residuals.tsglm'>
Residuals of a Generalised Linear Model for Time Series of Counts
</h2><span id='topic+residuals.tsglm'></span>

<h3>Description</h3>

<p>Returns the residuals of a fitted GLM-type model for time series of counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
residuals(object, type = c("response", "pearson", "anscombe"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.tsglm_+3A_object">object</code></td>
<td>

<p>an object of class <code>"tsglm"</code>. Usually the result of a call to <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code id="residuals.tsglm_+3A_type">type</code></td>
<td>

<p>character value giving the type of residuals which should be returned. Choose <code>type="response"</code> for raw residuals, <code>type="pearson"</code> for Pearson residuals and <code>type="anscombe"</code> for Anscombe residuals.
</p>
</td></tr>
<tr><td><code id="residuals.tsglm_+3A_...">...</code></td>
<td>

<p>further arguments are currently ignored. Only for compatibility with generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a vector with the respective residuals of the fit given in argument <code>object</code>.
</p>


<h3>Value</h3>

<p>Numerical vector of the residuals.
</p>


<h3>Author(s)</h3>

<p>Tobias Liboschik and Philipp Probst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Campylobacter infections in Canada (see help("campy"))
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
campyfit_resid &lt;- residuals(campyfit, type="pearson")
plot(campyfit_resid)
acf(campyfit_resid)
</code></pre>

<hr>
<h2 id='scoring'>
Predictive Model Assessment with Proper Scoring Rules
</h2><span id='topic+scoring'></span><span id='topic+scoring.default'></span><span id='topic+scoring.tsglm'></span>

<h3>Description</h3>

<p>Computes scores for the assessment of sharpness of a fitted model for time series of counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
scoring(object, individual=FALSE, cutoff=1000, ...)
## Default S3 method:
scoring(response, pred, distr=c("poisson", "nbinom"), distrcoefs,
          individual=FALSE, cutoff=1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoring_+3A_object">object</code></td>
<td>

<p>an object of class <code>"tsglm"</code>.
</p>
</td></tr>
<tr><td><code id="scoring_+3A_individual">individual</code></td>
<td>

<p>logical. If <code>FALSE</code> (the default) the average scores are returned. Otherwise a matrix with the individual scores for each observation is returned.
</p>
</td></tr>
<tr><td><code id="scoring_+3A_cutoff">cutoff</code></td>
<td>

<p>positive integer. Summation over the infinite sample space {0,1,2,...} of a distribution is cut off at this value. This affects the quadratic, spherical and ranked probability score.
</p>
</td></tr>
<tr><td><code id="scoring_+3A_response">response</code></td>
<td>

<p>integer vector. Vector of observed values <code class="reqn">Y_1,...,Y_n</code>.
</p>
</td></tr>
<tr><td><code id="scoring_+3A_pred">pred</code></td>
<td>

<p>numeric vector. Vector of predicted values <code class="reqn">\mu_{P_1},...,\mu_{P_n}</code>.
</p>
</td></tr>
<tr><td><code id="scoring_+3A_distr">distr</code></td>
<td>

<p>character giving the conditional distribution. Currently implemented are the Poisson (<code>"poisson"</code>)and the Negative Binomial (<code>"nbinom"</code>) distribution.
</p>
</td></tr>
<tr><td><code id="scoring_+3A_distrcoefs">distrcoefs</code></td>
<td>

<p>numeric vector of additional coefficients specifying the conditional distribution. For <code>distr="poisson"</code> no additional parameters need to be provided. For <code>distr="nbinom"</code> the additional parameter <code>size</code> needs to be specified (e.g. by <code>distrcoefs=2</code>), see <code><a href="#topic+tsglm">tsglm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="scoring_+3A_...">...</code></td>
<td>

<p>further arguments are currently ignored. Only for compatibility with generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scoring rules are penalties that should be minimised for a better forecast, so a smaller scoring value means better sharpness. 
Different competing forecast models can be ranked via these scoring rules. 
They are computed as follows:
For each score <code class="reqn">s</code> and time <code class="reqn">t</code> the value <code class="reqn">s(P_{t},Y_{t})</code> is computed, where <code class="reqn">P_t</code> is the predictive 
c.d.f. and <code class="reqn">Y_t</code> is the observation at time <code class="reqn">t</code>. To obtain the overall score for one model the average of the score of all observations
<code class="reqn">(1/n) \sum_{t=1}^{n}s(P_{t},Y_{t})</code>
is calculated. 
</p>
<p>For all <code class="reqn">t \geq 1</code>, let <code class="reqn">p_{y} = P(Y_{t}=y | {\cal{F}}_{t-1} )</code> be the density function of the predictive distribution at <code class="reqn">y</code> and 
<code class="reqn">||p||^2=\sum_{y=0}^{\infty} p_y^2</code> be a quadratic sum over the whole sample space <code class="reqn">y=0,1,2,...</code> of the predictive distribution.
<code class="reqn">\mu_{P_t}</code> and <code class="reqn">\sigma_{P_t}</code> are the mean and the standard deviation of the predictive distribution, respectively.
</p>
<p>Then the scores are defined as follows:
</p>
<p>Logarithmic score: <code class="reqn">logs(P_{t},Y_{t})= -log p_{y}</code>
</p>
<p>Quadratic or Brier score: <code class="reqn">qs(P_{t},Y_{t}) = -2p_{y} + ||p||^2 </code>
</p>
<p>Spherical score: <code class="reqn">sphs(P_{t},Y_{t})=\frac{-p_{y}}{||p||}</code>
</p>
<p>Ranked probability score:  <code class="reqn">rps(P_{t},Y_{t})=\sum_{x=0}^{\infty}(P_{t}(x) - 1(Y_t\leq x))^2</code> (sum over the whole sample space <code class="reqn">x=0,1,2,...</code>)
</p>
<p>Dawid-Sebastiani score: <code class="reqn">dss(P_{t},Y_{t})=\left(\frac{Y_t-\mu_{P_t}}{\sigma_{P_t}}\right)^2 + 2log\sigma_{P_t}</code>
</p>
<p>Normalized squared error score: <code class="reqn">nses(P_{t},Y_{t})=\left(\frac{Y_t-\mu_{P_t}}{\sigma_{P_t}}\right)^2</code>
</p>
<p>Squared error score: <code class="reqn">ses(P_{t},Y_{t})=(Y_t-\mu_{P_t})^2</code>
</p>
<p>For more information on scoring rules see the references listed below.
</p>


<h3>Value</h3>

 
<p>Returns a named vector of the mean scores (if argument <code>individual=FALSE</code>, the default) or a data frame of the individual scores for each observation (if argument <code>individual=TRUE</code>). The scoring rules are named as follows:
</p>
<table role = "presentation">
<tr><td><code>logarithmic</code></td>
<td>
<p>Logarithmic score</p>
</td></tr>
<tr><td><code>quadratic</code></td>
<td>
<p>Quadratic or Brier score</p>
</td></tr>
<tr><td><code>spherical</code></td>
<td>
<p>Spherical score</p>
</td></tr>
<tr><td><code>rankprob</code></td>
<td>
<p>Ranked probability score</p>
</td></tr>
<tr><td><code>dawseb</code></td>
<td>
<p>Dawid-Sebastiani score</p>
</td></tr>
<tr><td><code>normsq</code></td>
<td>
<p>Normalized squared error score</p>
</td></tr>
<tr><td><code>sqerror</code></td>
<td>
<p>Squared error score</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Philipp Probst and Tobias Liboschik
</p>


<h3>References</h3>

<p>Christou, V. and Fokianos, K. (2013) On count time series prediction. <em>Journal of Statistical Computation and Simulation</em> (published online), <a href="http://dx.doi.org/10.1080/00949655.2013.823612">http://dx.doi.org/10.1080/00949655.2013.823612</a>.
</p>
<p>Czado, C., Gneiting, T. and Held, L. (2009) Predictive model assessment for count data. <em>Biometrics</em> <b>65</b>, 1254&ndash;1261, <a href="http://dx.doi.org/10.1111/j.1541-0420.2009.01191.x">http://dx.doi.org/10.1111/j.1541-0420.2009.01191.x</a>.
</p>
<p>Gneiting, T., Balabdaoui, F. and Raftery, A.E. (2007) Probabilistic forecasts, calibration and sharpness. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> <b>69</b>, 243&ndash;268, <a href="http://dx.doi.org/10.1111/j.1467-9868.2007.00587.x">http://dx.doi.org/10.1111/j.1467-9868.2007.00587.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
</p>
<p><code><a href="#topic+pit">pit</a></code> and <code><a href="#topic+marcal">marcal</a></code> for other predictive model assessment tools.
</p>
<p><code><a href="surveillance.html#topic+permutationTest">permutationTest</a></code> in package <code>surveillance</code> for the Monte Carlo permutation test for paired individual scores by Paul and Held (2011, <em>Statistics in Medicine</em> <b>30</b>, 1118&ndash;1136, <a href="http://dx.doi.org/10.1002/sim.4177">http://dx.doi.org/10.1002/sim.4177</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Campylobacter infections in Canada (see help("campy"))
campyfit &lt;- tsglm(ts=campy, model=list(past_obs=1, past_mean=c(7,13)))
scoring(campyfit)
</code></pre>

<hr>
<h2 id='se.tsglm'>
Standard Errors of a Fitted Generalised Linear Model for Time Series of Counts
</h2><span id='topic+se.tsglm'></span><span id='topic+se'></span>

<h3>Description</h3>

<p>Computes the standard errors for the parameters of a fitted GLM-type model for time series of counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
se(object, B, parallel, level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="se.tsglm_+3A_object">object</code></td>
<td>

<p>an object of class <code>"tsglm"</code>. Usually the result of a call to <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code id="se.tsglm_+3A_b">B</code></td>
<td>

<p>positive integer value giving the number of bootstrap samples to use for estimation of the standard errors. If missing the standard errors are based on a normal approximation.
</p>
</td></tr>
<tr><td><code id="se.tsglm_+3A_parallel">parallel</code></td>
<td>

<p>logical value. If <code>parallel=TRUE</code>, the bootstrap is distributed to multiple cores parallely. Requires a computing cluster to be initialised and registered as the default cluster by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> and <code><a href="parallel.html#topic+setDefaultCluster">setDefaultCluster</a></code> from package <code>parallel</code>. 
</p>
</td></tr>
<tr><td><code id="se.tsglm_+3A_level">level</code></td>
<td>

<p>numeric value determining the desired coverage rate of confidence intervals.
</p>
</td></tr>
<tr><td><code id="se.tsglm_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to the fitting function <code><a href="#topic+tsglm">tsglm</a></code>. Only made use of if the standard errors are computed by a bootstrap procedure.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the standard errors and confidence intervals are based on a normal approximation of the (quasi) maximum likelihood estimator. The standard errors are the square roots of the diagonal elements of the inverse of the information matrix. Because there is no analytical approximation of the standard error for the overdispersion coefficient <code>sigmasq</code>, its standard error and its confidence interval are set to <code>NA</code>.
</p>
<p>If the number of bootstrap samples <code>B</code> is given, the standard errors and condidence intervals are computed by a parametric bootstrap. The standard errors are the empirical standard deviation of the parameter estimations of <code>B</code> random samples drawn from the fitted model given in argument <code>object</code>. The confidence intervals are the <code>a</code>- and <code>(1-a)</code>-quantile of this bootstrap sample with <code>a=(1-level)/2</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>a vector of the maximum likelihood estimated coefficients.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>a vector of the standard errors of each estimated coefficient.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>a matrix with the columns <code>"lower"</code> and <code>"upper"</code> giving the lower and upper boundaries of confidence intervals for the model parameters.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>numerical value giving the coverage rate of the confidence intervals.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a character value <code>"normapprox"</code> or <code>"bootstrap"</code> giving how the standard errors are computed.</p>
</td></tr>
</table>
<p>If the standard errors are computed by a parametric bootstrap procedure, the following component is additionally returned:
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>positive integer value giving the number of bootstrap samples used for estimation of the standard errors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Liboschik and Philipp Probst
</p>


<h3>References</h3>

<p>Liboschik, T., Fokianos, K. and Fried, R. (2017) tscount: An R package for analysis of count time series following generalized linear models. <em>Journal of Statistical Software</em> <b>82(5)</b>, 1&ndash;51, <a href="http://dx.doi.org/10.18637/jss.v082.i05">http://dx.doi.org/10.18637/jss.v082.i05</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Road casualties in Great Britain (see help("Seatbelts"))
timeseries &lt;- Seatbelts[, "VanKilled"]
regressors &lt;- cbind(PetrolPrice=Seatbelts[, c("PetrolPrice")],
                    linearTrend=seq(along=timeseries)/12)
#Logarithmic link function with Poisson distribution:                    
seatbeltsfit &lt;- tsglm(ts=timeseries, link="log",
  model=list(past_obs=c(1, 12)), xreg=regressors, distr="poisson")
  
se(seatbeltsfit) #by normal approximation

## Not run: 
system.time(stderror &lt;- se(seatbeltsfit, B=100)) #by bootstrap
stderror
#This estimation of bootstrap standard errors takes several minutes on a single
#processing unit, of course depending on its speed.
#Parallel computation for shorter run time on a cluster:
library(parallel)
ntasks &lt;- 3
clust &lt;- makeCluster(ntasks)
setDefaultCluster(cl=clust)
system.time(stderror &lt;- se(seatbeltsfit, B=100, parallel=TRUE))
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.tsglm'>
Summarising Fits of Count Time Series following Generalised Linear Models
</h2><span id='topic+summary.tsglm'></span><span id='topic+print.summary.tsglm'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"tsglm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsglm'
summary(object, B, parallel=FALSE, level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.tsglm_+3A_object">object</code></td>
<td>

<p>an object of class <code>"tsglm"</code>. Usually the result of a call to <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.tsglm_+3A_b">B</code></td>
<td>

<p>controls the computation of standard errors. Is passed to <code><a href="#topic+se.tsglm">se</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.tsglm_+3A_parallel">parallel</code></td>
<td>

<p>controls the computation of standard errors. Is passed to <code><a href="#topic+se.tsglm">se</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.tsglm_+3A_level">level</code></td>
<td>

<p>controls the computation of conficence intervals. Is passed to <code><a href="#topic+se.tsglm">se</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.tsglm_+3A_...">...</code></td>
<td>

<p>further arguments are currently ignored. Only for compatibility with generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes and returns a list of summary statistics of the fitted model given in argument <code>object</code>.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>see <code><a href="#topic+tsglm">tsglm</a></code>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>see <code><a href="#topic+tsglm">tsglm</a></code>.</p>
</td></tr>
<tr><td><code>distr</code></td>
<td>
<p>see <code><a href="#topic+tsglm">tsglm</a></code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>see <code><a href="#topic+tsglm">tsglm</a></code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>data frame with estimated parameters, their standard errors  and confidence intervals (based on a normal approximation or a parametric bootstrap, see <code><a href="#topic+se.tsglm">se.tsglm</a></code>).</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>numerical value giving the coverage rate of the confidence intervals.</p>
</td></tr>
<tr><td><code>number.coef</code></td>
<td>
<p>number of coefficients.</p>
</td></tr>
<tr><td><code>se.type</code></td>
<td>
<p>type of standard errors, see <code><a href="#topic+se.tsglm">se.tsglm</a></code>.</p>
</td></tr>
<tr><td><code>se.bootstrapsamples</code></td>
<td>
<p>number of bootstrap samples used for estimation of the standard errors, see <code><a href="#topic+se.tsglm">se.tsglm</a></code>. Is omitted if the standard errors are not obtained by a bootstrap procedure.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>value of the log-likelihood function evaluated at the (quasi) maximum likelihood estimate.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's information criterion (AIC), see <code><a href="stats.html#topic+AIC">AIC</a></code>.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion (BIC), see <code><a href="stats.html#topic+BIC">BIC</a></code>.</p>
</td></tr> 
<tr><td><code>QIC</code></td>
<td>
<p>Quasi information criterion (QIC), see <code><a href="#topic+QIC.tsglm">QIC.tsglm</a></code>.</p>
</td></tr>   
<tr><td><code>pearson.resid</code></td>
<td>
<p>Pearson residuals, see <code><a href="#topic+residuals.tsglm">residuals.tsglm</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Liboschik and Philipp Probst
</p>


<h3>See Also</h3>

<p>S3 method <code><a href="base.html#topic+print">print</a></code>.
</p>
<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Road casualties in Great Britain (see help("Seatbelts"))
timeseries &lt;- Seatbelts[, "VanKilled"]
regressors &lt;- cbind(PetrolPrice=Seatbelts[, c("PetrolPrice")],
                    linearTrend=seq(along=timeseries)/12)
#Logarithmic link function with Poisson distribution:                    
seatbeltsfit &lt;- tsglm(ts=timeseries, link="log",
  model=list(past_obs=c(1, 12)), xreg=regressors, distr="poisson")
summary(seatbeltsfit)
</code></pre>

<hr>
<h2 id='tsglm'>
Count Time Series Following Generalised Linear Models
</h2><span id='topic+tsglm'></span><span id='topic+print.tsglm'></span><span id='topic+logLik.tsglm'></span><span id='topic+tsglm.meanfit'></span><span id='topic+vcov.tsglm'></span>

<h3>Description</h3>

<p>The function <code>tsglm</code> fits a generalised linear model (GLM) for time series of counts.
The specification of the linear predictor allows for regressing on past observations, past values of the linear predictor and covariates as defined in the Details section.
There is the so-called INGARCH model with the identity link (see for example Ferland et al., 2006, Fokianos et al., 2009) and another model with the logarithmic link (see for example Fokianos and Tjostheim, 2011), which also differ in the specification of the linear predictor.
The conditional distribution can be chosen to be either Poisson or negative binomial.
</p>
<p>Estimation is done by conditional maximum likelihood for the Poisson distribution or by a conditional quasi-likelihood approach based on the Poisson likelihood function for the negative binomial distribution.
</p>
<p>There is a vignette available which introduces the functionality of <code>tsglm</code> and related functions of this package and its underlying statistical methods (<code>vignette("tsglm", package="tscount")</code>).
</p>
<p>The function <code>tsglm.meanfit</code> is a lower level function to fit the mean specification of such a model assuming a Poisson distribution. It is called by <code>tsglm</code>. It has additional arguments allowing for a finer control of the fitting procedure, which can be handed over from the function <code>tsglm</code> by its <code>...</code> argument. Note that it is usually not necessary for a user to call this lower level functions nor to worry about the additional arguments provided by this function. The defaults of these arguments have been chosen wisely by the authors of this package and should perform well in most applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsglm(ts, model = list(past_obs = NULL, past_mean = NULL,
            external = NULL), xreg = NULL, link = c("identity", "log"),
            distr = c("poisson", "nbinom"), ...)

tsglm.meanfit(ts, model, xreg, link, score = TRUE,
            info = c("score", "none", "hessian", "sandwich"),
            init.method=c("marginal", "iid", "firstobs", "zero"),
            init.drop = FALSE, epsilon = 1e-06, slackvar = 1e-06,
            start.control = list(), final.control = list(),
            inter.control = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsglm_+3A_ts">ts</code></td>
<td>

<p>a univariate time series.
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_model">model</code></td>
<td>

<p>a named list specifying the model for the linear predictor, which can be of the following elements:
</p>
  
<dl>
<dt><code>past_obs</code></dt><dd><p>integer vector giving the previous observations to be regressed on (autoregression). This is a vector with the elements <code class="reqn">i_1,\ldots,i_p</code> (see Details). If omitted, or of length zero, there will be no regression on previous observations.</p>
</dd>    
<dt><code>past_mean</code></dt><dd><p>integer vector giving the previous conditional means to be regressed on. This is a vector with the elements <code class="reqn">j_1,\ldots,j_q</code> (see Details). If omitted, or of length zero, there will be no regression on previous conditional means.</p>
</dd> 
<dt><code>external</code></dt><dd><p>logical vector of length <code>ncol(xreg)</code> specifying for each covariate wether its effect should be external or not (see Details). If this is a scalar this choice will be used for all covariates. If omitted, all covariates will have an internal effect (i.e. <code>external=FALSE</code>).</p>
</dd>
</dl>
 
</td></tr>
<tr><td><code id="tsglm_+3A_xreg">xreg</code></td>
<td>

<p>matrix with covariates in the columns, i.e. its number of rows must be <code>length(ts)</code>. This is the matrix <code class="reqn">X</code> (see Details). If omitted no covariates will be included. For the identity link the covariates have to be non-negative.
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_link">link</code></td>
<td>

<p>character giving the link function. Default is <code>"identity"</code>, fitting an INGARCH model. Another possible choice is <code>"log"</code>, fitting a log-linear model.
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_distr">distr</code></td>
<td>

<p>character giving the conditional distribution. Default is <code>"poisson"</code>, i.e. a Poisson distribution.
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to the lower level fitting function <code>tsglm.meanfit</code>. See below.  
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_score">score</code></td>
<td>

<p>logical value indicating whether the score vector should be computed.
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_info">info</code></td>
<td>

<p>character that determines if and how to compute the information matrix. Can be set to <code>"score"</code> (the default) for calculation via the outer product of the score vector, or to <code>"hessian"</code> for calculation via the Hessian matrix of second derivatives. For <code>info="sandwich"</code> the information matrix is estimated by a sandwich formula using both the outer score product and the Hessian matrix. If set to <code>"none"</code>, no information matrix is computed. For <code>distr="nbinom"</code> one can only use <code>info="score"</code>.
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_init.method">init.method</code></td>
<td>

<p>character that determines how the recursion of the conditional mean (and possibly of its derivatives) is initialised. If set to <code>"marginal"</code> (the default), the marginal mean of a model without covariates and its derivatives are used. If set to <code>"iid"</code>, all values are initialised by the marginal mean under the assumption of i.i.d. data, which depends on the intercept only. If set to <code>"firstobs"</code> the first obersvation is used. If set to <code>"zero"</code>, the recursions are initialised by the value zero.
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_init.drop">init.drop</code></td>
<td>

<p>logical value that determines which observations are considered for computation of the log-likelihood, the score vector and, if applicable, the information matrix. If <code>TRUE</code>, the first <code>max(model$past_obs)</code> observations, which are needed for the autoregression, are not considered. If <code>FALSE</code> (the default), all observations are considered and pre-sample values determined by the method specified by the argument <code>itit.method</code> are used for the autoregression. Note that in the first case the effective number of observations used for maximum likelihood estimation is lower than the total number of observations of the original time series. Consequently only this lower number of observations is considered in the output. Note that for <code>init.drop=TRUE</code> the log-likelihood function for models of different orders might not be comparable if the effective number of observations is different.
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_epsilon">epsilon</code></td>
<td>

<p>numeric positive but small value determining how close the parameters may come to the limits of the parameter space.
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_slackvar">slackvar</code></td>
<td>

<p>numeric positive but small value determining how true inequalities among the parameter restrictions are treated; a true inequality <code>x &lt; y</code> will be transformed to <code>x + slackvar &lt;= y</code>.
</p>
</td></tr>
<tr><td><code id="tsglm_+3A_start.control">start.control</code></td>
<td>

<p>named list with optional elements that determine how to make the start estimation. Possible list elements are:
</p>
  
<dl>
<dt><code>use</code></dt><dd><p>integer vector of length one or two giving the number of observations from the beginning (if of length one) or the range of observations (if of length two) used for start estimation. For <code>use = Inf</code> all observations are used, which is the default.</p>
</dd>
<dt><code>method</code></dt><dd><p>character specifying how start estimators should be estimated. Possible values are <code>"iid"</code>, <code>"CSS"</code>, <code>"CSS-ML"</code>, <code>"ML"</code>, <code>"MM"</code>, <code>"GLM"</code> and <code>"fixed"</code>. 
If <code>method</code> is <code>"iid"</code> (the default), a moment estimator assuming an iid model without covariates is used.
If <code>method="MM"</code>, the start estimate is an ARMA(1,1) fit by moment estimators and parameters of higher order than one are set to zero. For this method the starting parameter values for the covariates are zero by default and can be set by the list element <code>xreg</code>.
If <code>method</code> is <code>"CSS"</code>, <code>"CSS-ML"</code> or <code>"ML"</code>, the start estimate is based on an ARMA fit using the function <code><a href="stats.html#topic+arima">arima</a></code>, and list element <code>method</code> is passed to its argument of the same name.  
If <code>method="GLM"</code>, the estimated parameters of a generalised linear model with regression on the specified past observations and covariates, but not on past conditional means, are used as start estimates. Initial estimates for the coefficients of past conditional means are set to zero.
If <code>method="fixed"</code>, parameters given in further named list elements of <code>start.control</code> are used when available, else the predefined values given in the following are used.</p>
</dd>
<dt><code>intercept</code></dt><dd><p>numeric value with the start value for the intercept parameter. Default value is 1.</p>
</dd>
<dt><code>past_obs</code></dt><dd><p>numeric vector with the start values for parameters for regression on previous observations. Default values are zero.</p>
</dd>
<dt><code>past_mean</code></dt><dd><p>numeric vector with the start values for parameters for regression on previous conditional means. Default values are zero.</p>
</dd>
<dt><code>xreg</code></dt><dd><p>numeric vector with the start values for the regression parameters. These values will also be used if <code>method="MM"</code>. Default values are zero.</p>
</dd>
</dl>
  
</td></tr>
<tr><td><code id="tsglm_+3A_final.control">final.control</code></td>
<td>

<p>named list with optional elements that determine how to make the final maximum likelihood estimation. If <code>final.control=NULL</code>, only start estimates are computed and a list with fewer elements which has not the class <code>"tsglm"</code> is returned. Possible list elements of this argument are:
</p>
  
<dl>
<dt><code>constrained</code></dt><dd><p>named list whose elements are passed to function <code><a href="stats.html#topic+constrOptim">constrOptim</a></code> with possible elements <code>mu</code>, <code>outer.iterations</code> and <code>outer.eps</code> (see <code><a href="stats.html#topic+constrOptim">constrOptim</a></code> for details). If <code>constrained=NULL</code>, an unconstrained optimisation is made with function <code><a href="stats.html#topic+optim">optim</a></code>. Note that this is likely to result in a fitted model which is non-stationary, which might cause further problems.</p>
</dd>
<dt><code>optim.method</code></dt><dd><p>character which is passed to functions <code><a href="stats.html#topic+constrOptim">constrOptim</a></code> or <code><a href="stats.html#topic+optim">optim</a></code> as argument <code>method</code>. The default is <code>"BFGS"</code>.</p>
</dd>
<dt><code>optim.control</code></dt><dd><p>named list which is passed to function <code><a href="stats.html#topic+constrOptim">constrOptim</a></code> or <code><a href="stats.html#topic+optim">optim</a></code> as the argument <code>control</code>. Must not contain the list element <code>fnscale</code>. The default is <code>list(maxit=20, reltol=1e-8)</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="tsglm_+3A_inter.control">inter.control</code></td>
<td>

<p>named list determining how to maximise the log-likelihood function in a first step. This intermediate optimisation will start from the start estimation and be followed by the final optimisation, which will in turn start from the intermediate optimisation result. This intermediate optimisation is intended to use a very quick but imprecise optimisation algorithm. Possible elements are the same as for <code>final.control</code>. The default is <code>inter.control=NULL</code>, which skips this intermediate optimisation step. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The INGARCH model (argument <code>link="identity"</code>) used here follows the definition
</p>
<p style="text-align: center;"><code class="reqn">Z_{t}|{\cal{F}}_{t-1} \sim \mathrm{Poi}(\nu_{t}) \quad \mathrm{or} \quad Z_{t}|{\cal{F}}_{t-1} \sim \mathrm{NegBin}(\nu_{t}, \phi),</code>
</p>

<p>where <code class="reqn">{\cal{F}}_{t-1}</code> denotes the history of the process up to time <code class="reqn">t-1</code>, <code class="reqn">\mathrm{Poi}</code> and <code class="reqn">\mathrm{NegBin}</code> is the Poisson respectively the negative binomial distribution with the parametrisation as specified below.
For the model with covariates having an internal effect (the default) the linear predictor of the INGARCH model (which is in that case identical to the conditional mean) is given by
</p>
<p style="text-align: center;"><code class="reqn">\nu_t = \beta_0 + \beta_1 Z_{t-i_1} + \ldots + \beta_p Z_{t-i_p}
    + \alpha_1 \nu_{t-j_1} + \ldots  + \alpha_q \nu_{t-j_q}
    + \eta_1 X_{t,1} + \ldots + \eta_r X_{t,r}.</code>
</p>

<p>The log-linear model (argument <code>link="log"</code>) used here follows the definition
</p>
<p style="text-align: center;"><code class="reqn">Z_{t}|{\cal{F}}_{t-1} \sim \mathrm{Poi}(\lambda_{t}) \quad \mathrm{or} \quad Z_{t}|{\cal{F}}_{t-1} \sim \mathrm{NegBin}(\lambda_{t}, \phi),</code>
</p>

<p>with <code class="reqn">\lambda_t = \exp(\nu_t)</code> and <code class="reqn">{\cal{F}}_{t-1}</code> as above.
For the model with covariates having an internal effect (the default) the linear predictor <code class="reqn">\nu_t = \log(\lambda_t)</code> of the log-linear model is given by
</p>
<p style="text-align: center;"><code class="reqn">\nu_t = \beta_0 + \beta_1 \log(Z_{t-i_1}+1) + \ldots + \beta_p \log(Z_{t-i_p}+1)
    + \alpha_1 \nu_{t-j_1} + \ldots  + \alpha_q \nu_{t-j_q}
    + \eta_1 X_{t,1} + \ldots + \eta_r X_{t,r}.</code>
</p>

<p>Note that because of the logarithmic link function the effect of single summands in the linear predictor on the conditional mean is multiplicative and hence the parameters play a different role than in the INGARCH model, although they are denoted by the same letters.
</p>
<p>The Poisson distribution is parametrised by the mean <code>lambda</code> according to the definition in <code><a href="stats.html#topic+Poisson">Poisson</a></code>.
The negative binomial distribution is parametrised by the mean <code>mu</code> with an additional dispersion parameter <code>size</code> according to the definition in <code><a href="stats.html#topic+NegBinomial">NegBinomial</a></code>. In the notation above its mean parameter <code>mu</code> is <code class="reqn">\nu_{t}</code> and its dispersion parameter <code>size</code> is <code class="reqn">\phi</code>.
</p>
<p>This function allows to include covariates in two different ways. A covariate can have a so-called internal effect as defined above, where its effect propagates via the regression on past values of the linear predictor and on past observations. Alternatively, it can have a so-called external effect, where its effect does not directly propagates via the feedback on past values of the linear predictor, but only via past observations.
For external effects of the covariates, the linear predictor for the model with identity link is given by
</p>
<p style="text-align: center;"><code class="reqn">\nu_t = \mu_t + \eta_1 X_{t,1} + \ldots + \eta_r X_{t,r},</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_t = \beta_0 + \beta_1 Z_{t-i_1} + \ldots + \beta_p Z_{t-i_p}
    + \alpha_1 \mu{t-j_1} + \ldots  + \alpha_q \mu{t-j_q},</code>
</p>
 
<p>and analoguesly for the model with logarithmic link by
</p>
<p style="text-align: center;"><code class="reqn">\nu_t = \mu_t + \eta_1 X_{t,1} + \ldots + \eta_r X_{t,r},</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_t = \beta_0 + \beta_1 \log(Z_{t-i_1}+1) + \ldots + \beta_p \log(Z_{t-i_p}+1)
    + \alpha_1 \mu{t-j_1} + \ldots  + \alpha_q \mu{t-j_q}.</code>
</p>
 
<p>This is described in more detail by Liboschik et al. (2014) for the case of deterministic covariates for modelling interventions.
It is also possible to model a combination of external and internal covariates, which can be defined straightforwardly by adding each covariate either to the linear predictor <code class="reqn">\nu_t</code> itself (for an internal effect) or to <code class="reqn">\mu_t</code> defined above (for an external effect).
</p>


<h3>Value</h3>

<p>An object of class <code>"tsglm"</code>, which is a list with at least the following elements:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of the maximum likelihood estimated coefficients, which can be extracted by the <code><a href="stats.html#topic+coef">coef</a></code> method.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>a named vector of the start estimation for the coefficients.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of residuals, which can be extracted by the <code><a href="#topic+residuals.tsglm">residuals</a></code> method.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values, which can be extracted by the <code><a href="stats.html#topic+fitted">fitted</a></code> method.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>the linear fit on link scale.</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>a vector of the response values (this is usually the original time series but  possibly without the first few observations used for initialization if argument <code>init.drop=TRUE</code>).</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log-likelihood of the fitted model, which can be extracted by the <code><a href="stats.html#topic+logLik">logLik</a></code> method. This is the complete log-likelihood including all constant terms. It is based on <code>n_eff</code> observations (see below).</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>the score vector at the maximum likelihood estimation.</p>
</td></tr>
<tr><td><code>info.matrix</code></td>
<td>
<p>the information matrix at the maximum likelihood estimation assuming a Poisson distribution.</p>
</td></tr>
<tr><td><code>info.matrix_corrected</code></td>
<td>
<p>the information matrix at the maximum likelihood estimation assuming the distribution specified in <code>distr</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>n_obs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>n_eff</code></td>
<td>
<p>the effective number of observations used for maximum likelihood estimation (might be lower than <code>n_obs</code> if argument <code>init.drop=TRUE</code>).</p>
</td></tr>
<tr><td><code>ts</code></td>
<td>
<p>the original time series.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the model specification.</p>
</td></tr>
<tr><td><code>xreg</code></td>
<td>
<p>the given covariates.</p>
</td></tr>
<tr><td><code>distr</code></td>
<td>
<p>a character giving the fitted conditional distribution.</p>
</td></tr>
<tr><td><code>distrcoefs</code></td>
<td>
<p>a named vector of the estimated additional coefficients specifying the conditional distribution. Is <code>NULL</code> in case of a Poisson distribution.</p>
</td></tr>
<tr><td><code>sigmasq</code></td>
<td>
<p>the estimated overdispersion coefficient. Is zero in case of a Poisson distribution.</p>
</td></tr>
</table>
<p>The function <code>tsglm.meanfit</code> has the same output except the elements <code>distr</code>, <code>distrcoefs</code> and <code>sigmasq</code>. In addition, they return the following list elements:
</p>
<table role = "presentation">
<tr><td><code>inter</code></td>
<td>
<p>some details on the intermediate estimation of the coefficients as returned by <code><a href="stats.html#topic+constrOptim">constrOptim</a></code> or <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr> 
<tr><td><code>final</code></td>
<td>
<p>some details on the final estimation of the coefficients as returned by <code><a href="stats.html#topic+constrOptim">constrOptim</a></code> or <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>durations</code></td>
<td>
<p>named vector of the durations of the model fit (in seconds).</p>
</td></tr>
<tr><td><code>outerscoreprod</code></td>
<td>
<p>array of outer products of score vectors at each time point.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Tobias Liboschik, Philipp Probst, Konstantinos Fokianos and Roland Fried
</p>


<h3>References</h3>

<p>Christou, V. and Fokianos, K. (2014) Quasi-likelihood inference for negative binomial time series models. <em>Journal of Time Series Analysis</em> <b>35(1)</b>, 55&ndash;78, <a href="http://dx.doi.org/10.1002/jtsa.12050">http://dx.doi.org/10.1002/jtsa.12050</a>.
</p>
<p>Christou, V. and Fokianos, K. (2015) Estimation and testing linearity for non-linear mixed poisson autoregressions. <em>Electronic Journal of Statistics</em> <b>9</b>, 1357&ndash;1377, <a href="http://dx.doi.org/10.1214/15-EJS1044">http://dx.doi.org/10.1214/15-EJS1044</a>.
</p>
<p>Ferland, R., Latour, A. and Oraichi, D. (2006) Integer-valued GARCH process. <em>Journal of Time Series Analysis</em> <b>27(6)</b>, 923&ndash;942, <a href="http://dx.doi.org/10.1111/j.1467-9892.2006.00496.x">http://dx.doi.org/10.1111/j.1467-9892.2006.00496.x</a>.
</p>
<p>Fokianos, K. and Fried, R. (2010) Interventions in INGARCH processes. <em>Journal of Time Series Analysis</em> <b>31(3)</b>, 210&ndash;225, <a href="http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x">http://dx.doi.org/10.1111/j.1467-9892.2010.00657.x</a>.
</p>
<p>Fokianos, K., and Fried, R. (2012) Interventions in log-linear Poisson autoregression. <em>Statistical Modelling</em> <b>12(4)</b>, 299&ndash;322. <a href="http://dx.doi.org/10.1177/1471082X1201200401">http://dx.doi.org/10.1177/1471082X1201200401</a>.
</p>
<p>Fokianos, K., Rahbek, A. and Tjostheim, D. (2009) Poisson autoregression. <em>Journal of the American Statistical Association</em> <b>104(488)</b>, 1430&ndash;1439, <a href="http://dx.doi.org/10.1198/jasa.2009.tm08270">http://dx.doi.org/10.1198/jasa.2009.tm08270</a>.
</p>
<p>Fokianos, K. and Tjostheim, D. (2011) Log-linear Poisson autoregression. <em>Journal of Multivariate Analysis</em> <b>102(3)</b>, 563&ndash;578, <a href="http://dx.doi.org/10.1016/j.jmva.2010.11.002">http://dx.doi.org/10.1016/j.jmva.2010.11.002</a>.
</p>
<p>Liboschik, T., Fokianos, K. and Fried, R. (2017) tscount: An R package for analysis of count time series following generalized linear models. <em>Journal of Statistical Software</em> <b>82(5)</b>, 1&ndash;51, <a href="http://dx.doi.org/10.18637/jss.v082.i05">http://dx.doi.org/10.18637/jss.v082.i05</a>.
</p>


<h3>See Also</h3>

<p>S3 methods <code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+summary.tsglm">summary</a></code>, <code><a href="#topic+residuals.tsglm">residuals</a></code>, <code><a href="#topic+plot.tsglm">plot</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="#topic+predict.tsglm">predict</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+BIC">BIC</a></code> and <code><a href="#topic+QIC.tsglm">QIC</a></code> for the class <code>"tsglm"</code>.
The S3 method <code><a href="#topic+se.tsglm">se</a></code> computes the standard errors of the parameter estimates.
Additionally, there are the S3 methods <code><a href="#topic+pit.tsglm">pit</a></code>, <code><a href="#topic+marcal.tsglm">marcal</a></code> and <code><a href="#topic+scoring.tsglm">scoring</a></code> for predictive model assessment.
</p>
<p>S3 methods <code><a href="#topic+interv_test.tsglm">interv_test</a></code>, <code><a href="#topic+interv_detect.tsglm">interv_detect</a></code> and <code><a href="#topic+interv_multiple.tsglm">interv_multiple</a></code> for tests and detection procedures for intervention effects.
<code><a href="#topic+tsglm.sim">tsglm.sim</a></code> for simulation from GLM-type model for time series of counts. <code><a href="#topic+ingarch.mean">ingarch.mean</a></code>, <code><a href="#topic+ingarch.var">ingarch.var</a></code> and <code><a href="#topic+ingarch.acf">ingarch.acf</a></code> for calculation of analytical mean, variance and autocorrelation function of an INGARCH model (i.e. with identity link) without covariates.
</p>
<p>Example time series of counts are <code><a href="#topic+campy">campy</a></code>, <code><a href="#topic+ecoli">ecoli</a></code>, <code><a href="#topic+ehec">ehec</a></code>, <code><a href="#topic+influenza">influenza</a></code>, <code><a href="#topic+measles">measles</a></code> in this package, <code><a href="gamlss.data.html#topic+polio">polio</a></code> in package <code>gamlss.data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Campylobacter infections in Canada (see help("campy"))
interventions &lt;- interv_covariate(n=length(campy), tau=c(84, 100),
  delta=c(1, 0)) #detected by Fokianos and Fried (2010, 2012)
#Linear link function with Negative Binomial distribution:
campyfit &lt;- tsglm(campy, model=list(past_obs=1, past_mean=13),
  xreg=interventions, distr="nbinom")
campyfit
plot(campyfit)

###Road casualties in Great Britain (see help("Seatbelts"))
timeseries &lt;- Seatbelts[, "VanKilled"]
regressors &lt;- cbind(PetrolPrice=Seatbelts[, c("PetrolPrice")],
                    linearTrend=seq(along=timeseries)/12)
#Logarithmic link function with Poisson distribution:                    
seatbeltsfit &lt;- tsglm(ts=timeseries, link="log",
  model=list(past_obs=c(1, 12)), xreg=regressors, distr="poisson")
summary(seatbeltsfit)
</code></pre>

<hr>
<h2 id='tsglm.sim'>
Simulate a Time Series Following a Generalised Linear Model
</h2><span id='topic+tsglm.sim'></span>

<h3>Description</h3>

<p>Generates a simulated time series from a GLM-type model for time series of counts (see <code><a href="#topic+tsglm">tsglm</a></code> for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsglm.sim(n, param = list(intercept = 1, past_obs = NULL, past_mean = NULL,
            xreg = NULL), model = list(past_obs = NULL, past_mean = NULL,
            external = FALSE), xreg = NULL, link = c("identity", "log"),
            distr = c("poisson", "nbinom"), distrcoefs, fit, n_start = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsglm.sim_+3A_n">n</code></td>
<td>

<p>integer value giving the number of observations to be simulated.
</p>
</td></tr>
<tr><td><code id="tsglm.sim_+3A_param">param</code></td>
<td>

<p>a named list giving the parameters for the linear predictor of the model, which has the following elements: 
</p>

<dl>
<dt><code>intercept</code></dt><dd><p>numeric positive value for the intercept <code class="reqn">\beta_0</code>.</p>
</dd>
<dt><code>past_obs</code></dt><dd><p>numeric non-negative vector containing the coefficients <code class="reqn">\beta_1,\ldots, \beta_p</code> for regression on previous observations (see Details).</p>
</dd>
<dt><code>past_mean</code></dt><dd><p>numeric non-negative vector containing the coefficients <code class="reqn">\alpha_1,\ldots, \alpha_q</code> for regression on previous conditional means (see Details).</p>
</dd>
<dt><code>xreg</code></dt><dd><p>numeric non-negative vector specifying the size <code class="reqn">\nu_1,\ldots, \nu_r</code> of each intervention</p>
</dd>   
</dl>

</td></tr>
<tr><td><code id="tsglm.sim_+3A_model">model</code></td>
<td>

<p>a named list specifying the model for the linear predictor, which has the elements <code>past_obs</code>, <code>past_mean</code> and <code>external</code> (see function <code><a href="#topic+tsglm">tsglm</a></code> for details). This model specification must be in accordance to the parameters given in argument <code>param</code>.
</p>
</td></tr>
<tr><td><code id="tsglm.sim_+3A_xreg">xreg</code></td>
<td>

<p>matrix with covariates in the columns (see <code><a href="#topic+tsglm">tsglm</a></code> for details). Its number of rows must be equal to the number of observations which should be simulated.
</p>
</td></tr>
<tr><td><code id="tsglm.sim_+3A_link">link</code></td>
<td>

<p>character giving the link function. Default is <code>"identity"</code>, simulating from a so-called INGARCH model. Another possible choice is <code>"log"</code>, simulating from a log-linear model.
</p>
</td></tr>
<tr><td><code id="tsglm.sim_+3A_distr">distr</code></td>
<td>

<p>character giving the conditional distribution. Default is <code>"poisson"</code>, i.e. a Poisson distribution.
</p>
</td></tr>
<tr><td><code id="tsglm.sim_+3A_distrcoefs">distrcoefs</code></td>
<td>

<p>numeric vector of additional coefficients specifying the conditional distribution. For <code>distr="poisson"</code> no additional parameters need to be provided. For <code>distr="nbinom"</code> the additional parameter <code>size</code> needs to be specified (e.g. by <code>distrcoefs=2</code>), see <code><a href="#topic+tsglm">tsglm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="tsglm.sim_+3A_fit">fit</code></td>
<td>

<p>an object of class <code>"tsglm"</code>. Usually the result of a call to <code><a href="#topic+tsglm">tsglm</a></code>. If argument <code>fit</code> is not missing, the specification of the linear predictor, the link function and the estimated parameters from this argument are used instead of those in arguments <code>model</code>, <code>link</code> and <code>param</code>. The length of the simulated time series is only taken from argument <code>fit</code>, if no argument <code>n</code> is provided. The same holds for arguments <code>xreg</code>, <code>distr</code> and <code>distrcoefs</code>, which are also prefered over the respective information provided in argument <code>fit</code> if both are provided.
</p>
</td></tr>
<tr><td><code id="tsglm.sim_+3A_n_start">n_start</code></td>
<td>

<p>number of observations used as a burn-in.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of the model used here is like in function <code><a href="#topic+tsglm">tsglm</a></code>.
</p>
<p>Note that during the burn-in period covariates are set to zero.
</p>
<p>If a previous model fit is given in argument <code>fit</code> and the length of the burn-in period <code>n_start</code> is set to zero, then the a continuation of the original time series is simulated.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>ts</code></td>
<td>

<p>an object of class <code>"ts"</code> with the simulated time series.
</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>

<p>an object of class <code>"ts"</code> with the simulated linear predictors <code class="reqn">\kappa_t</code> for all <code class="reqn">t=1, \ldots, n</code>.
</p>
</td></tr>
<tr><td><code>xreg.effects</code></td>
<td>

<p>an object of class <code>"ts"</code> with the cumulated effect of the covariates <code class="reqn">\eta_1 X_{t,1} + \ldots + \eta_r X_{t,r}</code> for all <code class="reqn">t=1, \ldots, n</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Liboschik and Philipp Probst
</p>


<h3>References</h3>

<p>Liboschik, T., Fokianos, K. and Fried, R. (2017) tscount: An R package for analysis of count time series following generalized linear models. <em>Journal of Statistical Software</em> <b>82(5)</b>, 1&ndash;51, <a href="http://dx.doi.org/10.18637/jss.v082.i05">http://dx.doi.org/10.18637/jss.v082.i05</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsglm">tsglm</a></code> for fitting a GLM for time series of counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate from an INGARCH model with two interventions:
interventions &lt;- interv_covariate(n=200, tau=c(50, 150), delta=c(1, 0.8))
model &lt;- list(past_obs=1, past_mean=c(1, 7), external=FALSE)
param &lt;- list(intercept=2, past_obs=0.3, past_mean=c(0.2, 0.1), xreg=c(3, 10))
tsglm.sim(n=200, param=param, model=model, xreg=interventions, link="identity",
          distr="nbinom", distrcoefs=c(size=1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
