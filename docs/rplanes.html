<!DOCTYPE html><html lang="en"><head><title>Help for package rplanes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rplanes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rplanes-package'><p>rplanes: Plausibility Analysis of Epidemiological Signals</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#+25m-+25'><p>Month subtraction</p></a></li>
<li><a href='#check_incomplete'><p>Check completeness of seed and signal data</p></a></li>
<li><a href='#create_sliding_windows_df'><p>Sliding windows</p></a></li>
<li><a href='#cutter'><p>Cut into categorical differences</p></a></li>
<li><a href='#epiweek_start'><p>Epiweek start</p></a></li>
<li><a href='#get_shapes'><p>Determine shapes</p></a></li>
<li><a href='#is_forecast'><p>Check forecast</p></a></li>
<li><a href='#is_observed'><p>Check observed</p></a></li>
<li><a href='#month_start'><p>Month start</p></a></li>
<li><a href='#plane_cover'><p>Coverage component</p></a></li>
<li><a href='#plane_diff'><p>Difference component</p></a></li>
<li><a href='#plane_repeat'><p>Repeat component</p></a></li>
<li><a href='#plane_score'><p>Score PLANES components</p></a></li>
<li><a href='#plane_seed'><p>Create seed</p></a></li>
<li><a href='#plane_shape'><p>Shape component</p></a></li>
<li><a href='#plane_taper'><p>Taper component</p></a></li>
<li><a href='#plane_trend'><p>Trend component</p></a></li>
<li><a href='#plane_zero'><p>Zero component</p></a></li>
<li><a href='#q_boundary'><p>Quantile boundary</p></a></li>
<li><a href='#read_forecast'><p>Read in forecast file</p></a></li>
<li><a href='#resolve_resolution'><p>Resolve resolution</p></a></li>
<li><a href='#rplanes_explorer'><p><code>rplanes</code> explorer app launcher</p></a></li>
<li><a href='#seed_engine'><p>Seed engine</p></a></li>
<li><a href='#to_chunk'><p>Chunk a vector</p></a></li>
<li><a href='#to_signal'><p>Create signal object</p></a></li>
<li><a href='#valid_dates'><p>Validate dates</p></a></li>
<li><a href='#valid_location'><p>Validate location</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Plausibility Analysis of Epidemiological Signals</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality to prepare data and analyze plausibility of both forecasted and reported epidemiological signals. The functions implement a set of plausibility algorithms that are agnostic to geographic and time resolutions and are calculated independently then presented as a combined score.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://signaturescience.github.io/rplanes/">https://signaturescience.github.io/rplanes/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, dtw, ecp, lubridate, magrittr, purrr, readr, rlang,
stringr, tibble, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DT, ggplot2, markdown, knitr, MMWRweek, rmarkdown, shiny,
shinyjs, shinyWidgets, shinycssloaders, testthat (&ge; 3.0.0),
tools</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-15 16:28:47 UTC; vpnagraj</td>
</tr>
<tr>
<td>Author:</td>
<td>VP Nagraj <a href="https://orcid.org/0000-0003-0060-566X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Desiree Williams [aut],
  Amy Benefield [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>VP Nagraj &lt;nagraj@nagraj.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-17 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rplanes-package'>rplanes: Plausibility Analysis of Epidemiological Signals</h2><span id='topic+rplanes'></span><span id='topic+rplanes-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides functionality to prepare data and analyze plausibility of both forecasted and reported epidemiological signals. The functions implement a set of plausibility algorithms that are agnostic to geographic and time resolutions and are calculated independently then presented as a combined score.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: VP Nagraj <a href="mailto:nagraj@nagraj.net">nagraj@nagraj.net</a> (<a href="https://orcid.org/0000-0003-0060-566X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Desiree Williams
</p>
</li>
<li><p> Amy Benefield
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://signaturescience.github.io/rplanes/">https://signaturescience.github.io/rplanes/</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='+25m-+25'>Month subtraction</h2><span id='topic++25m-+25'></span>

<h3>Description</h3>

<p>See <code>lubridate::<a href="lubridate.html#topic+add_with_rollback">%m-%</a></code> for details.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25m-+2B25_+3A_e1">e1</code></td>
<td>
<p>A period or a date-time object of class <a href="base.html#topic+POSIXlt">POSIXlt</a>, <a href="base.html#topic+POSIXct">POSIXct</a>
or <a href="base.html#topic+Date">Date</a>.</p>
</td></tr>
<tr><td><code id="+2B25m-+2B25_+3A_e2">e2</code></td>
<td>
<p>A period or a date-time object of class <a href="base.html#topic+POSIXlt">POSIXlt</a>, <a href="base.html#topic+POSIXct">POSIXct</a>
or <a href="base.html#topic+Date">Date</a>. Note that one of e1 and e2 must be a period and the other a
date-time object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A date-time object of class POSIXlt, POSIXct or Date
</p>

<hr>
<h2 id='check_incomplete'>Check completeness of seed and signal data</h2><span id='topic+check_incomplete'></span>

<h3>Description</h3>

<p>This unexported helper is used internally in <a href="#topic+valid_dates">valid_dates</a> to optionally issue a warning for potential completeness of seed and signal data based on dates provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_incomplete(seed_date, signal_date, resolution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_incomplete_+3A_seed_date">seed_date</code></td>
<td>
<p>Last date available in seed object</p>
</td></tr>
<tr><td><code id="check_incomplete_+3A_signal_date">signal_date</code></td>
<td>
<p>First date available in signal object</p>
</td></tr>
<tr><td><code id="check_incomplete_+3A_resolution">resolution</code></td>
<td>
<p>Character vector specifying the temporal resolution (e.g., &quot;weeks&quot;, &quot;months&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Operates as side-effect and returns a <code>warning()</code> if there are the seed and signal dates combined indicate an incomplete week or month.
</p>

<hr>
<h2 id='create_sliding_windows_df'>Sliding windows</h2><span id='topic+create_sliding_windows_df'></span>

<h3>Description</h3>

<p>This unexported helper function is used within <code>plane_shape()</code> to generate sliding windows from a vector and return a data frame where each row is a subset (a sliding window) of a time series. The length of the each windowed time series (and therefore number of columns) is equal to &quot;window_size&quot;. The number of windows is equal to <code>(length(vector) - window_size) + 1</code>. For example, given a time series of length 38 and a window size of length 4, then there will be 35 windowed time series (rows), with 4 time stamps each (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_sliding_windows_df(vector, window_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_sliding_windows_df_+3A_vector">vector</code></td>
<td>
<p>A numeric or integer vector that is the time series to be used to create sliding windows</p>
</td></tr>
<tr><td><code id="create_sliding_windows_df_+3A_window_size">window_size</code></td>
<td>
<p>An integer specifying the size (i.e., number of elements) of the windowed time series desired</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> where each row is a subset (a sliding window) of a time series.
</p>

<hr>
<h2 id='cutter'>Cut into categorical differences</h2><span id='topic+cutter'></span>

<h3>Description</h3>

<p>This unexported helper function takes an input number for an observed difference and cuts it into a categorical description (e.g., &quot;increase&quot;, &quot;decrease&quot;, or &quot;stable&quot;) of the change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutter(x, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutter_+3A_x">x</code></td>
<td>
<p>Vector of length 1 with scaled difference to be categorized</p>
</td></tr>
<tr><td><code id="cutter_+3A_threshold">threshold</code></td>
<td>
<p>Limit used to define the categorical differences; default is <code>1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of length 1 with the categorical description of difference
</p>

<hr>
<h2 id='epiweek_start'>Epiweek start</h2><span id='topic+epiweek_start'></span>

<h3>Description</h3>

<p>This unexported helper identifies the date of the first day for the epiweek of the given date. The function is used internally inside of <a href="#topic+valid_dates">valid_dates</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epiweek_start(date)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="epiweek_start_+3A_date">date</code></td>
<td>
<p>Date to be queried</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Date of the first day of the epiweek for the input date.
</p>

<hr>
<h2 id='get_shapes'>Determine shapes</h2><span id='topic+get_shapes'></span>

<h3>Description</h3>

<p>This unexported helper function is used to identify the shape in the <code>plane_shape()</code> function's scaled difference (&quot;sdiff&quot;) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shapes(input_data, window_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_shapes_+3A_input_data">input_data</code></td>
<td>
<p>A data frame containing at least two columns, one of which must be named &quot;value&quot; with the value assessed and another named &quot;dates&quot; with the date for the observed data</p>
</td></tr>
<tr><td><code id="get_shapes_+3A_window_size">window_size</code></td>
<td>
<p>The number of of categorical differences used to define the shape</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the shapes identified. Each element of the vector will include a shape, which is a cluster of categorical differences (of the same size as the specified &quot;window_size&quot;) collapsed with &quot;;&quot; (e.g., <code>c("decrease;stable;stable;stable","stable;stable;stable;increase","stable;stable;increase;increase")</code>).
</p>

<hr>
<h2 id='is_forecast'>Check forecast</h2><span id='topic+is_forecast'></span>

<h3>Description</h3>

<p>This function checks if the object is of class <code>signal</code> and <code>forecast</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_forecast(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_forecast_+3A_x">x</code></td>
<td>
<p>Input object to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical as to whether or not the input object inherits the &quot;signal&quot; and &quot;forecast&quot; classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## get path to example forecast file
fp &lt;- system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv", package = "rplanes")
ex_forecast &lt;- read_forecast(fp)
sig &lt;- to_signal(ex_forecast, outcome="flu.admits", type="forecast", horizon=4, resolution="weeks")
is_forecast(sig)
</code></pre>

<hr>
<h2 id='is_observed'>Check observed</h2><span id='topic+is_observed'></span>

<h3>Description</h3>

<p>This function checks if the object is of class <code>signal</code> and <code>observed</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_observed(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_observed_+3A_x">x</code></td>
<td>
<p>Input object to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical as to whether or not the input object inherits the &quot;signal&quot; and &quot;observed&quot; classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))
hosp$date &lt;- as.Date(hosp$date, format = "%Y-%m-%d")
sig &lt;- to_signal(hosp, outcome = "flu.admits", type = "observed", resolution = "weeks")
is_observed(sig)
</code></pre>

<hr>
<h2 id='month_start'>Month start</h2><span id='topic+month_start'></span>

<h3>Description</h3>

<p>This unexported helper identifies the date of the first day of the month for the given date. The function is used internally inside of <a href="#topic+valid_dates">valid_dates</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>month_start(date)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="month_start_+3A_date">date</code></td>
<td>
<p>Date to be queried</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Date of the first day of the month for the input date.
</p>

<hr>
<h2 id='plane_cover'>Coverage component</h2><span id='topic+plane_cover'></span>

<h3>Description</h3>

<p>This function evaluates whether or not the evaluated signal interval covers the last observed value. The interval used in this plausibility component is drawn from the upper and lower bounds of the forecasted prediction interval. As such, the only accepted signal format is <a href="#topic+to_signal">forecast</a>, which will include upper and lower bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plane_cover(location, input, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plane_cover_+3A_location">location</code></td>
<td>
<p>Character vector with location code; the location must appear in input and seed</p>
</td></tr>
<tr><td><code id="plane_cover_+3A_input">input</code></td>
<td>
<p>Input signal data to be scored; object must be one of <a href="#topic+to_signal">forecast</a></p>
</td></tr>
<tr><td><code id="plane_cover_+3A_seed">seed</code></td>
<td>
<p>Prepared <a href="#topic+plane_seed">seed</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following values:
</p>

<ul>
<li> <p><strong>indicator</strong>: Logical as to whether or not the last value falls outside of the interval (e.g., not in between lower and upper bounds of prediction interval) of the evaluated signal
</p>
</li>
<li> <p><strong>last_value</strong>: A vector with the last value recorded in the seed
</p>
</li>
<li> <p><strong>bounds</strong>: A list with a two elements corresponding to the upper and lower bounds of the evaluated signal interval
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## read in example observed data and prep observed signal
hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))
hosp$date &lt;- as.Date(hosp$date, format = "%Y-%m-%d")
prepped_observed &lt;- to_signal(hosp, outcome = "flu.admits", type = "observed", resolution = "weeks")

## read in example forecast and prep forecast signal
fp &lt;- system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv", package = "rplanes")
prepped_forecast &lt;- read_forecast(fp) %&gt;%
  to_signal(., outcome = "flu.admits", type = "forecast", horizon = 4)

## prepare seed with cut date
prepped_seed &lt;- plane_seed(prepped_observed, cut_date = "2022-10-29")

## run plane component
plane_cover(location = "08", input = prepped_forecast, seed = prepped_seed)
plane_cover(location = "47", input = prepped_forecast, seed = prepped_seed)
</code></pre>

<hr>
<h2 id='plane_diff'>Difference component</h2><span id='topic+plane_diff'></span>

<h3>Description</h3>

<p>This function implements the point-to-point difference plausibility component. Differences in evaluated signals are calculated from input values iteratively subtracted from the previous values (i.e., for each x at time point i, the difference will be calculated as xi - xi-1). The plausibility analysis uses the evaluated differences to compare against the maximum difference observed and recorded in the seed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plane_diff(location, input, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plane_diff_+3A_location">location</code></td>
<td>
<p>Character vector with location code; the location must appear in input and seed</p>
</td></tr>
<tr><td><code id="plane_diff_+3A_input">input</code></td>
<td>
<p>Input signal data to be scored; object must be one of <a href="#topic+to_signal">forecast</a> or <a href="#topic+to_signal">observed</a></p>
</td></tr>
<tr><td><code id="plane_diff_+3A_seed">seed</code></td>
<td>
<p>Prepared <a href="#topic+plane_seed">seed</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following values:
</p>

<ul>
<li> <p><strong>indicator</strong>: Logical as to whether or not the absolute value of any of the evaluated differences exceeds the maximum difference
</p>
</li>
<li> <p><strong>values</strong>: A vector with the values assessed including the last value in seed concatenated with the evaluated signal values
</p>
</li>
<li> <p><strong>evaluated_differences</strong>: A vector with the consecutive differences for the values
</p>
</li>
<li> <p><strong>maximum_difference</strong>: A vector with one value for the maximum difference observed in seed
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## read in example observed data and prep observed signal
hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))
hosp$date &lt;- as.Date(hosp$date, format = "%Y-%m-%d")
prepped_observed &lt;- to_signal(hosp, outcome = "flu.admits", type = "observed", resolution = "weeks")

## read in example forecast and prep forecast signal
fp &lt;- system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv", package = "rplanes")
prepped_forecast &lt;- read_forecast(fp) %&gt;%
  to_signal(., outcome = "flu.admits", type = "forecast", horizon = 4)

## prepare seed with cut date
prepped_seed &lt;- plane_seed(prepped_observed, cut_date = "2022-10-29")

## run plane component
plane_diff(location = "10", input = prepped_forecast, seed = prepped_seed)
plane_diff(location = "51", input = prepped_forecast, seed = prepped_seed)

</code></pre>

<hr>
<h2 id='plane_repeat'>Repeat component</h2><span id='topic+plane_repeat'></span>

<h3>Description</h3>

<p>This function evaluates whether consecutive values in observations or forecasts are repeated a k number of times. This function takes in a <a href="#topic+to_signal">forecast</a> or <a href="#topic+to_signal">observed</a> object that is either from an observed dataset or forecast dataset. Note that if a signal is contant (i.e., the same value is repeated for all time points) then the repeat component will return <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plane_repeat(location, input, seed, tolerance = NULL, prepend = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plane_repeat_+3A_location">location</code></td>
<td>
<p>Character vector with location code; the location must appear in input and seed</p>
</td></tr>
<tr><td><code id="plane_repeat_+3A_input">input</code></td>
<td>
<p>Input signal data to be scored; object must be one of <a href="#topic+to_signal">forecast</a> or <a href="#topic+to_signal">observed</a></p>
</td></tr>
<tr><td><code id="plane_repeat_+3A_seed">seed</code></td>
<td>
<p>Prepared <a href="#topic+plane_seed">seed</a></p>
</td></tr>
<tr><td><code id="plane_repeat_+3A_tolerance">tolerance</code></td>
<td>
<p>Integer value for the number of allowed repeats before flag is raised. Default is <code>NULL</code> and allowed repeats will be determined from seed.</p>
</td></tr>
<tr><td><code id="plane_repeat_+3A_prepend">prepend</code></td>
<td>
<p>Integer value for the number of values from seed to add before the evaluated signal. Default is <code>NULL</code> and the number of values will be determined from seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following values:
</p>

<ul>
<li> <p><strong>indicator</strong>: Logical as to whether or not the value is repeated sequentially k number of times.
</p>
</li>
<li> <p><strong>repeats</strong>: A <code>tibble</code> with repeating values found. If there are no repeats (i.e., indicator is <code>FALSE</code>) then the <code>tibble</code> will have 0 rows.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## read in example observed data and prep observed signal
hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))
hosp$date &lt;- as.Date(hosp$date, format = "%Y-%m-%d")
prepped_observed &lt;- to_signal(hosp, outcome = "flu.admits", type = "observed", resolution = "weeks")

## read in example forecast and prep forecast signal
fp &lt;- system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv", package = "rplanes")
prepped_forecast &lt;- read_forecast(fp) %&gt;%
  to_signal(., outcome = "flu.admits", type = "forecast", horizon = 4)

## prepare seed with cut date
prepped_seed &lt;- plane_seed(prepped_observed, cut_date = "2022-10-29")

## run plane component
## use defaults
plane_repeat(location = "12", input = prepped_forecast, seed = prepped_seed)
## set tolerated repeats to 2
plane_repeat(location = "12", input = prepped_forecast, seed = prepped_seed, tolerance = 2)

## use defaults
plane_repeat(location = "49", input = prepped_forecast, seed = prepped_seed)
## set number of values prepended for evaluation to 4
plane_repeat(location = "49", input = prepped_forecast, seed = prepped_seed, prepend = 4)

</code></pre>

<hr>
<h2 id='plane_score'>Score PLANES components</h2><span id='topic+plane_score'></span>

<h3>Description</h3>

<p>This function wraps PLANES scoring for specified components across all locations in single step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plane_score(input, seed, components = "all", args = NULL, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plane_score_+3A_input">input</code></td>
<td>
<p>Input signal data to be scored; object must be one of <a href="#topic+to_signal">forecast</a> or <a href="#topic+to_signal">observed</a></p>
</td></tr>
<tr><td><code id="plane_score_+3A_seed">seed</code></td>
<td>
<p>Prepared <a href="#topic+plane_seed">seed</a></p>
</td></tr>
<tr><td><code id="plane_score_+3A_components">components</code></td>
<td>
<p>Character vector specifying component; must be either <code>"all"</code> or any combination of <code>"cover"</code>, <code>"diff"</code>, <code>"taper"</code>, <code>"trend"</code>, <code>"repeat"</code>, <code>"shape"</code>, and <code>"zero"</code>; default is <code>"all"</code> and will use all available components for the given signal</p>
</td></tr>
<tr><td><code id="plane_score_+3A_args">args</code></td>
<td>
<p>Named list of arguments for component functions. List elements must be named to match the given component and arguments passed as a nested list (e.g., <code>args = list("trend" = list("sig_lvl" = 0.05))</code>). Default is <code>NULL</code> and defaults for all components will be used</p>
</td></tr>
<tr><td><code id="plane_score_+3A_weights">weights</code></td>
<td>
<p>Named vector with weights to be applied; default is <code>NULL</code> and all components will be equally weighted; if not <code>NULL</code> then the length of the vector must equal the number of components, with each component given a numeric weight (see Examples). Specified weights must be real numbers greater than or equal to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with scoring results for all locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## read in example observed data and prep observed signal
hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))

hosp$date &lt;- as.Date(hosp$date, format = "%Y-%m-%d")
prepped_observed &lt;- to_signal(hosp, outcome = "flu.admits", type = "observed", resolution = "weeks")

## read in example forecast and prep forecast signal
fp &lt;- system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv", package = "rplanes")
prepped_forecast &lt;- read_forecast(fp) %&gt;%
  to_signal(., outcome = "flu.admits", type = "forecast", horizon = 4)

## prepare seed with cut date
prepped_seed &lt;- plane_seed(prepped_observed, cut_date = "2022-10-29")

## run plane scoring with all components
plane_score(input = prepped_forecast, seed = prepped_seed)

## run plane scoring with select components
plane_score(input = prepped_forecast, seed = prepped_seed, components = c("cover","taper"))

## run plane scoring with all components and additional args
trend_args &lt;- list("sig_lvl" = 0.05)
repeat_args &lt;- list("prepend" = 4, "tolerance" = 8)
shape_args &lt;- list("method" = "dtw")
comp_args &lt;- list("trend" = trend_args, "repeat" = repeat_args, "shape" = shape_args)
plane_score(input = prepped_forecast, seed = prepped_seed, args = comp_args)

## run plane scoring with specific components and weights
comps &lt;- c("cover", "taper", "diff")
wts &lt;- c("cover" = 1.5, "taper" = 1, "diff" = 4)
plane_score(input = prepped_forecast, seed = prepped_seed, components = comps, weights = wts)


</code></pre>

<hr>
<h2 id='plane_seed'>Create seed</h2><span id='topic+plane_seed'></span>

<h3>Description</h3>

<p>This function wraps the <a href="#topic+seed_engine">seed_engine</a> to operate across all locations in the input signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plane_seed(input, cut_date = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plane_seed_+3A_input">input</code></td>
<td>
<p>Input signal data used for seeding; must be an observed signal object</p>
</td></tr>
<tr><td><code id="plane_seed_+3A_cut_date">cut_date</code></td>
<td>
<p>Maximum date (inclusive) for which seeding should be performed; default is <code>NULL</code> and the entire input will be used for seeding</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> of length <em>n</em>, where multiple elements corresponding to seed characteristics and metadata for each of the <em>n</em> locations are nested in independent lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read in example observed data and prep observed signal
hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))
hosp$date &lt;- as.Date(hosp$date, format = "%Y-%m-%d")
prepped_observed &lt;- to_signal(hosp, outcome = "flu.admits", type = "observed", resolution = "weeks")

## prepare seed with no cut date
plane_seed(prepped_observed)

## prepare seed with cut date
plane_seed(prepped_observed, cut_date = "2022-10-29")

</code></pre>

<hr>
<h2 id='plane_shape'>Shape component</h2><span id='topic+plane_shape'></span>

<h3>Description</h3>

<p>This function identifies the shape of the trajectory for a forecasted signal to compare against existing shapes in seed data. If the shape is identified as novel, a flag is raised, and the signal is considered implausible. See the Details section for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plane_shape(location, input, seed, method = "sdiff")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plane_shape_+3A_location">location</code></td>
<td>
<p>Character vector with location code; the location must appear in input and seed</p>
</td></tr>
<tr><td><code id="plane_shape_+3A_input">input</code></td>
<td>
<p>Input signal data to be scored; object must be one of <a href="#topic+to_signal">forecast</a></p>
</td></tr>
<tr><td><code id="plane_shape_+3A_seed">seed</code></td>
<td>
<p>Prepared <a href="#topic+plane_seed">seed</a></p>
</td></tr>
<tr><td><code id="plane_shape_+3A_method">method</code></td>
<td>
<p>The method for determining shapes; must be one of &quot;sdiff&quot; or &quot;dtw&quot; (see Details); default is &quot;sdiff&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approach for determining shapes can be customized by the user with the <code>plane_shape()</code> &quot;method&quot; argument. The two methods available are &quot;sdiff&quot; (default) and &quot;dtw&quot;. Compared with &quot;sdiff&quot;, the &quot;dtw&quot; method has been shown to have a higher sensitivity, lower specificity, and much greater computational cost in some circumstances. The &quot;sdiff&quot; method is recommended if computational efficiency is a concern.
</p>
<p>The &quot;sdiff&quot; method will use consecutive scaled differences to construct shapes. The algorithm operates in three steps:
</p>

<ol>
<li><p> The prepared <a href="#topic+plane_seed">seed</a> data is combined with forecasted point estimates and each point-to-point difference is calculated.
</p>
</li>
<li><p> The differences are centered and scaled, then cut into categories. Differences greater than or equal to one standard deviation above the mean of differences are considered an &quot;increase&quot;. Differences less than or equal to one standard deviation below  the mean of differences are considered a &quot;decrease&quot;. All other differences are considered &quot;stable&quot;.
</p>
</li>
<li><p> The categorical differences are then combined into windows of equal size to the forecasted horizon. Collectively these combined categorical differences create a &quot;shape&quot; (e.g., &quot;increase;stable;stable;decrease&quot;).
</p>
</li>
<li><p> Lastly, the algorithm compares the shape for the forecast to all of the shapes observed. If the shape assessed has not been previously observed in the time series then a flag is raised and the indicator returned is <code>TRUE</code>.
</p>
</li></ol>

<p>The &quot;dtw&quot; method uses a Dynamic Time Warping (DTW) algorithm to identify shapes within the seed data and then compares the shape of the forecast input signal to the observed shapes. This is done in three broad steps:
</p>

<ol>
<li><p> The prepared <a href="#topic+plane_seed">seed</a> data is divided into a set of sliding windows with a step size of one, each representing a section of the overall time series. The length of these windows is determined by the horizon length of the input data signal (e.g., 2 weeks). For example, if the seed data was a vector, <code>c(1, 2, 3, 4, 5)</code>, and the horizon length was 2, then the sliding windows for the observed seed data would be: <code>c(1, 2)</code>, <code>c(2, 3)</code>, <code>c(3, 4)</code>, and <code>c(4, 5)</code>. Each sliding window is a subset of the total trajectory shape of the observed data.
</p>
</li>
<li><p> Shape-based DTW distances are calculated for every 1x1 combination of the observed sliding windows and are stored in a distance matrix. These distances calibrate the function for identifying outlying shapes in forecast data. The algorithm finds the minimum distances for each windowed time series to use as a baseline for &quot;observed distances&quot; between chunks of the larger observed time series. The maximum of those minimum distances across the observed time series is set as the threshold. If the minimum of the forecast:observed distance matrix is greater than the threshold, then the forecast is inferred to be unfamiliar (i.e., a novel shape).
</p>
</li>
<li><p> Next, the algorithm calculates the shape-based DTW distances between the forecast signal (including the point estimate, lower, and upper bounds) and every observed sliding window. If the distance between the forecast and any observed sliding window is less than or equal to the threshold defined above, then this shape is not novel and no flag is raised (indicator is <code>FALSE</code>).
</p>
</li></ol>



<h3>Value</h3>

<p>A <code>list</code> with the following values:
</p>

<ul>
<li> <p><strong>indicator</strong>: Logical as to whether or not the the shape of the evaluated signal is novel (<code>TRUE</code> if shape is novel, <code>FALSE</code> if a familiar shape exists in the seed)
</p>
</li></ul>



<h3>References</h3>

<p>Toni Giorgino. Computing and Visualizing Dynamic Time Warping Alignments in R: The dtw Package. Journal of Statistical Software, 31(7), 1-24. doi:10.18637/jss.v031.i07
</p>
<p>Tormene, P.; Giorgino, T.; Quaglini, S. &amp; Stefanelli, M. Matching incomplete time series with dynamic time warping: an algorithm and an application to post-stroke rehabilitation. Artif Intell Med, 2009, 45, 11-34. doi:10.1016/j.artmed.2008.11.007
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read in example observed data and prep observed signal
hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))

tmp_hosp &lt;-
 hosp %&gt;%
 dplyr::select(date, location, flu.admits) %&gt;%
 dplyr::mutate(date = as.Date(date))

prepped_observed &lt;- to_signal(tmp_hosp,
                               outcome = "flu.admits",
                               type = "observed",
                               resolution = "weeks")
## read in example forecast and prep forecast signal
prepped_forecast &lt;- read_forecast(system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv",
                                                package = "rplanes")) %&gt;%
   to_signal(., outcome = "flu.admits", type = "forecast", horizon = 4)

## prepare seed with cut date
prepped_seed &lt;- plane_seed(prepped_observed, cut_date = "2022-10-29")

## run plane component
plane_shape(location = "37", input = prepped_forecast, seed = prepped_seed)

## run plane component with DTW method
plane_shape(location = "37", input = prepped_forecast, seed = prepped_seed, method = "dtw")

</code></pre>

<hr>
<h2 id='plane_taper'>Taper component</h2><span id='topic+plane_taper'></span>

<h3>Description</h3>

<p>This function evaluates whether or not the evaluated signal interval tapers (i.e., decreases in width) as horizons progress. The interval used in this plausibility component is drawn from the upper and lower bounds of the forecasted prediction interval. As such, the only accepted signal format is <a href="#topic+to_signal">forecast</a>, which will include upper and lower bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plane_taper(location, input, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plane_taper_+3A_location">location</code></td>
<td>
<p>Character vector with location code; the location must appear in input and seed</p>
</td></tr>
<tr><td><code id="plane_taper_+3A_input">input</code></td>
<td>
<p>Input signal data to be scored; object must be one of <a href="#topic+to_signal">forecast</a></p>
</td></tr>
<tr><td><code id="plane_taper_+3A_seed">seed</code></td>
<td>
<p>Prepared <a href="#topic+plane_seed">seed</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following values:
</p>

<ul>
<li> <p><strong>indicator</strong>: Logical as to whether or not the prediction interval width tapers with advancing horizons
</p>
</li>
<li> <p><strong>widths</strong>: Consecutive interval widths for forecasted data
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## read in example observed data and prep observed signal
hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))
hosp$date &lt;- as.Date(hosp$date, format = "%Y-%m-%d")
prepped_observed &lt;- to_signal(hosp, outcome = "flu.admits", type = "observed", resolution = "weeks")

## read in example forecast and prep forecast signal
fp &lt;- system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv", package = "rplanes")
prepped_forecast &lt;- read_forecast(fp) %&gt;%
  to_signal(., outcome = "flu.admits", type = "forecast", horizon = 4)

## prepare seed with cut date
prepped_seed &lt;- plane_seed(prepped_observed, cut_date = "2022-10-29")

## run plane component
plane_taper(location = "19", input = prepped_forecast, seed = prepped_seed)
plane_taper(location = "44", input = prepped_forecast, seed = prepped_seed)
</code></pre>

<hr>
<h2 id='plane_trend'>Trend component</h2><span id='topic+plane_trend'></span>

<h3>Description</h3>

<p>This function identifies any change points in the forecast data or in the final observed data point. Change points are identified by any significant change in magnitude or direction of the slope of the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plane_trend(location, input, seed, sig_lvl = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plane_trend_+3A_location">location</code></td>
<td>
<p>Character vector with location code; the location must appear in input and seed</p>
</td></tr>
<tr><td><code id="plane_trend_+3A_input">input</code></td>
<td>
<p>Input signal data to be scored; object must be <a href="#topic+to_signal">forecast</a></p>
</td></tr>
<tr><td><code id="plane_trend_+3A_seed">seed</code></td>
<td>
<p>Prepared <a href="#topic+plane_seed">seed</a></p>
</td></tr>
<tr><td><code id="plane_trend_+3A_sig_lvl">sig_lvl</code></td>
<td>
<p>The significance level at which to identify change points (between zero and one); default is <code>0.1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <a href="ecp.html#topic+e.divisive">e.divisive()</a>, which implements a hierarchical divisive algorithm to identify change points based on distances between segments (calculated using equations 3 and 5 in Matteson and James, 2014; the larger the distance, the more likely a change point). Then a permutation test is used to calculate an approximate p-value.
</p>
<p>The input to <code>e.divisive()</code> is transformed using differencing (i.e., <code>diff(x)</code> instead of the raw data, <code>x</code>). This slightly changes the way that change points are identified, as the index aligns with the gap between points rather than the points themselves. Instead of identifying a change point based on the change in size between two points, it identifies change points based on the change in the change itself. The dataframe below illustrates the difference between <code>x</code> and <code>diff(x)</code>:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Index</strong> </td><td style="text-align: center;"> <strong>x</strong> </td><td style="text-align: right;"> <strong>diff(x)</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: center;"> 3 </td><td style="text-align: right;"> 6 </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: center;"> 9 </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: center;"> 9 </td><td style="text-align: right;"> 28 </td>
</tr>
<tr>
 <td style="text-align: left;">
   4 </td><td style="text-align: center;"> 37 </td><td style="text-align: right;"> 37 </td>
</tr>
<tr>
 <td style="text-align: left;">
   5 </td><td style="text-align: center;"> 74 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   6 </td><td style="text-align: center;"> 75 </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   7 </td><td style="text-align: center;"> 75 </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Given this data, <code>e.divisive(x)</code> would identify index 5 (74) as the change point, because there was a jump of +37 between index 4 and 5. But <code>e.divisive(diff(x))</code> would pick both index 3 (28) and 5 (1), because there was a jump of +28 from index 2 and 3, and there was a jump of -36 between index 4 and 5.
</p>
<p>Internally, the trend function uses an extra argument to <code>e.divisive()</code> for <code>min.size = 2</code>, which requires a gap of at least 2 points between detecting change points. This can indirectly increase the significance level or decrease the number of change points identified.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following values:
</p>

<ul>
<li> <p><strong>indicator</strong>: Logical as to whether or not the any forecast data or the final observed data point are a significant change point
</p>
</li>
<li> <p><strong>output</strong>: An n x 7 tibble. The length of the forecast plus the observed data determine the length of n. The columns are:
</p>

<ul>
<li> <p><strong>Location</strong>: A character vector with the location code
</p>
</li>
<li> <p><strong>Index</strong>: An integer index of all observed and forecast data
</p>
</li>
<li> <p><strong>Date</strong>: The dates corresponding to all observed and forecast data (formatted as date)
</p>
</li>
<li> <p><strong>Value</strong>: The incidence of all observed and forecast data (e.g., hospitalization rates)
</p>
</li>
<li> <p><strong>Type</strong>: Indicates whether the data row is observed or forecast data
</p>
</li>
<li> <p><strong>Changepoint</strong>: Logical identifying any change point (whether in observed or forecast data). A TRUE is returned if any point is determined a change point based on the user defined significance level (sig_lvl).
</p>
</li>
<li> <p><strong>Flagged</strong>: Logical indicating whether or not the change point was flagged. Change points are only flagged if they are in the forecast data or are the final observed data point. A TRUE is returned if the Changepoint is TRUE and is a final observed data point or any forecast point.
</p>
</li></ul>

</li>
<li> <p><strong>flagged_dates</strong>: The date of any flagged change point(s). If there are none, NA is returned
</p>
</li></ul>



<h3>References</h3>

<p>Matteson, D. S., &amp; James, N. A. (2014). A nonparametric approach for multiple change point analysis of multivariate data. Journal of the American Statistical Association, 109(505), 334–345. https://doi.org/10.1080/01621459.2013.849605
</p>
<p>Matteson DS, James NA (2013). “A Nonparametric Approach for Multiple Change Point Analysis of Multivariate Data.” ArXiv e-prints. To appear in the Journal of the American Statistical Association, 1306.4933.
</p>
<p>Gandy, A. (2009) &quot;Sequential implementation of Monte Carlo tests with uniformly bounded resampling risk.&quot; Journal of the American Statistical Association.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read in example observed data and prep observed signal
hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))
tmp_hosp &lt;-
  hosp %&gt;%
  dplyr::select(date, location, flu.admits) %&gt;%
  dplyr::mutate(date = as.Date(date))

prepped_observed &lt;- to_signal(tmp_hosp, outcome = "flu.admits",
                             type = "observed", resolution = "weeks")

## read in example forecast and prep forecast signal
prepped_forecast &lt;- read_forecast(system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv",
                                               package = "rplanes")) %&gt;%
   to_signal(., outcome = "flu.admits", type = "forecast", horizon = 4)

## prepare seed with cut date
prepped_seed &lt;- plane_seed(prepped_observed, cut_date = "2022-10-29")

## run plane component
plane_trend(location = "05", input = prepped_forecast, seed = prepped_seed, sig_lvl = .2)
## change location
plane_trend(location = "09", input = prepped_forecast, seed = prepped_seed, sig_lvl = .2)
## change sig_lvl
plane_trend(location = "06", input = prepped_forecast, seed = prepped_seed, sig_lvl = .05)

</code></pre>

<hr>
<h2 id='plane_zero'>Zero component</h2><span id='topic+plane_zero'></span>

<h3>Description</h3>

<p>This function checks for the presence of any value(s) equal to zero in the evaluated signal. If there are any zeros found, then the function assesses whether or not any zeros have been observed in the <a href="#topic+plane_seed">seed</a> for the given location. If so, the function will consider the evaluated zero plausible and no flag will be raised (i.e., indicator returned as <code>FALSE</code>). If not, the function will consider the evaluated zero implausible and a flag will be raised (i.e., indicator returned as <code>TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plane_zero(location, input, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plane_zero_+3A_location">location</code></td>
<td>
<p>Character vector with location code; the location must appear in input and seed</p>
</td></tr>
<tr><td><code id="plane_zero_+3A_input">input</code></td>
<td>
<p>Input signal data to be scored; object must be one of <a href="#topic+to_signal">forecast</a> or <a href="#topic+to_signal">observed</a></p>
</td></tr>
<tr><td><code id="plane_zero_+3A_seed">seed</code></td>
<td>
<p>Prepared <a href="#topic+plane_seed">seed</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following values:
</p>

<ul>
<li> <p><strong>indicator</strong>: Logical as to whether or not there are zeros in evaluated signal but not in seed data
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## read in example observed data and prep observed signal
hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))
hosp$date &lt;- as.Date(hosp$date, format = "%Y-%m-%d")
prepped_observed &lt;- to_signal(hosp, outcome = "flu.admits", type = "observed", resolution = "weeks")

## read in example forecast and prep forecast signal
fp &lt;- system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv", package = "rplanes")
prepped_forecast &lt;- read_forecast(fp) %&gt;%
  to_signal(., outcome = "flu.admits", type = "forecast", horizon = 4)

## prepare seed with cut date
prepped_seed &lt;- plane_seed(prepped_observed, cut_date = "2022-10-29")

## run plane component
plane_zero(location = "10", input = prepped_forecast, seed = prepped_seed)
plane_zero(location = "51", input = prepped_forecast, seed = prepped_seed)

</code></pre>

<hr>
<h2 id='q_boundary'>Quantile boundary</h2><span id='topic+q_boundary'></span>

<h3>Description</h3>

<p>This unexported helper generates a vector of lower bound, median, and upper bound for the prediction interval of specified width. The function is used internally inside of <a href="#topic+read_forecast">read_forecast</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_boundary(pi_width)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="q_boundary_+3A_pi_width">pi_width</code></td>
<td>
<p>Interval width as an integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of quantiles corresponding to lower and upper bounds centered on median.
</p>

<hr>
<h2 id='read_forecast'>Read in forecast file</h2><span id='topic+read_forecast'></span>

<h3>Description</h3>

<p>This function reads a probabilistic (&quot;quantile&quot;) forecast csv file and prepares it for the <a href="#topic+to_signal">to_signal</a> function and downstream plausibility analysis. The quantile forecast file can be either a &quot;legacy&quot; or &quot;hubverse&quot; format (see Details for more information). The object returned is a <code>tibble</code> with summarized forecast data (i.e., prediction interval) for each location and horizon in the original file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_forecast(file, pi_width = 95, format = "legacy")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_forecast_+3A_file">file</code></td>
<td>
<p>Path to csv file containing quantile forecasts</p>
</td></tr>
<tr><td><code id="read_forecast_+3A_pi_width">pi_width</code></td>
<td>
<p>Width of prediction interval as integer; default <code>95</code> corresponds to 95% prediction interval</p>
</td></tr>
<tr><td><code id="read_forecast_+3A_format">format</code></td>
<td>
<p>Format of the probabilistic format file; must be one of <code>"legacy"</code> or <code>"hubverse"</code> (see Details for more information); default is <code>"legacy"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probabilistic forecast format has been used by multiple forecasting hubs. In general, this format includes one row per combination of quantile, location, target, and horizon. At each row the forecasted value is provided. The specific format, including columns required, has changed over time. This function accommodates the &quot;legacy&quot; as well as more recent &quot;hubverse&quot; formats. For more details on specific columns and see the links in the References.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> with the following columns:
</p>

<ul>
<li> <p><strong>location</strong>: Geographic unit such as FIPS code
</p>
</li>
<li> <p><strong>date</strong>: Date corresponding the forecast horizon
</p>
</li>
<li> <p><strong>horizon</strong>: Forecast horizon
</p>
</li>
<li> <p><strong>lower</strong>: Lower limit of the prediction interval for the forecast
</p>
</li>
<li> <p><strong>point</strong>: Point estimate for the forecast
</p>
</li>
<li> <p><strong>upper</strong>: Upper limit of the prediction interval for the forecast
</p>
</li></ul>



<h3>References</h3>

<p>Hubverse: <a href="https://hubdocs.readthedocs.io/en/latest/user-guide/model-output.html">https://hubdocs.readthedocs.io/en/latest/user-guide/model-output.html</a>
</p>
<p>Legacy: <a href="https://github.com/cdcepi/Flusight-forecast-data/tree/master/data-forecasts#forecast-file-format">https://github.com/cdcepi/Flusight-forecast-data/tree/master/data-forecasts#forecast-file-format</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read in example forecast and prep forecast signal (legacy format)
fp &lt;- system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv", package = "rplanes")
read_forecast(fp)

fp2 &lt;- system.file("extdata/forecast/2023-11-04-SigSci-TSENS.csv", package = "rplanes")
read_forecast(fp2, format = "hubverse")

</code></pre>

<hr>
<h2 id='resolve_resolution'>Resolve resolution</h2><span id='topic+resolve_resolution'></span>

<h3>Description</h3>

<p>This helper function uses argument matching to resolve the resolution from input. The function also handles casing. This will allow, for example, an input resolution of &quot;daily&quot; or &quot;day&quot; to be resolved to &quot;days&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve_resolution(resolution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolve_resolution_+3A_resolution">resolution</code></td>
<td>
<p>Character vector specifying the temporal resolution (e.g., &quot;days&quot;, &quot;weeks&quot;, &quot;months&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the resolution matches to &quot;days&quot;, &quot;weeks&quot;, or &quot;months&quot; then the match will be returned. If not, the function will throw an error.
</p>

<hr>
<h2 id='rplanes_explorer'><code>rplanes</code> explorer app launcher</h2><span id='topic+rplanes_explorer'></span>

<h3>Description</h3>

<p>The <code>rplanes</code> explorer app allows a user to interactively upload their own data (or view an internal example) to explore the plausibility analysis functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rplanes_explorer(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rplanes_explorer_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <a href="shiny.html#topic+runApp">shiny::runApp</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function operates as a side-effect and starts the <code>rplanes</code> Shiny app.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Launch the explorer app
rplanes_explorer(host = "0.0.0.0",
                 launch.browser = TRUE,
                 port = 80)

## End(Not run)
</code></pre>

<hr>
<h2 id='seed_engine'>Seed engine</h2><span id='topic+seed_engine'></span>

<h3>Description</h3>

<p>This helper function is used inside of <a href="#topic+plane_seed">plane_seed</a> to evaluate characteristics of observed data to use for downstream plausibility analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seed_engine(input, location, cut_date = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seed_engine_+3A_input">input</code></td>
<td>
<p>Input signal data used for seeding; must be an observed signal object</p>
</td></tr>
<tr><td><code id="seed_engine_+3A_location">location</code></td>
<td>
<p>Character vector with location code</p>
</td></tr>
<tr><td><code id="seed_engine_+3A_cut_date">cut_date</code></td>
<td>
<p>Maximum date (inclusive) for which seeding should be performed; default is <code>NULL</code> and the entire input will be used for seeding</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of length 1 with multiple elements corresponding to seed characteristics and metadata for the given location.
</p>

<hr>
<h2 id='to_chunk'>Chunk a vector</h2><span id='topic+to_chunk'></span>

<h3>Description</h3>

<p>This unexported helper function creates a list with contents of a vector spit into chunks. The user can specify how large each chunk should be with the &quot;size&quot; argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_chunk(x, size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_chunk_+3A_x">x</code></td>
<td>
<p>Vector to be split into chunks as large as the &quot;size&quot; specified</p>
</td></tr>
<tr><td><code id="to_chunk_+3A_size">size</code></td>
<td>
<p>Width of the chunks for &quot;x&quot; vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with as many elements as the number of chunks created. Each element will include vector with a length equal to the &quot;size&quot; specified.
</p>

<hr>
<h2 id='to_signal'>Create signal object</h2><span id='topic+to_signal'></span>

<h3>Description</h3>

<p>This function creates an object of the S3 class &quot;signal&quot;. The user can conditionally specify either a &quot;forecast&quot; or &quot;observed&quot; signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_signal(
  input,
  outcome,
  type = "observed",
  resolution = "weeks",
  horizon = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_signal_+3A_input">input</code></td>
<td>
<p>Data to be converted to signal; see &quot;Details&quot; for more information</p>
</td></tr>
<tr><td><code id="to_signal_+3A_outcome">outcome</code></td>
<td>
<p>Name of the outcome column in the input data</p>
</td></tr>
<tr><td><code id="to_signal_+3A_type">type</code></td>
<td>
<p>Signal type; must be one of &quot;observed&quot; or &quot;forecast&quot;; default is &quot;observed&quot;</p>
</td></tr>
<tr><td><code id="to_signal_+3A_resolution">resolution</code></td>
<td>
<p>The temporal resolution of the signal; data can be aggregated daily, weekly, or monthly; default is <code>"weeks"</code>; see &quot;Details&quot; for more information</p>
</td></tr>
<tr><td><code id="to_signal_+3A_horizon">horizon</code></td>
<td>
<p>Number of time steps ahead for forecast signals; only used if <code>type="forecast"</code>; default is <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input signal data may be either &quot;observed&quot; or &quot;forecast&quot; data. Depending on the type, the input data must conform to certain format prior to submission. In both cases, the data must be passed as a data frame.
</p>
<p>For &quot;observed&quot; data the data frame must at minimum include columns for <strong>location</strong> (geographic unit such as FIPS code) and <strong>date</strong> (date of reported value; must be <code>date</code> class). The data should also include a column that contains the outcome (e.g., case count).
</p>
<p>For &quot;forecast&quot; data the data frame must include columns for <strong>location</strong> (geographic unit such as FIPS code), <strong>date</strong> (date corresponding to forecast horizon; must be <code>date</code> class or character formatted as 'YYYY-MM-DD'), <strong>horizon</strong> (forecast horizon), <strong>lower</strong> (the lower limit of the prediction interval for the forecast), <strong>point</strong> (the point estimate for the forecast), and <strong>upper</strong> (the upper limit of the prediction interval for the forecast). Note that the <a href="#topic+read_forecast">read_forecast</a> function returns data in this format.
</p>
<p>The input data must at the daily, weekly, or monthly resolution. The &quot;resolution&quot; parameter is designed to use string matching. This allows flexibility for the user, such that, for example, an input of &quot;day&quot;, &quot;days&quot;, or &quot;daily&quot; would all resolve to a resolution of <em>days</em>. The same rules apply for designating weekly or monthly resolution.
</p>


<h3>Value</h3>

<p>An object of the class <code>signal</code>. The object will have a second class of either <code>observed</code> or <code>forecast</code> depending on the value passed to the &quot;type&quot; argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hosp &lt;- read.csv(system.file("extdata/observed/hdgov_hosp_weekly.csv", package = "rplanes"))
to_signal(hosp, outcome = "flu.admits", type = "observed", resolution = "weeks")

fp &lt;- system.file("extdata/forecast/2022-10-31-SigSci-TSENS.csv", package = "rplanes")
ex_forecast &lt;- read_forecast(fp)
to_signal(ex_forecast, outcome = "flu.admits", type = "forecast", horizon = 4, resolution = "weeks")
</code></pre>

<hr>
<h2 id='valid_dates'>Validate dates</h2><span id='topic+valid_dates'></span>

<h3>Description</h3>

<p>This function validates that there are no gaps or overlaps between dates specified in the &quot;seed_date&quot; and &quot;signal_date&quot;. During plausibility component analyses, the function is called to validate the seed against the evaluated signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_dates(seed_date, signal_date, resolution, warn_incomplete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valid_dates_+3A_seed_date">seed_date</code></td>
<td>
<p>Last date available in seed object</p>
</td></tr>
<tr><td><code id="valid_dates_+3A_signal_date">signal_date</code></td>
<td>
<p>First date available in signal object</p>
</td></tr>
<tr><td><code id="valid_dates_+3A_resolution">resolution</code></td>
<td>
<p>Character vector specifying the temporal resolution (e.g., &quot;days&quot;, &quot;weeks&quot;, &quot;months&quot;)</p>
</td></tr>
<tr><td><code id="valid_dates_+3A_warn_incomplete">warn_incomplete</code></td>
<td>
<p>Logical as to whether or not the validation should warn for completeness of seed and signal; default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The validation will return with a <code>stop()</code> if there is an overlap or gap between seed and signal dates. Otherwise the function will invisibly return <code>TRUE</code> indicating that the date span is valid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seed_date &lt;- as.Date("2023-03-08")
signal_date &lt;- as.Date("2023-03-15")
valid_dates(seed_date = seed_date, signal_date = signal_date, resolution="weeks")
x &lt;- try(valid_dates(seed_date = seed_date,
                          signal_date = signal_date,
                          resolution="days"), silent=TRUE)
x
x &lt;- try(valid_dates(seed_date = seed_date,
                          signal_date = signal_date,
                          resolution="months"), silent=TRUE)
x
</code></pre>

<hr>
<h2 id='valid_location'>Validate location</h2><span id='topic+valid_location'></span>

<h3>Description</h3>

<p>This unexported helper is used inside of the individual plausibility component functions (e.g., <code>plane_diff()</code>) to validate that the location specified appears in both the input signal and seed and that the location has as many values as other locations in the seed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_location(location, input, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valid_location_+3A_location">location</code></td>
<td>
<p>Character vector with location code; the location must appear in input and seed</p>
</td></tr>
<tr><td><code id="valid_location_+3A_input">input</code></td>
<td>
<p>Input signal data to be scored; object must be <a href="#topic+to_signal">forecast</a></p>
</td></tr>
<tr><td><code id="valid_location_+3A_seed">seed</code></td>
<td>
<p>Prepared <a href="#topic+plane_seed">seed</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The validation will return with a <code>stop()</code> if the location is not found in the seed or input signal. Otherwise the function will invisibly return <code>TRUE</code> indicating that the location is valid.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
