<!DOCTYPE html><html lang="en"><head><title>Help for package FluMoDL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FluMoDL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addPredictions'><p>Add predictions to summary.FluMoDL objects</p></a></li>
<li><a href='#attrdl'><p>Attributable risk from distributed lag nonlinear models</p></a></li>
<li><a href='#attrMort'><p>Influenza- and temperature-attributable mortality for a FluMoDL object</p></a></li>
<li><a href='#blup.FluMoDL'><p>Get or set BLUP coefficients for a FluMoDL object</p></a></li>
<li><a href='#fitFluMoDL'><p>Fit a FluMoDL object</p></a></li>
<li><a href='#greece'><p>Greece mortality and influenza data</p></a></li>
<li><a href='#hasPeriodic'><p>Does object include a periodic B-spline term?</p></a></li>
<li><a href='#hasRSV'><p>Does object have a term for RSV?</p></a></li>
<li><a href='#isoweek'><p>Calculate the ISO week &amp; year for a Date</p></a></li>
<li><a href='#isoweekStart'><p>Calculate the start date of a given ISO week</p></a></li>
<li><a href='#linterp'><p>Linearly interpolate missing values in a numeric vector</p></a></li>
<li><a href='#metaFluMoDL'><p>Multivariate meta-analysis for FluMoDL objects</p></a></li>
<li><a href='#NOAA_allStations'><p>Get list of weather stations from NOAA</p></a></li>
<li><a href='#NOAA_getGSOD'><p>Get daily weather summaries from NOAA</p></a></li>
<li><a href='#pbs'><p>Periodic B-Spline Basis for Polynomial Splines</p></a></li>
<li><a href='#pooled'><p>Get pooled effect estimates from metaFluMoDL object</p></a></li>
<li><a href='#predict.FluMoDL'><p>Predict method for FluMoDL objects</p></a></li>
<li><a href='#summary.FluMoDL'><p>Summary method for FluMoDL objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, splines, tsModel</td>
</tr>
<tr>
<td>Title:</td>
<td>Influenza-Attributable Mortality with Distributed-Lag Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Theodore Lytras &lt;thlytras@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>dlnm, mvmeta</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to estimate the mortality attributable to 
    influenza and temperature, using distributed-lag nonlinear models
    (DLNMs), as first implemented in 
    Lytras et al. (2019) &lt;<a href="https://doi.org/10.2807%2F1560-7917.ES.2019.24.14.1800118">doi:10.2807/1560-7917.ES.2019.24.14.1800118</a>&gt;.
    Full descriptions of underlying DLNM methodology in Gasparrini et al. 
    &lt;<a href="https://doi.org/10.1002%2Fsim.3940">doi:10.1002/sim.3940</a>&gt; (DLNMs), 
    &lt;<a href="https://doi.org/10.1186%2F1471-2288-14-55">doi:10.1186/1471-2288-14-55</a>&gt; (attributable risk from DLNMs) and 
    &lt;<a href="https://doi.org/10.1002%2Fsim.5471">doi:10.1002/sim.5471</a>&gt; (multivariate meta-analysis).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-13 10:28:04 UTC; bones</td>
</tr>
<tr>
<td>Author:</td>
<td>Theodore Lytras <a href="https://orcid.org/0000-0002-4146-4122"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Antonio Gasparrini
    <a href="https://orcid.org/0000-0002-2271-3568"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Shuangcai Wang [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-13 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addPredictions'>Add predictions to summary.FluMoDL objects</h2><span id='topic+addPredictions'></span>

<h3>Description</h3>

<p>This function uses the data available in a <a href="#topic+fitFluMoDL">FluMoDL</a> object
to generate predictions (in the form of <code><a href="dlnm.html#topic+crosspred">crosspred</a></code> objects) for a
<code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPredictions(s, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addPredictions_+3A_s">s</code></td>
<td>
<p>An object of class <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> (normally holding BLUP or
pooled estimates, i.e. <code>s$type</code> will equal <code>"blup"</code> or <code>"pooled"</code>)
for which predictions will be generated.</p>
</td></tr>
<tr><td><code id="addPredictions_+3A_m">m</code></td>
<td>
<p>An object of class <a href="#topic+fitFluMoDL">FluMoDL</a>, which provides the original
(untransformed) predictor data to create the predictions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creating a <a href="dlnm.html#topic+crossbasis">cross-basis matrix</a> (to use as covariate
in a Distributed-Lag Nonlinear Model) transforms and scales the original predictor.
Interpreting the model coefficients requires revisiting the cross-basis matrix and
backtransforming to the original predictor, in order to generate predicted effect
estimates for specific values of predictor and lag.
</p>
<p>For this reason, <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> objects created from a
<a href="#topic+metaFluMoDL">multivariate meta-analysis</a>, containing pooled or BLUP coefficients,
do not contain predictions (their <code>$pred</code> element is <code>NULL</code>)
because they have no reference to an original predictor.
This is what <code>addPredictions()</code> does: it uses the cross-basis matrices from a
FluMoDL object <code>m</code> to calculate predictions with the coefficients in
the <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> object <code>s</code>. It provides the necessary
&quot;context&quot; in which to interpret the model coefficients.
</p>


<h3>Value</h3>

<p>The function returns the <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> object <code>s</code>,
with predictions added (as element <code>$pred</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code>, <code><a href="#topic+fitFluMoDL">fitFluMoDL</a></code>,
<code><a href="dlnm.html#topic+crosspred">crosspred</a></code>
</p>

<hr>
<h2 id='attrdl'>Attributable risk from distributed lag nonlinear models</h2><span id='topic+attrdl'></span>

<h3>Description</h3>

<p>This is a general function that computes attributable risk (attributable numbers or fractions)
from distributed lag nonlinear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attrdl(x, basis, cases, model = NULL, coef = NULL, vcov = NULL,
  type = "af", dir = "back", tot = TRUE, cen, range = NULL,
  sim = FALSE, nsim = 5000, sub = 1:length(cases))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attrdl_+3A_x">x</code></td>
<td>
<p>An exposure vector OR (only for <code>dir="back"</code>) a matrix of lagged exposures, for which
the attributable risk needs to be computed.</p>
</td></tr>
<tr><td><code id="attrdl_+3A_basis">basis</code></td>
<td>
<p>The object of class &quot;crossbasis&quot; used for fitting the model.</p>
</td></tr>
<tr><td><code id="attrdl_+3A_cases">cases</code></td>
<td>
<p>The cases vector OR (only for <code>dir="forw"</code>) the matrix of future cases corresponding to <code>x</code>.</p>
</td></tr>
<tr><td><code id="attrdl_+3A_model">model</code></td>
<td>
<p>The fitted model. You need to provide either this, or arguments <code>coef</code> and <code>vcov</code>.
<em>The model MUST have a log link function.</em></p>
</td></tr>
<tr><td><code id="attrdl_+3A_coef">coef</code></td>
<td>
<p>Coefficients for <code>basis</code> IF <code>model</code> is not provided</p>
</td></tr>
<tr><td><code id="attrdl_+3A_vcov">vcov</code></td>
<td>
<p>Variance-covariance matrix for <code>basis</code> IF <code>model</code> is not provided</p>
</td></tr>
<tr><td><code id="attrdl_+3A_type">type</code></td>
<td>
<p>Either &quot;an&quot; or &quot;af&quot; for attributable number or attributable fraction</p>
</td></tr>
<tr><td><code id="attrdl_+3A_dir">dir</code></td>
<td>
<p>Either &quot;back&quot; or &quot;forw&quot; for backward or forward perspectives of attributable risk</p>
</td></tr>
<tr><td><code id="attrdl_+3A_tot">tot</code></td>
<td>
<p>If <code>TRUE</code>, the total attributable risk is computed (number or fraction, depending on argument <code>type</code>)</p>
</td></tr>
<tr><td><code id="attrdl_+3A_cen">cen</code></td>
<td>
<p>The reference value used as the counterfactual scenario (the comparator)</p>
</td></tr>
<tr><td><code id="attrdl_+3A_range">range</code></td>
<td>
<p>The range of exposure (for which the attributable risk, compared to <code>cen</code>, is
calculated). If <code>NULL</code>, the whole range is used.</p>
</td></tr>
<tr><td><code id="attrdl_+3A_sim">sim</code></td>
<td>
<p>Set to <code>TRUE</code> if Monte Carlo simulation samples should be returned.</p>
</td></tr>
<tr><td><code id="attrdl_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulation samples desired (only for <code>nsim=TRUE</code>).</p>
</td></tr>
<tr><td><code id="attrdl_+3A_sub">sub</code></td>
<td>
<p>Subset of <code>cases</code> for which to calculate the attributable risk (as an integer index
vector). Defaults to <code>1:length(cases)</code>. Argument <code>cases</code> should be a vector (not a matrix).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Original function and documentation written by Antonio Gasparrini and available
<a href="https://github.com/gasparrini/2014_gasparrini_BMCmrm_Rcodedata">here</a>.
Slightly amended by Theodore Lytras for use with FluMoDL.
</p>
<p>Documentation below copied from the
<a href="https://github.com/gasparrini/2014_gasparrini_BMCmrm_Rcodedata/blob/master/attrdl.pdf">original source</a>.
</p>
<p>This function computes the attributable fraction or number for a specific exposure
scenario and associated cases, given an estimated exposure-lag-response association defined
by a DLNM. Either forward or backward versions of attributable risk measures are available
in this setting. The method is described by Gasparrini and Leone (2014), see references below.
The function works in combination with other functions in the package dlnm, which is assumed
to be available.
</p>
<p>The exposure and cases are provided by the arguments x and cases, respectively. The original
cross-basis and fitted model containg it used for estimation are provided by the arguments
basis and model, respectively. Alternatively, the user can provide estimated coefficients and
(co)variance matrix with coef and vcov.
</p>
<p>The function works both with time series and non-time series data. In a time series setting,
both x and cases represent a complete series of ordered observations. More generally, the user
can apply this function for any kind of data: in this case x must be a matrix of lagged
exposures when dir=&quot;back&quot;, and cases must be a matrix of future cases dir=&quot;forw&quot;. The function
can compute the total attributable risk (if tot=TRUE, the default) or the contribution for each
observation. The argument cen defines the value used as counterfactual scenario.
</p>
<p>If sim=TRUE, the function computes samples of the attributable risk measures by simulating from
the assumed normal distribution of the estimated coefficients (only implemented for total
estimates). These samples can be used to defined empirical confidence intervals.
</p>


<h3>Value</h3>

<p>By default, a numeric scalar representing the total attributable fraction or number.
If sim=TRUE, a vector of the simulated samples with length nsim. If tot=FALSE, a vector with
contributions for all the observations (see Note below). These quantities are defined versus
a counterfactual scenario defined through the argument cen.
</p>


<h3>Note</h3>

<p>The function handles missing values in both the x and cases objects, excluding incomplete
observations (also due to lagging) accordingly. However, the total attributable number is
rescaled to match the fraction using as denominator the total observed number in cases. This
approach uses the all the available information even in the presence of missing values in x.
All of this under the assumption that the missing mechanism is unrelated with both exposure and
cases values.
</p>
<p>The functions can be also used with estimates from DLNMs reduced to the overall cumulative
exposure-response through the function crossreduce in the package dlnm. In this case, the
modified coefficients and (co)variance matrix of the reduced cross-basis in basis must be
passed using the arguments coef and vcov. This option can be useful when the original estimates
from the full cross-basis are not available any more, for example following a meta-analysis.
Given the lag-specific estimates are not available in this case, only the forward version of
attributable risk (dir=&quot;forw&quot;) can be computed. See Gasparrini and Leone (2014) for further info.
</p>


<h3>Author(s)</h3>

<p>Original author: Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;
</p>


<h3>References</h3>

 <ul>
<li><p> Gasparrini A, Leone M. Attributable risk from distributed lag models.
<a href="https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/1471-2288-14-55">BMC Med Res Methodol</a> 2014;14:55.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# load the package
library(FluMoDL)  # package dlnm is automatically loaded

# define the cross-basis and fit the model
cb &lt;- crossbasis(chicagoNMMAPS$temp, lag=30, argvar=list(fun="bs",
   knots=c(-10,3,18)), arglag=list(knots=c(1,3,10)))
library(splines)
model &lt;- glm(death ~ cb + ns(time, 7*14) + dow,
   family=quasipoisson(), chicagoNMMAPS)

# global backward attributable risk of temperature (number and fraction)
attrdl(chicagoNMMAPS$temp,cb,chicagoNMMAPS$death,model,type="an",cen=21)
attrdl(chicagoNMMAPS$temp,cb,chicagoNMMAPS$death,model,cen=21)

# global forward attributable fraction
attrdl(chicagoNMMAPS$temp,cb,chicagoNMMAPS$death,model,dir="forw",cen=21)

# empirical confidence intervals
afsim &lt;- attrdl(chicagoNMMAPS$temp,cb,chicagoNMMAPS$death,model,cen=21,
   sim=TRUE,nsim=1000)
quantile(afsim,c(2.5,97.5)/100)

# attributable fraction component due to heat and cold
attrdl(chicagoNMMAPS$temp,cb,chicagoNMMAPS$death,model,cen=21,range=c(21,100))
attrdl(chicagoNMMAPS$temp,cb,chicagoNMMAPS$death,model,cen=21,range=c(-100,21))

# daily attributable deaths in the second month
attrdl(chicagoNMMAPS$temp,cb,chicagoNMMAPS$death,model,type="an",
   tot=FALSE,cen=21)[31:60]



</code></pre>

<hr>
<h2 id='attrMort'>Influenza- and temperature-attributable mortality for a FluMoDL object</h2><span id='topic+attrMort'></span>

<h3>Description</h3>

<p>This function uses an object of class <code>FluMoDL</code> to calculate mortality
attributed to influenza and/or temperature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attrMort(m, par = c("H1", "H3", "B", "temp", "RSV"), sel = "week",
  from = NULL, to = NULL, temprange = "cold", ci = TRUE,
  nsim = 5000, mcsamples = FALSE, progress = TRUE, blup = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attrMort_+3A_m">m</code></td>
<td>
<p>An object of class <code>FluMoDL</code>.</p>
</td></tr>
<tr><td><code id="attrMort_+3A_par">par</code></td>
<td>
<p>A character vector indicating which exposures to calculate the
attributable mortality for. Defaults to <code>c("H1","H3","B","temp","RSV")</code>, which
indicates all three influenza proxies, temperature and RSV (if it exists in the model).</p>
</td></tr>
<tr><td><code id="attrMort_+3A_sel">sel</code></td>
<td>
<p>For which time period(s) to calculate attributable mortality. This can be
one of several choices. For <code>sel="week"</code> (the default) and <code>sel="season"</code> attributable
mortality is calculated for each week or each season respectively. One can also
provide to <code>sel</code> a list of index vectors (integer or logical) corresponding to
particular rows of <code>m$data</code>, or a matrix of logical index vectors, or a single
index vector. Note that the index vectors should point to <em>consecutive rows</em>
of <code>m$data</code>.</p>
</td></tr>
<tr><td><code id="attrMort_+3A_from">from</code></td>
<td>
<p>Week (integer, in YYYYWW format) or season to start from, in case
<code>sel="week"</code> or <code>sel="season"</code> respectively.</p>
</td></tr>
<tr><td><code id="attrMort_+3A_to">to</code></td>
<td>
<p>Week (integer, in YYYYWW format) or season to end with, in case
<code>sel="week"</code> or <code>sel="season"</code> respectively.</p>
</td></tr>
<tr><td><code id="attrMort_+3A_temprange">temprange</code></td>
<td>
<p>In case temperature-attributable mortality is calculated (argument
<code>par</code> includes &quot;temp&quot;), this argument specifies the temperature range or interest.
This can be one of several choices.
</p>
<p>If <code>temprange="cold"</code> (the default) mortality
attributable to cold temperatures is calculated, i.e. temperatures below the MMP
(minimum mortality point). If <code>temprange="heat"</code> mortality attributable to hot
temperatures is calculated, i.e. those above the MMP. If <code>temperature="all"</code> the
entire range of temperatures is used, i.e. any temperature other than the MMP.
</p>
<p>Alternatively one can provide a numeric vector of length two, indicating a specific
temperature range; this can also be provided as a <em>character</em> vector of length two,
where one of the elements can be the word &quot;MMP&quot;, which will be replaced with the MMP
temperature.</p>
</td></tr>
<tr><td><code id="attrMort_+3A_ci">ci</code></td>
<td>
<p>If <code>TRUE</code>, empirical (Monte Carlo) 95
for all attributable mortality estimates.</p>
</td></tr>
<tr><td><code id="attrMort_+3A_nsim">nsim</code></td>
<td>
<p>Number of Monte Carlo simulations to run per attributable mortality estimate.
Defaults to 5000. Increase if higher precision is required (and you don't mind the wait).</p>
</td></tr>
<tr><td><code id="attrMort_+3A_mcsamples">mcsamples</code></td>
<td>
<p>If <code>TRUE</code>, return all Monte Carlo simulation samples in the output.
See below.</p>
</td></tr>
<tr><td><code id="attrMort_+3A_progress">progress</code></td>
<td>
<p>If <code>TRUE</code>, a progress bar appears if Monte Carlo simulations are
run and if there are more than three time periods selected in argument <code>sel</code>. Set to
<code>FALSE</code> to suppress the progress bar.</p>
</td></tr>
<tr><td><code id="attrMort_+3A_blup">blup</code></td>
<td>
<p>If <code>FALSE</code> (the default), the model coefficients stored in <code>m$model</code>
are used for the calculation of attributable mortality. If <code>TRUE</code>, the coefficients
<a href="#topic+blup.FluMoDL">stored in the FluMoDL object</a> are used; if <code>blup=TRUE</code> but
<code>blup(m)</code> is <code>NULL</code>, a warning is generated. Alternatively, <code>blup</code> can
be another object of class <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code>, whose coefficients are used for the
calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All attributable mortalities are calculated using the &quot;backward&quot; perspective, meaning
the mortality at any given day that is attributable to exposures up to 30 days previously
(=the maximum lag).
</p>
<p>Confidence intervals (when <code>ci=TRUE</code>) are obtained empirically through Monte Carlo
simulations; this can take quite some time if lots of CIs need to be calculated (for example
if <code>sel=TRUE</code>). For this reason, a progress bar is shown by default in this case
(which can be suppressed by <code>progress=FALSE</code>).
</p>
<p>Temperature-attributable mortalities are by default calculated for cold temperatures, i.e.
temperatures lower than the minimum mortality point (MMP). Note, however, that the adjustment
in the FluMoDL is made for the entire range of daily mean temperatures, not just for cold.
Therefore mortality attributable to any range of temperatures can be calculated, e.g. for
heat, extreme cold, extreme heat, etc. See argument <code>temprange</code> above for details.
</p>


<h3>Value</h3>

<p>If <code>mcsamples=FALSE</code> (the default), a data.frame is returned with columns named
'FluH1', 'FluH3', 'FluB' and 'Temp' (and/or 'RSV'), depending on the argument <code>par</code>,
and also 'FluH1.lo', 'FluH1.hi', 'FluH3.lo', ..., if <code>ci=TRUE</code>. Each row in the output
corresponds to a selection
made in argument <code>sel</code>, for example if <code>sel="week"</code> (the default) rows correspond to
each week available in the data. If all influenza types/subtypes are selected in <code>par</code>, a
column named 'AllFlu' is also calculated automatically, with the mortality (and 95
attributable to all influenza types/subtypes.
</p>
<p>If <code>mcsamples=TRUE</code>, a list is returned with elements 'result' and 'mcsamples'. The
first contains the data.frame with point estimates of influenza- and/or temperature-attributable
mortality, as before (no 95
element contains a list of the Monte Carlo simulation samples for each parameter in <code>par</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Lytras T, Pantavou K, Mouratidou E, Tsiodras S. Mortality attributable to seasonal influenza
in Greece, 2013 to 2017: variation by type/subtype and age, and a possible harvesting effect.
<a href="https://www.eurosurveillance.org/content/10.2807/1560-7917.ES.2019.24.14.1800118">Euro Surveill.</a>
2019;24(14):pii=1800118 (<a href="https://www.ncbi.nlm.nih.gov/pubmed/30968823">PubMed</a>)
</p>
</li>
<li><p> Gasparrini A, Leone M. Attributable risk from distributed lag models.
<a href="https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/1471-2288-14-55">BMC Med Res Methodol</a> 2014;14:55.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(greece) # Use example surveillance data from Greece
m &lt;- with(greece, fitFluMoDL(deaths = daily$deaths,
    temp = daily$temp, dates = daily$date,
    proxyH1 = weekly$ILI * weekly$ppH1,
    proxyH3 = weekly$ILI * weekly$ppH3,
    proxyB = weekly$ILI * weekly$ppB,
    yearweek = weekly$yearweek))


# Calculate influenza-attributable estimates by season, until 2016-17:
attr1 &lt;- attrMort(m, par=c("H1","H3","B"), sel="season", to=2016)
attr1

# Calculate influenza-attributable estimates by week, only point
#    estimates, for the 2014-15 season:
attr2 &lt;- attrMort(m, par=c("H1","H3","B"), sel="week",
    from=201440, to=201520, ci=FALSE)
attr2


# Calculate mortality attributable to temperatures below 5 celsius, for
#    the period of January 2017:
attr3 &lt;- attrMort(m, par="temp",
    sel=with(m$data, which(dates&gt;="2017-1-1" &amp; dates&lt;="2017-1-31")),
    temprange=c(5,-20))


# Calculate attributable mortalities for the entire 2017-18 season, and
#    return the Monte Carlo simulation samples in the output
attr4 &lt;- attrMort(m, sel="season", from=2017, to=2017, mcsamples=TRUE)


</code></pre>

<hr>
<h2 id='blup.FluMoDL'>Get or set BLUP coefficients for a FluMoDL object</h2><span id='topic+blup.FluMoDL'></span><span id='topic+blup+3C-'></span><span id='topic+blup+3C-.FluMoDL'></span>

<h3>Description</h3>

<p>This retrieves or sets the BLUP coefficients for a particular
<a href="#topic+fitFluMoDL">FluMoDL</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FluMoDL'
blup(object, ...)

blup(object) &lt;- value

## S3 replacement method for class 'FluMoDL'
blup(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blup.FluMoDL_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+fitFluMoDL">FluMoDL</a></code></p>
</td></tr>
<tr><td><code id="blup.FluMoDL_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="blup.FluMoDL_+3A_value">value</code></td>
<td>
<p>An object of class <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code>, holding BLUP estimates
to be assigned to <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>blup.FluMoDL</code>, the returned object of class
<code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> holding the BLUP coefficients associated
with the FluMoDL object.
</p>

<hr>
<h2 id='fitFluMoDL'>Fit a FluMoDL object</h2><span id='topic+fitFluMoDL'></span>

<h3>Description</h3>

<p>This function fits a FluMoDL object. This is a distributed lag nonlinear model (DLNM), of
quasipoisson family and with log link, which estimates the association between mortality
(as outcome) and daily mean temperatures and type-specific influenza incidence proxies
(as exposures), adjusted for covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitFluMoDL(deaths, temp, dates, proxyH1, proxyH3, proxyB, yearweek,
  proxyRSV = NULL, smooth = TRUE, periodic = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitFluMoDL_+3A_deaths">deaths</code></td>
<td>
<p>A vector of <em>daily</em> deaths, of equal length to argument <code>`dates`</code></p>
</td></tr>
<tr><td><code id="fitFluMoDL_+3A_temp">temp</code></td>
<td>
<p>A vector of <em>daily</em> mean temperatures, of equal length to argument <code>`dates`</code></p>
</td></tr>
<tr><td><code id="fitFluMoDL_+3A_dates">dates</code></td>
<td>
<p>A vector of dates (of class <code>Date</code>)</p>
</td></tr>
<tr><td><code id="fitFluMoDL_+3A_proxyh1">proxyH1</code></td>
<td>
<p>A vector of <em>weekly</em> influenza A(H1N1)pdm09 incidence proxies, of equal
length to argument <code>`yearweek`</code></p>
</td></tr>
<tr><td><code id="fitFluMoDL_+3A_proxyh3">proxyH3</code></td>
<td>
<p>A vector of <em>weekly</em> influenza A(H3N2) incidence proxies, of equal
length to argument <code>`yearweek`</code></p>
</td></tr>
<tr><td><code id="fitFluMoDL_+3A_proxyb">proxyB</code></td>
<td>
<p>A vector of <em>weekly</em> influenza B incidence proxies, of equal
length to argument <code>`yearweek`</code></p>
</td></tr>
<tr><td><code id="fitFluMoDL_+3A_yearweek">yearweek</code></td>
<td>
<p>An integer vector of weeks, in <em>yyyyww</em> format</p>
</td></tr>
<tr><td><code id="fitFluMoDL_+3A_proxyrsv">proxyRSV</code></td>
<td>
<p>An <em>optional</em> vector of <em>weekly</em> RSV incidence proxies, of equal
length to argument <code>`yearweek`</code>. (This is an experimental feature, and this argument
might be removed in the future.)</p>
</td></tr>
<tr><td><code id="fitFluMoDL_+3A_smooth">smooth</code></td>
<td>
<p><code>TRUE</code> (the default) if smoothing is to be applied to the influenza
incidence proxies when converting them to a daily series.</p>
</td></tr>
<tr><td><code id="fitFluMoDL_+3A_periodic">periodic</code></td>
<td>
<p>Should a periodic B-spline term be included in the model? 
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class 'FluMoDL' contain the model, the associated data, estimates of the predicted
associations and other information.
These objects can be further used as input for function <code><a href="#topic+attrMort">attrMort</a></code>, to calculate
influenza-attributable and temperature-attributable mortalities for any period in the data
(and any temperature range). Methods <code>print()</code>, <code>coef()</code> and <code>vcov()</code> have
been defined for objects of class 'FluMoDL' (see below),
and also <code><a href="#topic+summary.FluMoDL">summary()</a></code>.
</p>
<p>FluMoDL uses a DLNM with the <em>daily</em> number of deaths as the outcome. Covariates
include the following:
</p>

<ul>
<li><p> A <code><a href="dlnm.html#topic+crossbasis">cross-basis matrix</a></code> for temperature. The exposure-response
relationship is modelled with a quadratic B-spline with internal knots placed at the
10th, 75th and 90th percentile of the temperatures distribution. The lag-response
relationship is modelled with a natural cubic spline with three internal knots
equidistant in the log scale.
</p>
</li>
<li><p> Three <code><a href="dlnm.html#topic+crossbasis">cross-basis matrices</a></code> for influenza incidence proxies for
each type/subtype: A(H1N1)pdm09, A(H3N2) and B. These normally are equal to a
sentinel Influenza-Like Illness (ILI) rate, times the laboratory swab samples Percentage
Positive (
implying an approximately constant case fatality ratio for each influenza type. The
lag-response relationship is specified as above (for temperature).
</p>
</li>
<li><p> A periodic B-spline term to model seasonality, with three equidistant internal
knots according to day of the year. Can optionally be suppressed by setting argument
<code>periodic</code> to <code>FALSE</code>.
</p>
</li>
<li><p> A linear trend, and a factor variable for day of the week.
</p>
</li>
<li> <p><em>Optionally</em>, a <code><a href="dlnm.html#topic+crossbasis">cross-basis matrix</a></code> for an RSV
incidence proxy, with specification identical to those for influenza. If given,
it will be included in the model and output, and it will be possible to calculate
mortality attributable to RSV with <code><a href="#topic+attrMort">attrMort</a></code>. This is an experimental feature;
it might be removed in the future.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class 'FluMoDL'. This is a list containing the following elements:
</p>

<dl>
<dt>$data</dt><dd><p>A <code>data.frame</code> with the data used to fit the model. Rows correspond to
days in argument <code>dates</code>. The columns are named: <code>yearweek</code>, <code>dates</code>,
<code>deaths</code>, <code>temp</code>, (for temperature), <code>proxyH1</code>, <code>proxyH3</code>, <code>proxyB</code>,
<code>t</code> (linear trend, with values <code>1:nrow(m$data)</code>), <code>doy</code> (day of year,
use to calculate the periodic B-spline term to model seasonality) and <code>dow</code> (day of
the week). Also column <code>proxyRSV</code> if the relevant argument is provided.</p>
</dd>
<dt>$model</dt><dd><p>The fitted model; an object of class <code>glm</code> and of 'quasipoisson' family
with log link.</p>
</dd>
<dt>$basis</dt><dd><p>A list with names 'temp', 'proxyH1', 'proxyH3' and 'proxyB' (and proxyRSV,
if provided in the function arguments), containing the
cross-basis matrices that are used as exposures in the model. See <code><a href="dlnm.html#topic+crossbasis">crossbasis</a></code>.</p>
</dd>
<dt>$MMP</dt><dd><p>The Minimum Mortality Point, i.e. the temperature where mortality is lowest.</p>
</dd>
<dt>$pred</dt><dd><p>A list with names 'temp', 'proxyH1', 'proxyH3' and 'proxyB' (and 'proxyRSV'
if provided in the function arguments), containing
predictions (in the form of <code><a href="dlnm.html#topic+crosspred">crosspred</a></code> objects) for each exposure.
These can be plotted in both the exposure-response and lag-response dimensions, see
<code><a href="dlnm.html#topic+crosspred">crosspred</a></code>, <code><a href="dlnm.html#topic+plot.crosspred">plot.crosspred</a></code> and the examples below.</p>
</dd>
<dt>$blup</dt><dd><p>This element is NULL when creating the object, but can receive a
<code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> object that contains Best Linear Unbiased Predictor
(BLUP) coefficients, to be used when estimating attributable mortality. Can be
retrieved or set with the <code><a href="#topic+blup.FluMoDL">blup.FluMoDL</a></code> method</p>
</dd>
</dl>

<p>Objects of class 'FluMoDL' have methods <code>print()</code>, <code>coef()</code> and <code>vcov()</code>.
<code>coef()</code> returns a list of numeric vectors, with names 'proxyH1', 'proxyH3'
and 'proxyB' (and 'proxyRSV' if provided in the function arguments), containing the model
coefficients for these cross-basis terms. Similarly <code>vcov()</code> returns a list
of variance-covariance matrices for the same terms.
</p>


<h3>References</h3>


<ul>
<li><p> Lytras T, Pantavou K, Mouratidou E, Tsiodras S. Mortality attributable to seasonal influenza
in Greece, 2013 to 2017: variation by type/subtype and age, and a possible harvesting effect.
<a href="https://www.eurosurveillance.org/content/10.2807/1560-7917.ES.2019.24.14.1800118">Euro Surveill.</a>
2019;24(14):pii=1800118 (<a href="https://www.ncbi.nlm.nih.gov/pubmed/30968823">PubMed</a>)
</p>
</li>
<li><p> Gasparrini A, Armstrong B, Kenward MG. Distributed lag non-linear models.
<a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/sim.3940">Stat Med</a> 2010;29(21):2224–34.
</p>
</li>
<li><p> Gasparrini A, et al. Mortality risk attributable to high and low ambient temperature:
a multicountry observational study.
<a href="https://www.thelancet.com/journals/lancet/article/PIIS0140-6736(14)62114-0/fulltext">Lancet</a>
2015 Jul 25;386(9991):369–75.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(greece) # Use example surveillance data from Greece
m &lt;- with(greece, fitFluMoDL(deaths = daily$deaths,
    temp = daily$temp, dates = daily$date,
    proxyH1 = weekly$ILI * weekly$ppH1,
    proxyH3 = weekly$ILI * weekly$ppH3,
    proxyB = weekly$ILI * weekly$ppB,
    yearweek = weekly$yearweek))
m

# Plot the association between A(H1N1)pdm09 activity and mortality
#   and the overall temperature-mortality association:
plot(m$pred$proxyH1, "overall")
plot(m$pred$temp, "overall")

# Add the Minimum Mortality Point to the plot:
abline(v=m$MMP)

# Check the lag-response dimension for the A(H1N1)pdm09 - mortality
#   association, for all proxy values, and for an indicative value of 30.
plot(m$pred$proxyH1) # Produces a 3D plot, see ?plot.crosspred
plot(m$pred$proxyH1, var=30)

# Have a look at the data associated with this FluMoDL:
str(m$data)
tail(m$data)

</code></pre>

<hr>
<h2 id='greece'>Greece mortality and influenza data</h2><span id='topic+greece'></span>

<h3>Description</h3>

<p>Surveillance data from Greece used to estimate influenza-attributable
mortality using FluMoDL, covering the period from May 2013 to October 2017.
Contains the following:</p>

<ul>
<li><p> A daily time series of (all-cause) deaths
</p>
</li>
<li><p> A time series of daily mean temperatures
</p>
</li>
<li><p> A weekly series of Influenza-Like Illness (ILI) rates, calculated via
sentinel surveillance
</p>
</li>
<li><p> Three weekly series of laboratory sample percentage positives by influenza
type and subtype: A(H1N1)pdm09, A(H3N2) and B. These can be multiplied with
the respective ILI rates, to create type-specific influenza incidence proxies
(see Goldstein et al.
<a href="https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.1001051">PLoS Med.</a>
2011;8(7):e1001051)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(greece)
</code></pre>


<h3>Format</h3>

<p>An list with two elements of class <code>`data.frame`</code>: 'greece$daily'
contains a <code>`data.frame`</code> with columns 'date' (of class <code>`Date`</code>),
'deaths' and 'temperature'. 'greece$weekly' contains a <code>`data.frame`</code>
with columns 'yearweek' (integer, in YYYYWW format), 'ILI' (ILI rate per
1000 patient consultations), 'ppH1', 'ppH3' and 'ppB' (percentage positives
for A(H1N1)pdm09, A(H3N2) and B respectively).</p>


<h3>Source</h3>

<p>Greek <a href="https://eody.gov.gr/en/">National Public Health
Organization</a> (formerly the Hellenic Centre for Disease Control and Prevention)
</p>


<h3>References</h3>

<p>Lytras T, Pantavou K, Mouratidou E, Tsiodras S. Mortality attributable to seasonal influenza
in Greece, 2013 to 2017: variation by type/subtype and age, and a possible harvesting effect.
<a href="https://www.eurosurveillance.org/content/10.2807/1560-7917.ES.2019.24.14.1800118">Euro Surveill.</a>
2019;24(14):pii=1800118 (<a href="https://www.ncbi.nlm.nih.gov/pubmed/30968823">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(greece)
str(greece$daily)
str(greece$weekly)
</code></pre>

<hr>
<h2 id='hasPeriodic'>Does object include a periodic B-spline term?</h2><span id='topic+hasPeriodic'></span>

<h3>Description</h3>

<p>This method checks whether a 'FluMoDL' object includes a
periodic B-spline term in its parametrization or not. 
By default FluMoDL objects are created with a periodic term, 
unless argument <code>periodic</code> in <code><a href="#topic+fitFluMoDL">fitFluMoDL</a></code> is set to <code>FALSE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasPeriodic(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hasPeriodic_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+fitFluMoDL">FluMoDL</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the model includes a periodic term, <code>FALSE</code> if it does not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(greece) # Use example surveillance data from Greece
m &lt;- with(greece, fitFluMoDL(deaths = daily$deaths,
    temp = daily$temp, dates = daily$date,
    proxyH1 = weekly$ILI * weekly$ppH1,
    proxyH3 = weekly$ILI * weekly$ppH3,
    proxyB = weekly$ILI * weekly$ppB,
    yearweek = weekly$yearweek))
hasPeriodic(m)   # Returns TRUE

</code></pre>

<hr>
<h2 id='hasRSV'>Does object have a term for RSV?</h2><span id='topic+hasRSV'></span>

<h3>Description</h3>

<p>This method checks whether a 'FluMoDL' or 'summary.FluMoDL' object contains a
<code><a href="dlnm.html#topic+crossbasis">cross-basis term</a></code> for RSV (Respiratory Syncytial Virus)
incidence proxy, or contains only terms for influenza incidence proxies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasRSV(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hasRSV_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+fitFluMoDL">FluMoDL</a></code> or
<code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the model contains a term for RSV, <code>FALSE</code> if it does not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(greece) # Use example surveillance data from Greece
m &lt;- with(greece, fitFluMoDL(deaths = daily$deaths,
    temp = daily$temp, dates = daily$date,
    proxyH1 = weekly$ILI * weekly$ppH1,
    proxyH3 = weekly$ILI * weekly$ppH3,
    proxyB = weekly$ILI * weekly$ppB,
    yearweek = weekly$yearweek))
hasRSV(m)   # Returns FALSE
hasRSV(summary(m))   # Also returns FALSE

</code></pre>

<hr>
<h2 id='isoweek'>Calculate the ISO week &amp; year for a Date</h2><span id='topic+isoweek'></span>

<h3>Description</h3>

<p>This function takes a vector of Date objects and calculates the week and year
according to ISO 8601. It is flexible in its output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isoweek(x, type = "both_num", sep = "-", inv = FALSE,
  colnames = c("isoyear", "isoweek"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isoweek_+3A_x">x</code></td>
<td>
<p>A vector of class <code><a href="base.html#topic+Date">Date</a></code> (of length &gt;=1)</p>
</td></tr>
<tr><td><code id="isoweek_+3A_type">type</code></td>
<td>
<p>A string (one of &quot;week&quot;, &quot;year&quot;, &quot;both_text&quot;, &quot;both_num&quot; or &quot;matrix&quot;)
that determines the kind of output the function returns. See &quot;Return value&quot;.</p>
</td></tr>
<tr><td><code id="isoweek_+3A_sep">sep</code></td>
<td>
<p>Seperator between year and week, applicable if <code>type="both_text"</code></p>
</td></tr>
<tr><td><code id="isoweek_+3A_inv">inv</code></td>
<td>
<p>If <code>type="both_text"</code>, and <code>inv=FALSE</code>, then year comes before
week. If <code>inv=TRUE</code>, week comes before year.</p>
</td></tr>
<tr><td><code id="isoweek_+3A_colnames">colnames</code></td>
<td>
<p>Names for the matrix columns if <code>type="matrix"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the week number according to ISO 8601. Note that
dates near the start or end of a given year may belong to the previous or next
year respectively, thus the year needs to be calculated too.
</p>


<h3>Value</h3>

<p>Different according to the function's <code>type</code> argument. If
<code>"both_num"</code> (the default), a vector of 6-digit integers is returned, in a
YYYYWW format. If <code>"week"</code> or <code>"year"</code>, only the week number or year is
returned, respectively. If <code>"both_text"</code>, then a character vector of the same
length as <code>x</code> is returned, containing both the year and week number, seperated
by <code>sep</code>, and inverted if <code>inv=TRUE</code>. Finally, if <code>type="matix"</code>, both
year and week numbers are returned in a two-column matrix, with the columns named as
in <code>colnames</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isoweek(Sys.Date())
isoweek("1980-8-19", "both_text", sep="/", inv=TRUE)
isoweek(c("2004-5-31", "2006-6-10", "2007-8-20"), "matrix")

</code></pre>

<hr>
<h2 id='isoweekStart'>Calculate the start date of a given ISO week</h2><span id='topic+isoweekStart'></span>

<h3>Description</h3>

<p>This function takes a vector of ISO week numbers (of the form YYYYWW) and returns a Date
vector with the first Monday of each week. It is essentially the inverse function of
<code><a href="#topic+isoweek">isoweek</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isoweekStart(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isoweekStart_+3A_x">x</code></td>
<td>
<p>A numeric vector of ISO week numbers (of format YYYYWW)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of class <code><a href="base.html#topic+Date">Date</a></code> and length equal to <code>x</code>, containing the
start date (first Monday) of each ISO week.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isoweekStart(201740) # Start of 2017-18 influenza surveillance
isoweekStart(isoweek(Sys.Date()))

</code></pre>

<hr>
<h2 id='linterp'>Linearly interpolate missing values in a numeric vector</h2><span id='topic+linterp'></span>

<h3>Description</h3>

<p>This value fills in missing values (<code>NA</code>s) in a numeric vector by
linear interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linterp(x, max_allow = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linterp_+3A_x">x</code></td>
<td>
<p>The numeric vector to interpolate. The first and last element must
not be <code>NA</code>, otherwise an error is generated.</p>
</td></tr>
<tr><td><code id="linterp_+3A_max_allow">max_allow</code></td>
<td>
<p>Maximum number of consecutive missing values to allow. If
there is any number of consecutive <code>NA</code> values in <code>x</code> longer than
<code>max_allow</code>, the function will fail with an error. Set to <code>NULL</code> to
fully disable this check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be handy when running <code><a href="#topic+fitFluMoDL">fitFluMoDL</a></code>, for
example to fill in small gaps in the temperatures vector.
But it can be more generally useful as well.
</p>


<h3>Value</h3>

<p>The numeric vector <code>x</code>, with any missing values replaced by
linear interpolants.
</p>

<hr>
<h2 id='metaFluMoDL'>Multivariate meta-analysis for FluMoDL objects</h2><span id='topic+metaFluMoDL'></span>

<h3>Description</h3>

<p>This function runs multivariate meta-analysis (using package <code><a href="mvmeta.html#topic+mvmeta">mvmeta</a></code>)
on the first-stage coefficients of influenza (and possibly RSV) incidence proxies
for multiple 'FluMoDL' object summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaFluMoDL(summaries, par = c("H1", "H3", "B", "RSV"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metaFluMoDL_+3A_summaries">summaries</code></td>
<td>
<p>A <em>list</em> of objects of class <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code>
(at least two), representing the first-stage analyses. If the list is named, the
names are kept in the output object and can be retrieved with <code>names()</code>, see below.</p>
</td></tr>
<tr><td><code id="metaFluMoDL_+3A_par">par</code></td>
<td>
<p>For which model terms (sets of coefficients) to run the meta-analysis?
Defaults to <code>c("H1","H3","B","RSV")</code>, which
indicates all three influenza proxies and RSV (for those summaries that have included
an RSV term). It is unlikely that you'll want to alter this default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class 'metaFluMoDL'. This is a list of objects of class
<code><a href="mvmeta.html#topic+mvmeta">mvmeta</a></code>, representing the results of the multivariate
random-effects meta-analysis for the sets of coefficients corresponding to each
term in argument <code>par</code>; they can be accessed directly using the <code>$</code>
operator as <code>$proxyH1</code>, <code>$proxyH3</code> and <code>$proxyB</code> (and also
<code>$proxyRSV</code> if there were RSV terms in at least two elements of
<code>summaries</code> and <code>par</code> included &quot;RSV&quot; &ndash; in which case,
<code><a href="#topic+hasRSV">hasRSV()</a></code> returns <code>TRUE</code> for objects of class 'metaFluMoDL').
</p>
<p><em>However</em>, some methods have been redefined for class 'metaFluMoDL', and do not
work the same as in simple lists. In particular: <code><a href="base.html#topic+length">length()</a></code>
returns the number of summaries (number of &quot;studies&quot;) meta-analyzed and
<code><a href="base.html#topic+names">names()</a></code> returns the names of these summaries (if the list
in <code>summaries</code> argument was named).
</p>
<p>In addition, the <code>[[</code> and <code>[</code> operators have been redefined for class
'metaFluMoDL', and now return the Best Linear Unbiased Predictor (BLUP)
estimates for the selected summaries (&quot;studies&quot;), as objects of class
<code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code>; selection can be made the usual way,
with a logical or numeric index vector, or with the summary names
(as provided by <code>names</code>). <code>[</code> returns a <em>list</em> of
<code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> objects, whereas <code>[[</code> returns a single object.
The returned objects contain the string &quot;blup&quot; in their <code>$type</code> element,
to distinguish them from <code><a href="#topic+summary.FluMoDL">first-stage model summaries</a></code>
or <code><a href="#topic+pooled">pooled</a></code>
result summaries. In their <code>$description</code> element, they contain the
name of the respective summary (&quot;study&quot;) if a named list had been provided
in the <code>summaries</code> argument of <code>metaFluMoDL()</code>. And finally, they contain
no <code>$pred</code> element, as they are not associated with a particular dataset and
cross-basis matrices (which is a prerequisite to create
<code><a href="dlnm.html#topic+crosspred">crosspred</a></code> objects).
</p>
<p>The pooled coefficients (for all three or four incidence proxies) can be obtained
with function <code><a href="#topic+pooled">pooled()</a></code>, which also returns an object of class
<code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> that you can further use.
</p>


<h3>References</h3>


<ul>
<li><p> Gasparrini A, Armstrong B, Kenward MG. Multivariate meta-analysis for non-linear
and other multi-parameter associations.
<a href="https://onlinelibrary.wiley.com/doi/full/10.1002/sim.5471">Stat Med</a> 2012;31(29):3821–39.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code>, <code><a href="#topic+pooled">pooled</a></code>
</p>

<hr>
<h2 id='NOAA_allStations'>Get list of weather stations from NOAA</h2><span id='topic+NOAA_allStations'></span><span id='topic+NOAA_countryStations'></span>

<h3>Description</h3>

<p>Download the list of all available weather stations from NOAA, or only those for
a specific country and period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOAA_allStations(force_retrieve = FALSE)

NOAA_countryStations(fips, from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NOAA_allStations_+3A_force_retrieve">force_retrieve</code></td>
<td>
<p>If <code>TRUE</code> download the list again from NOAA (even if
it was already downloaded previously). Defaults to <code>FALSE</code>, so that download
happens only once per session.</p>
</td></tr>
<tr><td><code id="NOAA_allStations_+3A_fips">fips</code></td>
<td>
<p>2-letter country FIPS ID (full list of codes at
<a href="ftp://ftp.ncdc.noaa.gov/pub/data/gsod/country-list.txt">ftp://ftp.ncdc.noaa.gov/pub/data/gsod/country-list.txt</a>).</p>
</td></tr>
<tr><td><code id="NOAA_allStations_+3A_from">from</code></td>
<td>
<p>Lower limit of reporting period (as class <code>Date</code>). Only retrieve
stations whose period of record ends at or after this date.</p>
</td></tr>
<tr><td><code id="NOAA_allStations_+3A_to">to</code></td>
<td>
<p>Upper limit of reporting period (as class <code>Date</code>). Only retrieve
stations whose period of record begins at or before this date.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NOAA_allStations()</code> downloads the list of all available weather
stations from NOAA, found in
<a href="ftp://ftp.ncdc.noaa.gov/pub/data/noaa/isd-history.csv">ftp://ftp.ncdc.noaa.gov/pub/data/noaa/isd-history.csv</a>, and returns it
as a <code>data.frame</code>. The data are downloaded only once per R session,
the first time this function is used, and are then stored internally for
further retrievals.
</p>
<p><code>NOAA_countryStations()</code> retrieves the list for a specific country only
(or several countries, if <code>length(ctry)&gt;1</code>), and possibly only for a specific
period of record.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following columns (copy-pasted from NOAA):
</p>

<dl>
<dt>usaf</dt><dd><p>Air Force station ID. May contain a letter in the first position.</p>
</dd>
<dt>wban</dt><dd><p>NCDC WBAN number</p>
</dd>
<dt>ctry</dt><dd><p>FIPS country ID</p>
</dd>
<dt>st</dt><dd><p>State for US stations</p>
</dd>
<dt>icao</dt><dd><p>ICAO ID</p>
</dd>
<dt>lat</dt><dd><p>Latitude in thousandths of decimal degrees</p>
</dd>
<dt>lon</dt><dd><p>Longitude in thousandths of decimal degrees</p>
</dd>
<dt>elev.m.</dt><dd><p>Elevation in meters</p>
</dd>
<dt>begin</dt><dd><p>Beginning Period Of Record. There may be reporting gaps within the P.O.R.</p>
</dd>
<dt>end</dt><dd><p>Ending Period Of Record. There may be reporting gaps within the P.O.R.</p>
</dd>
</dl>

<p>Note that columns <code>begin</code> and <code>end</code> in the output are of class <code>Date</code>.
</p>

<hr>
<h2 id='NOAA_getGSOD'>Get daily weather summaries from NOAA</h2><span id='topic+NOAA_getGSOD'></span>

<h3>Description</h3>

<p>Downloads the daily weather summaries for a set of weather stations
and a set of years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOAA_getGSOD(stations, years, match.columns = "station.name",
  progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NOAA_getGSOD_+3A_stations">stations</code></td>
<td>
<p>A <code>data.frame</code> with the stations for which data are to be
retrieved. It can be a subset of the <code>data.frame</code>s returned from
<code><a href="#topic+NOAA_allStations">NOAA_allStations</a></code> or <code><a href="#topic+NOAA_countryStations">NOAA_countryStations</a></code>.
At a minimum it should contain columns 'usaf' and 'wban'.</p>
</td></tr>
<tr><td><code id="NOAA_getGSOD_+3A_years">years</code></td>
<td>
<p>An integer vector of years (from 1901 to current year)
for which data are to be retrieved.</p>
</td></tr>
<tr><td><code id="NOAA_getGSOD_+3A_match.columns">match.columns</code></td>
<td>
<p><code>NULL</code> or (optionally) a vector of column names that
can be found in <code>stations</code>. If given, these are included in the output
after matching with the respective weather stations.</p>
</td></tr>
<tr><td><code id="NOAA_getGSOD_+3A_progress">progress</code></td>
<td>
<p>If <code>TRUE</code> (the default), a progress bar appears if more
than three files are to be downloaded from NOAA. Set to <code>FALSE</code> to suppress
the progress bar.
</p>
<p>For example, one can include a grouping variable in <code>stations</code> (such as
region code) and give its name in <code>match.columns</code> for it to be included in
the function output. This facilitates aggregating the output by the grouping variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following columns (adapted from NOAA):
</p>

<dl>
<dt>usaf</dt><dd><p>Air Force station ID</p>
</dd>
<dt>wban</dt><dd><p>NCDC WBAN number</p>
</dd>
<dt>date</dt><dd><p>Date (of class <code>Date</code></p>
</dd>
<dt>temp</dt><dd><p>Mean temperature for the day, in degrees Celsius to tenths.</p>
</dd>
<dt>tempC</dt><dd><p>Number of observations used in calculating mean temperature.</p>
</dd>
<dt>dewp</dt><dd><p>Dew point for the day, in degrees Celsius to tenths.</p>
</dd>
<dt>dewpC</dt><dd><p>Number of observations used in calculating mean dew point.</p>
</dd>
<dt>slp</dt><dd><p>Mean sea level pressure for the day,in millibars to tenths.</p>
</dd>
<dt>slpC</dt><dd><p>Number of observations used in calculating mean sea level pressure.</p>
</dd>
<dt>stp</dt><dd><p>Mean station pressure for the day in millibars to tenths.</p>
</dd>
<dt>stpC</dt><dd><p>Number of observations used in calculating mean station pressure.</p>
</dd>
<dt>visib</dt><dd><p>Mean visibility for the day in miles to tenths.</p>
</dd>
<dt>visibC</dt><dd><p>Number of observations used in calculating mean visibility.</p>
</dd>
<dt>wdsp</dt><dd><p>Mean wind speed for the day in knots to tenths.</p>
</dd>
<dt>wdspC</dt><dd><p>Number of observations used in calculating mean wind speed.</p>
</dd>
<dt>mxspd</dt><dd><p>Maximum sustained wind speed reported for the day, in knots to tenths.</p>
</dd>
<dt>gust</dt><dd><p>Maximum wind gust reported for the day, in knots to tenths.</p>
</dd>
<dt>maxtemp</dt><dd><p>Maximum temperature reported during the day,
in degrees Celsius to tenths. Time of max temp report varies
by country and region, so this will sometimes not be the max for the calendar day.</p>
</dd>
<dt>maxtempF</dt><dd><p>Blank indicates max temp was taken from the explicit max temp report
and not from the 'hourly' data. An asterisk (*) indicates max temp was derived from
the hourly data (i.e., highest hourly or synoptic-reported temperature).</p>
</dd>
<dt>mintemp</dt><dd><p>Minimum temperature reported during the day,
in degrees Celsius to tenths. Time of min temp report varies
by country and region, so this will sometimes not be the min for the calendar day.</p>
</dd>
<dt>mintempF</dt><dd><p>Blank indicates min temp was taken from the explicit min temp report
and not from the 'hourly' data. An asterisk (*) indicates min temp was derived from
the hourly data (i.e., lowest hourly or synoptic-reported temperature).</p>
</dd>
<dt>prcp</dt><dd><p>Total precipitation (rain and/or melted snow) reported during the day,
in inches and hundredths; will usually not end with the midnight observation,
i.e. may include latter part of previous day. Zero indicates no measurable
precipitation (includes a trace).
Note:  Many stations do not report '0' on days with no precipitation, therefore
<code>NA</code> will often appear on these days. Also, for example, a station may only
report a 6-hour amount for the period during which rain fell. See 'prcpF' field
for source of data.</p>
</dd>
<dt>prcpF</dt><dd><p>A = 1 report of 6-hour precipitation amount.
B = Summation of 2 reports of 6-hour precipitation amount.
C = Summation of 3 reports of 6-hour precipitation amount.
D = Summation of 4 reports of 6-hour precipitation amount.
E = 1 report of 12-hour precipitation amount.
F = Summation of 2 reports of 12-hour precipitation amount.
G = 1 report of 24-hour precipitation amount.
H = Station reported '0' as the amount for the day (eg, from 6-hour reports),
but also reported at least one occurrence of precipitation in hourly observations;
this could indicate a trace occurred, but should be considered as incomplete data
for the day.
I = Station did not report any precip data for the day and did not report
any occurrences of precipitation in its hourly observations; it's still possible
that precip occurred but was not reported.</p>
</dd>
<dt>sndp</dt><dd><p>Snow depth in inches to tenths&ndash;last report for the day
if reported more than once. Note:  Most stations do not report '0' on days with
no snow on the ground&ndash;therefore, <code>NA</code> will often appear on these days.</p>
</dd>
<dt>frshtt</dt><dd><p>Indicators (1 = yes, 0 = no/not reported) for the occurrence during
the day of: Fog ('F' - 1st digit); Rain or Drizzle ('R' - 2nd digit); Snow or Ice
Pellets ('S' - 3rd digit); Hail ('H' - 4th digit); Thunder ('T' - 5th digit);
Tornado or Funnel Cloud ('T' - 6th digit).</p>
</dd>
</dl>

<p>Note that, compared to the original NOAA output (for details see
<a href="ftp://ftp.ncdc.noaa.gov/pub/data/gsod/readme.txt">ftp://ftp.ncdc.noaa.gov/pub/data/gsod/readme.txt</a>),
all temperatures are automatically converted to degrees Celsius (instead of Fahrenheit)
and all missing indicators are replaced with <code>NA</code>s.
</p>

<hr>
<h2 id='pbs'>Periodic B-Spline Basis for Polynomial Splines</h2><span id='topic+pbs'></span>

<h3>Description</h3>

<p>Generate the periodic B-spline basis matrix for a polynomial spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbs(x, df = NULL, knots = NULL, degree = 3, intercept = FALSE,
  Boundary.knots = range(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pbs_+3A_x">x</code></td>
<td>
<p>the predictor variable.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="pbs_+3A_df">df</code></td>
<td>
<p>degrees of freedom; one can specify 'df' rather than 'knots'; 'pbs()'
then chooses 'df - 1' knots at suitable quantiles of 'x' (which will ignore missing values).</p>
</td></tr>
<tr><td><code id="pbs_+3A_knots">knots</code></td>
<td>
<p>the _internal_ breakpoints that define the spline. The number of internal knots must be greater than or equal to degree polynomial regression. See also 'Boundary.knots'.</p>
</td></tr>
<tr><td><code id="pbs_+3A_degree">degree</code></td>
<td>
<p>degree of the piecewise polynomial-default is 3 for cubic splines.</p>
</td></tr>
<tr><td><code id="pbs_+3A_intercept">intercept</code></td>
<td>
<p>if 'TRUE', an intercept is included in the basis; default is 'FALSE'</p>
</td></tr>
<tr><td><code id="pbs_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to set the period of the perodic
B-spline basis(default the range of the data). If both 'knots' and 'Boundary.knots'
are supplied, the basis parameters do not depend on 'x'. Data CAN NOT be extended
beyond 'Boundary.knots'. Typical Bourday knots are start and end values of period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function and documentation is copied from the CRAN package
<a href="https://CRAN.R-project.org/package=pbs">pbs</a>
by Shuangcai Wang &lt;<a href="mailto:swang1@gmail.com">swang1@gmail.com</a>&gt;
</p>


<h3>Value</h3>

<p>A matrix of dimension 'length(x) * (df)', where either 'df' was supplied or if
'knots' were supplied, 'df = length(knots) + intercept'. Attributes are returned that
correspond to the arguments to 'pbs', and explicitly give the 'knots', 'Boundary.knots'
etc for use by 'predict.pbs()'.
</p>
<p>pbs()' is based on the function 'spline.des()' in package splines. It generates a
basis matrix for representing the family of piecewise polynomials with the specified
interior knots and degree, evaluated at the values of 'x'. A primary use is in modeling
formulas to directly specify a piecewise polynomial term in a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats); require(graphics); require(splines)
x = seq(1,628)/100
z = rep(seq(1, 314)/100, 2)

pbs(x, df = 5, Boundary.knots = c(0, 2*pi))
pbs(x, knots=c(pi/2, pi, pi*3/2), Boundary.knots = c(0, 2*pi))
#### example of one periodic functions
y= sin(x) + cos(2*x) +
rnorm(628, 0, 0.1) ## x has a period of 2*pi
## df method, need to use large enough df to get a better fit.
## May use max loglik to choose optimal df
summary( fm1 &lt;- lm(y ~ pbs(x, df = 10, Boundary.knots = c(0, 2*pi))) )
plot(x, y, xlab = "x", ylab = "sin(x)", pch="x", cex=.5)

lines(x, predict(fm1, data.frame(x=x, z=z)), col='blue')
lines(x, sin(x) + cos(2*x), col='red')

## knots methods, usually selected at turning points
summary( fm2 &lt;- lm(y ~ pbs(x, knots=c(pi/2, pi, pi*3/2),
          Boundary.knots = c(0, 2*pi)))
)
plot(x, y, xlab = "x", ylab = "sin(x)", pch="x", cex=.5)

lines(x, predict(fm2, data.frame(x=x, z=z)), col='blue')
lines(x, sin(x) + cos(2*x), col='red')

#### example of two periodic functions
x0 = seq(1,628, by=4)/100
z0 = seq(1, 314, by=3)/100
x = rep(x0, each=length(z0))
z = rep(z0, length(x0))
y = sin(x) + cos(2*z) +
   rnorm(length(x), 0, 0.1) ## x has a period of 2*pi and z of pi

summary( fm3 &lt;- lm(y ~ pbs(x, df = 5, Boundary.knots = c(0, 2*pi))+
                       pbs(z, df = 5, Boundary.knots = c(0, pi)))
)

plot(sin(x) + cos(2*3), predict(fm3, data.frame(x=x, z=3)))
summary(sin(x) + cos(2*3)- predict(fm3, data.frame(x=x, z=3)))
## End(Not run)

</code></pre>

<hr>
<h2 id='pooled'>Get pooled effect estimates from metaFluMoDL object</h2><span id='topic+pooled'></span>

<h3>Description</h3>

<p>This function returns the pooled effect estimates for all incidence proxy terms
(three for influenza, and optionally for RSV) from a <code><a href="#topic+metaFluMoDL">metaFluMoDL</a></code>
object. It returns a <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> object that can be
further used in analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooled(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pooled_+3A_m">m</code></td>
<td>
<p>An object of class <code><a href="#topic+metaFluMoDL">metaFluMoDL</a></code>, holding the results of a
random-effects multivariate meta-analysis of <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code>
first-stage model summaries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code>, holding the pooled
coefficients and variance-covariance matrices for the three influenza incidence
proxies (four if <code><a href="#topic+hasRSV">hasRSV(m)</a></code> is <code>TRUE</code>). The returned
object contains the string &quot;pooled&quot; in its <code>$type</code> element,
to distinguish it from <code><a href="#topic+summary.FluMoDL">first-stage model summaries</a></code>
or <code><a href="#topic+metaFluMoDL">BLUP summaries</a></code> (Best Linear Unbiased Predictor).
The returned <code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code> object also has no <code>$pred</code> element,
as it is not associated with a particular dataset and cross-basis matrices
(which is a prerequisite to create <code><a href="dlnm.html#topic+crosspred">crosspred</a></code> objects).
</p>


<h3>References</h3>


<ul>
<li><p> Gasparrini A, Armstrong B, Kenward MG. Multivariate meta-analysis for non-linear
and other multi-parameter associations.
<a href="https://onlinelibrary.wiley.com/doi/full/10.1002/sim.5471">Stat Med</a> 2012;31(29):3821–39.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+summary.FluMoDL">summary.FluMoDL</a></code>, <code><a href="#topic+metaFluMoDL">metaFluMoDL</a></code>
</p>

<hr>
<h2 id='predict.FluMoDL'>Predict method for FluMoDL objects</h2><span id='topic+predict.FluMoDL'></span>

<h3>Description</h3>

<p>Obtains predictions (predicted daily or weekly deaths) and optionally estimates
standard errors of those predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FluMoDL'
predict(object, temp = NULL, proxyH1 = NULL,
  proxyH3 = NULL, proxyB = NULL, proxyRSV = NULL, se.fit = FALSE,
  byWeek = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.FluMoDL_+3A_object">object</code></td>
<td>
<p>A FluMoDL object</p>
</td></tr>
<tr><td><code id="predict.FluMoDL_+3A_temp">temp</code></td>
<td>
<p>A vector of daily mean temperatures. See 'Details'.</p>
</td></tr>
<tr><td><code id="predict.FluMoDL_+3A_proxyh1">proxyH1</code></td>
<td>
<p>A vector of daily influenza A(H1N1)pdm09 incidence proxies. See 'Details'.</p>
</td></tr>
<tr><td><code id="predict.FluMoDL_+3A_proxyh3">proxyH3</code></td>
<td>
<p>A vector of daily influenza A(H3N2) incidence proxies. See 'Details'.</p>
</td></tr>
<tr><td><code id="predict.FluMoDL_+3A_proxyb">proxyB</code></td>
<td>
<p>A vector of daily influenza B incidence proxies. See 'Details'.</p>
</td></tr>
<tr><td><code id="predict.FluMoDL_+3A_proxyrsv">proxyRSV</code></td>
<td>
<p>An vector of daily RSV incidence proxies (used only if the FluMoDL
object includes an RSV term). See 'Details'.</p>
</td></tr>
<tr><td><code id="predict.FluMoDL_+3A_se.fit">se.fit</code></td>
<td>
<p>Logical switch indicating if standard errors are required.
Requires <code>byWeek=FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.FluMoDL_+3A_byweek">byWeek</code></td>
<td>
<p>If <code>TRUE</code>, aggregate fitted estimates by week. Has priority
over argument <code>se.fit</code>. If both <code>se.fit</code> and <code>byWeek</code> are
<code>TRUE</code>, <code>se.fit</code> is set to <code>FALSE</code> and a warning is returned.</p>
</td></tr>
<tr><td><code id="predict.FluMoDL_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments <code>temp</code>, <code>proxyH1</code>, <code>proxyH3</code>, <code>proxyB</code> and
(if <code>hasRSV(object)</code> is <code>TRUE</code>) <code>proxyRSV</code> take a numeric vector
as input, which is recycled to a length of <code>nrow(object$data)</code>. Alternatively
they can take <code>NULL</code>, in which case the respective column of <code>object$data</code>
is used as input. Argument <code>temp</code> can also take the string <code>"MMP"</code>, which
is interpreted as the &quot;Minimum Mortality Point&quot;, i.e. the temperature at which
mortality is lowest (found in <code>object$MMP</code>).
</p>
<p>In this way, the <code>predict()</code> method can be flexibly used to calculate the
predicted &quot;baseline&quot; mortality (by setting <code>temp="MMP"</code> and all incidence proxies
to zero), the model-predicted mortality for the actual input (by leaving all input
arguments to their default <code>NULL</code>), or predicted mortalities for any combination of
temperature and incidence proxy inputs.
</p>


<h3>Value</h3>

<p>A vector of daily predicted deaths (corresponding to the rows in
<code>object$data</code>). If <code>byWeek=TRUE</code>, the predictions are automatically
aggregated by week (as per <code>object$data$yearweek</code>) and the vector contains
the respective week (in YYYYWW format) as names.
</p>
<p>If <code>se.fit=TRUE</code>, a list
is returned with elements <code>$fit</code> and <code>$se.fit</code> containing the
(daily) predicted deaths and their associated log standard errors.
</p>
<p>Note that the first 30 elements (or first 5 elements if <code>byWeek=TRUE</code>) will be
<code>NA</code> by default, as FluMoDL uses a maximum lag of 30 days.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(greece) # Use example surveillance data from Greece
m &lt;- with(greece, fitFluMoDL(deaths = daily$deaths,
    temp = daily$temp, dates = daily$date,
    proxyH1 = weekly$ILI * weekly$ppH1,
    proxyH3 = weekly$ILI * weekly$ppH3,
    proxyB = weekly$ILI * weekly$ppB,
    yearweek = weekly$yearweek))
m

# Calculate FluMoDL baseline
baseline &lt;- predict(m, temp="MMP", proxyH1=0, proxyH3=0, proxyB=0, byWeek=TRUE)

# Calculate fitted predictions
fitted &lt;- predict(m, byWeek=TRUE)


# Plot everything
plot(with(m$data, tapply(deaths, yearweek, sum)), type="l",
     xaxt="n", ylab="Weekly deaths", xlab="Time")
points(baseline, type="l", col="blue")
points(fitted, type="l", col="green")
legend("topleft", c("Actual", "Baseline", "Fitted"), lty="solid",
    col=c("black", "blue", "green"), bty="n")


</code></pre>

<hr>
<h2 id='summary.FluMoDL'>Summary method for FluMoDL objects</h2><span id='topic+summary.FluMoDL'></span>

<h3>Description</h3>

<p>This function creates a summarized version of a 'FluMoDL' object. It contains
the sets of coefficients and variance-covariance matrices for the incidence
proxy terms (for influenza, and for RSV if provided), and the predictions for these terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FluMoDL'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.FluMoDL_+3A_object">object</code></td>
<td>
<p>An object of class 'FluMoDL'</p>
</td></tr>
<tr><td><code id="summary.FluMoDL_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These summaries can be used to run a <code><a href="#topic+metaFluMoDL">multivariate meta-analysis</a></code> and calculate
pooled effect estimates and BLUP (Best Unbiased Linear Predictor) estimates
for influenza (and RSV if provided).
</p>


<h3>Value</h3>

<p>An object of class 'summary.FluMoDL'. This is a list containing the following elements:
</p>

<dl>
<dt>$type</dt><dd><p>A string describing the meaning of the coefficients. Defaults to
&quot;summary&quot;, meaning a first-stage model summary. Alternatively, &quot;blup&quot; means
Best Unbiased Linear Predictor (BLUP) coefficients, and &quot;pooled&quot; refers to coefficients
pooled in the course of a multivariate meta-analysis. See <code><a href="#topic+metaFluMoDL">metaFluMoDL</a></code>.</p>
</dd>
<dt>$description</dt><dd><p>A string with an additional description. For objects created
with <code>summary.FluMoDL()</code> it is an empty string, but see <code><a href="#topic+metaFluMoDL">metaFluMoDL</a></code>.</p>
</dd>
<dt>$coef</dt><dd><p>A list of numeric vectors, with names 'proxyH1', 'proxyH3' and 'proxyB'
(and 'proxyRSV' if provided in the function arguments), containing the model
coefficients for these terms.</p>
</dd>
<dt>$vcov</dt><dd><p>A list of variance-covariance matrices, with names 'proxyH1', 'proxyH3'
and 'proxyB' (and 'proxyRSV' if provided in the function arguments), for the respective
model coefficients.</p>
</dd>
<dt>$pred</dt><dd><p>A list with names 'proxyH1', 'proxyH3' and 'proxyB' (and 'proxyRSV'
if provided in the function arguments), containing
predictions (in the form of <code><a href="dlnm.html#topic+crosspred">crosspred</a></code> objects) for each exposure.
These can be plotted in both the exposure-response and lag-response dimensions, see
<code><a href="dlnm.html#topic+crosspred">crosspred</a></code>, <code><a href="dlnm.html#topic+plot.crosspred">plot.crosspred</a></code> and the example below.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(greece) # Use example surveillance data from Greece
m &lt;- with(greece, fitFluMoDL(deaths = daily$deaths,
    temp = daily$temp, dates = daily$date,
    proxyH1 = weekly$ILI * weekly$ppH1,
    proxyH3 = weekly$ILI * weekly$ppH3,
    proxyB = weekly$ILI * weekly$ppB,
    yearweek = weekly$yearweek))
summ &lt;- summary(m)
summ

# Plot the association between A(H1N1)pdm09 activity and mortality:
plot(summ$pred$proxyH1, "overall")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
