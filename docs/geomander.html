<!DOCTYPE html><html lang="en-US"><head><title>Help for package geomander</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geomander}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geomander-package'><p>Geographic Tools for Studying Gerrymandering</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_edge'><p>Add Edges to an Adjacency List</p></a></li>
<li><a href='#adjacency'><p>Build Adjacency List</p></a></li>
<li><a href='#alarm_states'><p>List Available States from ALARM Data</p></a></li>
<li><a href='#baf_to_vtd'><p>Estimate Plans from a Block Assignment File to Voting Districts</p></a></li>
<li><a href='#block2prec'><p>Aggregate Block Table by Matches</p></a></li>
<li><a href='#block2prec_by_county'><p>Aggregate Block Table by Matches and County</p></a></li>
<li><a href='#check_contiguity'><p>Check Contiguity by Group</p></a></li>
<li><a href='#check_polygon_contiguity'><p>Check Polygon Contiguity</p></a></li>
<li><a href='#checkerboard'><p>Checkerboard</p></a></li>
<li><a href='#checkerboard_adj'><p>Checkerboard Adjacency</p></a></li>
<li><a href='#clean_vest'><p>Clean VEST Names</p></a></li>
<li><a href='#compare_adjacencies'><p>Compare Adjacency Lists</p></a></li>
<li><a href='#count_connections'><p>Count Times Precincts are Connected</p></a></li>
<li><a href='#create_block_table'><p>Create Block Level Data</p></a></li>
<li><a href='#create_tract_table'><p>Create Tract Level Data</p></a></li>
<li><a href='#dra2r'><p>DRA to R</p></a></li>
<li><a href='#estimate_down'><p>Estimate Down Levels</p></a></li>
<li><a href='#estimate_up'><p>Estimate Up Levels</p></a></li>
<li><a href='#geo_estimate_down'><p>Estimate Down Geography Levels</p></a></li>
<li><a href='#geo_estimate_up'><p>Estimate Up Geography Levels</p></a></li>
<li><a href='#geo_filter'><p>Filter to Intersecting Pieces</p></a></li>
<li><a href='#geo_match'><p>Match Across Geographic Layers</p></a></li>
<li><a href='#geo_plot'><p>Plots a Shape with Row Numbers as Text</p></a></li>
<li><a href='#geo_plot_group'><p>Create Plots of Shapes by Group with Connected Components Colored</p></a></li>
<li><a href='#geo_sort'><p>Sort Precincts</p></a></li>
<li><a href='#geo_trim'><p>Trim Away Small Pieces</p></a></li>
<li><a href='#geos_centerish'><p>Get the kind of center of each shape</p></a></li>
<li><a href='#geos_circle_center'><p>Get the centroid of the maximum inscribed circle</p></a></li>
<li><a href='#get_alarm'><p>Get ALARM Dataset</p></a></li>
<li><a href='#get_dra'><p>Get Dave's Redistricting App Dataset</p></a></li>
<li><a href='#get_heda'><p>Get Harvard Election Data Archive (&quot;HEDA&quot;) Dataset</p></a></li>
<li><a href='#get_lewis'><p>Get historical United States Congressional District Shapefiles</p></a></li>
<li><a href='#get_rpvnearme'><p>Get Racially Polarized Voting Dataset from RPV Near Me</p></a></li>
<li><a href='#get_vest'><p>Get Voting and Election Science Team (&quot;VEST&quot;) Dataset</p></a></li>
<li><a href='#global_gearys'><p>Compute Global Geary's C</p></a></li>
<li><a href='#global_morans'><p>Compute Global Moran's I</p></a></li>
<li><a href='#gstar_i'><p>Compute Standardized Getis Ord G*i</p></a></li>
<li><a href='#heda_doi'><p>Vest DOIs</p></a></li>
<li><a href='#heda_party'><p>HEDA Parties</p></a></li>
<li><a href='#heda_states'><p>List Available States from HEDA Dataverse</p></a></li>
<li><a href='#local_gearys'><p>Compute Local Geary's C</p></a></li>
<li><a href='#local_morans'><p>Compute Local Moran's I</p></a></li>
<li><a href='#nrcsd'><p>nrcsd</p></a></li>
<li><a href='#orange'><p>orange</p></a></li>
<li><a href='#precincts'><p>precincts</p></a></li>
<li><a href='#r2dra'><p>R to DRA</p></a></li>
<li><a href='#regionalize'><p>Estimate Regions by Geographic Features</p></a></li>
<li><a href='#rockland'><p>rockland</p></a></li>
<li><a href='#seam_adj'><p>Filter Adjacency to Edges Along Border</p></a></li>
<li><a href='#seam_geom'><p>Filter Shape to Geographies Along Border</p></a></li>
<li><a href='#seam_rip'><p>Remove Edges along a Boundary</p></a></li>
<li><a href='#seam_sew'><p>Suggest Edges to Connect Two Sides of a Border</p></a></li>
<li><a href='#split_precinct'><p>Split a Precinct</p></a></li>
<li><a href='#st_centerish'><p>Get the kind of center of each shape</p></a></li>
<li><a href='#st_circle_center'><p>Get the centroid of the maximum inscribed circle</p></a></li>
<li><a href='#subtract_edge'><p>Subtract Edges from an Adjacency List</p></a></li>
<li><a href='#suggest_component_connection'><p>Suggest Connections for Disconnected Groups</p></a></li>
<li><a href='#suggest_neighbors'><p>Suggest Neighbors for Lonely Precincts</p></a></li>
<li><a href='#towns'><p>towns</p></a></li>
<li><a href='#va_blocks'><p>va_blocks</p></a></li>
<li><a href='#va_vtd'><p>va_vtd</p></a></li>
<li><a href='#va18sub'><p>va18sub</p></a></li>
<li><a href='#vest_abb'><p>VEST Abbreviations</p></a></li>
<li><a href='#vest_doi'><p>VEST DOIs</p></a></li>
<li><a href='#vest_party'><p>VEST Parties</p></a></li>
<li><a href='#vest_states'><p>List Available States from VEST Dataverse</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geographic Tools for Studying Gerrymandering</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-15</td>
</tr>
<tr>
<td>Description:</td>
<td>A compilation of tools to complete common tasks for studying gerrymandering. 
    This focuses on the geographic tool side of common problems, such as linking 
    different levels of spatial units or estimating how to break up units. Functions 
    exist for creating redistricting-focused data for the US.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENCE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://christophertkenny.com/geomander/">https://christophertkenny.com/geomander/</a>,
<a href="https://github.com/christopherkenny/geomander">https://github.com/christopherkenny/geomander</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/christopherkenny/geomander/issues">https://github.com/christopherkenny/geomander/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.7)</td>
</tr>
<tr>
<td>Imports:</td>
<td>censable, cli, dataverse, dplyr, geos, ggplot2, magrittr,
readr, rlang, Rcpp, sf, stringr, tibble, tidyr, tinytiger</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>redist, knitr, rmarkdown, testthat (&ge; 3.0.0), RcppSimdJson,
spelling</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 20:40:33 UTC; chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher T. Kenny
    <a href="https://orcid.org/0000-0002-9386-6860"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Cory McCartan <a href="https://orcid.org/0000-0002-6251-669X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher T. Kenny &lt;christopherkenny@fas.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='geomander-package'>Geographic Tools for Studying Gerrymandering</h2><span id='topic+geomander-package'></span><span id='topic+geomander'></span>

<h3>Description</h3>

<p>A compilation of tools to complete common tasks for studying gerrymandering. 
    This focuses on the geographic tool side of common problems, such as linking 
    different levels of spatial units or estimating how to break up units. Functions 
    exist for creating redistricting-focused data for the US.</p>


<h3>Package Content</h3>


<p>Index of help topics:
</p>
<pre>
add_edge                Add Edges to an Adjacency List
adjacency               Build Adjacency List
alarm_states            List Available States from ALARM Data
baf_to_vtd              Estimate Plans from a Block Assignment File to
                        Voting Districts
block2prec              Aggregate Block Table by Matches
block2prec_by_county    Aggregate Block Table by Matches and County
check_contiguity        Check Contiguity by Group
check_polygon_contiguity
                        Check Polygon Contiguity
checkerboard            Checkerboard
checkerboard_adj        Checkerboard Adjacency
clean_vest              Clean VEST Names
compare_adjacencies     Compare Adjacency Lists
count_connections       Count Times Precincts are Connected
create_block_table      Create Block Level Data
create_tract_table      Create Tract Level Data
dra2r                   DRA to R
estimate_down           Estimate Down Levels
estimate_up             Estimate Up Levels
geo_estimate_down       Estimate Down Geography Levels
geo_estimate_up         Estimate Up Geography Levels
geo_filter              Filter to Intersecting Pieces
geo_match               Match Across Geographic Layers
geo_plot                Plots a Shape with Row Numbers as Text
geo_plot_group          Create Plots of Shapes by Group with Connected
                        Components Colored
geo_sort                Sort Precincts
geo_trim                Trim Away Small Pieces
geomander-package       Geographic Tools for Studying Gerrymandering
geos_centerish          Get the kind of center of each shape
geos_circle_center      Get the centroid of the maximum inscribed
                        circle
get_alarm               Get ALARM Dataset
get_dra                 Get Dave's Redistricting App Dataset
get_heda                Get Harvard Election Data Archive ("HEDA")
                        Dataset
get_lewis               Get historical United States Congressional
                        District Shapefiles
get_rpvnearme           Get Racially Polarized Voting Dataset from RPV
                        Near Me
get_vest                Get Voting and Election Science Team ("VEST")
                        Dataset
global_gearys           Compute Global Geary's C
global_morans           Compute Global Moran's I
gstar_i                 Compute Standardized Getis Ord G*i
heda_states             List Available States from HEDA Dataverse
local_gearys            Compute Local Geary's C
local_morans            Compute Local Moran's I
nrcsd                   nrcsd
orange                  orange
precincts               precincts
r2dra                   R to DRA
regionalize             Estimate Regions by Geographic Features
rockland                rockland
seam_adj                Filter Adjacency to Edges Along Border
seam_geom               Filter Shape to Geographies Along Border
seam_rip                Remove Edges along a Boundary
seam_sew                Suggest Edges to Connect Two Sides of a Border
split_precinct          Split a Precinct
st_centerish            Get the kind of center of each shape
st_circle_center        Get the centroid of the maximum inscribed
                        circle
subtract_edge           Subtract Edges from an Adjacency List
suggest_component_connection
                        Suggest Connections for Disconnected Groups
suggest_neighbors       Suggest Neighbors for Lonely Precincts
towns                   towns
va18sub                 va18sub
va_blocks               va_blocks
va_vtd                  va_vtd
vest_states             List Available States from VEST Dataverse
</pre>

<h3>Maintainer</h3>

<p>Christopher T. Kenny &lt;christopherkenny@fas.harvard.edu&gt;</p>


<h3>Author(s)</h3>

<p>Christopher T. Kenny [aut, cre]
    (&lt;https://orcid.org/0000-0002-9386-6860&gt;),
  Cory McCartan [ctb] (&lt;https://orcid.org/0000-0002-6251-669X&gt;)</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_edge'>Add Edges to an Adjacency List</h2><span id='topic+add_edge'></span>

<h3>Description</h3>

<p>Add Edges to an Adjacency List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_edge(adj, v1, v2, ids = NULL, zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_edge_+3A_adj">adj</code></td>
<td>
<p>list of adjacent precincts</p>
</td></tr>
<tr><td><code id="add_edge_+3A_v1">v1</code></td>
<td>
<p>vector of vertex identifiers for the first vertex. Can be an
integer index or a value to look up in <code>ids</code>, if that argument is provided.
If more than one identifier is present, connects each to corresponding
entry in v2.</p>
</td></tr>
<tr><td><code id="add_edge_+3A_v2">v2</code></td>
<td>
<p>vector of vertex identifiers for the second vertex. Can be an
integer index or a value to look up in <code>ids</code>, if that argument is provided.
If more than one identifier is present, connects each to corresponding
entry in v2.</p>
</td></tr>
<tr><td><code id="add_edge_+3A_ids">ids</code></td>
<td>
<p>A vector of identifiers which is used to look up the row indices
for the vertices.  If provided, the entries in <code>v1</code> and <code>v2</code> must match
exactly one entry in <code>ids</code>.</p>
</td></tr>
<tr><td><code id="add_edge_+3A_zero">zero</code></td>
<td>
<p>boolean, TRUE if the list is zero indexed. False if one indexed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adjacency list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(towns)
adj &lt;- adjacency(towns)

add_edge(adj, 2, 3)
add_edge(adj, "West Haverstraw", "Stony Point", towns$MUNI)
</code></pre>

<hr>
<h2 id='adjacency'>Build Adjacency List</h2><span id='topic+adjacency'></span>

<h3>Description</h3>

<p>This mimics redist's redist.adjacency using GEOS to create the patterns, rather than sf.
This is faster than that version, but forces projections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacency(shp, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjacency_+3A_shp">shp</code></td>
<td>
<p>sf dataframe</p>
</td></tr>
<tr><td><code id="adjacency_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with nrow(shp) entries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(precincts)
adj &lt;- adjacency(precincts)

</code></pre>

<hr>
<h2 id='alarm_states'>List Available States from ALARM Data</h2><span id='topic+alarm_states'></span>

<h3>Description</h3>

<p>List Available States from ALARM Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alarm_states()
</code></pre>


<h3>Value</h3>

<p>character abbreviations for states
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# relies on internet availability and interactivity on some systems
alarm_states()

## End(Not run)
</code></pre>

<hr>
<h2 id='baf_to_vtd'>Estimate Plans from a Block Assignment File to Voting Districts</h2><span id='topic+baf_to_vtd'></span>

<h3>Description</h3>

<p>District lines are often provided at the census block level, but analyses
often occur at the voting district level. This provides a simple way to
estimate the block level to the voting district level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baf_to_vtd(baf, plan_name, GEOID = "GEOID", year = 2020)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="baf_to_vtd_+3A_baf">baf</code></td>
<td>
<p>a tibble representing a block assignment file.</p>
</td></tr>
<tr><td><code id="baf_to_vtd_+3A_plan_name">plan_name</code></td>
<td>
<p>character. Name of column in <code>baf</code> which corresponds to the districts.</p>
</td></tr>
<tr><td><code id="baf_to_vtd_+3A_geoid">GEOID</code></td>
<td>
<p>character. Name of column which corresponds to each block's GEOID,
sometimes called &quot;BLOCKID&quot;. Default is <code>'GEOID'</code>.</p>
</td></tr>
<tr><td><code id="baf_to_vtd_+3A_year">year</code></td>
<td>
<p>the decade to request, either <code>2010</code> or <code>2020</code>. Default is <code>2020</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a voting district is split between blocks, this currently uses the most
common district.
</p>


<h3>Value</h3>

<p>a tibble with a vtd-level assignment file
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not guaranteed to reach download from redistrict2020.org
## Not run: 
# download and read baf ----
url &lt;- 'https://www.redistrict2020.org/files/DE-2021-01/DE_SLDU_bef.zip'
tf &lt;- tempfile('.zip')
utils::download.file(url, tf)
utils::unzip(tf, exdir = dirname(tf))
baf &lt;- readr::read_csv(
  file = paste0(dirname(tf), '/DE_SLDU_bef.csv'),
  col_types = 'ci'
)
names(baf) &lt;- c('GEOID', 'ssd_20')

# convert to vtd level ----
baf_to_vtd(baf = baf, plan_name = 'ssd_20', 'GEOID')

## End(Not run)

</code></pre>

<hr>
<h2 id='block2prec'>Aggregate Block Table by Matches</h2><span id='topic+block2prec'></span>

<h3>Description</h3>

<p>Aggregates block table values up to a higher level, normally precincts, hence
the name block2prec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block2prec(block_table, matches, geometry = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="block2prec_+3A_block_table">block_table</code></td>
<td>
<p>Required. Block table output from create_block_table</p>
</td></tr>
<tr><td><code id="block2prec_+3A_matches">matches</code></td>
<td>
<p>Required. Grouping variable to aggregate up by, typically made with geo_match</p>
</td></tr>
<tr><td><code id="block2prec_+3A_geometry">geometry</code></td>
<td>
<p>Boolean. Whether to keep geometry or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with length(unique(matches)) rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data(rockland)
rockland$id &lt;- sample(1:2, nrow(rockland), TRUE)
block2prec(rockland, rockland$id)

</code></pre>

<hr>
<h2 id='block2prec_by_county'>Aggregate Block Table by Matches and County</h2><span id='topic+block2prec_by_county'></span>

<h3>Description</h3>

<p>Performs the same type of operation as block2prec, but subsets a precinct geometry
based on a County fips column. This helps get around the problem that county geometries
often have borders that follow rivers and lead to funny shaped blocks. This guarantees
that every block is matched to a precinct which is in the same county.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block2prec_by_county(block_table, precinct, precinct_county_fips, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="block2prec_by_county_+3A_block_table">block_table</code></td>
<td>
<p>Required. Block table output from create_block_table</p>
</td></tr>
<tr><td><code id="block2prec_by_county_+3A_precinct">precinct</code></td>
<td>
<p>sf dataframe of shapefiles to match to.</p>
</td></tr>
<tr><td><code id="block2prec_by_county_+3A_precinct_county_fips">precinct_county_fips</code></td>
<td>
<p>Column within precincts</p>
</td></tr>
<tr><td><code id="block2prec_by_county_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with nrow(precinct) rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Need Census API
data(towns)
towns$fips &lt;- '087'
block &lt;- create_block_table('NY', 'Rockland')
block2prec_by_county(block, towns, 'fips')

## End(Not run)
</code></pre>

<hr>
<h2 id='check_contiguity'>Check Contiguity by Group</h2><span id='topic+check_contiguity'></span><span id='topic+cct'></span><span id='topic+ccm'></span>

<h3>Description</h3>

<p>Identify contiguous sets of units and numbers each set. Can be extended to repeat the procedure
within a subgeography.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_contiguity(adj, group)

cct(adj, group)

ccm(adj, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_contiguity_+3A_adj">adj</code></td>
<td>
<p>adjacency list</p>
</td></tr>
<tr><td><code id="check_contiguity_+3A_group">group</code></td>
<td>
<p>array of group identifiers. Typically district numbers or county names.
Defaults to 1 if no input is provided, checking that the adjacency list itself is
one connected component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a zero-indexed adjacency list and an array of group identifiers, this
returns a tibble which identifies the connected components. The three columns
are <code>group</code> for the inputted group, <code>group_number</code> which uniquely identifies each
group as a positive integer, and <code>component</code> which identifies the connected
component number for each corresponding entry of adjacency and group. If everything
is connected within the group, then each element of <code>component</code> will be <code>1</code>.
Otherwise, the largest component is given the value <code>1</code>, the next largest <code>2</code>,
and so on.
</p>
<p>If nothing is provided to group, it will default to a vector of ones, checking
if the adjacency graph is connected.
</p>
<p><code>cct()</code> is shorthand for creating a table of the component values. If everything
is connected within each group, it returns a value of 1. In general, it returns
a frequency table of components.
</p>
<p><code>ccm()</code> is shorthand for getting the maximum component value. It returns the
maximum number of  components that a group is broken into.
This returns 1 if each group is connected. #'
</p>


<h3>Value</h3>

<p>tibble with contiguity indicators. Each row is the units of <code>adj</code>. Columns include
</p>

<ul>
<li> <p><code>group</code> Values of the inputted <code>group</code> argument. If <code>group</code> is not specified, then all values
will be 1.
</p>
</li>
<li> <p><code>component</code> A number for each contiguous set of units within a <code>group</code>. If all units within a
<code>group</code> are contiguous, all values are 1. If there are two sets, each discontiguous with
the other, the larger one will be numbered 1 and the smaller one will be numbered as 2.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(checkerboard)
adj &lt;- adjacency(checkerboard)
# These each indicate the graph is connected.
check_contiguity(adj) # all contiguous
# If there are two discontiguous groups, there will be 2 values of `component`
cct(adj)
ccm(adj)

</code></pre>

<hr>
<h2 id='check_polygon_contiguity'>Check Polygon Contiguity</h2><span id='topic+check_polygon_contiguity'></span>

<h3>Description</h3>

<p>Cast <code>shp</code> to component polygons, build the adjacency, and check the contiguity.
Avoids issues where a precinct is actually a multipolygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_polygon_contiguity(shp, group, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_polygon_contiguity_+3A_shp">shp</code></td>
<td>
<p>An sf data frame</p>
</td></tr>
<tr><td><code id="check_polygon_contiguity_+3A_group">group</code></td>
<td>
<p>unquoted name of group identifier in shp.
Typically, this is district assignment. If you're looking for dis-contiguous precincts,
this should be a row number.</p>
</td></tr>
<tr><td><code id="check_polygon_contiguity_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with a column for each of inputted group, created group number, and the
identified connected component number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(checkerboard)
check_polygon_contiguity(checkerboard, i)
</code></pre>

<hr>
<h2 id='checkerboard'>Checkerboard</h2><span id='topic+checkerboard'></span>

<h3>Description</h3>

<p>This data set contains 64 squares in an 8x8 grid, like a checkerboard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("checkerboard")
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 64 observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('checkerboard')
</code></pre>

<hr>
<h2 id='checkerboard_adj'>Checkerboard Adjacency</h2><span id='topic+checkerboard_adj'></span>

<h3>Description</h3>

<p>This data contains a zero indexed adjacency list for the checkerboard dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("checkerboard_adj")
</code></pre>


<h3>Format</h3>

<p>A list with 64 entries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('checkerboard_adj')
</code></pre>

<hr>
<h2 id='clean_vest'>Clean VEST Names</h2><span id='topic+clean_vest'></span>

<h3>Description</h3>

<p>Clean VEST Names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_vest(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_vest_+3A_data">data</code></td>
<td>
<p>sf tibble from VEST</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with cleaned names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(va18sub)
va &lt;- clean_vest(va18sub)
</code></pre>

<hr>
<h2 id='compare_adjacencies'>Compare Adjacency Lists</h2><span id='topic+compare_adjacencies'></span>

<h3>Description</h3>

<p>Compare Adjacency Lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_adjacencies(adj1, adj2, shp, zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_adjacencies_+3A_adj1">adj1</code></td>
<td>
<p>Required. A first adjacency list.</p>
</td></tr>
<tr><td><code id="compare_adjacencies_+3A_adj2">adj2</code></td>
<td>
<p>Required. A second adjacency list.</p>
</td></tr>
<tr><td><code id="compare_adjacencies_+3A_shp">shp</code></td>
<td>
<p>shapefile to compare intersection types.</p>
</td></tr>
<tr><td><code id="compare_adjacencies_+3A_zero">zero</code></td>
<td>
<p>Boolean. Defaults to TRUE. Are adj1 and adj2 zero indexed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with row indices to compare, and optionally columns which describe the
DE-9IM relationship between differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(towns)
rook &lt;- adjacency(towns)
sf_rook &lt;- lapply(sf::st_relate(towns, pattern = 'F***1****'), function(x) {
  x - 1L
})
compare_adjacencies(rook, sf_rook, zero = FALSE)
</code></pre>

<hr>
<h2 id='count_connections'>Count Times Precincts are Connected</h2><span id='topic+count_connections'></span>

<h3>Description</h3>

<p>Count Times Precincts are Connected
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_connections(dm, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_connections_+3A_dm">dm</code></td>
<td>
<p>district membership matrix</p>
</td></tr>
<tr><td><code id="count_connections_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize all values by the number of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with the number of connections between precincts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
dm &lt;- matrix(sample(1:2, size = 100, TRUE), 10)
count_connections(dm)
</code></pre>

<hr>
<h2 id='create_block_table'>Create Block Level Data</h2><span id='topic+create_block_table'></span>

<h3>Description</h3>

<p>Creates a block level dataset, using the decennial census information, with the
standard redistricting variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_block_table(
  state,
  county = NULL,
  geometry = TRUE,
  year = 2020,
  mem = FALSE,
  epsg = 3857
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_block_table_+3A_state">state</code></td>
<td>
<p>Required. Two letter state postal code.</p>
</td></tr>
<tr><td><code id="create_block_table_+3A_county">county</code></td>
<td>
<p>Optional. Name of county.  If not provided, returns blocks for the entire state.</p>
</td></tr>
<tr><td><code id="create_block_table_+3A_geometry">geometry</code></td>
<td>
<p>Defaults to TRUE. Whether to return the geometry or not.</p>
</td></tr>
<tr><td><code id="create_block_table_+3A_year">year</code></td>
<td>
<p>year, must be 2000, 2010, or 2020</p>
</td></tr>
<tr><td><code id="create_block_table_+3A_mem">mem</code></td>
<td>
<p>Default is FALSE. Set TRUE to use memoized backend.</p>
</td></tr>
<tr><td><code id="create_block_table_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with data for each block in the selected region. Data includes
2 sets of columns for each race or ethnicity category: population (pop) and
voting age population (vap)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# uses the Census API
create_block_table(state = 'NY', county = 'Rockland', geometry = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='create_tract_table'>Create Tract Level Data</h2><span id='topic+create_tract_table'></span>

<h3>Description</h3>

<p>Create Tract Level Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_tract_table(
  state,
  county,
  geometry = TRUE,
  year = 2019,
  mem = FALSE,
  epsg = 3857
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_tract_table_+3A_state">state</code></td>
<td>
<p>Required. Two letter state postal code.</p>
</td></tr>
<tr><td><code id="create_tract_table_+3A_county">county</code></td>
<td>
<p>Optional. Name of county.  If not provided, returns tracts for the entire state.</p>
</td></tr>
<tr><td><code id="create_tract_table_+3A_geometry">geometry</code></td>
<td>
<p>Defaults to TRUE. Whether to return the geography or not.</p>
</td></tr>
<tr><td><code id="create_tract_table_+3A_year">year</code></td>
<td>
<p>year, must be &gt;= 2009 and &lt;= 2019.</p>
</td></tr>
<tr><td><code id="create_tract_table_+3A_mem">mem</code></td>
<td>
<p>Default is FALSE. Set TRUE to use memoized backend.</p>
</td></tr>
<tr><td><code id="create_tract_table_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with data for each tract in the selected region. Data includes
3 sets of columns for each race or ethnicity category: population (pop), voting age
population (vap), and citizen voting age population (cvap)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Relies on Census Bureau API
tract &lt;- create_tract_table('NY', 'Rockland', year = 2018)

## End(Not run)
</code></pre>

<hr>
<h2 id='dra2r'>DRA to R</h2><span id='topic+dra2r'></span>

<h3>Description</h3>

<p>Creates a block or precinct level dataset from DRA csv output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dra2r(dra, state, precincts, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dra2r_+3A_dra">dra</code></td>
<td>
<p>The path to an exported csv or
a dataframe with columns GEOID20 and District, loaded from a DRA export.</p>
</td></tr>
<tr><td><code id="dra2r_+3A_state">state</code></td>
<td>
<p>the state postal code of the state</p>
</td></tr>
<tr><td><code id="dra2r_+3A_precincts">precincts</code></td>
<td>
<p>an sf dataframe of precinct shapes to link the output to</p>
</td></tr>
<tr><td><code id="dra2r_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf dataframe either at the block level or precinct level
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Needs Census Bureau API
# dra_utah_test is available at https://bit.ly/3c6UDKk
blocklevel &lt;- dra2r('dra_utah_test.csv', state = 'UT')

## End(Not run)
</code></pre>

<hr>
<h2 id='estimate_down'>Estimate Down Levels</h2><span id='topic+estimate_down'></span>

<h3>Description</h3>

<p>Non-geographic partner function to geo_estimate_down. Allows users to estimate
down without the costly matching operation if they've already matched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_down(wts, value, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_down_+3A_wts">wts</code></td>
<td>
<p>numeric vector. Defaults to 1. Typically population or VAP, as a weight to give each precinct.</p>
</td></tr>
<tr><td><code id="estimate_down_+3A_value">value</code></td>
<td>
<p>numeric vector. Defaults to 1. Typically electoral outcomes, as a value to estimate down into blocks.</p>
</td></tr>
<tr><td><code id="estimate_down_+3A_group">group</code></td>
<td>
<p>matches of length(wts) that correspond to row indices of value. Often, this input is the output of geo_match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with each value split by weight
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
set.seed(1)
data(checkerboard)
counties &lt;- checkerboard %&gt;%
  group_by(id &lt;= 32) %&gt;%
  summarize(geometry = sf::st_union(geometry)) %&gt;%
  mutate(pop = c(100, 200))
matches &lt;- geo_match(checkerboard, counties)
estimate_down(wts = rep(1, nrow(checkerboard)), value = counties$pop, group = matches)
</code></pre>

<hr>
<h2 id='estimate_up'>Estimate Up Levels</h2><span id='topic+estimate_up'></span>

<h3>Description</h3>

<p>Non-geographic partner function to geo_estimate_up. Allows users to aggregate
up without the costly matching operation if they've already matched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_up(value, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_up_+3A_value">value</code></td>
<td>
<p>numeric vector. Defaults to 1. Typically population values.</p>
</td></tr>
<tr><td><code id="estimate_up_+3A_group">group</code></td>
<td>
<p>matches of length(value) that correspond to row indices of value.
Often, this input is the output of geo_match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with each value aggregated by group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
set.seed(1)
data(checkerboard)
counties &lt;- checkerboard %&gt;%
  group_by(id &lt;= 32) %&gt;%
  summarize(geometry = sf::st_union(geometry)) %&gt;%
  mutate(pop = c(100, 200))
matches &lt;- geo_match(checkerboard, counties)
estimate_up(value = checkerboard$i, group = matches)
</code></pre>

<hr>
<h2 id='geo_estimate_down'>Estimate Down Geography Levels</h2><span id='topic+geo_estimate_down'></span>

<h3>Description</h3>

<p>Simple method for estimating data down to a lower level. This is most often useful
for getting election data down from a precinct level to a block level in the case
that a state or other jurisdiction split precincts when creating districts. Geographic
partner to estimate_down.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_estimate_down(from, to, wts, value, method = "center", epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_estimate_down_+3A_from">from</code></td>
<td>
<p>Larger geography level</p>
</td></tr>
<tr><td><code id="geo_estimate_down_+3A_to">to</code></td>
<td>
<p>smaller geography level</p>
</td></tr>
<tr><td><code id="geo_estimate_down_+3A_wts">wts</code></td>
<td>
<p>numeric vector of length nrow(to). Defaults to 1. Typically population or VAP, as a weight to give each precinct.</p>
</td></tr>
<tr><td><code id="geo_estimate_down_+3A_value">value</code></td>
<td>
<p>numeric vector of length nrow(from). Defaults to 1. Typically electoral outcomes, as a value to estimate down into blocks.</p>
</td></tr>
<tr><td><code id="geo_estimate_down_+3A_method">method</code></td>
<td>
<p>string from center, centroid, point, or area for matching levels</p>
</td></tr>
<tr><td><code id="geo_estimate_down_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with each value split by weight
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
set.seed(1)
data(checkerboard)
counties &lt;- checkerboard %&gt;%
  group_by(id &lt;= 32) %&gt;%
  summarize(geometry = sf::st_union(geometry)) %&gt;%
  mutate(pop = c(100, 200))
geo_estimate_down(from = counties, to = checkerboard, value = counties$pop)
</code></pre>

<hr>
<h2 id='geo_estimate_up'>Estimate Up Geography Levels</h2><span id='topic+geo_estimate_up'></span>

<h3>Description</h3>

<p>Simple method for aggregating data up to a higher level This is most often useful
for getting population data from a block level up to a precinct level.
Geographic partner to estimate_up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_estimate_up(from, to, value, method = "center", epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_estimate_up_+3A_from">from</code></td>
<td>
<p>smaller geography level</p>
</td></tr>
<tr><td><code id="geo_estimate_up_+3A_to">to</code></td>
<td>
<p>larger geography level</p>
</td></tr>
<tr><td><code id="geo_estimate_up_+3A_value">value</code></td>
<td>
<p>numeric vector of length nrow(from). Defaults to 1.</p>
</td></tr>
<tr><td><code id="geo_estimate_up_+3A_method">method</code></td>
<td>
<p>string from center, centroid, point, or area for matching levels</p>
</td></tr>
<tr><td><code id="geo_estimate_up_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with each value aggregated by group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
set.seed(1)
data(checkerboard)
counties &lt;- checkerboard %&gt;%
  group_by(id &lt;= 32) %&gt;%
  summarize(geometry = sf::st_union(geometry)) %&gt;%
  mutate(pop = c(100, 200))
geo_estimate_up(from = checkerboard, to = counties, value = checkerboard$i)
</code></pre>

<hr>
<h2 id='geo_filter'>Filter to Intersecting Pieces</h2><span id='topic+geo_filter'></span>

<h3>Description</h3>

<p>Filter to Intersecting Pieces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_filter(from, to, bool = FALSE, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_filter_+3A_from">from</code></td>
<td>
<p>Required. sf dataframe. the geography to subset</p>
</td></tr>
<tr><td><code id="geo_filter_+3A_to">to</code></td>
<td>
<p>Required. sf dataframe. the geography that from must intersect</p>
</td></tr>
<tr><td><code id="geo_filter_+3A_bool">bool</code></td>
<td>
<p>Optional, defaults to FALSE. Should this just return a logical vector?</p>
</td></tr>
<tr><td><code id="geo_filter_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf data frame or logical vector if bool == TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Needs Census Bureau API
data(towns)
block &lt;- create_block_table('NY', 'Rockland')
geo_filter(block, towns)

## End(Not run)

data(towns)
data(rockland)
sub &lt;- geo_filter(rockland, towns)

</code></pre>

<hr>
<h2 id='geo_match'>Match Across Geographic Layers</h2><span id='topic+geo_match'></span>

<h3>Description</h3>

<p>Match Across Geographic Layers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_match(
  from,
  to,
  method = "center",
  by = NULL,
  tiebreaker = TRUE,
  epsg = 3857
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_match_+3A_from">from</code></td>
<td>
<p>smaller geographic level to match up from</p>
</td></tr>
<tr><td><code id="geo_match_+3A_to">to</code></td>
<td>
<p>larger geographic level to be matched to</p>
</td></tr>
<tr><td><code id="geo_match_+3A_method">method</code></td>
<td>
<p>string from 'center', 'centroid', 'point', 'circle', or 'area' for matching method</p>
</td></tr>
<tr><td><code id="geo_match_+3A_by">by</code></td>
<td>
<p>A character vector to match by. One element if both <code>from</code> and <code>to</code> share the subsetting column name.
One element with a name (for <code>from</code>) and one element (for <code>to</code>).</p>
</td></tr>
<tr><td><code id="geo_match_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>Should ties be broken? boolean. If FALSE, precincts with no
matches get value -1 and precincts with multiple matches get value -2.</p>
</td></tr>
<tr><td><code id="geo_match_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are as follows:
</p>

<ul>
<li><p> centroid: matches each element of <code>from</code> to the <code>to</code> entry that the geographic centroid intersects
</p>
</li>
<li><p> center: very similar to centroid, but it matches an arbitrary center point within <code>from</code>
if the centroid of <code>from</code> is outside the bounds of from. (This happens for non-convex shapes only).
</p>
</li>
<li><p> point: matches each element of <code>from</code> to the <code>to</code> entry that the &quot;point on surface&quot; intersects.
</p>
</li>
<li><p> circle: matches each element of <code>from</code> to the <code>to</code> entry that the centroid
of the maximum inscribed circle intersects
</p>
</li>
<li><p> area: matches each element of <code>from</code> to the <code>to</code> element which has the largest area overlap
</p>
</li></ul>



<h3>Value</h3>

<p>Integer Vector of matches length(to) with values in 1:nrow(from)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(checkerboard)
counties &lt;- sf::st_as_sf(as.data.frame(rbind(
  sf::st_union(checkerboard %&gt;% filter(i &lt; 4)),
  sf::st_union(checkerboard %&gt;% filter(i &gt;= 4))
)))

geo_match(from = checkerboard, to = counties)
geo_match(from = checkerboard, to = counties, method = 'area')
</code></pre>

<hr>
<h2 id='geo_plot'>Plots a Shape with Row Numbers as Text</h2><span id='topic+geo_plot'></span>

<h3>Description</h3>

<p>One liner to plot a shape with row numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_plot(shp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_plot_+3A_shp">shp</code></td>
<td>
<p>An sf shapefile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(checkerboard)
geo_plot(checkerboard)

</code></pre>

<hr>
<h2 id='geo_plot_group'>Create Plots of Shapes by Group with Connected Components Colored</h2><span id='topic+geo_plot_group'></span>

<h3>Description</h3>

<p>Create Plots of Shapes by Group with Connected Components Colored
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_plot_group(shp, adj, group, save = FALSE, path = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_plot_group_+3A_shp">shp</code></td>
<td>
<p>An sf shapefile</p>
</td></tr>
<tr><td><code id="geo_plot_group_+3A_adj">adj</code></td>
<td>
<p>adjacency list</p>
</td></tr>
<tr><td><code id="geo_plot_group_+3A_group">group</code></td>
<td>
<p>array of group identifiers. Typically district numbers or county names.</p>
</td></tr>
<tr><td><code id="geo_plot_group_+3A_save">save</code></td>
<td>
<p>Boolean, whether to save or not.</p>
</td></tr>
<tr><td><code id="geo_plot_group_+3A_path">path</code></td>
<td>
<p>Path to save, only used if save is TRUE. Defaults to working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of ggplots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data('checkerboard')
data('checkerboard_adj')

checkerboard &lt;- checkerboard %&gt;% mutate(discont = as.integer(j == 5 | j == 6))

p &lt;- geo_plot_group(checkerboard, checkerboard_adj, checkerboard$discont)

p[[1]]
p[[2]]
</code></pre>

<hr>
<h2 id='geo_sort'>Sort Precincts</h2><span id='topic+geo_sort'></span>

<h3>Description</h3>

<p>Reorders precincts by distance from the NW corner of the bounding box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_sort(shp, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_sort_+3A_shp">shp</code></td>
<td>
<p>sf dataframe, required.</p>
</td></tr>
<tr><td><code id="geo_sort_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(checkerboard)
geo_sort(checkerboard)
</code></pre>

<hr>
<h2 id='geo_trim'>Trim Away Small Pieces</h2><span id='topic+geo_trim'></span>

<h3>Description</h3>

<p>Trim Away Small Pieces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_trim(from, to, thresh = 0.01, bool = FALSE, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_trim_+3A_from">from</code></td>
<td>
<p>Required. sf dataframe. the geography to subset</p>
</td></tr>
<tr><td><code id="geo_trim_+3A_to">to</code></td>
<td>
<p>Required. sf dataframe. the geography that from must intersect</p>
</td></tr>
<tr><td><code id="geo_trim_+3A_thresh">thresh</code></td>
<td>
<p>Percent as decimal of an area to trim away. Default is .01, which is 1%.</p>
</td></tr>
<tr><td><code id="geo_trim_+3A_bool">bool</code></td>
<td>
<p>Optional, defaults to FALSE. Should this just return a logical vector?</p>
</td></tr>
<tr><td><code id="geo_trim_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf data frame or logical vector if bool=TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Needs Census Bureau API
data(towns)
block &lt;- create_block_table('NY', 'Rockland')
geo_trim(block, towns, thresh = 0.05)

## End(Not run)

data(towns)
data(rockland)
sub &lt;- geo_filter(rockland, towns)
rem &lt;- geo_trim(sub, towns, thresh = 0.05)

</code></pre>

<hr>
<h2 id='geos_centerish'>Get the kind of center of each shape</h2><span id='topic+geos_centerish'></span>

<h3>Description</h3>

<p>Returns points within the shape, near the center.
Uses the centroid if that's in the shape, or point on surface if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_centerish(shp, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geos_centerish_+3A_shp">shp</code></td>
<td>
<p>An sf dataframe</p>
</td></tr>
<tr><td><code id="geos_centerish_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A geos geometry list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(towns)
geos_centerish(towns)

</code></pre>

<hr>
<h2 id='geos_circle_center'>Get the centroid of the maximum inscribed circle</h2><span id='topic+geos_circle_center'></span>

<h3>Description</h3>

<p>Returns the centroid of the largest inscribed circle for each shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_circle_center(shp, tolerance = 0.01, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geos_circle_center_+3A_shp">shp</code></td>
<td>
<p>An sf dataframe</p>
</td></tr>
<tr><td><code id="geos_circle_center_+3A_tolerance">tolerance</code></td>
<td>
<p>positive numeric tolerance to simplify by. Default is 0.01.</p>
</td></tr>
<tr><td><code id="geos_circle_center_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A geos geometry list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(towns)
geos_circle_center(towns)

</code></pre>

<hr>
<h2 id='get_alarm'>Get ALARM Dataset</h2><span id='topic+get_alarm'></span>

<h3>Description</h3>

<p>Gets a dataset from the Algorithm-Assisted Redistricting Methodology Project.
The current supported data is the 2020 retabulations of the VEST data, which
can be downloaded with <code>get_vest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_alarm(state, year = 2020, geometry = TRUE, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_alarm_+3A_state">state</code></td>
<td>
<p>two letter state abbreviation</p>
</td></tr>
<tr><td><code id="get_alarm_+3A_year">year</code></td>
<td>
<p>year to get data for. Either <code>2020</code> or <code>2010</code></p>
</td></tr>
<tr><td><code id="get_alarm_+3A_geometry">geometry</code></td>
<td>
<p>Default is TRUE. Add geometry to the data?</p>
</td></tr>
<tr><td><code id="get_alarm_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the full available data at <a href="https://github.com/alarm-redist/census-2020">https://github.com/alarm-redist/census-2020</a>.
</p>


<h3>Value</h3>

<p>tibble with election data and optional geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ak &lt;- get_alarm('AK', geometry = FALSE)
</code></pre>

<hr>
<h2 id='get_dra'>Get Dave's Redistricting App Dataset</h2><span id='topic+get_dra'></span>

<h3>Description</h3>

<p>Gets a dataset from Dave's Redistricting App.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dra(state, year = 2020, geometry = TRUE, clean_names = TRUE, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dra_+3A_state">state</code></td>
<td>
<p>two letter state abbreviation</p>
</td></tr>
<tr><td><code id="get_dra_+3A_year">year</code></td>
<td>
<p>year to get data for. Either <code>2020</code> or <code>2010</code></p>
</td></tr>
<tr><td><code id="get_dra_+3A_geometry">geometry</code></td>
<td>
<p>Default is TRUE. Add geometry to the data?</p>
</td></tr>
<tr><td><code id="get_dra_+3A_clean_names">clean_names</code></td>
<td>
<p>Clean names. Default is <code>TRUE</code>. If <code>FALSE</code>,
returns default names.</p>
</td></tr>
<tr><td><code id="get_dra_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the full available data at <a href="https://github.com/dra2020/vtd_data">https://github.com/dra2020/vtd_data</a>.
</p>


<h3>Value</h3>

<p>tibble with election data and optional geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ak &lt;- get_dra('AK', geometry = FALSE)
</code></pre>

<hr>
<h2 id='get_heda'>Get Harvard Election Data Archive (&quot;HEDA&quot;) Dataset</h2><span id='topic+get_heda'></span>

<h3>Description</h3>

<p>Get Harvard Election Data Archive (&quot;HEDA&quot;) Dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_heda(state, path = tempdir(), epsg = 3857, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_heda_+3A_state">state</code></td>
<td>
<p>two letter state abbreviation</p>
</td></tr>
<tr><td><code id="get_heda_+3A_path">path</code></td>
<td>
<p>folder to put shape in. Default is <code>tempdir()</code></p>
</td></tr>
<tr><td><code id="get_heda_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
<tr><td><code id="get_heda_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="sf.html#topic+st_read">sf::read_sf()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
shp &lt;- get_heda('ND')

</code></pre>

<hr>
<h2 id='get_lewis'>Get historical United States Congressional District Shapefiles</h2><span id='topic+get_lewis'></span>

<h3>Description</h3>

<p>Data sourced from the United States Congressional District Shapefiles, primarily
hosted at <a href="https://cdmaps.polisci.ucla.edu/">https://cdmaps.polisci.ucla.edu/</a>. Files are fetched through the GitHub
repository at <a href="https://github.com/JeffreyBLewis/congressional-district-boundaries">https://github.com/JeffreyBLewis/congressional-district-boundaries</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lewis(state, congress)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_lewis_+3A_state">state</code></td>
<td>
<p>two letter state abbreviation</p>
</td></tr>
<tr><td><code id="get_lewis_+3A_congress">congress</code></td>
<td>
<p>congress number, from 1 to 114.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sf tibble of the congressional district boundaries
</p>


<h3>References</h3>

<p>Jeffrey B. Lewis, Brandon DeVine, Lincoln Pitcher, and Kenneth C. Martis. (2013)
Digital Boundary Definitions of United States Congressional Districts, 1789-2012.
[Data file and code book]. Retrieved from <a href="https://cdmaps.polisci.ucla.edu">https://cdmaps.polisci.ucla.edu</a> on [date of download].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_lewis(state = 'NM', congress = 111)
</code></pre>

<hr>
<h2 id='get_rpvnearme'>Get Racially Polarized Voting Dataset from RPV Near Me</h2><span id='topic+get_rpvnearme'></span>

<h3>Description</h3>

<p>Get Racially Polarized Voting Dataset from RPV Near Me
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rpvnearme(state, version = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_rpvnearme_+3A_state">state</code></td>
<td>
<p>the state postal code of the state</p>
</td></tr>
<tr><td><code id="get_rpvnearme_+3A_version">version</code></td>
<td>
<p>the version of the data to use. <code>1</code> for the original, <code>2</code> for the extended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble of precinct-level estimates of votes (party) by race
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_rpvnearme('DE')
</code></pre>

<hr>
<h2 id='get_vest'>Get Voting and Election Science Team (&quot;VEST&quot;) Dataset</h2><span id='topic+get_vest'></span>

<h3>Description</h3>

<p>Get Voting and Election Science Team (&quot;VEST&quot;) Dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_vest(state, year, path = tempdir(), clean_names = TRUE, epsg = 3857, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_vest_+3A_state">state</code></td>
<td>
<p>two letter state abbreviation</p>
</td></tr>
<tr><td><code id="get_vest_+3A_year">year</code></td>
<td>
<p>year any in 2016-2021</p>
</td></tr>
<tr><td><code id="get_vest_+3A_path">path</code></td>
<td>
<p>folder to put shape in. Default is <code>tempdir()</code></p>
</td></tr>
<tr><td><code id="get_vest_+3A_clean_names">clean_names</code></td>
<td>
<p>Clean names. Default is <code>TRUE</code>. If <code>FALSE</code>,
returns default names.</p>
</td></tr>
<tr><td><code id="get_vest_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
<tr><td><code id="get_vest_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="sf.html#topic+st_read">sf::read_sf()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Requires Dataverse API
shp &lt;- get_vest('CO', 2020)

## End(Not run)
</code></pre>

<hr>
<h2 id='global_gearys'>Compute Global Geary's C</h2><span id='topic+global_gearys'></span>

<h3>Description</h3>

<p>Computes the Global Geary's Contiguity statistic. Can produce spatial weights
from an adjacency or sf data frame, in which case the spatial_mat is a contiguity
matrix. Users can also provide a spatial_mat argument directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_gearys(shp, adj, wts, spatial_mat, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_gearys_+3A_shp">shp</code></td>
<td>
<p>sf data frame. Optional if adj or spatial_mat provided.</p>
</td></tr>
<tr><td><code id="global_gearys_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency list. Optional if shp or spatial_mat provided.</p>
</td></tr>
<tr><td><code id="global_gearys_+3A_wts">wts</code></td>
<td>
<p>Required. Numeric vector with weights to use for Moran's I.</p>
</td></tr>
<tr><td><code id="global_gearys_+3A_spatial_mat">spatial_mat</code></td>
<td>
<p>matrix of spatial weights. Optional if shp or adj provided.</p>
</td></tr>
<tr><td><code id="global_gearys_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data('checkerboard')
checkerboard &lt;- checkerboard %&gt;% mutate(m = as.numeric((id + i) %% 2 == 0))
global_gearys(shp = checkerboard, wts = checkerboard$m)
</code></pre>

<hr>
<h2 id='global_morans'>Compute Global Moran's I</h2><span id='topic+global_morans'></span>

<h3>Description</h3>

<p>Computes the Global Moran's I statistic and expectation. Can produce spatial weights
from an adjacency or sf data frame, in which case the spatial_mat is a contiguity
matrix. Users can also provide a spatial_mat argument directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_morans(shp, adj, wts, spatial_mat, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_morans_+3A_shp">shp</code></td>
<td>
<p>sf data frame. Optional if adj or spatial_mat provided.</p>
</td></tr>
<tr><td><code id="global_morans_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency list. Optional if shp or spatial_mat provided.</p>
</td></tr>
<tr><td><code id="global_morans_+3A_wts">wts</code></td>
<td>
<p>Required. Numeric vector with weights to use for Moran's I.</p>
</td></tr>
<tr><td><code id="global_morans_+3A_spatial_mat">spatial_mat</code></td>
<td>
<p>matrix of spatial weights. Optional if shp or adj provided.</p>
</td></tr>
<tr><td><code id="global_morans_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data('checkerboard')
checkerboard &lt;- checkerboard %&gt;% mutate(m = as.numeric((id + i) %% 2 == 0))
global_morans(shp = checkerboard, wts = checkerboard$m)
</code></pre>

<hr>
<h2 id='gstar_i'>Compute Standardized Getis Ord G*i</h2><span id='topic+gstar_i'></span>

<h3>Description</h3>

<p>Returns the Getis Ord G*i in standardized form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gstar_i(shp, adj, wts, spatial_mat, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gstar_i_+3A_shp">shp</code></td>
<td>
<p>sf data frame. Optional if adj or spatial_mat provided.</p>
</td></tr>
<tr><td><code id="gstar_i_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency list. Optional if shp or spatial_mat provided.</p>
</td></tr>
<tr><td><code id="gstar_i_+3A_wts">wts</code></td>
<td>
<p>Required. Numeric vector with weights to use for Moran's I.</p>
</td></tr>
<tr><td><code id="gstar_i_+3A_spatial_mat">spatial_mat</code></td>
<td>
<p>matrix of spatial weights. Optional if shp or adj provided.</p>
</td></tr>
<tr><td><code id="gstar_i_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of G*i scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data('checkerboard')
checkerboard &lt;- checkerboard %&gt;% mutate(m = as.numeric((id + i) %% 2 == 0))
gstar_i(shp = checkerboard, wts = checkerboard$m)
</code></pre>

<hr>
<h2 id='heda_doi'>Vest DOIs</h2><span id='topic+heda_doi'></span>

<h3>Description</h3>

<p>Vest DOIs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heda_doi()
</code></pre>

<hr>
<h2 id='heda_party'>HEDA Parties</h2><span id='topic+heda_party'></span>

<h3>Description</h3>

<p>HEDA Parties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heda_party(str)
</code></pre>

<hr>
<h2 id='heda_states'>List Available States from HEDA Dataverse</h2><span id='topic+heda_states'></span>

<h3>Description</h3>

<p>List Available States from HEDA Dataverse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heda_states()
</code></pre>


<h3>Value</h3>

<p>character abbreviations for states
</p>


<h3>Examples</h3>

<pre><code class='language-R'>heda_states()
</code></pre>

<hr>
<h2 id='local_gearys'>Compute Local Geary's C</h2><span id='topic+local_gearys'></span>

<h3>Description</h3>

<p>Compute Local Geary's C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_gearys(shp, adj, wts, spatial_mat, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_gearys_+3A_shp">shp</code></td>
<td>
<p>sf data frame. Optional if adj or spatial_mat provided.</p>
</td></tr>
<tr><td><code id="local_gearys_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency list. Optional if shp or spatial_mat provided.</p>
</td></tr>
<tr><td><code id="local_gearys_+3A_wts">wts</code></td>
<td>
<p>Required. Numeric vector with weights to use for Moran's I.</p>
</td></tr>
<tr><td><code id="local_gearys_+3A_spatial_mat">spatial_mat</code></td>
<td>
<p>matrix of spatial weights. Not required if shp or adj provided.</p>
</td></tr>
<tr><td><code id="local_gearys_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data('checkerboard')
checkerboard &lt;- checkerboard %&gt;% mutate(m = as.numeric((id + i) %% 2 == 0))
local_gearys(shp = checkerboard, wts = checkerboard$m)
</code></pre>

<hr>
<h2 id='local_morans'>Compute Local Moran's I</h2><span id='topic+local_morans'></span>

<h3>Description</h3>

<p>Compute Local Moran's I
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_morans(shp, adj, wts, spatial_mat, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_morans_+3A_shp">shp</code></td>
<td>
<p>sf data frame. Optional if adj or spatial_mat provided.</p>
</td></tr>
<tr><td><code id="local_morans_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency list. Optional if shp or spatial_mat provided.</p>
</td></tr>
<tr><td><code id="local_morans_+3A_wts">wts</code></td>
<td>
<p>Required. Numeric vector with weights to use for Moran's I.</p>
</td></tr>
<tr><td><code id="local_morans_+3A_spatial_mat">spatial_mat</code></td>
<td>
<p>matrix of spatial weights. Optional if shp or adj provided.</p>
</td></tr>
<tr><td><code id="local_morans_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data('checkerboard')
checkerboard &lt;- checkerboard %&gt;% mutate(m = as.numeric((id + i) %% 2 == 0))
local_morans(shp = checkerboard, wts = checkerboard$m)
</code></pre>

<hr>
<h2 id='nrcsd'>nrcsd</h2><span id='topic+nrcsd'></span>

<h3>Description</h3>

<p>The data contains the North Rockland Central School District.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('nrcsd')
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 1 observation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('nrcsd')
</code></pre>

<hr>
<h2 id='orange'>orange</h2><span id='topic+orange'></span>

<h3>Description</h3>

<p>This data contains the blocks for Orange County NY, with geographies simplified
to allow for better examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("orange")
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 10034 observations
</p>


<h3>Details</h3>

<p>It can be recreated with:
orange &lt;- create_block_table('NY', 'Orange')
orange &lt;- rmapshaper::ms_simplify(orange, keep_shapes = TRUE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('orange')
</code></pre>

<hr>
<h2 id='precincts'>precincts</h2><span id='topic+precincts'></span>

<h3>Description</h3>

<p>This data contains the election districts (or precincts) for Rockland County
NY, with geographies simplified to allow for better examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("precincts")
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 278 observations
</p>


<h3>References</h3>

<p>https://www.rocklandgis.com/portal/apps/sites/#/data/datasets/2d91f9db816c48318848ad66eb1a18e9
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('precincts')
</code></pre>

<hr>
<h2 id='r2dra'>R to DRA</h2><span id='topic+r2dra'></span>

<h3>Description</h3>

<p>Project a plan at the precinct level down to blocks into a format that can be used
with DRA. Projecting down to blocks can take a lot of time for larger states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2dra(precincts, plan, state, path, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r2dra_+3A_precincts">precincts</code></td>
<td>
<p>Required. an sf dataframe of precinct shapes</p>
</td></tr>
<tr><td><code id="r2dra_+3A_plan">plan</code></td>
<td>
<p>Required. Either a vector of district assignments
or the name of a column in precincts with district assignments.</p>
</td></tr>
<tr><td><code id="r2dra_+3A_state">state</code></td>
<td>
<p>Required. the state postal code of the state</p>
</td></tr>
<tr><td><code id="r2dra_+3A_path">path</code></td>
<td>
<p>Optional. A path to try to save to. Warns if saving failed.</p>
</td></tr>
<tr><td><code id="r2dra_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with columns Id, as used by DRA, identical to GEOID in census terms and District.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Needs Census Bureau API
cd &lt;- tinytiger::tt_congressional_districts() %&gt;% filter(STATEFP == '49')
cnty &lt;- tinytiger::tt_counties(state = 49)
matchedcty &lt;- geo_match(from = cnty, to = cd)
# use counties as precincts and let the plan be their center match:
r2dra(cnty, matchedcty, 'UT', 'r2dra_ex.csv')

## End(Not run)
</code></pre>

<hr>
<h2 id='regionalize'>Estimate Regions by Geographic Features</h2><span id='topic+regionalize'></span>

<h3>Description</h3>

<p>This offers a basic method for dividing a shape into separate pieces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regionalize(shp, lines, adj = adjacency(shp), epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regionalize_+3A_shp">shp</code></td>
<td>
<p><code>sf</code> tibble to estimate regions for</p>
</td></tr>
<tr><td><code id="regionalize_+3A_lines">lines</code></td>
<td>
<p><code>sf</code> tibble which divides <code>shp</code> into regions</p>
</td></tr>
<tr><td><code id="regionalize_+3A_adj">adj</code></td>
<td>
<p>adjacency graph</p>
</td></tr>
<tr><td><code id="regionalize_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of regions with <code>nrow(shp)</code> entries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(towns)
# make some weird roadlike feature passing through the towns
lines &lt;- sf::st_sfc(sf::st_linestring(sf::st_coordinates(sf::st_centroid(towns))),
  crs = sf::st_crs(towns)
)
regionalize(towns, lines)
</code></pre>

<hr>
<h2 id='rockland'>rockland</h2><span id='topic+rockland'></span>

<h3>Description</h3>

<p>This data contains the blocks for Rockland County NY, with geographies simplified
to allow for better examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("rockland")
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 4764 observations
</p>


<h3>Details</h3>

<p>It can be recreated with:
rockland &lt;- create_block_table('NY', 'Rockland')
rockland &lt;- rmapshaper::ms_simplify(rockland, keep_shapes = TRUE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('rockland')
</code></pre>

<hr>
<h2 id='seam_adj'>Filter Adjacency to Edges Along Border</h2><span id='topic+seam_adj'></span>

<h3>Description</h3>

<p>Filter Adjacency to Edges Along Border
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seam_adj(adj, shp, admin, seam, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seam_adj_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency graph</p>
</td></tr>
<tr><td><code id="seam_adj_+3A_shp">shp</code></td>
<td>
<p>tibble to subset and where admin column is found</p>
</td></tr>
<tr><td><code id="seam_adj_+3A_admin">admin</code></td>
<td>
<p>quoted name of administrative unit column</p>
</td></tr>
<tr><td><code id="seam_adj_+3A_seam">seam</code></td>
<td>
<p>administrative units to filter by</p>
</td></tr>
<tr><td><code id="seam_adj_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subset of adj
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('rockland')
data('orange')
data('nrcsd')

o_and_r &lt;- rbind(orange, rockland)
o_and_r &lt;- o_and_r %&gt;%
  geo_filter(nrcsd) %&gt;%
  geo_trim(nrcsd)
adj &lt;- adjacency(o_and_r)

seam_adj(adj, shp = o_and_r, admin = 'county', seam = c('071', '087'))

</code></pre>

<hr>
<h2 id='seam_geom'>Filter Shape to Geographies Along Border</h2><span id='topic+seam_geom'></span>

<h3>Description</h3>

<p>Filter Shape to Geographies Along Border
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seam_geom(adj, shp, admin, seam, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seam_geom_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency graph</p>
</td></tr>
<tr><td><code id="seam_geom_+3A_shp">shp</code></td>
<td>
<p>tibble to subset and where admin column is found</p>
</td></tr>
<tr><td><code id="seam_geom_+3A_admin">admin</code></td>
<td>
<p>quoted name of administrative unit column</p>
</td></tr>
<tr><td><code id="seam_geom_+3A_seam">seam</code></td>
<td>
<p>administrative units to filter by</p>
</td></tr>
<tr><td><code id="seam_geom_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subset of shp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('rockland')
data('orange')
data('nrcsd')

o_and_r &lt;- rbind(orange, rockland)
o_and_r &lt;- o_and_r %&gt;%
  geo_filter(nrcsd) %&gt;%
  geo_trim(nrcsd)
adj &lt;- adjacency(o_and_r)

seam_geom(adj, shp = o_and_r, admin = 'county', seam = c('071', '087'))

</code></pre>

<hr>
<h2 id='seam_rip'>Remove Edges along a Boundary</h2><span id='topic+seam_rip'></span>

<h3>Description</h3>

<p>Remove Edges along a Boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seam_rip(adj, shp, admin, seam, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seam_rip_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency graph</p>
</td></tr>
<tr><td><code id="seam_rip_+3A_shp">shp</code></td>
<td>
<p>tibble where admin column is found</p>
</td></tr>
<tr><td><code id="seam_rip_+3A_admin">admin</code></td>
<td>
<p>quoted name of administrative unit column</p>
</td></tr>
<tr><td><code id="seam_rip_+3A_seam">seam</code></td>
<td>
<p>units to rip the seam between by removing adjacency connections</p>
</td></tr>
<tr><td><code id="seam_rip_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adjacency list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('rockland')
data('orange')
data('nrcsd')

o_and_r &lt;- rbind(orange, rockland)
o_and_r &lt;- o_and_r %&gt;%
  geo_filter(nrcsd) %&gt;%
  geo_trim(nrcsd)
adj &lt;- adjacency(o_and_r)

seam_rip(adj, o_and_r, 'county', c('071', '087'))

</code></pre>

<hr>
<h2 id='seam_sew'>Suggest Edges to Connect Two Sides of a Border</h2><span id='topic+seam_sew'></span>

<h3>Description</h3>

<p>Suggest Edges to Connect Two Sides of a Border
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seam_sew(shp, admin, seam, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seam_sew_+3A_shp">shp</code></td>
<td>
<p>sf tibble where admin column is found</p>
</td></tr>
<tr><td><code id="seam_sew_+3A_admin">admin</code></td>
<td>
<p>quoted name of administrative unit column</p>
</td></tr>
<tr><td><code id="seam_sew_+3A_seam">seam</code></td>
<td>
<p>administrative units to filter by</p>
</td></tr>
<tr><td><code id="seam_sew_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble of edges connecting sides of a border
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('rockland')
data('orange')
data('nrcsd')

o_and_r &lt;- rbind(orange, rockland)
o_and_r &lt;- o_and_r %&gt;%
  geo_filter(nrcsd) %&gt;%
  geo_trim(nrcsd)
adj &lt;- adjacency(o_and_r)

adds &lt;- seam_sew(o_and_r, 'county', c('071', '087'))
adj &lt;- adj %&gt;% add_edge(adds$v1, adds$v2)

</code></pre>

<hr>
<h2 id='split_precinct'>Split a Precinct</h2><span id='topic+split_precinct'></span>

<h3>Description</h3>

<p>States often split a precinct when they create districts but rarely provide the
geography for the split precinct. This allows you to split a precinct using a
lower geography, typically blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_precinct(lower, precinct, split_by, lower_wt, split_by_id, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_precinct_+3A_lower">lower</code></td>
<td>
<p>The lower geography that makes up the precinct, this is often a
block level geography.</p>
</td></tr>
<tr><td><code id="split_precinct_+3A_precinct">precinct</code></td>
<td>
<p>The single precinct that you would like to split.</p>
</td></tr>
<tr><td><code id="split_precinct_+3A_split_by">split_by</code></td>
<td>
<p>The upper geography that you want to split precinct by</p>
</td></tr>
<tr><td><code id="split_precinct_+3A_lower_wt">lower_wt</code></td>
<td>
<p>Optional. Numeric weights to give to each precinct, typically
VAP or population.</p>
</td></tr>
<tr><td><code id="split_precinct_+3A_split_by_id">split_by_id</code></td>
<td>
<p>Optional. A string that names a column in split_by that
identifies each observation in split_by</p>
</td></tr>
<tr><td><code id="split_precinct_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf data frame with precinct split
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
data(checkerboard)
low &lt;- checkerboard %&gt;% dplyr::slice(1:3, 9:11)
prec &lt;- checkerboard %&gt;%
  dplyr::slice(1:3) %&gt;%
  dplyr::summarize(geometry = sf::st_union(geometry))
dists &lt;- checkerboard %&gt;%
  dplyr::slice(1:3, 9:11) %&gt;%
  dplyr::mutate(dist = c(1, 2, 2, 1, 3, 3)) %&gt;%
  dplyr::group_by(dist) %&gt;%
  dplyr::summarize(geometry = sf::st_union(geometry))

split_precinct(low, prec, dists, split_by_id = 'dist')
</code></pre>

<hr>
<h2 id='st_centerish'>Get the kind of center of each shape</h2><span id='topic+st_centerish'></span>

<h3>Description</h3>

<p>Returns points within the shape, near the center.
Uses the centroid if that's in the shape, or point on surface if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_centerish(shp, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_centerish_+3A_shp">shp</code></td>
<td>
<p>An sf dataframe</p>
</td></tr>
<tr><td><code id="st_centerish_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf dataframe where geometry is the center(ish) of each shape in shp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(towns)
st_centerish(towns)

</code></pre>

<hr>
<h2 id='st_circle_center'>Get the centroid of the maximum inscribed circle</h2><span id='topic+st_circle_center'></span>

<h3>Description</h3>

<p>Returns the centroid of the largest inscribed circle for each shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_circle_center(shp, tolerance = 0.01, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_circle_center_+3A_shp">shp</code></td>
<td>
<p>An sf dataframe</p>
</td></tr>
<tr><td><code id="st_circle_center_+3A_tolerance">tolerance</code></td>
<td>
<p>positive numeric tolerance to simplify by. Default is 0.01.</p>
</td></tr>
<tr><td><code id="st_circle_center_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf dataframe where geometry is the circle center of each shape in shp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(towns)
st_circle_center(towns)

</code></pre>

<hr>
<h2 id='subtract_edge'>Subtract Edges from an Adjacency List</h2><span id='topic+subtract_edge'></span>

<h3>Description</h3>

<p>Subtract Edges from an Adjacency List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtract_edge(adj, v1, v2, ids = NULL, zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subtract_edge_+3A_adj">adj</code></td>
<td>
<p>list of adjacent precincts</p>
</td></tr>
<tr><td><code id="subtract_edge_+3A_v1">v1</code></td>
<td>
<p>vector of vertex identifiers for the first vertex. Can be an
integer index or a value to look up in <code>ids</code>, if that argument is provided.
If more than one identifier is present, disconnects each to corresponding
entry in v2, if an edge exists.</p>
</td></tr>
<tr><td><code id="subtract_edge_+3A_v2">v2</code></td>
<td>
<p>vector of vertex identifiers for the second vertex. Can be an
integer index or a value to look up in <code>ids</code>, if that argument is provided.
If more than one identifier is present, disconnects each to corresponding
entry in v2, if an edge exists.</p>
</td></tr>
<tr><td><code id="subtract_edge_+3A_ids">ids</code></td>
<td>
<p>A vector of identifiers which is used to look up the row indices
for the vertices.  If provided, the entries in <code>v1</code> and <code>v2</code> must match
exactly one entry in <code>ids</code>.</p>
</td></tr>
<tr><td><code id="subtract_edge_+3A_zero">zero</code></td>
<td>
<p>boolean, TRUE if <code>adj</code> is zero indexed. False if one indexed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adjacency list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(towns)
adj &lt;- adjacency(towns)

subtract_edge(adj, 2, 3)
subtract_edge(adj, "West Haverstraw", "Stony Point", towns$MUNI)
</code></pre>

<hr>
<h2 id='suggest_component_connection'>Suggest Connections for Disconnected Groups</h2><span id='topic+suggest_component_connection'></span>

<h3>Description</h3>

<p>Suggests nearest neighbors for connecting a disconnected group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggest_component_connection(shp, adj, group, epsg = 3857)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="suggest_component_connection_+3A_shp">shp</code></td>
<td>
<p>An sf data frame</p>
</td></tr>
<tr><td><code id="suggest_component_connection_+3A_adj">adj</code></td>
<td>
<p>adjacency list</p>
</td></tr>
<tr><td><code id="suggest_component_connection_+3A_group">group</code></td>
<td>
<p>array of group identifiers. Typically district numbers or county names.
Defaults to rep(1, length(adj)) if missing.</p>
</td></tr>
<tr><td><code id="suggest_component_connection_+3A_epsg">epsg</code></td>
<td>
<p>numeric EPSG code to planarize to. Default is 3857.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with two columns of suggested rows of shp to connect in adj
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(checkerboard)
checkerboard &lt;- checkerboard %&gt;% filter(i != 1, j != 1)
adj &lt;- adjacency(checkerboard)
suggest_component_connection(checkerboard, adj)

</code></pre>

<hr>
<h2 id='suggest_neighbors'>Suggest Neighbors for Lonely Precincts</h2><span id='topic+suggest_neighbors'></span>

<h3>Description</h3>

<p>For precincts which have no adjacent precincts, this suggests the nearest precinct
as a friend to add. This is useful for when a small number of precincts are disconnected
from the remainder of the geography, such as an island.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggest_neighbors(shp, adj, idx, neighbors = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="suggest_neighbors_+3A_shp">shp</code></td>
<td>
<p>an sf shapefile</p>
</td></tr>
<tr><td><code id="suggest_neighbors_+3A_adj">adj</code></td>
<td>
<p>an adjacency list</p>
</td></tr>
<tr><td><code id="suggest_neighbors_+3A_idx">idx</code></td>
<td>
<p>Optional. Which indices to suggest neighbors for. If blank, suggests for those
with no neighbors.</p>
</td></tr>
<tr><td><code id="suggest_neighbors_+3A_neighbors">neighbors</code></td>
<td>
<p>number of neighbors to suggest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with two columns of suggested rows of shp to connect in adj
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(va18sub)
va18sub &lt;- va18sub %&gt;% filter(!VTDST %in% c('000516', '000510', '000505', '000518'))
adj &lt;- adjacency(va18sub)
suggests &lt;- suggest_neighbors(va18sub, adj)
adj &lt;- adj %&gt;% add_edge(v1 = suggests$x, v2 = suggests$y)

</code></pre>

<hr>
<h2 id='towns'>towns</h2><span id='topic+towns'></span>

<h3>Description</h3>

<p>This data contains 7 town boundaries for the towns which overlap
North Rockland School District in NY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("towns")
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 7 observations
</p>


<h3>References</h3>

<p>https://www.rocklandgis.com/portal/apps/sites/#/data/items/746ec7870a0b4f46b168e07369e79a27
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('towns')
</code></pre>

<hr>
<h2 id='va_blocks'>va_blocks</h2><span id='topic+va_blocks'></span>

<h3>Description</h3>

<p>This data contains the blocks Henrico County, VA with geographies simplified
to allow for better examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("va_blocks")
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 6354 observations
</p>


<h3>Details</h3>

<p>blocks87 &lt;- create_block_table(state = 'VA', county = '087')
va_blocks &lt;- rmapshaper::ms_simplify(va_blocks, keep_shapes = TRUE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('va_blocks')
</code></pre>

<hr>
<h2 id='va_vtd'>va_vtd</h2><span id='topic+va_vtd'></span>

<h3>Description</h3>

<p>This data contains the blocks for Henrico County, VA with geographies simplified
to allow for better examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("va_blocks")
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 93 observations
</p>


<h3>Details</h3>

<p>va_vtd &lt;- tinytiger::tt_voting_districts(state = 'VA', county = '087', year = 2010)
va_vtd &lt;- rmapshaper::ms_simplify(va_vtd, keep_shapes = TRUE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('va_blocks')
</code></pre>

<hr>
<h2 id='va18sub'>va18sub</h2><span id='topic+va18sub'></span>

<h3>Description</h3>

<p>This data contains a 90 precinct subset of Virginia from the 2018 Senate race.
Contains results for Henrico County
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("va18sub")
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 90 observations
</p>


<h3>References</h3>

<p>Voting and Election Science Team, 2019, &quot;va_2018.zip&quot;, 2
018 Precinct-Level Election Results,
https://doi.org/10.7910/DVN/UBKYRU/FQDLOO, Harvard Dataverse, V4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('va18sub')
</code></pre>

<hr>
<h2 id='vest_abb'>VEST Abbreviations</h2><span id='topic+vest_abb'></span>

<h3>Description</h3>

<p>VEST Abbreviations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vest_abb(x)
</code></pre>

<hr>
<h2 id='vest_doi'>VEST DOIs</h2><span id='topic+vest_doi'></span>

<h3>Description</h3>

<p>VEST DOIs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vest_doi()
</code></pre>

<hr>
<h2 id='vest_party'>VEST Parties</h2><span id='topic+vest_party'></span>

<h3>Description</h3>

<p>VEST Parties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vest_party(str)
</code></pre>

<hr>
<h2 id='vest_states'>List Available States from VEST Dataverse</h2><span id='topic+vest_states'></span>

<h3>Description</h3>

<p>List Available States from VEST Dataverse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vest_states(year)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vest_states_+3A_year">year</code></td>
<td>
<p>year in 2016, 2018, or 2020</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character abbreviations for states
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Requires Dataverse API
vest_states(2020)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
