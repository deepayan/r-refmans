<!DOCTYPE html><html><head><title>Help for package analyzer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {analyzer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anderson.test'><p>Anderson Darling test</p></a></li>
<li><a href='#association'><p>Find association between variables</p></a></li>
<li><a href='#CCassociation'><p>Association (Correlation) between Continuous (numeric) Variables</p></a></li>
<li><a href='#consoleBoxplot'><p>Boxplot on the console</p></a></li>
<li><a href='#CQassociation'><p>Association (Correlation) between Continuous-Categorical Variables</p></a></li>
<li><a href='#Cx'><p>Plots for Continuous independent variables</p></a></li>
<li><a href='#CxCy'><p>Plots for Continuous independent and dependent variables</p></a></li>
<li><a href='#explainer'><p>Generic explainer</p></a></li>
<li><a href='#explainer.character'><p>Explain method for character data types</p></a></li>
<li><a href='#explainer.data.frame'><p>Show details of the data frame</p></a></li>
<li><a href='#explainer.factor'><p>Explain method for factor data types</p></a></li>
<li><a href='#explainer.numeric'><p>Explain method for numeric data types</p></a></li>
<li><a href='#freqTable'><p>Frequency table and Histogram</p></a></li>
<li><a href='#GenerateReport'><p>Generate the report</p></a></li>
<li><a href='#kurtosis'><p>Kurtosis</p></a></li>
<li><a href='#linedivider'><p>Draws a horizontal line on console</p></a></li>
<li><a href='#mergeAnalyzer'><p>Analyze data for merging</p></a></li>
<li><a href='#norm_test_fun'><p>Checks for Normality Assumption</p></a></li>
<li><a href='#plot.analyzerPlot'><p>Plots a plot of class 'analyzerPlot'</p></a></li>
<li><a href='#plotNA'><p>Missing value visualization using ggplot2</p></a></li>
<li><a href='#plottr'><p>Creates plots for the variables in a data.frame</p></a></li>
<li><a href='#print.analyzerPlot'><p>Method for print generic</p></a></li>
<li><a href='#QQassociation'><p>Association (Correlation) between Categorical Variables</p></a></li>
<li><a href='#skewness'><p>Skewness</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Analysis and Automated R Notebook Generation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Apurv Priyam &lt;apurvpriyam@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Easy data analysis and quality checks which are commonly used in data science. It combines the tabular and graphical visualization for easier usability. This package also creates an R Notebook with detailed data exploration with one function call. The notebook can be made interactive.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, gridExtra, dplyr, grid</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>data.table, testthat, tidyr, reshape2, rmarkdown, MASS,
shiny, nnet, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-29 21:14:18 UTC; apurvpriyam</td>
</tr>
<tr>
<td>Author:</td>
<td>Apurv Priyam [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-30 09:20:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='anderson.test'>Anderson Darling test</h2><span id='topic+anderson.test'></span>

<h3>Description</h3>

<p><code>anderson.test</code> performs Anderson-Darling test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anderson.test(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anderson.test_+3A_x">x</code></td>
<td>
<p>a numeric vector. Length must be greater than 7.
Missing values are allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the Anderson-Darling test for  the composite hypothesis of normality,
see e.g. Thode (2002, Sec. 5.1.4).
</p>


<h3>Value</h3>

<p>A list with following elements:
</p>

<dl>
<dt>statistic</dt><dd><p>the value of Anderson-Darling test statistic</p>
</dd>
<dt>p.value</dt><dd><p>p-value of the test</p>
</dd>
<dt>method</dt><dd><p>Test name</p>
</dd>
<dt>data.name</dt><dd><p>Vector name</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+norm_test_fun">norm_test_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anderson.test(mtcars$mpg)

</code></pre>

<hr>
<h2 id='association'>Find association between variables</h2><span id='topic+association'></span>

<h3>Description</h3>

<p><code>association</code> finds association among all the variables in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>association(
  tb,
  categorical = NULL,
  method1 = c("auto", "pearson", "kendall", "spearman"),
  method3 = c("auto", "parametric", "non-parametric"),
  methodMats = NULL,
  use = "everything",
  normality_test_method = c("ks", "anderson", "shapiro"),
  normality_test_pval = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="association_+3A_tb">tb</code></td>
<td>
<p>tabular data</p>
</td></tr>
<tr><td><code id="association_+3A_categorical">categorical</code></td>
<td>
<p>a vector specifying the names of categorical (character,
factor) columns</p>
</td></tr>
<tr><td><code id="association_+3A_method1">method1</code></td>
<td>
<p>method for association between continuous-continuous
variables. values can be <code>"auto", "pearson",  "kendall", "spearman"</code>.
See details for more information.</p>
</td></tr>
<tr><td><code id="association_+3A_method3">method3</code></td>
<td>
<p>method for association between continuous-categorical
variables. Values can be <code>"auto", "parametric", "non-parametric"</code>.
See details of <code><a href="#topic+CQassociation">CQassociation</a></code> for more information.
Parametric does t-test while non-parametric
does 'Mann-Whitney’ test.</p>
</td></tr>
<tr><td><code id="association_+3A_methodmats">methodMats</code></td>
<td>
<p>This parameter can be used to define the methods for
calculating correlation and association at variables pair level. The input is
a square data.frame of dimension - number of columns in <code>tb</code>. The row
names and column names of <code>methodMats</code> are the column names of <code>tb</code>.
The values in the data.frame can be:
</p>

<dl>
<dt>between continuous-continuous variables</dt><dd><p>from parameter <code>method1</code>
- &quot;auto&quot;, &quot;pearson&quot;,  &quot;kendall&quot;, &quot;spearman&quot;</p>
</dd>
<dt>between continuous-categorical variables</dt><dd><p>from parameter
<code>method3</code> - &quot;auto&quot;, &quot;parametric&quot;, &quot;non-parametric&quot;</p>
</dd>
<dt>between categorical-categorical variables</dt><dd><p>can be anything</p>
</dd>
</dl>

<p>Default is NULL. In that case the method used for
calculating correlation and association will be the inputs from parameters.
</p>
<p>This parameter can also tale some other values. See example for more details.
But its advisable to use like mentioned above.</p>
</td></tr>
<tr><td><code id="association_+3A_use">use</code></td>
<td>
<p>an optional character string giving a method for computing
association in the presence of missing values. This must be (complete or an
abbreviation of) one of the strings &quot;everything&quot;, &quot;all.obs&quot;,
&quot;complete.obs&quot;, &quot;na.or.complete&quot;, or &quot;pairwise.complete.obs&quot;. If use is
&quot;everything&quot;, NAs will propagate conceptually, i.e., a resulting value will
be NA whenever one of its contributing observations is NA. If use is
&quot;all.obs&quot;, then the presence of missing observations will produce an error.
If use is &quot;complete.obs&quot; then missing values are handled by case wise
deletion (and if there are no complete cases, that gives an error).
&quot;na.or.complete&quot; is the same unless there are no complete cases, that gives
NA</p>
</td></tr>
<tr><td><code id="association_+3A_normality_test_method">normality_test_method</code></td>
<td>
<p>method for normality test for a variable.
Values can be <code>shapiro</code>
for Shapiro-Wilk test or
<code>'anderson'</code> for 'Anderson-Darling' test of normality or <code>ks</code> for
'Kolmogorov-Smirnov'</p>
</td></tr>
<tr><td><code id="association_+3A_normality_test_pval">normality_test_pval</code></td>
<td>
<p>significance level for normality tests. Default is 0.05</p>
</td></tr>
<tr><td><code id="association_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>cor</code>, <code>CCassociation</code>,
<code>CQassociation</code> and <code>QQassociation</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates association value in three categories -
</p>

<ul>
<li><p> between continuous variables (using <code>CCassociation</code> function)
</p>
</li>
<li><p> between categorical variables (using <code>QQassociation</code> function)
</p>
</li>
<li><p> between continuous and categorical variables (using <code>CQassociation</code>
function)
</p>
</li></ul>

<p>For more details, look at the individual documentation of
<code><a href="#topic+CCassociation">CCassociation</a></code>, <code><a href="#topic+QQassociation">QQassociation</a></code>,
<code><a href="#topic+CQassociation">CQassociation</a></code>
</p>


<h3>Value</h3>

<p>A list of three tables:
</p>

<dl>
<dt>continuous_corr</dt><dd><p>correlation among all the continuous variables</p>
</dd>
<dt>continuous_pvalue</dt><dd><p>Table containing p-value for the correlation test</p>
</dd>
<dt>categorical_cramers</dt><dd><p>Cramer's V value among all the categorical
variables</p>
</dd>
<dt>categorical_pvalue</dt><dd><p>Chi Sq test p-value</p>
</dd>
<dt>continuous_categorical</dt><dd><p>association value among continuous and
categorical variables</p>
</dd>
<dt>method_used</dt><dd><p>A data.frome showing the method used for all pairs
of variables</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+CCassociation">CCassociation</a></code> for Correlation between Continuous variables,
<code><a href="#topic+QQassociation">QQassociation</a></code> for Association between Categorical variables,
<code><a href="#topic+CQassociation">CQassociation</a></code> for Association between Continuous-Categorical
variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tb &lt;- mtcars
tb$cyl &lt;- as.factor(tb$cyl)
tb$vs  &lt;- as.factor(tb$vs)
out &lt;- association(tb, categorical = c("cyl", "vs"))

# To use the methodMats parameter, create a matrix like this
methodMats &lt;- out$method_used

# the values can be changed as per requirement
# NOTE: in addition to the values from parameters method1 and method3,
#       the values in methodMats can also be the values returned by
#       association function. But its advisable to use the options from
#       method1 and method3 arguements
methodMats["mpg", "disp"] &lt;- methodMats["disp", "mpg"] &lt;- "spearman"
out &lt;- association(tb, categorical = c("cyl", "vs"), methodMats = methodMats)
rm(tb)

</code></pre>

<hr>
<h2 id='CCassociation'>Association (Correlation) between Continuous (numeric) Variables</h2><span id='topic+CCassociation'></span>

<h3>Description</h3>

<p><code>CCassociation</code> finds correlation between all the variables in data
with only numeric columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCassociation(
  numtb,
  use = "everything",
  normality_test_method,
  normality_test_pval,
  method1 = c("auto", "pearson", "kendall", "spearman"),
  methodMat1 = NULL,
  methods_used
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCassociation_+3A_numtb">numtb</code></td>
<td>
<p>a data frame with all the numerical columns. This should
have at least two columns</p>
</td></tr>
<tr><td><code id="CCassociation_+3A_use">use</code></td>
<td>
<p>an optional character string giving a method for computing
association in the presence of missing values. This must be (complete or an
abbreviation of) one of the strings &quot;everything&quot;, &quot;all.obs&quot;,
&quot;complete.obs&quot;, &quot;na.or.complete&quot;, or &quot;pairwise.complete.obs&quot;. If use is
&quot;everything&quot;, NAs will propagate conceptually, i.e., a resulting value will
be NA whenever one of its contributing observations is NA. If use is
&quot;all.obs&quot;, then the presence of missing observations will produce an error.
If use is &quot;complete.obs&quot; then missing values are handled by case wise
deletion (and if there are no complete cases, that gives an error).
&quot;na.or.complete&quot; is the same unless there are no complete cases, that gives
NA</p>
</td></tr>
<tr><td><code id="CCassociation_+3A_normality_test_method">normality_test_method</code></td>
<td>
<p>method for normality test for a variable.
Values can be <code>shapiro</code>
for Shapiro-Wilk test or
<code>'anderson'</code> for 'Anderson-Darling' test of normality or <code>ks</code> for
'Kolmogorov-Smirnov'</p>
</td></tr>
<tr><td><code id="CCassociation_+3A_normality_test_pval">normality_test_pval</code></td>
<td>
<p>significance level for normality tests.
Default is 0.05</p>
</td></tr>
<tr><td><code id="CCassociation_+3A_method1">method1</code></td>
<td>
<p>method for association between continuous-continuous
variables. values can be <code>"auto", "pearson",  "kendall", "spearman"</code>.
See details for more information.</p>
</td></tr>
<tr><td><code id="CCassociation_+3A_methodmat1">methodMat1</code></td>
<td>
<p>method dataframe like methodMats from the function <code>
association</code></p>
</td></tr>
<tr><td><code id="CCassociation_+3A_methods_used">methods_used</code></td>
<td>
<p>a square data.frame which will store the type of
association used between the variables. Dimension will be
number of variables * number of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code>cor</code> function to calculate the correlation values.
The difference is that this doesn't take method as parameter, instead it
decides the methods itself using normality tests. If the variables satisfy
the assumption of Pearson correlation, then pearson correlation is calculated.
Otherwise Spearman is calculated. To learn more, check the
<code><a href="stats.html#topic+cor">cor</a></code>
</p>


<h3>Value</h3>

<p>a list of two tables with number of rows and column equal to number
of columns in <code>numtb</code>:
</p>

<dl>
<dt>r</dt><dd><p>Table containing correlation values</p>
</dd>
<dt>r_pvalue</dt><dd><p>Table containing p-value for the correlation test</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+association">association</a></code> for association between any type of variables,
<code><a href="#topic+QQassociation">QQassociation</a></code> for Association between Categorical variables,
<code><a href="#topic+CQassociation">CQassociation</a></code> for Association between Continuous-Categorical
variables
</p>

<hr>
<h2 id='consoleBoxplot'>Boxplot on the console</h2><span id='topic+consoleBoxplot'></span>

<h3>Description</h3>

<p><code>consoleBoxplot</code> prints the boxplot on console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consoleBoxplot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consoleBoxplot_+3A_x">x</code></td>
<td>
<p>a numeric vector of length at least 3</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is for the numeric vectors. It prints a boxplot in a single line
on the console. It automatically adjusts for the width of the console.
The input vector must have a length of three, otherwise the function
will throw a warning and not print any plot.
</p>
<p>In case of any potential outliers (based on 1.5*IQR criteria), this wil
give a warning.
This function is used in the <code>explainer</code>.
</p>


<h3>Value</h3>

<p>prints a boxplot on the console which has:
</p>

<ul>
<li> <p><code>|</code> at start and end means the minimum and maximum value respectively
</p>
</li>
<li> <p><code>&lt;==*==&gt;</code> The IQR region
</p>
</li>
<li> <p><code>*</code> shows the median
</p>
</li>
<li> <p><code>...</code> everything else in between
</p>
</li></ul>

<p>Gives a warning of potential outliers (if present)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>consoleBoxplot(mtcars$mpg)

</code></pre>

<hr>
<h2 id='CQassociation'>Association (Correlation) between Continuous-Categorical Variables</h2><span id='topic+CQassociation'></span>

<h3>Description</h3>

<p><code>CQassociation</code> finds Association measure between one
categorical and one continuous variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CQassociation(
  numtb,
  factb,
  method3 = c("auto", "parametric", "non-parametric"),
  use = "everything",
  normality_test_method = c("ks", "anderson", "shapiro"),
  normality_test_pval,
  methodMat3 = NULL,
  methods_used
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CQassociation_+3A_numtb">numtb</code></td>
<td>
<p>a data frame with all the numerical columns. This should
have at least two columns</p>
</td></tr>
<tr><td><code id="CQassociation_+3A_factb">factb</code></td>
<td>
<p>a data frame with all the categorical columns. This should
have atleast two columns</p>
</td></tr>
<tr><td><code id="CQassociation_+3A_method3">method3</code></td>
<td>
<p>method for association between continuous-categorical
variables. Values can be <code>"auto", "parametric", "non-parametric"</code>.
See details for more information. Parametric does t-test while
non-parametric does 'Mann-Whitney’ test.</p>
</td></tr>
<tr><td><code id="CQassociation_+3A_use">use</code></td>
<td>
<p>an optional character string giving a method for computing
association in the presence of missing values. This must be (complete or an
abbreviation of) one of the strings &quot;everything&quot;, &quot;all.obs&quot;,
&quot;complete.obs&quot;, &quot;na.or.complete&quot;, or &quot;pairwise.complete.obs&quot;. If use is
&quot;everything&quot;, NAs will propagate conceptually, i.e., a resulting value will
be NA whenever one of its contributing observations is NA. If use is
&quot;all.obs&quot;, then the presence of missing observations will produce an error.
If use is &quot;complete.obs&quot; then missing values are handled by case wise
deletion (and if there are no complete cases, that gives an error).
&quot;na.or.complete&quot; is the same unless there are no complete cases, that gives
NA</p>
</td></tr>
<tr><td><code id="CQassociation_+3A_normality_test_method">normality_test_method</code></td>
<td>
<p>takes values as 'shapiro' or 'anderson'.
this parameter decides which test to perform for the normality test.
See details of <code><a href="#topic+norm_test_fun">norm_test_fun</a></code> for more information.</p>
</td></tr>
<tr><td><code id="CQassociation_+3A_normality_test_pval">normality_test_pval</code></td>
<td>
<p>significance level for normality tests.
Default is 0.05</p>
</td></tr>
<tr><td><code id="CQassociation_+3A_methodmat3">methodMat3</code></td>
<td>
<p>method dataframe like methodMats from the function <code>
association</code></p>
</td></tr>
<tr><td><code id="CQassociation_+3A_methods_used">methods_used</code></td>
<td>
<p>a square data.frame which will store the type of
association used between the variables. Dimension will be
number of variables * number of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function measures the association between one categorical variable
and one continuous variable present in different dataset. Two datasets
are provided as input, one data has only numerical columns while other
data has only categorical columns. This performs either t-test for the
parametric case and 'Mann-Whitney’ test for the non-parametric case.
If the method3 is passed as 'auto', the function defines the method
itself based on different tests for equal variance and normality check
which checks for assumptions for the t-test. If the assumptions are
satisfied, then t-test (parametric) is performed, otherwise
'Mann-Whitney’ (non-parametric) test is performed.
</p>


<h3>Value</h3>

<p>a table with number of rows equal to number of columns in
<code>numtb</code> and number of columns equal to number of columns in
<code>factb</code>. Table containing p-values of performed test
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_test_fun">norm_test_fun</a></code> for normality test
<code><a href="#topic+association">association</a></code> for association between any type of variables,
<code><a href="#topic+CCassociation">CCassociation</a></code> for Association between Continuous (numeric)
variables,
<code><a href="#topic+QQassociation">QQassociation</a></code> for Association between Categorical variables
</p>

<hr>
<h2 id='Cx'>Plots for Continuous independent variables</h2><span id='topic+Cx'></span>

<h3>Description</h3>

<p>This function is used by [plottr()] when independent
variable is continuous. This function can be used as a template to
define a custom function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cx(dat, xname, binwidth = NULL, inc.density = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cx_+3A_dat">dat</code></td>
<td>
<p>a data.frame with only one column</p>
</td></tr>
<tr><td><code id="Cx_+3A_xname">xname</code></td>
<td>
<p>name of independent (x) variable in <code>dat</code></p>
</td></tr>
<tr><td><code id="Cx_+3A_binwidth">binwidth</code></td>
<td>
<p>for the histograms (extra parameters can be added like this)</p>
</td></tr>
<tr><td><code id="Cx_+3A_inc.density">inc.density</code></td>
<td>
<p>Binary. True to include the density plot on histogram</p>
</td></tr>
<tr><td><code id="Cx_+3A_...">...</code></td>
<td>
<p>required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grob of plot
</p>

<hr>
<h2 id='CxCy'>Plots for Continuous independent and dependent variables</h2><span id='topic+CxCy'></span>

<h3>Description</h3>

<p>This function is used by [plottr()] when both the dependent and independent
variables are continuous. This function can be used as a template to
define a custom function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CxCy(dat, xname, yname, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CxCy_+3A_dat">dat</code></td>
<td>
<p>a data.frame with two columns (including the dependent)</p>
</td></tr>
<tr><td><code id="CxCy_+3A_xname">xname</code></td>
<td>
<p>name of independent (x) variable in <code>dat</code></p>
</td></tr>
<tr><td><code id="CxCy_+3A_yname">yname</code></td>
<td>
<p>name of dependent (y) variable in <code>dat</code></p>
</td></tr>
<tr><td><code id="CxCy_+3A_...">...</code></td>
<td>
<p>required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grob of plot
</p>

<hr>
<h2 id='explainer'>Generic explainer</h2><span id='topic+explainer'></span>

<h3>Description</h3>

<p>Generic function for printing the details of data. Based on
the data type, this calls the appropriate method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explainer(X, xname = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explainer_+3A_x">X</code></td>
<td>
<p>a data.frame or a vector</p>
</td></tr>
<tr><td><code id="explainer_+3A_xname">xname</code></td>
<td>
<p>name of the data to be printed. If missing then the
name of variable passed as <code>X</code> will be used</p>
</td></tr>
<tr><td><code id="explainer_+3A_...">...</code></td>
<td>
<p>other parameters required for other methods of <code>explainer</code>
To see the parameters for numeric methods, use <code>?explainer.numeric</code> and
similarly for other methods (<code>?explainer.factor</code> etc.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current methods for <code>explainer</code> are for data.frame, numeric, integer,
character and factor vectors. To get the list of all available methods type
the command <code>methods(explainer)</code>.
</p>


<h3>Value</h3>

<p>Prints the information on the console. For print information for
the individual methods, see their documentation. Returns nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for numeric
explainer(mtcars)
explainer(mtcars$mpg) #same as explainer.numeric(mtcars$mpg)
# for factor
explainer(as.factor(mtcars$cyl)) #same as explainer.factor(as.factor(mtcars$cyl))

</code></pre>

<hr>
<h2 id='explainer.character'>Explain method for character data types</h2><span id='topic+explainer.character'></span>

<h3>Description</h3>

<p>This is a <code>explainer</code> method for character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'character'
explainer(X, xname = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explainer.character_+3A_x">X</code></td>
<td>
<p>a vector of character data type</p>
</td></tr>
<tr><td><code id="explainer.character_+3A_xname">xname</code></td>
<td>
<p>a placeholder for variable name</p>
</td></tr>
<tr><td><code id="explainer.character_+3A_...">...</code></td>
<td>
<p>other parameters required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method removes all the missing values in <code>x</code> before computing the
summaries.
</p>


<h3>Value</h3>

<p>Prints the following information on console:
</p>

<ul>
<li><p> vector name
</p>
</li>
<li><p> type
</p>
</li>
<li><p> number of distinct values
</p>
</li>
<li><p> number of missing values
</p>
</li>
<li><p> a frequency table and histogram. If counts of all the factor levels are
less than half of length of <code>X</code>, then the histogram is scaled with
maximum of 50
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>alphabets &lt;- sample(LETTERS[1:5], 50, replace = TRUE)
explainer(alphabets)
rm(alphabets)

</code></pre>

<hr>
<h2 id='explainer.data.frame'>Show details of the data frame</h2><span id='topic+explainer.data.frame'></span>

<h3>Description</h3>

<p><code>explainer</code> shows detail of all the columns of the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
explainer(X, xname = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explainer.data.frame_+3A_x">X</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="explainer.data.frame_+3A_xname">xname</code></td>
<td>
<p>variable name</p>
</td></tr>
<tr><td><code id="explainer.data.frame_+3A_...">...</code></td>
<td>
<p>parameters for explainer for other classes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code>explainer</code> on each column.
</p>


<h3>Value</h3>

<p>Prints details of the dataset which includes: dataset name,
type, number of columns, rows and unique rows. Also prints output of
<code>explainer</code> for all the columns. Returns nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explainer(mtcars)

</code></pre>

<hr>
<h2 id='explainer.factor'>Explain method for factor data types</h2><span id='topic+explainer.factor'></span>

<h3>Description</h3>

<p>This is a <code>explainer</code> method for factor vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factor'
explainer(X, xname = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explainer.factor_+3A_x">X</code></td>
<td>
<p>a numeric (or integer) data type</p>
</td></tr>
<tr><td><code id="explainer.factor_+3A_xname">xname</code></td>
<td>
<p>a placeholder for variable name</p>
</td></tr>
<tr><td><code id="explainer.factor_+3A_...">...</code></td>
<td>
<p>other parameters required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method removes all the missing values in <code>x</code> before computing the
summaries. This calls the method <code>explainer.character</code>
</p>


<h3>Value</h3>

<p>Prints the following information on console:
</p>

<ul>
<li><p> vector name
</p>
</li>
<li><p> type
</p>
</li>
<li><p> number of distinct values
</p>
</li>
<li><p> number of missing values
</p>
</li>
<li><p> a frequency table and histogram. If counts of all the factor levels are
less than half of length of <code>X</code>, then the histogram is scaled with
maximum of 50
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>alphabets &lt;- as.factor(sample(LETTERS[1:5], 50, replace = TRUE))
explainer(alphabets)
rm(alphabets)

</code></pre>

<hr>
<h2 id='explainer.numeric'>Explain method for numeric data types</h2><span id='topic+explainer.numeric'></span>

<h3>Description</h3>

<p>This is a <code>explainer</code> method for numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
explainer(
  X,
  xname = NULL,
  include.numeric = NULL,
  round.digit = 2,
  quant.seq = seq(0, 1, 0.2),
  trim = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explainer.numeric_+3A_x">X</code></td>
<td>
<p>a numeric (or integer) data type</p>
</td></tr>
<tr><td><code id="explainer.numeric_+3A_xname">xname</code></td>
<td>
<p>a placeholder for variable name</p>
</td></tr>
<tr><td><code id="explainer.numeric_+3A_include.numeric">include.numeric</code></td>
<td>
<p>a vector having strings which is also required along
with the default output. Can have values:
</p>

<ul>
<li> <p><code>trimmed.means</code> for printing the trimmed mean after removing
<code>trim</code> fraction of data from each side of x. <code>trim</code> can be passed
as an parameter
</p>
</li>
<li> <p><code>skewness</code> for printing the skewness of the data.
Use <code>?skreness</code> for more information
</p>
</li>
<li> <p><code>kurtosis</code> for printing
the kurtosis of the data. Use <code>?kurtosis</code> for more information
</p>
</li></ul>
</td></tr>
<tr><td><code id="explainer.numeric_+3A_round.digit">round.digit</code></td>
<td>
<p>number of decimal places required in the output.</p>
</td></tr>
<tr><td><code id="explainer.numeric_+3A_quant.seq">quant.seq</code></td>
<td>
<p>vector of fractions (0 to 1) for which the quantiles are
required <code>0.5</code> means median, <code>0</code> means smallest observation and
<code>1</code> means largest observation</p>
</td></tr>
<tr><td><code id="explainer.numeric_+3A_trim">trim</code></td>
<td>
<p>the fraction (0 to 0.5) of observations to be trimmed from each
end of x before the mean is computed. Values of trim outside that range are
taken as the nearest endpoint. This only works if <code>include.numeric</code> has
a string 'trimmed.means'</p>
</td></tr>
<tr><td><code id="explainer.numeric_+3A_...">...</code></td>
<td>
<p>other parameters required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method removes all the missing values in <code>x</code> before computing the
summaries.
</p>


<h3>Value</h3>

<p>Prints the following information on console:
</p>

<ul>
<li><p> vector name
</p>
</li>
<li><p> type
</p>
</li>
<li><p> number of distinct values
</p>
</li>
<li><p> number of missing values
</p>
</li>
<li><p> mean
</p>
</li>
<li><p> sd (standard deviation)
</p>
</li>
<li><p> median
</p>
</li>
<li><p> quantiles based on <code>quant.seq</code> parameter
</p>
</li>
<li><p> other information based on <code>include.numeric</code>
</p>
</li>
<li><p> a box plot (only if number distinct numbers are &gt; 2).
If counts of all the factor levels are less than half of length of
<code>x</code>, then the histogram is scaled with maximum of 50
<code>?consoleBoxplot</code> for how to read the table and histogram)
</p>
</li>
<li><p> a frequency table and histogram (only if number of distinct
numbers are &lt; 11)
(look at <code>?freqTable</code> for how to read the table and histogram)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>explainer(mtcars$mpg)
explainer(mtcars$mpg, include.numeric = c('trimmed.means', 'skewness',
'kurtosis'), round.digit = 1, quant.seq = seq(0,1,0.1), trim = 0.05)

</code></pre>

<hr>
<h2 id='freqTable'>Frequency table and Histogram</h2><span id='topic+freqTable'></span>

<h3>Description</h3>

<p><code>freqTable</code> prints a frequency table and histogram of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqTable(Value, limit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqTable_+3A_value">Value</code></td>
<td>
<p>a vector of any type</p>
</td></tr>
<tr><td><code id="freqTable_+3A_limit">limit</code></td>
<td>
<p>Upper limit of the bars in histogram. Default is NULL,
for which the function will automatically find the suitable limit.
This value should be in fraction (between 0 to 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works for all type of vector type. But calling <code>freqTable</code>
for vector with many unique values will print a very long table. If the
limit parameter is left blank, then the limit of
histogram is adjusted automatically and is shown at the end in brackets
(eg. 50
This function is used in the <code>explainer</code>.
</p>


<h3>Value</h3>

<p>Prints a table with columns </p>

<ul>
<li> <p><code>Value</code> Value. Each row has a unique value in this table
</p>
</li>
<li> <p><code>Freq</code> The frequency count of the Value
</p>
</li>
<li> <p><code>Proportion</code> Proportion of the Value <code>(= Freq / length(x))</code>
</p>
</li></ul>

<p>This table is followed by a histogram with bars for each of the unique
values present in the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freqTable(mtcars$cyl)
freqTable(mtcars$mpg, limit = 0.08)

</code></pre>

<hr>
<h2 id='GenerateReport'>Generate the report</h2><span id='topic+GenerateReport'></span>

<h3>Description</h3>

<p><code>GenerateReport</code> generates the markdown report in one command
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateReport(
  dtpath,
  catVars,
  yvar = NULL,
  model = "linReg",
  title = "Report",
  output_format = "html_document",
  output_dir = tempdir(),
  normality_test_method = "ks",
  interactive.plots = FALSE,
  include.vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateReport_+3A_dtpath">dtpath</code></td>
<td>
<p>dataset path as a string</p>
</td></tr>
<tr><td><code id="GenerateReport_+3A_catvars">catVars</code></td>
<td>
<p>vector of categorical variables names</p>
</td></tr>
<tr><td><code id="GenerateReport_+3A_yvar">yvar</code></td>
<td>
<p>y variable name if present else <code>NULL</code></p>
</td></tr>
<tr><td><code id="GenerateReport_+3A_model">model</code></td>
<td>
<p>type of model - <code>linReg</code> for linear regression
<code>binClass</code> for binary classification and <code>multiClass</code> for
multiclass classification</p>
</td></tr>
<tr><td><code id="GenerateReport_+3A_title">title</code></td>
<td>
<p>Title of the generated report</p>
</td></tr>
<tr><td><code id="GenerateReport_+3A_output_format">output_format</code></td>
<td>
<p>output report format. <code>'html_documennt'</code> for
html file or <code>pdf_document</code> for pdf file output. OR
<code>c("html_document", "pdf_document")</code> for both.</p>
</td></tr>
<tr><td><code id="GenerateReport_+3A_output_dir">output_dir</code></td>
<td>
<p>Directory where the output files needs to be stored.</p>
</td></tr>
<tr><td><code id="GenerateReport_+3A_normality_test_method">normality_test_method</code></td>
<td>
<p>method for normality test for a variable.
Values can be <code>shapiro</code>
for Shapiro-Wilk test or
<code>'anderson'</code> for 'Anderson-Darling' test of normality or <code>ks</code> for
'Kolmogorov-Smirnov'</p>
</td></tr>
<tr><td><code id="GenerateReport_+3A_interactive.plots">interactive.plots</code></td>
<td>
<p>for interactive variable exploration</p>
</td></tr>
<tr><td><code id="GenerateReport_+3A_include.vars">include.vars</code></td>
<td>
<p>include only these variables from the full data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a rmarkdown report which can be converted to
html or pdf format file.
</p>


<h3>Value</h3>

<p>creates a rmarkdown and html/pdf file. Returns the output directory
on successful run and <code>FALSE</code> in case of error
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assigning the temporary folder using tempdir(). replace with required directory
GenerateReport(dtpath = mtcars,
               catVars = c("cyl", "vs", "am", "gear"),
               yvar = "vs", model = "binClass",
               output_format = NULL,
               title = "Report",
               output_dir = tempdir(),          # pass the output directory
               interactive.plots = FALSE)       # set TRUE for interactive

</code></pre>

<hr>
<h2 id='kurtosis'>Kurtosis</h2><span id='topic+kurtosis'></span>

<h3>Description</h3>

<p><code>kurtosis</code> calculates the Kurtosis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kurtosis(x, na.rm = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kurtosis_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or a data.frame</p>
</td></tr>
<tr><td><code id="kurtosis_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) Should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the kurtosis of data which is a measure of the
&quot;tailedness&quot; of the probability distribution of a real-valued random
variable. Like skewness, kurtosis describes the shape of a probability
distribution. The formula used is: </p>
<p style="text-align: center;"><code class="reqn">\frac{E[(X-\mu)^{4}]}{(
E[(X-\mu)^2])^{2}}</code>
</p>
<p>.
This formula is the typical definition
used in many older textbooks and wikipedia
</p>


<h3>Value</h3>

<p>returns a single value if <code>x</code> is a vector, otherwise a named
vector of size <code>= ncol(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for a single vector
kurtosis(mtcars$mpg)

# for a dataframe
kurtosis(mtcars)

</code></pre>

<hr>
<h2 id='linedivider'>Draws a horizontal line on console</h2><span id='topic+linedivider'></span>

<h3>Description</h3>

<p>Draws a horizontal line on console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linedivider(consolewidth = getOption("width"), st = "x")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linedivider_+3A_consolewidth">consolewidth</code></td>
<td>
<p>a integer</p>
</td></tr>
<tr><td><code id="linedivider_+3A_st">st</code></td>
<td>
<p>a character or symbol of length to be used for creating the line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a horizontal line of width 'consolewidth'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>linedivider(20)
</code></pre>

<hr>
<h2 id='mergeAnalyzer'>Analyze data for merging</h2><span id='topic+mergeAnalyzer'></span>

<h3>Description</h3>

<p><code>mergeAnalyzer</code> analyzes the data drop after merge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeAnalyzer(x, y, round.digit = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeAnalyzer_+3A_x">x</code></td>
<td>
<p>left data to merge</p>
</td></tr>
<tr><td><code id="mergeAnalyzer_+3A_y">y</code></td>
<td>
<p>right data to merge</p>
</td></tr>
<tr><td><code id="mergeAnalyzer_+3A_round.digit">round.digit</code></td>
<td>
<p>integer indicating the number of decimal places to be used</p>
</td></tr>
<tr><td><code id="mergeAnalyzer_+3A_...">...</code></td>
<td>
<p>other parameters needs to be passed to merge function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the summary of data retained after merge and returns the merged data.
This function uses data.table (if the package is installed) for faster data
merge
</p>


<h3>Value</h3>

<p>Returns merged data with same class as that of input data.
Prints summary of data retained after merging.
The summary has 6 columns:
</p>

<ul>
<li><p> Column: Number of rows and union of column names of numeric columns
in both the data
</p>
</li>
<li><p> x, y: Sum of columns in both table
</p>
</li>
<li><p> Merged: Sum of columns in merged data
</p>
</li>
<li><p> remainingWRTx: ratio of remaining data in merged data after merging.
example - 0.5 means that 50
of inner join). 1.5 means value became 150
duplicates present in data
</p>
</li>
<li><p> remainingWRTy: same as above, but for y table
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Creating two tables to merge
A &lt;- data.frame(id = c("A", "A", "B", "D", "B"),
                valA = c(30, 83, 45, 2, 58))

B &lt;- data.frame(id = c("A", "C", "A", "B", "C", "C"),
                valB = c(10, 20, 30, 40, 50, 60))

mergeAnalyzer(A, B, allow.cartesian = TRUE, all = FALSE)

</code></pre>

<hr>
<h2 id='norm_test_fun'>Checks for Normality Assumption</h2><span id='topic+norm_test_fun'></span>

<h3>Description</h3>

<p><code>norm_test_fun</code> checks for the normality assumption
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_test_fun(x, method = "anderson", pval = 0.05, xn = "x", bin = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_test_fun_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="norm_test_fun_+3A_method">method</code></td>
<td>
<p><code>shapiro</code> for Shapiro-Wilk test or
<code>'anderson'</code> for 'Anderson-Darling' test of normality or <code>ks</code> for
'Kolmogorov-Smirnov'</p>
</td></tr>
<tr><td><code id="norm_test_fun_+3A_pval">pval</code></td>
<td>
<p>significance level for normality tests. Default is 0.05</p>
</td></tr>
<tr><td><code id="norm_test_fun_+3A_xn">xn</code></td>
<td>
<p>vector name</p>
</td></tr>
<tr><td><code id="norm_test_fun_+3A_bin">bin</code></td>
<td>
<p>TRUE if only TRUE/FALSE is required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks for normality assumption using
shapiro, Kolmogorov-Smirnov  or Anderson Darling test.
If the parameter <code>bin</code> is TRUE, then <code>TRUE</code> is returned
if vector is normal, otherwise FALSE.
The significance level is passed through the parameter
<code>pval</code>
</p>


<h3>Value</h3>

<p>Logical TRUE/FALSE based on the performed test and <code>pval</code>.
If the vector follows the normality assumption, then TRUE is returned
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anderson.test">anderson.test</a></code> for Anderson Darling test
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_test_fun(mtcars$mpg)
norm_test_fun(mtcars$mpg, method = "shapiro",
              pval = 0.05, xn = "mpg", bin = TRUE)

</code></pre>

<hr>
<h2 id='plot.analyzerPlot'>Plots a plot of class 'analyzerPlot'</h2><span id='topic+plot.analyzerPlot'></span>

<h3>Description</h3>

<p>This function plots the plot generated by the library <code>analyzer</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'analyzerPlot'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.analyzerPlot_+3A_x">x</code></td>
<td>
<p>a plot of class <code>analyzerPlot</code></p>
</td></tr>
<tr><td><code id="plot.analyzerPlot_+3A_...">...</code></td>
<td>
<p>extra arguments if required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays the plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating the plot
p &lt;- plottr(mtcars)
plot(p$mpg)

</code></pre>

<hr>
<h2 id='plotNA'>Missing value visualization using ggplot2</h2><span id='topic+plotNA'></span>

<h3>Description</h3>

<p><code>plotNA</code> returns a grob visualizing the missing values in data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNA(tb, order = T, limit = T, add_percent = T, row.level = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNA_+3A_tb">tb</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="plotNA_+3A_order">order</code></td>
<td>
<p>(logical) Whether to order the variables based on missing values
in plot</p>
</td></tr>
<tr><td><code id="plotNA_+3A_limit">limit</code></td>
<td>
<p>(logical) Whether to limit the plot to maximum missing value.
FALSE means the limit of axis will be [0, nrow(tb)]</p>
</td></tr>
<tr><td><code id="plotNA_+3A_add_percent">add_percent</code></td>
<td>
<p>(logical) Whether to add percent as data labels on bar plot</p>
</td></tr>
<tr><td><code id="plotNA_+3A_row.level">row.level</code></td>
<td>
<p>(logical) Whether to create plot at rows and variables level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function which helps in visualizing the missing values in data
using plots. By default a bar plot is generated which shows the count of
missing values in each variable.
</p>
<p>If <code>order</code> is set as <code>TRUE</code> then the bars are arranged in order of
missing values. If <code>limit</code> is set as <code>TRUE</code> then limit of axis is
set to [0, nrow(tb)]. If <code>add_percent</code> is set as <code>TRUE</code> then
percent is added as text to the bars. If <code>row.level</code> is set to
<code>TRUE</code> then an additional plot is generated which shows which rows have
missing values and in which variable (reshape2
(<a href="https://CRAN.R-project.org/package=reshape2">https://CRAN.R-project.org/package=reshape2</a>) library
is required for this).
</p>


<h3>Value</h3>

<p>This function returns a grob of class 'analyzePlot' which has a bar
plot showing the count of missing value for each variable. <code>order,
  limit, add_percent</code> can be used to modify the bar plot. An additional plot
will be created and added to the grob if <code>row.level</code> is set as
<code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- plotNA(airquality)
# function to show the 'analyzerPlot' class plot
plot(p)
p1 &lt;- plotNA(airquality, order = FALSE)
plot(p1)

</code></pre>

<hr>
<h2 id='plottr'>Creates plots for the variables in a data.frame</h2><span id='topic+plottr'></span>

<h3>Description</h3>

<p><code>plottr</code> can be used to create plots for
all the variables in a dataframe or any one vector. The output is a list of
plots for each variable of class 'analyzerPlot'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plottr(
  tb,
  yvar = NULL,
  xclasses = NULL,
  yclass = NULL,
  printall = F,
  callasfactor = 1,
  FUN1 = Cx,
  FUN2 = Qx,
  FUN3 = CxCy,
  FUN4 = QxCy,
  FUN5 = CxQy,
  FUN6 = QxQy,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plottr_+3A_tb">tb</code></td>
<td>
<p>a data.frame or a vector. If <code>yvar</code> argument is also passed,
then this should be a data.frame including the response variable (<code>yvar</code>)</p>
</td></tr>
<tr><td><code id="plottr_+3A_yvar">yvar</code></td>
<td>
<p>a string showing the response (dependent) variable name. Can be
<code>NULL</code> if response variable is not present. Make sure that this variable
is present in the <code>tb</code></p>
</td></tr>
<tr><td><code id="plottr_+3A_xclasses">xclasses</code></td>
<td>
<p>a vector of length <code>= ncol(tb)</code> with the data type of
all the columns. Can be <code>NULL</code>, in such case function assigns a class
to each column. The values have to be either NULL, or a vector of
either <code>'factor'</code> or <code>'numeric'</code>. The order should be same as the
actual columns in <code>tb</code>. In case when <code>tb</code> is a vector, this can
be a vector of length 1.</p>
</td></tr>
<tr><td><code id="plottr_+3A_yclass">yclass</code></td>
<td>
<p>class of response variable. Can be <code>NULL</code>, but must have
value when <code>yvar</code> is not <code>NULL</code>. Value can be <code>'factor'</code> or
<code>'numeric'</code></p>
</td></tr>
<tr><td><code id="plottr_+3A_printall">printall</code></td>
<td>
<p>(logical) Whether user wants to show the plots. Setting this
as <code>FALSE</code> will only returns a list of plots silently.</p>
</td></tr>
<tr><td><code id="plottr_+3A_callasfactor">callasfactor</code></td>
<td>
<p>minimum unique values needed for <code>x</code> to be
considered as numeric. See details for more information</p>
</td></tr>
<tr><td><code id="plottr_+3A_fun1">FUN1</code></td>
<td>
<p>an user-defined function for plotting 1 variables when the
variable is Continuous. See details for more details on how to define these
variables</p>
</td></tr>
<tr><td><code id="plottr_+3A_fun2">FUN2</code></td>
<td>
<p>same as FUN1 but for categorical variable</p>
</td></tr>
<tr><td><code id="plottr_+3A_fun3">FUN3</code></td>
<td>
<p>an user defined function for plotting 2 variables when both the
independent variable (x) and dependent variable (y) are Continuous</p>
</td></tr>
<tr><td><code id="plottr_+3A_fun4">FUN4</code></td>
<td>
<p>same as FUN3, but when independent variable (x) is Categorical and
dependent variable (y) is Continuous</p>
</td></tr>
<tr><td><code id="plottr_+3A_fun5">FUN5</code></td>
<td>
<p>same as FUN3, but when independent variable (x) is Continuous and
dependent variable (y) is Categorical</p>
</td></tr>
<tr><td><code id="plottr_+3A_fun6">FUN6</code></td>
<td>
<p>same as FUN3, but when both the independent variable (x) and
dependent variable (y) are Categorical</p>
</td></tr>
<tr><td><code id="plottr_+3A_...">...</code></td>
<td>
<p>extra arguments passed to functions FUN1-FUN6</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function which helps in understanding the data through multiple
visualizations. This works either for a data.frame having multiple variables
or a single <code>x</code> variable or for a combination of predictor <code>x</code> and
response <code>y</code> variables. Based on
class of <code>x</code> and <code>y</code> different types of plots are automatically
generated.
</p>
<p>Please note the following points:
</p>
<p>Defining the class of variables: If <code>yvar</code> is not NULL, then
<code>yclass</code> has to be passed (which can be 'factor' for classification type
problem, or 'numeric' for regression). <code>xclasses</code> stores the class of
all the variables in the dataframe in same order of columns. Note -
if <code>yvar</code> is not NULL, then <code>tb</code> has to be a data.frame with
at least 2 columns (including the yvar). In such
case xclasses should also have the class of <code>yvar</code> although it is
also passed through <code>yclass</code>. This can also be set as NULL, in
such case the function assigns a class based on the contents. If variable is
factor/character type, then <code>xclasses</code> will have 'factor' as the
entry for that variable, else if <code>x</code> is
numeric with number of unique values less than <strong>callasfactor</strong>
parameter value, then <code>xclasses</code> will have 'factor', else 'numeric'.
</p>
<p>DEFINING CUSTOM FUNCTIONS FOR THE PLOTS USING FUN1, FUN2, FUN3 ... FUN6:
</p>
<p>Custom plots can be made using these functions passed as arguments. Following
things must be followed while defining such functions:
</p>

<ul>
<li><p> the return plot must be of type 'grob' or 'gtables' or 'ggplot'.
Since these outputs will go to <code><a href="gridExtra.html#topic+arrangeGrob">arrangeGrob</a></code>, make
sure the output plots are acceptable by <code>arrangeGrob</code> function.
See code of <code><a href="#topic+CxCy">CxCy</a></code> for sample.
</p>
</li>
<li><p> not all 6 functions are required to be passed. Only pass those
functions for which plots need to be changed.
</p>
</li>
<li><p> FUN1 and FUN2 must have 3 parameters: <strong>dat</strong> (of type data.frame
for the data. Even
if there is only one column, it should be passed as a data.frame of one
column), <strong>xname</strong> name of column in dat and <strong>...</strong> In addition
to these three, any number of additional parameters can be added.
Look into source of code of <code><a href="#topic+Cx">Cx</a></code> for sample.
</p>
</li>
<li><p> FUN3, FUN4, FUN5 and FUN6
must have 4 parameters: <strong>dat</strong> (of type data.frame for the data.
Must have two columns for independent and dependent variables),
<strong>xname</strong> name of independent variable in <code>dat</code>,
<strong>yname</strong> name of dependent variable in <code>dat</code> and
<strong>...</strong> In addition to these four,
any number of additional parameters can be added.
Look into source of code of <code><a href="#topic+CxCy">CxCy</a></code> for sample.
</p>
</li>
<li> <p><strong>...</strong> must be added as an argument in all the functions.
</p>
</li></ul>

<p>To get a better idea, see the code for function <code><a href="#topic+CxCy">CxCy</a></code>
and <code><a href="#topic+Cx">Cx</a></code>
</p>
<p>Default plots: If the <code>y</code> is <code>NULL</code>, then histogram with density
is generated for numeric <code>x</code>. Boxplot
is also shown in the same histogram using color and vertical lines. For
factor <code>x</code>, a pie chart showing the distribution. This are the
univariate plots which can be modified by using the FUN1 and FUN2 arguments.
</p>
<p>If <code>y</code> is not
<code>NULL</code>, then additional plots are added which can be modified by
using the FUN3, FUN4, FUN5, FUN6 arguments:
</p>

<ul>
<li> <p><strong>factor <code>x</code>, factor <code>y</code></strong>: Crosstab with
heatmap (modified by using FUN6)
</p>
</li>
<li> <p><strong>factor <code>x</code>, numeric <code>y</code></strong>: histogram and
boxplot of <code>y</code> for different values of <code>x</code>
(modified by using FUN4)
</p>
</li>
<li> <p><strong>numeric <code>x</code>, factor <code>y</code></strong>:
histogram and boxplot of <code>x</code> for different
values of <code>y</code>
(modified by using FUN5)
</p>
</li>
<li> <p><strong>numeric <code>x</code>, numeric <code>y</code></strong>: Scatter
plot of <code>x</code> and <code>y</code> with rug plot included
(modified by using FUN3)
</p>
</li></ul>



<h3>Value</h3>

<p>A list of plots for all the variables. Each plot will have the class
<code>analyzerPlot</code> and can be displayed using <code>plot()</code>. If
<code>printall = TRUE</code>, then all plots will also be displayed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple use for one variable
p &lt;- plottr(mtcars$mpg)
# To display the plot
plot(p$x)

# With complete dataframe and assuming 'mpg' as a dependent variable
p &lt;- plottr(mtcars, yvar = "mpg", yclass = "numeric")
plot(p$disp)

</code></pre>

<hr>
<h2 id='print.analyzerPlot'>Method for print generic</h2><span id='topic+print.analyzerPlot'></span>

<h3>Description</h3>

<p>This function plots the plot generated by the library <code>analyzer</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'analyzerPlot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.analyzerPlot_+3A_x">x</code></td>
<td>
<p>a plot of class <code>analyzerPlot</code></p>
</td></tr>
<tr><td><code id="print.analyzerPlot_+3A_...">...</code></td>
<td>
<p>other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays the plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating the plot
p &lt;- plottr(mtcars$mpg)
p$x

</code></pre>

<hr>
<h2 id='QQassociation'>Association (Correlation) between Categorical Variables</h2><span id='topic+QQassociation'></span>

<h3>Description</h3>

<p><code>QQassociation</code> finds Association measure between all the variables in
data with only categorical columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QQassociation(factb, use = "everything", methods_used)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QQassociation_+3A_factb">factb</code></td>
<td>
<p>a data frame with all the categorical columns. This should
have at least two columns</p>
</td></tr>
<tr><td><code id="QQassociation_+3A_use">use</code></td>
<td>
<p>an optional character string giving a method for computing
association in the presence of missing values. This must be (complete or an
abbreviation of) one of the strings &quot;everything&quot;, &quot;all.obs&quot;,
&quot;complete.obs&quot;, &quot;na.or.complete&quot;, or &quot;pairwise.complete.obs&quot;. If use is
&quot;everything&quot;, NAs will propagate conceptually, i.e., a resulting value will
be NA whenever one of its contributing observations is NA. If use is
&quot;all.obs&quot;, then the presence of missing observations will produce an error.
If use is &quot;complete.obs&quot; then missing values are handled by case wise
deletion (and if there are no complete cases, that gives an error).
&quot;na.or.complete&quot; is the same unless there are no complete cases, that gives
NA</p>
</td></tr>
<tr><td><code id="QQassociation_+3A_methods_used">methods_used</code></td>
<td>
<p>a square data.frame which will store the type of
association used between the variables. Dimension will be
number of variables * number of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function measures the association between categorical variables using
Chi Square test. This also returns Cramers V value which is a measure of
association between two nominal variables, giving a value between 0 and +1
(inclusive). Higher number indicates higher association. Note that, unlike
Pearson correlation this doesn't give negative value.
</p>
<p>The relation between Cramer's V and Chi Sq test is
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\frac{\chi ^2}{n*min(k-1,r-1))}}</code>
</p>

<p>where:
</p>

<dl>
<dt>X</dt><dd><p>is derived from Pearson's chi-squared test</p>
</dd>
<dt>n</dt><dd><p>is the grand total of observations</p>
</dd>
<dt>k</dt><dd><p>being the number of columns</p>
</dd>
<dt>r</dt><dd><p>being the number of rows</p>
</dd>
</dl>

<p>The p-value for the significance of Cramer's V is the same one
that is calculated using the Pearson's chi-squared test.
</p>


<h3>Value</h3>

<p>a list of two tables with number of rows and column equal to number
of columns in <code>factb</code>:
</p>

<dl>
<dt>chisq</dt><dd><p>Table containing p-values of chi-square test</p>
</dd>
<dt>cramers</dt><dd><p>Table containing Cramer's V</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+association">association</a></code> for association between any type of variables,
<code><a href="#topic+CCassociation">CCassociation</a></code> for Association between Continuous (numeric)
variables,
<code><a href="#topic+CQassociation">CQassociation</a></code> for Association between Continuous-Categorical
variables
</p>

<hr>
<h2 id='skewness'>Skewness</h2><span id='topic+skewness'></span>

<h3>Description</h3>

<p><code>skewness</code> calculates the skewness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness(x, na.rm = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewness_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or a data.frame</p>
</td></tr>
<tr><td><code id="skewness_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) Should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the skewness of data which is a measure of the
asymmetry of the probability distribution of a real-valued random variable
about its mean. The formula used is:
</p>
<p style="text-align: center;"><code class="reqn">\frac{E[(X-\mu)^{3}]}{(E[(X-\mu)^2])^\frac{3}{2}}</code>
</p>
<p>. This formula is the
typical definition used in many older textbooks and wikipedia
</p>


<h3>Value</h3>

<p>returns a single value if <code>x</code> is a vector, otherwise a named
vector of size <code>= ncol(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for a single vector
skewness(mtcars$mpg)

# for a dataframe
skewness(mtcars)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
