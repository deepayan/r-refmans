<!DOCTYPE html><html><head><title>Help for package acdcquery</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {acdcquery}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_argument'><p>Add a filter argument to a list</p></a></li>
<li><a href='#add_join_paths_to_query'><p>Add Join Paths to Query</p></a></li>
<li><a href='#check_operator'><p>Check validity of operator and values</p></a></li>
<li><a href='#connect_to_db'><p>Connect to an SQLite database</p></a></li>
<li><a href='#discover_id_introduction_steps'><p>Discover ID Introduction Steps</p></a></li>
<li><a href='#find_relevant_tables'><p>Find relevant tables based on column name</p></a></li>
<li><a href='#get_argument_sequence'><p>Get argument sequence based on argument relation</p></a></li>
<li><a href='#get_column_names'><p>Get column names from database tables</p></a></li>
<li><a href='#get_filter_statement'><p>Get Filter Statement</p></a></li>
<li><a href='#make_valid_sql'><p>Create a valid SQL statement based on variable, operator, and values</p></a></li>
<li><a href='#precompute_table_join_paths'><p>Precompute Table Join Paths</p></a></li>
<li><a href='#query_db'><p>Query Database</p></a></li>
<li><a href='#return_id_name_from_table'><p>Return ID column name from table name</p></a></li>
<li><a href='#return_table_name_from_id'><p>Return table name from ID column name</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Query the Attentional Control Data Collection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Interact with the Attentional Control Data Collection (ACDC).
  Connect to the database via connect_to_db(), set filter arguments via add_argument()
  and query the database via query_db().</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>DBI, RSQLite</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SLesche/acdc-query">https://github.com/SLesche/acdc-query</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SLesche/acdc-query/issues">https://github.com/SLesche/acdc-query/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-18 10:55:17 UTC; Sven</td>
</tr>
<tr>
<td>Author:</td>
<td>Sven Lesche [aut, cre, cph],
  Julia M. Haaf [ctb, ths],
  Madlen Hoffstadt [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sven Lesche &lt;sven.lesche@psychologie.uni-heidelberg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-20 11:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_argument'>Add a filter argument to a list</h2><span id='topic+add_argument'></span>

<h3>Description</h3>

<p>This function adds an argument to a list containing filter arguments later used to select data from the database.
When supplying the variable used for filtering, the operator and the value, an SQL query will be constructed for the user and added as the next object to the list of arguments.#' When supplying only variable, operator and value, a SQL query will be constructed for the user and added as the next object to a list.
Alternatively, the user may specify an SQL query manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_argument(list, conn, variable, operator, values, statement = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_argument_+3A_list">list</code></td>
<td>
<p>The list to which the argument will be added.</p>
</td></tr>
<tr><td><code id="add_argument_+3A_conn">conn</code></td>
<td>
<p>The connection object or database connection string.</p>
</td></tr>
<tr><td><code id="add_argument_+3A_variable">variable</code></td>
<td>
<p>The variable name to be used in the argument.</p>
</td></tr>
<tr><td><code id="add_argument_+3A_operator">operator</code></td>
<td>
<p>The operator to be used in the argument (i.e., &quot;greater&quot;, &quot;between&quot;, &quot;equal&quot;, &quot;less&quot;).</p>
</td></tr>
<tr><td><code id="add_argument_+3A_values">values</code></td>
<td>
<p>The values to be used in the argument.</p>
</td></tr>
<tr><td><code id="add_argument_+3A_statement">statement</code></td>
<td>
<p>The manual SQL query to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with the new argument (SQL query) added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
conn &lt;- connect_to_db(":memory:")

mtcars$mtcars_id = 1:nrow(mtcars)

example_data = data.frame(
  example_id = 1:150,
  mtcars_id = rep(1:30, each = 5),
  example_value = runif(150, 0, 1)
)

DBI::dbWriteTable(conn, "mtcars_table", mtcars)
DBI::dbWriteTable(conn, "example_table", example_data)

# Initializing argument list
arguments = list()

# Using "equal" operator
arguments = add_argument(
 list = arguments,
 conn = conn,
 variable = "cyl",
 operator = "equal",
 values = c(4, 6)
)

# Using "greater" operator
arguments = add_argument(
 list = arguments,
 conn = conn,
 variable = "cyl",
 operator = "greater",
 values = 2
)

# Using "between" operator
arguments = add_argument(
 list = arguments,
 conn = conn,
 variable = "cyl",
 operator = "between",
 values = c(2, 8)
)

# Manully constructing a filter statement
manual_arguments = add_argument(
 list = arguments,
 conn = conn,
 statement = "SELECT mtcars_id FROM mtcars WHERE cyl = 4 OR cyl = 6)"
)
</code></pre>

<hr>
<h2 id='add_join_paths_to_query'>Add Join Paths to Query</h2><span id='topic+add_join_paths_to_query'></span>

<h3>Description</h3>

<p>This function generates an SQL query based on a specified connection, argument, and join path list.
It constructs a query that performs joins on multiple tables according to the provided join path,
incorporating requested variables and filter conditions as needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_join_paths_to_query(
  conn,
  filter_statements,
  join_path_list,
  argument_sequence,
  requested_vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_join_paths_to_query_+3A_conn">conn</code></td>
<td>
<p>The connection object or database connection string.</p>
</td></tr>
<tr><td><code id="add_join_paths_to_query_+3A_filter_statements">filter_statements</code></td>
<td>
<p>The SQL-Filter statements extracted from the filter arguments list via 'get_filter_statement()'.</p>
</td></tr>
<tr><td><code id="add_join_paths_to_query_+3A_join_path_list">join_path_list</code></td>
<td>
<p>A list representing the join path. Each element of the list should be a data frame
describing a step in the join path with columns: &quot;table_to_join&quot;, &quot;method&quot;, and &quot;common_var&quot;.</p>
</td></tr>
<tr><td><code id="add_join_paths_to_query_+3A_argument_sequence">argument_sequence</code></td>
<td>
<p>A numeric vector representing the AND/OR sequence of arguments.</p>
</td></tr>
<tr><td><code id="add_join_paths_to_query_+3A_requested_vars">requested_vars</code></td>
<td>
<p>A character vector specifying the variables to be selected from the final query result.
If <code>NULL</code>, all variables are selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SQL query string that represents the joined tables and requested variables.
</p>

<hr>
<h2 id='check_operator'>Check validity of operator and values</h2><span id='topic+check_operator'></span>

<h3>Description</h3>

<p>This function checks the validity of the operator and values used in a condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_operator(operator, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_operator_+3A_operator">operator</code></td>
<td>
<p>The operator to be checked.</p>
</td></tr>
<tr><td><code id="check_operator_+3A_values">values</code></td>
<td>
<p>The values to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (no explicit return value).
</p>

<hr>
<h2 id='connect_to_db'>Connect to an SQLite database</h2><span id='topic+connect_to_db'></span>

<h3>Description</h3>

<p>This function establishes a connection to an SQLite database file located at the specified path using the DBI and RSQLite packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connect_to_db(path_to_db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connect_to_db_+3A_path_to_db">path_to_db</code></td>
<td>
<p>The path to the SQLite database file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A database connection object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Connect to a SQLite database file in memory
conn &lt;- connect_to_db(":memory:")

# When connecting to a specific file, like the downloaded ACDC-Database
# just use the path to the database
## Not run: conn &lt;- connect_to_db("path/to/database.db")

# Want the most recent version of the database?
# Download it at https://github.com/jstbcs/acdc-database/blob/main/acdc.db

</code></pre>

<hr>
<h2 id='discover_id_introduction_steps'>Discover ID Introduction Steps</h2><span id='topic+discover_id_introduction_steps'></span>

<h3>Description</h3>

<p>This function identifies the steps in a join path where new IDs are introduced, allowing you to
determine at which join steps each ID variable is added to the query. It returns a data frame with
information about newly discovered IDs and the corresponding join step in the path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discover_id_introduction_steps(conn, full_path_dataframe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discover_id_introduction_steps_+3A_conn">conn</code></td>
<td>
<p>The connection object or database connection string.</p>
</td></tr>
<tr><td><code id="discover_id_introduction_steps_+3A_full_path_dataframe">full_path_dataframe</code></td>
<td>
<p>A data frame representing the full join path, including columns: &quot;table_to_join&quot;,
&quot;method&quot;, and &quot;common_var&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with information about newly discovered IDs and the corresponding join step.
</p>

<hr>
<h2 id='find_relevant_tables'>Find relevant tables based on column name</h2><span id='topic+find_relevant_tables'></span>

<h3>Description</h3>

<p>This function finds the relevant database tables that contain a specified column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_relevant_tables(conn, column_name, info = NULL, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_relevant_tables_+3A_conn">conn</code></td>
<td>
<p>The connection object or database connection string.</p>
</td></tr>
<tr><td><code id="find_relevant_tables_+3A_column_name">column_name</code></td>
<td>
<p>The name of the column to search for in the database tables.</p>
</td></tr>
<tr><td><code id="find_relevant_tables_+3A_info">info</code></td>
<td>
<p>Optional. The information data frame obtained from <code>get_column_names()</code> function.
If not provided, it will be obtained within the function.</p>
</td></tr>
<tr><td><code id="find_relevant_tables_+3A_strict">strict</code></td>
<td>
<p>Should only one table be returned? Relevant for id variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the names of the relevant tables.
</p>

<hr>
<h2 id='get_argument_sequence'>Get argument sequence based on argument relation</h2><span id='topic+get_argument_sequence'></span>

<h3>Description</h3>

<p>This function returns the sequence of arguments based on the specified argument relation.
The argument relation determines the logical relationship between the arguments (e.g., &quot;and&quot;, &quot;or&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_argument_sequence(arguments, argument_relation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_argument_sequence_+3A_arguments">arguments</code></td>
<td>
<p>The list of arguments.</p>
</td></tr>
<tr><td><code id="get_argument_sequence_+3A_argument_relation">argument_relation</code></td>
<td>
<p>The specified argument relation. If &quot;and&quot;, the sequence will be 1:length(arguments).
If &quot;or&quot;, the sequence will be rep(1, length(arguments)).
If a vector is provided, it should have the same length as the number of arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the sequence of arguments.
</p>

<hr>
<h2 id='get_column_names'>Get column names from database tables</h2><span id='topic+get_column_names'></span>

<h3>Description</h3>

<p>This function retrieves the column names from all tables in the specified database connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_column_names(conn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_column_names_+3A_conn">conn</code></td>
<td>
<p>The connection object or database connection string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the column names and corresponding table names.
</p>

<hr>
<h2 id='get_filter_statement'>Get Filter Statement</h2><span id='topic+get_filter_statement'></span>

<h3>Description</h3>

<p>This function constructs a SQL filter statement based on the provided filter statements and argument sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_filter_statement(filter_statements, argument_sequence, introduction_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_filter_statement_+3A_filter_statements">filter_statements</code></td>
<td>
<p>A character vector of SQL filter statements, one for each argument in the argument sequence.</p>
</td></tr>
<tr><td><code id="get_filter_statement_+3A_argument_sequence">argument_sequence</code></td>
<td>
<p>A numeric vector representing the argument sequence for constructing the filter statement.</p>
</td></tr>
<tr><td><code id="get_filter_statement_+3A_introduction_table">introduction_table</code></td>
<td>
<p>A data frame containing information about table prefixes for ID variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string representing the constructed SQL filter statement.
</p>

<hr>
<h2 id='make_valid_sql'>Create a valid SQL statement based on variable, operator, and values</h2><span id='topic+make_valid_sql'></span>

<h3>Description</h3>

<p>This function creates a valid SQL statement based on the specified variable, operator, and values.
It handles different operators such as &quot;greater&quot;, &quot;less&quot;, &quot;equal&quot;, and &quot;between&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_valid_sql(conn, variable, operator, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_valid_sql_+3A_conn">conn</code></td>
<td>
<p>The connection object or database connection string.</p>
</td></tr>
<tr><td><code id="make_valid_sql_+3A_variable">variable</code></td>
<td>
<p>The variable for which the SQL statement is created.</p>
</td></tr>
<tr><td><code id="make_valid_sql_+3A_operator">operator</code></td>
<td>
<p>The operator to be used in the SQL statement.</p>
</td></tr>
<tr><td><code id="make_valid_sql_+3A_values">values</code></td>
<td>
<p>The values to be used in the SQL statement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string representing the valid SQL statement.
</p>

<hr>
<h2 id='precompute_table_join_paths'>Precompute Table Join Paths</h2><span id='topic+precompute_table_join_paths'></span>

<h3>Description</h3>

<p>This function precomputes join paths for all tables in a given database using a combination of forward and backward joins.
It generates a list of data frames representing the join paths for each table, including information about tables to join,
walk approaches (forward or backward), and common variables used for joining.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precompute_table_join_paths(conn, input_table = NULL, relevant_tables = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precompute_table_join_paths_+3A_conn">conn</code></td>
<td>
<p>The connection object or database connection string.</p>
</td></tr>
<tr><td><code id="precompute_table_join_paths_+3A_input_table">input_table</code></td>
<td>
<p>The table from which the join path is computed.</p>
</td></tr>
<tr><td><code id="precompute_table_join_paths_+3A_relevant_tables">relevant_tables</code></td>
<td>
<p>A vector of tables that are relevant to the query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of join paths for each table in the database.
</p>

<hr>
<h2 id='query_db'>Query Database</h2><span id='topic+query_db'></span>

<h3>Description</h3>

<p>This function performs targeted queries on an SQLite database using specified filtering arguments and returns the query results.
It extracts information about which tables of the database are relevant for the query and then joins these relevant tables to the target table.
The function constructs an SQL query which incorporates both the joining and filtering target variables. This SQL statement is then applied to the database and the resulting dataframe is returned to the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_db(
  conn,
  arguments,
  target_vars = "default",
  target_table = "observation_table",
  argument_relation = "and"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_db_+3A_conn">conn</code></td>
<td>
<p>The connection object to an SQLite database.</p>
</td></tr>
<tr><td><code id="query_db_+3A_arguments">arguments</code></td>
<td>
<p>A list of filtering arguments for the query. The list must have only one filter argument per list-entry.</p>
</td></tr>
<tr><td><code id="query_db_+3A_target_vars">target_vars</code></td>
<td>
<p>A character vector specifying the variables to be included in the query results.</p>
</td></tr>
<tr><td><code id="query_db_+3A_target_table">target_table</code></td>
<td>
<p>The target table in the database for querying.</p>
</td></tr>
<tr><td><code id="query_db_+3A_argument_relation">argument_relation</code></td>
<td>
<p>A character string specifying the relation between filtering arguments (&quot;and&quot; or &quot;or&quot; or a numerical vector with the same length as the number of arguments). Arguments with equal numbers in their index are joined using the OR operator, others using AND. To represent (A OR B) AND C AND D use the vector c(1, 1, 2, 3).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the query results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conn &lt;- connect_to_db(":memory:")

mtcars$mtcars_id = 1:nrow(mtcars)

example_data = data.frame(
  example_id = 1:150,
  mtcars_id = rep(1:30, each = 5),
  example_value = runif(150, 0, 1)
)

DBI::dbWriteTable(conn, "mtcars_table", mtcars)
DBI::dbWriteTable(conn, "example_table", example_data)

# Initializing argument list
arguments = list()
arguments = add_argument(
 list = arguments,
 conn = conn,
 variable = "cyl",
 operator = "equal",
 values = c(4, 6)
)

arguments = add_argument(
 list = arguments,
 conn = conn,
 variable = "example_value",
 operator = "greater",
 values = 0.4
)

# Return specified variables
target_vars = c("mtcars_id", "example_id", "cyl")

query_results = query_db(
 conn = conn,
 arguments = arguments,
 target_vars = target_vars,
 target_table = "example_table",
 argument_relation = "and"
)

# Return all variables in mtcars_table and example_value from example_table
query_results = query_db(
 conn = conn,
 arguments = arguments,
 target_vars = c("default", "example_value"),
 target_table = "mtcars_table",
 argument_relation = "and"
)
</code></pre>

<hr>
<h2 id='return_id_name_from_table'>Return ID column name from table name</h2><span id='topic+return_id_name_from_table'></span>

<h3>Description</h3>

<p>This function generates the ID column name based on the provided table name.
It replaces the &quot;table&quot; suffix with &quot;id&quot; to obtain the ID column name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_id_name_from_table(table_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="return_id_name_from_table_+3A_table_name">table_name</code></td>
<td>
<p>The name of the table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated ID column name.
</p>

<hr>
<h2 id='return_table_name_from_id'>Return table name from ID column name</h2><span id='topic+return_table_name_from_id'></span>

<h3>Description</h3>

<p>This function generates the table name based on the provided ID column name.
It replaces the &quot;id&quot; suffix with &quot;table&quot; to obtain the table name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_table_name_from_id(id_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="return_table_name_from_id_+3A_id_name">id_name</code></td>
<td>
<p>The name of the ID column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated table name.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
