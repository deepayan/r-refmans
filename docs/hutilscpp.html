<!DOCTYPE html><html lang="en"><head><title>Help for package hutilscpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hutilscpp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hutilscpp-package'><p>hutilscpp: Miscellaneous Functions in C++</p></a></li>
<li><a href='#abs_diff'><p>Absolute difference</p></a></li>
<li><a href='#allNA'><p>Is a vector empty?</p></a></li>
<li><a href='#anyOutside'><p>Are any values outside the interval specified?</p></a></li>
<li><a href='#are_even'><p>Are elements of a vector even?</p></a></li>
<li><a href='#as_integer_if_safe'><p>Coerce from double to integer if safe</p></a></li>
<li><a href='#bench_system_time'><p>Evaluate time of computation</p></a></li>
<li><a href='#character2integer'><p>Character to numeric</p></a></li>
<li><a href='#coalesce0'><p>Convenience function for coalescing to zero</p></a></li>
<li><a href='#Comma'><p>Faster version of <code>scales::comma</code></p></a></li>
<li><a href='#count_logical'><p>Count logicals</p></a></li>
<li><a href='#cumsum_reset'><p>Cumulative sum unless reset</p></a></li>
<li><a href='#diam'><p>What is the diameter of set of points?</p></a></li>
<li><a href='#divisible'><p>Divisibility</p></a></li>
<li><a href='#every_int'><p>Every integer</p></a></li>
<li><a href='#fmatchp'><p>Parallel fastmatching</p></a></li>
<li><a href='#helper'><p>Helper</p></a></li>
<li><a href='#Implies'><p>Implies</p></a></li>
<li><a href='#is_constant'><p>Is a vector constant?</p></a></li>
<li><a href='#is_sorted'><p>Is a vector sorted?</p></a></li>
<li><a href='#logical3'><p>Vectorized logical with support for short-circuits</p></a></li>
<li><a href='#logical3s'><p>Complex logical expressions</p></a></li>
<li><a href='#match_nrst_haversine'><p>Match coordinates to nearest coordinates</p></a></li>
<li><a href='#minmax'><p>Minimum and maximum</p></a></li>
<li><a href='#ModeC'><p>Most common element</p></a></li>
<li><a href='#pmaxC'><p>Parallel maximum/minimum</p></a></li>
<li><a href='#poleInaccessibility'><p>Find a binary pole of inaccessibility</p></a></li>
<li><a href='#range_rcpp'><p>Range C++</p></a></li>
<li><a href='#squish'><p>Squish into a range</p></a></li>
<li><a href='#sum_and3s'><p>Sum of logical expressions</p></a></li>
<li><a href='#sum_isna'><p>Number of missing values</p></a></li>
<li><a href='#unique_fmatch'><p>Distinct elements</p></a></li>
<li><a href='#which_first'><p>Where does a logical expression first return <code>TRUE</code>?</p></a></li>
<li><a href='#which_firstNA'><p>First/last position of missing values</p></a></li>
<li><a href='#which_true_onwards'><p>At which point are all values true onwards</p></a></li>
<li><a href='#which3'><p>which of three vectors are the elements (all, any) true?</p></a></li>
<li><a href='#whichs'><p>Separated which</p></a></li>
<li><a href='#xor2'><p>Exclusive or</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Miscellaneous Functions in C++</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.10</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides utility functions that are simply, frequently used, 
    but may require higher performance that what can be obtained from base R.
    Incidentally provides support for 'reverse geocoding', such as matching a point
    with its nearest neighbour in another array. Used as a complement to package
    'hutils' by sacrificing compilation or installation time for higher running 
    speeds. The name is a portmanteau of the author and 'Rcpp'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hughparsonage/hutilscpp">https://github.com/hughparsonage/hutilscpp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hughparsonage/hutilscpp/issues">https://github.com/hughparsonage/hutilscpp/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, hutils, magrittr, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, parallel, TeXCheckR, withr, tinytest, covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-20 07:45:30 UTC; hughp</td>
</tr>
<tr>
<td>Author:</td>
<td>Hugh Parsonage [aut, cre],
  Simon Urbanek [ctb] (fastmatch components)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hugh Parsonage &lt;hugh.parsonage@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-20 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hutilscpp-package'>hutilscpp: Miscellaneous Functions in C++</h2><span id='topic+hutilscpp'></span><span id='topic+hutilscpp-package'></span>

<h3>Description</h3>

<p>Provides utility functions that are simply, frequently used, but may require higher performance that what can be obtained from base R. Incidentally provides support for 'reverse geocoding', such as matching a point with its nearest neighbour in another array. Used as a complement to package 'hutils' by sacrificing compilation or installation time for higher running speeds. The name is a portmanteau of the author and 'Rcpp'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hugh Parsonage <a href="mailto:hugh.parsonage@gmail.com">hugh.parsonage@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Simon Urbanek (fastmatch components) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/hughparsonage/hutilscpp">https://github.com/hughparsonage/hutilscpp</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hughparsonage/hutilscpp/issues">https://github.com/hughparsonage/hutilscpp/issues</a>
</p>
</li></ul>


<hr>
<h2 id='abs_diff'>Absolute difference</h2><span id='topic+abs_diff'></span><span id='topic+max_abs_diff'></span>

<h3>Description</h3>

<p>Equivalent to <code>abs(x - y)</code> but aims to be faster by
avoiding allocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abs_diff(x, y, nThread = getOption("hutilscpp.nThread", 1L), option = 1L)

max_abs_diff(x, y, nThread = getOption("hutilscpp.nThread", 1L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abs_diff_+3A_x">x</code>, <code id="abs_diff_+3A_y">y</code></td>
<td>
<p>Atomic, numeric, equilength vectors.</p>
</td></tr>
<tr><td><code id="abs_diff_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="abs_diff_+3A_option">option</code></td>
<td>
<p>An integer, provides backwards-compatible method to change results.
</p>

<dl>
<dt>0</dt><dd><p>Return <code>max(abs(x - y))</code> (without allocation).</p>
</dd>
<dt>1</dt><dd><p>Return <code>abs(x - y)</code> with the expectation that every element will be <code>integer</code>,
returning a <code>double</code> only if required.</p>
</dd>
<dt>2</dt><dd><p>Return <code>abs(x - y)</code> but always a <code>double</code> vector, regardless of necessity.</p>
</dd>
<dt>3</dt><dd><p>Return <code>which.max(abs(x - y))</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(10)
y &lt;- sample(10)
abs_diff(x, y)
max_abs_diff(x, y)

</code></pre>

<hr>
<h2 id='allNA'>Is a vector empty?</h2><span id='topic+allNA'></span>

<h3>Description</h3>

<p>A vector is empty if <code>all(is.na(x))</code> with a
special case for <code>length(x) == 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allNA(
  x,
  expected = FALSE,
  len0 = FALSE,
  nThread = getOption("hutilscpp.nThread", 1L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allNA_+3A_x">x</code></td>
<td>
<p>A vector. Only atomic vectors are supported.</p>
</td></tr>
<tr><td><code id="allNA_+3A_expected">expected</code></td>
<td>
<p><code>TRUE | FALSE</code> Whether it is expected that <code>x</code> is empty.
If <code>TRUE</code> the function will be marginally faster if <code>x</code> is empty but
likely slower if not.</p>
</td></tr>
<tr><td><code id="allNA_+3A_len0">len0</code></td>
<td>
<p>The result if <code>length(x) == 0</code>.</p>
</td></tr>
<tr><td><code id="allNA_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use (only applicable if <code>expected</code> is <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>allNA(c(NA, NA))
allNA(c(NA, NA, 1))

</code></pre>

<hr>
<h2 id='anyOutside'>Are any values outside the interval specified?</h2><span id='topic+anyOutside'></span>

<h3>Description</h3>

<p>Are any values outside the interval specified?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anyOutside(x, a, b, nas_absent = NA, na_is_outside = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anyOutside_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="anyOutside_+3A_a">a</code>, <code id="anyOutside_+3A_b">b</code></td>
<td>
<p>Single numeric values designating the interval.</p>
</td></tr>
<tr><td><code id="anyOutside_+3A_nas_absent">nas_absent</code></td>
<td>
<p>Are <code>NA</code>s <em>known</em> to be absent from <code>x</code>?
If <code>nas_absent = NA</code>, the default, <code>x</code> will be searched for <code>NA</code>s;
if <code>nas_absent = TRUE</code>, <code>x</code> will not be checked;
if <code>nas_absent = FALSE</code>, the answer is <code>NA_integer_</code> if <code>na.rm = FALSE</code>
otherwise only non-NA values outside <code>[a, b]</code>.
</p>
<p>If <code>nas_absent = TRUE</code> but <code>x</code> has missing values then the result is unreliable.</p>
</td></tr>
<tr><td><code id="anyOutside_+3A_na_is_outside">na_is_outside</code></td>
<td>
<p>(logical, default: <code>NA</code>) How should <code>NA</code>s in <code>x</code> be treated?
</p>

<dl>
<dt>If <code>NA</code></dt><dd><p> the default, then the first value in <code>x</code> that is either
outside <code>[a, b]</code> or <code>NA</code> is detected: if it is <code>NA</code>, then
<code>NA_integer_</code> is returned; otherwise the position of that value is returned.</p>
</dd></dl>
<p>#'
</p>
<dl>
<dt>If <code>FALSE</code></dt><dd><p>then <code>NA</code> values are effectively skipped; the position of the first
<em>known</em> value outside <code>[a, b]</code> is returned.</p>
</dd>
<dt>If <code>TRUE</code></dt><dd><p>the position of the first value that is either
outside <code>[a, b]</code> or <code>NA</code> is returned.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p><code>0L</code> if no values in <code>x</code> are outside <code>[a, b]</code>. Otherwise, the position
of the first value of <code>x</code> outside <code>[a, b]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anyOutside(1:10, 1L, 10L)
anyOutside(1:10, 1L, 7L)

# na_is_outside = NA
anyOutside(c(1:10, NA), 1L, 7L)     # Already outside before the NA
anyOutside(c(NA, 1:10, NA), 1L, 7L) # NA since it occurred first

anyOutside(c(1:7, NA), 1L, 7L, na_is_outside = FALSE)
anyOutside(c(1:7, NA), 1L, 7L, na_is_outside = TRUE)

##
# N &lt;- 500e6
N &lt;- 500e3
x &lt;- rep_len(hutils::samp(-5:6, size = 23), N)
bench_system_time(anyOutside(x, -5L, 6L))
#    process      real
#  453.125ms 459.758ms

</code></pre>

<hr>
<h2 id='are_even'>Are elements of a vector even?</h2><span id='topic+are_even'></span><span id='topic+which_are_even'></span>

<h3>Description</h3>

<p>Are elements of a vector even?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_even(
  x,
  check_integerish = TRUE,
  keep_nas = TRUE,
  nThread = getOption("hutilscpp.nThread", 1L)
)

which_are_even(x, check_integerish = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="are_even_+3A_x">x</code></td>
<td>
<p>An integer vector. Double vectors may also be used, but will
be truncated, with a warning if any element are not integers.
Long vectors are not supported unless <code>x</code> is integer and <code>keep_nas = FALSE</code>.</p>
</td></tr>
<tr><td><code id="are_even_+3A_check_integerish">check_integerish</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Should the
values in <code>x</code> be checked for non-integer values
if <code>x</code> is a double vector. If <code>TRUE</code>
and values are found to be non-integer a warning is emitted.</p>
</td></tr>
<tr><td><code id="are_even_+3A_keep_nas">keep_nas</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Should <code>NA</code>s in <code>x</code>
return <code>NA</code> in the result? If <code>FALSE</code>, will return <code>TRUE</code> since
the internal representation of <code>x</code> is even. Only applies if <code>is.integer(x)</code>.</p>
</td></tr>
<tr><td><code id="are_even_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>are_even</code>, a logical vector the same length as <code>x</code>,
<code>TRUE</code> whenever <code>x</code> is even.
</p>
<p>For <code>which_are_even</code> the integer positions of even values in <code>x</code>.
</p>

<hr>
<h2 id='as_integer_if_safe'>Coerce from double to integer if safe</h2><span id='topic+as_integer_if_safe'></span>

<h3>Description</h3>

<p>The same as <code>as.integer(x)</code> but only if <code>x</code> consists only of
whole numbers and is within the range of integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_integer_if_safe(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_integer_if_safe_+3A_x">x</code></td>
<td>
<p>A double vector. If not a double vector, it is simply returned without any coercion.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 1e6  # run with 1e9
x &lt;- rep_len(as.double(sample.int(100)), N)
alt_as_integer &lt;- function(x) {
  xi &lt;- as.integer(x)
  if (isTRUE(all.equal(x, xi))) {
    xi
  } else {
    x
  }
}
bench_system_time(as_integer_if_safe(x))
#&gt; process    real
#&gt;  6.453s  6.452s
bench_system_time(alt_as_integer(x))
#&gt; process    real
#&gt; 15.516s 15.545s
bench_system_time(as.integer(x))
#&gt; process    real
#&gt;  2.469s  2.455s

</code></pre>

<hr>
<h2 id='bench_system_time'>Evaluate time of computation</h2><span id='topic+bench_system_time'></span>

<h3>Description</h3>

<p>(Used for examples and tests)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bench_system_time(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bench_system_time_+3A_expr">expr</code></td>
<td>
<p>Passed to <code><a href="bench.html#topic+system_time">system_time</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='character2integer'>Character to numeric</h2><span id='topic+character2integer'></span>

<h3>Description</h3>

<p>Character to numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>character2integer(x, na.strings = NULL, allow.double = FALSE, option = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="character2integer_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="character2integer_+3A_na.strings">na.strings</code></td>
<td>
<p>A set of strings that shall be coerced to <code>NA_integer_</code></p>
</td></tr>
<tr><td><code id="character2integer_+3A_allow.double">allow.double</code></td>
<td>
<p><code>logical(1)</code> If <code>TRUE</code>, a double vector may be returned.
If <code>FALSE</code>, an error will be emitted. If <code>NA</code>, numeric values outside
integer range are coerced to <code>NA_integer_</code>, silently.</p>
</td></tr>
<tr><td><code id="character2integer_+3A_option">option</code></td>
<td>
<p>Control behaviour:
</p>

<dl>
<dt>0</dt><dd><p>Strip commas.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='coalesce0'>Convenience function for coalescing to zero</h2><span id='topic+coalesce0'></span><span id='topic+COALESCE0'></span>

<h3>Description</h3>

<p>Convenience function for coalescing to zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce0(x, nThread = getOption("hutilscpp.nThread", 1L))

COALESCE0(x, nThread = getOption("hutilscpp.nThread", 1L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coalesce0_+3A_x">x</code></td>
<td>
<p>An atomic vector. Or a list for <code>COALESCE0</code>.</p>
</td></tr>
<tr><td><code id="coalesce0_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent to <code>hutils::coalesce(x, 0)</code> for
an appropriate type of zero. <code>COALESCE0(x)</code>
</p>
<p>For complex numbers, each component is coalesced. For unsupported
types, the vector is returned, silently.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coalesce0(c(NA, 2:3))
coalesce0(NaN + 1i)

</code></pre>

<hr>
<h2 id='Comma'>Faster version of <code>scales::comma</code></h2><span id='topic+Comma'></span>

<h3>Description</h3>

<p>Faster version of <code>scales::comma</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Comma(x, digits = 0L, big.mark = c(",", " ", "'", "_", "~", "\"", "/"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Comma_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="Comma_+3A_digits">digits</code></td>
<td>
<p>An integer, similar to <code>round</code>.</p>
</td></tr>
<tr><td><code id="Comma_+3A_big.mark">big.mark</code></td>
<td>
<p>A single character, the thousands separator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Similar to <code>prettyNum(round(x, digits), big.mark = ',')</code> but rounds down
and <code>-1 &lt; x &lt; 0</code> will output <code>"-0"</code>.
</p>

<hr>
<h2 id='count_logical'>Count logicals</h2><span id='topic+count_logical'></span>

<h3>Description</h3>

<p>Count the number of <code>FALSE</code>, <code>TRUE</code>, and <code>NA</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_logical(x, nThread = getOption("hutilscpp.nThread", 1L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_logical_+3A_x">x</code></td>
<td>
<p>A logical vector.</p>
</td></tr>
<tr><td><code id="count_logical_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 3 elements: the number of <code>FALSE</code>, <code>TRUE</code>, and
<code>NA</code> values in <code>x</code>.
</p>

<hr>
<h2 id='cumsum_reset'>Cumulative sum unless reset</h2><span id='topic+cumsum_reset'></span>

<h3>Description</h3>

<p>Cumulative sum unless reset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumsum_reset(x, y = as.integer(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumsum_reset_+3A_x">x</code></td>
<td>
<p>A logical vector indicating when the sum should <em>continue</em>.
Missing values in <code>x</code> is an error.</p>
</td></tr>
<tr><td><code id="cumsum_reset_+3A_y">y</code></td>
<td>
<p>Optional: a numeric vector the same length as <code>x</code> to cumulatively sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of cumulative sums,
resetting whenever <code>x</code> is <code>FALSE</code>.
The return type is double if <code>y</code> is double; otherwise an integer vector. Integer
overflow wraps around, rather than being promoted to double type, as this
function is intended for 'shortish' runs of cumulative sums.
</p>
<p>If <code>length(x) == 0</code>, <code>y</code> is returned (i.e. <code>integer(0)</code> or <code>double(0)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cumsum_reset(c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE))
cumsum_reset(c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE),
             c(1000, 1000, 10000,   10,   20,   33,     0))

</code></pre>

<hr>
<h2 id='diam'>What is the diameter of set of points?</h2><span id='topic+diam'></span><span id='topic+thinner'></span>

<h3>Description</h3>

<p>Equivalent to <code>diff(minmax(x))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diam(x, nThread = getOption("hutilscpp.nThread", 1L))

thinner(x, width, nThread = getOption("hutilscpp.nThread", 1L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diam_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="diam_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="diam_+3A_width">width</code></td>
<td>
<p><code>numeric(1)</code> (For <code>thinner</code>, the maximum width)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value:
</p>

<dl>
<dt><code>diam</code></dt><dd><p>The difference of <code>minmax(x)</code></p>
</dd>
<dt><code>thinner</code></dt><dd><p>Equivalent to <code>diam(x) &lt;= width</code></p>
</dd>
</dl>


<hr>
<h2 id='divisible'>Divisibility</h2><span id='topic+divisible'></span><span id='topic+divisible2'></span><span id='topic+divisible16'></span>

<h3>Description</h3>

<p>Divisibility
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divisible(x, d, nThread = getOption("hutilscpp.nThread", 1L))

divisible2(x, nThread = getOption("hutilscpp.nThread", 1L))

divisible16(x, nThread = getOption("hutilscpp.nThread", 1L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="divisible_+3A_x">x</code></td>
<td>
<p>An integer vector</p>
</td></tr>
<tr><td><code id="divisible_+3A_d">d</code></td>
<td>
<p><code>integer(1)</code>. The divisor.</p>
</td></tr>
<tr><td><code id="divisible_+3A_nthread">nThread</code></td>
<td>
<p>The number of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector: <code>TRUE</code> where <code>x</code> is divisible by <code>d</code>.
</p>
<p><code>divisible2</code>,<code>divisible16</code> are short for (and quicker than)
<code>divisible(x, 2)</code> and <code>divisble(x, 16)</code>.
</p>

<hr>
<h2 id='every_int'>Every integer</h2><span id='topic+every_int'></span>

<h3>Description</h3>

<p>Every integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>every_int(nThread = getOption("hutilsc.nThread", 1L), na = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="every_int_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
<tr><td><code id="every_int_+3A_na">na</code></td>
<td>
<p>Value for <code>NA_INTEGER</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='fmatchp'>Parallel fastmatching</h2><span id='topic+fmatchp'></span><span id='topic+finp'></span><span id='topic+fnotinp'></span>

<h3>Description</h3>

<p><code>fastmatch::fmatch</code> and logical versions, with parallelization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmatchp(
  x,
  table,
  nomatch = NA_integer_,
  nThread = getOption("hutilscpp.nThread", 1L),
  fin = FALSE,
  whichFirst = 0L,
  .raw = 0L
)

finp(x, table, nThread = getOption("hutilscpp.nThread", 1L), .raw = 0L)

fnotinp(x, table, nThread = getOption("hutilscpp.nThread", 1L), .raw = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmatchp_+3A_x">x</code>, <code id="fmatchp_+3A_table">table</code>, <code id="fmatchp_+3A_nomatch">nomatch</code></td>
<td>
<p>As in <code>match</code>.</p>
</td></tr>
<tr><td><code id="fmatchp_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="fmatchp_+3A_fin">fin</code></td>
<td>
<p><code>TRUE | FALSE</code> Behaviour of return value when value found in
<code>table</code>. If <code>FALSE</code>, return the index of <code>table</code>;
if <code>TRUE</code>, return <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fmatchp_+3A_whichfirst">whichFirst</code></td>
<td>
<p><code>integer(1)</code> If <code>0L</code>, not used. If positive,
returns the index of the first element in <code>x</code> found in <code>table</code>;
if negative, returns the last element in <code>x</code> found in <code>table</code>.</p>
</td></tr>
<tr><td><code id="fmatchp_+3A_.raw">.raw</code></td>
<td>
<p><code>integer(1)</code>
</p>

<dl>
<dt>0</dt><dd><p>Return integer or logical as required.</p>
</dd>
<dt>1</dt><dd><p>Return raw if possible.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1L, 4:5)
y &lt;- c(2L, 4:5)
fmatchp(x, y)
fmatchp(x, y, nomatch = 0L)
finp(x, y)

</code></pre>

<hr>
<h2 id='helper'>Helper</h2><span id='topic+helper'></span>

<h3>Description</h3>

<p>Helper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="helper_+3A_expr">expr</code></td>
<td>
<p>An expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expression evaluated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x6 &lt;- 1:6
helper(x6 + 1)

</code></pre>

<hr>
<h2 id='Implies'>Implies</h2><span id='topic+Implies'></span>

<h3>Description</h3>

<p>Implies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Implies(x, y, anyNAx = TRUE, anyNAy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Implies_+3A_x">x</code>, <code id="Implies_+3A_y">y</code></td>
<td>
<p>Logical vectors of equal length.</p>
</td></tr>
<tr><td><code id="Implies_+3A_anynax">anyNAx</code>, <code id="Implies_+3A_anynay">anyNAy</code></td>
<td>
<p>Whether <code>x,y</code> may contain <code>NA</code>.
If <code>FALSE</code>, the function runs faster, but under that assumption.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical implies: <code>TRUE</code> unless <code>x</code> is <code>TRUE</code> and <code>y</code> is <code>FALSE</code>.
</p>
<p><code>NA</code> in either <code>x</code> or <code>y</code> results in <code>NA</code> if and only if the result is unknown.
In particular <code>NA %implies% TRUE</code> is <code>TRUE</code> and <code>FALSE %implies% NA</code> is <code>TRUE</code>.
</p>
<p>If <code>x</code> or <code>y</code> are length-one, the function proceeds as if the length-one vector were recycled
to the length of the other.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
CJ(x = c(TRUE,
         FALSE),
   y = c(TRUE,
         FALSE))[, ` x =&gt; y` := Implies(x, y)][]

#&gt;        x     y  x =&gt; y
#&gt; 1: FALSE FALSE    TRUE
#&gt; 2: FALSE  TRUE    TRUE
#&gt; 3:  TRUE FALSE   FALSE
#&gt; 4:  TRUE  TRUE    TRUE

# NA results:
#&gt; 5:    NA    NA      NA
#&gt; 6:    NA FALSE      NA
#&gt; 7:    NA  TRUE    TRUE
#&gt; 8: FALSE    NA    TRUE
#&gt; 9:  TRUE    NA      NA
</code></pre>

<hr>
<h2 id='is_constant'>Is a vector constant?</h2><span id='topic+is_constant'></span><span id='topic+isntConstant'></span>

<h3>Description</h3>

<p>Efficiently decide whether an atomic vector is constant; that is,
contains only one value.
</p>
<p>Equivalent to
</p>
<p><code>data.table::uniqueN(x) == 1L</code>
</p>
<p>or
</p>
<p><code>forecast::is.constant(x)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_constant(x, nThread = getOption("hutilscpp.nThread", 1L))

isntConstant(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_constant_+3A_x">x</code></td>
<td>
<p>An atomic vector. Only logical, integer, double, and character
vectors are supported. Others may work but have not been tested.</p>
</td></tr>
<tr><td><code id="is_constant_+3A_nthread">nThread</code></td>
<td>

<dl>
<dt><code>integer(1)</code></dt><dd><p>Number of threads to use in <code>is_constant</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Whether or not the vector <code>x</code> is constant:
</p>

<dl>
<dt><code>is_constant</code></dt><dd><p><code>TRUE</code> or <code>FALSE</code>. Missing values are considered to
be the same as each other, so a vector entirely composed of missing values is
considered constant. Note that <code>is_constant(c(NA_real_, NaN))</code> is <code>TRUE</code>.</p>
</dd>
<dt><code>isntConstant</code></dt><dd><p>If constant, <code>0L</code>; otherwise, the first integer position at
which <code>x</code> has a different value to the first.
</p>
<p>This has the virtue of <code>!isntConstant(x) == is_constant(x)</code>.</p>
</dd>
</dl>

<p>Multithreaded <code>is_constant(x, nThread)</code> should only be used if
<code>x</code> is expected to be true. It will be faster when
<code>x</code> is constant but much slower otherwise.
</p>
<p>Empty vectors are constant, as are length-one vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(hutilscpp)
library(data.table)
setDTthreads(1L)
N &lt;- 1e9L
N &lt;- 1e6  # to avoid long-running examples on CRAN

## Good-cases
nonconst &lt;- c(integer(1e5), 13L, integer(N))
bench_system_time(uniqueN(nonconst) == 1L)
#&gt; process    real
#&gt; 15.734s  2.893s
bench_system_time(is_constant(nonconst))
#&gt; process    real
#&gt;   0.000   0.000
bench_system_time(isntConstant(nonconst))
#&gt; process    real
#&gt;   0.000   0.000

## Worst-cases
consti &lt;- rep(13L, N)
bench_system_time(uniqueN(consti) == 1L)
#&gt; process    real
#&gt;  5.734s  1.202s
bench_system_time(is_constant(consti))
#&gt;   process      real
#&gt; 437.500ms 437.398ms
bench_system_time(isntConstant(consti))
#&gt;   process      real
#&gt; 437.500ms 434.109ms

nonconsti &lt;- c(consti, -1L)
bench_system_time(uniqueN(nonconsti) == 1L)
#&gt; process    real
#&gt; 17.812s  3.348s
bench_system_time(is_constant(nonconsti))
#&gt;   process      real
#&gt; 437.500ms 431.104ms
bench_system_time(isntConstant(consti))
#&gt;   process      real
#&gt; 484.375ms 487.588ms

constc &lt;- rep("a", N)
bench_system_time(uniqueN(constc) == 1L)
#&gt; process    real
#&gt; 11.141s  3.580s
bench_system_time(is_constant(constc))
#&gt; process    real
#&gt;  4.109s  4.098s

nonconstc &lt;- c(constc, "x")
bench_system_time(uniqueN(nonconstc) == 1L)
#&gt; process    real
#&gt; 22.656s  5.629s
bench_system_time(is_constant(nonconstc))
#&gt; process    real
#&gt;  5.906s  5.907s


</code></pre>

<hr>
<h2 id='is_sorted'>Is a vector sorted?</h2><span id='topic+is_sorted'></span><span id='topic+isntSorted'></span>

<h3>Description</h3>

<p>Is a vector sorted?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_sorted(x, asc = NA)

isntSorted(x, asc = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_sorted_+3A_x">x</code></td>
<td>
<p>An atomic vector.</p>
</td></tr>
<tr><td><code id="is_sorted_+3A_asc">asc</code></td>
<td>
<p>Single logical. If <code>NA</code>, the default, a vector is considered
sorted if it is either sorted ascending or sorted descending;
if <code>FALSE</code>, a vector is sorted only if sorted descending;
if <code>TRUE</code>, a vector is sorted only if sorted ascending.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_sorted</code> returns <code>TRUE</code> or <code>FALSE</code>
</p>
<p><code>isntSorted</code> returns <code>0</code> if sorted or the first position
that proves the vector is not sorted
</p>

<hr>
<h2 id='logical3'>Vectorized logical with support for short-circuits</h2><span id='topic+logical3'></span><span id='topic+and3'></span><span id='topic+or3'></span>

<h3>Description</h3>

<p>Vectorized logical with support for short-circuits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>and3(x, y, z = NULL, nas_absent = FALSE)

or3(x, y, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logical3_+3A_x">x</code>, <code id="logical3_+3A_y">y</code>, <code id="logical3_+3A_z">z</code></td>
<td>
<p>Logical vectors. If <code>z</code> is <code>NULL</code> the function is equivalent to the
binary versions; only <code>x</code> and <code>y</code> are used.</p>
</td></tr>
<tr><td><code id="logical3_+3A_nas_absent">nas_absent</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) Can it be assumed that <code>x,y,z</code> have
no missing values? Set to <code>TRUE</code> when you are sure that that is the case; setting to
<code>TRUE</code> falsely has no defined behaviour.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>and3</code>, the same as <code>x &amp; y &amp; z</code>;
for <code>or3</code>, the same as <code>x | y | z</code>, designed to be efficient when component-wise
short-circuiting is available.
</p>

<hr>
<h2 id='logical3s'>Complex logical expressions</h2><span id='topic+logical3s'></span><span id='topic+and3s'></span><span id='topic+or3s'></span>

<h3>Description</h3>

<p>Performant implementations of <code>&amp;</code> et <code>or</code>.
Performance is high when the expressions are long (i.e. over 10M elements)
and in particular when they are of the form <code>lhs &lt;op&gt; rhs</code> for binary
<code>&lt;op&gt;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>and3s(
  exprA,
  exprB = NULL,
  exprC = NULL,
  ...,
  nThread = getOption("hutilscpp.nThread", 1L),
  .parent_nframes = 1L,
  type = c("logical", "raw", "which")
)

or3s(
  exprA,
  exprB = NULL,
  exprC = NULL,
  ...,
  nThread = getOption("hutilscpp.nThread", 1L),
  .parent_nframes = 1L,
  type = c("logical", "raw", "which")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logical3s_+3A_expra">exprA</code>, <code id="logical3s_+3A_exprb">exprB</code>, <code id="logical3s_+3A_exprc">exprC</code>, <code id="logical3s_+3A_...">...</code></td>
<td>
<p>Expressions of the form <code>x &lt;op&gt; y</code>.
with <code>&lt;op&gt;</code> one of the standard binary operators.
</p>
<p>Only <code>exprA</code> is required, all following expressions are optional.</p>
</td></tr>
<tr><td><code id="logical3s_+3A_nthread">nThread</code></td>
<td>

<dl>
<dt><code>integer(1)</code></dt><dd><p>Number of threads to use.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="logical3s_+3A_.parent_nframes">.parent_nframes</code></td>
<td>

<dl>
<dt><code>integer(1)</code></dt><dd><p>For internal use. Passed to <code>eval.parent</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="logical3s_+3A_type">type</code></td>
<td>
<p>The type of the result. <code>which</code> corresponds to the
indices of <code>TRUE</code> in the result. Type <code>raw</code> is available
for a memory-constrained result, though the result will not be
interpreted as logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>and3s</code> and <code>or3s</code> return <code>exprA &amp; exprB &amp; exprC</code> and
<code>exprA | exprB | exprC</code> respectively. If any expression is missing
it is considered <code>TRUE</code> for <code>and3s</code> and <code>FALSE</code> for <code>or3s</code>;
in other words only the results of the other expressions count towards the result.
</p>

<hr>
<h2 id='match_nrst_haversine'>Match coordinates to nearest coordinates</h2><span id='topic+match_nrst_haversine'></span>

<h3>Description</h3>

<p>When geocoding coordinates to known addresses, an efficient way to
match the given coordinates with the known is necessary. This function provides this
efficiency by using <code>C++</code> and allowing approximate matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_nrst_haversine(
  lat,
  lon,
  addresses_lat,
  addresses_lon,
  Index = seq_along(addresses_lat),
  cartesian_R = NULL,
  close_enough = 10,
  excl_self = FALSE,
  as.data.table = TRUE,
  .verify_box = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_nrst_haversine_+3A_lat">lat</code>, <code id="match_nrst_haversine_+3A_lon">lon</code></td>
<td>
<p>Coordinates to be geocoded. Numeric vectors of equal length.</p>
</td></tr>
<tr><td><code id="match_nrst_haversine_+3A_addresses_lat">addresses_lat</code>, <code id="match_nrst_haversine_+3A_addresses_lon">addresses_lon</code></td>
<td>
<p>Coordinates of known locations. Numeric vectors of equal length
(likely to be a different length than the length of <code>lat</code>, except when <code>excl_self = TRUE</code>).</p>
</td></tr>
<tr><td><code id="match_nrst_haversine_+3A_index">Index</code></td>
<td>
<p>A vector the same length as <code>lat</code> to encode the match between <code>lat,lon</code>
and <code>addresses_lat,addresses_lon</code>. The default is to use the integer position
of the nearest match to
<code>addresses_lat,addresses_lon</code>.</p>
</td></tr>
<tr><td><code id="match_nrst_haversine_+3A_cartesian_r">cartesian_R</code></td>
<td>
<p>The maximum radius of any address from the points to be geocoded. Used
to accelerate the detection of minimum distances. Note, as the argument name suggests,
the distance is in cartesian coordinates, so a small number is likely.</p>
</td></tr>
<tr><td><code id="match_nrst_haversine_+3A_close_enough">close_enough</code></td>
<td>
<p>The distance, in metres, below which a match will be considered to have occurred.
(The distance that is considered &quot;close enough&quot; to be a match.)
</p>
<p>For example, <code>close_enough = 10</code> means the first location within ten metres will be matched,
even if a closer match occurs later.
</p>
<p>May be provided as a string to emphasize the units, e.g. <code>close_enough = "0.25km"</code>.
Only <code>km</code> and <code>m</code> are permitted.</p>
</td></tr>
<tr><td><code id="match_nrst_haversine_+3A_excl_self">excl_self</code></td>
<td>
<p>(bool, default: <code>FALSE</code>) For each <code class="reqn">x_i</code> of the first coordinates,
exclude the <code class="reqn">y_i</code>-th point when determining closest match. Useful to determine the
nearest neighbour within a set of coordinates, <em>viz.</em>
<code>match_nrst_haversine(x, y, x, y, excl_self = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="match_nrst_haversine_+3A_as.data.table">as.data.table</code></td>
<td>
<p>Return result as a <code>data.table</code>?
If <code>FALSE</code>, a list is returned. <code>TRUE</code> by default to
avoid dumping a huge list to the console.</p>
</td></tr>
<tr><td><code id="match_nrst_haversine_+3A_.verify_box">.verify_box</code></td>
<td>
<p>Check the initial guess against other points within the
box of radius <code class="reqn">\ell^\infty</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (or <code>data.table</code> if <code>as.data.table = TRUE</code>) with two elements,
both the same length as <code>lat</code>, giving for point <code>lat,lon</code>:
</p>

<dl>
<dt><code>pos</code></dt><dd><p>the position (or corresponding value in <code>Table</code>)
in <code>addresses_lat,addresses_lon</code> nearest to <code>lat, lon</code>.</p>
</dd>
<dt><code>dist</code></dt><dd><p>the distance, in kilometres, between the two points.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>lat2 &lt;- runif(5, -38, -37.8)
lon2 &lt;- rep(145, 5)

lat1 &lt;- c(-37.875, -37.91)
lon1 &lt;- c(144.96, 144.978)

match_nrst_haversine(lat1, lon1, lat2, lon2)
match_nrst_haversine(lat1, lon1, lat1, lon1, 11:12, excl_self = TRUE)

</code></pre>

<hr>
<h2 id='minmax'>Minimum and maximum</h2><span id='topic+minmax'></span>

<h3>Description</h3>

<p>Minimum and maximum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minmax(x, empty_result = NULL, nThread = getOption("hutilscpp.nThread", 1L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minmax_+3A_x">x</code></td>
<td>
<p>An atomic vector.</p>
</td></tr>
<tr><td><code id="minmax_+3A_empty_result">empty_result</code></td>
<td>
<p>What should be returned when <code>length(x) == 0</code>?</p>
</td></tr>
<tr><td><code id="minmax_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of two elements, the minimum and maximum of <code>x</code>, or <code>NULL</code>.
</p>

<hr>
<h2 id='ModeC'>Most common element</h2><span id='topic+ModeC'></span>

<h3>Description</h3>

<p>Most common element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModeC(
  x,
  nThread = getOption("hutilscpp.nThread", 1L),
  .range_fmatch = 1000000000,
  option = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ModeC_+3A_x">x</code></td>
<td>
<p>An atomic vector.</p>
</td></tr>
<tr><td><code id="ModeC_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="ModeC_+3A_.range_fmatch">.range_fmatch</code></td>
<td>
<p>If the range of <code>x</code> differs by more than
this amount, the mode will be calculated via <code>fmatchp</code>.</p>
</td></tr>
<tr><td><code id="ModeC_+3A_option">option</code></td>
<td>
<p><code>integer(1)</code> Handle exceptional cases:
</p>

<dl>
<dt>0</dt><dd><p>Returns <code>NULL</code> quietly.</p>
</dd>
<dt>1</dt><dd><p>Returns an error if the mode cannot be calculated.</p>
</dd>
<dt>2</dt><dd><p>Emits a warning if the mode cannot be calculate, falls back to <code>hutils::Mode</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ModeC(c(1L, 1L, 2L))


</code></pre>

<hr>
<h2 id='pmaxC'>Parallel maximum/minimum</h2><span id='topic+pmaxC'></span><span id='topic+pminC'></span><span id='topic+pmaxV'></span><span id='topic+pminV'></span><span id='topic+pmax0'></span><span id='topic+pmin0'></span><span id='topic+pmax3'></span><span id='topic+pmin3'></span>

<h3>Description</h3>

<p>Faster <code>pmax()</code> and <code>pmin()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmaxC(
  x,
  a,
  in_place = FALSE,
  keep_nas = FALSE,
  dbl_ok = NA,
  nThread = getOption("hutilscpp.nThread", 1L)
)

pminC(
  x,
  a,
  in_place = FALSE,
  keep_nas = FALSE,
  dbl_ok = NA,
  nThread = getOption("hutilscpp.nThread", 1L)
)

pmax0(
  x,
  in_place = FALSE,
  sorted = FALSE,
  keep_nas = FALSE,
  nThread = getOption("hutilscpp.nThread", 1L)
)

pmin0(
  x,
  in_place = FALSE,
  sorted = FALSE,
  keep_nas = FALSE,
  nThread = getOption("hutilscpp.nThread", 1L)
)

pmaxV(
  x,
  y,
  in_place = FALSE,
  dbl_ok = TRUE,
  nThread = getOption("hutilscpp.nThread", 1L)
)

pminV(
  x,
  y,
  in_place = FALSE,
  dbl_ok = TRUE,
  nThread = getOption("hutilscpp.nThread", 1L)
)

pmax3(x, y, z, in_place = FALSE)

pmin3(x, y, z, in_place = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmaxC_+3A_x">x</code></td>
<td>

<dl>
<dt><code>numeric(n)</code></dt><dd><p>A numeric vector.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pmaxC_+3A_a">a</code></td>
<td>
<dl>
<dt><code>numeric(1)</code></dt><dd><p>A single numeric value.</p>
</dd></dl>
</td></tr>
<tr><td><code id="pmaxC_+3A_in_place">in_place</code></td>
<td>

<dl>
<dt><code>TRUE | FALSE</code>, default: <code>FALSE</code></dt><dd><p>Should <code>x</code> be modified in-place? For advanced use only.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pmaxC_+3A_keep_nas">keep_nas</code></td>
<td>

<dl>
<dt><code>TRUE | FALSE</code>, default: <code>FALSE</code></dt><dd><p>Should <code>NA</code>s values be
preserved? By default, <code>FALSE</code>, so the behaviour of the function is
dependent on the representation of <code>NA</code>s at the C++ level.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pmaxC_+3A_dbl_ok">dbl_ok</code></td>
<td>

<dl>
<dt><code>logical(1)</code>, default: <code>NA</code></dt><dd><p>Is it acceptable to return
a non-integer vector if <code>x</code> is integer?
</p>
<p>This argument will have effect <code>a</code> is both double and cannot be coerced to
<code>integer</code>:
</p>
<p>If <code>NA</code>, the default, a message is emitted whenever a double vector
needs to be returned.
If <code>FALSE</code>, an error is returned.
If <code>TRUE</code>, neither an error nor a message is returned.
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pmaxC_+3A_nthread">nThread</code></td>
<td>

<dl>
<dt><code>integer(1)</code></dt><dd><p>The number of threads to use. Combining <code>nThread &gt; 1</code>
and <code>in_place = TRUE</code> is not supported.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pmaxC_+3A_sorted">sorted</code></td>
<td>

<dl>
<dt><code>TRUE | FALSE</code>, default: <code>FALSE</code></dt><dd>
<p>Is <code>x</code> known to be sorted?
If <code>TRUE</code>, <code>x</code> is assumed to be sorted. Thus the
first zero determines whether the position at which zeroes start or end.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pmaxC_+3A_y">y</code>, <code id="pmaxC_+3A_z">z</code></td>
<td>
<dl>
<dt><code>numeric(n)</code></dt><dd><p>Other numeric vectors the same length as <code>x</code></p>
</dd></dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Versions of <code>pmax</code> and <code>pmin</code>, designed for performance.
</p>
<p>When <code>in_place = TRUE</code>, the values of <code>x</code> are modified in-place.
For advanced users only.
</p>
<p>The differences are:
</p>

<dl>
<dt><code>pmaxC(x, a)</code> and <code>pminC(x, a)</code></dt><dd><p>Both <code>x</code> and <code>a</code> must be numeric and
<code>a</code> must be length-one.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This function will always be faster than <code>pmax(x, a)</code> when <code>a</code> is
a single value, but can be slower than <code>pmax.int(x, a)</code> when <code>x</code> is short.
Use this function when comparing a numeric vector with a single value.
</p>
<p>Use <code>in_place = TRUE</code> only within functions when you are sure it is safe, i.e. not a
reference to something outside the environment.
</p>
<p>By design, the functions first check whether <code>x</code> will be modified before
allocating memory to a new vector. For example, if all values in <code>x</code> are
nonnegative, the vector is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pmaxC(-5:5, 2)
pmaxC(1:4, 5.5)
pmaxC(1:4, 5.5, dbl_ok = TRUE)
# pmaxC(1:4, 5.5, dbl_ok = FALSE)  # error

</code></pre>

<hr>
<h2 id='poleInaccessibility'>Find a binary pole of inaccessibility</h2><span id='topic+poleInaccessibility'></span><span id='topic+poleInaccessibility2'></span><span id='topic+poleInaccessibility3'></span>

<h3>Description</h3>

<p>Find a binary pole of inaccessibility
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poleInaccessibility2(
  x = NULL,
  y = NULL,
  DT = NULL,
  x_range = NULL,
  y_range = NULL,
  copy_DT = TRUE
)

poleInaccessibility3(
  x = NULL,
  y = NULL,
  DT = NULL,
  x_range = NULL,
  y_range = NULL,
  copy_DT = TRUE,
  test_both = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poleInaccessibility_+3A_x">x</code>, <code id="poleInaccessibility_+3A_y">y</code></td>
<td>
<p>Coordinates.</p>
</td></tr>
<tr><td><code id="poleInaccessibility_+3A_dt">DT</code></td>
<td>
<p>A <code>data.table</code> containing <code>LONGITUDE</code> and <code>LATITUDE</code> to define
the <code>x</code> and <code>y</code> coordinates.</p>
</td></tr>
<tr><td><code id="poleInaccessibility_+3A_x_range">x_range</code>, <code id="poleInaccessibility_+3A_y_range">y_range</code></td>
<td>
<p>Numeric vectors of length-2; the range of <code>x</code> and <code>y</code>.
Use this rather than the default when the 'vicinity' of <code>x,y</code> is different from
the minimum closed rectangle covering the points.</p>
</td></tr>
<tr><td><code id="poleInaccessibility_+3A_copy_dt">copy_DT</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Run <code><a href="data.table.html#topic+copy">copy</a></code> on <code>DT</code>
before proceeding. If <code>FALSE</code>, <code>DT</code> have additional columns updated by reference.</p>
</td></tr>
<tr><td><code id="poleInaccessibility_+3A_test_both">test_both</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) For <code>3</code>, test both stretching vertically
then horizontally and horizontally then vertically.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>poleInaccessibility2</code></dt><dd>
<p>A named vector containing the
<code>xmin</code>, <code>xmax</code> and
<code>ymin</code>, <code>ymax</code> coordinates of
the largest rectangle of width an integer power of two that is empty.</p>
</dd>
<dt><code>poleInaccessibility3</code></dt><dd>
<p>Starting with the rectangle formed by <code>poleInaccessibility2</code>,
the rectangle formed by stretching it out vertically and horizontally until
the edges intersect the points <code>x,y</code>
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
library(hutils)
# A square with a 10 by 10 square of the northeast corner removed
x &lt;- runif(1e4, 0, 100)
y &lt;- runif(1e4, 0, 100)
DT &lt;- data.table(x, y)
# remove the NE corner
DT_NE &lt;- DT[implies(x &gt; 90, y &lt; 89)]
DT_NE[, poleInaccessibility2(x, y)]
DT_NE[, poleInaccessibility3(x, y)]

</code></pre>

<hr>
<h2 id='range_rcpp'>Range C++</h2><span id='topic+range_rcpp'></span>

<h3>Description</h3>

<p>Range of a vector using Rcpp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_rcpp(
  x,
  anyNAx = anyNA(x),
  warn_empty = TRUE,
  integer0_range_is_integer = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="range_rcpp_+3A_x">x</code></td>
<td>
<p>A vector for which the range is desired. Vectors with missing values
are not supported and have no definite behaviour.</p>
</td></tr>
<tr><td><code id="range_rcpp_+3A_anynax">anyNAx</code></td>
<td>
<p>(logical, default: <code>anyNA(x)</code> lazily). Set to <code>TRUE</code>
only if <code>x</code> is known to contain no missing values (including <code>NaN</code>).</p>
</td></tr>
<tr><td><code id="range_rcpp_+3A_warn_empty">warn_empty</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) If <code>x</code> is
empty (i.e. has no length), should a warning be emitted (like <code><a href="base.html#topic+range">range</a></code>)?</p>
</td></tr>
<tr><td><code id="range_rcpp_+3A_integer0_range_is_integer">integer0_range_is_integer</code></td>
<td>
<p>(logical, default: <code>FALSE</code>)
If <code>x</code> is a length-zero integer, should the result also be an integer?
Set to <code>FALSE</code> by default in order to be compatible with <code><a href="base.html#topic+range">range</a></code>, but can
be set to <code>TRUE</code> if an integer result is desired, in which case
<code>range_rcpp(integer())</code> is <code>(INT_MAX, -INT_MAX)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-4 vector, the first two positions give the range and
the next two give the positions in <code>x</code> where the max and min occurred.
</p>
<p>This is almost equivalent to <code>c(range(x), which.min(x), which.max(x))</code>.
Note that the type is not strictly preserved, but no loss should occur. In particular,
logical <code>x</code> results in an integer result, and a double <code>x</code> will
have double values for <code>which.min(x)</code> and <code>which.max(x)</code>.
</p>
<p>A completely empty, logical <code>x</code> returns <code>c(NA, NA, NA, NA)</code> as an integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1e3) # Not noticeable at this scale
bench_system_time(range_rcpp(x))
bench_system_time(range(x))



</code></pre>

<hr>
<h2 id='squish'>Squish into a range</h2><span id='topic+squish'></span>

<h3>Description</h3>

<p>Squish into a range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squish(x, a, b, in_place = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="squish_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="squish_+3A_a">a</code>, <code id="squish_+3A_b">b</code></td>
<td>
<p>Upper and lower bounds</p>
</td></tr>
<tr><td><code id="squish_+3A_in_place">in_place</code></td>
<td>
<p>(logical, default: <code>FALSE</code>) Should the function operate on <code>x</code> in place?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric/integer vector with the values of <code>x</code> &quot;squished&quot; between <code>a</code>
and <code>b</code>; values above <code>b</code>
replaced with <code>b</code> and values below <code>a</code> replaced with <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>squish(-5:5,-1L, 1L)

</code></pre>

<hr>
<h2 id='sum_and3s'>Sum of logical expressions</h2><span id='topic+sum_and3s'></span><span id='topic+sum_or3s'></span>

<h3>Description</h3>

<p>Sum of logical expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_and3s(
  exprA,
  exprB,
  exprC,
  ...,
  nThread = getOption("hutilscpp.nThread", 1L),
  .env = parent.frame()
)

sum_or3s(
  exprA,
  exprB,
  exprC,
  ...,
  .env = parent.frame(),
  nThread = getOption("hutilscpp.nThread", 1L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum_and3s_+3A_expra">exprA</code>, <code id="sum_and3s_+3A_exprb">exprB</code>, <code id="sum_and3s_+3A_exprc">exprC</code>, <code id="sum_and3s_+3A_...">...</code></td>
<td>
<p>Expressions of the form <code>x &lt;op&gt; y</code>.
with <code>&lt;op&gt;</code> one of the standard binary operators.</p>
</td></tr>
<tr><td><code id="sum_and3s_+3A_nthread">nThread</code></td>
<td>

<dl>
<dt><code>integer(1)</code></dt><dd><p>Number of threads to use.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sum_and3s_+3A_.env">.env</code></td>
<td>
<p>The environment in which the expressions are to be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent to <code>sum(exprA &amp; exprB &amp; exprC)</code> or
<code>sum(exprA | exprB | exprC)</code> as desired.
</p>

<hr>
<h2 id='sum_isna'>Number of missing values</h2><span id='topic+sum_isna'></span>

<h3>Description</h3>

<p>The count of missing values in an atomic vector, equivalent to
to <code>sum(is.na(x))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_isna(x, do_anyNA = TRUE, nThread = getOption("hutilscpp.nThread", 1L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum_isna_+3A_x">x</code></td>
<td>
<p>An atomic vector.</p>
</td></tr>
<tr><td><code id="sum_isna_+3A_do_anyna">do_anyNA</code></td>
<td>
<p>Should <code>anyNA(x)</code> be executed before an attempt to
count the <code>NA</code>'s in <code>x</code> one-by-one? By default, set to <code>TRUE</code>,
since it is generally quicker. It will only be slower when <code>NA</code> is rare
and occurs late in <code>x</code>.
</p>
<p>Ignored silently if <code>nThread != 1</code>.</p>
</td></tr>
<tr><td><code id="sum_isna_+3A_nthread">nThread</code></td>
<td>

<dl>
<dt><code>nThread</code></dt><dd><p>Number of threads to use.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sum_isna(c(1:5, NA))
sum_isna(c(NaN, NA))  # 2 from v0.4.0 (Sep 2020)
</code></pre>

<hr>
<h2 id='unique_fmatch'>Distinct elements</h2><span id='topic+unique_fmatch'></span><span id='topic+uniqueN_fmatch'></span>

<h3>Description</h3>

<p>Using the <code>fastmatch</code> hash functions, determine
the unique elements of a vector, and the number of distinct elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_fmatch(x, nThread = getOption("hutilscpp.nThread", 1L))

uniqueN_fmatch(x, nThread = getOption("hutilscpp.nThread", 1L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unique_fmatch_+3A_x">x</code></td>
<td>
<p>An atomic vector.</p>
</td></tr>
<tr><td><code id="unique_fmatch_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Equivalent to <code>unique(x)</code> or <code>data.table::uniqueN(x)</code> respectively.
</p>

<hr>
<h2 id='which_first'>Where does a logical expression first return <code>TRUE</code>?</h2><span id='topic+which_first'></span><span id='topic+which_last'></span>

<h3>Description</h3>

<p>A faster and safer version of <code>which.max</code> applied
to simple-to-parse logical expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_first(
  expr,
  verbose = FALSE,
  reverse = FALSE,
  sexpr,
  eval_parent_n = 1L,
  suppressWarning = getOption("hutilscpp_suppressWarning", FALSE),
  use.which.max = FALSE
)

which_last(
  expr,
  verbose = FALSE,
  reverse = FALSE,
  suppressWarning = getOption("hutilscpp_suppressWarning", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_first_+3A_expr">expr</code></td>
<td>
<p>An expression, such as <code>x == 2</code>.</p>
</td></tr>
<tr><td><code id="which_first_+3A_verbose">verbose</code></td>
<td>

<dl>
<dt><code>logical(1)</code>, default: <code>FALSE</code></dt><dd><p>If <code>TRUE</code> a message is emitted
if <code>expr</code> could not be handled in the advertised way.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="which_first_+3A_reverse">reverse</code></td>
<td>

<dl>
<dt><code>logical(1)</code>, default: <code>FALSE</code></dt><dd><p>Scan <code>expr</code> in reverse.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="which_first_+3A_sexpr">sexpr</code></td>
<td>
<p>Equivalent to <code>substitute(expr)</code>. For internal use.</p>
</td></tr>
<tr><td><code id="which_first_+3A_eval_parent_n">eval_parent_n</code></td>
<td>
<p>Passed to <code>eval.parent</code>, the environment in which
<code>expr</code> is evaluated.</p>
</td></tr>
<tr><td><code id="which_first_+3A_suppresswarning">suppressWarning</code></td>
<td>
<p>Either a <code>FALSE</code> or <code>TRUE</code>, whether or not
warnings should be suppressed. Also supports a string input which suppresses a
warning if it matches as a regular expression.</p>
</td></tr>
<tr><td><code id="which_first_+3A_use.which.max">use.which.max</code></td>
<td>
<p>If <code>TRUE</code>, <code>which.max</code> is dispatched immediately,
even if <code>expr</code> would be amenable to separation. Useful when evaluating
many small <code>expr</code>'s when these are known in advance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>expr</code> is of the form <code>LHS &lt;operator&gt; RHS</code>
and <code>LHS</code> is a single symbol, <code>operator</code> is one of
<code>==</code>,  <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>%in%</code>,
or
<code>%between%</code>,
and <code>RHS</code> is numeric, then <code>expr</code> is not
evaluated directly; instead, each element of <code>LHS</code> is compared
individually.
</p>
<p>If <code>expr</code> is not of the above form, then <code>expr</code> is evaluated
and passed to <code>which.max</code>.
</p>
<p>Using this function can be significantly faster than the alternatives
when the computation
of <code>expr</code> would be expensive, though the difference is only likely to
be clear when <code>length(x)</code> is much larger than 10 million.
But even for smaller vectors, it has the benefit of returning
<code>0L</code> if none of the values in <code>expr</code> are <code>TRUE</code>, unlike
<code>which.max</code>.
</p>
<p>Compared to <code><a href="base.html#topic+funprog">Position</a></code> for an appropriate
choice of <code>f</code> the speed of <code>which_first</code> is not much faster
when the expression is <code>TRUE</code> for some position. However, <code>which_first</code>
is faster when all elements of <code>expr</code> are <code>FALSE</code>.
Thus <code>which_first</code> has a smaller worst-case time than the
alternatives for most <code>x</code>.
</p>
<p>Missing values on the RHS are handled specially.
<code>which_first(x %between% c(NA, 1))</code> for example is equivalent to
<code>which_first(x &lt;= 1)</code>, as in <code><a href="data.table.html#topic+between">data.table::between</a></code>.
</p>


<h3>Value</h3>

<p>The same as <code>which.max(expr)</code> or <code>which(expr)[1]</code> but returns <code>0L</code>
when <code>expr</code> has no <code>TRUE</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 1e5
# N &lt;- 1e8  ## too slow for CRAN

# Two examples, from slowest to fastest,
# run with N = 1e8 elements

                                       # seconds
x &lt;- rep_len(runif(1e4, 0, 6), N)
bench_system_time(x &gt; 5)
bench_system_time(which(x &gt; 5))        # 0.8
bench_system_time(which.max(x &gt; 5))    # 0.3
bench_system_time(which_first(x &gt; 5))  # 0.000

## Worst case: have to check all N elements
x &lt;- double(N)
bench_system_time(x &gt; 0)
bench_system_time(which(x &gt; 0))        # 1.0
bench_system_time(which.max(x &gt; 0))    # 0.4  but returns 1, not 0
bench_system_time(which_first(x &gt; 0))  # 0.1

x &lt;- as.character(x)
# bench_system_time(which(x == 5))     # 2.2
bench_system_time(which.max(x == 5))   # 1.6
bench_system_time(which_first(x == 5)) # 1.3

</code></pre>

<hr>
<h2 id='which_firstNA'>First/last position of missing values</h2><span id='topic+which_firstNA'></span><span id='topic+which_lastNA'></span>

<h3>Description</h3>

<p>Introduced in <code>v 1.6.0</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_firstNA(x)

which_lastNA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_firstNA_+3A_x">x</code></td>
<td>
<p>An atomic vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The position of the first/last missing value in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1e8
N &lt;- 1e6  # for CRAN etc
x &lt;- c(1:1e5, NA, integer(N))
bench_system_time(which.max(is.na(x))) # 123ms
bench_system_time(Position(is.na, x))  #  22ms
bench_system_time(which_firstNA(x))    #  &lt;1ms
</code></pre>

<hr>
<h2 id='which_true_onwards'>At which point are all values true onwards</h2><span id='topic+which_true_onwards'></span>

<h3>Description</h3>

<p>At which point are all values true onwards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_true_onwards(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_true_onwards_+3A_x">x</code></td>
<td>
<p>A logical vector. <code>NA</code> values are not permitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The position of the first <code>TRUE</code> value in <code>x</code> at which all
the following values are <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>which_true_onwards(c(TRUE, FALSE, TRUE, TRUE, TRUE))

</code></pre>

<hr>
<h2 id='which3'>which of three vectors are the elements (all, any) true?</h2><span id='topic+which3'></span>

<h3>Description</h3>

<p>which of three vectors are the elements (all, any) true?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which3(
  x,
  y,
  z,
  And = TRUE,
  anyNAx = anyNA(x),
  anyNAy = anyNA(y),
  anyNAz = anyNA(z)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which3_+3A_x">x</code>, <code id="which3_+3A_y">y</code>, <code id="which3_+3A_z">z</code></td>
<td>
<p>Logical vectors. Either the same length or length-1</p>
</td></tr>
<tr><td><code id="which3_+3A_and">And</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, only indices where all of x, y, z
are TRUE are returned; if <code>FALSE</code>, any index where x, y, z
are TRUE are returned.</p>
</td></tr>
<tr><td><code id="which3_+3A_anynax">anyNAx</code>, <code id="which3_+3A_anynay">anyNAy</code>, <code id="which3_+3A_anynaz">anyNAz</code></td>
<td>
<p>Whether or not the inputs have <code>NA</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='whichs'>Separated which</h2><span id='topic+whichs'></span>

<h3>Description</h3>

<p>Same as <code>which(exprA)</code> where <code>exprA</code> is a binary
expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whichs(
  exprA,
  .env = parent.frame(),
  nThread = getOption("hutilscpp.nThread", 1L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whichs_+3A_expra">exprA</code></td>
<td>
<p>An expression. Useful when of the form <code>a &lt;op&gt; b</code> for
<code>a</code> an atomic vector. Long expressions are not supported.</p>
</td></tr>
<tr><td><code id="whichs_+3A_.env">.env</code></td>
<td>
<p>The environment in which <code>exprA</code> is to be evaluated.</p>
</td></tr>
<tr><td><code id="whichs_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector, the indices of <code>exprA</code> that return <code>TRUE</code>.
</p>

<hr>
<h2 id='xor2'>Exclusive or</h2><span id='topic+xor2'></span>

<h3>Description</h3>

<p>Exclusive or
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xor2(x, y, anyNAx = TRUE, anyNAy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xor2_+3A_x">x</code>, <code id="xor2_+3A_y">y</code></td>
<td>
<p>Logical vectors.</p>
</td></tr>
<tr><td><code id="xor2_+3A_anynax">anyNAx</code>, <code id="xor2_+3A_anynay">anyNAy</code></td>
<td>
<p>Could <code>x</code> and <code>y</code> possibly contain <code>NA</code> values?
Only set to <code>FALSE</code> if known to be free of <code>NA</code>.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
