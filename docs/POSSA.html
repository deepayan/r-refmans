<!DOCTYPE html><html><head><title>Help for package POSSA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {POSSA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#POSSA-package'><p>POSSA: Power Simulation for Sequential Analyses</p></a></li>
<li><a href='#get_p'><p>Extract p-value from tests</p></a></li>
<li><a href='#pow'><p>Power calculation</p></a></li>
<li><a href='#print.possa_pow_df'><p>Print pow results data frame</p></a></li>
<li><a href='#print.possa_pow_list'><p>Print pow results</p></a></li>
<li><a href='#print.possa_sim_df'><p>Print sim results</p></a></li>
<li><a href='#sim'><p>Simulation procedure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Power Simulation for Sequential Analyses and Multiple Hypotheses</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-22</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates, via simulation, power and appropriate stopping
  alpha boundaries (and/or futility bounds) for sequential analyses (i.e.,
  group sequential design) as well as for multiple hypotheses (multiple tests
  included in an analysis), given any specified global error rate. This enables
  the sequential use of practically any significance test, as long as the
  underlying data can be simulated in advance to a reasonable approximation.
  Lukács (2022) &lt;<a href="https://doi.org/10.21105%2Fjoss.04643">doi:10.21105/joss.04643</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gasparl/possa">https://github.com/gasparl/possa</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, faux</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-22 05:38:20 UTC; gaspar</td>
</tr>
<tr>
<td>Author:</td>
<td>Gáspár Lukács [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gáspár Lukács &lt;lkcsgaspar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-22 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='POSSA-package'>POSSA: Power Simulation for Sequential Analyses</h2><span id='topic+POSSA'></span><span id='topic+POSSA-package'></span>

<h3>Description</h3>

<p>This R package serves to calculate, via simulation, power and appropriate
&quot;stopping&quot; alpha boundaries (and/or futility bounds) for sequential analyses
(i.e., &quot;group sequential design&quot;) as well as for multiple hypotheses
(multiple tests included in an analysis), given any specified global error
rate. This enables the sequential use of practically any significance test,
as long as the underlying data can be simulated in advance to a reasonable
approximation. Note: Since the specific functions are rather complex, it is
much easier to understand the procedure with the examples given in the
vignettes (see via https://github.com/gasparl/possa).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gáspár Lukács <a href="mailto:lkcsgaspar@gmail.com">lkcsgaspar@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/gasparl/possa">https://github.com/gasparl/possa</a>
</p>
</li></ul>


<hr>
<h2 id='get_p'>Extract p-value from tests</h2><span id='topic+get_p'></span><span id='topic+get_p.aov'></span><span id='topic+get_p.aovlist'></span>

<h3>Description</h3>

<p>This function attempts to extract p values from certain tests
where it could otherwise be complicated to do so. Please make sure, in case
of each new test, whether the function actually returns the values you want.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_p(x)

## S3 method for class 'aov'
get_p(x)

## S3 method for class 'aovlist'
get_p(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_p_+3A_x">x</code></td>
<td>
<p>Test results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Supported functions: all tests that return the p value as <code>p.value</code>
(including most R <code>stats</code> test functions, having <code>htest</code> class),
and the <code>aov()</code> function (<code>aov</code> and <code>aovlist</code> classes).
</p>


<h3>Value</h3>

<p>Returns either a single p value or, in case of multiple p values, a
list or nested list with each p value.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>get_p(aov)</code>: get_p method for class 'aov'
</p>
</li>
<li> <p><code>get_p(aovlist)</code>: get_p method for class 'aovlist'
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
get_p(t.test(extra ~ group, data = sleep))
# returns 0.07939414
# same as printed via t.test(extra ~ group, data = sleep)

get_p(prop.test(c(83, 90, 129, 70), c(86, 93, 136, 82)))
# returns 0.005585477,
# same as printed prop.test(c(83, 90, 129, 70), c(86, 93, 136, 82))

get_p(aov(yield ~ block + N * P * K, npk))
# returns list of p values
# corresponds to summary(aov(yield ~ block + N * P * K, npk))

get_p(aov(yield ~ N * P * K + Error(block), npk))
# returns nested list of p values (effects per error term)
# again corresponds printed p values via summary()

</code></pre>

<hr>
<h2 id='pow'>Power calculation</h2><span id='topic+pow'></span>

<h3>Description</h3>

<p>Calculates power and local alphas based on simulated p values
(which should be provided as created by the
<code><a href="#topic+sim">POSSA::sim</a></code> function). The calculation for
sequential testing involves a staircase procedure during which an initially
provided set of local alphas is continually adjusted until the (approximate)
specified global type 1 error rate (e.g., global alpha = .05) is reached:
the value of adjustment is decreasing while global type 1 error rate is
larger than specified, and increasing while global type 1 error rate is
smaller than specified; a smaller step is chosen whenever the direction
(increase vs. decrease) changes; the procedure stops when the global type 1
error rate is close enough to the specified one (e.g., matches it up to 4
fractional digits) or when the specified smallest step is passed. The
adjustment works via a dedicated (&quot;<code>adjust</code>&quot;) function that either
replaces missing (<code>NA</code>) values with varying alternatives or (when there
are no missing values) in some manner varyingly modifies the initial values
(e.g. by addition or multiplication).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow(
  p_values,
  alpha_locals = NULL,
  alpha_global = 0.05,
  adjust = TRUE,
  adj_init = NULL,
  staircase_steps = NULL,
  alpha_precision = 5,
  fut_locals = NULL,
  multi_logic_a = "all",
  multi_logic_fut = "all",
  multi_logic_global = "any",
  group_by = NULL,
  alpha_loc_nonstop = NULL,
  round_to = 5,
  iter_limit = 100,
  seed = 8,
  prog_bar = FALSE,
  hush = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pow_+3A_p_values">p_values</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the simulated
iterations, looks, and corresponding H0 and H1 p value outcomes, as returned
by the <code><a href="#topic+sim">POSSA::sim</a></code> function. (Custom data frames are
also accepted, but may not work as expected.)</p>
</td></tr>
<tr><td><code id="pow_+3A_alpha_locals">alpha_locals</code></td>
<td>
<p>A number, a numeric vector, or a named <code><a href="base.html#topic+list">list</a></code>
of numeric vectors, that specify the initial set of local alphas that decide
on statistical significance (for interim looks as well as for the final
look), and, if significant, stop the experiment at the given interim look;
to be adjusted via the <code>adjust</code> function; see the <code>adjust</code>
parameter below. Any of the numbers included can always be <code>NA</code> values
as well (which indicates alphas to be calculated; again, see the related
<code>adjust</code> parameter below). In case of a vector or a list of vectors,
the length of each vector must correspond exactly to the maximum number of
looks in the <code>p_values</code> data frame. When a <code><a href="base.html#topic+list">list</a></code> is given,
the names of the list element(s) must correspond to the root of the related
H0 and H1 p value column name pair(s) (in the <code>p_values</code> data frame),
that is, without the &quot;<code>_h0</code>&quot; and &quot;<code>_h1</code>&quot; suffixes: for example, if
the column name pair is &quot;<code>p_test4_h0</code>&quot; and &quot;<code>p_test4_h1</code>&quot;, the
name of the corresponding list element should be &quot;<code>p_test4</code>&quot;. If a
single number or a single numeric vector is given, all potential p value
column pairs are automatically detected as starting with &quot;<code>p_</code>&quot; prefix
and ending with &quot;<code>_h0</code>&quot; and &quot;<code>_h1</code>&quot;. In case of a single vector
given, each such automatically detected p value pair receives this same
vector. In case of a single number given, all elements of all vectors will
be assigned this same number (up to the maximum number of looks). If a list
is given and any of the elements contain just one number, it will be
extended into a vector (up to the maximum number of looks). The default
<code>NULL</code> value specifies &quot;fixed design&quot; (no interim stopping alphas) with
final alpha as specified as <code>alpha_global</code>, without adjustment
procedure as long as the <code>adjust</code> argument is also left as default
<code>TRUE</code>. (This is useful for cases where only futility bounds are to be
set for stopping.)</p>
</td></tr>
<tr><td><code id="pow_+3A_alpha_global">alpha_global</code></td>
<td>
<p>Global alpha (expected type 1 error rate in total);
<code>0.05</code> by default. See also <code>multi_logic_global</code> for when multiple
p values are being evaluated.</p>
</td></tr>
<tr><td><code id="pow_+3A_adjust">adjust</code></td>
<td>
<p>The function via which the initial vector local alphas is
modified with each step of the staircase procedure. Three arguments are
passed to it: <code>adj</code>, <code>orig</code>, and <code>prev</code>. The <code>adj</code>
parameter is mandatory; it passes the pivotal changing value that, starting
from an initial value (see <code>adj_init</code>), should, via the staircase
steps, decrease when the global type 1 error rate is too large, and increase
when the global type 1 error rate is too small. The <code>orig</code> parameter
(optional) always passes the same original vector of alphas as they were
provided via <code>alpha_locals</code>. The <code>prev</code> parameter (optional)
passes the &quot;latest&quot; vector of local alphas, which were obtained in the
previous adjustment step (or, in the initial run, it is the original vector,
i.e., the same as <code>orig</code>). When <code>TRUE</code> (default), if the given
<code>alpha_locals</code> contains any <code>NA</code>s, an <code>adjust</code> function is
given internally that simply replaces <code>NA</code>s with the varying adjustment
value (as <code>{ prev[is.na(orig)] = adj; return(prev) }</code>). If
<code>alpha_locals</code> contains no <code>NA</code>s, an <code>adjust</code> function is
given that multiplies each original local alpha with the varying adjustment
value (as <code>{ return(orig * adj) }</code>). When set to <code>FALSE</code>, there
will be no adjustment (staircase procedure omitted): this is useful to
calculate the global type 1 error rate for any given set of local alphas.
Furthermore, if both <code>adjust</code> and <code>alpha_locals</code> are left as
default (<code>TRUE</code> and <code>NULL</code>), the staircase procedure will be
omitted.</p>
</td></tr>
<tr><td><code id="pow_+3A_adj_init">adj_init</code></td>
<td>
<p>The initial adjustment value that is used as the &quot;<code>adj</code>&quot;
parameter in the &quot;<code>adjust</code>&quot; function and is continually adjusted via
the staircase steps (see <code>staircase_steps</code> parameter). When <code>NULL</code>
(default), assuming that &quot;<code>adj</code>&quot; is used as a replacement for
<code>NA</code>s, <code>adj_init</code> is calculated as the global alpha divided by the
maximum number of looks (Bonferroni correction), as a rough initial
approximation. However, multiplication is assumed when finding any
multiplication sign (<code>*</code>) in a given custom <code>adjust</code> function: in
such a case, <code>adj_init</code> will be <code>1</code> by default.</p>
</td></tr>
<tr><td><code id="pow_+3A_staircase_steps">staircase_steps</code></td>
<td>
<p>Numeric vector that specifies the (normally decreasing)
sequence of step sizes for the staircase that narrows down on the specified
global error error by decreasing or increasing the adjustment value
(initially: <code>adj_init</code>): the step size (numeric value) is added for
increase, and subtracted for decrease. Whenever the direction (decrease vs.
increase) is changed, the staircase moves on to the next step size. When the
direction changes and there are no more steps remaining, the procedure is
finished (regardless of the global error rate). By default (<code>NULL</code>),
the <code>staircase_steps</code> is either &quot;<code>0.01 * (0.5 ^ (seq(0, 11, 1)))</code>&quot;
(giving: <code>0.01, 0.005, 0.0025, ...</code>) or &quot;<code>0.5 * (0.5 ^ (seq(0, 11,
1)))</code>&quot; (giving: <code>0.05, 0.025, 0.0125, ...</code>). The latter is chosen when
adjustment via multiplication is assumed, which is simply based on finding
any multiplication sign (<code>*</code>) in a given custom <code>adjust</code> function.
The former is chosen in any other case.</p>
</td></tr>
<tr><td><code id="pow_+3A_alpha_precision">alpha_precision</code></td>
<td>
<p>During the staircase procedure, at any point when the
simulated global type 1 error rate first matches the given
<code>alpha_global</code> at least for the number of fractional digits given here
(<code>alpha_precision</code>; default: <code>5</code>), the procedure stops and the
results are printed. (Otherwise, the procedures finishes only when all steps
given as <code>staircase_steps</code> have been used.)</p>
</td></tr>
<tr><td><code id="pow_+3A_fut_locals">fut_locals</code></td>
<td>
<p>Specifies local futility bounds that may stop the experiment
at the given interim looks if the corresponding p value is above the given
futility bound value. When <code>NULL</code> (default), sets no futility bounds.
Otherwise, it follows the same logic as <code>alpha_locals</code> and has the same
input possibilities (number, numeric vector, or named list of numeric
vectors).</p>
</td></tr>
<tr><td><code id="pow_+3A_multi_logic_a">multi_logic_a</code></td>
<td>
<p>When multiple p values are evaluated for local alpha
stopping rules, <code>multi_logic_a</code> specifies the function used for how to
evaluate the multiple significance outcomes (p values being below or above
the given local alphas) as a single <code>TRUE</code> or <code>FALSE</code> value that
decides whether or not to stop at a given look. The default, <code>'all'</code>,
specifies that all of the p values must be below the local boundary for
stopping. The other acceptable character input is <code>'any'</code>, which
specifies that the collection stops when any of the p values pass the
boundary for stopping. Instead of these strings, the actual
<code><a href="base.html#topic+all">all</a></code> and <code><a href="base.html#topic+any">any</a></code> would lead to identical outcomes,
respectively, but the processing would be far slower (since the string
<code>'all'</code> or <code>'any'</code> inputs specify a dedicated faster internal
solution). For custom combinations, any custom function can be given, which
will take, as arguments, the p value columns in their given order (either in
the <code>p_values</code> data frame, or as specified in <code>alpha_locals</code>), and
should return a single <code>TRUE</code> or <code>FALSE</code> value.</p>
</td></tr>
<tr><td><code id="pow_+3A_multi_logic_fut">multi_logic_fut</code></td>
<td>
<p>Same as <code>multi_logic_a</code> (again with <code>'all'</code>
as default), but for futility bounds (for the columns specified in
<code>fut_locals</code>).</p>
</td></tr>
<tr><td><code id="pow_+3A_multi_logic_global">multi_logic_global</code></td>
<td>
<p>Similar as <code>multi_logic_a</code>, but for the
calculation of the global type 1 error rate (again: in case of multiple p
values being evaluated; otherwise this parameter is not relevant), and with
<code>'any'</code> by default. This default means that if any of the p values
under evaluation (specified via <code>alpha_locals</code> or detected
automatically) is significant (p value below the given local alpha at the
stopping of the simulated &quot;experiment&quot; iteration) in case of the H0
scenario, this is calculated as a type 1 error. If <code>'all'</code> were
specified, only cases with all p evaluated values being significant are
counted as type 1 errors. In either case, the ratio of outcomes with such
type 1 errors (out of all iterations) gives the global type 1 error rate,
which is intended to (approximately) match (via the adjustment procedure)
the value specified as <code>alpha_global</code>. This global type 1 error is also
what is printed to the console in the end as the &quot;combined&quot; global error
rate. Furthermore, the logic given here is also used for the calculation of
the &quot;combined&quot; global power printed to the console. In this case, the
<code>'any'</code> logic, for example, would mean that, if any of the p values are
significant at the end of the experiment, this is a positive finding. The
global power is then the ratio of iterations with such positive findings.</p>
</td></tr>
<tr><td><code id="pow_+3A_group_by">group_by</code></td>
<td>
<p>When given as a character element or vector, specifies the
factors by which to group the analysis: the <code>p_values</code> data will be
divided into parts by these factors and these parts will be analyzed
separately, with power and error information calculated per each part. By
default (<code>NULL</code>), it identifies factors, if any, given to the
<code>sim</code> function (via <code>fun_obs</code>) that created the given
<code>p_values</code> data.</p>
</td></tr>
<tr><td><code id="pow_+3A_alpha_loc_nonstop">alpha_loc_nonstop</code></td>
<td>
<p>Optional &quot;non-stopper&quot; alphas via which to evaluate p
values per look, but without stopping the data collection regardless of
statistical significance. Must be a list with names indicating p value
column name pairs, similarly as for the <code>alpha_locals</code> argument; see
<code>alpha_locals</code> for details.</p>
</td></tr>
<tr><td><code id="pow_+3A_round_to">round_to</code></td>
<td>
<p>Number of fractional digits (default: <code>5</code>) to round to,
for the displayed numeric information (such as alphas and power; mainly for
default value for <code><a href="#topic+print.possa_pow_list">printing</a></code>).</p>
</td></tr>
<tr><td><code id="pow_+3A_iter_limit">iter_limit</code></td>
<td>
<p>In some specific cases of unideal/wrong input, the staircase
may get stuck at a given step's loop process. The <code>iter_limit</code>
parameter specifies the number (by default <code>100</code>) at which the script
pauses the loop and offers to the user that the procedure be ceased. If the
user chooses to continue, the offer will always be posed again after the
same number of iterations (e.g., by default, after <code>100</code>, at
<code>200</code>, then <code>300</code>, etc.).</p>
</td></tr>
<tr><td><code id="pow_+3A_seed">seed</code></td>
<td>
<p>Number for <code><a href="base.html#topic+set.seed">set.seed</a></code>; <code>8</code> by default. Set to
<code>NULL</code> for random seed.</p>
</td></tr>
<tr><td><code id="pow_+3A_prog_bar">prog_bar</code></td>
<td>
<p>Logical, <code>FALSE</code> by default. If <code>TRUE</code>, shows
progress bar.</p>
</td></tr>
<tr><td><code id="pow_+3A_hush">hush</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prevents printing any details (or the
progress bar) to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returns a <code><a href="base.html#topic+list">list</a></code> (with class <code>"possa_pow_list"</code>)
that includes all details of the calculated power, T1ER, and sample
information. This list can be printed legibly (via POSSA's
<code><a href="#topic+print.possa_pow_list">print()</a></code> method).
</p>


<h3>Note</h3>

<p>For the replicability, in case the <code>adjust</code> function uses any
randomization, <code><a href="base.html#topic+set.seed">set.seed</a></code> is executed in the beginning of this
function, each time it is called; see the <code>seed</code> parameter.
</p>
<p>This function uses, internally, the <code><a href="data.table.html#topic+data.table">data.table</a></code> R package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim">sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# below is a (very) minimal example
# for more, see the vignettes via https://github.com/gasparl/possa#usage

# create sampling function
customSample = function(sampleSize) {
    list(
        sample1 = rnorm(sampleSize, mean = 0, sd = 10),
        sample2_h0 = rnorm(sampleSize, mean = 0, sd = 10),
        sample2_h1 = rnorm(sampleSize, mean = 5, sd = 10)
    )
}

# create testing function
customTest = function(sample1, sample2_h0, sample2_h1) {
 c(
   p_h0 = t.test(sample1, sample2_h0, 'less', var.equal = TRUE)$p.value,
   p_h1 = t.test(sample1, sample2_h1, 'less', var.equal = TRUE)$p.value
 )
}

# run simulation
dfPvals = sim(
    fun_obs = customSample,
    n_obs = 80,
    fun_test = customTest,
    n_iter = 1000
)

# get power info
pow(dfPvals)

</code></pre>

<hr>
<h2 id='print.possa_pow_df'>Print pow results data frame</h2><span id='topic+print.possa_pow_df'></span>

<h3>Description</h3>

<p>Prints, in a readable manner, the main information from any of
the data frames containing power information from the list created by the
<code><a href="#topic+pow">POSSA::pow</a></code> function. This is an extension (method)
of the base R <code><a href="base.html#topic+print">print</a></code> function, so it can be called simply as
<code>print()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'possa_pow_df'
print(x, round_to = 5, possa_title = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.possa_pow_df_+3A_x">x</code></td>
<td>
<p>Power information <code><a href="base.html#topic+data.frame">data.frame</a></code> included in the list
returned by the <code><a href="#topic+pow">POSSA::pow</a></code> function.</p>
</td></tr>
<tr><td><code id="print.possa_pow_df_+3A_round_to">round_to</code></td>
<td>
<p>Number of fractional digits to round to, for the displayed
numbers (<code>5</code> by default).</p>
</td></tr>
<tr><td><code id="print.possa_pow_df_+3A_possa_title">possa_title</code></td>
<td>
<p>Set to <code>FALSE</code> to omit title printing.</p>
</td></tr>
<tr><td><code id="print.possa_pow_df_+3A_...">...</code></td>
<td>
<p>(Allow additional arguments for technical reasons.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nothing (<code>NULL</code>); this method serves only to print
information to the console.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pow">pow</a></code>, <code><a href="#topic+print.possa_pow_list">print.possa_pow_list</a></code>
</p>

<hr>
<h2 id='print.possa_pow_list'>Print pow results</h2><span id='topic+print.possa_pow_list'></span>

<h3>Description</h3>

<p>Prints, in a readable manner, the main information from the list
created by the <code><a href="#topic+pow">POSSA::pow</a></code> function, calling
<code><a href="#topic+print.possa_pow_df">print.possa_pow_df</a></code> for each of the POSSA power information
data frames in the list. This is an extension (method) of the base R
<code><a href="base.html#topic+print">print</a></code> function, so it can be called simply as <code>print()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'possa_pow_list'
print(x, round_to = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.possa_pow_list_+3A_x">x</code></td>
<td>
<p>The <code><a href="base.html#topic+list">list</a></code> returned by the
<code><a href="#topic+pow">POSSA::pow</a></code> function.</p>
</td></tr>
<tr><td><code id="print.possa_pow_list_+3A_round_to">round_to</code></td>
<td>
<p>Number of fractional digits to round to, for the displayed
numbers. The default is the value passed from the
<code><a href="#topic+pow">POSSA::pow</a></code> function (stored in the returned list).</p>
</td></tr>
<tr><td><code id="print.possa_pow_list_+3A_...">...</code></td>
<td>
<p>(Allow additional arguments for technical reasons.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nothing (<code>NULL</code>); this method serves only to print
information to the console.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pow">pow</a></code>, <code><a href="#topic+print.possa_pow_df">print.possa_pow_df</a></code>
</p>

<hr>
<h2 id='print.possa_sim_df'>Print sim results</h2><span id='topic+print.possa_sim_df'></span>

<h3>Description</h3>

<p>Prints information about the simulated p values created by the
<code><a href="#topic+sim">POSSA::sim</a></code> function. This is an extension (method)
of the base R <code><a href="base.html#topic+print">print</a></code> function, so it can be called simply as
<code>print()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'possa_sim_df'
print(x, group_by = NULL, descr_cols = TRUE, descr_func = summary, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.possa_sim_df_+3A_x">x</code></td>
<td>
<p>The <code><a href="base.html#topic+data.frame">data.frame</a></code> returned by the
<code><a href="#topic+sim">POSSA::sim</a></code> function.</p>
</td></tr>
<tr><td><code id="print.possa_sim_df_+3A_group_by">group_by</code></td>
<td>
<p>When given as a character element or vector, specifies the
factors by which to group the descriptives: the <code>x</code> data will be
divided into parts by these factors and these parts will be analyzed
separately, with descriptives printed per each part. By default
(<code>NULL</code>), it identifies factors, if any, given to the <code>sim</code>
function (via <code>fun_obs</code>) that created the given <code>x</code> data.</p>
</td></tr>
<tr><td><code id="print.possa_sim_df_+3A_descr_cols">descr_cols</code></td>
<td>
<p>When given as a character element or vector, specifies the
factors for which descriptive data should be shown (by group, if
applicable). By default <code>NULL</code>, it identifies (similar as
<code>group_by</code>) factors, if any, given to the <code>sim</code> function (via
<code>fun_obs</code>) that produced the given <code>x</code> data.</p>
</td></tr>
<tr><td><code id="print.possa_sim_df_+3A_descr_func">descr_func</code></td>
<td>
<p>Function used for printing descriptives (see
<code>descr_cols</code>). By default, it uses the <code><a href="base.html#topic+summary">summary</a></code>
(<code><a href="base.html#topic+base">base</a></code>) function.</p>
</td></tr>
<tr><td><code id="print.possa_sim_df_+3A_...">...</code></td>
<td>
<p>(Allow additional arguments for technical reasons.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nothing (<code>NULL</code>); this method serves only to print
information to the console.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim">sim</a></code>
</p>

<hr>
<h2 id='sim'>Simulation procedure</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>This function performs the simulation procedure in order to get
the p values that will eventually serve for power calculations (via
<code><a href="#topic+pow">pow</a></code>). The observation values (&quot;sample&quot;) to be tested are
simulated via the given <code>fun_obs</code> function, and the significance
testing is performed via the given <code>fun_test</code> function. The numbers of
observations per look (for a sequential design) are specified in
<code>n_obs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(
  fun_obs,
  n_obs,
  fun_test,
  n_iter = 45000,
  adjust_n = 1,
  seed = 8,
  pair = NULL,
  ignore_suffix = FALSE,
  prog_bar = FALSE,
  hush = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_+3A_fun_obs">fun_obs</code></td>
<td>
<p>A <code><a href="base.html#topic+function">function</a></code> that creates the observations (i.e.,
the &quot;sample&quot;; all values for the dependent variable(s)). The respective
maximum observation number(s), given in <code>n_obs</code>, will be passed to the
<code>fun_obs</code>. For this, the returned value must be a named list, where the
names correspond exactly to the arguments in <code>fun_test</code>. In case of
sequential testing, the observations returned by <code>fun_obs</code> will be
reduced to the specified (smaller) number(s) of observations for each given
interim &quot;look&quot; (as a simulation for what would happen if collection was
stopped at that given look), to be used in <code>fun_test</code>. Optionally, the
<code>fun_obs</code> can be passed additional arguments (via a
<code><a href="base.html#topic+list">list</a></code>); see Details.</p>
</td></tr>
<tr><td><code id="sim_+3A_n_obs">n_obs</code></td>
<td>
<p>A numeric vector or a named list of numeric vectors. Specifies
the numbers of observations (i.e., samples sizes) that are to be generated
by <code>fun_obs</code> and then tested in <code>fun_test</code>. If a single vector is
given, this will be used for all observation number arguments in the
<code>fun_obs</code> and for the sample size adjustments for the arguments in the
<code>fun_test</code> functions. Otherwise, if a named list of numeric vectors is
given, the names must correspond exactly to the argument names in
<code>fun_obs</code> and <code>fun_test</code>, so that the respective numeric vectors
are used for each given sample variable. For convenience, in case of a
&quot;<code>_h</code>&quot; suffix, the variable will be divided into names with
&quot;<code>_h0</code>&quot; and &quot;<code>_h1</code>&quot; suffixes for <code>fun_test</code> (but not for
<code>fun_obs</code>); see Details.</p>
</td></tr>
<tr><td><code id="sim_+3A_fun_test">fun_test</code></td>
<td>
<p>The function for significance testing. The list of samples
returned by <code>fun_obs</code> (with observation numbers specified in
<code>n_obs</code>) will be passed into this <code>fun_test</code> function as
arguments, to be used in the given statistical significance tests in this
function. To correctly calculate the sample sizes in
<code><a href="#topic+pow">POSSA::pow</a></code>, the argument names for the sample that
varies depending on whether the null (H0) and alternative (H1) hypothesis is
true should be indicated with &quot;<code>_h0</code>&quot; and &quot;<code>_h1</code>&quot; suffixes,
respectively, with a common root (so, e.g., &quot;<code>var_x_h0</code>&quot; and
&quot;<code>var_x_h1</code>&quot;). Then, in the resulting <code><a href="base.html#topic+data.frame">data.frame</a></code>, their
sample size (which must always be identical) will be automatically merged
into a single column with a trimmed &quot;<code>_h</code>&quot; suffix (e.g.,
&quot;<code>var_x_h</code>&quot;). (Otherwise, the sample sizes of both H0 and H1 would be
calculated toward the total expected sample in either case, which is of
course incorrect. There are internal checks to prevent this, but the
intended total sample size can also be double-checked in the returned
<code><a href="base.html#topic+data.frame">data.frame</a></code>'s <code>.n_total</code> column.) Within-subject
observations, i.e., multiple observations per group, should be specified
with &quot;<code>GRP</code>&quot; prefix for a single group (e.g., simply &quot;<code>GRP</code>&quot;, or
&quot;<code>GRP_mytest</code>&quot;) and, for multiple groups, &quot;<code>grp_</code>&quot; prefix with a
following group name (e.g., &quot;<code>grp_1</code>&quot; or &quot;<code>grp_alpha</code>&quot;); the
numbers of multiple observations in each group can then be specified in
<code>fun_obs</code> via their group name (since the respective numbers of
observations should always be the same anyway); see Examples. To be
recognized by the <code><a href="#topic+pow">POSSA::pow</a></code> function, the
<code>fun_test</code> must return a named vector including a pair (or pairs) of p
values for H0 and H1 outcomes, where each p value's name must be specified
with a &quot;<code>p_</code>&quot; prefix and a &quot;<code>_h0</code>&quot; suffix for H0 outcome or a
&quot;<code>_h1</code>&quot; suffix for H1 outcome (e.g., <code>p_h0</code>, <code>p_h1</code>;
<code>p_ttest_h0</code>, <code>p_ttest_h1</code>). The simulated outcomes (per
iteration) for each of these p values will be separately stored in a
dedicated column of the <code><a href="base.html#topic+data.frame">data.frame</a></code> returned by the <code>sim</code>
function. Optionally, the <code>fun_test</code> can return other miscellaneous
outcomes too, such as effect sizes or confidence interval limits; these will
then be stored in dedicated columns in the resulting
<code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sim_+3A_n_iter">n_iter</code></td>
<td>
<p>Number of iterations (default: 45000).</p>
</td></tr>
<tr><td><code id="sim_+3A_adjust_n">adjust_n</code></td>
<td>
<p>Adjust total number of observations via simple multiplication.
Might be useful in some specific cases, e.g. if for some reason multiple p
values are derived from the same sample without specifying grouping
(<code>GRP</code> or <code>grp_</code> in <code>fun_test</code>), which would then lead to
incorrect (too many, multiplied) totals; for example, in case of four
observations obtained from the same sample, the value <code>1/4</code> could be
given. (The default value is <code>1</code>.)</p>
</td></tr>
<tr><td><code id="sim_+3A_seed">seed</code></td>
<td>
<p>Number for <code><a href="base.html#topic+set.seed">set.seed</a></code>; <code>8</code> by default. Set to
<code>NULL</code> for random seed.</p>
</td></tr>
<tr><td><code id="sim_+3A_pair">pair</code></td>
<td>
<p>Logical or <code>NULL</code>. By default <code>NULL</code>, the algorithm
assumes paired samples included among the observations in case of any
grouping via the <code>fun_test</code> parameters (&quot;<code>GRP</code>&quot;/&quot;<code>grp</code>&quot;), and
no paired samples otherwise. In case of paired samples included, within each
look, the same vector indexes to remove elements from the given
observations. In general, this should not substantially affect the outcomes
of independent samples (assuming that their order is truly independent), but
this depends on how the random samples are generated in the <code>fun_obs</code>
function. To be safe and avoid any potential bias, it is best to avoid this
paired sampling mechanism when no paired samples are included. To override
the default, set to <code>TRUE</code> for paired samples scenario (paired
sampling), or to <code>FALSE</code> for no paired samples scenario (random
subsampling of each sample). (Might be useful for testing or some very
specific procedures, e.g. where grouping is not indicated despite paired
samples.)</p>
</td></tr>
<tr><td><code id="sim_+3A_ignore_suffix">ignore_suffix</code></td>
<td>
<p>Set to <code>NULL</code> to give warnings instead of errors for
internally detected consistency problems with the <code>_h0</code>/<code>_h1</code>
suffixes in the <code>fun_test</code> function arguments. Set to <code>TRUE</code> to
completely ignore these (neither error nor warning). (Might be useful for
testing or some very specific procedures.)</p>
</td></tr>
<tr><td><code id="sim_+3A_prog_bar">prog_bar</code></td>
<td>
<p>Logical, <code>FALSE</code> by default. If <code>TRUE</code>, shows
progress bar.</p>
</td></tr>
<tr><td><code id="sim_+3A_hush">hush</code></td>
<td>
<p>Logical, <code>FALSE</code> by default. If <code>TRUE</code>, prevents
printing any details to console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To specify a variable that differs depending on whether the null hypothesis
(&quot;H0&quot;) or the alternative hypothesis (&quot;H1&quot;) is true, a pair of samples are
needed for <code>fun_test</code>, for which the argument names should have an
identical root and &quot;<code>_h0</code>&quot; and &quot;<code>_h1</code>&quot; endings, such as
&quot;<code>var_x_h0</code>&quot; (for sample in case of H0) and &quot;<code>var_x_h1</code>&quot; (for sample
in case of H1). Then, since the observation number for this pair will always
be the same, as a convenience, parameters with &quot;<code>_h0</code>&quot; and &quot;<code>_h1</code>&quot;
endings specifically can be specified together in <code>n_obs</code> with the last
&quot;0&quot;/&quot;1&quot; character dropped, hence ending with &quot;<code>_h</code>&quot;. So, for example,
&quot;<code>var_x_h = c(30, 60, 90)</code>&quot; will be automatically adjusted to specify the
observation numbers for both &quot;<code>var_x_h0</code>&quot; and &quot;<code>var_x_h1</code>&quot;. In that
case, <code>fun_obs</code> must have a single argument &quot;<code>var_x_h</code>&quot;, while
<code>fun_test</code> must have both full names as arguments (&quot;<code>var_x_h0</code>&quot; and
&quot;<code>var_x_h1</code>&quot;).
</p>
<p>Optionally, <code>fun_obs</code> can be provided in <code><a href="base.html#topic+list">list</a></code> format for
the convenience of exploring varying factors (e.g., different effect sizes,
correlations) at once, without writing a dedicated <code>fun_obs</code> function for
each combination, and each time separately running the simulation and the
power calculation. In this case, the first element of the list must be the
actual <code><a href="base.html#topic+function">function</a></code>, which contains certain parameters for
specifying varying factors, while the rest of the elements should contain the
various argument values for these parameters of the function as named elements
of the list (e.g., <code>list(my_function, factor1=c(1, 2, 3), factor2=c(0,
5))</code>), with the name corresponding to the parameter name in the function, and
the varying values (numbers or strings). When so specified, a separate
simulation procedure will be run for each combination of the given factors
(or, if only one factor is given, for each element of that factor). The
<code><a href="#topic+pow">POSSA::pow</a></code> function will be able to automatically
detect (by default) the factors generated this way in the present
<code><a href="#topic+sim">POSSA::sim</a></code> function, in order to calculate power
separately for each factor combination.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> (with class <code>"possa_sim_df"</code>)
that includes the columns <code>.iter</code> (the iterations of the simulation
procedure numbered from <code>1</code> to <code>n_iter</code>), <code>.look</code> (the
interim &quot;looks&quot; numbered from <code>1</code> to the maximum number of looks,
including the final one), and the information returned by the
<code>fun_test</code> function for H0 and H1 outcomes (mainly p values; but also
other, optional information, if any) and the corresponding observation
numbers, as well as the total observation number per each look under a
dedicated <code>.n_total</code> column. When this data frame is printed to the
console (via POSSA's <code><a href="#topic+print.possa_pow_list">print()</a></code>
method), the head (first few lines) of the data is shown, as well as, in
case of any varying factors included, summary information per factor
combination.
</p>


<h3>Note</h3>

<p>For the replicability (despite the randomization), <code><a href="base.html#topic+set.seed">set.seed</a></code> is
executed in the beginning of this function, each time it is called; see the
<code>seed</code> parameter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pow">pow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# below is a (very) minimal example
# for more, see the vignettes via https://github.com/gasparl/possa#usage

# create sampling function
customSample = function(sampleSize) {
    list(
        sample1 = rnorm(sampleSize, mean = 0, sd = 10),
        sample2_h0 = rnorm(sampleSize, mean = 0, sd = 10),
        sample2_h1 = rnorm(sampleSize, mean = 5, sd = 10)
    )
}

# create testing function
customTest = function(sample1, sample2_h0, sample2_h1) {
 c(
   p_h0 = t.test(sample1, sample2_h0, 'less', var.equal = TRUE)$p.value,
   p_h1 = t.test(sample1, sample2_h1, 'less', var.equal = TRUE)$p.value
 )
}

# run simulation
dfPvals = sim(
    fun_obs = customSample,
    n_obs = 80,
    fun_test = customTest,
    n_iter = 1000
)

# get power info
pow(dfPvals)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
