<!DOCTYPE html><html><head><title>Help for package Thermimage</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Thermimage}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#airdensity'>
<p>Returns the density of air for a given air temperature.</p></a></li>
<li><a href='#airspecificheat'>
<p>Specific heat capacity of air</p></a></li>
<li><a href='#airtconductivity'>
<p>Thermal conductivity of air.</p></a></li>
<li><a href='#airviscosity'>
<p>Returns air viscosity for a given air temperature.</p></a></li>
<li><a href='#areacone'>
<p>Provides the surface are of a cone</p></a></li>
<li><a href='#areacylinder'>
<p>Provides the surface area of a cylinder.</p></a></li>
<li><a href='#areasphere'>
<p>Provides the surface area of a sphere.</p></a></li>
<li><a href='#convertflirJPG'>
<p>Convert FLIR jpg into 16 bit grayscale file using shell commands.</p></a></li>
<li><a href='#convertflirVID'>
<p>Convert FLIR CSQ or SEQ into PNG or AVI, using shell commands.</p></a></li>
<li><a href='#cumulDiff'>
<p>Cumulative difference sum function for use with frame by frame difference dataframe</p></a></li>
<li><a href='#diffFrame'>
<p>A frame difference function for subtracting adjacent frames from an imported thermal image sequence.</p></a></li>
<li><a href='#ffmpegcall'>
<p>A simplified wrapper function calling ffmpeg</p></a></li>
<li><a href='#flip.matrix'>
<p>Flips a matrix 'left-right'.  Used in re-arranging image data for plotting properly in R.</p></a></li>
<li><a href='#flirpal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#flirsettings'>
<p>Extracts meta tag information from a FLIR JPG image</p></a></li>
<li><a href='#forcedparameters'>
<p>Parameters required for forced convection equation.</p></a></li>
<li><a href='#frameLocates'>
<p>Find the frame read start positions in a FLIR SEQ video file.</p></a></li>
<li><a href='#freeparameters'>
<p>Parameters required for free convection equation.</p></a></li>
<li><a href='#getFrames'>
<p>Extract raw binary thermal from thermal image file.</p></a></li>
<li><a href='#getTimes'>
<p>Extracts time values from binary imported thermal video file</p></a></li>
<li><a href='#glowbowpal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#Grashof'>
<p>Determines the Grashof number for an object</p></a></li>
<li><a href='#grey10pal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#grey120pal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#greyredpal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#hconv'>
<p>Convective heat coefficient (W/m2/oC)</p></a></li>
<li><a href='#hotironpal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#ironbowpal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#Ld'>
<p>Estimates downward facing longwave radiation (W/m2)</p></a></li>
<li><a href='#locate.fid'>
<p>Returns the index locations that match vector fid within data vector.</p></a></li>
<li><a href='#Lu'>
<p>Estimates upward facing ground radiation (W/m2)</p></a></li>
<li><a href='#Lw'>
<p>Estimates downward facing longwave radiation (W/m2)</p></a></li>
<li><a href='#meanEveryN'>
<p>Calculate the mean every nth data point.</p></a></li>
<li><a href='#medicalpal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#midgreenpal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#midgreypal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#mikronprismpal'>
<p>Colour palette extracted from Mikron thermal camera files</p></a></li>
<li><a href='#mikroscanpal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#mirror.matrix'>
<p>Mirrors a matrix upside-down.  Used in re-arranging image data for plotting properly in R.</p></a></li>
<li><a href='#nameleadzero'>
<p>Add leading zeros to character for easy sequential naming of filenames.</p></a></li>
<li><a href='#Nusseltforced'>
<p>Nusselt number for forced convection.</p></a></li>
<li><a href='#Nusseltfree'>
<p>Nusselt number for free convection.</p></a></li>
<li><a href='#palette.choose'>
<p>Choose a colour palette for gradient filling thermal image files.</p></a></li>
<li><a href='#plotTherm'>
<p>Plot thermal image data for visualisation purposes.</p></a></li>
<li><a href='#Prandtl'>
<p>Returns the Prandtl number</p></a></li>
<li><a href='#qabs'>
<p>Estimates the absorbed solar and infrared radiation (W/m2)</p></a></li>
<li><a href='#qcond'>
<p>Estimates the area specific heat transfer by conduction (W/m2)</p></a></li>
<li><a href='#qconv'>
<p>Estimates the area specific heat transfer by convection (W/m2)</p></a></li>
<li><a href='#qrad'>
<p>Estimates the area specific heat transfer by radiation (W/m2)</p></a></li>
<li><a href='#rainbow1234pal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#rainbowpal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
<li><a href='#raw2temp'>
<p>Converts raw thermal data into temperature (oC)</p></a></li>
<li><a href='#readflirJPG'>
<p>Reads an image from a FLIR JPG file into an integer array.</p></a></li>
<li><a href='#Reynolds'>
<p>Calculates the Reynolds number.</p></a></li>
<li><a href='#rotate180.matrix'>
<p>Rotate a matrix by 180 degrees.  Used for adjusting image plotting in R.</p></a></li>
<li><a href='#rotate270.matrix'>
<p>Rotate a matrix by 270 degrees counterclockwise (or 90 degree clockwise).  Used for adjusting image plotting in R.</p></a></li>
<li><a href='#rotate90.matrix'>
<p>Rotate a matrix by 90 degrees counterclockwise (270 degrees clockwise).  Used for adjusting image plotting in R.</p></a></li>
<li><a href='#samp.image'>
<p>A sample thermal image to demonstrate thermal colour palette use.</p></a></li>
<li><a href='#slopebypoint'>
<p>Returns the slope from linear regression with x values as equally spaced 1:length</p></a></li>
<li><a href='#slopeEveryN'>
<p>Calculate the slope every nth data point.</p></a></li>
<li><a href='#StephBoltz'>
<p>The Stephan Boltzman constant.</p></a></li>
<li><a href='#Te'>
<p>Operative temperature estimate.</p></a></li>
<li><a href='#temp2raw'>
<p>Converts temperature (oC) to raw thermal data</p></a></li>
<li><a href='#Teq'>
<p>Estimates equivalent temperature.</p></a></li>
<li><a href='#Tground'>
<p>Estimates ground temperature from ambient temperature and solar radiation.</p></a></li>
<li><a href='#Thermimage-package'>
<p>Handles thermal image data input and conversion to temperature using established physical equations.</p></a></li>
<li><a href='#thermsum'>
<p>Return summary of thermal image data.</p></a></li>
<li><a href='#thermsumcent'>
<p>Summary thermal calculations on a centrally located region of interest from a thermal image dataset</p></a></li>
<li><a href='#writeFlirBin'>
<p>Saves thermal image data to a binary file</p></a></li>
<li><a href='#yellowpal'>
<p>Colour palette extracted from FLIR thermal camera files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Thermal Image Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>4.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Glenn J. Tattersall</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions and routines for inputting thermal
    image video files, plotting and converting binary raw data into estimates of
    temperature.  First published 2015-03-26.  Written primarily for research purposes
    in biological applications of thermal images.  v1 included the base calculations 
    for converting thermal image binary values to temperatures. v2 included additional
    equations for providing heat transfer calculations and an import function for thermal
    image files (v2.2.3 fixed error importing thermal image to windows OS). v3. Added numerous
    functions for converting thermal image, videos, rewriting and exporting.  
    v3.1. Added new functions to convert files. v3.2.  Fixed the various functions related to finding frame times.
    v4.0. fixed an error in atmospheric attenuation constants, affecting raw2temp and temp2raw functions.
    Recommend update for use with long distance calculations. v.4.1.3 changed to frameLocates to reflect change to as.character() to format().</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>exiftool, perl, ffmpeg, imagemagick</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fields</td>
</tr>
<tr>
<td>Imports:</td>
<td>tiff, png</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Glenn J. Tattersall &lt;gtatters@brocku.ca&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=Thermimage">https://cran.r-project.org/package=Thermimage</a>,
<a href="https://github.com/gtatters/Thermimage">https://github.com/gtatters/Thermimage</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gtatters/Thermimage/issues">https://github.com/gtatters/Thermimage/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-26 16:34:56 UTC; GlennTattersall</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-27 10:00:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='airdensity'>
Returns the density of air for a given air temperature.
</h2><span id='topic+airdensity'></span>

<h3>Description</h3>

<p>Density of air if temperature (degrees Celsius) provided.  Units: kg/m3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airdensity(Ta = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="airdensity_+3A_ta">Ta</code></td>
<td>

<p>Air temperature in degrees Celsius.  Default value is 20.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>http://www.engineeringtoolbox.com/air-properties-d_156.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (Ta = 20) 
{
    Base &lt;- 314.156
    Exponent &lt;- (-0.981)
    p &lt;- Base * (Ta + 273.15)^Exponent
    p
  }
</code></pre>

<hr>
<h2 id='airspecificheat'>
Specific heat capacity of air
</h2><span id='topic+airspecificheat'></span>

<h3>Description</h3>

<p>Specific heat capacity of air if temperature (degrees Celsius) provided.  Units: J/(kg*K)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airspecificheat(Ta = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="airspecificheat_+3A_ta">Ta</code></td>
<td>

<p>Air temperature in degrees Celsius.  Default value is 20.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>http://www.engineeringtoolbox.com/air-properties-d_156.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (Ta = 20) 
{
    Intercept &lt;- 1.003731424
    Slope1 &lt;- 5.37909e-06
    Slope2 &lt;- 7.30124e-07
    Slope3 &lt;- (-1.34472e-09)
    Slope4 &lt;- 1.23027e-12
    cp &lt;- 1000*(Intercept + Slope1 * Ta + Slope2 * Ta^2 + Slope3 * 
        Ta^3 + Slope4 * Ta^4)
    cp
  }
</code></pre>

<hr>
<h2 id='airtconductivity'>
Thermal conductivity of air.
</h2><span id='topic+airtconductivity'></span>

<h3>Description</h3>

<p>Thermal conductivity of air.  Units: W/m/K
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airtconductivity(Ta = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="airtconductivity_+3A_ta">Ta</code></td>
<td>

<p>Air temperature in degrees Celsius.  Default value is 20.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>http://www.engineeringtoolbox.com/air-properties-d_156.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+airviscosity">airviscosity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (Ta = 20) 
{
    Intercept &lt;- 0.024280952
    Slope &lt;- 7.07143e-05
    k &lt;- Intercept + Slope * Ta
    k
  }
# Example calculation:
Ta&lt;-20
airtconductivity(Ta)
</code></pre>

<hr>
<h2 id='airviscosity'>
Returns air viscosity for a given air temperature.
</h2><span id='topic+airviscosity'></span>

<h3>Description</h3>

<p>Returns the air viscosity value for a given, supplied air temperature (Ta).  Ta should be in
units of oC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airviscosity(Ta = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="airviscosity_+3A_ta">Ta</code></td>
<td>

<p>Air temperature in degrees Celsius.  Default value is 20.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Kinematic viscosity of air, as a function of temperature
Units: m2/s
Regression for 0 to 100oC range:
Intercept&lt;-13.17380952
Slope&lt;-0.097457143
k&lt;-(Intercept+Slope*Ta)*1e-6 #  multiply by 1e-6 to get into m2/s units
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>http://www.engineeringtoolbox.com/air-properties-d_156.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (Ta = 20) 
{
    Intercept &lt;- 13.17380952
    Slope &lt;- 0.097457143
    k &lt;- (Intercept + Slope * Ta) * 1e-06
    k
  }
# Example calculation
Ta&lt;-20
airviscosity(Ta)
</code></pre>

<hr>
<h2 id='areacone'>
Provides the surface are of a cone
</h2><span id='topic+areacone'></span>

<h3>Description</h3>

<p>Provides the surface area of a cone with an elliptical base.  For a circular cone, simply use Radius=radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areacone(Radius, radius=Radius, hypotenuse=NULL, height, ends=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areacone_+3A_radius">Radius</code></td>
<td>

<p>The Radius of the major axis of the base of the cone. 
</p>
</td></tr>
<tr><td><code id="areacone_+3A_radius">radius</code></td>
<td>

<p>The radius of the minor axis of the base of the cone. 
</p>
</td></tr>
<tr><td><code id="areacone_+3A_hypotenuse">hypotenuse</code></td>
<td>

<p>The hypotenuse of the height of the cone (if blank, determined from radius and height)
</p>
</td></tr>
<tr><td><code id="areacone_+3A_height">height</code></td>
<td>

<p>The height of the cone (if hypotenuse is known, leave height blank)
</p>
</td></tr>
<tr><td><code id="areacone_+3A_ends">ends</code></td>
<td>

<p>To include the base area in surface area calculation, set ends = 1, otherwise set ends = 0.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the surface are of a cone with an elliptical base.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function(Radius, radius=Radius, hypotenuse=NULL, height, ends=1)
{
  if(is.null(hypotenuse)){
    hypotenuse&lt;-sqrt(height^2+Radius^2)
  }
  Area &lt;- ends*pi*Radius*radius + pi*Radius*hypotenuse
  Area
}

# Example calculation from a measure of a bird bill.

# Typically, a bird bill will be measured by its depth (d) at the base, its width (w) at the 
# base and by its overall length.  The length (l) is typically measured along the length of
# the culmen, and thus is a diagonal measure along the hypotenuse of the cone.

d&lt;-12
w&lt;-6
l&lt;-18
areacone(Radius=d/2, radius=w/2, hypotenuse=l, height=NULL, ends=1)


# If the perpendicular cone height (h) is instead measured, rather than the hypotenuse, then
# substitute h for height and assign hypotenuse = NULL, to obtain the same result

h&lt;-sqrt(l^2-(d/2)^2)
areacone(Radius=d/2, radius=w/2, hypotenuse=NULL, height=h, ends=1)


# To only show surface area of the exposed surface, and exclude the oval base of the cone
# set ends=0:

areacone(Radius=d/2, radius=w/2, hypotenuse=l/2, height=NULL, ends=0)

</code></pre>

<hr>
<h2 id='areacylinder'>
Provides the surface area of a cylinder.
</h2><span id='topic+areacylinder'></span>

<h3>Description</h3>

<p>Provides the surface area of a cylinder, including the circular bases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areacylinder(Radius, radius=Radius, height, ends = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areacylinder_+3A_radius">Radius</code></td>
<td>

<p>The major radius of the base of the cylinder.
</p>
</td></tr>
<tr><td><code id="areacylinder_+3A_radius">radius</code></td>
<td>

<p>The minor radius of the base of the cylinder.  Default is to equal the major Radius in the case of a circular base.
</p>
</td></tr>
<tr><td><code id="areacylinder_+3A_height">height</code></td>
<td>

<p>The height of the cylinder (alternatively, the length of a horizontal cylinder)
</p>
</td></tr>
<tr><td><code id="areacylinder_+3A_ends">ends</code></td>
<td>

<p>How many ends to include in the surface area calculation (2=both ends, 1=one end, 0=neither end)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function(Radius, radius=Radius, height, ends=2)
{
  Area &lt;- (Radius+radius)*pi*height + ends*pi*Radius*radius
  Area
  }

# Example calculation:

# Typically, a body part might be modelled as cylindrical if it appears to be approximately
# circular or elliptical and elongated.  By measuring the major diameter (D) and minor
# diameter (d) as well as the length or height (l), the overall surface area can be 
# determined:

D&lt;-12
d&lt;-6
l&lt;-18
areacylinder(Radius=D/2, radius=d/2, height=l, ends=2)


# To only show surface area of the exposed surface, and exclude the oval base of the 
# cylinder, set ends=0

areacylinder(Radius=D/2, radius=d/2, height=l, ends=0)


</code></pre>

<hr>
<h2 id='areasphere'>
Provides the surface area of a sphere.
</h2><span id='topic+areasphere'></span>

<h3>Description</h3>

<p>Provides the surface area of a sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areasphere(radius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areasphere_+3A_radius">radius</code></td>
<td>

<p>The radius of the sphere.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (radius) 
{
    Area &lt;- 4 * pi * radius^2
    Area
  }

# Example calculation:
radius&lt;-4
areasphere(radius)

</code></pre>

<hr>
<h2 id='convertflirJPG'>
Convert FLIR jpg into 16 bit grayscale file using shell commands.
</h2><span id='topic+convertflirJPG'></span>

<h3>Description</h3>

<p>Invoking shell commands to act on a FLIR jpg and calls the exiftool -RawThermalImage option to extract the raw, binary thermal image data in 16 bit format and passes this to imagemagick's convert function to swap the byte order (if necessary) and output as a png file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertflirJPG(imagefile, exiftoolpath="installed", res.in="640x480", 
endian="lsb", outputfolder="output", verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertflirJPG_+3A_imagefile">imagefile</code></td>
<td>

<p>Name of the FLIR JPG file to read from, as captured by the thermal camera.  A character string.
</p>
</td></tr>
<tr><td><code id="convertflirJPG_+3A_exiftoolpath">exiftoolpath</code></td>
<td>

<p>A character string that determines whether Exiftool has been &quot;installed&quot; or not.  If Exiftool has been installed in a specific location, use to direct to the folder location.
</p>
</td></tr>
<tr><td><code id="convertflirJPG_+3A_res.in">res.in</code></td>
<td>

<p>Input file image resolution in text format, &quot;wxh&quot;.  Default = &quot;640x480&quot;
</p>
</td></tr>
<tr><td><code id="convertflirJPG_+3A_endian">endian</code></td>
<td>

<p>Byte order (&quot;lsb&quot; = least significant byte or &quot;msb&quot; = most significant byte) used in converting raw thermal image in call to imagemagick's convert function.  Byte order can be set according to the inherent raw thermal data type.  TIFF type raw thermal image data are saved as lsb, PNG type raw thermal image data are saved as msb. 
</p>
</td></tr>
<tr><td><code id="convertflirJPG_+3A_outputfolder">outputfolder</code></td>
<td>

<p>Desired output subfolder name, placed inside the folder where the input files are stored.  Default = &quot;output&quot;.
</p>
</td></tr>
<tr><td><code id="convertflirJPG_+3A_verbose">verbose</code></td>
<td>

<p>Provides the command line output if verbose=TRUE.  Default = FALSE. 
</p>
</td></tr>
<tr><td><code id="convertflirJPG_+3A_...">...</code></td>
<td>

<p>Other values to pass to command line functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls exiftool and imagemagick (convert) in shell to convert a FLIR jpg, using the command line exiftool, and passing that raw thermal binary datat to convert to create a png file.  The subsequent converted file is a 16 bit grayscale png, with each pixel representing the uncalibrated raw sensor radiance data from the thermal imaging camera.  This raw png file can be loaded into ImageJ for further analysis.
</p>
<p>For example, a typical shell call might look like:
</p>
<p>exiftool FLIRjpgfilename.jpg -b -RawThermalImage | convert - gray:- | convert -depth 16 -endian lsb -size 640x480 gray:- Outputfilename.png
</p>


<h3>Value</h3>

<p>No output generated in R.  Shell call to exiftool and imagemagick to convert flir jpg files to png files.  exiftool and imagemagick must be installed on the system.  Files generated require further processing to estimate temperature.  
</p>


<h3>Note</h3>

<p>This function has not been fully tested with all flir jpg types.  Multiburst images and older camera file types may not work.
</p>
<p>This function requires that exiftool and imagemagick are installed.  Consult with the references for how to install
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>References</h3>

<p>1. https://www.sno.phy.queensu.ca/~phil/exiftool/
</p>
<p>2. https://www.imagemagick.org/script/index.php
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convertflirVID">convertflirVID</a></code>, 
<code><a href="#topic+ffmpegcall">ffmpegcall</a></code>, 
<code><a href="#topic+readflirJPG">readflirJPG</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Based on the following command line unix code, 
# this function will convert a flir jpg into a 16 bit 
# greyscale png to import into imageJ

# Equivalent command line code:
# exiftool FLIRjpgfilename.jpg -b -RawThermalImage | convert - gray:- | 
# convert -depth 16 -endian lsb 
# -size 640x480 gray:- Outputfilename.png

# Examples
# See https://github.com/gtatters/FLIRJPGConvert/blob/master/Examples.R

# See https://github.com/gtatters/FLIRJPGConvert/blob/master/FLIRJPG_Convert.R 

# See https://github.com/gtatters/Thermimage/blob/master/README.md
</code></pre>

<hr>
<h2 id='convertflirVID'>
Convert FLIR CSQ or SEQ into PNG or AVI, using shell commands.
</h2><span id='topic+convertflirVID'></span>

<h3>Description</h3>

<p>Invoking shell commands to act on a FLIR video (SEQ or CSQ file type) and calls the exiftool -RawThermalImage option to extract the raw, binary thermal image frames in 16 bit format and pass these to ffmpeg to convert the output as a series of png files or as an avi video file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertflirVID(imagefile, exiftoolpath="installed", perlpath="installed", 
fffsplitpattern="fff", fr=30, res.in="1024x768", res.out="1024x768", 
outputcompresstype="jpegls", outputfilenameroot=NULL, outputfiletype="avi",
outputfolder="output", verbose=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertflirVID_+3A_imagefile">imagefile</code></td>
<td>

<p>Name of the FLIR SEQ or CSQ file to read from, as captured by the thermal camera.  A character string.
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_exiftoolpath">exiftoolpath</code></td>
<td>

<p>A character string that determines whether Exiftool has been &quot;installed&quot; or not.  If Exiftool has been installed in a specific location, use to direct to the folder location.
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_perlpath">perlpath</code></td>
<td>

<p>A character string that determines whether Perl has been &quot;installed&quot; or not.  If Perl has been installed in a specific location, use to direct to the folder location.
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_fffsplitpattern">fffsplitpattern</code></td>
<td>

<p>This split pattern is used to break up thermal video file into their component frames prior to call to exiftool.  Used in call to the built-in perl script, split.pl. The default value, &quot;fff&quot;, should work for most files, but sometimes you might need to specify &quot;seq&quot;, &quot;fcf&quot;, or &quot;csq&quot; if there are problems with the generated output.  
</p>
<p>fff splits based on: &quot;46 46 46 00&quot;  
</p>
<p>fcf splits based on: &quot;46 46 46 00 43 41 50&quot;  
</p>
<p>seq splits based on: &quot;46 46 46 00 43 41 4D&quot;  
</p>
<p>csq splits based on: &quot;46 46 46 00 52 54 50&quot;  
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_fr">fr</code></td>
<td>

<p>Frame rate of input video data, frames per sec.  Default = 30.
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_res.in">res.in</code></td>
<td>

<p>Input file image resolution in text format, &quot;wxh&quot;.  Default = &quot;640x480&quot;
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_res.out">res.out</code></td>
<td>

<p>Desired output file image resolution in text format, &quot;wxh&quot;. Decrease to make smaller file, but maintain same aspect ratio.  Default = &quot;640x480&quot;.
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_outputcompresstype">outputcompresstype</code></td>
<td>

<p>Desired output file image compression format.  Possible values are &quot;tiff&quot;, &quot;png&quot; or &quot;jpegls&quot; (or any modifier from ffmpeg -vcodec).  Default = &quot;png&quot;.
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_outputfilenameroot">outputfilenameroot</code></td>
<td>

<p>The base root of the output file(s) to be exported, without the indexing.  If NULL, then the input filenameroot will be used and a numeric index attached.  Default is NULL.
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_outputfiletype">outputfiletype</code></td>
<td>

<p>Desired output file type, &quot;avi&quot; or &quot;png&quot;.  If &quot;png&quot;, multiple files will be exported.  If &quot;avi&quot;, a single video file will be exported.  Default = &quot;avi&quot;
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_outputfolder">outputfolder</code></td>
<td>

<p>Desired output subfolder name, placed inside the folder where the input files are stored.  Default = &quot;output&quot;.
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_verbose">verbose</code></td>
<td>

<p>Provides the command line output if verbose=TRUE.  Default = FALSE. 
</p>
</td></tr>
<tr><td><code id="convertflirVID_+3A_...">...</code></td>
<td>

<p>Other values to pass to command line functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls exiftool, imagemagick, and ffmpeg in shell to convert a thermal image video file (SEQ or CSQ) into a 16 bit grayscale avi or series of images corresponding to each frame of the input video.
</p>


<h3>Value</h3>

<p>No output generated in R.  Shell call to exiftool, imagemagick, and ffmpeg to convert files.
</p>


<h3>Note</h3>

<p>Use with files &lt;2Gb in size.  Larger files have failed during testing due to internal memory limits during call to perl. 
</p>
<p>This function requires that exiftool and ffmpeg are installed.  Consult with the references for how to install.
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>References</h3>

<p>1. https://www.sno.phy.queensu.ca/~phil/exiftool/
</p>
<p>2. https://www.imagemagick.org/script/index.php
</p>
<p>3. https://www.eevblog.com/forum/thermal-imaging/csq-file-format/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convertflirJPG">convertflirJPG</a></code>, 
<code><a href="#topic+ffmpegcall">ffmpegcall</a></code>, 
<code><a href="#topic+readflirJPG">readflirJPG</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Based on the following command line unix code, this function will convert a 
# flir jpg into a 16 bit greyscale video or sequence of images for import into imageJ

# Equivalent command line code:
# ffmpeg -f image2 -vcodec tiff -r 30 -s 640x480 -i 'output/frame%05d.tiff' -pix_fmt gray16be 
# -vcodec png -s 640x480 file.avi

# Examples 
# See https://github.com/gtatters/FLIRJPGConvert/blob/master/Examples.R

# See https://github.com/gtatters/FLIRJPGConvert/blob/master/FLIRJPG_Convert.R 

# See https://github.com/gtatters/Thermimage/blob/master/README.md


</code></pre>

<hr>
<h2 id='cumulDiff'>
Cumulative difference sum function for use with frame by frame difference dataframe
</h2><span id='topic+cumulDiff'></span>

<h3>Description</h3>

<p>Based on the absolute difference sum method (Lighton and Turner, 2004), this function takes a difference frame dataframe, where each column corresponds to a video frame (i+1) that has been subtracted from the previous (ith) frame. Each row corresponds to a pixel difference value.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulDiff(fdiff, extract.times, samples = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulDiff_+3A_fdiff">fdiff</code></td>
<td>

<p>Dataframe containing the frame by frame differences obtained from the diffFrame function.  Rows corresponds to the pixel dimensions (w x h) of each frame and Columns (C-1) correpond to the number of columns, which is one fewer columns compared to the original video dataframe.
</p>
</td></tr>
<tr><td><code id="cumulDiff_+3A_extract.times">extract.times</code></td>
<td>

<p>A vector of times (POSIXct format) that corresponds to the actual frames from the original video file.  This should be length of C.
</p>
</td></tr>
<tr><td><code id="cumulDiff_+3A_samples">samples</code></td>
<td>

<p>The number of samples over which to calculate the slope of the cumulative difference sums.  Must be &gt;= 2, as it will calculate the slope over at least two frames.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row in fdiff corresponds to a specific pixel position in a thermal video frame.  Data frames are preferred over array functions for speed and simplicity.  Row numbers range from 1 through to the image dimensions (i.e. w*h = 640 * 480=307200). Image dimensions are not required, provided the row number corresponds to the same relative position.
</p>
<p>The premise behind this is that the thermal video is either time lapse or higher speed video. If a specific pixel shows no change (0) from frame to frame, then there is no movement or temperature change.  For videos of living specimens, movement artefacts will manifest as change over time at specific pixels.  If there is sufficient movement, across the image space, the accumulation of small differences will provide a measure of relative activity from frame to frame.
</p>
<p>cumulDiff takes the average, standard deviation and rootmean square of all pixels within one frame to arrive at an aggregate value for each difference frame (absolute value).  Subsequently, it sums these successive data points (avg,sd,rms) across all frames, arriving at an absolute difference summation.  This results in an incrementing value, of which the slope will be a semi-quantitative assessment of relative change.  It also provides a clean break point when activity ceases (Lighton, 2008).  
</p>
<p>The extract.times value (POSIX) is required to provide a time index as well as to calculate the frame rate.  
</p>


<h3>Value</h3>

<p>Returns a list variable, containing raw, cumulative difference calculations and the slope calculations on a minimum of 2, preferrably every 3rd frame.
</p>
<table>
<tr><td><code>rawdiff</code></td>
<td>
<p>rawdiff is a table of the cumulative average, sd, and rms values</p>
</td></tr>
<tr><td><code>slopediff</code></td>
<td>
<p>slopediff is the summarised rates of change over time in the rawdiff values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>1. Lighton, J.R.B., and Turner, R.J. (2004). Thermolimit respirometry: an objective assessment of critical thermal maxima in two sympatric desert harvester ants, Pogonomyrmex rugosus and P. californicus. J Exp Biol 207: 1903-1913.
</p>
<p>2. Lighton, J. R. B. (2008). Measuring metabolic rates : a manual for scientists. Oxford ; New York, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffFrame">diffFrame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a vector of arbitrary frame times - these would be extracted normally using the 
# locateFrames and getTimes functions

start&lt;-as.POSIXct("2017-03-31 12:00:00")
fdiff&lt;-data.frame(matrix(runif(307200*20, 20, 40), nrow=307200))

# add noise to pixels
for(i in 1:20){
  randpixels&lt;-floor(runif(10000, 1,307200))
  fdiff[randpixels,i]&lt;-fdiff[randpixels,i]*runif(1, 10, 10000)
}

extract.times&lt;-seq(start, start+20,1)
cumulDiff(fdiff, extract.times, 2)


</code></pre>

<hr>
<h2 id='diffFrame'>
A frame difference function for subtracting adjacent frames from an imported thermal image sequence.
</h2><span id='topic+diffFrame'></span>

<h3>Description</h3>

<p>Works similarly to the simple diff() function, but on a data.frame.  Subtracts column i from column i+1, assuming each column represents the pixel information for one frame of an imported thermal image video.  Each row in the column corresponds to a pixel.  Returns a data.frame of one column shorter dimension than the original data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffFrame(dat, absolute = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffFrame_+3A_dat">dat</code></td>
<td>

<p>A data.frame of R x C dimensions, where R represents the specific pixel, ranging from 1 to w x h rows, and C represents the frame number.  
</p>
</td></tr>
<tr><td><code id="diffFrame_+3A_absolute">absolute</code></td>
<td>

<p>If set to TRUE (default) the absolute difference between the value for each pixel is provided.  If set to FALSE, it will return the true difference (negative/positive values).  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Providing a data frame of R x C dimensions, returns a data frame of R x (C-1) dimensions, where each column represents the difference between adjacent columns.  Absolute or relative values are provided. 
</p>
<p>Each row in dat corresponds to a specific pixel position in a thermal video frame.  Data frames are preferred over array functions for speed and simplicity.  Row numbers range from 1 through to the image dimensions (i.e. w*h = 640 * 480=307200).  
</p>
<p>The premise behind this is that the thermal video is either time lapse or higher speed video. If a specific pixel shows no change (0) from frame to frame, then there is no movement or temperature change.  For videos of living specimens, movement artefacts will manifest as change over time at specific pixels.  If there is sufficient movement, across the image space, the accumulation of small differences will provide a measure of relative activity from frame to frame.
</p>
<p>In combination of a cumulative summation function (cumulDiff), the diffFrame function can assess relative change in movement or activity.  This makes use of a concept called the absolute difference sum method, sometimes used to simplify noisy data.  See cumulDiff for further info.
</p>


<h3>Value</h3>

<p>Returns a data frame of R x (C-1) dimensions, where each column represents the difference between adjacent columns.  
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>1. Lighton, J.R.B., and Turner, R.J. (2004). Thermolimit respirometry: an objective assessment of critical thermal maxima in two sympatric desert harvester ants, Pogonomyrmex rugosus and P. californicus. J Exp Biol 207: 1903-1913.
</p>
<p>2. Lighton, J. R. B. (2008). Measuring metabolic rates : a manual for scientists. Oxford ; New York, Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cumulDiff">cumulDiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# set w to 640 and h to 480
w&lt;-640
h&lt;-480
f&lt;-system.file("extdata", "SampleSEQ.seq", package = "Thermimage")
x&lt;-frameLocates(f, w=w, h=h)
suppressWarnings(templookup&lt;-raw2temp(1:65535))
alldata&lt;-unlist(lapply(x$f.start, getFrames, vidfile=f, w=w, h=h))
alldata&lt;-matrix(alldata, nrow=w*h, byrow=FALSE)
alltemperature&lt;-templookup[alldata]
alltemperature&lt;-unname(matrix(alltemperature, nrow=w*h, byrow=FALSE))

dalltemperature&lt;-as.matrix(diffFrame(alltemperature, absolute=TRUE), nrow=w)

# Plot 
plotTherm(dalltemperature[,1], templookup=NULL, w=w, h=h,  minrangeset=min(dalltemperature),
          maxrangeset=max(dalltemperature), trans="mirror.matrix")



</code></pre>

<hr>
<h2 id='ffmpegcall'>
A simplified wrapper function calling ffmpeg 
</h2><span id='topic+ffmpegcall'></span>

<h3>Description</h3>

<p>A simplified wrapper function calling ffmpeg to convert numbered files extracted from FLIR thermal image videos via exiftool into radiometric png files or radiometric avi files.  Mostly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffmpegcall(filenameroot, filenamesuffix="%05d", filenameext="jpegls", 
incompresstype="jpegls", fr=30, res.in="640x480", res.out=res.in, 
outputcompresstype="png", outputfilenameroot=NULL, outputfiletype="avi", 
outputfolder="output",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffmpegcall_+3A_filenameroot">filenameroot</code></td>
<td>

<p>The base root of the files to be converted, without the indexing.  If numbered files are: &quot;Frame00001.fff&quot;, &quot;Frame00002.fff&quot;, etc., then filenameroot = &quot;Frame&quot;.
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_filenamesuffix">filenamesuffix</code></td>
<td>

<p>The suffix defining the indexing numbers associated with filename.  If numbered files are: &quot;Frame00001.fff&quot;, &quot;Frame00002.fff&quot;, etc., then filenamesuffix = &quot;%05d&quot;
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_filenameext">filenameext</code></td>
<td>

<p>File extension for input files.  Typically &quot;jpegls&quot; or &quot;fff&quot;&quot;, depending on the video or image filetype (SEQ files are extracted into .fff files; CSQ files are extracted into .jpegls files).  Default = &quot;jpegls&quot;.
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_incompresstype">incompresstype</code></td>
<td>

<p>Input file compression type.  Typically &quot;tiff&quot; (non compressed data in SEQ videos files) or &quot;jpegls&quot; (corresponds to jpegls, a lossless jpeg format (see Details and References).
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_fr">fr</code></td>
<td>

<p>Frame rate of input video data, frames per sec.  Default = 30.
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_res.in">res.in</code></td>
<td>

<p>Input file image resolution in text format, &quot;wxh&quot;.  Default = &quot;640x480&quot;
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_res.out">res.out</code></td>
<td>

<p>Desired output file image resolution in text format, &quot;wxh&quot;. Decrease to make smaller file, but maintain same aspect ratio.  Default = &quot;640x480&quot;.
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_outputcompresstype">outputcompresstype</code></td>
<td>

<p>Desired output file image compression format.  Possible values are &quot;tiff&quot;, &quot;png&quot; or &quot;jpegls&quot; (or any modifier from ffmpeg -vcodec).  Default = &quot;png&quot;.
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_outputfilenameroot">outputfilenameroot</code></td>
<td>

<p>The base root of the output file(s) to be exported, without the indexing.  If NULL, then the input filenameroot will be used and a numeric index attached.  Default is NULL.
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_outputfiletype">outputfiletype</code></td>
<td>

<p>Desired output file type, &quot;avi&quot; or &quot;png&quot;.  If &quot;png&quot;, multiple files will be exported.  If &quot;avi&quot;, a single video file will be exported.  Default = &quot;avi&quot;
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_outputfolder">outputfolder</code></td>
<td>

<p>Desired output subfolder name, placed inside the folder where the input files are stored.  Default = &quot;output&quot;.
</p>
</td></tr>
<tr><td><code id="ffmpegcall_+3A_...">...</code></td>
<td>

<p>Other values to pass to command line functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls ffmpeg in shell to convert a series of image files, named filenameroot%05d.filenameext, extracted from a thermal image file using the command line tool, exiftool.  The subsequent converted file is a 16 bit grayscale avi or series of images corresponding to each of the input files.
</p>
<p>For example, a typical shell call to ffmpeg might look like:
</p>
<p>ffmpeg -f image2 -vcodec fff -i frame%05d.fff -f image2 -vcodec png frame%05d.png -y
</p>
<p>which converts a series of fff files (frameNNNNN.fff) into a series of png files (frameNNNNN.png).
</p>
<p>Likewise, the following:
</p>
<p>ffmpeg -r 30 -f image2 -vcodec jpegls -s 1024x768 -i frame%05d.jpegls -vcodec png -s 1024x768 frame.avi -y
</p>
<p>converts a series of jpegls files (frameNNNNN.jpegls) into an avi file (frame.avi) with png style compression
</p>
<p>Jpeg-ls is a lossless jpg format (JPG-LS) that is used for certain flir image types (e.g., CSQ, Ultramax FLIR jpg).  The easiest means to convert the extracted, compressed data type is with ffmpeg, which contains the codecs for extraction. 
</p>
<p>For example, once ffmpeg is installed, try in shell: 
</p>
<p>ffmpeg -codecs | grep jpegls
</p>


<h3>Value</h3>

<p>No output generated in R.  Shell call to ffmpeg to convert files.  ffmpeg must be installed on the system.
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>References</h3>

<p>1. https://www.ffmpeg.org/
</p>
<p>2. https://www.eevblog.com/forum/thermal-imaging/csq-file-format/
</p>
<p>3. http://www.digitalpreservation.gov/formats/fdd/fdd000151.shtml 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convertflirVID">convertflirVID</a></code>, 
<code><a href="#topic+convertflirJPG">convertflirJPG</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples 
# See https://github.com/gtatters/FLIRJPGConvert/blob/master/Examples.R

# See https://github.com/gtatters/Thermimage/blob/master/README.md
</code></pre>

<hr>
<h2 id='flip.matrix'>
Flips a matrix 'left-right'.  Used in re-arranging image data for plotting properly in R.
</h2><span id='topic+flip.matrix'></span>

<h3>Description</h3>

<p>Flips a matrix 'left-right'.  Used in re-arranging image data for plotting properly in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip.matrix_+3A_x">x</code></td>
<td>

<p>A matrix corresponding to raster or image data.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>1. http://www.inside-r.org/packages/cran/RSEIS/docs/mirror.matrix
</p>
<p>2. Based on similar code in package &lt;RSEIS&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mirror.matrix">mirror.matrix</a></code>
<code><a href="#topic+rotate90.matrix">rotate90.matrix</a></code>
<code><a href="#topic+rotate270.matrix">rotate270.matrix</a></code>
<code><a href="#topic+rotate180.matrix">rotate180.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (x) 
{
    mirror.matrix(rotate180.matrix(x))
  }


par(mfrow=c(1,2),mar=c(1,1,1,1))
r&lt;-c(1:100,rnorm(1:100)*10,1:100)
m&lt;-matrix(r,20)
image(m, axes=FALSE)
box()
text(.5,.5,"Matrix",col="white")
mf&lt;-flip.matrix(m)
image(mf,axes=FALSE)
box()
text(.5,.5,"Flipped",col="white")
  
</code></pre>

<hr>
<h2 id='flirpal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+flirpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='flirsettings'>
Extracts meta tag information from a FLIR JPG image
</h2><span id='topic+flirsettings'></span>

<h3>Description</h3>

<p>Extracts meta tag information from a FLIR JPG image using system installed Exiftool application.  Use this to obtain thermal image calibration values, date/time stamps, object distance, and other parameters saved in FLIR image or video files. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flirsettings(imagefile, exiftoolpath = "installed", camvals = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flirsettings_+3A_imagefile">imagefile</code></td>
<td>

<p>Name of the FLIR JPG file to read from, as captured by the thermal camera.  A character string.
</p>
</td></tr>
<tr><td><code id="flirsettings_+3A_exiftoolpath">exiftoolpath</code></td>
<td>

<p>A character string that determines whether Exiftool has been &quot;installed&quot; (http://www.sno.phy.queensu.ca/~phil/exiftool/) or not.  If Exiftool has been installed in a specific location, use to direct to the folder location.
</p>
</td></tr>
<tr><td><code id="flirsettings_+3A_camvals">camvals</code></td>
<td>

<p>A list of arguments to be passed to Exiftool as described in Exiftool documentation.  A character string.  Default value (recommended) is &quot;&quot;, which will pass all possible arguments to Exiftool.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The imagefile should be the original captured FLIR JPG file, not a modified JPG. This also works with FLIR video files (.seq and .fcf).    
</p>
<p>Exiftool should install on most operating systems.  Consult with http://www.sno.phy.queensu.ca/~phil/exiftool/ for information on installing Exiftool.  If trouble installing, download Exiftool perl scripts and set exiftoolpath to the custom folder locationto access the perl scripts that are attached with this package. 
</p>
<p>For camvals, provide a character string as described in Exiftool documentation.   Set camvals=&quot;-*Emissivity&quot;, to simply return the Emissivity value. Set camvals=&quot;-*Planck*&quot; for camera calibration constants.
</p>
<p>Note: the Emissivity value is simply that which is stored in the file.  It typically is the default value the camera is set to (0.95), but this does not mean that the true Emissivity of the surface is what is stored in the file.  Similar caution is advised regarding the environmental parameters returned from the meta tags.  User knowledge is required.
</p>


<h3>Value</h3>

<p>Returns a list of camera meta tags for use in thermal imaging calculations.  
</p>
<p>Info is the basic list of camera settings.
</p>
<p>Dates will be the date values associated with the image creation, modification etc.
</p>


<h3>Note</h3>

<p>Requires Exiftool be installed.  see http://www.sno.phy.queensu.ca/~phil/exiftool/
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>1. http://www.sno.phy.queensu.ca/~phil/exiftool/
2. http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## To access meta-tag information from a flir jpg or flir file:

## Example using the flirsettings functions:

library(Thermimage)
## Sample flir jpg included with Thermimage package:

imagefile&lt;-paste0(system.file("extdata/IR_2412.jpg", package="Thermimage"))

## Extract meta-tags from thermal image file ##
cams&lt;-flirsettings(imagefile, exiftool="installed", camvals="")
cams

## Set variables for calculation of temperature values from raw A/D sensor data
Emissivity&lt;-cams$Info$Emissivity      # Image Saved Emissivity - should be ~0.95 or 0.96
ObjectEmissivity&lt;-0.96                # Object Emissivity - should be ~0.95 or 0.96
dateOriginal&lt;-cams$Dates$DateTimeOriginal
dateModif&lt;-   cams$Dates$FileModificationDateTime
PlanckR1&lt;-    cams$Info$PlanckR1                      # Planck R1 constant for camera  
PlanckB&lt;-     cams$Info$PlanckB                       # Planck B constant for camera  
PlanckF&lt;-     cams$Info$PlanckF                       # Planck F constant for camera
PlanckO&lt;-     cams$Info$PlanckO                       # Planck O constant for camera
PlanckR2&lt;-    cams$Info$PlanckR2                      # Planck R2 constant for camera
ATA1&lt;-        cams$Info$AtmosphericTransAlpha1        # Atmospheric attenuation constant
ATA2&lt;-        cams$Info$AtmosphericTransAlpha2        # Atmospheric attenuation constant
ATB1&lt;-        cams$Info$AtmosphericTransBeta1         # Atmospheric attenuation constant
ATB2&lt;-        cams$Info$AtmosphericTransBeta2         # Atmospheric attenuation constant
ATX&lt;-         cams$Info$AtmosphericTransX             # Atmospheric attenuation constant
OD&lt;-          cams$Info$ObjectDistance                # object distance in metres
FD&lt;-          cams$Info$FocusDistance                 # focus distance in metres
ReflT&lt;-       cams$Info$ReflectedApparentTemperature  # Reflected apparent temperature
AtmosT&lt;-      cams$Info$AtmosphericTemperature        # Atmospheric temperature
IRWinT&lt;-      cams$Info$IRWindowTemperature           # IR Window Temperature
IRWinTran&lt;-   cams$Info$IRWindowTransmission          # IR Window transparency
RH&lt;-          cams$Info$RelativeHumidity              # Relative Humidity
h&lt;-           cams$Info$RawThermalImageHeight         # sensor height (i.e. image height)
w&lt;-           cams$Info$RawThermalImageWidth          # sensor width (i.e. image width)

## See also https://github.com/gtatters/Thermimage/README.md

## End(Not run)


</code></pre>

<hr>
<h2 id='forcedparameters'>
Parameters required for forced convection equation.
</h2><span id='topic+forcedparameters'></span>

<h3>Description</h3>

<p>Parameters required for forced convection equation and heat exchange estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forcedparameters(V = 1, L = 0.1, Ta = 20, shape = "hcylinder")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forcedparameters_+3A_v">V</code></td>
<td>

<p>Air velocity in metres/second.  Used in call to Reynolds().  Default is 0.1.
</p>
</td></tr>
<tr><td><code id="forcedparameters_+3A_l">L</code></td>
<td>

<p>Characteristic dimension in metres.  Default value is 0.1.
</p>
</td></tr>
<tr><td><code id="forcedparameters_+3A_ta">Ta</code></td>
<td>

<p>Air temperature in degrees celsius. Used in call to Reynolds().  Default is 20.
</p>
</td></tr>
<tr><td><code id="forcedparameters_+3A_shape">shape</code></td>
<td>

<p>&quot;sphere&quot;, &quot;hplate&quot;, &quot;vplate&quot;, &quot;hcylinder&quot;, &quot;vcylinder&quot; to denote shape and orientation.  h=horizontal, v=vertical.  Default shape is &quot;hcylinder&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gates (2003) describes coefficients that characterise the base and exponent values used to calculate Nusselt numbers from Reynolds number as: c*Re^n. This function will return those parameters.
</p>


<h3>Value</h3>

<p>A vector of length two, with values c and n.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, 1986.  Energy metabolism in animals and man.  Cambridge University Press, Cambridge, UK, 340 pp.
</p>
<p>Gates, DM. 2003.  Biophysical Ecology.  Dover Publications, Mineola, New York, 611 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freeparameters">freeparameters</a></code>
<code><a href="#topic+Nusseltforced">Nusseltforced</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (V = 1, L = 0.1, Ta = 20, shape = "hcylinder") 
{
    Re &lt;- Reynolds(V, L, airviscosity(Ta))
    if (shape == "vplate" | shape == "hplate") 
        shape &lt;- "plate"
    if (shape == "vcylinder" | shape == "hcylinder") 
        shape &lt;- "cylinder"
    if (shape == "plate") {
        c = 0.595
        n = 0.5
    }
    if (shape == "sphere") {
        c = 0.37
        n = 0.6
    }
    if (shape == "cylinder" &amp; Re &gt;= 0.4 &amp; Re &lt; 4) {
        c &lt;- 0.891
        n = 0.33
    }
    if (shape == "cylinder" &amp; Re &gt;= 4 &amp; Re &lt; 40) {
        c &lt;- 0.821
        n = 0.385
    }
    if (shape == "cylinder" &amp; Re &gt;= 40 &amp; Re &lt; 4000) {
        c &lt;- 0.615
        n = 0.466
    }
    if (shape == "cylinder" &amp; Re &gt;= 4000 &amp; Re &lt; 40000) {
        c &lt;- 0.174
        n = 0.618
    }
    if (shape == "cylinder" &amp; Re &gt;= 40000 &amp; Re &lt; 4e+05) {
        c &lt;- 0.024
        n = 0.805
    }
    coeffs &lt;- c(c, n)
    names(coeffs) &lt;- c("c", "n")
    coeffs
  }
  # Example:
V&lt;-1
L&lt;-0.1
Ta&lt;-20
shape="hcylinder"
forcedparameters(V, L, Ta, shape)

shape="vcylinder"
forcedparameters(V, L, Ta, shape)

shape="hplate"
forcedparameters(V, L, Ta, shape)

shape="vplate"
forcedparameters(V, L, Ta, shape)

shape="sphere"
forcedparameters(V, L, Ta, shape)

</code></pre>

<hr>
<h2 id='frameLocates'>
Find the frame read start positions in a FLIR SEQ video file.
</h2><span id='topic+frameLocates'></span>

<h3>Description</h3>

<p>Using readBin function, find everywhere in file where the magic-byte/thermal resolution info is stored: i.e. 640x480, 320x240.  These positions denote where the image frame data is found in the larger video file and will facilitate extraction of image save times and pixel information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frameLocates(vidfile = "", w = 640, h = 480)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frameLocates_+3A_vidfile">vidfile</code></td>
<td>

<p>Filename or filepath (as character) of the thermal video.  Should end in .seq or .fcf.  Not tested comprehensively so it may only work for certain camera models and software packages.  
</p>
</td></tr>
<tr><td><code id="frameLocates_+3A_w">w</code></td>
<td>

<p>Width resolution (pixels) of thermal camera.  Can be found by using the flirsettings function.
</p>
</td></tr>
<tr><td><code id="frameLocates_+3A_h">h</code></td>
<td>

<p>Height resolution (pixels) of thermal camera. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FLIR cameras have built-in radiometric video saving functions.  FLIR software also has similar video, or time lapse, functionality.  These files are typically stored as .seq or .fcf and encode information on the thermal imaging camera model, calibration, date/time, etc.  These meta-tags can be extracted using system installed software (Exiftool).  
</p>
<p>This function makes use of the readBin function in the R base package, by loading a small portion of the file in raw().  It then searches through this data vector for the magic byte sequence in hexadecimal (0200wwwwhhhh) where wwww is the image width in little endian hexadecimal, and hhhh is the image height in little endian hexademical.
</p>
<p>The actual start of all the magic byte locations is empirically determined by the repeating pattern of locations within the file.  
</p>
<p>Frame refers to the still frame that is to be extracted from the thermal video file.
</p>
<p>The function returns a list, containing the 'header' start (h.start) position of each frame and the 'frame' start (f.start) where pixel data is stored in raw, binary format (at present, in 16-Bit integers).  
</p>
<p>h.start and f.start can be passed to other functions to extract the precise times of each frame (getTimes) and to extract the actual frame by frame data (getFrames).
</p>
<p>The length of h.start and f.start should be the same.  If these are blank, then the detection process has not worked and the filetype might not be supported by this function.  
</p>
<p>Warning: this is not tested on all samples of all video file types and may return errors for .fcf files.  
</p>


<h3>Value</h3>

<p>Returns a list, containing two vectors, h.start and f.start.  These should be the same length.
</p>
<table>
<tr><td><code>h.start</code></td>
<td>
<p>A vector containing the byte read position start points in the file to extract header information from each frame.  Typically passed to the getTimes function.</p>
</td></tr>
<tr><td><code>f.start</code></td>
<td>
<p>A vector containing the byte read position start points in the file to extract raw, binary pixel data from each frame.  Typically passed to the getFrames function.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Requires Exiftool be installed in order to automatically determine thermal image width and height.  If you know the width and height in pixels, then the frame start locations can be determined.
</p>
<p>For information on installing Exiftool, see http://www.sno.phy.queensu.ca/~phil/exiftool/
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>1. http://www.sno.phy.queensu.ca/~phil/exiftool/
2. http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getFrames">getFrames</a></code>,
<code><a href="#topic+getTimes">getTimes</a></code>,
<code><a href="base.html#topic+readBin">readBin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-frameLocates(vidfile = system.file("extdata", "SampleSEQ.seq", package = "Thermimage"))
x$h.start
x$f.start

</code></pre>

<hr>
<h2 id='freeparameters'>
Parameters required for free convection equation.
</h2><span id='topic+freeparameters'></span>

<h3>Description</h3>

<p>Parameters required for free convection equation and heat exchange estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freeparameters(L = 0.1, Ts = 30, Ta = 20, shape = "hcylinder")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freeparameters_+3A_l">L</code></td>
<td>

<p>Characteristic dimension in metres.  Default is 0.1.
</p>
</td></tr>
<tr><td><code id="freeparameters_+3A_ts">Ts</code></td>
<td>

<p>Surface temperature (degrees Celsius) of object.  Default is 30.
</p>
</td></tr>
<tr><td><code id="freeparameters_+3A_ta">Ta</code></td>
<td>

<p>Air temperature (degrees Celsius) of environment.  Defauly is 20.
</p>
</td></tr>
<tr><td><code id="freeparameters_+3A_shape">shape</code></td>
<td>

<p>&quot;sphere&quot;, &quot;hplate&quot;, &quot;vplate&quot;, &quot;hcylinder&quot;, &quot;vcylinder&quot; to denote shape and orientation.  h=horizontal, v=vertical.  Default shape is &quot;hcylinder&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gates (2003) describes coefficients that characterise laminar flow patterns describing how to calculate Nusselt numbers for objects of different shapes.  This function will return those parameters.  At present, it only supplies coefficients for different shapes, not for laminar vs. turbulent since free convection is not often used in biological applications.
</p>


<h3>Value</h3>

<p>A vector of length three, with values a, b, and m.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, 1986.  Energy metabolism in animals and man.  Cambridge University Press, Cambridge, UK, 340 pp.
</p>
<p>Gates, DM. 2003.  Biophysical Ecology.  Dover Publications, Mineola, New York, 611 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Nusseltfree">Nusseltfree</a></code>
<code><a href="#topic+forcedparameters">forcedparameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (L = 0.1, Ts = 30, Ta = 20, shape = "hcylinder") 
{
    a = 1
    Gr &lt;- Grashof(L = 1, Ts = Ts, Ta = Ta)
    Pr &lt;- Prandtl(Ta)
    if (shape == "hcylinder") {
        b &lt;- 0.53
        m &lt;- 0.25
    }
    if (shape == "vcylinder") {
        b &lt;- 0.726
        m &lt;- 0.25
    }
    if (shape == "hplate") {
        b &lt;- 0.71
        m &lt;- 0.25
    }
    if (shape == "vplate") {
        b &lt;- 0.523
        m &lt;- 0.25
    }
    if (shape == "sphere") {
        b &lt;- 0.58
        m &lt;- 0.25
    }
    coeffs &lt;- c(a, b, m)
    names(coeffs) &lt;- c("a", "b", "m")
    coeffs
  }

# Example:
L&lt;-0.1
Ts&lt;-30
Ta&lt;-20
shape="hcylinder"
freeparameters(L, Ts, Ta, shape)

shape="vcylinder"
freeparameters(L, Ts, Ta, shape)

shape="hplate"
freeparameters(L, Ts, Ta, shape)

shape="vplate"
freeparameters(L, Ts, Ta, shape)

shape="sphere"
freeparameters(L, Ts, Ta, shape)

</code></pre>

<hr>
<h2 id='getFrames'>
Extract raw binary thermal from thermal image file.
</h2><span id='topic+getFrames'></span>

<h3>Description</h3>

<p>Extracts raw binary thermal image data in integer format as a vector from a flir seq file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFrames(vidfile, framestarts, w = 640, h = 480, l = w * h, byte.length = 2, 
reverse=FALSE, magic2pixel=32)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFrames_+3A_vidfile">vidfile</code></td>
<td>

<p>Filename or filepath (as character) of the thermal video.  Should end in .seq or .fcf.  Not tested comprehensively with .fcf files, so it may only work for certain camera models and software packages.
</p>
</td></tr>
<tr><td><code id="getFrames_+3A_framestarts">framestarts</code></td>
<td>

<p>An integer value corresponding to the actual pixel read byte start position in the thermal video file.  Acquired using the frameLocates function.  
</p>
</td></tr>
<tr><td><code id="getFrames_+3A_w">w</code></td>
<td>

<p>Width of thermal image.
</p>
</td></tr>
<tr><td><code id="getFrames_+3A_h">h</code></td>
<td>

<p>Height of thermal image
</p>
</td></tr>
<tr><td><code id="getFrames_+3A_l">l</code></td>
<td>

<p>The total size (length) of pixel data corresponding to one image = width * height.  User does not need to set this.
</p>
</td></tr>
<tr><td><code id="getFrames_+3A_byte.length">byte.length</code></td>
<td>

<p>Set to 2 by default.  Each pixel information is encoded in two bytes (i.e. 16 bit), leading to an integer value ranging from 1 to 2^16. Pixel data are read in order in the file and converted to integer using the readBin function. User does not need to set this.
</p>
</td></tr>
<tr><td><code id="getFrames_+3A_reverse">reverse</code></td>
<td>

<p>Set to FALSE by default.  Will provide the vector in reverse order.
</p>
</td></tr>
<tr><td><code id="getFrames_+3A_magic2pixel">magic2pixel</code></td>
<td>

<p>Set to 32 by default.  This is the number of bytes ahead of the magicbyte where pixel information generally starts.  User does not need to set this, but this might help diagnose oddly aligned frames.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will load into memory the raw binary pixel data from the entire thermal video file.  Data are stored as read in using the readBin function, but the number of frames read in can be determined by dividing the length of the vector by (w*h*byte.length).  Depending on the size of the video, this can become quite large.  
</p>
<p>Frame data is stored as a vector to speed calculations.  Thermal video files may exceed memory capacity of some systems, so processing as arrays or dataframes is generally avoided.
</p>
<p>As written, this is a vectorised function, so will only load in one frame is used normally.  To load multiple frames from the video file, use a for-loop (usually slow) or the apply function to import (faster processing) or parallel apply functions (best).  
</p>


<h3>Value</h3>

<p>Returns a vector of integers, each item corresponding to raw pixel value.  With information on thermal image width and height, the specific image can be reconstructed.  To be used in conjunction with raw2temp function which will convert this raw binary value into an estimated temperature.
</p>


<h3>Note</h3>

<p>Requires Exiftool be installed in order to automatically determine thermal image width and height.  If you know the width and height in pixels, then the frame start locations can be determined.
</p>
<p>For information on installing Exiftool, see http://www.sno.phy.queensu.ca/~phil/exiftool/
</p>
<p>See convertflirVID function for an alternative to getFrames.  The latter is loaded into R, which has high processor requirements.  It is likely more feasible to first convert the thermal video into a format to be imported into an image stack processing program like ImageJ.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>1. http://www.sno.phy.queensu.ca/~phil/exiftool/
2. http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frameLocates">frameLocates</a></code>,
<code><a href="#topic+getTimes">getTimes</a></code>,
<code><a href="base.html#topic+readBin">readBin</a></code>,
<code><a href="#topic+raw2temp">raw2temp</a></code>,
<code><a href="#topic+convertflirVID">convertflirVID</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set w to 640 and h to 480

w&lt;-640
h&lt;-480
f&lt;-system.file("extdata", "SampleSEQ.seq", package = "Thermimage")
x&lt;-frameLocates(f, w=w, h=h)

# Slow approach:
system.time({
  alldata&lt;-matrix(nrow=w*h, ncol=length(x$f.start))
  for(i in 1:length(x$f.start)) alldata[,i]&lt;-getFrames(f, x$f.start[i], w, h)
})
dim(alldata)

# Faster approach
alldata&lt;-NULL
system.time(alldata&lt;-unlist(lapply(x$f.start, getFrames, vidfile=f, w=w, h=h)))
length(alldata)/(w*h)

## Parallel approach (requires parallel package. will not be faster on small files)
# library(parallel)
# alldata&lt;-NULL
## set mc.cores to higher number to use parallel processing
# system.time(alldata&lt;-unlist(mclapply(x$f.start, getFrames, vidfile=f, mc.cores=1)))
# length(alldata)/(w*h) # number of frames in video

</code></pre>

<hr>
<h2 id='getTimes'>
Extracts time values from binary imported thermal video file
</h2><span id='topic+getTimes'></span>

<h3>Description</h3>

<p>Extracts time values for each image frame from a thermal camera video file (.seq or with some .fcf).  For time lapse or video capture, computer time is stored for each image frame in 3 chunks, denoting msec, sec, and date information.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTimes(vidfile, headstarts, timestart = 900, byte.length = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimes_+3A_vidfile">vidfile</code></td>
<td>

<p>Filename or filepath (as character) of the thermal video.  Should end in .seq or .fcf.  Not tested comprehensively so it may only work for certain camera models, software packages, file type combinations.
</p>
</td></tr>
<tr><td><code id="getTimes_+3A_headstarts">headstarts</code></td>
<td>

<p>A vector of integers corresponding to the header read byte start positions in the thermal video file.  Acquired using the getFrames function.  The header information is where the magicbyte + width + height image information is located (ie. FLIR CameraInfo Tags from the Exiftool library), as well as information on the camera, calibration, time of image capture, etc...are stored.  
</p>
</td></tr>
<tr><td><code id="getTimes_+3A_timestart">timestart</code></td>
<td>

<p>Set to 900 by default.  Once the header start location has been determined with the frameLocates function, the frame times were stored in 900 bytes into the header.  The user should not need to set this.
</p>
</td></tr>
<tr><td><code id="getTimes_+3A_byte.length">byte.length</code></td>
<td>

<p>Set to 1 by default. User does not need to set this.  Deprecated option from an older version of this function.s
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Somewhat empirically determined, but also information provided on the exiftool website below describes where time stamp information is stored in each file.  This function concatentates the 3 time stamps corresponding to msec, sec, and date into one variable that gives the actual time each image was captured.
</p>
<p>As written, this is a vectorised function, so to extract multiple frames of data (i.e. length(headstarts)&gt;1), use a loop or the apply function as shown in the example below. 
</p>
<p>Extracted times are used in sumamrising information about the temperature profiles of the thermal videos and can be passed to the cumulDiff function.  
</p>
<p>Extracted times can also be used to verify the frame rate of the image capture in the video.  
</p>
<p>Has not been fully tested on file types from all cameras or thermal imaging software.
</p>


<h3>Value</h3>

<p>Returns a vector of times as characters corresponding to the frame capture times as extracted from the thermal video file.  Times should resemble those returned using Exiftool.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>1. http://www.sno.phy.queensu.ca/~phil/exiftool/
</p>
<p>2. http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html
</p>
<p>3. http://www.silisoftware.com/tools/date.php
</p>
<p>4. http://www.sandersonforensics.com/forum/content.php?131-A-brief-history-of-time-stamps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getFrames">getFrames</a></code>,
<code><a href="#topic+frameLocates">frameLocates</a></code>,
<code><a href="#topic+cumulDiff">cumulDiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w=640
h=480
f&lt;-system.file("extdata", "SampleSEQ.seq", package = "Thermimage")
x&lt;-frameLocates(f, w=w, h=h)
getTimes(f, x$h.start)

# only returns the first frame of data, must use lapply to get all frames

# Using lapply
extract.times&lt;-do.call("c", lapply(x$h.start, getTimes, vidfile=f))
extract.times

# Using parallel lapply (uncomment below):
# library(parallel)
## set mc.cores to higher number to use parallel processing:
# extract.times&lt;-do.call("c", mclapply(x$h.start, getTimes, vidfile=f, mc.cores=1))
# extract.times

</code></pre>

<hr>
<h2 id='glowbowpal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+glowbowpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='Grashof'>
Determines the Grashof number for an object
</h2><span id='topic+Grashof'></span>

<h3>Description</h3>

<p>Determines the Grashof number for an object.  The Grashof number is used in
calculations of heat exchange.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Grashof(L = 1, Ts = 25, Ta = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Grashof_+3A_l">L</code></td>
<td>

<p>Characteristic dimension of object in metres.  Usually height, depending on object shape.
</p>
</td></tr>
<tr><td><code id="Grashof_+3A_ts">Ts</code></td>
<td>

<p>Surface Temperature of object, in degrees Celsius.
</p>
</td></tr>
<tr><td><code id="Grashof_+3A_ta">Ta</code></td>
<td>

<p>Air/Ambient Temperature surrounding object, in degrees Celsius.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Grashof number is a dimensionless number describing the ability of a parcel of fluid 
warmer or colder than the surrounding fluid to rise against or fall with the attractive
force of gravity as follows:
Gr=agL^3(Ts-Ta)/v^2
where
L is the characteristic dimension, usually the vertical dimension.  For reference, 
a cylinder's characteristic L would be its height, assuming it is standing on its end
Units of L should be in metres
This L should be the same L as is used for the convective coefficient calculation
Ts is the surface temperature
Ta is the ambient temperature
v2 is the kinematic viscosity squared (calculated from airviscosity(Ta))
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, K. 1989.  Energy Metabolism in Animals and Man.
Gates, D. M. 2003.  Biophysical Ecology.  Dover Publications, Mineola, New York.  611 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+airviscosity">airviscosity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Typical values for Grashof number range from 0.016 to 4.6e+09 if Ts-Ta varies from 
# 0.1 to 30oC

L&lt;-1
Ts&lt;-30
Ta&lt;-20
Grashof(L, Ts, Ta)  

</code></pre>

<hr>
<h2 id='grey10pal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+grey10pal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='grey120pal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+grey120pal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='greyredpal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+greyredpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='hconv'>
Convective heat coefficient (W/m2/oC)
</h2><span id='topic+hconv'></span>

<h3>Description</h3>

<p>Calculates the convective heat coefficient for an object of known dimensions, and given various physical parameters, typically only for laminar flow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hconv(Ts=30, Ta = 20, V = 1, L = 0.1, c = NULL, n = NULL, a = NULL, b = NULL, m = NULL, 
type = "forced", shape="hcylinder")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hconv_+3A_ts">Ts</code></td>
<td>

<p>Surface temperature (degrees celsius). Required for free convection function call.  Default value is 30.  
</p>
</td></tr>
<tr><td><code id="hconv_+3A_ta">Ta</code></td>
<td>

<p>Air temperature (degrees celsius). Default value is 20.
</p>
</td></tr>
<tr><td><code id="hconv_+3A_v">V</code></td>
<td>

<p>Air velocity (m/s).  Default value is 1.
</p>
</td></tr>
<tr><td><code id="hconv_+3A_l">L</code></td>
<td>

<p>Characteristic dimension (m) of object.  Usually the vertical dimension (i.e. height). Default value is 0.1.
</p>
</td></tr>
<tr><td><code id="hconv_+3A_c">c</code></td>
<td>

<p>coefficient used in forced convection (see Gates, 2003). Default value is NULL, typical values is 0.24)
</p>
</td></tr>
<tr><td><code id="hconv_+3A_n">n</code></td>
<td>

<p>coefficient used in forced convection (see Gates, 2003). Default value is NULL, typical value is 0.6)
</p>
</td></tr>
<tr><td><code id="hconv_+3A_a">a</code></td>
<td>

<p>coefficient used in forced convection (see Gates, 2003). Default value is NULL, typical value is 1.
</p>
</td></tr>
<tr><td><code id="hconv_+3A_b">b</code></td>
<td>

<p>coefficient used in free convection (see Gates, 2003). Default value is NULL, typical value is 0.58 for upright cylinder, 0.48 for horizontal cylinder.
</p>
</td></tr>
<tr><td><code id="hconv_+3A_m">m</code></td>
<td>

<p>coefficient used in free convection.  Default is NULL.  For laminar flow, m=0.25
</p>
</td></tr>
<tr><td><code id="hconv_+3A_type">type</code></td>
<td>

<p>&quot;forced&quot; or &quot;free&quot; - to calculate convection coefficient for either forced or free convection.  Default value is &quot;forced&quot;
</p>
</td></tr>
<tr><td><code id="hconv_+3A_shape">shape</code></td>
<td>

<p>&quot;sphere&quot;, &quot;hplate&quot;, &quot;vplate&quot;, &quot;hcylinder&quot;, &quot;vcylinder&quot; to denote shape and orientation.  h=horizontal, v=vertical.  Default shape is &quot;hcylinder&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the convection coefficient for heat transfer estimation by estimating Nusselt's number.  Used in conjunction with known temperature differences in order to estimate heat transfer via convection.  Gates advises to use &quot;forced&quot; convection coefficients down to 0.1 m/s as appropriate for very low air flow rates, rather than distinguishing between &quot;free&quot; and &quot;forced&quot; convection.  Nussel's number depends on whether forced or free convection is specified.  There may be some conditions (i.e. combinations of wind speeds, critical dimensions) where Nusselt's numbers are unspecified, since these values fall outside the range of Reynold's number for which estimates of convection coefficients are plausible.
</p>
<p>Caution is advised when using hconv without considering the assumptions of convective heat exchange, and users are advised to check with Gates (2003) to see if estimates provided with this function are within the predicted range.   
</p>


<h3>Value</h3>

<p>A value corresponding to the convection coefficient, units: W/m/oC.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, 1986.  Energy metabolism in animals and man.  Cambridge University Press, Cambridge, UK, 340 pp.
</p>
<p>Gates, DM. 2003.  Biophysical Ecology.  Dover Publications, Mineola, New York, 611 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qconv">qconv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (Ts=30, Ta = 20, V = 1, L = 0.1, c = NULL, n = NULL, a = NULL, b = NULL, 
    m = NULL, type = "forced", shape="hcylinder") 
{
    if (V == 0) 
        type &lt;- "free"
    if (type == "forced" | type == "Forced") 
        Nu &lt;- Nusseltforced(c = c, n = n, V = V, L = L, Ta = Ta, shape="hcylinder")
    if (type == "free" | type == "Free") 
        Nu &lt;- Nusseltfree(a = a, b = b, m = m, L = L, Ts = Ts, Ta = Ta, shape="hcylinder")
    k &lt;- airtconductivity(Ta)
    hconv &lt;- Nu * k/L
    hconv
  }
  

</code></pre>

<hr>
<h2 id='hotironpal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+hotironpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='ironbowpal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+ironbowpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='Ld'>
Estimates downward facing longwave radiation (W/m2) 
</h2><span id='topic+Ld'></span>

<h3>Description</h3>

<p>Estimates downward incoming longwave radiation (W/m2) using relationship derived from Konzelmann et al. 1994.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ld(Ta = 20, RH = 0.5, n = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ld_+3A_ta">Ta</code></td>
<td>

<p>Local air temperature (degrees Celsius), ~ 2 m above ground 
</p>
</td></tr>
<tr><td><code id="Ld_+3A_rh">RH</code></td>
<td>

<p>Local relative humidity (fractional value from 0 to 1)
</p>
</td></tr>
<tr><td><code id="Ld_+3A_n">n</code></td>
<td>

<p>Fractional cloud cover (fractional value from 0 to 1)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By estimating the sky emissivity, from information on humidity and cloud cover, the incoming infrared radiation can be estimated using the Stephan-Boltzmann relationship: emissivity*Stephan Boltzmann constant * T^4. 
The effective atmospheric emissivity is determined from known cloud emissivity (0.97) and empirically determined clear sky emissivities.
</p>


<h3>Value</h3>

<p>A value, vector of length one, corresponding to the incoming longwave radiation, units: W/m2.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Konzelmann et al 1994.  Parameterization of global and longwave incoming radiation for the Greenland ice-sheet.  Global and Planetary Change.  9: 143-164. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lw">Lw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Returns a value in W/m2 of the estimated incoming longwave radiation  
# Example calculation:

Ta&lt;-30
RH&lt;-0.5
n&lt;-0
Ld(Ta, RH, n)

</code></pre>

<hr>
<h2 id='locate.fid'>
Returns the index locations that match vector fid within data vector.
</h2><span id='topic+locate.fid'></span>

<h3>Description</h3>

<p>Returns the index locations that match vector fid within data vector.  Used mostly to search for magic byte locations in a raw vector, but can be used to search any vector for locations of fid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate.fid(fid, vect, long = TRUE, zeroindex = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locate.fid_+3A_fid">fid</code></td>
<td>

<p>A lookup vector, typically numeric, which can be 1 element long or greater.  Typical use is
2 elements long. fid&lt;-c(1,2).  This sequence of values will be searched within the data
vector, vect.
</p>
</td></tr>
<tr><td><code id="locate.fid_+3A_vect">vect</code></td>
<td>

<p>Data vector of interest, within which fid will be searched.
</p>
</td></tr>
<tr><td><code id="locate.fid_+3A_long">long</code></td>
<td>

<p>Default is TRUE, will use a slower algorithm. When long=true, any length of fid can be used
to search in vector.  Computing time also depends on the length of fid.  Caution advised
when setting long = FALSE.  Null values maye be returned.
</p>
</td></tr>
<tr><td><code id="locate.fid_+3A_zeroindex">zeroindex</code></td>
<td>

<p>Whether you wish the returned values to reference 0 as the starting index or 1 as the starting index.  Natural byte reading starts at 0, but in R, indexes start at 1, so set zeroindex=FALSE if you using this simply as a vector lookup tool in R.  Default is TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the positions within the data vector where fid is found.  Do not use this function
if fid is length = 1.  Use which().  If length(fid)&gt;1, the elements of fid must be adjacent
and in that specific order.
</p>


<h3>Value</h3>

<p>An object of type integer, to be used as an index subset.
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>
<code><a href="base.html#topic+which">which</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Similar to the which or match functions in package::base, except that this returns the 
# index placement where variable fid occurs in data

## Define a vector
s&lt;-c(2,3,42,38,88,33,55,99,32,56,22,48,1,2,3,5,6,7,8,9,10,12,20)
## Define what fid sequence to look for: i.e. what adjacent elements to look for in 
## this order
fid&lt;-c(22,48)
## look for all instances where 22 and 48 occur together, using locate.fid
system.time(where.locate&lt;-locate.fid(fid,s,long=FALSE, zeroindex=FALSE))
where.locate
## verify that locate.fid worked by subsetting s, using where.locate as index
s[where.locate]
system.time(where.locate&lt;-locate.fid(fid,s,long=TRUE, zeroindex=FALSE))
s[where.locate]

## longer algorithm check
### Define a vector of 100000 random numbers from 1 to 100
s&lt;-ceiling(runif(100000, 0, 100))
## Define what fid sequence to look for: i.e. what adjacent elements to look for in 
## this order
fid&lt;-c(22,48)
system.time(where.locate&lt;-locate.fid(fid,s,long=TRUE,zeroindex=FALSE))
where.locate
## verify that locate.fid worked by subsetting s, using where.locate as index
s[where.locate]

</code></pre>

<hr>
<h2 id='Lu'>
Estimates upward facing ground radiation (W/m2)
</h2><span id='topic+Lu'></span>

<h3>Description</h3>

<p>Estimates upward facing ground radiation (W/m2), from the Stephan Boltzmann relationship and ground temperature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lu(Tg = 20, Eground = 0.97)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lu_+3A_tg">Tg</code></td>
<td>

<p>Ground temperature (degrees celsius)
</p>
</td></tr>
<tr><td><code id="Lu_+3A_eground">Eground</code></td>
<td>

<p>Emissivity of soil or ground.  Default value is 0.97.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates ground radiation facing upward.  Assumes ground emissivity = 0.97.  Terrain emissivities vary from 0.89 (sand, snow) to 0.97 (moist soil) - Blaxter, 1986
</p>


<h3>Value</h3>

<p>A value, vector of length one, corresponding to the longwave radiation from the ground, units: W/m2.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, 1986.  Energy metabolism in animals and man.  Cambridge University Press, Cambridge, UK, 340 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ld">Ld</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Estimates ground generated longwave radiation rising up.  Units W/m2.
# Example calculation:
Tg&lt;-30
Eground&lt;-0.97
Lu(Tg, Eground)
</code></pre>

<hr>
<h2 id='Lw'>
Estimates downward facing longwave radiation (W/m2) 
</h2><span id='topic+Lw'></span>

<h3>Description</h3>

<p>Estimates downward facing longwave radiation (W/m2) using a relationship derived from Gabathuler et al 2001
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lw(Ta = 20, RH = 0.5, n = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lw_+3A_ta">Ta</code></td>
<td>

<p>Local air temperature (degrees Celsius), ~ 2 m above ground 
</p>
</td></tr>
<tr><td><code id="Lw_+3A_rh">RH</code></td>
<td>

<p>Local relative humidity (fractional value from 0 to 1)
</p>
</td></tr>
<tr><td><code id="Lw_+3A_n">n</code></td>
<td>

<p>Fractional cloud cover (fractional value from 0 to 1)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alternative to Ld() for estimating incoming radiation by determining an offset temperature to account for the influence of atmospheric transmission loss. The incoming infrared radiation is estimated using the Stephan-Boltzmann relationship: 
emissivity*Stephan Boltzmann constant*T^4  
</p>


<h3>Value</h3>

<p>A value, vector of length one, corresponding to the incoming longwave radiation, units: W/m2.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Gabathuler et al 2001.  Parameterization of incoming longwave radiation in high mountain environments.  Physical Geography 22: 99-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ld">Ld</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example calculation:
Ta&lt;-30
RH&lt;-0.5
n&lt;-0
Lw(Ta, RH, n)

</code></pre>

<hr>
<h2 id='meanEveryN'>
Calculate the mean every nth data point.
</h2><span id='topic+meanEveryN'></span>

<h3>Description</h3>

<p>meanEveryN calculates the mean of a vectorised data set (x) at N intervals.  Means are
calculated by centring around every nth data point in the vector.  Upon running the function,
it attempts to subdivide the vector into n discrete intervals.  If the vector length is not
fully divisible by n, then the remainder elements are forced to NA values and the final mean
calculated.  
</p>
<p>The function returns a labelled matrix, with the average index as the first column and the
mean over that range of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanEveryN(x, n = 2, lag = round(n/2),showsamples=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanEveryN_+3A_x">x</code></td>
<td>

<p>numeric vector containing the data over which mean is required.  Typically this is a vector of data 
that has been sampled at even time intervals (represented by n). 
</p>
</td></tr>
<tr><td><code id="meanEveryN_+3A_n">n</code></td>
<td>

<p>the sample interval over which the mean will be calculated.  Default is 2 (as in every 2nd data
point).  At minimum this must be &gt;1.  
</p>
</td></tr>
<tr><td><code id="meanEveryN_+3A_lag">lag</code></td>
<td>

<p>default value is half the sample interval, n, which will ensure the calculation is centred over the new sample interval.  Not tested for any other situation.  Leave blank to have function operate as intended.
</p>
</td></tr>
<tr><td><code id="meanEveryN_+3A_showsamples">showsamples</code></td>
<td>

<p>default value is false.  Determines whether to output a matrix where the first column contains the mean sample #.  If true, the mean sample number is included with the mean calculations of the variable of interest, x.  If false, then only a vector containing the mean values of x will be provided.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general purpose of this function is to assist with time based averaging a data stream typically sampled at evenly recorded time intervals common to computerised data acquisition systems.  Akin to a moving average function, except that it also resamples the data.
</p>


<h3>Value</h3>

<p>A matrix object returned
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slopeEveryN">slopeEveryN</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Define a vector of 50 random numbers from 1 to 100
#s&lt;-ceiling(runif(50, 0, 100))
#x&lt;-seq(1,50,1)
## Calculate the mean value every 4th point
#s10&lt;-meanEveryN(s,4)

#plot(x,s,type="l",col="red")
#lines(s10,col="black")
</code></pre>

<hr>
<h2 id='medicalpal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+medicalpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='midgreenpal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+midgreenpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='midgreypal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+midgreypal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='mikronprismpal'>
Colour palette extracted from Mikron thermal camera files
</h2><span id='topic+mikronprismpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='mikroscanpal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+mikroscanpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='mirror.matrix'>
Mirrors a matrix upside-down.  Used in re-arranging image data for plotting properly in R.
</h2><span id='topic+mirror.matrix'></span>

<h3>Description</h3>

<p>Mirrors a matrix upside-down.  Used in re-arranging image data for plotting properly in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirror.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirror.matrix_+3A_x">x</code></td>
<td>

<p>A matrix corresponding to raster or image data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flip.matrix">flip.matrix</a></code>
<code><a href="#topic+rotate90.matrix">rotate90.matrix</a></code>
<code><a href="#topic+rotate270.matrix">rotate270.matrix</a></code>
<code><a href="#topic+rotate180.matrix">rotate180.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (x) 
{
    xx &lt;- as.data.frame(x)
    xx &lt;- rev(xx)
    xx &lt;- as.matrix(xx)
    xx
  }
  

# par(mfrow=c(2,1),mar=c(1,1,1,1))
# r&lt;-c(1:100,rnorm(1:100)*10,1:100)
# m&lt;-matrix(r,50)
# image(m, axes=FALSE)
# box()
# text(.5,.5,"Matrix",col="white")
# mf&lt;-mirror.matrix(m)
# image(mf,axes=FALSE)
# box()
# text(.5,.5,"Mirror",col="white")
</code></pre>

<hr>
<h2 id='nameleadzero'>
Add leading zeros to character for easy sequential naming of filenames.
</h2><span id='topic+nameleadzero'></span>

<h3>Description</h3>

<p>Returns a character with leading zeros according to the total number of filenames to be created.  Useful when exporting multiple images arising from imported video data stored as a matrix or dataframe.  By providing a base root name, the function will then add leading zeroes ahead of the number suffix (counter variable), according to the no.digits requested (i.e. Img0001.png, Img0002.png,...Img9999.png).  Best used inside a loop exporting images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameleadzero(filenameroot = "Img", filetype = ".png", no.digits = 5, counter = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nameleadzero_+3A_filenameroot">filenameroot</code></td>
<td>

<p>Prefix or root filename, supplied as a character vector.
</p>
</td></tr>
<tr><td><code id="nameleadzero_+3A_filetype">filetype</code></td>
<td>

<p>The type of file to be saved, as a character.  i.e. &quot;.png&quot;, or &quot;.csv&quot;.  
</p>
</td></tr>
<tr><td><code id="nameleadzero_+3A_no.digits">no.digits</code></td>
<td>

<p>The total number of digits required for the suffix portion of the complete filename.  Use 2 if numbers range from 1 to 99.
</p>
</td></tr>
<tr><td><code id="nameleadzero_+3A_counter">counter</code></td>
<td>

<p>The specific counter to add to the suffix.  Typically counter is a number. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although this returns a single character value with leading zeros, it could be used in a loop to create a new, incremented file name (i.e. Img0001.png, Img0002.png, Img0003.png,... Img9999.png), or wrapped in an apply function: 
</p>


<h3>Value</h3>

<p>Returns a character value.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using for-loop 
prefix&lt;-"Img_"
filetype&lt;-".png"
no.digits&lt;-2
for(i in 1:10){
  f.txt&lt;-nameleadzero(prefix, filetype, no.digits, counter=i)
  print(f.txt)
}

# Using an apply function
x&lt;-unlist(lapply(1:10, nameleadzero, filenameroot="Img_", filetype=".png", no.digits=2))
x

</code></pre>

<hr>
<h2 id='Nusseltforced'>
Nusselt number for forced convection.
</h2><span id='topic+Nusseltforced'></span>

<h3>Description</h3>

<p>Nusselt number for forced convection.  Used in estimating convective heat loss.  Typical values of c and n are 0.24 and 0.6, respectively.  This function sets c and n to NULL to force shape calculation checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nusseltforced(c = NULL, n = NULL, V = 1, L = 0.1, Ta = 20, shape="hcylinder")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nusseltforced_+3A_c">c</code></td>
<td>

<p>coefficient used in calculating Nusselt number.  Default is NULL
</p>
</td></tr>
<tr><td><code id="Nusseltforced_+3A_n">n</code></td>
<td>

<p>coefficient used in calculating Nusselt number. Default is NULL
</p>
</td></tr>
<tr><td><code id="Nusseltforced_+3A_v">V</code></td>
<td>

<p>Air velocity in metres/second.  Used in call to Reynolds().  Default value is 1.
</p>
</td></tr>
<tr><td><code id="Nusseltforced_+3A_l">L</code></td>
<td>

<p>Characteristic dimension in metres.  Default value is 0.1.
</p>
</td></tr>
<tr><td><code id="Nusseltforced_+3A_ta">Ta</code></td>
<td>

<p>Air temperature in degrees celsius. Used in call to Reynolds().
</p>
</td></tr>
<tr><td><code id="Nusseltforced_+3A_shape">shape</code></td>
<td>

<p>&quot;sphere&quot;, &quot;hplate&quot;, &quot;vplate&quot;, &quot;hcylinder&quot;, &quot;vcylinder&quot; to denote shape and orientation.  h=horizontal, v=vertical.  Default shape is &quot;hcylinder&quot;
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Gates, DM. 2003.  Biophysical Ecology.  Dover Publications, Mineola, New York, 611 pp.
Blaxter, K. 1989.  Energy Metabolism in Animals and Man
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (c = NULL, n = NULL, V = 1, L = 0.1, Ta = 20, shape="hcylinder") 
{
    Nu &lt;- c * Reynolds(V, L, Ta)^n
    Nu
  }
  
# Example
# Usually called from the hconv() or qconv() functions
V&lt;-1
L&lt;-0.1
Ta&lt;-20
shape="hcylinder"

Nu&lt;-Nusseltforced(V=V, L=L, Ta=Ta, shape=shape)

</code></pre>

<hr>
<h2 id='Nusseltfree'>
Nusselt number for free convection.
</h2><span id='topic+Nusseltfree'></span>

<h3>Description</h3>

<p>Nusselt number for free convection.  Used in calculating heat loss by convection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nusseltfree(a=NULL, b = NULL, m = NULL, L = 0.1, Ts = 25, Ta = 20, shape="hcylinder")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nusseltfree_+3A_a">a</code></td>
<td>

<p>Coefficient used in calculating Nu.  a is normally 1, except for turbulent flow.
</p>
</td></tr>
<tr><td><code id="Nusseltfree_+3A_b">b</code></td>
<td>

<p>Coefficient used in calculating Nu. b is 0.58 for upright cylinders, 0.48 for 
horizontal cylinders.  
</p>
</td></tr>
<tr><td><code id="Nusseltfree_+3A_m">m</code></td>
<td>

<p>Coefficient used in calculating Nu. m=0.25 for laminar flow.
</p>
</td></tr>
<tr><td><code id="Nusseltfree_+3A_l">L</code></td>
<td>

<p>Characteristic dimension in metres.
</p>
</td></tr>
<tr><td><code id="Nusseltfree_+3A_ts">Ts</code></td>
<td>

<p>Surface temperature in degrees celsius.  Used in call to Grashof() function.
</p>
</td></tr>
<tr><td><code id="Nusseltfree_+3A_ta">Ta</code></td>
<td>

<p>Air temperature in degrees celsius.  Used in call to Grashof() function.
</p>
</td></tr>
<tr><td><code id="Nusseltfree_+3A_shape">shape</code></td>
<td>

<p>&quot;sphere&quot;, &quot;hplate&quot;, &quot;vplate&quot;, &quot;hcylinder&quot;, &quot;vcylinder&quot; to denote shape and orientation.  h=horizontal, v=vertical.  Default shape is &quot;hcylinder&quot;
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, K. 1989.  Energy Metabolism in Animals and Man
Gates, DM. 2003.  Biophysical Ecology.  Dover Publications, Mineola, New York, 611 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (a=NULL, b = NULL, m = NULL, L = 0.1, Ts = 20, Ta = 20) 
{
    Nu &lt;- b * (Grashof(L, Ts, Ta)*Prandtl(Ta)^a)^m
    Nu
  }

# Nusselt number for free convection
# Example calculation:

a&lt;-1
b&lt;-0.58
m&lt;-0.25
L&lt;-1
Ts&lt;-30
Ta&lt;-20
Nusseltfree(a,b,m,L,Ts,Ta)


# Free convection is higher when surface temperatures are elevated.  This is the effect
# that free convection predicts: greater molecular energy of air surrounding a warmer surface
# leading to air currents over top of a warm surface.

Ts&lt;-40
Nusseltfree(a,b,m,L,Ts,Ta)




</code></pre>

<hr>
<h2 id='palette.choose'>
Choose a colour palette for gradient filling thermal image files.
</h2><span id='topic+palette.choose'></span>

<h3>Description</h3>

<p>Choose from among three the following colour palettes: flir, glowblow, grey120, grey10,
greyred, hotiron, ironbow, medical, midgreen, midgrey, mikronprism, mikroscan, rain, and
yellow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette.choose(colscheme)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palette.choose_+3A_colscheme">colscheme</code></td>
<td>

<p>A colour palette from the following: flir, glowblow, grey, grey10, greyred, hotiron, ironbow,
medical, midgreen, midgrey, mikronprism, mikroscan, rain, and yellow.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Colscheme is a character description drawn from the following list: 
(&quot;flir&quot;, &quot;glowblow&quot;, &quot;grey120&quot;, &quot;grey10&quot;, &quot;greyred&quot;, &quot;hotiron&quot;, &quot;ironbow&quot;, &quot;medical&quot;,
&quot;midgreen&quot;, &quot;midgrey&quot;, &quot;mikronprism&quot;, &quot;mikroscan&quot;, &quot;rain&quot;, &quot;yellow&quot;)
</p>
<p>palnames&lt;-c(&quot;flir&quot;, &quot;glowblow&quot;, &quot;grey120&quot;, &quot;grey10&quot;, &quot;greyred&quot;, &quot;hotiron&quot;, &quot;ironbow&quot;,
&quot;medical&quot;, &quot;midgreen&quot;, &quot;midgrey&quot;, &quot;mikronprism&quot;, &quot;mikroscan&quot;, &quot;rainbowpal&quot;, &quot;yellowpal&quot;)
</p>
<p>where &quot;flir&quot; is palnames[1], &quot;rain&quot; is palnames[13]
</p>


<h3>Value</h3>

<p>Returns a palette to be used in various graphics functions where 'col=palette' is requested. 
The palette vector is formatted for use as gradient fills in plotting functions.
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###### Example #####
palnames&lt;-c("flir", "ironbow", "mikronprism", "glowbow", "grey120", "grey10", "greyred", 
"hotiron",  "medical", "midgreen", "midgrey", "mikroscan", "yellowpal", "rainbowpal")
palnames&lt;-as.matrix(palnames)

pals&lt;-apply(as.matrix(palnames),1,palette.choose)
# add palnames to a list to call in image function below

par(mfrow=c(4,1),mar=c(1,0.3,1,0.3))
r&lt;-c(1:500)
m&lt;-matrix(r,500)

## Show palettes
image(m, axes=FALSE, col=flirpal, main="Flir Standard Palette")
image(m, axes=FALSE, col=ironbowpal, main="Ironbow Palette") 
# smaller palette for faster plotting
image(m, axes=FALSE, col=mikronprismpal, main="Mikron Prism Palette")
image(m, axes=FALSE, col=glowbowpal, main="Glowbow Palette")
image(m, axes=FALSE, col=grey120pal, main="Grey120 Palette")
image(m, axes=FALSE, col=grey10pal, main="Grey10 Palette")
image(m, axes=FALSE, col=greyredpal, main="Greyred Palette")
image(m, axes=FALSE, col=hotironpal, main="Hotiron Palette")
image(m, axes=FALSE, col=medicalpal, main="Medical Palette")
image(m, axes=FALSE, col=midgreypal, main="Midgrey Palette")
image(m, axes=FALSE, col=mikroscanpal, main="Mikroscan Palette")
image(m, axes=FALSE, col=rainbowpal, main="Rainbow Palette")
image(m, axes=FALSE, col=yellowpal, main="Yellow Palette")

# Palettes can be run in reverse
par(mfrow=c(2,1),mar=c(1,0.3,1,0.3))
image(m, axes=FALSE, col=flirpal, main="Flir Standard Palette")
image(m, axes=FALSE, col=rev(flirpal), main="Reverse Flir Standard Palette")

</code></pre>

<hr>
<h2 id='plotTherm'>
Plot thermal image data for visualisation purposes.
</h2><span id='topic+plotTherm'></span>

<h3>Description</h3>

<p>A quick way to plot and visualise thermal image data using the fields package image.plot function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTherm(bindata, templookup = NULL, w, h, minrangeset = 20, maxrangeset = 40, trans="I",
main = NULL, thermal.palette = flirpal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTherm_+3A_bindata">bindata</code></td>
<td>

<p>An integer vector of raw binary thermal information (usually) extracted from a thermal video or image using the getFrames or readflirJPG functions to be converted to temperature and summarised.  Instead, this can be a vector of temperature values (numeric); if so, then templookup should be set to NULL or ignored.
</p>
</td></tr>
<tr><td><code id="plotTherm_+3A_templookup">templookup</code></td>
<td>

<p>A vector of temperatures converted using the raw2temp function, corresponding to the conversion from raw binary thermal information to calibrated temperature estimates.  Typically will be vector of numbers 2^16 long, for a 16-bit camera.  Default is NULL, which assumes that dat has already been converted to temperature.
</p>
</td></tr>
<tr><td><code id="plotTherm_+3A_w">w</code></td>
<td>

<p>Width resolution (pixels) of thermal camera.  Can be found by using the flirsettings function.
</p>
</td></tr>
<tr><td><code id="plotTherm_+3A_h">h</code></td>
<td>

<p>Height resolution (pixels) of thermal camera.  Can be found by using the flirsettings function.
</p>
</td></tr>
<tr><td><code id="plotTherm_+3A_minrangeset">minrangeset</code></td>
<td>

<p>The minimum temperature to scale the raster plot z (temperature) value to.
</p>
</td></tr>
<tr><td><code id="plotTherm_+3A_maxrangeset">maxrangeset</code></td>
<td>

<p>The maximum temperature to scale the raster plot z (temperature) value to.
</p>
</td></tr>
<tr><td><code id="plotTherm_+3A_trans">trans</code></td>
<td>

<p>Transformation to apply to image matrix.  Default is I, the identity matrix, which will plot the image without transformation.  Options are mirror.matrix, rotate90.matrix, rotate270.matrix, rotate180.matrix, flip.matrix.
</p>
</td></tr>
<tr><td><code id="plotTherm_+3A_main">main</code></td>
<td>

<p>Title to plot on image.  Default is NULL.
</p>
</td></tr>
<tr><td><code id="plotTherm_+3A_thermal.palette">thermal.palette</code></td>
<td>

<p>Palette to use for the thermal image plot.  Default is ironbowpal (FLIR standard prism palette).  See examples in the palette.choose() function, or provide a custom palette.   
</p>
<p>Experience has shown that it is challenging to set the scale bar to align nicely with the rasterised image, so the user is left to explore the image.plot() function on their own.  It may help to set the plot area size first to get nicely aligned image and scale bars.  The following option has worked in testing: par(pin=c(6,4.5))
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simplified wrapper to call the image.plot function in the fields package.  Not all options are implemented, but default ones are shown here.  
</p>


<h3>Value</h3>

<p>Provides a rasterised plot based on a vector of data from a thermal image file.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Douglas Nychka, Reinhard Furrer, John Paige and Stephan Sain (2015). &quot;fields: Tools for spatial data.&quot;
doi: 10.5065/D6W957CT (URL: http://doi.org/10.5065/D6W957CT), R package version 8.10, &lt;URL: www.image.ucar.edu/fields&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m = 400 # grid size
C = complex( real=rep(seq(-1.8,0.6, length.out=m), each=m ), 
imag=rep(seq(-1.2,1.2, length.out=m), m ) )
C = matrix(C,m,m)

Z = 0
X = array(0, c(m,m,20))

for (k in 1:10) {
  Z = Z^2+C
  X[,,k] = exp(-abs(Z))
}

for (k in 1:10){
  x&lt;-as.matrix(X[,,k], nrow=400)
  x[is.na(x)]&lt;-min(x, na.rm=TRUE)
  plotTherm(x, w=400, h=400, minrangeset=min(x), maxrangeset=max(x))
}


# set w to 640 and h to 480
w&lt;-640
h&lt;-480
f&lt;-system.file("extdata", "SampleSEQ.seq", package = "Thermimage")
x&lt;-frameLocates(f)
suppressWarnings(templookup&lt;-raw2temp(1:65535))
alldata&lt;-unlist(lapply(x$f.start, getFrames, vidfile=f, w=w, h=h))
alldata&lt;-matrix(alldata, nrow=w*h, byrow=FALSE)
alltemperature&lt;-templookup[alldata]
alltemperature&lt;-unname(matrix(alltemperature, nrow=w*h, byrow=FALSE))

# Plot 
plotTherm(alldata[,2], templookup=templookup, w=w, h=h,  minrangeset=min(alldata),
          maxrangeset=max(alldata), trans="mirror.matrix")


# Plot all frames using binary data with templookup
x&lt;-apply(alldata, 2, plotTherm, templookup=templookup, w=w, h=h, minrangeset=20, 
maxrangeset=40, trans="mirror.matrix")

# Plot all frames using converted temperature data
x&lt;-apply(alltemperature, 2, plotTherm, w=w, h=h, minrangeset=min(alltemperature),
         maxrangeset=max(alltemperature), thermal.palette=flirpal, trans="mirror.matrix")

# Try other palettes:
#x&lt;-apply(alltemperature, 2, plotTherm, w=w, h=h, minrangeset=min(alltemperature),
#maxrangeset=max(alltemperature), thermal.palette=rainbowpal, trans="mirror.matrix")

#x&lt;-apply(alltemperature, 2, plotTherm, w=w, h=h, minrangeset=min(alltemperature),
#maxrangeset=max(alltemperature), thermal.palette=midgreypal, trans="mirror.matrix")

#x&lt;-apply(alltemperature, 2, plotTherm, w=w, h=h, minrangeset=min(alltemperature),
#maxrangeset=max(alltemperature), thermal.palette=midgreenpal, trans="mirror.matrix")

#x&lt;-apply(alltemperature, 2, plotTherm, w=w, h=h, minrangeset=min(alltemperature),
#maxrangeset=max(alltemperature), thermal.palette=greyredpal, trans="mirror.matrix")

#x&lt;-apply(alltemperature, 2, plotTherm, w=w, h=h, minrangeset=min(alltemperature),
#maxrangeset=max(alltemperature), thermal.palette=hotironpal, trans="mirror.matrix")


</code></pre>

<hr>
<h2 id='Prandtl'>
Returns the Prandtl number
</h2><span id='topic+Prandtl'></span>

<h3>Description</h3>

<p>Returns the Prandtl number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Prandtl(Ta = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prandtl_+3A_ta">Ta</code></td>
<td>

<p>Air temperature in degrees Celsius.  Default value is 20.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the Prandlt number
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, K. 1989.  Energy Metabolism in Animals and Man
Gates, D. M. 2003.  Biophysical Ecology.  Dover Publications, Mineola, New York.  611 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example:
Ta&lt;-30
Prandtl(Ta)

</code></pre>

<hr>
<h2 id='qabs'>
Estimates the absorbed solar and infrared radiation (W/m2)
</h2><span id='topic+qabs'></span>

<h3>Description</h3>

<p>Estimates the absorbed solar radiation and infrared radiation (W/m2) of an object using known physical relationships. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qabs(Ta = 20, Tg = NULL, RH = 0.5, E = 0.96, rho = 0.1, cloud = 0, SE = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qabs_+3A_ta">Ta</code></td>
<td>

<p>Air temperature (degrees Celsius).  Default value is 20.  Used to estimate ground temperature if Tg is unavailable.
</p>
</td></tr>
<tr><td><code id="qabs_+3A_tg">Tg</code></td>
<td>

<p>Ground temperature (degrees Celsius).  Default value is NULL, but a measured Tg can be substituted or estimated with other functions.
</p>
</td></tr>
<tr><td><code id="qabs_+3A_rh">RH</code></td>
<td>

<p>Relative humidity (fraction 0 to 1).  Default value is 0.5.  Used in call to Ld() to determine incoming radiation.
</p>
</td></tr>
<tr><td><code id="qabs_+3A_e">E</code></td>
<td>

<p>Emissivity (fraction 0 to 1) of the object absorbing longwave radiation.  According to Kirschoff's law, emissivity = absorptivity.  Absorptivity is multiplied by the average of the incoming longwave radiation to estimate absorbed radiation.
</p>
</td></tr>
<tr><td><code id="qabs_+3A_rho">rho</code></td>
<td>

<p>Reflectivity (fraction 0 to 1) of the object absorbing solar radiation.  Used to modify absorbed solar energy.  Default is 0.1.  
</p>
</td></tr>
<tr><td><code id="qabs_+3A_cloud">cloud</code></td>
<td>

<p>Fractional cloud cover (fraction from 0 to 1).  Used in call to Ld() to determine incoming radiation.  Default is 0.
</p>
</td></tr>
<tr><td><code id="qabs_+3A_se">SE</code></td>
<td>

<p>Solar energy (W/m2), usually measured.  Default is 100.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Total solar radiation must be supplied at this stage.  The calculation here provides the worst case scenario since since no profile/angle metrics are yet taken into account.  The animal could change orientation to/away from solar beam.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, 1986.  Energy metabolism in animals and man.  Cambridge University Press, Cambridge, UK, 340 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ld">Ld</a></code>
<code><a href="#topic+Lu">Lu</a></code>
<code><a href="#topic+Ld">Ld</a></code>
<code><a href="#topic+qrad">qrad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (Ta = 25, Tg = NULL, RH = 0.5, E = 0.96, rho = 0.1, 
    cloud = 0, SE = 100) 
{
    if (length(SE) == 1) 
        SE &lt;- rep(SE, length(Ta))
    if (is.null(Tg)) 
        Tg &lt;- Tg(Ta, SE)
    Ld &lt;- Ld(Ta, RH = RH, n = cloud)
    Lu &lt;- Lu(Tg)
    IR &lt;- E * (Lu + Ld)/2
    qabs &lt;- (1 - rho) * SE + IR
    qabs
  }
  
# Example:
Ta&lt;-25
Tg&lt;-30
RH&lt;-0.5
E&lt;-0.96
rho&lt;-0.1
cloud=0
SE&lt;-100
qabs(Ta, Tg, RH, E, rho, cloud, SE)

# If Tg is unknown it can be set to NULL, and the qabs function will estimate Tg from
# an empirical relationship of Tg vs Ta and SE from the Tground() function

qabs(Ta, Tg=NULL, RH, E, rho, cloud, SE)

# For detailed examples and explanations, see:
# https://github.com/gtatters/Thermimage/blob/master/HeatTransferCalculations.md
  
</code></pre>

<hr>
<h2 id='qcond'>
Estimates the area specific heat transfer by conduction (W/m2)
</h2><span id='topic+qcond'></span>

<h3>Description</h3>

<p>Estimates the area specific heat transfer by conduction (W/m2).  Positive 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcond(Ts = 30, Tc = 20, ktiss = 0.502, x = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qcond_+3A_ts">Ts</code></td>
<td>

<p>Surface temperature (degrees Celsius).  Default value is 30.
</p>
</td></tr>
<tr><td><code id="qcond_+3A_tc">Tc</code></td>
<td>

<p>Contact temperature (degrees Celsius), usually ground temperature.  Default value is 20.
</p>
</td></tr>
<tr><td><code id="qcond_+3A_ktiss">ktiss</code></td>
<td>

<p>Thermal conductivity of tissue (W/m/oC).
</p>
</td></tr>
<tr><td><code id="qcond_+3A_x">x</code></td>
<td>

<p>Distance over which heat is conducted.  Default value is 1 m (unrealistic, but easier for converting)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually conductive heat transfer is ignored given little surface area will be in contact with the ground, but this is included for functionality.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, 1986.  Energy metabolism in animals and man.  Cambridge University Press, Cambridge, UK, 340 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qrad">qrad</a></code>
<code><a href="#topic+qconv">qconv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (Ts = 30, Tc = 20, ktiss = 0.502, x = 1) 
{
    qcond &lt;- ktiss * (Tc - Ts)/x
    qcond
  }
</code></pre>

<hr>
<h2 id='qconv'>
Estimates the area specific heat transfer by convection (W/m2)
</h2><span id='topic+qconv'></span>

<h3>Description</h3>

<p>Estimates heat transfer by convective heat exchange, using the heat transfer coefficient estimate, surface temperature, and air temperature.  Positive value = heat gain from air to object.  Negative value = heat loss from object to air.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qconv(Ts = 30, Ta = 20, V = 1, L = 0.1, c = NULL, n =NULL, a=NULL, b = NULL, m = NULL, 
type = "forced", shape="hcylinder")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qconv_+3A_ts">Ts</code></td>
<td>

<p>Surface temperature (degrees celsius).  Default value is 30.
</p>
</td></tr>
<tr><td><code id="qconv_+3A_ta">Ta</code></td>
<td>

<p>Air temperature (degrees celsius). Default value is 20.
</p>
</td></tr>
<tr><td><code id="qconv_+3A_v">V</code></td>
<td>

<p>Air velocity (m/s).  Default value is 1.
</p>
</td></tr>
<tr><td><code id="qconv_+3A_l">L</code></td>
<td>

<p>Characteristic dimension (m) of object.  Usually the vertical dimension (i.e. height). Default value is 0.1.
</p>
</td></tr>
<tr><td><code id="qconv_+3A_c">c</code></td>
<td>

<p>coefficient used in forced convection (see Blaxter, 1986, default value is 0.24).  see forcedparameters() for details.
</p>
</td></tr>
<tr><td><code id="qconv_+3A_n">n</code></td>
<td>

<p>coefficient used in forced convection (see Blaxter, 1986, default value is 0.6).  see forcedparameters() for details.
</p>
</td></tr>
<tr><td><code id="qconv_+3A_a">a</code></td>
<td>

<p>coefficient used in free convection (see Gates, 2003. default value is 1). see freeparameters() for details.
</p>
</td></tr>
<tr><td><code id="qconv_+3A_b">b</code></td>
<td>

<p>coefficient used in free convection (0.58 upright cylinder, 0.48 flat cylinder, default value is 0.58). see freeparameters() for details.
</p>
</td></tr>
<tr><td><code id="qconv_+3A_m">m</code></td>
<td>

<p>coefficient used in free convection (0.25 laminar flow, default value is 0.25). see freeparameters() for details.
</p>
</td></tr>
<tr><td><code id="qconv_+3A_type">type</code></td>
<td>

<p>&quot;forced&quot; or &quot;free&quot; - to calculate convection coefficient for either forced or free convection.  Default value is &quot;forced&quot;.
</p>
</td></tr>
<tr><td><code id="qconv_+3A_shape">shape</code></td>
<td>

<p>&quot;sphere&quot;, &quot;hplate&quot;, &quot;vplate&quot;, &quot;hcylinder&quot;, &quot;vcylinder&quot; to denote shape and orientation.  h=horizontal, v=vertical.  Default shape is &quot;hcylinder&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates an area specific rate of heat transfer (W/m2), where a negative value depicts heat loss from surface to air, while positive value depicts heat gain from air to surface.  Uses the gradient in temperature (Ta minus Ts) multiplied by a convection coefficient to estimate heat transfer from a surface.  Designed for estimating steady state heat exchange from animal surfaces using thermal images.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, 1986.  Energy metabolism in animals and man.  Cambridge University Press, Cambridge, UK, 340 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hconv">hconv</a></code>,
<code><a href="#topic+forcedparameters">forcedparameters</a></code>,
<code><a href="#topic+freeparameters">freeparameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (Ts = 30, Ta = 20, V = 1, L = 0.1, c = NULL, n = NULL, a=NULL,
    b = NULL, m = NULL, type = "forced", shape="hcylinder") 
{
    qconv &lt;- (Ta - Ts) * hconv(Ta = 20, V = 1, L = 0.1, c = NULL, n = NULL, a=NULL,
    b = NULL, m = NULL, type = "forced", shape="hcylinder")
    qconv
  }

# Example:
Ts&lt;-30
Ta&lt;-20
V&lt;-1
L&lt;-0.1
type="forced"
shape="hcylinder"

qconv(Ts=Ts, Ta=Ta, V=V, L=L, type=type, shape=shape)

qconv(Ts=Ts, Ta=Ta, V=V, L=L, type=type, shape="sphere")

# For detailed examples and explanations, see:
# https://github.com/gtatters/Thermimage/blob/master/HeatTransferCalculations.md
  
</code></pre>

<hr>
<h2 id='qrad'>
Estimates the area specific heat transfer by radiation (W/m2)
</h2><span id='topic+qrad'></span>

<h3>Description</h3>

<p>Estimates heat transfer by radiation (W/m2), using the absorbed radiation estimate from qabs() minus emitted radiation from the object surface (determined from thermal image surface temperature estimates).  Positive value = heat gain from environment to object.  Negative value = heat loss from object to environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qrad(Ts = 30, Ta = 25, Tg = NULL, RH = 0.5, E = 0.96, rho = 0.1, cloud = 0, SE = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qrad_+3A_ts">Ts</code></td>
<td>

<p>Surface temperature (degrees Celsius) of the object.  Default value is 30.
</p>
</td></tr>
<tr><td><code id="qrad_+3A_ta">Ta</code></td>
<td>

<p>Air temperature (degrees Celsius), or effective atmospheric temperature.  Default value is 25.
</p>
</td></tr>
<tr><td><code id="qrad_+3A_tg">Tg</code></td>
<td>

<p>Ground temperature (degrees Celsius) to estimate longwave ground radiation.  Default value is NULL, since Tg can be estimated from Ta unless otherwise measured.
</p>
</td></tr>
<tr><td><code id="qrad_+3A_rh">RH</code></td>
<td>

<p>Relative humidity (fraction 0 to 1).  Default value is 0.5.  Used in call to Ld() to determine incoming radiation.
</p>
</td></tr>
<tr><td><code id="qrad_+3A_e">E</code></td>
<td>

<p>Emissivity (fraction 0 to 1) of the object absorbing longwave radiation.  According to Kirschoff's law, emissivity = absorptivity.  Absorptivity is multiplied by the average of the incoming longwave radiation to estimate absorbed radiation.
</p>
</td></tr>
<tr><td><code id="qrad_+3A_rho">rho</code></td>
<td>

<p>Reflectivity (fraction 0 to 1) of the object absorbing solar radiation.  Used to modify absorbed solar energy.  Default is 0.1.  
</p>
</td></tr>
<tr><td><code id="qrad_+3A_cloud">cloud</code></td>
<td>

<p>Fractional cloud cover (fraction from 0 to 1).  Used in call to Ld() to determine incoming radiation.  Default is 0.
</p>
</td></tr>
<tr><td><code id="qrad_+3A_se">SE</code></td>
<td>

<p>Solar energy (W/m2), usually measured.  Default is 100.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Total solar radiation must be supplied at this stage.  The calculation here provides the worst case scenario since since no profile/angle metrics are yet taken into account.  The animal could change orientation to/away from solar beam.  
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, 1986.  Energy metabolism in animals and man.  Cambridge University Press, Cambridge, UK, 340 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ld">Ld</a></code>
<code><a href="#topic+Lu">Lu</a></code>
<code><a href="#topic+Ld">Ld</a></code>
<code><a href="#topic+qabs">qabs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (Ts = 30, Ta = 25, Tg = NULL, RH = 0.5, E = 0.96, rho = 0.1, 
    cloud = 0, SE = 0) 
{
    qrad &lt;- qabs(Ta = Ta, Tg = Tg, RH = RH, E = E, rho = rho, 
        cloud = cloud, SE = SE) - E * StephBoltz() * (Ts + 273.15)^4
    qrad
  }

# Example:
Ts&lt;-30
Ta&lt;-25
Tg&lt;-28
RH&lt;-0.5
E&lt;-0.96
rho&lt;-0.1
cloud&lt;-0
SE&lt;-100
# qrad should result in a positive gain of heat:
qrad(Ts, Ta, Tg, RH, E, rho, cloud, SE)

# if rho is elevated (i.e. doubles reflectance of solar energy), heat exchange by 
# radiation is reduced
rho&lt;-0.2
qrad(Ts, Ta, Tg, RH, E, rho, cloud, SE)

# But if solar energy = 0, under similar conditions, qrad is negative:
SE&lt;-0
qrad(Ts, Ta, Tg, RH, E, rho, cloud, SE)

# For detailed examples and explanations, see:
# https://github.com/gtatters/Thermimage/blob/master/HeatTransferCalculations.md
  


</code></pre>

<hr>
<h2 id='rainbow1234pal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+rainbow1234pal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='rainbowpal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+rainbowpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

<hr>
<h2 id='raw2temp'>
Converts raw thermal data into temperature (oC)
</h2><span id='topic+raw2temp'></span>

<h3>Description</h3>

<p>Converts a raw value obtained from binary thermal image video file into estimated
temperature using standard equations used in infrared thermography.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw2temp(raw, E = 1, OD = 1, RTemp = 20, ATemp = RTemp, IRWTemp = RTemp, IRT = 1,
RH = 50, PR1 = 21106.77, PB = 1501, PF = 1, PO = -7340, PR2 = 0.012545258, 
         ATA1=0.006569, ATA2=0.01262, ATB1=-0.002276, ATB2=-0.00667, ATX=1.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw2temp_+3A_raw">raw</code></td>
<td>

<p>A/D bit signal from FLIR file. FLIR .seq files and .fcf files store data in a 16-bit encoded value. This means it can range from 0 up to 65535.  This is referred to as the raw value.  The raw value is actually what the sensor detects which is related to the radiance hitting the sensor. At the factory, each sensor has been calibrated against a blackbody radiation source so calibration values to conver the raw signal into the expected temperature of a blackbody radiator are provided. Since the sensors do not pick up all wavelengths of light, the calibration can be estimated usinga limited version of Planck's law.  But the blackbody calibration is still critical to this.
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_e">E</code></td>
<td>

<p>Emissivity - default 1, should be ~0.95 to 0.97 depending on object of interest.  Determined by user.
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_od">OD</code></td>
<td>

<p>Object distance from thermal camera in metres
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_rtemp">RTemp</code></td>
<td>

<p>Apparent reflected temperature (oC) of the enrivonment impinging on the object of interest - one value from FLIR file (oC), default 20C.
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_atemp">ATemp</code></td>
<td>

<p>Atmospheric temperature (oC) for infrared tranmission loss - one value from FLIR file (oC) - default value is set to be equal to the reflected temperature.  Transmission loss is a function of absolute humidity in the air.
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_irwtemp">IRWTemp</code></td>
<td>

<p>Infrared Window Temperature (oC). Default is set to be equivalent to reflected temp (oC).  
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_irt">IRT</code></td>
<td>

<p>Infrared Window transmission - default is set to 1.0.  Likely ~0.95-0.97. Should be empirically determined.  Germanium windows with anti-reflective coating typically have IRTs ~0.95-0.97.
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_rh">RH</code></td>
<td>

<p>Relative humidity expressed as percent.  Default value is 50.
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_pr1">PR1</code></td>
<td>

<p>PlanckR1 - a calibration constant for FLIR cameras
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_pb">PB</code></td>
<td>

<p>PlanckB - a calibration constant for FLIR cameras
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_pf">PF</code></td>
<td>

<p>PlanckF - a calibration constant for FLIR cameras
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_po">PO</code></td>
<td>

<p>PlanckO - a calibration constant for FLIR cameras
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_pr2">PR2</code></td>
<td>

<p>PlanckR2 - a calibration constant for FLIR cameras
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_ata1">ATA1</code></td>
<td>

<p>ATA1 - an atmospheric attenuation constant to calculate atmospheric tau
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_ata2">ATA2</code></td>
<td>

<p>ATA2 - an atmospheric attenuation constant to calculate atmospheric tau
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_atb1">ATB1</code></td>
<td>

<p>ATB1 - an atmospheric attenuation constant to calculate atmospheric tau
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_atb2">ATB2</code></td>
<td>

<p>ATB2 - an atmospheric attenuation constant to calculate atmospheric tau
</p>
</td></tr>
<tr><td><code id="raw2temp_+3A_atx">ATX</code></td>
<td>

<p>ATX - an atmospheric attenuation constant to calculate atmospheric tau
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: PR1, PR2, PB, PF, and PO are specific to each camera and result from the calibration 
at factory of the camera's Raw data signal recording from a blackbody radiation source.  
Sample calibration constants for three different cameras (FLIR SC660 with 24x18 degree lens,
FLIR T300 with 25x19 degree lens, FLIR T300 with 2xtelephoto.
</p>
<p>Calibration Constants by cameras:  SC660, T300(25o), T300(25o with telephoto)
</p>

<table>
<tr>
 <td style="text-align: left;">
Constant </td><td style="text-align: center;"> FLIR SC660 </td><td style="text-align: center;"> FLIR T300 </td><td style="text-align: center;"> FLIR T300(t)</td>
</tr>
<tr>
 <td style="text-align: left;">
PR1: </td><td style="text-align: center;"> 21106.77 </td><td style="text-align: center;"> 14364.633 </td><td style="text-align: center;"> 14906.216</td>
</tr>
<tr>
 <td style="text-align: left;">
PB: </td><td style="text-align: center;"> 1501 </td><td style="text-align: center;"> 1385.4 </td><td style="text-align: center;"> 1396.5</td>
</tr>
<tr>
 <td style="text-align: left;">
PF: </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1</td>
</tr>
<tr>
 <td style="text-align: left;">
PO: </td><td style="text-align: center;"> -7340 </td><td style="text-align: center;"> -5753 </td><td style="text-align: center;"> -7261</td>
</tr>
<tr>
 <td style="text-align: left;">
PR2: </td><td style="text-align: center;">  0.012545258 </td><td style="text-align: center;"> 0.010603162 </td><td style="text-align: center;"> 0.010956882</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>PR1: PlanckR1 calibration constant
PB: PlanckB calibration constant  
PF: PlanckF calibration constant   
PO: PlanckO calibration constant
PR2: PlanckR2 calibration constant
</p>
<p>The calibration constants allow for the raw digital signal conversion to and from the 
predicted radiance of a blackbody, using the standard equation: 
</p>
<p>temperature&lt;-PB/log(PR1/(PR2*(raw+PO))+PF)-273.15
</p>
<p>Also used in calculations for transmission loss are the following constants:
</p>
<p>ATA1: Atmospheric Trans Alpha 1  0.006569 
ATA2: Atmospheric Trans Alpha 2  0.012620
ATB1: Atmospheric Trans Beta 1  -0.002276
ATB2: Atmospheric Trans Beta 2  -0.006670
ATX:  Atmospheric Trans X        1.900000
</p>
<p>Some files may return slightly different ATA1, ATA2, ATB1, ATB2, and ATX values. 
Use the flirsettings function to find out what constants are used for your files.
</p>


<h3>Value</h3>

<p>Returns numeric value in degrees C.  Can handle vector or matrix objects
</p>


<h3>Warning </h3>

<p>Raw values need to be greater than Planck0 constant</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>References</h3>

<p>1. http://130.15.24.88/exiftool/forum/index.php/topic,4898.60.html
</p>
<p>2. Minkina, W. and Dudzik, S. 2009. Infrared Thermography: Errors and Uncertainties.  
Wiley Press, 192 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+temp2raw">temp2raw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># General Usage:
# raw2temp(raw,E,OD,RTemp,ATemp,IRWTemp,IRT,RH,PR1,PB,PF,PO,PR2,ATA1,ATA2,ATB1,ATB2,ATX)

#
# Example with all settings at default/blackbody levels:
raw2temp(18109,1,0,20,20,20,1,50,PR1=21106.77,PB=1501,PF=1,PO=-7340,PR2=0.012545258,
ATA1=0.006569, ATA2=0.01262, ATB1=-0.002276, ATB2=-0.00667, ATX=1.9)

# Example with emissivity=0.95, distance=1m, window transmission=0.96, all temperatures=20C, 
# 50 RH:

raw2temp(18109,0.95,1,20,20,20,0.96,50) 
# Note: default calibration constants for the FLIR camera will be used if you leave out the
# calibration data

# Vector example
r&lt;-17000:25000
t1.0&lt;-raw2temp(r,1,0,20,20,20,0.96,50)
t0.9&lt;-raw2temp(r,0.9,0,20,20,20,0.96,50)

dev.off()
plot(r,t1.0,type="l",col="red")
lines(r,t0.9,col="black")
legend("topleft", bty = "n", c("E=1.0", "E=0.9"), lty=c(1,1), col=c("red", "black"))

# Create a templookup vector - faster calculations when working with huge binary data files
# suppressWarnings remove the NaN warning that results from the low values falling outside the 
# range of temperatures relevant

suppressWarnings(templookup&lt;-raw2temp(raw=1:65535)) 
r&lt;-floor(runif(10000000, 16000,25000)) # create a long vector of raw binary values

# calculate temperature using the lookup vector:
system.time(templookup[r]) # 0.109 seconds

# calculate temperature using the raw2temp function on the raw vector: 
system.time(raw2temp(r)) # 0.248 seconds

# For information on the effectiveness of the raw2temp and temp2raw
# functions at estimating temperature properly, see the following:
# https://github.com/gtatters/ThermimageCalibration
</code></pre>

<hr>
<h2 id='readflirJPG'>
Reads an image from a FLIR JPG file into an integer array.
</h2><span id='topic+readflirJPG'></span>

<h3>Description</h3>

<p>Reads an image from a FLIR JPG file into an integer matrix, w pixels wide x h pixels high, depending on image size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readflirJPG(imagefile, exiftoolpath = "installed", headerindex=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readflirJPG_+3A_imagefile">imagefile</code></td>
<td>

<p>Name of the FLIR JPG file to read from, as captured by the thermal camera.  A character string.
</p>
</td></tr>
<tr><td><code id="readflirJPG_+3A_exiftoolpath">exiftoolpath</code></td>
<td>

<p>A character string that determines whether Exiftool has been &quot;installed&quot; (http://www.sno.phy.queensu.ca/~phil/exiftool/) or not.  If Exiftool has been installed in a specific location, use to direct to the folder location.
</p>
</td></tr>
<tr><td><code id="readflirJPG_+3A_headerindex">headerindex</code></td>
<td>

<p>An integer defining which TIFF or PNG detected header to use as the thermal image data.  Default = 1, since most files will only have one detected header, but sometimes when exiftool extracts the raw thermal data, it produces more than one head in the tempfile.  This might be the case with FLIR cameras and files with fused digital and thermal image data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only tested on a select number of FLIR JPGs.  Usage depends on functionality provided by Exiftool.  At present this function first makes use of readBin to read in thermal image jpgs and searches for the magic start byte sequence (&quot;54&quot;, &quot;49&quot;, &quot;46&quot;, &quot;46&quot;,&quot;49&quot;, &quot;49&quot;) for TIFF type images or (&quot;89&quot;, &quot;50&quot;, &quot;4e&quot;, &quot;47&quot;, &quot;0d&quot;, &quot;0a&quot;, &quot;1a&quot;, &quot;0a&quot;) for PNG type images, and then uses the readTIFF or readPNG functions to load into R.
</p>
<p>Exiftool should install on most operating systems.  Consult with http://www.sno.phy.queensu.ca/~phil/exiftool/ for information on installing Exiftool.  If trouble installing, download Exiftool and set exiftoolpath to the custom folder location.  To test if the custom path to Exiftool will work on your OS, try your own system or system2 call: system2(&quot;/custompath/exiftool&quot;) to see if you get an error or not.
</p>
<p>v 2.2.3: updated to fix a problem calling shell commands requiring folder write access on a windows OS (thanks to John Al-Alawneh)
</p>


<h3>Value</h3>

<p>Returns a matrix of integer values, corresponding the calibrated raw thermal image radiance values.  Can be converted to temperature estimates using the raw2temp() function.
</p>


<h3>Note</h3>

<p>Loading image files and manipulating them in R is slow.  Consider using command line tools like exiftool, imagemagick, and ffmpeg to convert the files into a format to analyse in ImageJ, where more powerful plug-ins can be accessed. 
</p>
<p>Alternatively, convertflirjpg and convertflirvid functions are wrappers that will call command line tools and convert flir files in the shell environment.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>1. Exiftool Command line tool: http://www.sno.phy.queensu.ca/~phil/exiftool/
</p>
<p>2. Simon Urbanek (2013). tiff: Read and write TIFF images. R package version
0.1-5. https://CRAN.R-project.org/package=tiff
</p>
<p>3.  Simon Urbanek (2013). png: Read and write PNG images. R package version 0.1-7.
https://CRAN.R-project.org/package=png
</p>


<h3>See Also</h3>

<p><code><a href="#topic+temp2raw">temp2raw</a></code>
<code><a href="#topic+raw2temp">raw2temp</a></code>
<code><a href="#topic+convertflirJPG">convertflirJPG</a></code>
<code><a href="#topic+convertflirVID">convertflirVID</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Example using the flirsettings and readflirjpg functions

library(Thermimage)
## Sample flir jpg included with Thermimage package:

imagefile&lt;-paste0(system.file("extdata/IR_2412.jpg", package="Thermimage"))

## Extract meta-tags from thermal image file ##
cams&lt;-flirsettings(imagefile, exiftool="installed", camvals="")
cams

## Set variables for calculation of temperature values from raw A/D sensor data  ####
Emissivity&lt;-cams$Info$Emissivity      # Image Saved Emissivity - should be ~0.95 or 0.96
ObjectEmissivity&lt;-0.96                # Object Emissivity - should be ~0.95 or 0.96
dateOriginal&lt;-cams$Dates$DateTimeOriginal
dateModif&lt;-   cams$Dates$FileModificationDateTime
PlanckR1&lt;-    cams$Info$PlanckR1                      # Planck R1 constant for camera  
PlanckB&lt;-     cams$Info$PlanckB                       # Planck B constant for camera  
PlanckF&lt;-     cams$Info$PlanckF                       # Planck F constant for camera
PlanckO&lt;-     cams$Info$PlanckO                       # Planck O constant for camera
PlanckR2&lt;-    cams$Info$PlanckR2                      # Planck R2 constant for camera
OD&lt;-          cams$Info$ObjectDistance                # object distance in metres
FD&lt;-          cams$Info$FocusDistance                 # focus distance in metres
ReflT&lt;-       cams$Info$ReflectedApparentTemperature  # Reflected apparent temperature
AtmosT&lt;-      cams$Info$AtmosphericTemperature        # Atmospheric temperature
IRWinT&lt;-      cams$Info$IRWindowTemperature           # IR Window Temperature
IRWinTran&lt;-   cams$Info$IRWindowTransmission          # IR Window transparency
RH&lt;-          cams$Info$RelativeHumidity              # Relative Humidity
h&lt;-           cams$Info$RawThermalImageHeight         # sensor height (i.e. image height)
w&lt;-           cams$Info$RawThermalImageWidth          # sensor width (i.e. image width)

## Import image from flir jpg to obtain binary data
img&lt;-readflirJPG(imagefile)

## Rotate image before plotting
imgr&lt;-rotate270.matrix(img)

## Plot initial image of raw binary data
library(fields)
image.plot(imgr, useRaster=TRUE, col=ironbowpal)

## Convert binary data to temperature

## Consider whether you should change any of the following: 
## ObjectEmissivity, OD, RH, ReflT, AtmosT, IRWinT, IRWinTran

temperature&lt;-raw2temp(imgr,ObjectEmissivity,OD,ReflT,AtmosT,IRWinT,IRWinTran,RH,
                      PlanckR1,PlanckB,PlanckF,PlanckO,PlanckR2)
colnames(temperature)&lt;-NULL
rownames(temperature)&lt;-NULL

## Plot temperature image using fields package
t&lt;-temperature
image.plot(t, asp=h/w, bty="n", useRaster=TRUE, xaxt="n", yaxt="n", col=ironbowpal)

## Plot temperature image using ggplot2
library(ggplot2)
library(reshape2)
d&lt;-melt(temperature)

p&lt;-ggplot(d, aes(Var1, Var2))+
  geom_raster(aes(fill=value))+coord_fixed()+
  scale_fill_gradientn(colours=ironbowpal)+
  theme_void()+
  theme(legend.key.height=unit(2, "cm"), legend.key.width=unit(0.5, "cm"))
p


## Export Temperature Data to CSV file
## Must rotate image 90 degrees before exporting
## This csv file can be imported into imageJ (File-Import-Text Image) for open source image
## analysis options of accurate thermal image data.  If you have many csv files, consider
## writing a macro, see:
## http://imagej.1557.x6.nabble.com/open-text-image-sequence-td4999149.html


f.temperature&lt;-"IR_2412.csv"
write.csv(rotate90.matrix(temperature), f.temperature, row.names=FALSE)


## End(Not run)

## See also https://github.com/gtatters/Thermimage/README.md

</code></pre>

<hr>
<h2 id='Reynolds'>
Calculates the Reynolds number.
</h2><span id='topic+Reynolds'></span>

<h3>Description</h3>

<p>Calculates the Reynolds number, a unitless measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Reynolds(V, L, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reynolds_+3A_v">V</code></td>
<td>

<p>Air velocity in m/s
</p>
</td></tr>
<tr><td><code id="Reynolds_+3A_l">L</code></td>
<td>

<p>The characteristic dimension, usually the vertical dimension.  For reference, 
a cylinder's characteristic L would be its height, assuming it is standing on its end
This L should be the same L as is used for the convective coefficient calculation
</p>
</td></tr>
<tr><td><code id="Reynolds_+3A_v">v</code></td>
<td>

<p>The kinematic viscosity returned from function airviscosity (Ta).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Blaxter, K. 1989.  Energy Metabolism in Animals and Man
Gates, D. M. 2003.  Biophysical Ecology.  Dover Publications, Mineola, New York.  611 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (V, L, v) 
{
  v&lt;-airviscosity(Ta)
  Re&lt;-V*L/v
  }

# Typical values for Reynolds numbers range from 6.6 to 6.6e+5 

# Example calculation:
V&lt;-1
L&lt;-1
Ta&lt;-20
v&lt;-airviscosity(Ta)
Reynolds(V, L, v)

</code></pre>

<hr>
<h2 id='rotate180.matrix'>
Rotate a matrix by 180 degrees.  Used for adjusting image plotting in R.
</h2><span id='topic+rotate180.matrix'></span>

<h3>Description</h3>

<p>Rotate a matrix by 180 degrees.  Used for adjusting image plotting in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate180.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate180.matrix_+3A_x">x</code></td>
<td>

<p>A matrix corresponding to raster or image data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>1. http://www.inside-r.org/packages/cran/RSEIS/docs/mirror.matrix
</p>
<p>2. Based on similar code in package &lt;RSEIS&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flip.matrix">flip.matrix</a></code>
<code><a href="#topic+mirror.matrix">mirror.matrix</a></code>
<code><a href="#topic+rotate90.matrix">rotate90.matrix</a></code>
<code><a href="#topic+rotate270.matrix">rotate270.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (x) 
{
    xx &lt;- rev(x)
    dim(xx) &lt;- dim(x)
    xx
  }
  
  
# set.seed(5)
# par(mfrow=c(1,2),mar=c(1,1,1,1))
# r&lt;-c(1:100,rnorm(1:100)*10,1:100)
# m&lt;-matrix(r,50)
# image(m, axes=FALSE)
# box()
# text(.5,.5,"Matrix")
# mf&lt;-rotate180.matrix(m)
# image(mf,axes=FALSE)
# box()
# text(.5,.5,"Rotate180",col="white")
  
  
</code></pre>

<hr>
<h2 id='rotate270.matrix'>
Rotate a matrix by 270 degrees counterclockwise (or 90 degree clockwise).  Used for adjusting image plotting in R.
</h2><span id='topic+rotate270.matrix'></span>

<h3>Description</h3>

<p>Rotate a matrix by 270 degrees counterclockwise (or 90 degree clockwise).  Used for adjusting image plotting in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate270.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate270.matrix_+3A_x">x</code></td>
<td>

<p>A matrix corresponding to raster or image data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>1. http://www.inside-r.org/packages/cran/RSEIS/docs/mirror.matrix
</p>
<p>2. Based on similar code in package &lt;RSEIS&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flip.matrix">flip.matrix</a></code>
<code><a href="#topic+mirror.matrix">mirror.matrix</a></code>
<code><a href="#topic+rotate90.matrix">rotate90.matrix</a></code>
<code><a href="#topic+rotate180.matrix">rotate180.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (x) 
{
    mirror.matrix(t(x))
  }
  
  

 set.seed(5)
 par(mfrow=c(1,2),mar=c(1,1,1,1))
 r&lt;-c(1:100,rnorm(1:100)*10,1:100)
 m&lt;-matrix(r,50)
 image(m, axes=FALSE)
 box()
 text(.5,.5,"Matrix",col="white")
 mf&lt;-rotate270.matrix(m)
 image(mf,axes=FALSE)
 box()
 text(.5,.5,"Rotate270",col="white")
  
</code></pre>

<hr>
<h2 id='rotate90.matrix'>
Rotate a matrix by 90 degrees counterclockwise (270 degrees clockwise).  Used for adjusting image plotting in R.
</h2><span id='topic+rotate90.matrix'></span>

<h3>Description</h3>

<p>Rotate a matrix by 90 degrees counterclockwise (270 degrees clockwise).  Used for adjusting image plotting in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate90.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate90.matrix_+3A_x">x</code></td>
<td>

<p>A matrix corresponding to raster or image data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix.
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>References</h3>

<p>1. http://www.inside-r.org/packages/cran/RSEIS/docs/mirror.matrix
</p>
<p>2. Based on similar code in package &lt;RSEIS&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flip.matrix">flip.matrix</a></code>
<code><a href="#topic+mirror.matrix">mirror.matrix</a></code>
<code><a href="#topic+rotate270.matrix">rotate270.matrix</a></code>
<code><a href="#topic+rotate180.matrix">rotate180.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (x) 
{
    t(mirror.matrix(x))
  }
  
set.seed(5)
par(mfrow=c(1,2),mar=c(1,1,1,1))
r&lt;-c(1:100,rnorm(1:100)*10,1:100)
m&lt;-matrix(r,50)
image(m, axes=FALSE)
box()
text(.5,.5,"Matrix",col="white")
mf&lt;-rotate90.matrix(m)
image(mf,axes=FALSE)
box()
text(.5,.5,"Rotate90",col="white")
  
</code></pre>

<hr>
<h2 id='samp.image'>
A sample thermal image to demonstrate thermal colour palette use.
</h2><span id='topic+samp.image'></span>

<h3>Description</h3>

<p>A sample thermal image to demonstrate thermal colour palette use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("samp.image")</code></pre>


<h3>Format</h3>

<p>A sample thermal image to demonstrate thermal colour palette use.
The format is:
num [1:480, 1:640] 23.2 23.2 23.4 23.3 23.3 ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example #####
palnames&lt;-c("flir", "ironbow", "mikronprism", "glowbow", "grey120", "grey10", "greyred", 
"hotiron",  "medical", "midgreen", "midgrey", "mikroscan", "yellowpal", "rainbowpal")

m&lt;-rotate90.matrix(samp.image)
par(mfrow=c(2,1),mar=c(0.3,2,1,2))

## Show palettes
image(m, axes=FALSE, useRaster=TRUE, col=flirpal, main="Flir Standard Palette")
image(m, axes=FALSE, useRaster=TRUE, col=ironbowpal, main="Ironbow Palette") 
# smaller palette for faster plotting
image(m, axes=FALSE, useRaster=TRUE, col=mikronprismpal, main="Mikron Prism Palette")
image(m, axes=FALSE, useRaster=TRUE, col=glowbowpal, main="Glowbow Palette")
image(m, axes=FALSE, useRaster=TRUE, col=grey120pal, main="Grey120 Palette")
image(m, axes=FALSE, useRaster=TRUE, col=grey10pal, main="Grey10 Palette")
image(m, axes=FALSE, useRaster=TRUE, col=greyredpal, main="Greyred Palette")
image(m, axes=FALSE, useRaster=TRUE, col=hotironpal, main="Hotiron Palette")
image(m, axes=FALSE, useRaster=TRUE, col=medicalpal, main="Medical Palette")
image(m, axes=FALSE, useRaster=TRUE, col=midgreypal, main="Midgrey Palette")
image(m, axes=FALSE, useRaster=TRUE, col=mikroscanpal, main="Mikroscan Palette")
image(m, axes=FALSE, useRaster=TRUE, col=rainbowpal, main="Rainbow Palette")
image(m, axes=FALSE, useRaster=TRUE, col=yellowpal, main="Yellow Palette")

</code></pre>

<hr>
<h2 id='slopebypoint'>
Returns the slope from linear regression with x values as equally spaced 1:length
</h2><span id='topic+slopebypoint'></span>

<h3>Description</h3>

<p>Returns the slope from linear regression with x values as equally spaced 1:length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slopebypoint(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slopebypoint_+3A_data">data</code></td>
<td>

<p>Returns the slope from linear regression with x values as equally spaced 1:length
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the slope (i.e. localised tangent) from linear regression with x values as equally spaced 1:length.  The usefulness of this function is to reduce a time series type of data collected at equal time intervals. 
</p>
<p>N=number of data points over which to calculate the slope.
</p>


<h3>Value</h3>

<p>An object of type numeric.  
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Define a vector of 50 random numbers from 1 to 100
y&lt;-ceiling(runif(50, 0, 100))
# Calculate the slope with respect to the index values (i.e. 1 to 50)
# instead of an x axis, this will provide a slope value of y vs. index
s&lt;-slopebypoint(y)
s

# same as if typing: 
lm(y~seq(0,length(y)-1,1))

</code></pre>

<hr>
<h2 id='slopeEveryN'>
Calculate the slope every nth data point.
</h2><span id='topic+slopeEveryN'></span>

<h3>Description</h3>

<p>slopeEveryN calculates the slope of a vectorised data set (x) at N intervals.  Slopes are
calculated using the lm() function centred around every nth data point in the vector.  Upon
running the function, it attempts to subdivide the vector into n discrete intervals.  If the
vector length is not fully divisible by n, then the remainder elements are forced to NA
values and the final slope calculated.  
</p>
<p>The function returns a labelled matrix, with the average index as the first column and the
slope over that range of data.  Units for slope then are technically in un
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slopeEveryN(x, n = 2, lag = round(n/2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slopeEveryN_+3A_x">x</code></td>
<td>

<p>numeric vector containing the data over which slope is required.  Typically this is a vector of data that has been sampled at even time intervals (represented by n). 
</p>
</td></tr>
<tr><td><code id="slopeEveryN_+3A_n">n</code></td>
<td>

<p>the sample interval over which the slope will be calculated.  Default is 2 (as in every 2nd data point).  At minimum this must be &gt;1.
</p>
</td></tr>
<tr><td><code id="slopeEveryN_+3A_lag">lag</code></td>
<td>

<p>default value is half the sample interval, n, which will ensure the calculation is centred over the new sample interval.  Not tested for any other situation.  Leave blank to have function operate as intended.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general purpose of this function is to provide a moving average of a data stream typically sampled at evenly recorded time intervals common computerised data acquisition systems.  Akin to a moving average function, except that it also resamples the data.
</p>


<h3>Value</h3>

<p>A matrix object returned
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slopebypoint">slopebypoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define a vector of 50 random numbers from 1 to 100
s&lt;-ceiling(runif(50, 0, 100))
x&lt;-seq(1,50,1)
# Calculate the slope value every 4th point
s10&lt;-slopeEveryN(s,4)

plot(x,s,type="l",col="red")
lines(s10,col="black")

</code></pre>

<hr>
<h2 id='StephBoltz'>
The Stephan Boltzman constant.
</h2><span id='topic+StephBoltz'></span>

<h3>Description</h3>

<p>The Stephan Boltzman constant.  Units:  W/m^2/K^4 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StephBoltz()
</code></pre>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function () 
{
    s &lt;- 5.67e-08
    s
  }
  
# Example
# This is simply the Stephan Boltzmann constant, saves having to remember the exact value
# and it allows easier coding.  To call it, type:

StephBoltz()

</code></pre>

<hr>
<h2 id='Te'>
Operative temperature estimate.
</h2><span id='topic+Te'></span>

<h3>Description</h3>

<p>Operative temperature (degrees Celsius) is a measure of the effective temperature an object/animal will be given a specific radiative and convective environment.  Basal heat production and evaporative heat loss are assumed to balance each other out.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Te(Ts=30, Ta=25, Tg=NULL, RH=0.5, E=0.96, rho=0.1, cloud=0, SE=0, V=1, 
L=0.1, c=NULL, n=NULL, a=NULL, b=NULL, m=NULL, type="forced", shape="hcylinder")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Te_+3A_ts">Ts</code></td>
<td>

<p>Surface temperature (degrees Celsius). Default value is 30.  Used in free convection calculation.
</p>
</td></tr>
<tr><td><code id="Te_+3A_ta">Ta</code></td>
<td>

<p>Air temperature (degrees Celsius).  Default value is 20.  Used to estimate ground temperature if Tg is unavailable.
</p>
</td></tr>
<tr><td><code id="Te_+3A_tg">Tg</code></td>
<td>

<p>Ground temperature (degrees Celsius).  Default value is NULL, but a measured Tg can be substituted or estimated with other functions.
</p>
</td></tr>
<tr><td><code id="Te_+3A_rh">RH</code></td>
<td>

<p>Relative humidity (fraction 0 to 1).  Default value is 0.5.  Used in call to Ld() to determine incoming radiation.
</p>
</td></tr>
<tr><td><code id="Te_+3A_e">E</code></td>
<td>

<p>Emissivity (fraction 0 to 1) of the object absorbing longwave radiation.  According to Kirschoff's law, emissivity = absorptivity.  Absorptivity is multiplied by the average of the incoming longwave radiation to estimate absorbed radiation.
</p>
</td></tr>
<tr><td><code id="Te_+3A_rho">rho</code></td>
<td>

<p>Reflectivity (fraction 0 to 1) of the object absorbing solar radiation.  Used to modify absorbed solar energy.  Default is 0.1.  
</p>
</td></tr>
<tr><td><code id="Te_+3A_cloud">cloud</code></td>
<td>

<p>Fractional cloud cover (fraction from 0 to 1).  Used in call to Ld() to determine incoming radiation.  Default is 0.
</p>
</td></tr>
<tr><td><code id="Te_+3A_se">SE</code></td>
<td>

<p>Solar energy (W/m2), usually measured.  Default is 100.
</p>
</td></tr>
<tr><td><code id="Te_+3A_v">V</code></td>
<td>

<p>Air velocity (m/s).  Default value is 1.
</p>
</td></tr>
<tr><td><code id="Te_+3A_l">L</code></td>
<td>

<p>Characteristic dimension (m) of object.  Usually the vertical dimension (i.e. height). Default value is 1.
</p>
</td></tr>
<tr><td><code id="Te_+3A_c">c</code></td>
<td>

<p>coefficient used in forced convection (see Blaxter, 1986, default value is 0.24)
</p>
</td></tr>
<tr><td><code id="Te_+3A_n">n</code></td>
<td>

<p>coefficient used in forced convection (see Blaxter, 1986, default value is 0.6)
</p>
</td></tr>
<tr><td><code id="Te_+3A_a">a</code></td>
<td>

<p>coefficient used in free convection (see Gates, 2003, default value is 1)
</p>
</td></tr>
<tr><td><code id="Te_+3A_b">b</code></td>
<td>

<p>coefficient used in free convection (0.58 upright cylinder, 0.48 flat cylinder, default value is 0.58)
</p>
</td></tr>
<tr><td><code id="Te_+3A_m">m</code></td>
<td>

<p>coefficient used in free convection (0.25 laminar flow, default value is 0.25)
</p>
</td></tr>
<tr><td><code id="Te_+3A_type">type</code></td>
<td>

<p>&quot;forced&quot; or &quot;free&quot; - to calculate convection coefficient for either forced or free convection.  Default value is &quot;forced&quot;
</p>
</td></tr>
<tr><td><code id="Te_+3A_shape">shape</code></td>
<td>

<p>&quot;sphere&quot;, &quot;hplate&quot;, &quot;vplate&quot;, &quot;hcylinder&quot;, &quot;vcylinder&quot; to denote shape and orientation.  h=horizontal, v=vertical.  Default shape is &quot;hcylinder&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates operative temperature according to calculations in Gates (2003) and Angiletta ()
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Angiletta, M. J.  2009.  Thermal Adaptation: A Theoretical and Empirical Synthesis. Oxford University Press, Oxford, UK, 304 pp.
Gates, D.M. 2003.  Biophysical Ecology.  Courier Corporation, 656 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qabs">qabs</a></code>
<code><a href="#topic+hconv">hconv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example

Ts&lt;-40
Ta&lt;-30
SE&lt;-seq(0,1500,100)
Toperative&lt;-NULL
for(rho in seq(0, 1, 0.1)){
  temp&lt;-Te(Ts=Ts, Ta=Ta, Tg=NULL, RH=0.5, E=0.96, rho=rho, cloud=1, SE=SE, V=0.1, 
           L=0.1, type="free", shape="hcylinder")
  Toperative&lt;-cbind(Toperative, temp)
}
Toperative&lt;-data.frame(SE=seq(0,1500,100), Toperative)
colnames(Toperative)&lt;-c("SE", seq(0,1,0.1))
matplot(Toperative$SE, Toperative[,-1], ylim=c(30, 50), type="l", xlim=c(0,1000),
        ylab="Operative Temperature (C)", xlab="Solar Radiation (W/m2)", lty=1,
        col=flirpal[rev(seq(1,380,35))])

# For detailed examples and explanations, see:
# https://github.com/gtatters/Thermimage/blob/master/HeatTransferCalculations.md


</code></pre>

<hr>
<h2 id='temp2raw'>
Converts temperature (oC) to raw thermal data
</h2><span id='topic+temp2raw'></span>

<h3>Description</h3>

<p>Inverse of the function raw2temp.  Typically used when incorrect settings were used during
thermal imaging analysis, and the raw values need to be extracted in order to re-calculate
temperature using raw2temp.  Parameters under which the temperatures were estimated should
be known, since the conversion to raw will take those into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temp2raw(temp, E = 1, OD = 1, RTemp = 20, ATemp = RTemp, IRWTemp = RTemp, IRT = 1, 
RH = 50, PR1 = 21106.77, PB = 1501, PF = 1, PO = -7340, PR2 = 0.012545258,
  ATA1=0.006569, ATA2=0.01262, ATB1=-0.002276, ATB2=-0.00667, ATX=1.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temp2raw_+3A_temp">temp</code></td>
<td>

<p>estimate temperature (oC) from an infrared thermal imaging file
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_e">E</code></td>
<td>

<p>Emissivity - default 1, should be ~0.95 to 0.97 depending on object of interest.  Determined by user.
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_od">OD</code></td>
<td>

<p>Object distance from thermal camera in metres
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_rtemp">RTemp</code></td>
<td>

<p>Apparent reflected temperature (oC) of the enrivonment impinging on the object of interest - one value from FLIR file (oC), default 20C.
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_atemp">ATemp</code></td>
<td>

<p>Atmospheric temperature (oC) for infrared tranmission loss - one value from FLIR file (oC) - default value is set to be equal to the reflected temperature.  Transmission loss is a function of absolute humidity in the air.
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_irwtemp">IRWTemp</code></td>
<td>

<p>Infrared Window Temperature (oC). Default is set to be equivalent to reflected temp (oC).  
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_irt">IRT</code></td>
<td>

<p>Infrared Window transmission - default is set to 1.0.  Likely ~0.95-0.97. Should be empirically determined.  Germanium windows with anti-reflective coating typically have IRTs ~0.95-0.97.
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_rh">RH</code></td>
<td>

<p>Relative humidity expressed as percent.  Default value is 50.
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_pr1">PR1</code></td>
<td>

<p>PlanckR1 - a calibration constant for FLIR cameras
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_pb">PB</code></td>
<td>

<p>PlanckB - a calibration constant for FLIR cameras
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_pf">PF</code></td>
<td>

<p>PlanckF - a calibration constant for FLIR cameras
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_po">PO</code></td>
<td>

<p>PlanckO - a calibration constant for FLIR cameras
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_pr2">PR2</code></td>
<td>

<p>PlanckR2 - a calibration constant for FLIR cameras
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_ata1">ATA1</code></td>
<td>

<p>ATA1 - an atmospheric attenuation constant to calculate atmospheric tau
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_ata2">ATA2</code></td>
<td>

<p>ATA2 - an atmospheric attenuation constant to calculate atmospheric tau
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_atb1">ATB1</code></td>
<td>

<p>ATB1 - an atmospheric attenuation constant to calculate atmospheric tau
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_atb2">ATB2</code></td>
<td>

<p>ATB2 - an atmospheric attenuation constant to calculate atmospheric tau
</p>
</td></tr>
<tr><td><code id="temp2raw_+3A_atx">ATX</code></td>
<td>

<p>ATX - an atmospheric attenuation constant to calculate atmospheric tau
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: PR1, PR2, PB, PF, and PO are specific to each camera and result from the calibration
at factory of the camera's Raw data signal recording from a blackbody radiation source. 
Sample calibration constants for three different cameras (FLIR SC660 with 24x18 degree lens,
FLIR T300 with 25x19 degree lens, FLIR T300 with 2xtelephoto.
</p>
<p>Calibration Constants by cameras:  SC660, T300(25o), T300(25o with telephoto)
</p>

<table>
<tr>
 <td style="text-align: left;">
Constant </td><td style="text-align: center;"> FLIR SC660 </td><td style="text-align: center;"> FLIR T300 </td><td style="text-align: center;"> FLIR T300(t)</td>
</tr>
<tr>
 <td style="text-align: left;">
PR1: </td><td style="text-align: center;"> 21106.77 </td><td style="text-align: center;"> 14364.633 </td><td style="text-align: center;"> 14906.216</td>
</tr>
<tr>
 <td style="text-align: left;">
PB: </td><td style="text-align: center;"> 1501 </td><td style="text-align: center;"> 1385.4 </td><td style="text-align: center;"> 1396.5</td>
</tr>
<tr>
 <td style="text-align: left;">
PF: </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1</td>
</tr>
<tr>
 <td style="text-align: left;">
PO: </td><td style="text-align: center;"> -7340 </td><td style="text-align: center;"> -5753 </td><td style="text-align: center;"> -7261</td>
</tr>
<tr>
 <td style="text-align: left;">
PR2: </td><td style="text-align: center;">  0.012545258 </td><td style="text-align: center;"> 0.010603162 </td><td style="text-align: center;"> 0.010956882</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>PR1: PlanckR1 calibration constant
PB: PlanckB calibration constant  
PF: PlanckF calibration constant   
PO: PlanckO calibration constant
PR2: PlanckR2 calibration constant
</p>
<p>The calibration constants allow for the raw digital signal conversion to and from the
predicted radiance of a blackbody, using the standard equation: 
</p>
<p>temperature&lt;-PB/log(PR1/(PR2*(raw+PO))+PF)-273.15
</p>
<p>Also used in calculations for transmission loss are the following constants:
ATA1: Atmospheric Trans Alpha 1  0.006569 
ATA2: Atmospheric Trans Alpha 2  0.012620
ATB1: Atmospheric Trans Beta 1  -0.002276
ATB2: Atmospheric Trans Beta 2  -0.006670
ATX:  Atmospheric Trans X        1.900000
</p>
<p>Some files may return slightly different ATA1, ATA2, ATB1, ATB2, and ATX values. 
Use the flirsettings function to find out what constants are used for your files.
</p>


<h3>Value</h3>

<p>Returns numeric value.  Can handle vector or matrix objects.
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>


<h3>References</h3>

<p>1. http://130.15.24.88/exiftool/forum/index.php/topic,4898.60.html
</p>
<p>2. Minkina, W. and Dudzik, S. 2009. Infrared Thermography: Errors and Uncertainties.  Wiley
Press, 192 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raw2temp">raw2temp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># General Usage:
# temp2raw(temp,E,OD,RTemp,ATemp,IRWTemp,IRT,RH,PR1,PB,PF,PO,PR2)

# Example with all settings at default/blackbody levels:
temp2raw(23,1,0,20,20,20,1,50,PR1=21106.77,PB=1501,PF=1,PO=-7340,PR2=0.012545258)

# Example with emissivity=0.95, distance=1m, window transmission=0.96, all temperatures=20C,
# 50 RH:

temp2raw(23,0.95,1,20,20,20,0.96,50) 
# Note: default calibration constants for my FLIR camera will be used if you leave out the
# calibration data

t&lt;-10:50
r1.0&lt;-temp2raw(t,1,0,20,20,20,0.96,50)
r0.9&lt;-temp2raw(t,0.9,0,20,20,20,0.96,50)

dev.off()
plot(t,r1.0,type="l",col="red")
lines(t,r0.9,col="black")
legend("topleft", bty = "n", c("E=1.0", "E=0.9"), lty=c(1,1), col=c("red", "black"))

# For information on the effectiveness of the raw2temp and temp2raw 
# functions at estimating temperature properly, see the following:
# https://github.com/gtatters/ThermimageCalibration

</code></pre>

<hr>
<h2 id='Teq'>
Estimates equivalent temperature.
</h2><span id='topic+Teq'></span>

<h3>Description</h3>

<p>Estimates equivalent black-body temperature of an object.  Analagous to other measures of operative temperature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Teq(Ts = 30, Ta = 25, Tg = NULL, RH = 0.5, E = 0.96, rho = 0.1, cloud = 0, SE = 0, V = 1, 
L = 0.1, type = "forced")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Teq_+3A_ts">Ts</code></td>
<td>

<p>Surface temperature (degrees Celsius). Default value is 30.  Not used in this calculation but kept for similar structure to other functions in package.
</p>
</td></tr>
<tr><td><code id="Teq_+3A_ta">Ta</code></td>
<td>

<p>Air temperature (degrees Celsius).  Default value is 20.  Used to estimate ground temperature if Tg is unavailable.
</p>
</td></tr>
<tr><td><code id="Teq_+3A_tg">Tg</code></td>
<td>

<p>Ground temperature (degrees Celsius).  Default value is NULL, but a measured Tg can be substituted or estimated with other functions.  Used in estimating long wave radiation from the ground.
</p>
</td></tr>
<tr><td><code id="Teq_+3A_rh">RH</code></td>
<td>

<p>Relative humidity (fraction 0 to 1).  Default value is 0.5.  Used in call to Ld() to determine incoming radiation.
</p>
</td></tr>
<tr><td><code id="Teq_+3A_e">E</code></td>
<td>

<p>Emissivity (fraction 0 to 1) of the object absorbing longwave radiation.  According to Kirschoff's law, emissivity = absorptivity.  Absorptivity is multiplied by the average of the incoming longwave radiation to estimate absorbed radiation.
</p>
</td></tr>
<tr><td><code id="Teq_+3A_rho">rho</code></td>
<td>

<p>Reflectivity (fraction 0 to 1) of the object absorbing solar radiation.  Used to modify absorbed solar energy.  Default is 0.1.  
</p>
</td></tr>
<tr><td><code id="Teq_+3A_cloud">cloud</code></td>
<td>

<p>Fractional cloud cover (fraction from 0 to 1).  Used in call to Ld() to determine incoming radiation.  Default is 0.
</p>
</td></tr>
<tr><td><code id="Teq_+3A_se">SE</code></td>
<td>

<p>Solar energy (W/m2), usually measured.  Default is 100.
</p>
</td></tr>
<tr><td><code id="Teq_+3A_v">V</code></td>
<td>

<p>Air velocity (m/s).  Default value is 1.
</p>
</td></tr>
<tr><td><code id="Teq_+3A_l">L</code></td>
<td>

<p>Characteristic dimension (m) of object.  Usually the vertical dimension (i.e. height). Default value is 1.
</p>
</td></tr>
<tr><td><code id="Teq_+3A_type">type</code></td>
<td>

<p>&quot;forced&quot; or &quot;free&quot; - to calculate convection coefficient for either forced or free convection.  Default value is &quot;forced&quot;
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Mahoney, S.A. and King, J. R. (1977). The use of the equivalent black-body temperautre in the thermal energetics of small birds.  J Thermal Biol. 2: 115-120
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (Ts = 30, Ta = 25, Tg = NULL, RH = 0.5, E = 0.96, rho = 0.1, 
    cloud = 0, SE = 0, V = 1, L = 0.1, type = "forced") 
{
    if (type == "forced") 
        k &lt;- 0.7 * 310
    if (type == "free") 
        k &lt;- 310
    rr &lt;- airdensity(Ta) * airspecificheat(Ta)/(4 * E * StephBoltz() * 
        (Ta + 273.15)^3)
    ra &lt;- k * (L/V)^0.5
    re &lt;- 1/(1/ra + 1/rr)
    Rni &lt;- qabs(Ta = Ta, Tg = Tg, RH = RH, E = E, rho = rho, 
        cloud = cloud, SE = SE) - StephBoltz() * E * (Ta + 273.15)^4
    Teq &lt;- Ta + Rni * re/(airdensity(Ta) * airspecificheat(Ta))
    Teq
  }
  
# For detailed examples and explanations, see:
# https://github.com/gtatters/Thermimage/blob/master/HeatTransferCalculations.md

</code></pre>

<hr>
<h2 id='Tground'>
Estimates ground temperature from ambient temperature and solar radiation.
</h2><span id='topic+Tground'></span>

<h3>Description</h3>

<p>Estimates ground temperature from ambient temperature and solar radiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tground(Ta = 20, SE = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tground_+3A_ta">Ta</code></td>
<td>

<p>Air temperature (degrees Celsius).  Default is 20.
</p>
</td></tr>
<tr><td><code id="Tground_+3A_se">SE</code></td>
<td>

<p>Solar energy (radiation in W per m2).  Default is 100.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If ground temperature is not measured, but air temperature and solar energy are provided, ground temperature can be estimated from empirical relationships.  Ground temperature is used in obtain incoming longwave radiation from the ground.
</p>


<h3>Value</h3>

<p>Returns a vector of one, with an estimate of ground temperature.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>References</h3>

<p>Bartlett et al. 2006. A decade of ground-air temperature tracking at emigrant pass observatory, Utah. Journal of Climate. 19: 3722-3731.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  
# Example:
Ta&lt;-25
SE&lt;-200
Tground(Ta, SE)

# For detailed examples and explanations, see:
# https://github.com/gtatters/Thermimage/blob/master/HeatTransferCalculations.md

</code></pre>

<hr>
<h2 id='Thermimage-package'>
Handles thermal image data input and conversion to temperature using established physical equations.
</h2><span id='topic+Thermimage-package'></span><span id='topic+Thermimage'></span>

<h3>Description</h3>

<p>Assists in converting raw thermal imaging data files into temperature values.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Thermimage</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Primary purpose of the package is to assist with manipulating raw data extracted from thermal image files.  These raw data are stored in a raw data format and require inforamtion about various environmental variables to estimate surface temperatures accurately.  raw2temp is the primary function of use.  Other functions included involve simple scripts for data handling.  
</p>


<h3>Author(s)</h3>

<p>Glenn J. Tattersall
</p>
<p>Please report issues, upload problems, or provide sample files to the following site:
https://github.com/gtatters/Thermimage/issues
</p>


<h3>References</h3>

<p>1. http://130.15.24.88/exiftool/forum/index.php/topic,4898.60.html
</p>
<p>2. Minkina, W. and Dudzik, S. 2009. Infrared Thermography: Errors and Uncertainties.  Wiley Press, 192 pp.
</p>

<hr>
<h2 id='thermsum'>
Return summary of thermal image data.
</h2><span id='topic+thermsum'></span>

<h3>Description</h3>

<p>Provides typical summary data (min, max, mean, sd, median) of a vector of raw binary thermal encoded data.  If templookup is not provided, the summary info is conducted on the data provided.  If a templookup vector is provided (see Examples in raw2temp function), the dat values are converted to temperature before summary information is extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thermsum(dat, templookup = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thermsum_+3A_dat">dat</code></td>
<td>

<p>An integer vector of raw binary thermal information (usually) extracted from a thermal video or image using the getFrames or readflirJPG functions to be converted to temperature and summarised.  Instead, this can be a vector of temperature values (numeric); if so, then templookup should be set to NULL or ignored.
</p>
</td></tr>
<tr><td><code id="thermsum_+3A_templookup">templookup</code></td>
<td>

<p>A vector of temperatures converted using the raw2temp function, corresponding to the conversion from raw binary thermal information to calibrated temperature estimates.  Typically will be vector of numbers 2^16 long, for a 16-bit camera.  Default is NULL, which assumes that dat has already been converted to temperature.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple summary function for thermal imaging data to allow for extraction of basic statistical data from a thermal image dataset.  If dat is supplied as an integer vector of raw binary values, then templookup should be supplied to use as an indexing function. 
</p>
<p>Using raw2temp(1:65535) will produce a vector of temperatures that correspond to the indexed integers 1:65535.  This method of calculation can be faster on large video files.  The default settings for raw2temp() will not be appropriate, and all camera settings should be used according to calibration constants.
</p>
<p>If dat is supplied as a vector of temperatures, then templookup must be left blank or NULL as the default.  Summary information will be calculated on the dat variable assuming it is properly calibrated temperature values.
</p>
<p>As written, this is a vectorised function, so will only calculate summary on the vector provided.  To perform thermal summaries on multiple frames from the raw binary video data, use a for-loop (usually slow) or the apply function to process (faster processing) or parallel apply functions (best).  
</p>


<h3>Value</h3>

<p>Returns a named vector: Mintemp, Maxtemp, Meantemp, SDtemp, and Mediantemp 
</p>


<h3>Warning</h3>

<p>This function simply calculates summary data, and does not detect objects in the image frame.  Use only as rapid way to extract thermal information.  This is not a replacement for doing analysis by hand, and may only be useful for objects that are stationary and remain within the image frame over time.</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raw2temp">raw2temp</a></code>, 
<code><a href="#topic+thermsumcent">thermsumcent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set w to 640 and h to 480
w&lt;-640
h&lt;-480
f&lt;-system.file("extdata", "SampleSEQ.seq", package = "Thermimage")
x&lt;-frameLocates(f, w=w, h=h)
suppressWarnings(templookup&lt;-raw2temp(1:65535))
alldata&lt;-unlist(lapply(x$f.start, getFrames, vidfile=f, w=w, h=h))
alldata&lt;-matrix(alldata, nrow=w*h, byrow=TRUE)

# Summary on one image or frame of data
thermsum(alldata[,1], templookup)

# Summary on multi-frame seq file
tsum&lt;-data.frame(t(apply(alldata, 2, thermsum, templookup)))
tsum

# Randomly generated data
alldata&lt;-floor(runif(w*h*10, 17000, 25000))
alldata&lt;-matrix(alldata, nrow=w*h)

# depending on the size of alldata, directly calculating temperature can slow down processing
# For a 10 frame file:
system.time(alltemperature&lt;-raw2temp(alldata))

# But summary calculations using raw binary with lookup are slightly slower than
# using numeric temperatures:

# Perform calculations on the raw binary but supply the templookup vector
system.time(tsum&lt;-data.frame(t(apply(alldata, 2, thermsum, templookup))))

# Perform calculations on the converted temperature values
system.time(tsum&lt;-data.frame(t(apply(alltemperature, 2, thermsum))))
tsum



</code></pre>

<hr>
<h2 id='thermsumcent'>
Summary thermal calculations on a centrally located region of interest from a thermal image dataset 
</h2><span id='topic+thermsumcent'></span>

<h3>Description</h3>

<p>Similarly to the thermsum except this provides thermal summary data on a central region of interest, commonly used in thermal imaging.  The size of the region is a rectangular region corresponding to a fraction of the total image area set by boxsize.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thermsumcent(dat, templookup = NULL, w = 640, h = 480, boxsize = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thermsumcent_+3A_dat">dat</code></td>
<td>

<p>An integer vector of raw binary thermal information (usually) extracted from a thermal video or image using the getFrames or readflirJPG functions to be converted to temperature and summarised.  Instead, this can be a vector of temperature values (numeric); if so, then templookup should be set to NULL or ignored.
</p>
</td></tr>
<tr><td><code id="thermsumcent_+3A_templookup">templookup</code></td>
<td>

<p>A vector of temperatures converted using the raw2temp function, corresponding to the conversion from raw binary thermal information to calibrated temperature estimates.  Typically will be vector of numbers 2^16 long, for a 16-bit camera.  Default is NULL, which assumes that dat has already been converted to temperature.
</p>
</td></tr>
<tr><td><code id="thermsumcent_+3A_w">w</code></td>
<td>

<p>Width resolution (pixels) of thermal camera.  Can be found by using the flirsettings function.
</p>
</td></tr>
<tr><td><code id="thermsumcent_+3A_h">h</code></td>
<td>

<p>Height resolution (pixels) of thermal camera.  Can be found by using the flirsettings function.
</p>
</td></tr>
<tr><td><code id="thermsumcent_+3A_boxsize">boxsize</code></td>
<td>

<p>Fractional area of the desired rectangular region of interest.  Default is set to 0.05.  Dimensions of the region will depend on w and h dimensions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple summary function for thermal imaging data to allow for extraction of basic statistical data from a thermal image dataset.  If dat is supplied as an integer vector of raw binary values, then templookup should be supplied to use as an indexing function. 
</p>
<p>Using raw2temp(1:65535) will produce a vector of temperatures that correspond to the indexed integers 1:65535.  This method of calculation can be faster on large video files.  The default settings for raw2temp() will not be appropriate, and all camera settings should be used according to calibration constants.
</p>
<p>If dat is supplied as a vector of temperatures, then templookup must be left blank or NULL as the default.  Summary information will be calculated on the dat variable assuming it is properly calibrated temperature values.
</p>
<p>As written, this is a vectorised function, so will only calculate summary on the vector provided.  To perform thermal summaries on multiple frames from the raw binary video data, use a for-loop (usually slow) or the apply function to process (faster processing) or parallel apply functions (best). 
</p>
<p>Similar to thermsum, except this assesses only the centrally located region of interest in the image frame centre.
</p>


<h3>Value</h3>

<p>Returns a named vector: CentrePoint, CentreBoxMin, CentreBoxMax, CentreBoxMean, CentreBoxSD, CentreBoxMedian)
</p>


<h3>Warning</h3>

<p>This function simply calculates summary data, and does not detect objects in the image frame.  Use only as rapid way to extract thermal information.  This is not a replacement for doing analysis by hand, and may only be useful for objects that are stationary and remain within the image frame over time.</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raw2temp">raw2temp</a></code>, 
<code><a href="#topic+thermsum">thermsum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set w to 640 and h to 480

w&lt;-640
h&lt;-480
f&lt;-system.file("extdata", "SampleSEQ.seq", package = "Thermimage")
x&lt;-frameLocates(f)
suppressWarnings(templookup&lt;-raw2temp(1:65535))
alldata&lt;-unlist(lapply(x$f.start, getFrames, vidfile=f, w=w, h=h))
alldata&lt;-matrix(alldata, nrow=w*h, byrow=TRUE)

# Summary on one image or frame of data
thermsumcent(alldata[,1], templookup)

# Summary on multi-frame seq file
tsum&lt;-data.frame(t(apply(alldata, 2, thermsumcent, templookup)))
tsum

# Randomly generated data
alldata&lt;-floor(runif(w*h*20, 17000, 25000))
alldata&lt;-matrix(alldata, nrow=w*h)

# depending on the size of alldata, directly calculating temperature can slow down processing
# For a 20 frame file:
system.time(alltemperature&lt;-raw2temp(alldata))

# But summary calculations using raw binary with lookup are slightly slower than
# using numeric temperatures:

# Perform calculations on the raw binary but supply the templookup vector
system.time(tsum&lt;-data.frame(t(apply(alldata, 2, thermsumcent, templookup))))

# Perform calculations on the converted temperature values
system.time(tsum&lt;-data.frame(t(apply(alltemperature, 2, thermsumcent))))
tsum






</code></pre>

<hr>
<h2 id='writeFlirBin'>
Saves thermal image data to a binary file
</h2><span id='topic+writeFlirBin'></span>

<h3>Description</h3>

<p>Saves thermal image data to a binary file.  This function serves to allow thermal images that have been imported into R to be exported to a raw, 32-bit real format that can then be imported and analysed in ImageJ.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeFlirBin(bindata, templookup, w, h, Interval, rootname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeFlirBin_+3A_bindata">bindata</code></td>
<td>

<p>Vector of raw binary data imported from a thermal image file, using the getFrames function.  Each value corresponds to the raw binary sensor value for each pixel.  Should be supplied as a vector, not a dataframe or matrix.
</p>
</td></tr>
<tr><td><code id="writeFlirBin_+3A_templookup">templookup</code></td>
<td>

<p>A vector of values from 1:65535 (2^16) that serves as a rapid means to convert the above bindata into calibrated temperature data for each pixel.  This makes use of the raw2temp function.  This value must be supplied and properly calibrated, otherwise the conversion will not be correct.  Default is set to NULL.  If calibrated temperature data is supplised as bindata, then templookup should be set to NULL.
</p>
</td></tr>
<tr><td><code id="writeFlirBin_+3A_w">w</code></td>
<td>

<p>Width resolution (pixels) of thermal camera.  Can be found by using the flirsettings function.
</p>
</td></tr>
<tr><td><code id="writeFlirBin_+3A_h">h</code></td>
<td>

<p>Height resolution (pixels) of thermal camera.  Can be found by using the flirsettings function.
</p>
</td></tr>
<tr><td><code id="writeFlirBin_+3A_interval">Interval</code></td>
<td>

<p>Time inverval (in seconds = 1 / Frame rate) of the thermal video file.  Used for encoding in filename. 
</p>
</td></tr>
<tr><td><code id="writeFlirBin_+3A_rootname">rootname</code></td>
<td>

<p>Root name (character) for saving the binary file
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exports raw binary information from the getFrames function in a 32-bit real file format (4 bytes).  This file format can be relatively easily imported into ImageJ using the Import-Raw option, choose 32-bit Real, set your image width and height and # of frames. Little endian and hyperstack options must be enabled during import.
</p>
<p>The file naming takes the rootname and appends image width, height, number of frames, and image interval, appending .raw to the end to make ImageJ import easier. 
</p>
<p>If rootname = 'Thermvid', w=640, h=480, number of frames=100, and image interval is 0.0333 seconds, the file name will be saved as:
</p>
<p>'Thermvid_W640_H480_F100_I0.0333.raw'
</p>


<h3>Value</h3>

<p>Returns nothing, but saves a new file to the current working directory. 
</p>


<h3>Warning</h3>

<p>This function has not been fully tested with all possible video/camera combinations.  Users are advised to compare the exported values in ImageJ on sample images to standard FLIR software values before proceeding with analysis.
</p>


<h3>Author(s)</h3>

<p>Glenn J Tattersall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raw2temp">raw2temp</a></code>,
<code><a href="#topic+getFrames">getFrames</a></code>,
<code><a href="base.html#topic+readBin">readBin</a></code>,
<code><a href="base.html#topic+writeBin">writeBin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bindata&lt;-floor(runif(307200, 17000, 25000))
templookup&lt;-raw2temp(bindata)
w&lt;-640
h&lt;-480
Interval&lt;-0.03
f.root&lt;-"Thermalvid"

# Usage:
# writeFlirBin(bindata, templookup=templookup,  w=w, h=h, Interval=Interval, rootname=f.root)

</code></pre>

<hr>
<h2 id='yellowpal'>
Colour palette extracted from FLIR thermal camera files
</h2><span id='topic+yellowpal'></span>

<h3>Description</h3>

<p>A text file containing the palette information for use in thermal images
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
