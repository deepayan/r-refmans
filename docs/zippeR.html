<!DOCTYPE html><html lang="en"><head><title>Help for package zippeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {zippeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#zi_aggregate'><p>Aggregate ZCTAs to Three-digit ZCTAs</p></a></li>
<li><a href='#zi_convert'><p>Convert Five-digit ZIP Codes to Three-digit ZIP Codes</p></a></li>
<li><a href='#zi_crosswalk'><p>Crosswalk ZIP Codes with UDS, HUD, or a Custom Dictionary</p></a></li>
<li><a href='#zi_get_demographics'><p>Download Demographic Data for Five-digit ZCTAs</p></a></li>
<li><a href='#zi_get_geometry'><p>Download and Optionally Geoprocess ZCTAs</p></a></li>
<li><a href='#zi_label'><p>Label ZIP Codes with Contextual Data</p></a></li>
<li><a href='#zi_list_zctas'><p>List ZCTA GEOIDs for States</p></a></li>
<li><a href='#zi_load_crosswalk'><p>Load Crosswalk Files</p></a></li>
<li><a href='#zi_load_labels'><p>Load Label Data</p></a></li>
<li><a href='#zi_load_labels_list'><p>Load List of Available Label Data Sets</p></a></li>
<li><a href='#zi_mo_hud'><p>Missouri HUD ZIP Code to County Crosswalk, 2023</p></a></li>
<li><a href='#zi_mo_pop'><p>Total Population and Median Household Income, Missouri ZCTAs 2022</p></a></li>
<li><a href='#zi_mo_usps'><p>Missouri USPS Three-digit ZIP Code Labels, August 2024</p></a></li>
<li><a href='#zi_mo_zcta3'><p>Missouri Three-digit ZCTAs, 2022</p></a></li>
<li><a href='#zi_prep_hud'><p>Convert HUD Crosswalk Data to Finalized Crosswalk</p></a></li>
<li><a href='#zi_repair'><p>Repair ZIP Code or ZCTA Vector</p></a></li>
<li><a href='#zi_validate'><p>Validate ZIP Code or ZCTA Vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Working with United States ZIP Code and ZIP Code Tabulation Area
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of functions for working with American postal codes,
   which are known as ZIP Codes. These include accessing ZIP Code to ZIP Code 
   Tabulation Area (ZCTA) crosswalks, retrieving demographic data for ZCTAs, and 
   tabulating demographic data for three-digit ZCTAs.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pfizer-opensource/zippeR">https://github.com/pfizer-opensource/zippeR</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, datasets, dplyr, httr, jsonlite, purrr, readr, sf,
spatstat.univar, stats, stringr, tibble, tidycensus, tidyr,
tigris</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-25 21:56:07 UTC; prenec</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Prener
    <a href="https://orcid.org/0000-0002-4310-9888"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Timothy Wiemken <a href="https://orcid.org/0000-0002-8251-3007"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Angela Cook [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Prener &lt;Christopher.Prener@pfizer.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-25 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='zi_aggregate'>Aggregate ZCTAs to Three-digit ZCTAs</h2><span id='topic+zi_aggregate'></span>

<h3>Description</h3>

<p>This function takes input ZCTA data and aggregates it to three-digit
areas, which are considerably larger. These regions are sometimes used in
American health care contexts for publishing geographic identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_aggregate(.data, year, extensive = NULL, intensive = NULL,
    intensive_method = "mean", survey, output = "tidy", zcta = NULL,
    key = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_aggregate_+3A_.data">.data</code></td>
<td>
<p>A tidy set of demographic data containing one or more variables
that should be aggregated to three-digit ZCTAs. This data frame or tibble
should contain all five-digit ZCTAs within the three digit ZCTAs that you
plan to use for aggregating data. See Details below for formatting
requirements.</p>
</td></tr>
<tr><td><code id="zi_aggregate_+3A_year">year</code></td>
<td>
<p>A four-digit numeric scalar for year. <code>zippeR</code> currently
supports data for from 2010 to 2022. Different <code>survey</code> products
are available for different years. See the <code>survey</code> parameter
for more details.</p>
</td></tr>
<tr><td><code id="zi_aggregate_+3A_extensive">extensive</code></td>
<td>
<p>A character scalar or vector listing all extensive (i.e.
count data) variables you wish to aggregate. These will be summed. For
American Community Survey data, the margin of error will be calculated by
taking the square root of the summed, squared margins of error for each
five-digit ZCTA within a given three-digit ZCTA.</p>
</td></tr>
<tr><td><code id="zi_aggregate_+3A_intensive">intensive</code></td>
<td>
<p>A character scalar or vector listing all intensive (i.e.
ratio, percent, or median data) variables you wish to aggregate. These
will be combined using the approach listed for <code>intensive_method</code>.</p>
</td></tr>
<tr><td><code id="zi_aggregate_+3A_intensive_method">intensive_method</code></td>
<td>
<p>A character scalar; either <code>"mean"</code> (default)
or <code>"median"</code>. In either case, a weighted approach is used where
total population for each five-digit ZCTA is used to calculate individual
ZCTAs' weights. For American Community Survey Data, this is applied to
the margin of error as well.</p>
</td></tr>
<tr><td><code id="zi_aggregate_+3A_survey">survey</code></td>
<td>
<p>A character scalar representing the Census product. It can
be either a Decennial Census product (either <code>"sf1"</code> or <code>"sf3"</code>)
or an American Community Survey product (either <code>"acs1"</code>,
<code>"acs3"</code>, or <code>"acs5"</code>). For Decennial Census calls, only the 2010
Census is available. In addition, if a variable cannot be found in <code>"sf1"</code>,
the function will look in <code>"sf3"</code>. Also note that <code>"acs3"</code> was
discontinued after 2013.</p>
</td></tr>
<tr><td><code id="zi_aggregate_+3A_output">output</code></td>
<td>
<p>A character scalar; one of <code>"tidy"</code> (long output) or
<code>"wide"</code> depending on the type of data format you want. If you are
planning to join these data with geometric data, <code>"wide"</code> is the
strongly encouraged format.</p>
</td></tr>
<tr><td><code id="zi_aggregate_+3A_zcta">zcta</code></td>
<td>
<p>An optional vector of ZCTAs that demographic data are requested
for. If this is <code>NULL</code>, data will be returned for all ZCTAs. If a
vector is supplied, only data for those requested ZCTAs will be returned.
The vector can be created with <code>zi_get_geometry()</code>. If
<code>style = "zcta5"</code>, this vector should be made up of five-digit
<code>GEOID</code> values. If <code>style = "zcta3"</code>, this vector should be
made up of three-digital <code>ZCTA3</code> values.</p>
</td></tr>
<tr><td><code id="zi_aggregate_+3A_key">key</code></td>
<td>
<p>A Census API key, which can be obtained at
<a href="https://api.census.gov/data/key_signup.html">https://api.census.gov/data/key_signup.html</a>. This can be omitted if
<code>tidycensus::census_api_key()</code> has been used to write your key to
your <code>.Renviron</code> file. You can check whether an API key has been
written to <code>.Renviron</code> by using <code>Sys.getenv("CENSUS_API_KEY")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing all aggregated data requested in either
<code>"tidy"</code> or <code>"wide"</code> format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load sample demographic data
mo22_demos &lt;- zi_mo_pop

  # the above data can be replicated with the following code:
  # zi_get_demographics(year = 2022, variables = c("B01003_001", "B19013_001"),
  #   survey = "acs5")

# load sample geometric data
mo22_zcta3 &lt;- zi_mo_zcta3

  # the above data can be replicated with the following code:
  # zi_get_geometry(year = 2022, style = "zcta3", state = "MO",
  #   method = "intersect")

# aggregate a single variable
zi_aggregate(mo22_demos, year = 2020, extensive = "B01003_001", survey = "acs5",
  zcta = mo22_zcta3$ZCTA3)


# aggregate multiple variables, outputting wide data
zi_aggregate(mo22_demos, year = 2020,
  extensive = "B01003_001", intensive = "B19013_001", survey = "acs5",
  zcta = mo22_zcta3$ZCTA3, output = "wide")


</code></pre>

<hr>
<h2 id='zi_convert'>Convert Five-digit ZIP Codes to Three-digit ZIP Codes</h2><span id='topic+zi_convert'></span>

<h3>Description</h3>

<p>This function converts five-digit ZIP Codes to three-digit ZIP
Codes. The first three digits of a ZIP Code are known as the ZIP3 Code,
and corresponds to the sectional center facility (SCF) that processes mail
for a region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_convert(.data, input_var, output_var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_convert_+3A_.data">.data</code></td>
<td>
<p>A data frame containing a column of five-digit ZIP Codes.</p>
</td></tr>
<tr><td><code id="zi_convert_+3A_input_var">input_var</code></td>
<td>
<p>A character scalar specifying the column name with the five-digit
ZIP Codes in the data frame.</p>
</td></tr>
<tr><td><code id="zi_convert_+3A_output_var">output_var</code></td>
<td>
<p>Optional; A character scalar specifying the column name to
store the three-digit ZIP Codes in the data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the original data frame with a new column of
three-digit ZIP Codes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add new column
## create sample data
df &lt;- data.frame(id = c(1:3), zip5 = c("63005", "63139", "63636"))

## convert ZIP Codes to ZIP3, creating a new column
zi_convert(.data = df, input_var = zip5, output_var = zip3)

# overwrite existing column
## create sample data
df &lt;- data.frame(id = c(1:3), zip = c("63005", "63139", "63636"))

## convert ZIP Codes to ZIP3, creating a new column
zi_convert(.data = df, input_var = zip)

</code></pre>

<hr>
<h2 id='zi_crosswalk'>Crosswalk ZIP Codes with UDS, HUD, or a Custom Dictionary</h2><span id='topic+zi_crosswalk'></span>

<h3>Description</h3>

<p>This function compares input data containing ZIP Codes with
a crosswalk file that will append ZCTAs. This is an important step because
not all ZIP Codes have the same five digits as their enclosing ZCTA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_crosswalk(.data, input_var, zip_source = "UDS", source_var,
    source_result, year = NULL, qtr = NULL, target = NULL, query = NULL,
    by = NULL, return_max = NULL, key = NULL, return = "id")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_crosswalk_+3A_.data">.data</code></td>
<td>
<p>An &quot;input object&quot; that is data.frame or tibble that contains
ZIP Codes to be crosswalked.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_input_var">input_var</code></td>
<td>
<p>The column in the input data that contains five-digit ZIP
Codes. If the input is numeric, it will be transformed to character data
and leading zeros will be added.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_zip_source">zip_source</code></td>
<td>
<p>Required character scalar or data frame; specifies the
source of ZIP Code crosswalk data. This can be one of either <code>"UDS"</code>
(default) or <code>"HUD"</code>, or a data frame containing a custom dictionary.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_source_var">source_var</code></td>
<td>
<p>Character scalar, required when <code>zip_source</code> is a
data frame containing a custom dictionary; specifies the column name in
the dictionary object that contains ZIP Codes.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_source_result">source_result</code></td>
<td>
<p>Character scalar, required when <code>zip_source</code> is a
data frame containing a custom dictionary; specifies the column name in
the dictionary object that contains ZCTAs, GEOIDs, or other values.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_year">year</code></td>
<td>
<p>Optional four-digit numeric scalar for year; varies based on source.
For <code>"UDS"</code>, years 2009 through 2023 are available. For <code>"HUD"</code>,
years 2010 through 2024 are available. Does not need to be specified when
a custom dictionary is used.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_qtr">qtr</code></td>
<td>
<p>Numeric scalar, required when <code>zip_code</code> is <code>"HUD"</code>.
Integer value between 1 and 4, representing the quarter of the year.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_target">target</code></td>
<td>
<p>Character scalar, required when <code>zip_code</code> is <code>"HUD"</code>.
Can be one of <code>"TRACT"</code>, <code>"COUNTY"</code>, <code>"CBSA"</code>,
<code>"CBSADIV"</code>, <code>"CD"</code>, and <code>"COUNTYSUB"</code>.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_query">query</code></td>
<td>
<p>Scalar or vector, required when <code>zip_code</code> is <code>"HUD"</code>.
This can be a five-digit numeric or character ZIP Code, a vector of
ZIP Codes, a two-letter character state abbreviation, or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_by">by</code></td>
<td>
<p>Character scalar, required when <code>zip_code</code> is <code>"HUD"</code>;
the column name to use for identifying the best match for a given ZIP Code.
This could be either <code>"residential"</code>, <code>"commercial"</code>, or <code>"total"</code>.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_return_max">return_max</code></td>
<td>
<p>Logical scalar, required when <code>zip_code</code> is <code>"HUD"</code>;
if <code>TRUE</code> (default), only the geography with the highest proportion
of the ZIP Code type will be returned. If the ZIP Code straddles two states,
two records will be returned. If <code>FALSE</code>, all records for the ZIP Code
will be returned. Where a tie exists (i.e. two geographies each contain half
of all addresses), the county with the lowest <code>GEOID</code> value will be
returned.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_key">key</code></td>
<td>
<p>Optional when <code>zip_code</code> is <code>"HUD"</code>. This should be a
character string containing your HUD API key. Alternatively, it can be
stored in your <code>.RProfile</code> as <code>hud_key</code>.</p>
</td></tr>
<tr><td><code id="zi_crosswalk_+3A_return">return</code></td>
<td>
<p>Character scalar, specifies the type of output to return. Can be
one of <code>"id"</code> (default), which appends only the crosswalked value,
or <code>"all"</code>, which returns the entire crosswalk file appended to
the source data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with crosswalk values (or optionally, the full
crosswalk file) appended based on the <code>return</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create sample data
df &lt;- data.frame(id = c(1:3), zip5 = c("63005", "63139", "63636"))

# UDS crosswalk

  zi_crosswalk(df, input_var = zip5, zip_source = "UDS", year = 2022)


# HUD crosswalk
# you will need to replace INSERT_HUD_KEY with your own key
## Not run: 
  zi_crosswalk(df, input_var = zip5, zip_source = "HUD", year = 2023,
    qtr = 1, target = "COUNTY", query = "MO", by = "residential",
    return_max = TRUE, key = INSERT_HUD_KEY)

## End(Not run)

# custom dictionary
## load sample crosswalk data to simulate custom dictionary
mo_xwalk &lt;- zi_mo_hud

# prep crosswalk
# when a ZIP Code crosses county boundaries, the portion with the largest
# number of residential addresses will be returned
mo_xwalk &lt;- zi_prep_hud(mo_xwalk, by = "residential", return_max = TRUE)

## crosswalk
zi_crosswalk(df, input_var = zip5, zip_source = mo_xwalk, source_var = zip5,
  source_result = geoid)

</code></pre>

<hr>
<h2 id='zi_get_demographics'>Download Demographic Data for Five-digit ZCTAs</h2><span id='topic+zi_get_demographics'></span>

<h3>Description</h3>

<p>This function returns demographic data for five-digit ZIP Code
Tabulation Areas (ZCTAs), which are rough approximations of many (but not
all) USPS ZIP codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_get_demographics(year, variables = NULL, table = NULL,
    survey, output = "tidy", zcta = NULL, key = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_get_demographics_+3A_year">year</code></td>
<td>
<p>A four-digit numeric scalar for year. <code>zippeR</code> currently
supports data for from 2010 to 2022. Different <code>survey</code> products
are available for different years. See the <code>survey</code> parameter
for more details</p>
</td></tr>
<tr><td><code id="zi_get_demographics_+3A_variables">variables</code></td>
<td>
<p>A character scalar or vector of variable IDs.</p>
</td></tr>
<tr><td><code id="zi_get_demographics_+3A_table">table</code></td>
<td>
<p>A character scalar of a table ID (only one table may be
requested per call).</p>
</td></tr>
<tr><td><code id="zi_get_demographics_+3A_survey">survey</code></td>
<td>
<p>A character scalar representing the Census product. It can
be either a Decennial Census product (either <code>"sf1"</code> or <code>"sf3"</code>)
or an American Community Survey product (either <code>"acs1"</code>,
<code>"acs3"</code>, or <code>"acs5"</code>). For Decennial Census calls, only the 2010
Census is available. In addition, if a variable cannot be found in <code>"sf1"</code>,
the function will look in <code>"sf3"</code>. Also note that <code>"acs3"</code> was
discontinued after 2013.</p>
</td></tr>
<tr><td><code id="zi_get_demographics_+3A_output">output</code></td>
<td>
<p>A character scalar; one of <code>"tidy"</code> (long output) or
<code>"wide"</code> depending on the type of data format you want. If you are
planning to pass these data to <code>zi_aggregate()</code>, you must choose
<code>"tidy"</code>. If you are leaving these data as five-digit ZCTAs and are
planning to join them with geometric data, <code>"wide"</code> is the
strongly encouraged format.</p>
</td></tr>
<tr><td><code id="zi_get_demographics_+3A_zcta">zcta</code></td>
<td>
<p>An optional vector of ZCTAs that demographic data are requested
for. If this is <code>NULL</code>, data will be returned for all ZCTAs. If a
vector is supplied, only data for those requested ZCTAs will be returned.
The vector can be created with <code>zi_get_geometry()</code> and should only
contain five-digit ZCTAs.</p>
</td></tr>
<tr><td><code id="zi_get_demographics_+3A_key">key</code></td>
<td>
<p>A Census API key, which can be obtained at
<a href="https://api.census.gov/data/key_signup.html">https://api.census.gov/data/key_signup.html</a>. This can be omitted if
<code>tidycensus::census_api_key()</code> has been used to write your key to
your <code>.Renviron</code> file. You can check whether an API key has been
written to <code>.Renviron</code> by using <code>Sys.getenv("CENSUS_API_KEY")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing all demographic data requested in either
<code>"tidy"</code> or <code>"wide"</code> format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # download all ZCTAs
  zi_get_demographics(year = 2012, variables = "B01003_001", survey = "acs5")

  # limit output to subset of ZCTAs
  ## download all ZCTAs in Missouri, intersects method
  mo20 &lt;- zi_get_geometry(year = 2020, state = "MO", method = "intersect")

  ## download demographic data
  zi_get_demographics(year = 2012, variables = "B01003_001", survey = "acs5",
      zcta = mo20$GEOID)


</code></pre>

<hr>
<h2 id='zi_get_geometry'>Download and Optionally Geoprocess ZCTAs</h2><span id='topic+zi_get_geometry'></span>

<h3>Description</h3>

<p>This function returns geometric data for ZIP Code Tabulation
Areas (ZCTAs), which are rough approximations of many (but not all)
USPS ZIP codes. Downloading and processing these data will be heavily
affected by your internet connection, your choice for the <code>cb</code>
argument, and the processing power of your computer (if you select
specific counties).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_get_geometry (year, style = "zcta5", return = "id", class = "sf",
    state = NULL, county = NULL, territory = NULL, cb = FALSE,
    starts_with = NULL, includes = NULL, excludes = NULL, method,
    shift_geo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_get_geometry_+3A_year">year</code></td>
<td>
<p>A four-digit numeric scalar for year. <code>zippeR</code> currently
supports data between 2010 and 2023</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_style">style</code></td>
<td>
<p>A character scalar - either <code>"zcta5"</code> or <code>"zcta3"</code>.
See Details below.</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_return">return</code></td>
<td>
<p>A character scalar; if <code>"id"</code> (default), only the five-digit
number of each ZCTA (or three-digit if <code>style = "zcta3"</code>) is returned.
This is the only valid option for  <code>style = "zcta3"</code>. For
<code>style = "zcta5"</code>, if <code>return = "full"</code>, all TIGER/Line columns
are returned.</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_class">class</code></td>
<td>
<p>A character scalar; if <code>"sf"</code> (default), a <code>sf</code> object
suitable for mapping will be returned. If <code>"tibble"</code>, an object
that omits the geometric data will be returned instead.</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_state">state</code></td>
<td>
<p>A character scalar or vector with character state abbreviations
(e.x. <code>"MO"</code>) or numeric FIPS codes (e.x. <code>29</code>). ZCTAs that
are within the given states (determined based on a combination of
<code>year</code> and <code>method</code>) will be returned. See Details below for
more information. This argument is optional unless a argument is also
specified for <code>county</code>.</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_county">county</code></td>
<td>
<p>A character scalar or vector with character GEOIDs (e.x.
<code>"29510"</code>). ZCTAs that are within the given states (determined based
on a combination of <code>year</code> and <code>method</code>) will be returned. See
Details below for more information. This argument is optional.</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_territory">territory</code></td>
<td>
<p>A character scalar or vector with character territory abbreviations
(e.x. <code>"PR"</code>) or numeric FIPS codes (e.x. <code>72</code>). ZCTAs that are
within the given territories will be returned. By default, all territories
are excluded. The five territory abbreviations are: <code>"AS"</code> (American
Samoa), <code>"GU"</code> (Guam), <code>"MP"</code> (Northern Mariana Islands),
<code>"PR"</code> (Puerto Rico), and <code>"VI"</code> (U.S. Virgin Islands).</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_cb">cb</code></td>
<td>
<p>A logical scalar; if <code>FALSE</code>, the most detailed TIGER/Line
data will be used for <code>style = "zcta5"</code>. If <code>TRUE</code>, a
generalized (1:500k) version of the data will be used. The generalized
data will download significantly faster, though they show less detail.
According to the <code>tigris::zctas()</code> documentation, the download size
if <code>TRUE</code> is ~65MB while it is ~500MB if <code>cb = FALSE</code>.
</p>
<p>This argument does not apply to <code>style = "zcta3"</code>, which only returns
generalized data. It also does not apply if <code>class = "tibble"</code>.</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_starts_with">starts_with</code></td>
<td>
<p>A character scalar or vector containing the first two
digits of a GEOID or ZCTA3 value to return. It defaults to <code>NULL</code>,
which will return all ZCTAs in the US. For example, supplying the argument
<code>starts_with = c("63", "64")</code> will return only those ZCTAs or ZCTA3s
that begin with 63 or 64. If you supply a state or a county, that will limit
the data this argument is applied to, potentially leading to missed ZCTAs.</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_includes">includes</code></td>
<td>
<p>A character scalar or vector containing GEOID's or ZCTA3 values
to include when finalizing output. This may be necessary depending on what
is identified with the <code>method</code> argument.</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_excludes">excludes</code></td>
<td>
<p>A character scalar or vector containing GEOID's or ZCTA3 values
to exclude when finalizing output. This may be necessary depending on what
is identified with the <code>method</code> argument.</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_method">method</code></td>
<td>
<p>A character scalar - either <code>"intersect"</code> or <code>"centroid"</code>.
See Details below.</p>
</td></tr>
<tr><td><code id="zi_get_geometry_+3A_shift_geo">shift_geo</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code>, Alaska, Hawaii, and Puerto Rico
will be re-positioned so that the lie to the southwest of the continental
United States. This defaults to <code>FALSE</code>, and can only be used when
states are not listed for the <code>state</code> argument. It does not apply
if <code>class = "tibble"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function contains options for both the type of ZCTA and,
optionally, for how state and county data are identified. For type,
either five-digit or three-digit ZCTA geometries are available. The
three-digit ZCTAs were created by geoprocessing the five-digit boundaries
for each year, and then applying a modest amount of simplification
(with <code>sf::st_simplify()</code>) to reduce file size. The source files
are available on GitHub at <a href="https://github.com/chris-prener/zcta3">https://github.com/chris-prener/zcta3</a>.
</p>
<p>Since ZCTAs cross state lines, two methods are used to create these
geometry data for years 2012 and beyond for states and all years for counties.
The <code>"intersect"</code> method  will return ZCTAs that border the states or
counties selected. In most  cases, this will result in more ZCTAs being
returned than are actually within the states or counties selected.
Conversely, the <code>"centroid"</code> method will return only ZCTAs whose
centroids (geographical centers) lie within the states or counties named.
In most cases, this will return fewer ZCTAs than actually lie within the
states or counties selected. Users will need to review their data carefully
and will likely need to use the <code>include</code> and <code>exclude</code> arguments
to finalize the geographies returned.
</p>
<p>For state-level data in 2010 and 2011, the Census Bureau published individual
state files that will be utilized automatically by <code>zippeR</code>. If
county-level data are requested for these years, the state-specific file
will be used as a base before identifying ZCTAs within counties using
either the <code>"intersect"</code> or <code>"centroid"</code> method described above.
</p>


<h3>Value</h3>

<p>A <code>sf</code> object with ZCTAs matching the parameters specified above:
either a nationwide file, a specific state or states, or a specific
county or counties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # five-digit ZCTAs
  ## download all ZCTAs for 2020 including territories
  zi_get_geometry(year = 2020, territory = c("AS", "GU", "MP", "PR", "VI"),
      shift_geo = TRUE)

  ## download all ZCTAs for 2020 excluding territories
  zi_get_geometry(year = 2020, shift_geo = TRUE)

  ## download all ZCTAs in a selection of states, intersects method
  zi_get_geometry(year = 2020, state = c("IA", "IL", "MO"), method = "intersect")

  ## download all ZCTAs in a single county - St. Louis City, MO
  zi_get_geometry(year = 2020, state = "MO", county = "29510",
      method = "intersect")

  # three-digit ZCTAs
  ## download all ZCTAs for 2018 including territories
  zi_get_geometry(year = 2018, territory = c("AS", "GU", "MP", "PR", "VI"),
      shift_geo = TRUE)


</code></pre>

<hr>
<h2 id='zi_label'>Label ZIP Codes with Contextual Data</h2><span id='topic+zi_label'></span>

<h3>Description</h3>

<p>This function appends information about the city (for five-digit
ZIP Codes) or area (for three-digit ZIP Codes) to a data frame containing
these values. State is returned for both types of ZIP Codes. The function
also optionally returns data on Sectional Center Facilities (SCFs) for
three-digit ZIP Codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_label(.data, input_var, label_source = "UDS", source_var,
    type = "zip5", include_scf = FALSE, vintage = 2022)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_label_+3A_.data">.data</code></td>
<td>
<p>An &quot;input object&quot; that is data.frame or tibble that contains
ZIP Codes to be crosswalked.</p>
</td></tr>
<tr><td><code id="zi_label_+3A_input_var">input_var</code></td>
<td>
<p>The column in the input data that contains five-digit ZIP
Codes. If the input is numeric, it will be transformed to character data
and leading zeros will be added.</p>
</td></tr>
<tr><td><code id="zi_label_+3A_label_source">label_source</code></td>
<td>
<p>Required character scalar or data frame; specifies the
source of the label data. This could be either <code>'UDS'</code> (default) or
<code>'USPS'</code>, or a data frame containing a custom dictionary.</p>
</td></tr>
<tr><td><code id="zi_label_+3A_source_var">source_var</code></td>
<td>
<p>Character scalar, required when <code>label_source</code> is a
data frame containing a custom dictionary; specifies the column name in
the dictionary object that contains ZIP Codes.</p>
</td></tr>
<tr><td><code id="zi_label_+3A_type">type</code></td>
<td>
<p>Character scalar, required when <code>label_source</code> is either
<code>label_source</code> is <code>'UDS'</code> or <code>'USPS'</code>; one of either
<code>'zip3'</code> or <code>'zip5'</code>. The  <code>'zip3'</code> type is only available
from the <code>'USPS'</code> source, while the <code>'zip5'</code> type is available
from <code>'UDS'</code>.</p>
</td></tr>
<tr><td><code id="zi_label_+3A_include_scf">include_scf</code></td>
<td>
<p>A logical scalar required when <code>label_source = 'USPS'</code> and
<code>type = 'zip3'</code>; specifying whether to include the SCF (Sectional
Center Facility) ID in the output. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="zi_label_+3A_vintage">vintage</code></td>
<td>
<p>Character or numeric scalar, required when <code>label_source</code>
is either <code>label_source</code> is <code>'UDS'</code> or <code>'USPS'</code>; specifying
the date for <code>label_source = 'USPS'</code> or the year of the data for
<code>label_source = 'UDS'</code>. The <code>zip_load_labels_list()</code> function
can be used to see available date values for <code>label_source = 'USPS'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Labels are approximations of the actual location of a ZIP Code. For
five-digit ZIP Codes, the city and state may or may not correspond to
an individuals' mailing address city (since multiple cities may be
accepted as valid by USPS for a particular ZIP Code) or state (since ZIP
Codes may cross state lines).
</p>
<p>For three-digit ZIP Codes, the area and state may or may not correspond to
an individuals' mailing address state (since SCFs cover multiple states).
For example, the three digit ZIP Code <code>010</code> covers Western Massachusetts
in practice, but is assigned to the state of Connecticut.
</p>


<h3>Value</h3>

<p>A tibble containing the original data with additional columns from the
selected label data set appended.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create sample data
df &lt;- data.frame(
  id = c(1:3),
  zip5 = c("63005", "63139", "63636"),
  zip3 = c("630", "631", "636")
)

# UDS crosswalk

  zi_label(df, input_var = zip5, label_source = "UDS", vintage = 2022)


# USPS crosswalk

  zi_label(df, input_var = zip3, label_source = "USPS", type = "zip3",
    vintage = 202408)


# custom dictionary
## load sample ZIP3 label data to simulate custom dictionary
mo_label &lt;- zi_mo_usps

## label
zi_label(df, input_var = zip3, label_source = mo_label, source_var = zip3,
  type = "zip3")

</code></pre>

<hr>
<h2 id='zi_list_zctas'>List ZCTA GEOIDs for States</h2><span id='topic+zi_list_zctas'></span>

<h3>Description</h3>

<p>This function returns a vector of GEOIDs that represent ZCTAs
in and around states, depending on the method selected. The two methods
included described in Details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_list_zctas(year, state, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_list_zctas_+3A_year">year</code></td>
<td>
<p>A four-digit numeric scalar for year. <code>zippeR</code> currently
supports data between 2010 and 2021.</p>
</td></tr>
<tr><td><code id="zi_list_zctas_+3A_state">state</code></td>
<td>
<p>A scalar or vector with state abbreviations (e.x. <code>"MO"</code>)
or FIPS codes (e.x. <code>29</code>).</p>
</td></tr>
<tr><td><code id="zi_list_zctas_+3A_method">method</code></td>
<td>
<p>A character scalar - either <code>"intersect"</code> or <code>"centroid"</code>.
See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since ZCTAs cross state lines, two methods are used to create these
vectors. The <code>"intersect"</code> method will return ZCTAs that border
the state selected. In most cases, this will result in more ZCTAs
being returned than are actually within the states(s) named in the
<code>state</code> argument. Conversely, the <code>"centroid"</code> method will
return only ZCTAs whose centroids (geographical centers) lie within the
states named. In most cases, this will return fewer ZCTAs than
actually lie within the state selected. Users will need to review
their data carefully and, when using other <code>zipperR</code> functions,
will likely need to use the <code>include</code> and <code>exclude</code> arguments
to finalize the geographies returned.
</p>


<h3>Value</h3>

<p>A vector of GEOIDs representing ZCTAs in and around the state selected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Missouri ZCTAs, intersect method
## return list
mo_zctas &lt;- zi_list_zctas(year = 2021, state = "MO", method = "intersect")

## preview ZCTAs
mo_zctas[1:10]

# Missouri ZCTAs, centroid method
## return list
mo_zctas &lt;- zi_list_zctas(year = 2021, state = "MO", method = "centroid")

## preview ZCTAs
mo_zctas[1:10]

</code></pre>

<hr>
<h2 id='zi_load_crosswalk'>Load Crosswalk Files</h2><span id='topic+zi_load_crosswalk'></span>

<h3>Description</h3>

<p>Spatial data on USPS ZIP Codes are not published by the U.S.
Postal Service or the U.S. Census Bureau. Instead, ZIP Codes can be
converted to a variety of Census Bureau geographies using crosswalk files.
This function reads in ZIP Code to ZIP Code Tabulation Area (ZCTA) crosswalk
files from the former UDS Mapper project, which was sunset by the American
Academy of Family Physicians in early 2024. It also provides access to the
U.S. Department of Housing and Urban Development's ZIP Code crosswalk files,
which provide similar functionality for converting ZIP Codes to a variety
of geographies including counties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_load_crosswalk(zip_source = "UDS", year, qtr = NULL, target = NULL,
    query = NULL, key = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_load_crosswalk_+3A_zip_source">zip_source</code></td>
<td>
<p>Required character scalar; specifies the source of ZIP Code
crosswalk data. This can be one of either <code>"UDS"</code> (default) or
<code>"HUD"</code>.</p>
</td></tr>
<tr><td><code id="zi_load_crosswalk_+3A_year">year</code></td>
<td>
<p>Required four-digit numeric scalar for year; varies based on source.
For <code>"UDS"</code>, years 2009 through 2023 are available. For <code>"HUD"</code>,
years 2010 through 2024 are available.</p>
</td></tr>
<tr><td><code id="zi_load_crosswalk_+3A_qtr">qtr</code></td>
<td>
<p>Numeric scalar, required when <code>zip_code</code> is <code>"HUD"</code>.
Integer value between 1 and 4, representing the quarter of the year.</p>
</td></tr>
<tr><td><code id="zi_load_crosswalk_+3A_target">target</code></td>
<td>
<p>Character scalar, required when <code>zip_code</code> is <code>"HUD"</code>.
Can be one of <code>"TRACT"</code>, <code>"COUNTY"</code>, <code>"CBSA"</code>,
<code>"CBSADIV"</code>, <code>"CD"</code>, and <code>"COUNTYSUB"</code>.</p>
</td></tr>
<tr><td><code id="zi_load_crosswalk_+3A_query">query</code></td>
<td>
<p>Scalar or vector, required when <code>zip_code</code> is <code>"HUD"</code>.
This can be a five-digit numeric or character ZIP Code, a vector of
ZIP Codes, a two-letter character state abbreviation, or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="zi_load_crosswalk_+3A_key">key</code></td>
<td>
<p>Optional when <code>zip_code</code> is <code>"HUD"</code>. This should be a
character string containing your HUD API key. Alternatively, it can be
stored in your <code>.RProfile</code> as <code>hud_key</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the crosswalk file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # former UDS mapper crosswalks
 zi_load_crosswalk(zip_source = "UDS", year = 2020)


## Not run: 
 # HUD crosswalks
 # you will need to replace INSERT_HUD_KEY with your own key
 ## ZIP Code to CBSA crosswalk for all ZIP Codes
 zi_load_crosswalk(zip_source = "HUD", year = 2023, qtr = 1, target = "CBSA",
     query = "all", key = INSERT_HUD_KEY)

 ## ZIP Code to County crosswalk for all ZIP Codes in Missouri
 zi_load_crosswalk(zip_source = "HUD", year = 2023, qtr = 1, target = "COUNTY",
     query = "MO", key = INSERT_HUD_KEY)

 ## ZIP Code to Tract crosswalk for ZIP Code 63139 in St. Louis City
 zi_load_crosswalk(zip_source = "HUD", year = 2023, qtr = 1, target = "TRACT",
     query = 63139, key = INSERT_HUD_KEY)

## End(Not run)

</code></pre>

<hr>
<h2 id='zi_load_labels'>Load Label Data</h2><span id='topic+zi_load_labels'></span>

<h3>Description</h3>

<p>This function loads a specific label data set that can be used to
label five or three-digit ZIP codes in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_load_labels(source = "UDS", type = "zip5", include_scf = FALSE,
    vintage = 2022)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_load_labels_+3A_source">source</code></td>
<td>
<p>A required character scalar; specifies the source of the label
data. The only supported sources are <code>'UDS'</code> (default) and
<code>'USPS'</code>.</p>
</td></tr>
<tr><td><code id="zi_load_labels_+3A_type">type</code></td>
<td>
<p>A required character scalar; one of either  <code>'zip3'</code> or
<code>'zip5'</code>. The  <code>'zip3'</code> type is only available from the <code>'USPS'</code>
source, while the <code>'zip5'</code> type is available from <code>'UDS'</code>.</p>
</td></tr>
<tr><td><code id="zi_load_labels_+3A_include_scf">include_scf</code></td>
<td>
<p>A logical scalar required when <code>source = 'USPS'</code> and
<code>type = 'zip3'</code>; specifying whether to include the SCF (Sectional
Center Facility) ID in the output. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="zi_load_labels_+3A_vintage">vintage</code></td>
<td>
<p>A required character or numeric scalar; specifying the date
for <code>source = 'USPS'</code> or the year of the data for <code>source = 'UDS'</code>.
The <code>zip_load_labels_list()</code> function can be used to see available
date values for <code>source = 'USPS'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Labels are approximations of the actual location of a ZIP Code. For
five-digit ZIP Codes, the city and state may or may not correspond to
an individuals' mailing address city (since multiple cities may be
accepted as valid by USPS for a particular ZIP Code) or state (since ZIP
Codes may cross state lines).
</p>
<p>For three-digit ZIP Codes, the area and state may or may not correspond to
an individuals' mailing address state (since SCFs cover multiple states).
For example, the three digit ZIP Code <code>010</code> covers Western Massachusetts
in practice, but is assigned to the state of Connecticut.
</p>


<h3>Value</h3>

<p>A tibble with the specified label data for either five or three-digit
ZIP Codes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # zip5 labels via UDS
  zi_load_labels(source = "UDS", type = "zip5", vintage = 2022)

  # zip3 labels via USPS
  zi_load_labels(source = "USPS", type = "zip3", vintage = 202408)


</code></pre>

<hr>
<h2 id='zi_load_labels_list'>Load List of Available Label Data Sets</h2><span id='topic+zi_load_labels_list'></span>

<h3>Description</h3>

<p>This function loads a list of available label data sets that can
be used to label ZIP Codes. Currently, only three-digit ZIP Codes are
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_load_labels_list(type = "zip3")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_load_labels_list_+3A_type">type</code></td>
<td>
<p>A character scalar specifying the type of label data to load. The
only supported type is  <code>'zip3'</code> (three-digit ZIP Codes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing date values that can be used with <code>zi_load_labels</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  zi_load_labels_list(type = "zip3")


</code></pre>

<hr>
<h2 id='zi_mo_hud'>Missouri HUD ZIP Code to County Crosswalk, 2023</h2><span id='topic+zi_mo_hud'></span>

<h3>Description</h3>

<p>A tibble containing the HUD ZIP Code to County Crosswalk file
for Missouri's ZIP Codes in 2023's first quarter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(zi_mo_hud)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1749 rows and 8 variables:
</p>

<dl>
<dt>ZIP</dt><dd><p>five-digit United States Postal Service ZIP Code</p>
</dd>
<dt>GEOID</dt><dd><p>five-digit county FIPS code</p>
</dd>
<dt>RES_RATIO</dt><dd><p>for ZIP Codes that cross county boundaries, the proportion
of the ZIP Code's residential customers in the given county</p>
</dd>
<dt>BUS_RATIO</dt><dd><p>for ZIP Codes that cross county boundaries, the proportion
of the ZIP Code's commercial customers in the given county</p>
</dd>
<dt>OTH_RATIO</dt><dd><p>for ZIP Codes that cross county boundaries, the proportion
of the ZIP Code's other customers in the given county</p>
</dd>
<dt>TOT_RATIO</dt><dd><p>for ZIP Codes that cross county boundaries, the proportion
of the ZIP Code's total customers in the given county</p>
</dd>
<dt>CITY</dt><dd><p>United States Postal Service city name</p>
</dd>
<dt>STATE</dt><dd><p>United States Postal Service state abbreviation</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data included in <code>zi_mo_hud</code> can be replicated with the
following code: <code>zi_load_crosswalk(zip_source = "HUD", year = 2023,
  qtr = 1, target = "COUNTY", query = "MO")</code>. This assumes your HUD API key
is stored in your <code>.Rprofile</code> file as <code>hud_key</code>.
</p>


<h3>Source</h3>

<p>U.S. Department of Housing and Urban Development's ZIP Code crosswalk
files
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::str(zi_mo_hud)
utils::head(zi_mo_hud)

</code></pre>

<hr>
<h2 id='zi_mo_pop'>Total Population and Median Household Income, Missouri ZCTAs 2022</h2><span id='topic+zi_mo_pop'></span>

<h3>Description</h3>

<p>A tibble containing the total population
and median household income estimates from the 2018-2022 5-year
U.S. Census Bureau American Communiy Survey estimates for Missouri
five-digit ZIP Code Tabulation Areas (ZCTAs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(zi_mo_pop)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2664 rows and 4 variables:
</p>

<dl>
<dt>GEOID</dt><dd><p>full GEOID string</p>
</dd>
<dt>variable</dt><dd><p>variable, either <code>B01003_001</code> (total population) or
<code>B19013_001</code> (median household income)</p>
</dd>
<dt>estimate</dt><dd><p>value for associated <code>variable</code></p>
</dd>
<dt>moe</dt><dd><p>margin of error for associated <code>variable</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The data included in <code>zi_mo_pop</code> can be replicated with the
following code: <code>zi_get_demographics(year = 2022,
  variables = c("B01003_001", "B19013_001"), survey = "acs5")</code>.
</p>


<h3>Source</h3>

<p>U.S. Census Bureau American Community Survey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::str(zi_mo_pop)
utils::head(zi_mo_pop)

</code></pre>

<hr>
<h2 id='zi_mo_usps'>Missouri USPS Three-digit ZIP Code Labels, August 2024</h2><span id='topic+zi_mo_usps'></span>

<h3>Description</h3>

<p>A tibble containing the USPS Three-digit ZIP Code labels for
August 2024.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(zi_mo_usps)
</code></pre>


<h3>Format</h3>

<p>A data frame with 37 rows and 3 variables:
</p>

<dl>
<dt>zip3</dt><dd><p>three-digit United States Postal Service ZIP Code</p>
</dd>
<dt>label_area</dt><dd><p>area associated with the three-digit ZIP Code</p>
</dd>
<dt>label_state</dt><dd><p>state associated with the three-digit ZIP Code</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data included in <code>zi_mo_usps</code> can be replicated with the
following code: <code>zi_load_labels(type = "zip3", source = "USPS",
  vintage = 202408)</code>. After downloading the data, subset to
<code>label_state == "MO"</code>.
</p>


<h3>Source</h3>

<p>U.S. Postal Service Facility Access and Shipment Tracking (FAST) Database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::str(zi_mo_usps)
utils::head(zi_mo_usps)

</code></pre>

<hr>
<h2 id='zi_mo_zcta3'>Missouri Three-digit ZCTAs, 2022</h2><span id='topic+zi_mo_zcta3'></span>

<h3>Description</h3>

<p>A simple features data set containing the geometric data
for Missouri's three-digit ZIP Code Tabulation Areas (ZCTAs) for 2022,
derived from the U.S. Census Bureau's 2022 TIGER/Line shapefiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(zi_mo_zcta3)
</code></pre>


<h3>Format</h3>

<p>A data frame with 31 rows and 2 variables:
</p>

<dl>
<dt>ZCTA3</dt><dd><p>three-digit ZCTA value</p>
</dd>
<dt>geometry</dt><dd><p>simple features geometry</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data included in <code>zi_mo_zcta3</code> can be replicated with the
following code: <code>zi_get_geometry(year = 2022, style = "zcta3",
  state = "MO", method = "intersect")</code>.
</p>


<h3>Source</h3>

<p>U.S. Census Bureau's TIGER/Line database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::str(zi_mo_zcta3)
utils::head(zi_mo_zcta3)

</code></pre>

<hr>
<h2 id='zi_prep_hud'>Convert HUD Crosswalk Data to Finalized Crosswalk</h2><span id='topic+zi_prep_hud'></span>

<h3>Description</h3>

<p>The output from <code>zi_load_crosswalk()</code> for HUD data requires
additional processing to be used in the <code>zi_crosswalk()</code> function.
This function prepares the HUD data for use in joins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_prep_hud(.data, by, return_max = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_prep_hud_+3A_.data">.data</code></td>
<td>
<p>The output from <code>zi_load_crosswalk()</code> with HUD data.</p>
</td></tr>
<tr><td><code id="zi_prep_hud_+3A_by">by</code></td>
<td>
<p>Character scalar; the column name to use for identifying the best
match for a given ZIP Code. This could be either <code>"residential"</code>,
<code>"commercial"</code>, or <code>"total"</code>.</p>
</td></tr>
<tr><td><code id="zi_prep_hud_+3A_return_max">return_max</code></td>
<td>
<p>Logical scalar; if <code>TRUE</code> (default), only the county
with the highest proportion of the ZIP Code type will be returned. If the
ZIP Code straddles two states, two records will be returned. If <code>FALSE</code>,
all records for the ZIP Code will be returned. Where a tie exists (i.e.
two counties each contain half of all addresses), the county with the lowest
<code>GEOID</code> value will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble that has been further prepared for use as a crosswalk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load sample crosswalk data
mo_xwalk &lt;- zi_mo_hud

  # the above data can be replicated with the following code:
  # zi_load_crosswalk(zip_source = "HUD", year = 2023, qtr = 1,
  #   target = "COUNTY", query = "MO")

# prep crosswalk
# when a ZIP Code crosses county boundaries, the portion with the largest
# number of residential addresses will be returned
zi_prep_hud(mo_xwalk, by = "residential", return_max = TRUE)

</code></pre>

<hr>
<h2 id='zi_repair'>Repair ZIP Code or ZCTA Vector</h2><span id='topic+zi_repair'></span>

<h3>Description</h3>

<p>This function repairs two of the four conditions identified
in the validation checks with <code>zi_validate()</code>. For the other two
conditions, values are conveted <code>NA</code>. See Details below for the
specific changes made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_repair(x, style = "zcta5")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_repair_+3A_x">x</code></td>
<td>
<p>A vector containing ZIP or ZCTA values to be repaired.</p>
</td></tr>
<tr><td><code id="zi_repair_+3A_style">style</code></td>
<td>
<p>A character scalar - either <code>"zcta5"</code> or <code>"zcta3"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>zi_repair()</code> function addresses four conditions:
</p>

<ul>
<li><p>If the input vector is numeric, it will be converted to character data.
</p>
</li>
<li><p>If there are values less than five characters (if <code>style = "zcta5"</code>,
the default), or three characters (if <code>style = "zcta3"</code>), they will
be padded with leading zeros.
</p>
</li>
<li><p>If there are input values over five characters (if <code>style = "zcta5"</code>,
the default), or three characters (if <code>style = "zcta3"</code>), they will
be converted to <code>NA</code>.
</p>
</li>
<li><p>If there are input values that have non-numeric characters, they will
be converted to <code>NA</code>.
</p>
</li></ul>

<p>Since two of the four steps will result in <code>NA</code> values, it is strongly
recommended to attempt to manually fix these issues first.
</p>


<h3>Value</h3>

<p>A repaired vector of ZIP or ZCTA values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample five-digit ZIPs with character
zips &lt;- c("63088", "63108", "zip")

# failed validation
zi_validate(zips)

# repair
zips &lt;- zi_repair(zips)

# successful validation
zi_validate(zips)

</code></pre>

<hr>
<h2 id='zi_validate'>Validate ZIP Code or ZCTA Vector</h2><span id='topic+zi_validate'></span>

<h3>Description</h3>

<p>This function validates vectors of ZIP Code or ZCTA values. It
is used internally throughout <code>zippeR</code> for data validation, but
is exported to facilitate troubleshooting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_validate(x, style = "zcta5", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zi_validate_+3A_x">x</code></td>
<td>
<p>A vector containing ZIP or ZCTA values to be validated.</p>
</td></tr>
<tr><td><code id="zi_validate_+3A_style">style</code></td>
<td>
<p>A character scalar - either <code>"zcta5"</code> (default) or
<code>"zcta3"</code>.</p>
</td></tr>
<tr><td><code id="zi_validate_+3A_verbose">verbose</code></td>
<td>
<p>A logical scalar; if <code>FALSE</code> (default), an overall
evaluation will be returned. If <code>TRUE</code>, a <code>tibble</code> object
listing validation criteria and results will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>zi_validate()</code> function checks for four conditions:
</p>

<ul>
<li><p>Is the input vector character data? This is important because of USPS's
use of leading zeros in ZIP codes and ZCTAs.
</p>
</li>
<li><p>Are all values five characters (if <code>style = "zcta5"</code>, the default),
or three characters (if <code>style = "zcta3"</code>)?
</p>
</li>
<li><p>Are any input values over five characters (if <code>style = "zcta5"</code>,
the default), or three characters (if <code>style = "zcta3"</code>)?
</p>
</li>
<li><p>Do any input values have non-numeric characters?
</p>
</li></ul>

<p>The questions provide a basis for repairing issues identified with
<code>zi_repair()</code>.
</p>


<h3>Value</h3>

<p>Either a logical value (if <code>verbose = FALSE</code>) or a <code>tibble</code>
containing validation criteria and results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample five-digit ZIPs
zips &lt;- c("63088", "63108", "63139")

# successful validation
zi_validate(zips)

# sample five-digit ZIPs in data frame
zips &lt;- data.frame(id = c(1:3), ZIP = c("63139", "63108", "00501"), stringsAsFactors = FALSE)

# successful validation
zi_validate(zips$ZIP)

# sample five-digit ZIPs with character
zips &lt;- c("63088", "63108", "zip")

# failed validation
zi_validate(zips)
zi_validate(zips, verbose = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
