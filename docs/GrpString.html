<!DOCTYPE html><html><head><title>Help for package GrpString</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GrpString}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CommonPatt'>
<p>Discovers common patterns in a group of strings - simplified version</p></a></li>
<li><a href='#CommonPattern'>
<p>Discovers common patterns in a group of strings - full version</p></a></li>
<li><a href='#DupRm'>
<p>Removes successive duplicates in strings</p></a></li>
<li><a href='#event1s.df'>
<p>Data frame containing event names</p></a></li>
<li><a href='#eventChar.df'>
<p>Event name - character conversion key</p></a></li>
<li><a href='#EveS'>
<p>Converts sequence of event names to a string</p></a></li>
<li><a href='#EveStr'>
<p>Converts sequences of event names to strings - same length</p></a></li>
<li><a href='#EveString'>
<p>Converts sequences of event names to strings - generalized</p></a></li>
<li><a href='#FeaturedPatt'>
<p>Discovers featured patterns in two groups of strings</p></a></li>
<li><a href='#GrpString-package'>
<p>Patterns and Statistical Differences Between Two Groups of Strings</p></a></li>
<li><a href='#HistDif'>
<p>Customizes the positions of legend and p value in a histogram</p></a></li>
<li><a href='#p1_20up'>
<p>Patterns from string group 1</p></a></li>
<li><a href='#p2_25up'>
<p>Patterns from string group 2</p></a></li>
<li><a href='#PatternInfo'>
<p>Discovers pattern information in one group of strings</p></a></li>
<li><a href='#str1'>
<p>String group 1</p></a></li>
<li><a href='#str2'>
<p>String group 2</p></a></li>
<li><a href='#StrDif'>
<p>Statistically compares the difference between two groups of strings</p></a></li>
<li><a href='#StrHclust'>
<p>Hierarchical cluster of a group of strings</p></a></li>
<li><a href='#StrKclust'>
<p>K-means clustering of a group of strings</p></a></li>
<li><a href='#TransEntro'>
<p>Transition entropy of a group of strings</p></a></li>
<li><a href='#TransEntropy'>
<p>Transition entropy of each string in a group</p></a></li>
<li><a href='#TransInfo'>
<p>Transitions in one group of strings</p></a></li>
<li><a href='#TransMx'>
<p>Transition matrices in one group of strings</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Patterns and Statistical Differences Between Two Groups of
Strings</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-08-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Hui Tang, Norbert J. Pienta</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hui (Tom) Tang &lt;htang2013@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods include converting series of event names to strings, finding common patterns
    in a group of strings, discovering featured patterns when comparing two groups of strings as well
    as the number and starting position of each pattern in each string, obtaining transition matrix, 
    computing transition entropy, statistically comparing the difference between two groups of strings,
    and clustering string groups. Event names can be any action names or labels such as events in log
    files or areas of interest (AOIs) in eye tracking research.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, plyr, Rcpp, cluster, graphics, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-08-15 20:43:01 UTC; huitang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-08-15 21:54:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='CommonPatt'>
Discovers common patterns in a group of strings - simplified version
</h2><span id='topic+CommonPatt'></span>

<h3>Description</h3>

<p>CommonPatt finds common patterns shared by a group of strings.
</p>
<p>A common pattern is defined as a substring with the minimum length of three
that occurs at least twice among a group of strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CommonPatt(strings.vec, low = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CommonPatt_+3A_strings.vec">strings.vec</code></td>
<td>

<p>String Vector.
</p>
</td></tr>
<tr><td><code id="CommonPatt_+3A_low">low</code></td>
<td>

<p>Cutoff. It is the minimum percentage of the occurrence of patterns that the user specifies.
The default value is 10.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'low' ranges from 0 to 100 in percentage.
</p>


<h3>Value</h3>

<p>The function returns a data frame containing patterns, lengths and percentages of patterns.
</p>
<p>row name - The initial order of substrings, which can be ignored.
</p>
<p>Column 1 - Pattern: common pattern.
</p>
<p>Column 2 - Freq_grp: the overall frequency (times of occurrence) of each pattern.
</p>
<p>Column 3 - Percent_grp: the ratio of Freq_grp to the number of original strings, in percent. 
</p>
<p>Column 4 - Length: the length (i.e., number of characters) of pattern.
</p>
<p>Column 5 - Freq_str: similar to Freq_grp; but each pattern is counted only once in a string even if the string contains that pattern multiple times.
</p>
<p>Column 6 - Percent_str: similar to Percent; but each pattern is counted only once in a string if this string contains the pattern.
</p>
<p>Data is sorted by Length, then Freq_grp, in decreasing order.
</p>


<h3>References</h3>

<p>1. H. Tang; E. Day; L. Kendhammer; J. N. Moore; S. A. Brown; N. J. Pienta. (2016). Eye movement patterns in solving science ordering problems. Journal of eye movement research, 9(3), 1-13.
</p>
<p>2. J. J. Topczewski; A. M. Topczewski; H. Tang; L. Kendhammer; N. J. Pienta.(2017). NMR Spectra through the eyes of a student: eye tracking applied to NMR items. Journal of chemical education, 94(1), 29-37.
</p>
<p>3. J. M. West; A. H. Haake; E. P. Rozanksi; K. S. Karn. (2006). EyePatterns: Software for identifying patterns and similarities across fixation sequences. In Proceedings of the Symposium on Eye-tracking Research &amp; Applications, ACM Press, New York, 149-154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CommonPattern">CommonPattern</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple strings, non-default cutoff
strs.vec &lt;- c("ABCDdefABCDa", "def123DC", "123aABCD", "ACD13", "AC1ABC", "3123fe")
CommonPatt(strs.vec, low = 30)
</code></pre>

<hr>
<h2 id='CommonPattern'>
Discovers common patterns in a group of strings - full version
</h2><span id='topic+CommonPattern'></span>

<h3>Description</h3>

<p>CommonPattern finds common patterns shared by a group of strings.
</p>
<p>It is the extended version of CommonPatt and the users have more options.
</p>
<p>A common pattern is defined as a substring with the minimum length of three
that occurs at least twice among a group of strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CommonPattern(strings.vec, low = 5, high = 25, interval = 5, eveChar.df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CommonPattern_+3A_strings.vec">strings.vec</code></td>
<td>

<p>String vector.
</p>
</td></tr>
<tr><td><code id="CommonPattern_+3A_low">low</code></td>
<td>

<p>The lowest cutoff. It is the minimum percentage of the occurrence of patterns that the user specifies.
The default value is 5.
</p>
</td></tr>
<tr><td><code id="CommonPattern_+3A_high">high</code></td>
<td>

<p>The highest cutoff, which is the maximum percentage of the occurrence of patterns that the user specifies.
The default value is 25.
</p>
</td></tr>
<tr><td><code id="CommonPattern_+3A_interval">interval</code></td>
<td>

<p>The increment percentage from the lowest to the highest cutoff.
The default value is 5.
</p>
</td></tr>
<tr><td><code id="CommonPattern_+3A_evechar.df">eveChar.df</code></td>
<td>

<p>Data frame that stores the event name - character conversion key (optional).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments 'low', 'high' and 'interval' range from 0 to 100 in percentage.
</p>


<h3>Value</h3>

<p>A set of .txt files are exported into the current directory that contain patterns, lengths, percents of patterns,
and converted event names if eveChar.fle is included. The names of these files are the name of strings.vec appended with
the percentages. In addition, a file with all patterns that occurred at least 2 times is exported. 
</p>
<p>row name - The initial order of substrings, which can be ignored.
</p>
<p>Column 1 - Pattern: common pattern.
</p>
<p>Column 2 - Freq_grp: the overall frequency (times of occurrence) of each pattern.
</p>
<p>Column 3 - Percent_grp: the ratio of Freq_grp to the number of original strings, in percent. 
</p>
<p>Column 4 - Length: the length (i.e., number of characters) of pattern.
</p>
<p>Column 5 - Freq_str: similar to Freq_grp; but each pattern is counted only once in a string even if the string contains that pattern multiple times.
</p>
<p>Column 6 - Percent_str: similar to Percent; but each pattern is counted only once in a string if this string contains the pattern.
</p>
<p>Column 7 - Event_name (optional): sequence of event names converted back from pattern string 
</p>
<p>Data is sorted by Length, then Freq_grp, in decreasing order.
</p>


<h3>Note</h3>

<p>The time to run this function can be relatively long (from seconds to minutes depending on the number and lengths of strings as well as the performance of computers).
</p>


<h3>References</h3>

<p>1. H. Tang; E. Day; L. Kendhammer; J. N. Moore; S. A. Brown; N. J. Pienta. (2016). Eye movement patterns in solving science ordering problems. Journal of eye movement research, 9(3), 1-13.
</p>
<p>2. J. J. Topczewski; A. M. Topczewski; H. Tang; L. Kendhammer; N. J. Pienta.(2017). NMR Spectra through the eyes of a student: eye tracking applied to NMR items. Journal of chemical education, 94(1), 29-37.
</p>
<p>3. J. M. West; A. H. Haake; E. P. Rozanksi; K. S. Karn. (2006). EyePatterns: Software for identifying patterns and similarities across fixation sequences. In Proceedings of the Symposium on Eye-tracking Research &amp; Applications, ACM Press, New York, 149-154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CommonPatt">CommonPatt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple strings
strs.vec &lt;- c("ABCDdefABCDa", "def123DC", "123aABCD", "ACD13", "AC1ABC", "3123fe")
CommonPattern(strs.vec, low = 30, high = 50, interval = 20)

# None-default cutoff values, with conversion back
data(eventChar.df)
data(str1)
s0 &lt;- str1[5:15]
CommonPattern(s0, low = 20, high = 30, interval = 10, eveChar.df = eventChar.df)
</code></pre>

<hr>
<h2 id='DupRm'>
Removes successive duplicates in strings
</h2><span id='topic+DupRm'></span>

<h3>Description</h3>

<p>DupRm removes successive duplicated characters in each string in a group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DupRm(strings.vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DupRm_+3A_strings.vec">strings.vec</code></td>
<td>

<p>String Vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a string vector with successive duplicates been removed.
</p>
<p>That is, each string in the export vector is &quot;collapsed&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple example
dup1 &lt;- "000&lt;&lt;&lt;&lt;&lt;DDDFFF333333qqqqqKKKKK33FFF"
dup3 &lt;- "aaBB111^^~~~555667777000000!!!###$$$$$$&amp;&amp;&amp;(((((***)))))@@@@@&gt;&gt;&gt;&gt;99"
dup13 &lt;- c(dup1, dup3)
DupRm(dup13)

</code></pre>

<hr>
<h2 id='event1s.df'>
Data frame containing event names
</h2><span id='topic+event1s.df'></span>

<h3>Description</h3>

<p>A data frame containing event names, There are 45 rows.
Each row has 26 event names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(event1s.df)</code></pre>


<h3>Format</h3>

<p>A data frame with 45 observations or rows.
</p>


<h3>Note</h3>

<p>The event names are from an eye tracking study.
Thus, each event name is actually an area of interst (AOI). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(event1s.df)

</code></pre>

<hr>
<h2 id='eventChar.df'>
Event name - character conversion key
</h2><span id='topic+eventChar.df'></span>

<h3>Description</h3>

<p>A data frame where each element in column 'event' (event name) corresponds to an element in column 'char' (character), which can be a letter, digit, or a special character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eventChar.df)</code></pre>


<h3>Format</h3>

<p>A data frame with 16 observations on the following 2 variables.
</p>

<dl>
<dt><code>event</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>char</code></dt><dd><p>a character vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(eventChar.df)

</code></pre>

<hr>
<h2 id='EveS'>
Converts sequence of event names to a string
</h2><span id='topic+EveS'></span>

<h3>Description</h3>

<p>EveS converts event names in a vector to a single string based on the conversion key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EveS(eves.vec, eveName.vec, char.vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EveS_+3A_eves.vec">eves.vec</code></td>
<td>

<p>Vector that stores event names to be converted.
</p>
</td></tr>
<tr><td><code id="EveS_+3A_evename.vec">eveName.vec</code></td>
<td>

<p>Event name vector in a conversion key.
</p>
</td></tr>
<tr><td><code id="EveS_+3A_char.vec">char.vec</code></td>
<td>

<p>Character vector in a conversion key.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lengths of eveName.vec and char.vec are the same.
</p>
<p>Each element (event name) in eveName.vec corresponds to an element (character) in char.vec.
</p>
<p>An element in char.vec can be a letter, digit, or a special character.
</p>


<h3>Value</h3>

<p>The function returns a string.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EveStr">EveStr</a></code>, 
<code><a href="#topic+EveString">EveString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>event.vec &lt;- c("aoi_1", "aoi_2", "aoi_3", "aoi_2", "aoi_1")
eve.names &lt;- c("aoi_1", "aoi_2", "aoi_3")
labels &lt;- c("a", "b", "c")
EveS(event.vec, eve.names, labels)

</code></pre>

<hr>
<h2 id='EveStr'>
Converts sequences of event names to strings - same length
</h2><span id='topic+EveStr'></span>

<h3>Description</h3>

<p>EveStr converts event names in a data frame to a string vector.
In the data frame, each row, which has the same number of event names,
is converted to a string based on the conversion key. A string vector is exported.
As a result, in the vector, each converted string has the same length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EveStr(eveName.df, eveName.vec, char.vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EveStr_+3A_evename.df">eveName.df</code></td>
<td>

<p>Data frame that stores event names to be converted.
</p>
</td></tr>
<tr><td><code id="EveStr_+3A_evename.vec">eveName.vec</code></td>
<td>

<p>Event name vector in a conversion key.
</p>
</td></tr>
<tr><td><code id="EveStr_+3A_char.vec">char.vec</code></td>
<td>

<p>Character vector in a conversion key.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lengths of eveName.vec and char.vec are the same.
</p>
<p>Each element (event name) in eveName.vec corresponds to an element (character) in char.vec.
</p>
<p>An element in char.vec can be a letter, digit, or a special character.
</p>


<h3>Value</h3>

<p>The function returns a string vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EveS">EveS</a></code>, 
<code><a href="#topic+EveString">EveString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># small number of event names
event.df &lt;- data.frame(c("aoi_1", "aoi_2"),
                     c("aoi_1", "aoi_3"),
                     c("aoi_3", "aoi_5"))
event.name.vec &lt;- c("aoi_1", "aoi_2", "aoi_3", "aoi_4", "aoi_5")
label.vec &lt;- c("a", "b", "c", "d", "e")
EveStr(event.df, event.name.vec, label.vec)

# more event names
data(event1s.df) 
data(eventChar.df)
EveStr(event1s.df, eventChar.df$event, eventChar.df$char)
</code></pre>

<hr>
<h2 id='EveString'>
Converts sequences of event names to strings - generalized
</h2><span id='topic+EveString'></span>

<h3>Description</h3>

<p>EveString converts event names in a data frame to a string vector.
</p>
<p>In the data frame, each row, which can have different number of 
event names, is converted to a string based on the conversion key. As
a result, in the vector, converted strings may have different lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EveString(eveName.file, eveName.vec, char.vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EveString_+3A_evename.file">eveName.file</code></td>
<td>

<p>File that stores event names to be converted.
</p>
</td></tr>
<tr><td><code id="EveString_+3A_evename.vec">eveName.vec</code></td>
<td>

<p>Vector of event names in a conversion key.
</p>
</td></tr>
<tr><td><code id="EveString_+3A_char.vec">char.vec</code></td>
<td>

<p>Characters vector in a conversion key.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, it is not convenient to deal with data frames where different rows have different
numbers of elements. Thus, it is easier to use a text file than to use a data frame when storing
different numbers of event names in rows. As a result, this function utilizes a .txt or .csv file 
(for eveName.file) and handles such task to save users' effort.
</p>


<h3>Value</h3>

<p>The function returns a vector containing converted strings that generally have different lengths.
</p>
<p>If not all event names are converted to characters, a warning message will be printed out.
</p>


<h3>Note</h3>

<p>eveName.file is the name of a file. Thus quote signs are needed
when a file name (and its directory) is directly used in the function. 
</p>
<p>If the example is used, the eveName.file will be eve1d.txt, which is located in your R library.
The users may copy eve1d.txt to a directory that can be easily found.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EveS">EveS</a></code>, 
<code><a href="#topic+EveStr">EveStr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eventChar.df)
event1d &lt;- paste(path.package("GrpString"), "/extdata/eve1d.txt", sep = "")
EveString(event1d, eventChar.df$event, eventChar.df$char)
</code></pre>

<hr>
<h2 id='FeaturedPatt'>
Discovers featured patterns in two groups of strings
</h2><span id='topic+FeaturedPatt'></span>

<h3>Description</h3>

<p>FeaturedPatt discovers featured patterns that are in one group of strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FeaturedPatt(grp1_pattern, grp2_pattern, grp1_string, grp2_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FeaturedPatt_+3A_grp1_pattern">grp1_pattern</code></td>
<td>

<p>Patterns shared by a certain percent of strings in string group 1.
</p>
</td></tr>
<tr><td><code id="FeaturedPatt_+3A_grp2_pattern">grp2_pattern</code></td>
<td>

<p>Patterns shared by a certain percent of strings in string group 2.
</p>
</td></tr>
<tr><td><code id="FeaturedPatt_+3A_grp1_string">grp1_string</code></td>
<td>

<p>String group 1.
</p>
</td></tr>
<tr><td><code id="FeaturedPatt_+3A_grp2_string">grp2_string</code></td>
<td>

<p>String group 2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A (common) pattern is defined as a substring with the minimum length of three
that occurs at least twice among a group of strings.
</p>
<p>In practice, a pattern usually is not shared by all the strings in a group.
Thus, featured patterns may be obtained from two pattern vectors, each of which contains patterns that are shared by a certain percent of strings in a group.
As a result, featured patterns can possibly appear in both groups of strings,
athough ideally, a featured pattern should only appears in one of the two groups of strings.
</p>


<h3>Value</h3>

<p>The function exports five text files:
</p>
<p>File that lists featured patterns: column 1 for string group 1; column 2 for string group 2.
</p>
<p>Four files that contain information about each group of patterns in each group of strings.
</p>
<p>The information includes the number of each of the patterns in each string and the starting
</p>
<p>positions of the first occurring patterns, as well as the lengths of original strings.
</p>
<p>If a pattern does not appear in a string, -1 is returned.
</p>
<p>In the above four files: the first column contains original strings;
the second column contains the length of strings;
the third column contains the number of featured patterns each string has; 
each of the columns from the fourth is the starting position of a pattern that first appears in a string.
</p>
<p>In addition, messages are printed out for the four situations of each pattern group in each string group.
The messages include the number and the ratio of strings that have at least one featured pattern.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PatternInfo">PatternInfo</a></code>,
<code><a href="#topic+CommonPatt">CommonPatt</a></code>,
<code><a href="#topic+CommonPattern">CommonPattern</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(str1)
data(str2)
data(p1_20up)
data(p2_25up)
FeaturedPatt(p1_20up, p2_25up, str1, str2)
</code></pre>

<hr>
<h2 id='GrpString-package'>
Patterns and Statistical Differences Between Two Groups of Strings
</h2><span id='topic+GrpString-package'></span><span id='topic+GrpString'></span>

<h3>Description</h3>

<p>Methods include converting series of event names to strings, finding common patterns in a group of strings, discovering featured patterns when comparing two groups of strings as well as the number and starting position of each pattern in each string, obtaining transition matrix, computing transition entropy, statistically comparing the difference between two groups of strings, and clustering string groups.
</p>
<p>Event names can be any action names or labels such as events in log files or areas of interest (AOIs) in eye tracking research.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GrpString</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-08-15</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Some functions have two or more types, e.g., one returning a data frame or a vector and the other exporting one or more than one .txt file to the current directory. The former is a simple version of the functions, while the latter can be considered as a generalized or complex version of the former one. This is because some data sets are large (e.g., many rows or columns), or it helps the users to view and manage the results when more than one data set is exported. Example function pairs are EveStr - EveString, CommonPatt - CommonPattern, and PatternInfo - FeaturedPatt.
</p>
<p>In addition, to save the users' effort, the function EveString utilizes an input file (which can be a .txt or .csv file) instead of a data frame. This is because the input data are more convenient to be stored in a .txt or .csv file than in a data frame. We suggest that the users copy the relevant input files (including eve1d.txt and eve1d.csv) to a different directory, because the function exports files to the same directory where the input files locate. 
</p>


<h3>Author(s)</h3>

<p>Hui Tang,
Norbert J. Pienta
</p>
<p>Maintainer: Hui (Tom) Tang &lt;htang2013@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Discover common patterns in a group of strings
strs.vec &lt;- c("ABCDdefABCDa", "def123DC", "123aABCD", "ACD13", "AC1ABC", "3123fe")
CommonPatt(strs.vec, low = 30)
</code></pre>

<hr>
<h2 id='HistDif'>
Customizes the positions of legend and p value in a histogram
</h2><span id='topic+HistDif'></span>

<h3>Description</h3>

<p>The positions of legend and p value in the histogram generated from function StrDif may not be ideal
for different (permutations on differences of normalized Levenshtein distances) situations.
HistDif customizes the positions of legend and p value in the histogram of the statistical difference
of two groups of strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HistDif(dif.vec, obsDif, pvalue, o.x = 0.01, o.y = 0, p.x = 0.015, p.y = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HistDif_+3A_dif.vec">dif.vec</code></td>
<td>

<p>Vector containing differences of normalized Levenshtein differences (LD) from the permutation test.
</p>
</td></tr>
<tr><td><code id="HistDif_+3A_obsdif">obsDif</code></td>
<td>

<p>The &quot;observed&quot; or original difference between between-group and within-group normalized LD.
</p>
</td></tr>
<tr><td><code id="HistDif_+3A_pvalue">pvalue</code></td>
<td>

<p>p value of the permutation test.
</p>
</td></tr>
<tr><td><code id="HistDif_+3A_o.x">o.x</code></td>
<td>

<p>x coordinate of the legend in the histogram, default is 0.01.
</p>
</td></tr>
<tr><td><code id="HistDif_+3A_o.y">o.y</code></td>
<td>

<p>y coordinate of the legend in the histogram, default is 0.
</p>
</td></tr>
<tr><td><code id="HistDif_+3A_p.x">p.x</code></td>
<td>

<p>x coordinate of the p value in the histogram, default is 0.015.
</p>
</td></tr>
<tr><td><code id="HistDif_+3A_p.y">p.y</code></td>
<td>

<p>y coordinate of the p value in the histogram, default is 0.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default values of o.y and p.y are 0. They are actually related to the number of permutations (num_perm):  o.y is above 0.2 * num_perm, 
and p.y is below 0.2 * num_perm. If non-default values are used, the values become absolute y coordinates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+StrDif">StrDif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple example, use the vectors of ld difference values obtained from StrDif
strs1.vec &lt;- c("ABCDdefABCDa", "def123DC", "123aABCD", "ACD13", "AC1ABC", "3123fe")
strs2.vec &lt;- c("xYZdkfAxDa", "ef1563xy", "BC9Dzy35X", "AkeC1fxz", "65CyAdC", "Dfy3f69k")
ld.dif.vec &lt;- StrDif(strs1.vec, strs2.vec, num_perm = 500, p.x = 0.025)
HistDif(dif.vec = ld.dif.vec, obsDif = 0.00751, pvalue = 0.35600, 
        o.x = 0.025, p.x = 0.040, p.y = 75)
</code></pre>

<hr>
<h2 id='p1_20up'>
Patterns from string group 1
</h2><span id='topic+p1_20up'></span>

<h3>Description</h3>

<p>Patterns that occur at least 20 percent compared to the number of strings 
in string group 1. It can be obtained from one of the exported files from
CommonPattern(str1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(p1_20up)</code></pre>


<h3>Format</h3>

<p>The format is:
chr [1:32] &quot;212&quot; &quot;202&quot; &quot;BAB&quot; &quot;D0D&quot; &quot;F0F&quot; &quot;020&quot; &quot;B0B&quot; &quot;010&quot; &quot;404&quot; &quot;C0C&quot; ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(p1_20up)

</code></pre>

<hr>
<h2 id='p2_25up'>
Patterns from string group 2
</h2><span id='topic+p2_25up'></span>

<h3>Description</h3>

<p>Patterns that occur at least 25 percent compared to the number of strings 
in string group 2. It can be obtained from one of the exported files from
CommonPattern(str2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(p2_25up)</code></pre>


<h3>Format</h3>

<p>The format is:
chr [1:32] &quot;0D0D&quot; &quot;0E0E&quot; &quot;E0E0&quot; &quot;D0D&quot; &quot;E0E&quot; &quot;F0F&quot; &quot;B0B&quot; &quot;0C0&quot; &quot;0D0&quot; ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(p2_25up)

</code></pre>

<hr>
<h2 id='PatternInfo'>
Discovers pattern information in one group of strings
</h2><span id='topic+PatternInfo'></span>

<h3>Description</h3>

<p>PatternInfo discovers the starting position of each pattern that occurs first or last
as well as the number of patterns in each string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PatternInfo(patterns, strings, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PatternInfo_+3A_patterns">patterns</code></td>
<td>

<p>Pattern vector.
</p>
</td></tr>
<tr><td><code id="PatternInfo_+3A_strings">strings</code></td>
<td>

<p>String vector.
</p>
</td></tr>
<tr><td><code id="PatternInfo_+3A_rev">rev</code></td>
<td>

<p>Determine whether returning the starting positions of patterns that occur first or last in strings.
Default is first.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame, which contains the length of each string, and the starting position
of each pattern in each string.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FeaturedPatt">FeaturedPatt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple strings and patterns
strs.vec &lt;- c("ABCDdefABCDa", "def123DC", "123aABCD", "ACD13", "AC1ABC", "3123fe")
patts &lt;- c("ABC", "123")
PatternInfo(patts, strs.vec)

# simple strings and patterns, starting position of last pattern
strs.vec &lt;- c("ABCDdefABCDa", "def123DC", "123aABCD", "ACD13", "AC1ABC", "3123fe")
patts &lt;- c("ABC", "123")
PatternInfo(patts, strs.vec, rev = TRUE)
</code></pre>

<hr>
<h2 id='str1'>
String group 1
</h2><span id='topic+str1'></span>

<h3>Description</h3>

<p>A vector containing 45 strings that have different lengths. It also can be 
obtained in the export file from the example in function EveString.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(str1)</code></pre>


<h3>Format</h3>

<p>The format is:
chr [1:45] &quot;D02F0E20DEDC0C30BDC0E45G050A0B5050A06BG0BA5607BA&quot; ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(str1)

</code></pre>

<hr>
<h2 id='str2'>
String group 2
</h2><span id='topic+str2'></span>

<h3>Description</h3>

<p>A vector containing 29 strings that have different lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(str2)</code></pre>


<h3>Format</h3>

<p>The format is:
chr [1:29] &quot;G21A1C14C2D0D21D2123201D23D21234320431212412421AB3EGEGE0E4G4B5G6A&quot; ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(str2)

</code></pre>

<hr>
<h2 id='StrDif'>
Statistically compares the difference between two groups of strings
</h2><span id='topic+StrDif'></span>

<h3>Description</h3>

<p>StrDif tests whether the difference between two groups of strings is statistically significant or not.
The difference is based on normalized Levenshtein distances (LDs) between strings. A permutation test is used 
as the statistical method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StrDif(grp1_string, grp2_string, num_perm = 1000,
       o.x = 0.01, o.y = 0, p.x = 0.015, p.y = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StrDif_+3A_grp1_string">grp1_string</code></td>
<td>

<p>String group (vector) 1.
</p>
</td></tr>
<tr><td><code id="StrDif_+3A_grp2_string">grp2_string</code></td>
<td>

<p>String group  (vector) 2.
</p>
</td></tr>
<tr><td><code id="StrDif_+3A_num_perm">num_perm</code></td>
<td>

<p>Number of permutations. The default is 1000.
</p>
</td></tr>
<tr><td><code id="StrDif_+3A_o.x">o.x</code></td>
<td>

<p>x coordinate of the legend in the histogram, default is 0.01.
</p>
</td></tr>
<tr><td><code id="StrDif_+3A_o.y">o.y</code></td>
<td>

<p>y coordinate of the legend in the histogram, default is 0.
</p>
</td></tr>
<tr><td><code id="StrDif_+3A_p.x">p.x</code></td>
<td>

<p>x coordinate of the p value in the histogram, default is 0.015.
</p>
</td></tr>
<tr><td><code id="StrDif_+3A_p.y">p.y</code></td>
<td>

<p>y coordinate of the legend in the histogram, default is 0.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default values of o.y and p.y are 0. They are actually related to num_perm:  o.y is above 0.2 * num_perm, and p.y is below 0.2 * num_perm. If non-default values are used, the values become absolute y coordinates.
</p>


<h3>Value</h3>

<p>The function generates a histogram that demonstrates the distribution of the differences of LDs, the original difference, and the p value.
</p>
<p>The function also returns a vector containing differences of normalized LDs. 
The total number of differences is num_perm (number of permutations).
</p>
<p>Differences are calculated by subtracting within-group LD from between-group LD. They range from -1 to 1.
The &quot;observed&quot; difference is the difference from the original data set. 
</p>


<h3>Note</h3>

<p>1. Because the number of permutations is usually large (default is 1000), and so
is the number of elements in the vector returned from the function,
it's better for the user to use a vector to store the returned results,
instead of printing out directly. See the examples. 
</p>
<p>2. The positions of legend and p value in the histogram generated from function StrDif may not be ideal
for different (permutations on differences of normalized Levenshtein distances) situations.
Thus, this package includes another function, HistDif, to customize the positions of legend and p value in the histogram.
</p>
<p>3. The time to run this function can be relatively long (from seconds to minutes depending on the number and lengths of strings as well as the computer performance).
</p>
<p>4. Acknowledgement: The first version of this function was developed with significant help from Dr. Rhonda DeCook 
in the Department of Statistics and Actuarial Science at the University of Iowa.
</p>


<h3>References</h3>

<p>1. H. Tang; J. J. Topczewski; A. M. Topczewski; N. J. Pienta.
Permutation Test for Groups of Scanpaths Using Normalized
Levenshtein Distances and Application in NMR Questions. In
Proceedings of the Symposium on Eye Tracking Research and Applications,
Santa Barbara, CA, March 28-30, 2012; ACM Press: New York; pp 169-172.
</p>
<p>2. M. Feusner; B. Lukoff. (2008). Testing for statistically significant differences between groups of scan patterns. 
In Proceedings of the Symposium on Eye-tracking Research &amp; Applications, ACM Press, New York, 43-46.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HistDif">HistDif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple stings, non-default permutation number and p-value position
strs1.vec &lt;- c("ABCDdefABCDa", "def123DC", "123aABCD", "ACD13", "AC1ABC", "3123fe")
strs2.vec &lt;- c("xYZdkfAxDa", "ef1563xy", "BC9Dzy35X", "AkeC1fxz", "65CyAdC", "Dfy3f69k")
ld.dif.vec &lt;- StrDif(strs1.vec, strs2.vec, num_perm = 500, p.x = 0.025)

# longer strings
data(str1)
data(str2)
s1 &lt;- str1[1:6]
s2 &lt;- str2[1:6]
ld.dif12.vec &lt;- StrDif(s1, s2, num_perm = 500)
</code></pre>

<hr>
<h2 id='StrHclust'>
Hierarchical cluster of a group of strings
</h2><span id='topic+StrHclust'></span>

<h3>Description</h3>

<p>StrHclust discovers clusters of the strings in a group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StrHclust(strings.vec, nclust = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StrHclust_+3A_strings.vec">strings.vec</code></td>
<td>

<p>String Vector.
</p>
</td></tr>
<tr><td><code id="StrHclust_+3A_nclust">nclust</code></td>
<td>

<p>Number of clusters. Default is 2.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the specific cluster assigned to each string.
</p>
<p>A Hierarchical dendrogram is also exported.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+StrKclust">StrKclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple strings
strs3.vec &lt;- c("ABCDdefABCDa", "AC3aABCD", "ACD1AB3", "xYZfgAxZY", "gf56xZYx", "AkfxzYZg")
StrHclust(strs3.vec)

</code></pre>

<hr>
<h2 id='StrKclust'>
K-means clustering of a group of strings
</h2><span id='topic+StrKclust'></span>

<h3>Description</h3>

<p>StrKclust discovers clusters of the strings in a group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StrKclust(strings.vec, nclust = 2, nstart = 1, shade = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StrKclust_+3A_strings.vec">strings.vec</code></td>
<td>

<p>String Vector.
</p>
</td></tr>
<tr><td><code id="StrKclust_+3A_nclust">nclust</code></td>
<td>

<p>Number of clusters. Default is 2.
</p>
</td></tr>
<tr><td><code id="StrKclust_+3A_nstart">nstart</code></td>
<td>

<p>Number of random data sets chosen to start. Default is 1.
</p>
</td></tr>
<tr><td><code id="StrKclust_+3A_shade">shade</code></td>
<td>

<p>Whether shade the ellipses in the cluster plot or not. Default is false.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the specific cluster assigned to each string.
</p>
<p>A cluster plot is also exported.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+StrHclust">StrHclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple strings
strs3.vec &lt;- c("ABCDdefABCDa", "AC3aABCD", "ACD1AB3", "xYZfgAxZY", "gf56xZYx", "AkfxzYZg")
StrKclust(strs3.vec)

</code></pre>

<hr>
<h2 id='TransEntro'>
Transition entropy of a group of strings
</h2><span id='topic+TransEntro'></span>

<h3>Description</h3>

<p>TransEntro computes the overall transition entropy of all the strings in a group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransEntro(strings.vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransEntro_+3A_strings.vec">strings.vec</code></td>
<td>

<p>String Vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Entropy is calculated using the Shannon entropy formula: -sum(freqs * log2(freqs)). Here, freqs are transition frequencies, which are the values in the normalized transition matrix exported by function TransMx in this package. The formula is equivalent to the function entropy.empirical in the 'entropy' package when unit is set to log2.
</p>


<h3>Value</h3>

<p>Returns a single number.
</p>


<h3>Note</h3>

<p>Strings with less than 2 characters are not included for computation of entropy.
</p>


<h3>References</h3>

<p>I. Hooge; G. Camps. (2013) Scan path entropy and arrow plots: capturing scanning behavior of multiple observers. Frontiers in Psychology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransEntropy">TransEntropy</a></code>, 
<code><a href="#topic+TransMx">TransMx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple strings
stra.vec &lt;- c("ABCDdefABCDa", "def123DC", "A", "123aABCD", "ACD13", "AC1ABC", "3123fe")
TransEntro(stra.vec)

</code></pre>

<hr>
<h2 id='TransEntropy'>
Transition entropy of each string in a group
</h2><span id='topic+TransEntropy'></span>

<h3>Description</h3>

<p>TransEntropy computes the transition entropy of each of the strings in a group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransEntropy(strings.vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransEntropy_+3A_strings.vec">strings.vec</code></td>
<td>

<p>String Vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Entropy is calculated using the Shannon entropy formula: -sum(freqs * log2(freqs)). Here, freqs are transition frequencies, which are the values in the normalized transition matrix exported by function TransMx in this package. The formula is equivalent to the function entropy.empirical in the 'entropy' package when unit is set to log2.
</p>


<h3>Value</h3>

<p>Returns a number vector.
</p>


<h3>Note</h3>

<p>Strings with less than 2 characters are not included for computation of entropy.
</p>


<h3>References</h3>

<p>I. Hooge; G. Camps. (2013) Scan path entropy and arrow plots: capturing scanning behavior of multiple observers. Frontiers in Psychology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransEntro">TransEntro</a></code>, 
<code><a href="#topic+TransMx">TransMx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># default values
stra.vec &lt;- c("ABCDdefABCDa", "def123DC", "A", "123aABCD", "ACD13", "AC1ABC", "3123fe")
TransEntropy(stra.vec)

</code></pre>

<hr>
<h2 id='TransInfo'>
Transitions in one group of strings
</h2><span id='topic+TransInfo'></span>

<h3>Description</h3>

<p>TransInfo discovers transitions of two adjacent characters in strings.
</p>
<p>A transition is defined as a substring (in the forward order) with length of 2 characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransInfo(strings.vec, type1 = "letters", type2 = "digits")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransInfo_+3A_strings.vec">strings.vec</code></td>
<td>

<p>String Vector.
</p>
</td></tr>
<tr><td><code id="TransInfo_+3A_type1">type1</code></td>
<td>

<p>The first type of transition. Default value is letter.
</p>
</td></tr>
<tr><td><code id="TransInfo_+3A_type2">type2</code></td>
<td>

<p>The second type of transition. Default value is digit.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data frame, which contains the numbers of type1 transition, type2 transition, and transitions
belonging to neither type1 nor type2.
</p>


<h3>Note</h3>

<p>Strings with less than 2 characters are not included due to the definition of transition.
</p>


<h3>References</h3>

<p>1. H. Tang; E. Day; L. Kendhammer; J. N. Moore; S. A. Brown; N. J. Pienta. (2016) Eye movement patterns in solving science ordering problems. Journal of eye movement research, 9(3), 1-13.  
</p>
<p>2. J. J. Topczewski; A. M. Topczewski; H. Tang; L. Kendhammer; N. J. Pienta.(2017) NMR Spectra through the eyes of a student: eye tracking applied to NMR items. Journal of chemical education, 94(1), 29-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransMx">TransMx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># default values
strs.vec &lt;- c("ABCDdefABCDa", "def123DC", "123aABCD", "ACD13", "AC1ABC", "3123fe")
TransInfo(strs.vec)

# non-default values
str1.vec &lt;- c("ABCABEF", "CDCDAB")
TransInfo(str1.vec, type1 = "AB", type2 = "CD")
</code></pre>

<hr>
<h2 id='TransMx'>
Transition matrices in one group of strings
</h2><span id='topic+TransMx'></span>

<h3>Description</h3>

<p>TransMx discovers transition matrix of a string vector and the related information.
</p>
<p>A transition is defined as a substring (in the forward order) with length of 2 characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransMx(strings.vec, indiv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransMx_+3A_strings.vec">strings.vec</code></td>
<td>

<p>String Vector.
</p>
<p>If a string has fewer than 2 characters, that string will be ignored.
</p>
</td></tr>
<tr><td><code id="TransMx_+3A_indiv">indiv</code></td>
<td>

<p>Whether exports transition matrix for each string into the current directory. Default value is FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list, which contains the transition matrix, the normalized matrix, and the sorted numbers of transitions.
</p>
<p>If indiv = TRUE, a set of mx.txt files are exported into the current directory that contain transition matrix for each string. The names of these files are the name of strings.vec appended with the orders of the strings in the string vector. If a string has fewer than 2 characters, the corresponding mx.txt file will be skipped.
</p>


<h3>Note</h3>

<p>Strings with less than 2 characters are not included due to the definition of transition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransInfo">TransInfo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple strings
strs.vec &lt;- c("ABCDdefABCDa", "def123DC", "123aABCD", "ACD13", "AC1ABC", "3123fe")
TransMx(strs.vec)

# simple strings, export an individual transition matrix for each string
strs.vec &lt;- c("ABCDdefABCDa", "def123DC", "123aABCD", "ACD13", "AC1ABC", "3123fe")
TransMx(strs.vec, indiv = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
