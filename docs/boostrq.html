<!DOCTYPE html><html><head><title>Help for package boostrq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {boostrq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+5B.boostrq'><p>Updating number of iterations</p></a></li>
<li><a href='#boostrq'><p>Fitting a boosting regression quantiles model</p></a></li>
<li><a href='#brq'><p>base learner for boosting linear regression quantiles</p></a></li>
<li><a href='#coef.boostrq'><p>estimated coefficients of boosting regression quantiles</p></a></li>
<li><a href='#cvrisk.boostrq'><p>Crossvalidation for boostrq</p></a></li>
<li><a href='#fitted.boostrq'><p>fitted values of boosting regression quantiles</p></a></li>
<li><a href='#mstop.boostrq'><p>Current number of iterations of boostrq</p></a></li>
<li><a href='#predict.boostrq'><p>Model predictions for boosting regression quantiles</p></a></li>
<li><a href='#print.boostrq'><p>printing boosting regression quantiles</p></a></li>
<li><a href='#print.summary.boostrq'><p>Print result summaries for a boostrq object</p></a></li>
<li><a href='#residuals.boostrq'><p>residuals of boosting regression quantiles</p></a></li>
<li><a href='#risk.boostrq'><p>Empirical Quantile Risk of boostrq Object</p></a></li>
<li><a href='#selected.boostrq'><p>Extract indices of selected base learners</p></a></li>
<li><a href='#stabsel.boostrq'><p>Stability Selection for boosting regression quantiles</p></a></li>
<li><a href='#summary.boostrq'><p>Result summaries for a boostrq object</p></a></li>
<li><a href='#update.boostrq'><p>Update and Re-fit a boostrq model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Boosting Regression Quantiles</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Boosting Regression Quantiles is a component-wise boosting algorithm, 
             that embeds all boosting steps in the well-established framework 
             of quantile regression. It is initialized with the corresponding quantile, 
             uses a quantile-specific learning rate, and uses quantile regression as its base learner.
             The package implements this algorithm and allows cross-validation and stability selection. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stefanlinner/boostrq">https://github.com/stefanlinner/boostrq</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stefanlinner/boostrq/issues">https://github.com/stefanlinner/boostrq/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>mboost, stabs, stats, parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>quantreg, checkmate</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-02 08:53:32 UTC; stefa</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Linner [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Linner &lt;stefan.linner97@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 11:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.boostrq'>Updating number of iterations</h2><span id='topic++5B.boostrq'></span>

<h3>Description</h3>

<p>Updating number of iterations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
x[i, return = TRUE, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.boostrq_+3A_x">x</code></td>
<td>
<p>a boostrq object</p>
</td></tr>
<tr><td><code id="+2B5B.boostrq_+3A_i">i</code></td>
<td>
<p>desired number of boosting iterations</p>
</td></tr>
<tr><td><code id="+2B5B.boostrq_+3A_return">return</code></td>
<td>
<p>TRUE, if the result should be returned</p>
</td></tr>
<tr><td><code id="+2B5B.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boostrq object with the updated number of iterations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

boosted.rq[500]

</code></pre>

<hr>
<h2 id='boostrq'>Fitting a boosting regression quantiles model</h2><span id='topic+boostrq'></span>

<h3>Description</h3>

<p>Component-wise functional gradient boosting algorithm to fit a quantile
regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boostrq(
  formula,
  data,
  mstop = 100,
  nu = NULL,
  tau = 0.5,
  offset = NULL,
  weights = NULL,
  oobweights = NULL,
  risk = "inbag",
  digits = 10,
  exact.fit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boostrq_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="boostrq_+3A_data">data</code></td>
<td>
<p>a data frame (or data.table) containing the variables stated in the formula.</p>
</td></tr>
<tr><td><code id="boostrq_+3A_mstop">mstop</code></td>
<td>
<p>number of iterations, as integer</p>
</td></tr>
<tr><td><code id="boostrq_+3A_nu">nu</code></td>
<td>
<p>learning rate, as numeric</p>
</td></tr>
<tr><td><code id="boostrq_+3A_tau">tau</code></td>
<td>
<p>quantile parameter, as numeric</p>
</td></tr>
<tr><td><code id="boostrq_+3A_offset">offset</code></td>
<td>
<p>a numeric vector used as offset.</p>
</td></tr>
<tr><td><code id="boostrq_+3A_weights">weights</code></td>
<td>
<p>(optional) a numeric vector indicating which weights to used in the fitting process
(default: all observations are equally weighted, with 1).</p>
</td></tr>
<tr><td><code id="boostrq_+3A_oobweights">oobweights</code></td>
<td>
<p>an additional vector of out-of-bag weights, which is used for the out-of-bag risk.</p>
</td></tr>
<tr><td><code id="boostrq_+3A_risk">risk</code></td>
<td>
<p>string indicating how the empirical risk should be computed for each boosting iteration.
inbag leads to risks computed for the learning sample (i.e. observations with non-zero weights),
oobag to risks based on the out-of-bag (i.e. observations with non-zero oobagweights).</p>
</td></tr>
<tr><td><code id="boostrq_+3A_digits">digits</code></td>
<td>
<p>number of digits the slope parameter different from zero to be
considered the best-fitting component, as integer.</p>
</td></tr>
<tr><td><code id="boostrq_+3A_exact.fit">exact.fit</code></td>
<td>
<p>logical, if set to TRUE the negative gradients of exact fits are set to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (generalized) additive quantile regression model is fitted using
the boosting regression quantiles algorithm, which is a functional component-wise
boosting algorithm.
The base-learner can be specified via the formula object. brq (linear quantile regression)
and brqss(nonlinear quantile regression) are available base-learner.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

boosted.rq$mstop()

boosted.rq$selection.freqs()

boosted.rq$coef()

boosted.rq$risk()

</code></pre>

<hr>
<h2 id='brq'>base learner for boosting linear regression quantiles</h2><span id='topic+brq'></span>

<h3>Description</h3>

<p>Base-learner for linear quantile regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brq(formula, method = "fn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brq_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the base learner.</p>
</td></tr>
<tr><td><code id="brq_+3A_method">method</code></td>
<td>
<p>the algortihm used to fit the quantile regression, the default
is set to &quot;fn&quot;, referring to the Frisch-Newton inferior point method.
For more details see the documentation of quantreg::rq.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>brq returns a string, which is used to specifiy the formula in the fitting process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>brq(cyl * hp)
</code></pre>

<hr>
<h2 id='coef.boostrq'>estimated coefficients of boosting regression quantiles</h2><span id='topic+coef.boostrq'></span>

<h3>Description</h3>

<p>estimated coefficients of boosting regression quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
coef(object, which = NULL, aggregate = "sum", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.boostrq_+3A_object">object</code></td>
<td>
<p>object of class boostrq</p>
</td></tr>
<tr><td><code id="coef.boostrq_+3A_which">which</code></td>
<td>
<p>a subset of base-learners</p>
</td></tr>
<tr><td><code id="coef.boostrq_+3A_aggregate">aggregate</code></td>
<td>
<p>a character specifying how to aggregate coefficients of
single base learners. The default returns the coefficient for the final number
of boosting iterations. &quot;cumsum&quot; returns a list with matrices (one per base-learner)
with the cumulative coefficients for all iterations. &quot;none&quot; returns a list of
matrices where the jth columns of the respective matrix contains coefficients
of the base-learner of the jth boosting iteration.v &quot;sum_aggr&quot; ...</p>
</td></tr>
<tr><td><code id="coef.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coef extracts the regression coefficients of the fitted boostrq model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

coef(boosted.rq, aggregate = "cumsum")

</code></pre>

<hr>
<h2 id='cvrisk.boostrq'>Crossvalidation for boostrq</h2><span id='topic+cvrisk.boostrq'></span>

<h3>Description</h3>

<p>Crossvalidation for boostrq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
cvrisk(
  object,
  folds = mboost::cv(object$weights, type = "kfold"),
  grid = 0:mstop(object),
  papply = parallel::mclapply,
  mc.preschedule = FALSE,
  fun = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvrisk.boostrq_+3A_object">object</code></td>
<td>
<p>a boostrq object</p>
</td></tr>
<tr><td><code id="cvrisk.boostrq_+3A_folds">folds</code></td>
<td>
<p>a matrix indicating the weights for the k resampling iterations</p>
</td></tr>
<tr><td><code id="cvrisk.boostrq_+3A_grid">grid</code></td>
<td>
<p>a vetor of stopping parameters the empirical quantile risk is to be evaluated for.</p>
</td></tr>
<tr><td><code id="cvrisk.boostrq_+3A_papply">papply</code></td>
<td>
<p>(parallel) apply function, defaults to mclapply. To run sequentially
(i.e. not in parallel), one can use lapply.</p>
</td></tr>
<tr><td><code id="cvrisk.boostrq_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>preschedule tasks if are parallelized using mclapply (default: FALSE)?
For details see mclapply.</p>
</td></tr>
<tr><td><code id="cvrisk.boostrq_+3A_fun">fun</code></td>
<td>
<p>if fun is NULL, the out-of-sample risk is returned. fun, as a function of object, may
extract any other characteristic of the cross-validated models. These are returned as is.</p>
</td></tr>
<tr><td><code id="cvrisk.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cross-validated Boosting regression quantiles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

set.seed(101)

cvk.out &lt;-
cvrisk(
 boosted.rq,
 grid = 0:mstop(boosted.rq),
 folds = mboost::cv(boosted.rq$weights, type = "kfold", B = 5)
)

cvk.out

plot(cvk.out)

mstop(cvk.out)

boosted.rq[mstop(cvk.out)]

</code></pre>

<hr>
<h2 id='fitted.boostrq'>fitted values of boosting regression quantiles</h2><span id='topic+fitted.boostrq'></span>

<h3>Description</h3>

<p>fitted values of boosting regression quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.boostrq_+3A_object">object</code></td>
<td>
<p>object of class boostrq</p>
</td></tr>
<tr><td><code id="fitted.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted returns the fitted values of the fitted boostrq model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

fitted(boosted.rq)

</code></pre>

<hr>
<h2 id='mstop.boostrq'>Current number of iterations of boostrq</h2><span id='topic+mstop.boostrq'></span>

<h3>Description</h3>

<p>Current number of iterations of boostrq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
mstop(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstop.boostrq_+3A_object">object</code></td>
<td>
<p>a boostrq object</p>
</td></tr>
<tr><td><code id="mstop.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>current number of boosting iterations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

mstop(boosted.rq)

</code></pre>

<hr>
<h2 id='predict.boostrq'>Model predictions for boosting regression quantiles</h2><span id='topic+predict.boostrq'></span>

<h3>Description</h3>

<p>Model predictions for boosting regression quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
predict(object, newdata = NULL, which = NULL, aggregate = "sum", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.boostrq_+3A_object">object</code></td>
<td>
<p>a boostrq object</p>
</td></tr>
<tr><td><code id="predict.boostrq_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame (or data.table) including all covariates contained in the
baselearners</p>
</td></tr>
<tr><td><code id="predict.boostrq_+3A_which">which</code></td>
<td>
<p>a subset of base-learners</p>
</td></tr>
<tr><td><code id="predict.boostrq_+3A_aggregate">aggregate</code></td>
<td>
<p>a character specifying how to aggregate coefficients of
single base learners. The default returns the coefficient for the final number
of boosting iterations. &quot;cumsum&quot; returns a list with matrices (one per base-learner)
with the cumulative coefficients for all iterations. &quot;none&quot; returns a list of
matrices where the jth columns of the respective matrix contains coefficients
of the base-learner of the jth boosting iteration.</p>
</td></tr>
<tr><td><code id="predict.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predictions for the new data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

predict.data &lt;- data.frame(hp = 165, cyl = 6, am = 1, wt = 3.125)

predict(boosted.rq, newdata = predict.data)

</code></pre>

<hr>
<h2 id='print.boostrq'>printing boosting regression quantiles</h2><span id='topic+print.boostrq'></span>

<h3>Description</h3>

<p>printing boosting regression quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.boostrq_+3A_x">x</code></td>
<td>
<p>object of class boostrq</p>
</td></tr>
<tr><td><code id="print.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>print shows a dense representation of the boostrq model fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

boosted.rq

</code></pre>

<hr>
<h2 id='print.summary.boostrq'>Print result summaries for a boostrq object</h2><span id='topic+print.summary.boostrq'></span>

<h3>Description</h3>

<p>Print result summaries for a boostrq object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.boostrq'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.boostrq_+3A_x">x</code></td>
<td>
<p>a summary.boostrq object</p>
</td></tr>
<tr><td><code id="print.summary.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>printing the result summaries for a boostrq object including the print-information,
estimated coefficients, and selection frequencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

summary(boosted.rq)

</code></pre>

<hr>
<h2 id='residuals.boostrq'>residuals of boosting regression quantiles</h2><span id='topic+residuals.boostrq'></span>

<h3>Description</h3>

<p>residuals of boosting regression quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.boostrq_+3A_object">object</code></td>
<td>
<p>object of class boostrq</p>
</td></tr>
<tr><td><code id="residuals.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>residuals returns the residuals of the fitted boostrq model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

residuals(boosted.rq)

</code></pre>

<hr>
<h2 id='risk.boostrq'>Empirical Quantile Risk of boostrq Object</h2><span id='topic+risk.boostrq'></span>

<h3>Description</h3>

<p>Empirical Quantile Risk of boostrq Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
risk(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="risk.boostrq_+3A_object">object</code></td>
<td>
<p>a boostrq object</p>
</td></tr>
<tr><td><code id="risk.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector containing the respective empirical quantile risk of the
different boosting iterations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

risk(boosted.rq)

</code></pre>

<hr>
<h2 id='selected.boostrq'>Extract indices of selected base learners</h2><span id='topic+selected.boostrq'></span>

<h3>Description</h3>

<p>Extract indices of selected base learners
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
selected(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selected.boostrq_+3A_object">object</code></td>
<td>
<p>a boostrq object</p>
</td></tr>
<tr><td><code id="selected.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an index vector indicating the selected base learner in each iteration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

selected(boosted.rq)

</code></pre>

<hr>
<h2 id='stabsel.boostrq'>Stability Selection for boosting regression quantiles</h2><span id='topic+stabsel.boostrq'></span>

<h3>Description</h3>

<p>Stability Selection for boosting regression quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
stabsel(
  x,
  cutoff,
  q,
  PFER,
  grid = 0:mstop(x),
  folds = stabs::subsample(x$weights, B = B),
  B = ifelse(sampling.type == "MB", 100, 50),
  assumption = "unimodal",
  sampling.type = "SS",
  papply = parallel::mclapply,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabsel.boostrq_+3A_x">x</code></td>
<td>
<p>a fitted model of class &quot;boostrq&quot;</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_cutoff">cutoff</code></td>
<td>
<p>cutoff between 0.5 and 1. Preferably a value between 0.6 and 0.9 should be used</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_q">q</code></td>
<td>
<p>number of (unique) selected componenents (base-learners) that are selected in each subsample.</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_pfer">PFER</code></td>
<td>
<p>upper bound for the per-family error rate. This specifies the amount of falsely selected
base-learners, which is tolerated.</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_grid">grid</code></td>
<td>
<p>a numeric vector of the form 0:m.</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_folds">folds</code></td>
<td>
<p>a weight matrix with number of rows equal to the number of observations. Usually one should
not change the default here as subsampling with a fraction of 1/2 is needed for the error bounds to hold.</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_b">B</code></td>
<td>
<p>umber of subsampling replicates. Per default, we use 50 complementary pairs for the
error bounds of Shah &amp; Samworth (2013) and 100 for the error bound derived in
Meinshausen &amp; Buehlmann (2010). As we use B complementray pairs in the former
case this leads to 2B subsamples.</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_assumption">assumption</code></td>
<td>
<p>Defines the type of assumptions on the distributions of the selection probabilities
and simultaneous selection probabilities. Only applicable for sampling.type = &quot;SS&quot;. For
sampling.type = &quot;MB&quot; we always use code&quot;none&quot;.</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_sampling.type">sampling.type</code></td>
<td>
<p>use sampling scheme of of Shah &amp; Samworth (2013), i.e., with complementarty pairs
(sampling.type = &quot;SS&quot;), or the original sampling scheme of Meinshausen &amp; Buehlmann (2010).</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_papply">papply</code></td>
<td>
<p>(parallel) apply function, defaults to mclapply. To run sequentially
(i.e. not in parallel), one can use lapply.</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_verbose">verbose</code></td>
<td>
<p>logical (default: TRUE) that determines wether warnings should be issued.</p>
</td></tr>
<tr><td><code id="stabsel.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class stabsel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl) + brq(hp) + brq(am) + brq(wt) + brq(drat),
 data = mtcars,
 mstop = 600,
 nu = 0.1,
 tau = 0.5
)

stabsel_parameters(
 q = 3,
 PFER = 1,
 p = 5,
 sampling.type = "SS",
 assumption = "unimodal"
)


set.seed(100)
brq.stabs &lt;-
stabsel(
 x = boosted.rq,
 q = 3,
 PFER = 1,
 sampling.type = "SS",
 assumption = "unimodal"
)

brq.stabs


</code></pre>

<hr>
<h2 id='summary.boostrq'>Result summaries for a boostrq object</h2><span id='topic+summary.boostrq'></span>

<h3>Description</h3>

<p>Result summaries for a boostrq object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.boostrq_+3A_object">object</code></td>
<td>
<p>a boostrq object</p>
</td></tr>
<tr><td><code id="summary.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result summaries for a boostrq object including the print-information,
estimated coefficients, and selection frequencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

summary(boosted.rq)

</code></pre>

<hr>
<h2 id='update.boostrq'>Update and Re-fit a boostrq model</h2><span id='topic+update.boostrq'></span>

<h3>Description</h3>

<p>Update and Re-fit a boostrq model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostrq'
update(object, weights, oobweights, risk, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.boostrq_+3A_object">object</code></td>
<td>
<p>a boostrq object</p>
</td></tr>
<tr><td><code id="update.boostrq_+3A_weights">weights</code></td>
<td>
<p>(optional) a numeric vector indicating which weights to used in the fitting process
(default: all observations are equally weighted, with 1).</p>
</td></tr>
<tr><td><code id="update.boostrq_+3A_oobweights">oobweights</code></td>
<td>
<p>an additional vector of out-of-bag weights, which is used for the out-of-bag risk.</p>
</td></tr>
<tr><td><code id="update.boostrq_+3A_risk">risk</code></td>
<td>
<p>string indicating how the empirical risk should be computed for each boosting iteration.
inbag leads to risks computed for the learning sample (i.e. observations with non-zero weights),
oobag to risks based on the out-of-bag (i.e. observations with non-zero oobagweights).</p>
</td></tr>
<tr><td><code id="update.boostrq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to callies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a re-fitted boostrq model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boosted.rq &lt;-
boostrq(
 formula = mpg ~ brq(cyl * hp) + brq(am + wt),
 data = mtcars,
 mstop = 200,
 nu = 0.1,
 tau = 0.5
)

update(
boosted.rq,
weights = c(rep(1, 30), 0, 0),
oobweights = c(rep(0, 30), 1,1),
risk = "oobag"
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
