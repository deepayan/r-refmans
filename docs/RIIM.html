<!DOCTYPE html><html lang="en"><head><title>Help for package RIIM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RIIM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#conditional_p'><p>The function for calculating the post-matching treatment assignment probabilities</p></a></li>
<li><a href='#IPPW'><p>Randomization-based inference using inverse post-matching probability weighting (IPPW)</p></a></li>
<li><a href='#IPPW_IV'><p>The bias-corrected Wald estimator for the complier average treatment effect</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Randomization-Based Inference Under Inexact Matching</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Randomization-based inference for average treatment effects in potentially inexactly matched observational studies. It implements the inverse post-matching probability weighting framework proposed by the authors. The post-matching probability calculation follows the approach of Pimentel and Huang (2024) &lt;<a href="https://doi.org/10.1093%2Fjrsssb%2Fqkae033">doi:10.1093/jrsssb/qkae033</a>&gt;. The optimal full matching method is based on Hansen (2004) &lt;<a href="https://doi.org/10.1198%2F106186006X137047">doi:10.1198/106186006X137047</a>&gt;. The variance estimator extends the method proposed in Fogarty (2018) &lt;<a href="https://doi.org/10.1111%2Frssb.12290">doi:10.1111/rssb.12290</a>&gt; from the perfect randomization settings to the potentially inexact matching case. Comparisons are made with conventional methods, as described in Rosenbaum (2002) &lt;<a href="https://doi.org/10.1007%2F978-1-4757-3692-2">doi:10.1007/978-1-4757-3692-2</a>&gt;, Fogarty (2018) &lt;<a href="https://doi.org/10.1111%2Frssb.12290">doi:10.1111/rssb.12290</a>&gt;, and Kang et al. (2016) &lt;<a href="https://doi.org/10.1214%2F15-aoas894">doi:10.1214/15-aoas894</a>&gt;. </td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, xgboost, optmatch</td>
</tr>
<tr>
<td>Suggests:</td>
<td>VGAM, mvtnorm</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-10 20:45:40 UTC; jiananzhu</td>
</tr>
<tr>
<td>Author:</td>
<td>Jianan Zhu [aut, cre],
  Jeffrey Zhang [aut],
  Zijian Guo [aut],
  Siyu Heng [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jianan Zhu &lt;jz4698@nyu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-12 17:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='conditional_p'>The function for calculating the post-matching treatment assignment probabilities</h2><span id='topic+conditional_p'></span>

<h3>Description</h3>

<p>This function calculates the regularized post-matching treatment assignment probabilities, as described in Zhu, Zhang, Guo, and Heng (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_p(treated.subject.index,matched.control.subject.index,p,alpha=0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_p_+3A_treated.subject.index">treated.subject.index</code></td>
<td>
<p>The index list for treated subjects after matching.</p>
</td></tr>
<tr><td><code id="conditional_p_+3A_matched.control.subject.index">matched.control.subject.index</code></td>
<td>
<p>The index list for control subjects after matching.</p>
</td></tr>
<tr><td><code id="conditional_p_+3A_p">p</code></td>
<td>
<p>The estimated propensity score vector.</p>
</td></tr>
<tr><td><code id="conditional_p_+3A_alpha">alpha</code></td>
<td>
<p>Prespecified small number as the regularization threshold. The default is 0.1.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>prob</code></td>
<td>
<p>The regularized post-matching treatment assignment probabilities vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jianan Zhu (maintainer), Jeffrey Zhang, Zijian Guo and Siyu Heng.
</p>


<h3>References</h3>

<p>Zhu, J., Zhang, J., Guo, Z., and Heng, S. (2024). Randomization-Based Inference for Average Treatment Effect in Inexactly Matched Observational Studies. arXiv:2308.02005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
library(xgboost)
library(optmatch)

# Generate data
set.seed(1)
d = 5
n = 50
sigma = diag(d)

# Generate X
X_d = mvtnorm::rmvnorm(n, mean = rep(0,d), sigma = sigma)
X_d[,4] = VGAM::rlaplace(n, location = 0, scale = sqrt(2)/2)
X_d[,5] = VGAM::rlaplace(n, location = 0, scale = sqrt(2)/2)

# Generate Z
C = -2.5 
fx = 0.1*(X_d[,1])^3 + 0.3*(X_d[,2]) + 0.2*log((X_d[,3])^2) + 0.1*(X_d[,4]) +  
     0.2*X_d[,5] + abs(X_d[,1]*X_d[,2]) + (X_d[,3]*X_d[,4])^2 + 0.5*(X_d[,2]*X_d[,4])^2 +  
     rnorm(n,0,1) + C
p = exp(fx)/(1+exp(fx)) # the probability of receiving the treatment
Z = rep(0,length(p))
for(i in seq_along(p)){
  Z[i] = rbinom(1,1,p[i])
}

# Generate Y 
Y_0 = 0.2*(X_d[,1])^3 + 0.2*abs(X_d[,2]) + 0.2*X_d[,3]^3 + 0.5*abs(X_d[,4]) +   
0.3*X_d[,5] + rnorm(n,0,1)
Y_1 = Y_0 + 1 + 0.3*X_d[,1] + 0.2*X_d[,3]^3
Y = (1-Z)*Y_0 + Z*Y_1

# Smahal function
  smahal=
    function(z,X){
      X&lt;-as.matrix(X)
      n&lt;-dim(X)[1]
      rownames(X)&lt;-1:n
      k&lt;-dim(X)[2]
      m&lt;-sum(z)
      for (j in 1:k) X[,j]&lt;-rank(X[,j])
      cv&lt;-cov(X)
      vuntied&lt;-var(1:n)
      rat&lt;-sqrt(vuntied/diag(cv))
      cv&lt;-diag(rat)%*%cv%*%diag(rat)
      out&lt;-matrix(NA,m,n-m)
      Xc&lt;-X[z==0,]
      Xt&lt;-X[z==1,]
      rownames(out)&lt;-rownames(X)[z==1]
      colnames(out)&lt;-rownames(X)[z==0]
      icov&lt;-MASS::ginv(cv)
      for (i in 1:m) out[i,]&lt;-mahalanobis(Xc,Xt[i,],icov,inverted=TRUE)
      out
    }
  
  # Matching
  treated.index = which(Z == 1)
  propscore.model = glm(Z ~ X_d, family = 'binomial',x=TRUE,y=TRUE)
  treated = propscore.model$y
  Xmat=propscore.model$x[,-1]
  distmat=smahal(treated,Xmat)
  logit.propscore=predict(propscore.model)
  subject.index=seq(1,length(treated),1)
  rownames(distmat)=subject.index[treated==1]
  colnames(distmat)=subject.index[treated==0]
  matchvec=fullmatch(distmat,min.controls=0.0001,max.controls=10000)
  treated.subject.index=vector("list",length(treated.index))
  matched.control.subject.index=vector("list",length(treated.index))
  matchedset.index=substr(matchvec,start=3,stop=10)
  matchedset.index.numeric=as.numeric(matchedset.index)
  subjects.match.order=as.numeric(names(matchvec))
  matchedset_index = length(unique(matchedset.index.numeric))
  
  # total number in each set
  l &lt;- rep(0,length(treated.subject.index))
  for(i in 1:length(treated.subject.index)){
    matched.set.temp=which(matchedset.index.numeric==i)
    matched.set.temp.indices=subjects.match.order[matched.set.temp]
    l[i] &lt;- length(matched.set.temp.indices)
  }
  
  # the order of matchvec
  for(i in 1:length(treated.index)){
  matched.set.temp=which(matchedset.index.numeric==i)
  matched.set.temp.indices=subjects.match.order[matched.set.temp]
  treated.temp.index=which(matched.set.temp.indices %in% treated.index)
  if(length(treated.temp.index) != 0){
    treated.subject.index[[i]]=matched.set.temp.indices[treated.temp.index]
    matched.control.subject.index[[i]]=matched.set.temp.indices[-treated.temp.index]
  }
}
  
  # remove null
  if(sum(sapply(treated.subject.index, is.null)) != 0){
    treated.subject.index&lt;- treated.subject.index[-which(sapply(treated.subject.index, is.null))]
    matched.control.subject.index&lt;-matched.control.subject.index[-which(sapply(   
    matched.control.subject.index,is.null))]
  }

# Use XGBoost to estimate propensity score
  length_all = length(Z)
  length_X = ncol(X_d)
  df = data.frame(Z,X_d)
  index_model1 = sample(length_all,length_all/2)
  df1 = df[index_model1,]
  df2 = df[-index_model1,]
  prob = rep(0,length_all)
  xgb.model1 = xgboost(data = as.matrix(df1[2:length_X]), label = df1$Z, nrounds = 2,   
  objective = "binary:logistic",verbose = 0)
  prob[-index_model1] = predict(xgb.model1, as.matrix(df2[2:length_X]))
  xgb.model2 = xgboost(data = as.matrix(df2[2:length_X]), label = df2$Z, nrounds = 2,   
  objective = "binary:logistic",verbose = 0)
  prob[index_model1] = predict(xgb.model2, as.matrix(df1[2:length_X]))
  
  # calculate the post-matching treatment assignment probabilities
  p = conditional_p(treated.subject.index,matched.control.subject.index,prob,alpha=0.1)
</code></pre>

<hr>
<h2 id='IPPW'>Randomization-based inference using inverse post-matching probability weighting (IPPW)</h2><span id='topic+IPPW'></span>

<h3>Description</h3>

<p>This function implements the inverse post-matching probability weighting (IPPW) method proposed in Zhu, Zhang, Guo and Heng (2024). It can be used for conducting randomization-based inference for the sample average treatment effect in potentially inexactly matched observational studies. By default, the matching design implemented in the package is optimal full matching, and the estimated propensity scores used in our method are obtained by the XGBoost method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IPPW(Y, Z, X, min.controls = 0.0001,max.controls = 10000, caliper = TRUE, 
     calipersd = 0.2, dim = FALSE, gamma = 0.1, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IPPW_+3A_y">Y</code></td>
<td>
<p>The observed outcome vector.</p>
</td></tr>
<tr><td><code id="IPPW_+3A_z">Z</code></td>
<td>
<p>The treatment indicator vector.</p>
</td></tr>
<tr><td><code id="IPPW_+3A_x">X</code></td>
<td>
<p>The covariates matrix. Each row is an individual.</p>
</td></tr>
<tr><td><code id="IPPW_+3A_min.controls">min.controls</code></td>
<td>
<p>The minimum ratio of controls to treatments permitted within a matched set. The default is 0.0001.</p>
</td></tr>
<tr><td><code id="IPPW_+3A_max.controls">max.controls</code></td>
<td>
<p>The maximum ratio of controls to treatments permitted within a matched set. The default is 10000.</p>
</td></tr>
<tr><td><code id="IPPW_+3A_caliper">caliper</code></td>
<td>
<p>Whether adding a propensity score caliper or not. The default is TRUE.</p>
</td></tr>
<tr><td><code id="IPPW_+3A_calipersd">calipersd</code></td>
<td>
<p>The standard deviation of the logit propensity score for caliper. The default is 0.2.</p>
</td></tr>
<tr><td><code id="IPPW_+3A_dim">dim</code></td>
<td>
<p>Whether using difference-in-means estimator to estimate the average treatment effect. The default is FALSE.</p>
</td></tr>
<tr><td><code id="IPPW_+3A_gamma">gamma</code></td>
<td>
<p>The regularization threshold. The default is 0.1.</p>
</td></tr>
<tr><td><code id="IPPW_+3A_alpha">alpha</code></td>
<td>
<p>The prespecified level alpha for the 1-alpha condifence interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>estimate</code></td>
<td>
<p>The estimate for the sample average treatment effect using the IPPW estimator.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The variance for the sample average treatment effect using the IPPW estimator.</p>
</td></tr>
<tr><td><code>low</code></td>
<td>
<p>The lower bound for the sample average treatment effect using the IPPW estimator.</p>
</td></tr>
<tr><td><code>up</code></td>
<td>
<p>The upper bound for the sample average treatment effect using the IPPW estimator.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>The confidence interval for the sample average treatment effect using the IPPW estimator.</p>
</td></tr>
<tr><td><code>balance</code></td>
<td>
<p>The pre- and post-matching covariate balance table.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jianan Zhu (maintainer), Jeffrey Zhang, Zijian Guo and Siyu Heng.
</p>


<h3>References</h3>

<p>Fogarty, C. B. (2018). On mitigating the analytical limitations of finely stratified experiments. Journal of the Royal Statistical Society Series B: Statistical Methodology, 80(5), 1035-1056.
</p>
<p>Hansen, B. B. (2004). Full matching in an observational study of coaching for the SAT. Journal of the American Statistical Association, 99(467), 609-618.
</p>
<p>Hansen, B. B. and Klopfer, S. O. (2006). Optimal full matching and related designs via network flows. Journal of Computational and Graphical Statistics, 15(3), 609-627.
</p>
<p>Kang, H., Kreuels, B., May, J., and Small, D. S. (2016). Full matching approach to instrumental variables estimation with application to the effect of malaria on stunting. The Annals of Applied Statistics, 10(1), 335-364.
</p>
<p>Rosenbaum, P. R. (1991). A characterization of optimal designs for observational studies. Journal of the Royal Statistical Society: Series B (Methodological), 53(3), 597-610.
</p>
<p>Zhu, J., Zhang, J., Guo, Z., and Heng, S. (2024). Randomization-Based Inference for Average Treatment Effect in Inexactly Matched Observational Studies. arXiv preprint, arXiv:2308.02005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
library(xgboost)
library(optmatch)

# Generate data
set.seed(1)
d = 3
n = 30
sigma = diag(d)

# Generate X
X_d = mvtnorm::rmvnorm(n, mean = rep(0,d), sigma = sigma)

# Generate Z
C = -2.5 
fx = 0.1*(X_d[,1])^3 + 0.3*(X_d[,2]) + 0.2*log((X_d[,3])^2) + 
     abs(X_d[,1]*X_d[,2]) + rnorm(n,0,1) + C
p = exp(fx)/(1+exp(fx)) # the probability of receiving the treatment
Z = rep(0,length(p))
for(i in seq_along(p)){
  Z[i] = rbinom(1,1,p[i])
}

# Generate Y 
Y_0 = 0.2*(X_d[,1])^3 + 0.2*abs(X_d[,2]) + 0.5*abs(X_d[,3]) + rnorm(n,0,1)
Y_1 = Y_0 + 1 + 0.3*X_d[,1] + 0.2*X_d[,3]^3
Y = (1-Z)*Y_0 + Z*Y_1

# The output
est = IPPW(Y,Z,X_d,min.controls = 0.01,max.controls = 100,caliper=FALSE,  
calipersd = 0.2,dim=FALSE,gamma=0.1,alpha=0.05)$estimate
est

</code></pre>

<hr>
<h2 id='IPPW_IV'>The bias-corrected Wald estimator for the complier average treatment effect</h2><span id='topic+IPPW_IV'></span>

<h3>Description</h3>

<p>This function implements the bias-corrected Wald estimator for randomization-based estimation and inference for the complier average treatment effect under inexact matching, proposed in Zhu, Zhang, Guo and Heng (2024). By default, the matching design implemented in the package is optimal full matching, and the estimated propensity scores used in our method are obtained by the XGBoost method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IPPW_IV(Y, Z, X, D, min.controls = 0.0001, max.controls = 10000, 
        caliper = TRUE, calipersd = 0.2, classical = FALSE, gamma = 0.1, 
        lower.bound, upper.bound, by,alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IPPW_IV_+3A_y">Y</code></td>
<td>
<p>The observed outcome vector.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_z">Z</code></td>
<td>
<p>The binary instrument vector.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_x">X</code></td>
<td>
<p>The covariates matrix. Each row is an individual.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_d">D</code></td>
<td>
<p>The binary treatment indicator vector.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_min.controls">min.controls</code></td>
<td>
<p>The minimum ratio of the unencouraged to the encouraged permitted within a matched set. The default is 0.0001.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_max.controls">max.controls</code></td>
<td>
<p>The maximum ratio of the unencouraged to the encouraged permitted within a matched set. The default is 10000.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_caliper">caliper</code></td>
<td>
<p>Whether adding a propensity score caliper or not. The default is TRUE.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_calipersd">calipersd</code></td>
<td>
<p>The standard deviation of the logit propensity score for caliper. The default is 0.2.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_classical">classical</code></td>
<td>
<p>Whether using the classical estimator (proposed by Kang et al. (2016)) to estimate the complier average treatment effect. The default is FALSE.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_gamma">gamma</code></td>
<td>
<p>The regularization threshold. The default is 0.1.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_lower.bound">lower.bound</code></td>
<td>
<p>The starting value of the search region for the point estimate.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_upper.bound">upper.bound</code></td>
<td>
<p>The end value of the search region for the point estimate.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_by">by</code></td>
<td>
<p>The increment of the search region for the point estimate.</p>
</td></tr>
<tr><td><code id="IPPW_IV_+3A_alpha">alpha</code></td>
<td>
<p>The prespecified level alpha for the 1-alpha confidence interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>estimate</code></td>
<td>
<p>The estimate for the complier average treatment effect using the bias-corrected Wald estimator.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>The confidence interval for the complier average treatment effect using the bias-corrected Wald estimator.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The corresponding z-scores for the hypothetical values of the complier average treatment effect.</p>
</td></tr>
<tr><td><code>balance</code></td>
<td>
<p>The pre- and post-matching covariate balance table.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jianan Zhu (maintainer), Jeffrey Zhang, Zijian Guo and Siyu Heng.
</p>


<h3>References</h3>

<p>Fogarty, C. B. (2018). On mitigating the analytical limitations of finely stratified experiments. Journal of the Royal Statistical Society Series B: Statistical Methodology, 80(5), 1035-1056.
</p>
<p>Hansen, B. B. (2004). Full matching in an observational study of coaching for the SAT. Journal of the American Statistical Association, 99(467), 609-618.
</p>
<p>Hansen, B. B. and Klopfer, S. O. (2006). Optimal full matching and related designs via network flows. Journal of Computational and Graphical Statistics, 15(3), 609-627.
</p>
<p>Kang, H., Kreuels, B., May, J., and Small, D. S. (2016). Full matching approach to instrumental variables estimation with application to the effect of malaria on stunting. The Annals of Applied Statistics, 10(1), 335-364.
</p>
<p>Rosenbaum, P. R. (1991). A characterization of optimal designs for observational studies. Journal of the Royal Statistical Society: Series B (Methodological), 53(3), 597-610.
</p>
<p>Zhu, J., Zhang, J., Guo, Z., and Heng, S. (2024). Randomization-Based Inference for Average Treatment Effect in Inexactly Matched Observational Studies. arXiv preprint, arXiv:2308.02005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
library(xgboost)
library(optmatch)

# Generate data
set.seed(1)
d = 3
n = 30
sigma = diag(d)

# generate X
X_d = mvtnorm::rmvnorm(n, mean = rep(0,d), sigma = sigma)

# generate Z
C = -2.5 
fx = 0.1*(X_d[,1])^3 + 0.3*(X_d[,2]) + 0.2*log((X_d[,3])^2) + 
     abs(X_d[,1]*X_d[,2]) + rnorm(n,0,1) + C
p = exp(fx)/(1+exp(fx)) # the probability of receiving the treatment
Z = rep(0,length(p))
for(i in seq_along(p)){
  Z[i] = rbinom(1,1,p[i])
}

#joint distribution
matrix = matrix(c(1,0.8,0.8,1),2,2)
sigma = mvrnorm(n,c(0,0),matrix)
  
# generate the treatment effect D:
fx_D0 = 0.1*X_d[,3] + 0.4*sin(X_d[,2]) + 0.4*abs(X_d[,3])- 1 + sigma[,1]  
ibu &lt;- rnorm(n,0,1)
D_0 = ifelse(fx_D0&gt;ibu,1,0)
  
fx_D1 = fx_D0 + 2 + 0.8*X_d[,2]^2
D_1 = ifelse(fx_D1&gt;ibu,1,0)
D = (1-Z)*D_0 + Z*D_1
  
# generate continuous outcome Y:
Y_0 = 0.4*(X_d[,1])^2 + 0.1*abs(X_d[,2]) + 0.2*cos(X_d[,3]) + sigma[,2]   
Y_1 = Y_0 + 1 + 0.1*X_d[,1] + 0.3*X_d[,3]^2
Y = (1-D)*Y_0 + D*Y_1

# The output
est = IPPW_IV(Y,Z,X_d,D,min.controls = 0.01, max.controls = 100,caliper=FALSE,  
      calipersd = 0.2, classical = FALSE,gamma = 0.1,lower.bound=0,upper.bound=3,
      by=0.01,alpha=0.05)$estimate
est


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
