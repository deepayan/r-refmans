<!DOCTYPE html><html><head><title>Help for package detpack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {detpack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#detpack'><p>Distribution Element Trees for Density Estimation and Bootstrapping</p></a></li>
<li><a href='#allequal'><p>Are All Columns in a Matrix Equal?</p></a></li>
<li><a href='#chi2indeptest'><p>Pairwise Mutual Independence Test</p></a></li>
<li><a href='#chi2testlinear'><p>Goodness-of-Fit Test for Linear Distributions</p></a></li>
<li><a href='#chi2testtable'><p>(Contingency) Tables for Chi-square Tests</p></a></li>
<li><a href='#chi2testuniform'><p>Goodness-of-Fit Test for Uniform Distribution</p></a></li>
<li><a href='#contourRect'><p>Draw Contours in a Rectangle</p></a></li>
<li><a href='#de.split'><p>Split a Distribution Element</p></a></li>
<li><a href='#det.construct'><p>Distribution Element Tree (DET) Construction</p></a></li>
<li><a href='#det.cut'><p>Identify Tree Leafs Intersected by Condition(s)</p></a></li>
<li><a href='#det.de'><p>Extract Distribution Element Characteristics</p></a></li>
<li><a href='#det.leafs'><p>Extract Leaf Elements from Distribution Element Tree</p></a></li>
<li><a href='#det.query'><p>Density Estimation Based on Distribution Element Trees</p></a></li>
<li><a href='#det.rnd'><p>Bootstrapping from Distribution Element Trees</p></a></li>
<li><a href='#det1'><p>Density Estimation for Univariate Data Based on Distribution Element Trees</p></a></li>
<li><a href='#det2'><p>Density Estimation for Bivariate Data Based on Distribution Element Trees</p></a></li>
<li><a href='#dimstosplit'><p>Determine Split Dimension(s)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Density Estimation and Random Number Generation with
Distribution Element Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Meyer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Meyer &lt;meyerda@ethz.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Density estimation for possibly large data sets and conditional/unconditional random number generation or bootstrapping with distribution element trees. The function 'det.construct' translates a dataset into a distribution element tree. To evaluate the probability density based on a previously computed tree at arbitrary query points, the function 'det.query' is available. The functions 'det1' and 'det2' provide density estimation and plotting for one- and two-dimensional datasets. Conditional/unconditional smooth bootstrapping from an available distribution element tree can be performed by 'det.rnd'. For more details on distribution element trees, see: Meyer, D.W. (2016) &lt;<a href="https://doi.org/10.48550/arXiv.1610.00345">doi:10.48550/arXiv.1610.00345</a>&gt; or Meyer, D.W., Statistics and Computing (2017) &lt;<a href="https://doi.org/10.1007%2Fs11222-017-9751-9">doi:10.1007/s11222-017-9751-9</a>&gt; and Meyer, D.W. (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1711.04632">doi:10.48550/arXiv.1711.04632</a>&gt; or Meyer, D.W., Journal of Computational and Graphical Statistics (2018) &lt;<a href="https://doi.org/10.1080%2F10618600.2018.1482768">doi:10.1080/10618600.2018.1482768</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, graphics, grDevices, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-24 10:43:34 UTC; meyerda</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-24 11:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='detpack'>Distribution Element Trees for Density Estimation and Bootstrapping</h2><span id='topic+detpack'></span><span id='topic+detpack-package'></span>

<h3>Description</h3>

<p>Distribution element trees (DETs) enable the estimation of probability densities based on (possibly large) datasets.
Moreover, DETs can be used for random number generation or smooth bootstrapping both in unconditional and conditional modes.
In the latter mode, information about certain probability-space components is taken into account when sampling the remaining probability-space components.
</p>


<h3>Details</h3>

<p>The function <code><a href="#topic+det.construct">det.construct</a></code> translates a dataset into a DET.
To evaluate the probability density based on a precomputed DET at arbitrary query points, <code><a href="#topic+det.query">det.query</a></code> is used.
The functions <code><a href="#topic+det1">det1</a></code> and <code><a href="#topic+det2">det2</a></code> provide density estimation and plotting for one- and two-dimensional datasets.
(Un)conditional smooth bootstrapping from an available DET, can be performed by <code><a href="#topic+det.rnd">det.rnd</a></code>.
To inspect the structure of a DET, the functions <code><a href="#topic+det.de">det.de</a></code> and <code><a href="#topic+det.leafs">det.leafs</a></code> are useful. While <code><a href="#topic+det.de">det.de</a></code> enables the extraction of an individual distribution element from the tree, <code><a href="#topic+det.leafs">det.leafs</a></code> extracts all leaf elements at branch ends.
</p>


<h3>Author(s)</h3>

<p>Daniel Meyer, <a href="mailto:meyerda@ethz.ch">meyerda@ethz.ch</a>
</p>


<h3>References</h3>

<p>Distribution element tree basics and density estimation, see Meyer, D.W. (2016) <a href="http://arxiv.org/abs/1610.00345">http://arxiv.org/abs/1610.00345</a> or Meyer, D.W., Statistics and Computing (2017) <a href="https://doi.org/10.1007/s11222-017-9751-9">https://doi.org/10.1007/s11222-017-9751-9</a>.
</p>
<p>DETs for smooth bootstrapping, see Meyer, D.W. (2017) <a href="http://arxiv.org/abs/1711.04632">http://arxiv.org/abs/1711.04632</a> or Meyer, D.W., Journal of Computational and Graphical Statistics (2018) <a href="https://doi.org/10.1080/10618600.2018.1482768">https://doi.org/10.1080/10618600.2018.1482768</a>.
</p>

<hr>
<h2 id='allequal'>Are All Columns in a Matrix Equal?</h2><span id='topic+allequal'></span>

<h3>Description</h3>

<p>Check if all column vectors in a matrix are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allequal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allequal_+3A_x">x</code></td>
<td>
<p>matrix with column vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if matrix <code>x</code> has zero or one column, or if all column vectors in matrix <code>x</code> are equal. FALSE if <code>x</code> contains at least two different columns.
</p>

<hr>
<h2 id='chi2indeptest'>Pairwise Mutual Independence Test</h2><span id='topic+chi2indeptest'></span>

<h3>Description</h3>

<p>Pearson's Chi-square test of pairwise mutual independence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi2indeptest(x, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi2indeptest_+3A_x">x</code></td>
<td>
<p>matrix with <code>n</code> rows comprised of normalized data between 0 and 1.</p>
</td></tr>
<tr><td><code id="chi2indeptest_+3A_alpha">alpha</code></td>
<td>
<p>significance level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with test outcomes <code>h[i,j] = h[j,i] = TRUE/FALSE</code> for <code>1 &lt;= i,j &lt;= n</code> meaning rejection/acceptance of independence null hypothesis involving rows <code>i</code> and <code>j</code> of matrix <code>x</code>, and p-value or confidence level of acceptance.
</p>

<hr>
<h2 id='chi2testlinear'>Goodness-of-Fit Test for Linear Distributions</h2><span id='topic+chi2testlinear'></span>

<h3>Description</h3>

<p>Composite Pearson's Chi-square test for goodness-of-fit of linear distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi2testlinear(x, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi2testlinear_+3A_x">x</code></td>
<td>
<p>vector with normalized data between 0 and 1.</p>
</td></tr>
<tr><td><code id="chi2testlinear_+3A_alpha">alpha</code></td>
<td>
<p>significance level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with test outcome <code>h = TRUE/FALSE</code> meaning rejection/acceptance of linear null hypothesis, and p-value or confidence level of acceptance.
</p>

<hr>
<h2 id='chi2testtable'>(Contingency) Tables for Chi-square Tests</h2><span id='topic+chi2testtable'></span>

<h3>Description</h3>

<p>(Contingency) tables for Pearson's Chi-square goodness-of-fit and independence tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi2testtable(x, alpha, cf = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi2testtable_+3A_x">x</code></td>
<td>
<p>vector with normalized data between 0 and 1.</p>
</td></tr>
<tr><td><code id="chi2testtable_+3A_alpha">alpha</code></td>
<td>
<p>significance level.</p>
</td></tr>
<tr><td><code id="chi2testtable_+3A_cf">cf</code></td>
<td>
<p>flag, if <code>TRUE</code>, bin counts for a multi-variate contingency table are applied (Bagnato et al., 2012). Otherwise rules for univariate tables are used (Cochran, 1952; Mann and Wald, 1942).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with observed counts <code>co</code> of data <code>x</code> inside bins defined by edges <code>be</code>.
</p>


<h3>References</h3>

<p>Cochran, W.G., The Chi Square Test of Goodness of Fit. The Annals of Mathematical Statistics, 1952. 23(3): p. 315-345.
</p>
<p>Mann, H.B. and A. Wald, On the Choice of the Number of Class Intervals in the Application of the Chi Square Test. The Annals of Mathematical Statistics, 1942. 13(3): p. 306-317.
</p>
<p>Bagnato, L., A. Punzo, and O. Nicolis, The autodependogram: a graphical device to investigate serial dependences. Journal of Time Series Analysis, 2012. 33(2): p. 233-254.
</p>

<hr>
<h2 id='chi2testuniform'>Goodness-of-Fit Test for Uniform Distribution</h2><span id='topic+chi2testuniform'></span>

<h3>Description</h3>

<p>Pearson's Chi-square test for goodness-of-fit of a uniform distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi2testuniform(x, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi2testuniform_+3A_x">x</code></td>
<td>
<p>vector with normalized data between 0 and 1.</p>
</td></tr>
<tr><td><code id="chi2testuniform_+3A_alpha">alpha</code></td>
<td>
<p>significance level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with test outcome <code>h = TRUE/FALSE</code> meaning rejection/acceptance of uniform null hypothesis, and p-value or confidence level of acceptance.
</p>

<hr>
<h2 id='contourRect'>Draw Contours in a Rectangle</h2><span id='topic+contourRect'></span>

<h3>Description</h3>

<p>The function <code>contourRect</code> draws the z contour levels of a rectangular domain in x-y-space with z-values given at the corners of the rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contourRect(xy, z, n = 20, zlb = 0, zub = 1,
  color = grDevices::colorRamp(c("white", "black")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contourRect_+3A_xy">xy</code></td>
<td>
<p>matrix with two rows and four columns containing x- and y-coordinates of the four corner points of the rectangle. The corner points are ordered in clockwise or counter-clockwise direction.</p>
</td></tr>
<tr><td><code id="contourRect_+3A_z">z</code></td>
<td>
<p>vector with four z-values at the four corner points.</p>
</td></tr>
<tr><td><code id="contourRect_+3A_n">n</code></td>
<td>
<p><code>abs(n)</code> gives the number of local or global contour levels. If <code>n &gt; 0</code>, <code>n</code> local contours are drawn within <code>[min(z),max(z)]</code>. If <code>n &lt; 0</code>, <code>n</code> global contours result in <code>[zlb,zub]</code>, but only the contours falling inside <code>[min(z),max(z)]</code> are drawn.</p>
</td></tr>
<tr><td><code id="contourRect_+3A_zlb">zlb</code>, <code id="contourRect_+3A_zub">zub</code></td>
<td>
<p>determines the global range of z-values used to determine the contour colors. All values in <code>z</code> have to be contained in <code>[zlb,zub]</code>.</p>
</td></tr>
<tr><td><code id="contourRect_+3A_color">color</code></td>
<td>
<p>function to assign plot colors that is generated, e.g., by <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code>. <code>color</code> returns a color based on an argument in <code>[0,1]</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='de.split'>Split a Distribution Element</h2><span id='topic+de.split'></span>

<h3>Description</h3>

<p>Splits a parent distribution element characterized by <code>x</code>, <code>sze</code>, and <code>id</code> along dimension <code>dimens</code> based on <code>mode</code> into two child elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>de.split(dimens, x, sze, id, mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="de.split_+3A_dimens">dimens</code></td>
<td>
<p>split dimension.</p>
</td></tr>
<tr><td><code id="de.split_+3A_x">x</code></td>
<td>
<p>data in element given as matrix with <code>d</code> rows or components and <code>n</code> columns or samples.</p>
</td></tr>
<tr><td><code id="de.split_+3A_sze">sze</code></td>
<td>
<p>vector representing the size of the element.</p>
</td></tr>
<tr><td><code id="de.split_+3A_id">id</code></td>
<td>
<p>element index or identifier.</p>
</td></tr>
<tr><td><code id="de.split_+3A_mode">mode</code></td>
<td>
<p>for splitting: <code>&gt; 0</code> or <code>&lt; 0</code> for equal-size or -score split, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object containing the properties of the resulting two child distribution elements and the split position within the parent element.
</p>

<hr>
<h2 id='det.construct'>Distribution Element Tree (DET) Construction</h2><span id='topic+det.construct'></span>

<h3>Description</h3>

<p>The function <code>det.construct</code> generates a distribution element tree DET from available data. The DET can be used firstly in connection with <code><a href="#topic+det.query">det.query</a></code> for density estimation. Secondly, with <code><a href="#topic+det.rnd">det.rnd</a></code>, DETs can be used for smooth bootstrapping or more specifically conditional or unconditional random number generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det.construct(dta, mode = 2, lb = NA, ub = NA, alphag = 0.001,
  alphad = 0.001, progress = TRUE, dtalim = Inf, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det.construct_+3A_dta">dta</code></td>
<td>
<p>matrix with <code>d</code> rows representing components or dimensions and <code>n</code> columns corresponding to data points or samples.</p>
</td></tr>
<tr><td><code id="det.construct_+3A_mode">mode</code></td>
<td>
<p>order of distribution elements applied, default is <code>mode = 2</code>. Use <code>+/-1</code> for constant or <code>+/-2</code> for linear elements. <code>mode &gt; 0</code> and <code>mode &lt; 0</code> lead to equal-size and -score splits, respectively, in the element-refinement process.</p>
</td></tr>
<tr><td><code id="det.construct_+3A_lb">lb</code>, <code id="det.construct_+3A_ub">ub</code></td>
<td>
<p>vectors of length <code>d</code> with lower and upper sample-space bounds. If not provided or set to <code>NA</code> or <code>0</code>, the bounds are determined from the data <code>dta</code>. If bounds are provided or given as <code>0</code>, the data is not pre-whitened before the DET is computed.</p>
</td></tr>
<tr><td><code id="det.construct_+3A_alphag">alphag</code>, <code id="det.construct_+3A_alphad">alphad</code></td>
<td>
<p>significance levels for goodness-of-fit and independence tests, respectively, in element refinement or splitting process. Default is <code>alphag = alphad = 1.0e-3</code>. <code>alphad</code> is irrelevant for univariate data <code>dta</code> with <code>d = 1</code>.</p>
</td></tr>
<tr><td><code id="det.construct_+3A_progress">progress</code></td>
<td>
<p>optional logical, if set to <code>TRUE</code>, a progress report about the DET construction process is provided.</p>
</td></tr>
<tr><td><code id="det.construct_+3A_dtalim">dtalim</code></td>
<td>
<p>for large datasets, <code>det.construct</code> can be accelerated (with negligible impact on the resulting DET if <code>dtalim</code> is sufficiently large) by using only up to <code>dtalim</code> samples for element splitting tests. Setting <code>dtalim &lt; n</code> impacts mainly the splitting at the tree root, with elements being large and thus containing many samples. Default is <code>dtalim = Inf</code>, which corresponds to using all available samples (no acceleration). When using <code>dtalim &lt; n</code>, the samples have to be randomly arranged in <code>dta</code>: use for example <code>dta[,sample(1:ncol(dta), ncol(dta), replace = FALSE)]</code> to randomly rearrange the data.</p>
</td></tr>
<tr><td><code id="det.construct_+3A_cores">cores</code></td>
<td>
<p><code>&gt; 1</code> allows for parallel tree construction or branch splitting using the indicated number of cores. With <code>cores = Inf</code>, half of the available cores (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>) are allocated. <code>cores = 1</code> corresponds to serial tree construction (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DET object, which reflects the tree and pre-white transform, is returned.
</p>


<h3>References</h3>

<p>Meyer, D.W. (2016) <a href="http://arxiv.org/abs/1610.00345">http://arxiv.org/abs/1610.00345</a> or Meyer, D.W., Statistics and Computing (2017) <a href="https://doi.org/10.1007/s11222-017-9751-9">https://doi.org/10.1007/s11222-017-9751-9</a> and Meyer, D.W. (2017) <a href="http://arxiv.org/abs/1711.04632">http://arxiv.org/abs/1711.04632</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gaussian mixture data
require(stats)
det &lt;- det.construct(t(c(rnorm(1e5),rnorm(1e4)/100+2))) # default linear det (mode = 2)
x &lt;- t(seq(-4,6,0.01)); p &lt;- det.query(det, x); plot(x, p, type = "l")

## piecewise uniform data with peaks
x &lt;- matrix(c(rep(0,1e3),rep(1,1e3), 2*runif(1e4),
              rep(0,5e2),rep(1,25e2),2*runif(9e3)), nrow = 2, byrow = TRUE)
det &lt;- det.construct(x, mode = 1, lb = 0, ub = 0) # constant elements, no pre-whitening
</code></pre>

<hr>
<h2 id='det.cut'>Identify Tree Leafs Intersected by Condition(s)</h2><span id='topic+det.cut'></span>

<h3>Description</h3>

<p>Identify distribution element tree (DET) leafs that are cut by conditions. The latter are defined in terms of positions <code>xc</code> along probability-space components with indices <code>dc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det.cut(det, xc, dc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det.cut_+3A_det">det</code></td>
<td>
<p>distribution element tree object resulting from <code><a href="#topic+det.construct">det.construct</a></code>.</p>
</td></tr>
<tr><td><code id="det.cut_+3A_xc">xc</code></td>
<td>
<p>vector with conditioning values of probability-space components listed in <code>dc</code>.</p>
</td></tr>
<tr><td><code id="det.cut_+3A_dc">dc</code></td>
<td>
<p>integer vector with indices of conditioning components corresponding to <code>xc</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the leaf indices that are cut by conditions <code>xc</code> of components <code>dc</code> is returned. If no leafs are found, the return vector has length 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DET based on Gaussian data
require(stats); require(graphics)
n &lt;- 8e4; x &lt;- rnorm(n)
x &lt;- matrix(c(x, x+rnorm(n,0,0.2)), ncol = 2)
det &lt;- det.construct(t(x), lb = 0, ub = 0) # no pre-whitening
plot(x, type = "p", pch = ".", asp = 1)
# leaf elements that are cut by x1 = 2
leafs &lt;- det.cut(det, xc = 2, dc = 1) # condition x1 = 2
# draw probability space (black) with cut leaf elements (red)
rect(det$lb[1], det$lb[2], det$ub[1], det$ub[2], border = "black")
for (k in 1:length(leafs)) {
   p &lt;- det.de(det, leafs[k])$lb; w &lt;- det.de(det, leafs[k])$size
   rect(p[1],p[2],p[1]+w[1],p[2]+w[2], border = "red")
}
# leafs cut by two conditions x1 = -3, x2 = -2 (blue)
leafs &lt;- det.cut(det, xc = c(-2,-3), dc = c(2,1))
p &lt;- det.de(det, leafs[1])$lb; w &lt;- det.de(det, leafs[1])$size
rect(p[1],p[2],p[1]+w[1],p[2]+w[2], border = "blue")
</code></pre>

<hr>
<h2 id='det.de'>Extract Distribution Element Characteristics</h2><span id='topic+det.de'></span>

<h3>Description</h3>

<p>The function <code>det.de</code> extracts the distribution element with index <code>ind</code> from a distribution element tree (DET) generated by the function <code><a href="#topic+det.construct">det.construct</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det.de(det, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det.de_+3A_det">det</code></td>
<td>
<p>distribution element tree object resulting from <code><a href="#topic+det.construct">det.construct</a></code>.</p>
</td></tr>
<tr><td><code id="det.de_+3A_ind">ind</code></td>
<td>
<p>index of element to extract from <code>det</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the element characteristics is returned: <code>p</code> probability density, <code>theta</code> element parameters, <code>lb</code> lower bound, <code>size</code> of element, <code>div</code> divisions or splits along dimensions leading to final element.
</p>

<hr>
<h2 id='det.leafs'>Extract Leaf Elements from Distribution Element Tree</h2><span id='topic+det.leafs'></span>

<h3>Description</h3>

<p>The function <code>det.leafs</code> extracts the distribution elements at the branch ends of a DET generated by the function <code><a href="#topic+det.construct">det.construct</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det.leafs(det)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det.leafs_+3A_det">det</code></td>
<td>
<p>distribution element tree object resulting from <code><a href="#topic+det.construct">det.construct</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors containing the leaf element data is returned: <code>p</code> probability density, <code>theta</code> element parameters, <code>lb</code> lower bound, <code>size</code> of element, <code>div</code> divisions or splits along dimensions leading to final element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats); require(graphics)
# generate DET based on bi-variate Gaussian data
n &lt;- 1e4; x &lt;- rnorm(n)
x &lt;- matrix(c(x, x+rnorm(n,0,0.2)), nrow = 2, byrow = TRUE)
det &lt;- det.construct(x)
# plot data and element pattern
leafs &lt;- det.leafs(det)
plot(t(x), type = "p", pch = ".", asp = 1)
for (k in 1:length(leafs$p)) {
   p &lt;- leafs$lb[,k] # element corner point
   w &lt;- leafs$size[,k] # element size
   elem &lt;- rbind(c(p[1],p[1]+w[1],p[1]+w[1],p[1],p[1]),
                 c(p[2],p[2],p[2]+w[2],p[2]+w[2],p[2])) # element rectangle
   elem &lt;- t(det$A) %*% elem + det$mu %*% t(rep(1,5)) # pre-white transform
   lines(elem[1,],elem[2,]) # draw element
}
</code></pre>

<hr>
<h2 id='det.query'>Density Estimation Based on Distribution Element Trees</h2><span id='topic+det.query'></span>

<h3>Description</h3>

<p>The function <code>det.query</code> evaluates probability densities at the query points <code>x</code> based on a distribution element tree (DET). The latter is calculable with <code><a href="#topic+det.construct">det.construct</a></code> based on available data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det.query(det, x, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det.query_+3A_det">det</code></td>
<td>
<p>distribution element tree object resulting from <code><a href="#topic+det.construct">det.construct</a></code> based on data with <code>d</code> components or dimensions.</p>
</td></tr>
<tr><td><code id="det.query_+3A_x">x</code></td>
<td>
<p>matrix containing <code>n</code> query points (columns) with <code>d</code> components or dimensions (rows).</p>
</td></tr>
<tr><td><code id="det.query_+3A_cores">cores</code></td>
<td>
<p>for large query-point sets, <code>cores &gt; 1</code> allows for parallel tree query using the indicated number of cores. <code>cores = Inf</code> allocates half of the available cores (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>). The default is <code>cores = 1</code> corresponding to serial tree query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the probability density at the query points <code>x</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1d example
require(stats); require(graphics)
# DET generation based on Gaussian/uniform data
det &lt;- det.construct(t(c(rnorm(1e5,2,3),runif(1e5)-3)))
# density evaluation based on DET at equidistant query points
x &lt;- t(seq(-10,14,0.01)); p &lt;- det.query(det, x)
# compare DET estimate (black) against Gaussian/uniform reference (red)
plot(x, p, type = "l", col = "black")
lines(x, (dnorm(x,2,3)+dunif(x+3))/2, col = "red")

## 2d example
require(stats); require(graphics)
# mean and covariance of Gaussian, data generation
mu &lt;- c(3,5); C &lt;- matrix(c(4.0,-2.28,-2.28,1.44), nrow = 2)
A &lt;- eigen(C); B &lt;- diag(A$values); A &lt;- A$vectors
x &lt;- matrix(rnorm(2e4), nrow = 2)
x &lt;- t(A %*% (sqrt(B) %*% x) + mu %*% t(rep(1,ncol(x))))
# bounds and resolution of x1-x2 query grid
lb &lt;- c(-5,0); ub &lt;- c(11,10); np &lt;- c(320,200)
x1 &lt;- lb[1] + (ub[1]-lb[1])*((1:np[1])-0.5)/np[1]
x2 &lt;- lb[2] + (ub[2]-lb[2])*((1:np[2])-0.5)/np[2]
xp &lt;- rbind(rep(x1,np[2]), rep(x2,each = np[1])) # grid points
# plotting
split.screen(c(2, 2)); screen(1)
plot(x, type = "p", pch = ".", asp = 1, main = "data")
# DET estimator
det &lt;- det.construct(t(x))
yd &lt;- matrix(det.query(det, xp), nrow = np[1])
screen(2)
image(list(x = x1, y = x2, z = yd), asp = 1,
      col = grDevices::gray((100:0)/100), main = "det")
# Gaussian density for comparison
yr &lt;- yr &lt;- exp(-1/2 * colSums(
   (t(solve(C)) %*% (xp - mu%*%t(rep(1,ncol(xp))))) *
                    (xp - mu%*%t(rep(1,ncol(xp)))))
                              ) / sqrt((2*pi)^2*det(C))
yr &lt;- matrix(yr, nrow = np[1])
screen(3)
image(list(x = x1, y = x2, z = yr), asp = 1,
      col = grDevices::gray((100:0)/100), main = "reference")
</code></pre>

<hr>
<h2 id='det.rnd'>Bootstrapping from Distribution Element Trees</h2><span id='topic+det.rnd'></span>

<h3>Description</h3>

<p>Smooth bootstrapping or generation of (un)conditional random vectors based on an existing distribution element tree (DET).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det.rnd(n, det, xc = vector("numeric", length = 0), dc = vector("numeric",
  length = 0), cores = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det.rnd_+3A_n">n</code></td>
<td>
<p>number of samples to generate.</p>
</td></tr>
<tr><td><code id="det.rnd_+3A_det">det</code></td>
<td>
<p>distribution element tree object resulting from <code><a href="#topic+det.construct">det.construct</a></code>.</p>
</td></tr>
<tr><td><code id="det.rnd_+3A_xc">xc</code></td>
<td>
<p>vector with conditioning values of probability-space components listed in <code>dc</code>. If empty (default), unconditional samples are generated.</p>
</td></tr>
<tr><td><code id="det.rnd_+3A_dc">dc</code></td>
<td>
<p>integer vector with indices of conditioning components corresponding to <code>xc</code>. If empty (default), unconditional samples are generated.</p>
</td></tr>
<tr><td><code id="det.rnd_+3A_cores">cores</code></td>
<td>
<p>for large <code>n</code>, <code>cores &gt; 1</code> allows for parallel bootstrapping using the indicated number of cores. The default is <code>cores = Inf</code>, which allocates half of the available cores (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>). <code>cores = 1</code> corresponds to serial bootstrapping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing <code>n</code> random vectors (columns) with <code>d</code> components or dimensions (rows) is returned. <code>d</code> is equal to the dimensionality of the underlying <code>det</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 2d example
require(stats); require(graphics)
# data from uniform distribution on a wedge
x &lt;- matrix(runif(2e4), ncol = 2); x &lt;- x[x[,2]&lt;x[,1],]
x2c &lt;- 0.75 # conditioning component
# data and conditioning line
split.screen(c(2, 1)); screen(1)
plot(x, type = "p", pch = ".", asp = 1)
lines(c(0,1), x2c*c(1,1), col = "red")
# DET construction and bootstrapping
det &lt;- det.construct(t(x), mode = 1, lb = 0, ub = 0) # const. de's, no pre-white
y &lt;- det.rnd(1e3, det, xc = x2c, dc = 2, cores = 2) # conditional bootstrap'g
# compare generated data (black) with exact cond. distribution (red)
screen(2); det1(y[1,], mode = 1)
lines(c(0,x2c,x2c,1,1),c(0,0,1/(1-x2c),1/(1-x2c),0), col = "red")

## example 2d unconditional
require(stats); require(graphics)
x &lt;- matrix(runif(2e4), ncol = 2); x &lt;- x[x[,2]&lt;x[,1],] # uniform wedge
det &lt;- det.construct(t(x), mode = 1, lb = 0, ub = 0) # no pre-white
y &lt;- t(det.rnd(nrow(x), det, cores = 2)) # smooth bootstrapping
split.screen(c(2, 1))
screen(1); plot(x, type = "p", pch = ".", asp = 1, main = "original")
screen(2); plot(y, type = "p", pch = ".", asp = 1, main = "bootstrapped")

## example 3d
require(stats); require(graphics)
# mean and covariance of Gaussian, data generation
mu &lt;- c(1,3,2); C &lt;- matrix(c(25,7.5,1.75,7.5,7,1.35,1.75,1.35,0.43), nrow = 3)
A &lt;- eigen(C); B &lt;- diag(A$values); A &lt;- A$vectors
x &lt;- matrix(rnorm(3e4), nrow = 3)
x &lt;- A %*% (sqrt(B) %*% x) + mu %*% t(rep(1,ncol(x)))
lbl &lt;- "x1 | x2 = 7 &amp; x3 = 2.5"
pairs(t(x), labels = c("x1","x2","x3"), pch = ".", main = lbl)
# bootstrapping conditional on x2 and x3
det &lt;- det.construct(x, lb = 0, ub = 0)
xc &lt;- c(2.5,7); d &lt;- c(3,2) # conditional on x2 = 7 &amp; x3 = 2.5
y &lt;- det.rnd(1e4, det, xc, d, cores = 1)
det1(y[1,], mode = 1, main = lbl)
# compare with exact conditional density
Cm1 &lt;- solve(C); var1 &lt;- det(C)/det(C[2:3,2:3]) # conditional variance
mu1 &lt;- mu[1] + var1*((mu[2]-xc[d==2])*Cm1[1,2]+(mu[3]-xc[d==3])*Cm1[1,3]) # cond. mean
x1 &lt;- mu1 + seq(-50,50)/50 * 5*sqrt(var1) # x1-axis grid points
lines(x1, dnorm(x1,mu1,sqrt(var1)), col = "red")
</code></pre>

<hr>
<h2 id='det1'>Density Estimation for Univariate Data Based on Distribution Element Trees</h2><span id='topic+det1'></span>

<h3>Description</h3>

<p>One-dimensional piecewise linear or constant probability density estimator based on distribution element trees (DETs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det1(dta, mode = 2, bounds = c(0, 0), alpha = 0.001, main = NULL,
  dtalim = Inf, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det1_+3A_dta">dta</code></td>
<td>
<p>vector with data</p>
</td></tr>
<tr><td><code id="det1_+3A_mode">mode</code></td>
<td>
<p>order of distribution elements applied, default is <code>mode = 2</code>. Use <code>+/-1</code> for constant or <code>+/-2</code> for linear elements. <code>mode &gt; 0</code> and <code>mode &lt; 0</code> lead to equal-size and -score splits, respectively, in the element-refinement process.</p>
</td></tr>
<tr><td><code id="det1_+3A_bounds">bounds</code></td>
<td>
<p><code>c(lb,ub)</code>, where <code>lb</code> and <code>ub</code> are lower and upper bounds of the probability space. If both bounds are set to 0 (default), the bounds are determined based on the data <code>dta</code>.</p>
</td></tr>
<tr><td><code id="det1_+3A_alpha">alpha</code></td>
<td>
<p>significance level for goodness-of-fit testing in element refinement or splitting process. Default is <code>alpha = 1.0e-3</code>.</p>
</td></tr>
<tr><td><code id="det1_+3A_main">main</code></td>
<td>
<p>an overall plot title, see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="det1_+3A_dtalim">dtalim</code></td>
<td>
<p>allows to limit the number of samples used in tests guiding the element splitting process. Default is <code>dtalim = Inf</code>, which corresponds to using all available samples, see <code><a href="#topic+det.construct">det.construct</a></code>.</p>
</td></tr>
<tr><td><code id="det1_+3A_cores">cores</code></td>
<td>
<p>number of cores for parallel tree construction. Default is <code>1</code> for serial construction, see <code><a href="#topic+det.construct">det.construct</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)
det1(rbeta(5e5, shape1 = 1.05, shape2 = 0.8), mode = -1,
     bounds = c(-0.1,1.1), main = "beta, const. elements, equal-scores splits")
x &lt;- seq(-0.1,1.1,0.005); lines(x, dbeta(x,shape1 = 1.05,shape2 = 0.8), col = "red")
det1(rbeta(5e5, shape1 = 1.05, shape2 = 0.8), mode = -2,
     bounds = c(-0.1,1.1), main = "beta, linear elements, equal-scores splits")
x &lt;- seq(-0.1,1.1,0.005); lines(x, dbeta(x,shape1 = 1.05,shape2 = 0.8), col = "red")
det1(rnorm(5e5), mode = 2, cores = 1, main = "Gaussian, linear elements, equal-size splits")
x &lt;- seq(-5,5,0.05); lines(x, dnorm(x), col = "red")
det1(runif(5e5), mode = 1, bounds = c(-0.1,1.1),
     main = "uniform, const. elements, equal-size splits")
x &lt;- seq(-0.1,1.1,0.005); lines(x, dunif(x), col = "red")
</code></pre>

<hr>
<h2 id='det2'>Density Estimation for Bivariate Data Based on Distribution Element Trees</h2><span id='topic+det2'></span>

<h3>Description</h3>

<p>Two-dimensional piecewise linear or constant probability density estimator based on distribution element trees (DETs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det2(dta, mode = 2, bounds = list(NA, NA), alphag = 0.001,
  alphad = 0.001, main = NULL, nc = 20, dtalim = Inf, cores = 1,
  color = grDevices::colorRamp(c("white", "black")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det2_+3A_dta">dta</code></td>
<td>
<p>matrix with two rows containing data (samples in columns).</p>
</td></tr>
<tr><td><code id="det2_+3A_mode">mode</code></td>
<td>
<p>order of distribution elements applied, default is <code>mode = 2</code>. Use <code>+/-1</code> for constant or <code>+/-2</code> for linear elements. <code>mode &gt; 0</code> and <code>mode &lt; 0</code> lead to equal-size and -score splits, respectively, in the element-refinement process.</p>
</td></tr>
<tr><td><code id="det2_+3A_bounds">bounds</code></td>
<td>
<p><code>list(lb,ub)</code>, where <code>lb</code> and <code>ub</code> are vectors representing the lower and upper bounds of the probability space. If both bounds are set to NA (default) or 0, the bounds are determined based on the data <code>dta</code>. Additionally, if the bounds are set to 0, pre-whitening is not applied to the data.</p>
</td></tr>
<tr><td><code id="det2_+3A_alphag">alphag</code>, <code id="det2_+3A_alphad">alphad</code></td>
<td>
<p>significance levels for goodness-of-fit and independence tests, respectively, in element refinement or splitting process. Default is <code>alphag = alphad = 1.0e-3</code>.</p>
</td></tr>
<tr><td><code id="det2_+3A_main">main</code></td>
<td>
<p>an overall plot title, see <code><a href="graphics.html#topic+title">title</a></code>. If <code>main = NULL</code> (default), the density range is provided as a title.</p>
</td></tr>
<tr><td><code id="det2_+3A_nc">nc</code></td>
<td>
<p>number of contour levels (default is 20).</p>
</td></tr>
<tr><td><code id="det2_+3A_dtalim">dtalim</code></td>
<td>
<p>allows to limit the number of samples used in tests guiding the element splitting process. Default is <code>dtalim = Inf</code>, which corresponds to using all available samples, see <code><a href="#topic+det.construct">det.construct</a></code>.</p>
</td></tr>
<tr><td><code id="det2_+3A_cores">cores</code></td>
<td>
<p>number of cores for parallel tree construction. Default is <code>cores = 1</code> for serial processing, see <code>cores</code> in <code><a href="#topic+det.construct">det.construct</a></code>.</p>
</td></tr>
<tr><td><code id="det2_+3A_color">color</code></td>
<td>
<p>function to assign plot colors that is generated, e.g., by <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code>. <code>color</code> returns a color based on an argument in <code>[0,1]</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## uniform
require(stats)
det2(rbind(runif(5e3),1+2*runif(5e3)), mode = 1, bounds = list(c(-0.1,0),c(1.1,4)))
det2(rbind(1:100,101:200+runif(100)), mode = 2) # data on a line

## Gaussian
require(stats); require(graphics); require(grDevices)
n &lt;- 5e3; x &lt;- rnorm(n)
x &lt;- matrix(c(x, x+rnorm(n,0,0.5)), ncol = 2)
split.screen(c(2,2))
color = colorRamp(c("#FFFFFF","#E6E680","#E6BF1A",
                    "#E68000","#FF4026","#993380",
                    "#4D26BF","#262680","#000000"))
screen(3); plot(x, type = "p", pch = ".", main = "data")
screen(1); det2(t(x), mode = 1, main = "constant det estimator", color = color)
screen(2); det2(t(x), main = "linear det estimator", color = color)
screen(4)
det2(t(x), mode = 1, bounds = list(0,0), main = "const. det, no pre-white", color = color)
</code></pre>

<hr>
<h2 id='dimstosplit'>Determine Split Dimension(s)</h2><span id='topic+dimstosplit'></span>

<h3>Description</h3>

<p>Determine the split dimensions of an existing distribution element in the DET refinement-process based on statistical tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimstosplit(x, sze, mode, alphag, alphad)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimstosplit_+3A_x">x</code></td>
<td>
<p>data in element given as matrix with <code>d</code> rows or components and <code>n</code> columns or samples.</p>
</td></tr>
<tr><td><code id="dimstosplit_+3A_sze">sze</code></td>
<td>
<p>vector representing the element size.</p>
</td></tr>
<tr><td><code id="dimstosplit_+3A_mode">mode</code></td>
<td>
<p>element order and split mode as detailed in <code><a href="#topic+det.construct">det.construct</a></code>.</p>
</td></tr>
<tr><td><code id="dimstosplit_+3A_alphag">alphag</code>, <code id="dimstosplit_+3A_alphad">alphad</code></td>
<td>
<p>significance levels for goodness-of-fit and independence tests, respectively, in element refinement or splitting process. <code>alphad</code> is irrelevant for univariate data <code>x</code> with <code>d = 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object comprised of the split dimension(s) or <code>NA</code> for no split, and the resulting child element parameters is returned.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
