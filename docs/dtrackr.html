<!DOCTYPE html><html lang="en-GB"><head><title>Help for package dtrackr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dtrackr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dtrackr-package'><p>dtrackr: Track your Data Pipelines</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_count.trackr_df'><p>dplyr modifying operations</p></a></li>
<li><a href='#add_tally'><p>dplyr modifying operations</p></a></li>
<li><a href='#anti_join.trackr_df'><p>Anti join</p></a></li>
<li><a href='#arrange.trackr_df'><p>dplyr modifying operations</p></a></li>
<li><a href='#bind_cols'><p>Set operations</p></a></li>
<li><a href='#bind_rows'><p>Set operations</p></a></li>
<li><a href='#capture_exclusions'><p>Start capturing exclusions on a tracked dataframe.</p></a></li>
<li><a href='#comment'><p>Add a generic comment to the dtrackr history graph</p></a></li>
<li><a href='#count_subgroup'><p>Add a subgroup count to the dtrackr history graph</p></a></li>
<li><a href='#distinct.trackr_df'><p>Distinct values of data</p></a></li>
<li><a href='#dot2svg'><p>Convert <code>Graphviz</code> dot content to a SVG</p></a></li>
<li><a href='#exclude_all'><p>Exclude all items matching one or more criteria</p></a></li>
<li><a href='#excluded'><p>Get the dtrackr excluded data record</p></a></li>
<li><a href='#filter.trackr_df'><p>Filtering data</p></a></li>
<li><a href='#flowchart'><p>Flowchart output</p></a></li>
<li><a href='#full_join.trackr_df'><p>Full join</p></a></li>
<li><a href='#group_by.trackr_df'><p>Stratifying your analysis</p></a></li>
<li><a href='#group_modify.trackr_df'><p>Group-wise modification of data and complex operations</p></a></li>
<li><a href='#history'><p>Get the dtrackr history graph</p></a></li>
<li><a href='#include_any'><p>Include any items matching a criteria</p></a></li>
<li><a href='#inner_join.trackr_df'><p>Inner joins</p></a></li>
<li><a href='#intersect.trackr_df'><p>Set operations</p></a></li>
<li><a href='#left_join.trackr_df'><p>Left join</p></a></li>
<li><a href='#mutate.trackr_df'><p>dplyr modifying operations</p></a></li>
<li><a href='#nest_join.trackr_df'><p>Nest join</p></a></li>
<li><a href='#p_add_count'><p>dplyr modifying operations</p></a></li>
<li><a href='#p_add_tally'><p>dplyr modifying operations</p></a></li>
<li><a href='#p_anti_join'><p>Anti join</p></a></li>
<li><a href='#p_arrange'><p>dplyr modifying operations</p></a></li>
<li><a href='#p_bind_cols'><p>Set operations</p></a></li>
<li><a href='#p_bind_rows'><p>Set operations</p></a></li>
<li><a href='#p_capture_exclusions'><p>Start capturing exclusions on a tracked dataframe.</p></a></li>
<li><a href='#p_clear'><p>Clear the dtrackr history graph</p></a></li>
<li><a href='#p_comment'><p>Add a generic comment to the dtrackr history graph</p></a></li>
<li><a href='#p_copy'><p>Copy the dtrackr history graph from one dataframe to another</p></a></li>
<li><a href='#p_count_if'><p>Simple count_if dplyr summary function</p></a></li>
<li><a href='#p_count_subgroup'><p>Add a subgroup count to the dtrackr history graph</p></a></li>
<li><a href='#p_distinct'><p>Distinct values of data</p></a></li>
<li><a href='#p_exclude_all'><p>Exclude all items matching one or more criteria</p></a></li>
<li><a href='#p_excluded'><p>Get the dtrackr excluded data record</p></a></li>
<li><a href='#p_filter'><p>Filtering data</p></a></li>
<li><a href='#p_flowchart'><p>Flowchart output</p></a></li>
<li><a href='#p_full_join'><p>Full join</p></a></li>
<li><a href='#p_get'><p>Get the dtrackr history graph</p></a></li>
<li><a href='#p_get_as_dot'><p>DOT output</p></a></li>
<li><a href='#p_group_by'><p>Stratifying your analysis</p></a></li>
<li><a href='#p_group_modify'><p>Group-wise modification of data and complex operations</p></a></li>
<li><a href='#p_include_any'><p>Include any items matching a criteria</p></a></li>
<li><a href='#p_inner_join'><p>Inner joins</p></a></li>
<li><a href='#p_intersect'><p>Set operations</p></a></li>
<li><a href='#p_left_join'><p>Left join</p></a></li>
<li><a href='#p_mutate'><p>dplyr modifying operations</p></a></li>
<li><a href='#p_nest_join'><p>Nest join</p></a></li>
<li><a href='#p_pause'><p>Pause tracking the data frame.</p></a></li>
<li><a href='#p_pivot_longer'><p>Reshaping data using <code>tidyr::pivot_longer</code></p></a></li>
<li><a href='#p_pivot_wider'><p>Reshaping data using <code>tidyr::pivot_wider</code></p></a></li>
<li><a href='#p_reframe'><p>Summarise a data set</p></a></li>
<li><a href='#p_relocate'><p>dplyr modifying operations</p></a></li>
<li><a href='#p_rename'><p>dplyr modifying operations</p></a></li>
<li><a href='#p_rename_with'><p>dplyr modifying operations</p></a></li>
<li><a href='#p_resume'><p>Resume tracking the data frame.</p></a></li>
<li><a href='#p_right_join'><p>Right join</p></a></li>
<li><a href='#p_select'><p>dplyr modifying operations</p></a></li>
<li><a href='#p_semi_join'><p>Semi join</p></a></li>
<li><a href='#p_set'><p>Set the dtrackr history graph</p></a></li>
<li><a href='#p_setdiff'><p>Set operations</p></a></li>
<li><a href='#p_slice'><p>Slice operations</p></a></li>
<li><a href='#p_slice_head'><p>Slice operations</p></a></li>
<li><a href='#p_slice_max'><p>Slice operations</p></a></li>
<li><a href='#p_slice_min'><p>Slice operations</p></a></li>
<li><a href='#p_slice_sample'><p>Slice operations</p></a></li>
<li><a href='#p_slice_tail'><p>Slice operations</p></a></li>
<li><a href='#p_status'><p>Add a summary to the dtrackr history graph</p></a></li>
<li><a href='#p_summarise'><p>Summarise a data set</p></a></li>
<li><a href='#p_tagged'><p>Retrieve tagged data in the history graph</p></a></li>
<li><a href='#p_track'><p>Start tracking the dtrackr history graph</p></a></li>
<li><a href='#p_transmute'><p>dplyr modifying operations</p></a></li>
<li><a href='#p_ungroup'><p>Remove a stratification from a data set</p></a></li>
<li><a href='#p_union'><p>Set operations</p></a></li>
<li><a href='#p_union_all'><p>Set operations</p></a></li>
<li><a href='#p_untrack'><p>Remove tracking from the dataframe</p></a></li>
<li><a href='#pause'><p>Pause tracking the data frame.</p></a></li>
<li><a href='#pivot_longer.trackr_df'><p>Reshaping data using <code>tidyr::pivot_longer</code></p></a></li>
<li><a href='#pivot_wider.trackr_df'><p>Reshaping data using <code>tidyr::pivot_wider</code></p></a></li>
<li><a href='#plot.trackr_graph'><p>Plots a history graph as html</p></a></li>
<li><a href='#print.trackr_graph'><p>Print a history graph to the console</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reframe.trackr_df'><p>Summarise a data set</p></a></li>
<li><a href='#relocate.trackr_df'><p>dplyr modifying operations</p></a></li>
<li><a href='#rename_with.trackr_df'><p>dplyr modifying operations</p></a></li>
<li><a href='#rename.trackr_df'><p>dplyr modifying operations</p></a></li>
<li><a href='#resume'><p>Resume tracking the data frame.</p></a></li>
<li><a href='#right_join.trackr_df'><p>Right join</p></a></li>
<li><a href='#save_dot'><p>Save DOT content to a file</p></a></li>
<li><a href='#select.trackr_df'><p>dplyr modifying operations</p></a></li>
<li><a href='#semi_join.trackr_df'><p>Semi join</p></a></li>
<li><a href='#setdiff.trackr_df'><p>Set operations</p></a></li>
<li><a href='#slice_head.trackr_df'><p>Slice operations</p></a></li>
<li><a href='#slice_max.trackr_df'><p>Slice operations</p></a></li>
<li><a href='#slice_min.trackr_df'><p>Slice operations</p></a></li>
<li><a href='#slice_sample.trackr_df'><p>Slice operations</p></a></li>
<li><a href='#slice_tail.trackr_df'><p>Slice operations</p></a></li>
<li><a href='#slice.trackr_df'><p>Slice operations</p></a></li>
<li><a href='#status'><p>Add a summary to the dtrackr history graph</p></a></li>
<li><a href='#std_size'><p>Standard paper sizes</p></a></li>
<li><a href='#summarise.trackr_df'><p>Summarise a data set</p></a></li>
<li><a href='#tagged'><p>Retrieve tagged data in the history graph</p></a></li>
<li><a href='#track'><p>Start tracking the dtrackr history graph</p></a></li>
<li><a href='#transmute.trackr_df'><p>dplyr modifying operations</p></a></li>
<li><a href='#ungroup.trackr_df'><p>Remove a stratification from a data set</p></a></li>
<li><a href='#union_all.trackr_df'><p>Set operations</p></a></li>
<li><a href='#union.trackr_df'><p>Set operations</p></a></li>
<li><a href='#untrack'><p>Remove tracking from the dataframe</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Track your Data Pipelines</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Track and
    document 'dplyr' data pipelines. As you filter, mutate, and join your
    way through a data set, 'dtrackr' seamlessly keeps track of your data
    flow and makes publication ready documentation of a data pipeline simple.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.1.0), glue, htmltools, magrittr, rlang, rsvg,
stringr, tibble, tidyr, utils, V8, fs, purrr, base64enc,
pdftools, png, lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, here, knitr, rmarkdown, tidyselect, devtools,
testthat (&ge; 2.1.0), rstudioapi, survival, ggplot2, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2.9003</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://terminological.github.io/dtrackr/index.html">https://terminological.github.io/dtrackr/index.html</a>,
<a href="https://github.com/terminological/dtrackr">https://github.com/terminological/dtrackr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/terminological/dtrackr/issues">https://github.com/terminological/dtrackr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-21 08:33:55 UTC; vp22681</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert Challen <a href="https://orcid.org/0000-0002-5504-7768"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert Challen &lt;rob.challen@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-21 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dtrackr-package'>dtrackr: Track your Data Pipelines</h2><span id='topic+dtrackr'></span><span id='topic+dtrackr-package'></span>

<h3>Description</h3>

<p>Track and document 'dplyr' data pipelines. As you filter, mutate, and join your way through a data set, 'dtrackr' seamlessly keeps track of your data flow and makes publication ready documentation of a data pipeline simple.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Robert Challen <a href="mailto:rob.challen@bristol.ac.uk">rob.challen@bristol.ac.uk</a> (<a href="https://orcid.org/0000-0002-5504-7768">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://terminological.github.io/dtrackr/index.html">https://terminological.github.io/dtrackr/index.html</a>
</p>
</li>
<li> <p><a href="https://github.com/terminological/dtrackr">https://github.com/terminological/dtrackr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/terminological/dtrackr/issues">https://github.com/terminological/dtrackr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_count.trackr_df'>dplyr modifying operations</h2><span id='topic+add_count.trackr_df'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
add_count(x, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_count.trackr_df_+3A_x">x</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="add_count.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables to group
by.
Named arguments passed on to <code><a href="dplyr.html#topic+count">dplyr::add_count</a></code></p>

<dl>
<dt><code>wt</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</dd>
<dt><code>sort</code></dt><dd><p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</dd>
<dt><code>.drop</code></dt><dd><p>Handling of factor levels that don't appear in the data, passed
on to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>
<p>For <code>count()</code>: if <code>FALSE</code> will include counts for empty groups (i.e. for
levels of factors that don't exist in the data).
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> For <code>add_count()</code>: deprecated since it
can't actually affect the output.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="add_count.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="add_count.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="add_count.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::add_count()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# add_count
# adding in a count or tally column as a new column
iris %&gt;%
  track() %&gt;%
  add_count(Species, name="new_count_total",
            .messages="{.new_cols}",
            # .messages="{.cols}",
            .headline="New columns from add_count:") %&gt;%
  history()

# add_tally
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  dtrackr::add_tally(wt=Petal.Length, name="new_tally_total",
            .messages="{.new_cols}",
            .headline="New columns from add_tally:") %&gt;%
  history()



</code></pre>

<hr>
<h2 id='add_tally'>dplyr modifying operations</h2><span id='topic+add_tally'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_tally(x, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_tally_+3A_x">x</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="add_tally_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables to group
by.
Named arguments passed on to <code><a href="dplyr.html#topic+count">dplyr::add_tally</a></code></p>

<dl>
<dt><code>wt</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</dd>
<dt><code>sort</code></dt><dd><p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</dd>
<dt><code>.drop</code></dt><dd><p>Handling of factor levels that don't appear in the data, passed
on to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>
<p>For <code>count()</code>: if <code>FALSE</code> will include counts for empty groups (i.e. for
levels of factors that don't exist in the data).
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> For <code>add_count()</code>: deprecated since it
can't actually affect the output.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="add_tally_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="add_tally_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="add_tally_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::add_tally()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# add_count
# adding in a count or tally column as a new column
iris %&gt;%
  track() %&gt;%
  add_count(Species, name="new_count_total",
            .messages="{.new_cols}",
            # .messages="{.cols}",
            .headline="New columns from add_count:") %&gt;%
  history()

# add_tally
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  dtrackr::add_tally(wt=Petal.Length, name="new_tally_total",
            .messages="{.new_cols}",
            .headline="New columns from add_tally:") %&gt;%
  history()



</code></pre>

<hr>
<h2 id='anti_join.trackr_df'>Anti join</h2><span id='topic+anti_join.trackr_df'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
anti_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS", "{.count.out} not matched"),
  .headline = "Semi join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anti_join.trackr_df_+3A_x">x</code>, <code id="anti_join.trackr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="anti_join.trackr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="anti_join.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="anti_join.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::anti_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Anti join
join = lhs %&gt;% anti_join(rhs, by="name") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history() %&gt;% print()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='arrange.trackr_df'>dplyr modifying operations</h2><span id='topic+arrange.trackr_df'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
arrange(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="arrange.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>

<p>Named arguments passed on to <code><a href="dplyr.html#topic+arrange">dplyr::arrange</a></code></p>

<dl>
<dt><code>.by_group</code></dt><dd><p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</dd>
<dt><code>.locale</code></dt><dd><p>The locale to sort character vectors in.
</p>

<ul>
<li><p> If <code>NULL</code>, the default, uses the <code>"C"</code> locale unless the
<code>dplyr.legacy_locale</code> global option escape hatch is active. See the
<a href="dplyr.html#topic+dplyr-locale">dplyr-locale</a> help page for more details.
</p>
</li>
<li><p> If a single string from <code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code> is supplied, then
this will be used as the locale to sort with. For example, <code>"en"</code> will
sort with the American English locale. This requires the stringi package.
</p>
</li>
<li><p> If <code>"C"</code> is supplied, then character vectors will always be sorted in the
C locale. This does not require stringi and is often much faster than
supplying a locale identifier.
</p>
</li></ul>

<p>The C locale is not the same as English locales, such as <code>"en"</code>,
particularly when it comes to data containing a mix of upper and lower case
letters. This is explained in more detail on the <a href="dplyr.html#topic+dplyr-locale">locale</a>
help page under the <code style="white-space: pre;">&#8288;Default locale&#8288;</code> section.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="arrange.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="arrange.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="arrange.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::arrange()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# arrange
# In this case we sort the data descending and show the first value
# is the same as the maximum value.
iris %&gt;%
  track() %&gt;%
  arrange(
    desc(Petal.Width),
    .messages="{.count} items, columns: {.cols}",
    .headline="Reordered dataframe:") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='bind_cols'>Set operations</h2><span id='topic+bind_cols'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_cols(
  ...,
  .messages = "{.count.out} in combined set",
  .headline = "Bind columns"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_cols_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine
Named arguments passed on to <code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols</a></code></p>

<dl>
<dt><code>.name_repair</code></dt><dd><p>One of <code>"unique"</code>, <code>"universal"</code>, or
<code>"check_unique"</code>. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for the meaning of these
options.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bind_cols_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="bind_cols_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::bind_cols()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='bind_rows'>Set operations</h2><span id='topic+bind_rows'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_rows(..., .messages = "{.count.out} in union", .headline = "Union")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_rows_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine
Named arguments passed on to <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows</a></code></p>

<dl>
<dt><code>.id</code></dt><dd><p>The name of an optional identifier column. Provide a string to
create an output column that identifies each input. The column will use
names if available, otherwise it will use positions.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bind_rows_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="bind_rows_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::bind_rows()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='capture_exclusions'>Start capturing exclusions on a tracked dataframe.</h2><span id='topic+capture_exclusions'></span>

<h3>Description</h3>

<p>Start capturing exclusions on a tracked dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_exclusions(.data, .capture = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capture_exclusions_+3A_.data">.data</code></td>
<td>
<p>a tracked dataframe</p>
</td></tr>
<tr><td><code id="capture_exclusions_+3A_.capture">.capture</code></td>
<td>
<p>Should we capture exclusions (things removed from the data
set). This is useful for debugging data issues but comes at a significant
cost. Defaults to the value of <code>getOption("dtrackr.exclusions")</code> or
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with the exclusions flag set (or cleared if
<code>.capture=FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
tmp = iris %&gt;% track() %&gt;% capture_exclusions()
tmp %&gt;% filter(Species!="versicolor") %&gt;% history()
</code></pre>

<hr>
<h2 id='comment'>Add a generic comment to the dtrackr history graph</h2><span id='topic+comment'></span>

<h3>Description</h3>

<p>A comment can be any kind of note and is added once for every current
grouping as defined by the <code>.message</code> field. It can be made context specific
by including variables such as {.count} and {.total} in <code>.message</code> which
refer to the grouped and ungrouped counts at this current stage of the
pipeline respectively. It can also pull in any global variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comment(
  .data,
  .messages = .defaultMessage(),
  .headline = .defaultHeadline(),
  .type = "info",
  .asOffshoot = (.type == "exclusion"),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comment_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="comment_+3A_.messages">.messages</code></td>
<td>
<p>a character vector of glue specifications. A glue
specification can refer to any grouping variables of .data, or any
variables defined in the calling environment, the {.total} of all rows,
the {.count} variable which is the count in each group and {.strata} a
description of the group</p>
</td></tr>
<tr><td><code id="comment_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, or any variables defined in the calling environment, or the
{.total} variable (which is <code>nrow(.data)</code>) and {.strata} which is a
description of the grouping</p>
</td></tr>
<tr><td><code id="comment_+3A_.type">.type</code></td>
<td>
<p>one of &quot;info&quot;,&quot;...,&quot;exclusion&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="comment_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>do you want this comment to be an offshoot of the main
flow (default = FALSE).</p>
</td></tr>
<tr><td><code id="comment_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same .data dataframe with the history graph updated with the comment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
iris %&gt;% track() %&gt;% comment("hello {.total} rows") %&gt;% history()
</code></pre>

<hr>
<h2 id='count_subgroup'>Add a subgroup count to the dtrackr history graph</h2><span id='topic+count_subgroup'></span>

<h3>Description</h3>

<p>A frequent use case for more detailed description is to have a subgroup count
within a flowchart. This works best for factor subgroup columns but other
data will be converted to a factor automatically. The count of the items in
each subgroup is added as a new stage in the flowchart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_subgroup(
  .data,
  .subgroup,
  ...,
  .messages = .defaultCountSubgroup(),
  .headline = .defaultHeadline(),
  .type = "info",
  .asOffshoot = FALSE,
  .tag = NULL,
  .maxsubgroups = .defaultMaxSupportedGroupings()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_subgroup_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="count_subgroup_+3A_.subgroup">.subgroup</code></td>
<td>
<p>a column with a small number of levels (e.g. a factor)</p>
</td></tr>
<tr><td><code id="count_subgroup_+3A_...">...</code></td>
<td>
<p>passed to <code style="white-space: pre;">&#8288;base::factor(subgroup values, ...)&#8288;</code> to allow reordering
of levels etc.</p>
</td></tr>
<tr><td><code id="count_subgroup_+3A_.messages">.messages</code></td>
<td>
<p>a character vector of glue specifications. A glue
specification can refer to anything from the calling environment,
{.subgroup} for the subgroup column name and {.name} for the subgroup
column value, {.count} for the subgroup column count, {.subtotal} for
the current stratification grouping count and {.total} for the whole
dataset count</p>
</td></tr>
<tr><td><code id="count_subgroup_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, {.subtotal} for the current grouping count, or any variables
defined in the calling environment</p>
</td></tr>
<tr><td><code id="count_subgroup_+3A_.type">.type</code></td>
<td>
<p>one of &quot;info&quot;,&quot;exclusion&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="count_subgroup_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>do you want this comment to be an offshoot of the main
flow (default = FALSE).</p>
</td></tr>
<tr><td><code id="count_subgroup_+3A_.tag">.tag</code></td>
<td>
<p>if you want to use the summary data from this step in the future
then give it a name with .tag.</p>
</td></tr>
<tr><td><code id="count_subgroup_+3A_.maxsubgroups">.maxsubgroups</code></td>
<td>
<p>the maximum number of discrete values allowed in
.subgroup is configurable with
<code>options("dtrackr.max_supported_groupings"=XX)</code>. The default is 16. Large
values produce unwieldy flow charts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same .data dataframe with the history graph updated with a
subgroup count as a new stage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
survival::cgd %&gt;% track() %&gt;% group_by(treat) %&gt;%
  count_subgroup(center) %&gt;% history()
</code></pre>

<hr>
<h2 id='distinct.trackr_df'>Distinct values of data</h2><span id='topic+distinct.trackr_df'></span>

<h3>Description</h3>

<p>Distinct acts in the same way as in <code>dplyr::distinct</code>. Prior to the operation
the size of the group is calculated {.count.in} and after the operation the
output size {.count.out} The group {.strata} is also available (if
grouped) for reporting. See <code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
distinct(
  .data,
  ...,
  .messages = "removing {.count.in-.count.out} duplicates",
  .headline = .defaultHeadline(),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distinct.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="distinct.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Optional variables to
use when determining uniqueness. If there are multiple rows for a given
combination of inputs, only the first row will be preserved. If omitted,
will use all variables in the data frame.
Named arguments passed on to <code><a href="dplyr.html#topic+distinct">dplyr::distinct</a></code></p>

<dl>
<dt><code>.keep_all</code></dt><dd><p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="distinct.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="distinct.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="distinct.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with distinct values and history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::distinct()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = bind_rows(iris %&gt;% track(), iris %&gt;% track() %&gt;% filter(Petal.Length &gt; 5))
tmp %&gt;% group_by(Species) %&gt;% distinct() %&gt;% history()
</code></pre>

<hr>
<h2 id='dot2svg'>Convert <code>Graphviz</code> dot content to a SVG</h2><span id='topic+dot2svg'></span>

<h3>Description</h3>

<p>Convert a <code>graphviz</code> dot digraph as string to <code>SVG</code> as string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dot2svg(dot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dot2svg_+3A_dot">dot</code></td>
<td>
<p>a <code>graphviz</code> dot string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the SVG as a string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dot2svg("digraph { A-&gt;B }")
</code></pre>

<hr>
<h2 id='exclude_all'>Exclude all items matching one or more criteria</h2><span id='topic+exclude_all'></span>

<h3>Description</h3>

<p>Apply a set of filters and summarise the actions of the filter to the <code>dtrackr</code>
history graph. Because of the ... filter specification, all parameters MUST BE
NAMED. The filters work in an combinatorial manner, i.e. the results EXCLUDE ALL
rows that match any of the criteria. If <code>na.rm = TRUE</code> they also remove
anything that cannot be evaluated by any criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclude_all(
  .data,
  ...,
  .headline = .defaultHeadline(),
  na.rm = FALSE,
  .type = "exclusion",
  .asOffshoot = TRUE,
  .stage = (if (is.null(.tag)) "" else .tag),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exclude_all_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="exclude_all_+3A_...">...</code></td>
<td>
<p>a dplyr filter specification as a set of formulae where the LHS are
predicates to test the data set against, items that match any of the predicates will
be excluded. The RHS is a glue specification, defining the message, to be
entered in the history graph for each predicate. This can refer to grouping variables
variables from the environment and {.excluded} and {.matched} or
{.missing} (excluded = matched+missing), {.count} and {.total} -
group and overall counts respectively, e.g. &quot;excluding {.matched} items
and {.missing} with missing values&quot;.</p>
</td></tr>
<tr><td><code id="exclude_all_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, or any variables defined in the calling environment</p>
</td></tr>
<tr><td><code id="exclude_all_+3A_na.rm">na.rm</code></td>
<td>
<p>(default FALSE) if the filter cannot be evaluated for a row
count that row as missing and either exclude it (TRUE) or don't exclude it
(FALSE)</p>
</td></tr>
<tr><td><code id="exclude_all_+3A_.type">.type</code></td>
<td>
<p>default &quot;exclusion&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="exclude_all_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>do you want this comment to be an offshoot of the main
flow (default = TRUE).</p>
</td></tr>
<tr><td><code id="exclude_all_+3A_.stage">.stage</code></td>
<td>
<p>a name for this step in the pathway</p>
</td></tr>
<tr><td><code id="exclude_all_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the filtered .data dataframe with the history graph updated with the
summary of excluded items as a new offshoot stage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

iris %&gt;% track() %&gt;% capture_exclusions() %&gt;% exclude_all(
      Petal.Length &gt; 5 ~ "{.excluded} long ones",
      Petal.Length &lt; 2 ~ "{.excluded} short ones"
) %&gt;% history()


# simultaneous evaluation of criteria:
data.frame(a = 1:10) %&gt;%
  track() %&gt;%
  exclude_all(
    # These two criteria identify the same value and one item is excluded
    a &gt; 9 ~ "{.excluded} value &gt; 9",
    a == max(a) ~ "{.excluded} max value",
  ) %&gt;%
  status() %&gt;%
  history()

# the behaviour is equivalent to the inverse of dplyr's filter function:
data.frame(a=1:10) %&gt;%
  dplyr::filter(a &lt;= 9, a != max(a)) %&gt;%
  nrow()

# step-wise evaluation of criteria results in a different output
data.frame(a = 1:10) %&gt;%
  track() %&gt;%
  # Performing the same exclusion sequentially results in 2 items
  # being excluded as the criteria no longer identify the same
  # item.
  exclude_all(a &gt; 9 ~ "{.excluded} value &gt; 9") %&gt;%
  exclude_all(a == max(a) ~ "{.excluded} max value") %&gt;%
  status() %&gt;%
  history()

# the behaviour is equivalent to the inverse of dplyr's filter function:
data.frame(a=1:10) %&gt;%
  dplyr::filter(a &lt;= 9) %&gt;%
  dplyr::filter(a != max(a)) %&gt;%
  nrow()

</code></pre>

<hr>
<h2 id='excluded'>Get the dtrackr excluded data record</h2><span id='topic+excluded'></span>

<h3>Description</h3>

<p>Get the dtrackr excluded data record
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excluded(.data, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="excluded_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="excluded_+3A_simplify">simplify</code></td>
<td>
<p>return a single summary dataframe of all exclusions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new dataframe of the excluded data up to this point in the workflow. This dataframe is by default flattened, but if <code>.simplify=FALSE</code> has a nested structure containing records excluded at each part of the pipeline.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
tmp = iris %&gt;% track() %&gt;% capture_exclusions()
tmp %&gt;% exclude_all(
   Petal.Length &gt; 5.8 ~ "{.excluded} long ones",
   Petal.Length &lt; 1.3 ~ "{.excluded} short ones",
   .stage = "petal length exclusion"
) %&gt;% excluded()
</code></pre>

<hr>
<h2 id='filter.trackr_df'>Filtering data</h2><span id='topic+filter.trackr_df'></span>

<h3>Description</h3>

<p>Filter acts in the same way as in <code>dplyr</code> where predicates which evaluate to
TRUE act to select items to include, and items for which the predicate cannot
be evaluated are excluded. For tracking prior to the filter operation the
size of each group is calculated {.count.in} and after the operation the
output size of each group {.count.out}. The grouping {.strata} is also
available (if grouped) for reporting. See <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
filter(
  .data,
  ...,
  .messages = "excluded {.excluded} items",
  .headline = .defaultHeadline(),
  .type = "exclusion",
  .asOffshoot = (.type == "exclusion"),
  .stage = (if (is.null(.tag)) "" else .tag),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="filter.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>.data</code>. If multiple expressions are included, they are combined with the
<code>&amp;</code> operator. Only rows for which all conditions evaluate to <code>TRUE</code> are
kept.
Named arguments passed on to <code><a href="dplyr.html#topic+filter">dplyr::filter</a></code></p>

<dl>
<dt><code>.by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="filter.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="filter.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="filter.trackr_df_+3A_.type">.type</code></td>
<td>
<p>the format type of the action typically an exclusion</p>
</td></tr>
<tr><td><code id="filter.trackr_df_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>if the type is exclusion, <code>.asOffshoot</code> places the
information box outside of the main flow, as an exclusion.</p>
</td></tr>
<tr><td><code id="filter.trackr_df_+3A_.stage">.stage</code></td>
<td>
<p>a name for this step in the pathway</p>
</td></tr>
<tr><td><code id="filter.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with <code>.tag</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the filtered <code>.data</code> dataframe with history graph updated
</p>


<h3>See Also</h3>

<p>dplyr::filter()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% track() %&gt;% group_by(Species)
tmp %&gt;% filter(Petal.Length &gt; 5) %&gt;% history()
</code></pre>

<hr>
<h2 id='flowchart'>Flowchart output</h2><span id='topic+flowchart'></span>

<h3>Description</h3>

<p>Generate a flowchart of the history of the dataframe(s), with all the tracked
data pipeline as stages in the flowchart. Multiple dataframes can be plotted
together in which case an attempt is made to determine which parts are
common.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flowchart(
  .data,
  filename = NULL,
  size = std_size$full,
  maxWidth = size$width,
  maxHeight = size$height,
  formats = c("dot", "png", "pdf", "svg"),
  defaultToHTML = TRUE,
  landscape = size$rot != 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flowchart_+3A_.data">.data</code></td>
<td>
<p>the tracked dataframe(s) either as a single dataframe or as a
list of dataframes.</p>
</td></tr>
<tr><td><code id="flowchart_+3A_filename">filename</code></td>
<td>
<p>a file name which will be where the formatted flowcharts are
saved. If no extension is specified the output formats are determined by
the <code>formats</code> parameter.</p>
</td></tr>
<tr><td><code id="flowchart_+3A_size">size</code></td>
<td>
<p>a named list with 3 elements, length and width in inches and
rotation. A predefined set of standard sizes are available in the
<a href="#topic+std_size">std_size</a> object.</p>
</td></tr>
<tr><td><code id="flowchart_+3A_maxwidth">maxWidth</code></td>
<td>
<p>a width (on the paper) in inches if <code>size</code> is not defined</p>
</td></tr>
<tr><td><code id="flowchart_+3A_maxheight">maxHeight</code></td>
<td>
<p>a height (on the paper) in inches if <code>size</code> is not defined</p>
</td></tr>
<tr><td><code id="flowchart_+3A_formats">formats</code></td>
<td>
<p>some of <code>pdf</code>,<code>dot</code>,<code>svg</code>,<code>png</code>,<code>ps</code></p>
</td></tr>
<tr><td><code id="flowchart_+3A_defaulttohtml">defaultToHTML</code></td>
<td>
<p>if the correct output format is not easy to determine
from the context, default providing <code>HTML</code> (TRUE) or to embedding the <code>PNG</code> (FALSE)</p>
</td></tr>
<tr><td><code id="flowchart_+3A_landscape">landscape</code></td>
<td>
<p>rotate the output by 270 degrees into a landscape format.
<code>maxWidth</code> and <code>maxHeight</code> still apply and refer to the paper width to fit
the flowchart into after rotation. (you might need to flip width and height)</p>
</td></tr>
<tr><td><code id="flowchart_+3A_...">...</code></td>
<td>
<p>other parameters passed onto either <code>p_get_as_dot()</code>, notable ones are
<code>fill</code> (background colour e.g. <code>lightgrey</code>), <code>fontsize</code> (in points),
<code>colour</code> (font colour)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the nature of the flowchart output depends on the context in which
the function is called. It will be some form of browse-able html output if
called from an interactive session or a <code>PNG</code>/<code>PDF</code> link if in <code>knitr</code> and
knitting latex or word type outputs, if file name is specified the output
will also be saved at the given location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% track() %&gt;% comment(.tag = "step1") %&gt;% filter(Species!="versicolor")
tmp %&gt;% group_by(Species) %&gt;% comment(.tag="step2") %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='full_join.trackr_df'>Full join</h2><span id='topic+full_join.trackr_df'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
full_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS",
    "{.count.out} in linked set"),
  .headline = "Full join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="full_join.trackr_df_+3A_x">x</code>, <code id="full_join.trackr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="full_join.trackr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>suffix</code></dt><dd><p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</dd>
<dt><code>keep</code></dt><dd><p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
<dt><code>multiple</code></dt><dd><p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</dd>
<dt><code>unmatched</code></dt><dd><p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</dd>
<dt><code>relationship</code></dt><dd><p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="full_join.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="full_join.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::full_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Full join
join = lhs %&gt;% full_join(rhs, by="name", multiple = "all") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()

</code></pre>

<hr>
<h2 id='group_by.trackr_df'>Stratifying your analysis</h2><span id='topic+group_by.trackr_df'></span>

<h3>Description</h3>

<p>Grouping a data set acts in the normal way. When tracking a dataframe
sometimes a <code>group_by()</code> operation will create a lot of groups. This happens
for example if you are doing a <code>group_by()</code>, <code>summarise()</code> step that is
aggregating data on a fine scale, e.g. by day in a time-series. This is
generally a terrible idea when tracking a dataframe as the resulting
flowchart will have many many branches and be illegible. <code>dtrackr</code> will detect this issue and
pause tracking the dataframe with a warning. It is up to the user to the
<code>resume()</code> tracking when the large number of groups have been resolved e.g.
using a <code>dplyr::ungroup()</code>. This limit is configurable with
<code>options("dtrackr.max_supported_groupings"=XX)</code>. The default is 16. See
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
group_by(
  .data,
  ...,
  .messages = "stratify by {.cols}",
  .headline = NULL,
  .tag = NULL,
  .maxgroups = .defaultMaxSupportedGroupings()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_by.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="group_by.trackr_df_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.
Named arguments passed on to <code><a href="dplyr.html#topic+group_by">dplyr::group_by</a></code></p>

<dl>
<dt><code>.add</code></dt><dd><p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</dd>
<dt><code>.drop</code></dt><dd><p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</dd>
<dt><code>x</code></dt><dd><p>A <code><a href="dplyr.html#topic+tbl">tbl()</a></code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="group_by.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.cols} which is the columns that are being grouped by.</p>
</td></tr>
<tr><td><code id="group_by.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, or {.cols}.</p>
</td></tr>
<tr><td><code id="group_by.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
<tr><td><code id="group_by.trackr_df_+3A_.maxgroups">.maxgroups</code></td>
<td>
<p>the maximum number of subgroups allowed before the tracking
is paused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data but grouped.
</p>


<h3>See Also</h3>

<p>dplyr::group_by()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% track() %&gt;% group_by(Species, .messages="stratify by {.cols}")
tmp %&gt;% comment("{.strata}") %&gt;% history()
</code></pre>

<hr>
<h2 id='group_modify.trackr_df'>Group-wise modification of data and complex operations</h2><span id='topic+group_modify.trackr_df'></span>

<h3>Description</h3>

<p>Group modifying a data set acts in the normal way. The internal mechanics of
the modify function are opaque to the history. This means these can be used
to wrap any unsupported operation without losing the history (e.g. <code>df %&gt;% track() %&gt;% group_modify(function(d,...) { d %&gt;% unsupported_operation() })</code>
) Prior to the operation the size of the group is calculated {.count.in}
and after the operation the output size {.count.out} The group {.strata}
is also available (if grouped) for reporting See <code><a href="dplyr.html#topic+group_map">dplyr::group_modify()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
group_modify(
  .data,
  ...,
  .messages = NULL,
  .headline = .defaultHeadline(),
  .type = "modify",
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_modify.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A grouped tibble</p>
</td></tr>
<tr><td><code id="group_modify.trackr_df_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code>
Named arguments passed on to <code><a href="dplyr.html#topic+group_map">dplyr::group_modify</a></code></p>

<dl>
<dt><code>.f</code></dt><dd><p>A function or formula to apply to each group.
</p>
<p>If a <strong>function</strong>, it is used as is. It should have at least 2 formal arguments.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ head(.x)</code>, it is converted to a function.
</p>
<p>In the formula, you can use
</p>

<ul>
<li> <p><code>.</code> or <code>.x</code> to refer to the subset of rows of <code>.tbl</code>
for the given group
</p>
</li>
<li> <p><code>.y</code> to refer to the key, a one row tibble with one column per grouping variable
that identifies the group
</p>
</li></ul>
</dd>
<dt><code>.keep</code></dt><dd><p>are the grouping variables kept in <code>.x</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="group_modify.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="group_modify.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="group_modify.trackr_df_+3A_.type">.type</code></td>
<td>
<p>default &quot;modify&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="group_modify.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformed .data dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::group_modify()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% track() %&gt;% group_by(Species)
tmp %&gt;% group_modify(
      function(d,g,...) { return(tibble::tibble(x=runif(10))) },
      .messages="{.count.in} in, {.count.out} out"
) %&gt;% history()
</code></pre>

<hr>
<h2 id='history'>Get the dtrackr history graph</h2><span id='topic+history'></span>

<h3>Description</h3>

<p>This provides the raw history graph and is not really intended for mainstream use.
The internal structure of the graph is explained below. print and plot S3 methods exist for
the dtrackr history graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>history(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="history_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the history graph. This is a list, of class <code>trackr_graph</code>, containing the following named items:
</p>

<ul>
<li><p> excluded - the data items that have been excluded thus far as a nested dataframe
</p>
</li>
<li><p> tags - a dataframe of tag-value pairs containing the summary of the data at named points in the data flow (see <code><a href="#topic+tagged">tagged()</a></code>)
</p>
</li>
<li><p> nodes - a dataframe of the nodes of the flow chart
</p>
</li>
<li><p> edges - an edge list (as a dataframe) of the relationships between the nodes in the flow chart
</p>
</li>
<li><p> head - the current most recent nodes added into the graph as a dataframe.
</p>
</li></ul>

<p>The format of this data may grow over time but these fields are unlikely to be changed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
graph = iris %&gt;% track() %&gt;% comment("A comment") %&gt;% history()
print(graph)
</code></pre>

<hr>
<h2 id='include_any'>Include any items matching a criteria</h2><span id='topic+include_any'></span>

<h3>Description</h3>

<p>Apply a set of inclusion criteria and record the actions of the
filter to the <code>dtrackr</code> history graph. Because of the ... filter specification,
all parameters MUST BE NAMED. This function is the opposite of
<code><a href="#topic+exclude_all">exclude_all()</a></code> and the filtering criteria work to identify rows to
include i.e. the results include anything that match any of the criteria. If
<code>na.rm=TRUE</code> they also keep anything that cannot be evaluated by the criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>include_any(
  .data,
  ...,
  .headline = .defaultHeadline(),
  na.rm = TRUE,
  .type = "inclusion",
  .asOffshoot = FALSE,
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="include_any_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="include_any_+3A_...">...</code></td>
<td>
<p>a dplyr filter specification as a set of formulae where the LHS
are predicates to test the data set against, items that match at least one
of the predicates will be included. The RHS is a glue specification,
defining the message, to be entered in the history graph for each predicate
matched. This can refer to grouping variables, variables from the
environment and {.included} and {.matched} or {.missing} (included =
matched+missing), {.count} and {.total} - group and overall counts
respectively, e.g. &quot;excluding {.matched} items and {.missing} with
missing values&quot;.</p>
</td></tr>
<tr><td><code id="include_any_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, or any variables defined in the calling environment</p>
</td></tr>
<tr><td><code id="include_any_+3A_na.rm">na.rm</code></td>
<td>
<p>(default TRUE) if the filter cannot be evaluated for a row
count that row as missing and either exclude it (TRUE) or don't exclude it
(FALSE)</p>
</td></tr>
<tr><td><code id="include_any_+3A_.type">.type</code></td>
<td>
<p>default &quot;inclusion&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="include_any_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>do you want this comment to be an offshoot of the main
flow (default = FALSE).</p>
</td></tr>
<tr><td><code id="include_any_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the filtered .data dataframe with the history graph updated with the
summary of included items as a new stage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

iris %&gt;% track() %&gt;% group_by(Species) %&gt;% include_any(
      Petal.Length &gt; 5 ~ "{.included} long ones",
      Petal.Length &lt; 2 ~ "{.included} short ones"
) %&gt;% history()

# simultaneous evaluation of criteria:
data.frame(a = 1:10) %&gt;%
  track() %&gt;%
  include_any(
    # These two criteria identify the same value and one item is excluded
    a &gt; 1 ~ "{.included} value &gt; 1",
    a != min(a) ~ "{.included} everything but the smallest value",
  ) %&gt;%
  status() %&gt;%
  history()

# the behaviour is equivalent to dplyr's filter function:
data.frame(a=1:10) %&gt;%
  dplyr::filter(a &gt; 1, a != min(a)) %&gt;%
  nrow()

# step-wise evaluation of criteria results in a different output
data.frame(a = 1:10) %&gt;%
  track() %&gt;%
  # Performing the same exclusion sequentially results in 2 items
  # being excluded as the criteria no longer identify the same
  # item.
  include_any(a &gt; 1 ~ "{.included} value &gt; 1") %&gt;%
  include_any(a != min(a) ~ "{.included} everything but the smallest value") %&gt;%
  status() %&gt;%
  history()

# the behaviour is equivalent to dplyr's filter function:
data.frame(a=1:10) %&gt;%
  dplyr::filter(a &gt; 1) %&gt;%
  dplyr::filter(a != min(a)) %&gt;%
  nrow()

</code></pre>

<hr>
<h2 id='inner_join.trackr_df'>Inner joins</h2><span id='topic+inner_join.trackr_df'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
inner_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS",
    "{.count.out} in linked set"),
  .headline = "Inner join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner_join.trackr_df_+3A_x">x</code>, <code id="inner_join.trackr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="inner_join.trackr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>suffix</code></dt><dd><p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</dd>
<dt><code>keep</code></dt><dd><p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
<dt><code>multiple</code></dt><dd><p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</dd>
<dt><code>unmatched</code></dt><dd><p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</dd>
<dt><code>relationship</code></dt><dd><p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="inner_join.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="inner_join.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::inner_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Inner join
join = lhs %&gt;% inner_join(rhs, by="name", multiple = "all") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history() %&gt;% print()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='intersect.trackr_df'>Set operations</h2><span id='topic+intersect.trackr_df'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
intersect(
  x,
  y,
  ...,
  .messages = "{.count.out} in intersection",
  .headline = "Intersection"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersect.trackr_df_+3A_x">x</code>, <code id="intersect.trackr_df_+3A_y">y</code></td>
<td>
<p>Vectors to combine.</p>
</td></tr>
<tr><td><code id="intersect.trackr_df_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine</p>
</td></tr>
<tr><td><code id="intersect.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="intersect.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>generics::intersect()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='left_join.trackr_df'>Left join</h2><span id='topic+left_join.trackr_df'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
left_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS",
    "{.count.out} in linked set"),
  .headline = "Left join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="left_join.trackr_df_+3A_x">x</code>, <code id="left_join.trackr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="left_join.trackr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>suffix</code></dt><dd><p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</dd>
<dt><code>keep</code></dt><dd><p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
<dt><code>multiple</code></dt><dd><p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</dd>
<dt><code>unmatched</code></dt><dd><p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</dd>
<dt><code>relationship</code></dt><dd><p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="left_join.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="left_join.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::left_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Left join
join = lhs %&gt;% left_join(rhs, by="name", multiple = "all") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()

</code></pre>

<hr>
<h2 id='mutate.trackr_df'>dplyr modifying operations</h2><span id='topic+mutate.trackr_df'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
mutate(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="mutate.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>

<p>Named arguments passed on to <code><a href="dplyr.html#topic+mutate">dplyr::mutate</a></code></p>

<dl>
<dt><code>.by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.keep</code></dt><dd><p>Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>
</dd>
<dt><code>.before,.after</code></dt><dd><p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, control where new columns
should appear (the default is to add to the right hand side). See
<code><a href="dplyr.html#topic+relocate">relocate()</a></code> for more details.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mutate.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="mutate.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="mutate.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::mutate()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# mutate
# In this example we compare the column names of the input and the
# output to identify the new columns created by the mutate operation as
# the `.new_cols` variable
iris %&gt;%
  track() %&gt;%
  mutate(extra_col = NA_real_,
         .messages="{.new_cols}",
         .headline="Extra columns from mutate:") %&gt;%
  history()

</code></pre>

<hr>
<h2 id='nest_join.trackr_df'>Nest join</h2><span id='topic+nest_join.trackr_df'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+nest_join">dplyr::nest_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
nest_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS", "{.count.out} matched"),
  .headline = "Nest join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nest_join.trackr_df_+3A_x">x</code>, <code id="nest_join.trackr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="nest_join.trackr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+nest_join">dplyr::nest_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>keep</code></dt><dd><p>Should the new list-column contain join keys? The default
will preserve the join keys for inequality joins.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the list-column created by the join. If <code>NULL</code>,
the default, the name of <code>y</code> is used.</p>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
<dt><code>unmatched</code></dt><dd><p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="nest_join.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="nest_join.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::nest_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Nest join
join = lhs %&gt;% nest_join(rhs, by="name") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history() %&gt;% print()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_add_count'>dplyr modifying operations</h2><span id='topic+p_add_count'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_add_count(x, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_add_count_+3A_x">x</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="p_add_count_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables to group
by.
Named arguments passed on to <code><a href="dplyr.html#topic+count">dplyr::add_count</a></code></p>

<dl>
<dt><code>wt</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</dd>
<dt><code>sort</code></dt><dd><p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</dd>
<dt><code>.drop</code></dt><dd><p>Handling of factor levels that don't appear in the data, passed
on to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>
<p>For <code>count()</code>: if <code>FALSE</code> will include counts for empty groups (i.e. for
levels of factors that don't exist in the data).
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> For <code>add_count()</code>: deprecated since it
can't actually affect the output.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_add_count_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_add_count_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_add_count_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::add_count()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# add_count
# adding in a count or tally column as a new column
iris %&gt;%
  track() %&gt;%
  add_count(Species, name="new_count_total",
            .messages="{.new_cols}",
            # .messages="{.cols}",
            .headline="New columns from add_count:") %&gt;%
  history()

# add_tally
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  dtrackr::add_tally(wt=Petal.Length, name="new_tally_total",
            .messages="{.new_cols}",
            .headline="New columns from add_tally:") %&gt;%
  history()



</code></pre>

<hr>
<h2 id='p_add_tally'>dplyr modifying operations</h2><span id='topic+p_add_tally'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_add_tally(x, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_add_tally_+3A_x">x</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="p_add_tally_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables to group
by.</p>
</td></tr>
<tr><td><code id="p_add_tally_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_add_tally_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_add_tally_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::add_tally()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# add_count
# adding in a count or tally column as a new column
iris %&gt;%
  track() %&gt;%
  add_count(Species, name="new_count_total",
            .messages="{.new_cols}",
            # .messages="{.cols}",
            .headline="New columns from add_count:") %&gt;%
  history()

# add_tally
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  dtrackr::add_tally(wt=Petal.Length, name="new_tally_total",
            .messages="{.new_cols}",
            .headline="New columns from add_tally:") %&gt;%
  history()



</code></pre>

<hr>
<h2 id='p_anti_join'>Anti join</h2><span id='topic+p_anti_join'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_anti_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS", "{.count.out} not matched"),
  .headline = "Semi join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_anti_join_+3A_x">x</code>, <code id="p_anti_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_anti_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_anti_join_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="p_anti_join_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::anti_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Anti join
join = lhs %&gt;% anti_join(rhs, by="name") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history() %&gt;% print()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_arrange'>dplyr modifying operations</h2><span id='topic+p_arrange'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_arrange(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_arrange_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_arrange_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>

<p>Named arguments passed on to <code><a href="dplyr.html#topic+arrange">dplyr::arrange</a></code></p>

<dl>
<dt><code>.by_group</code></dt><dd><p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</dd>
<dt><code>.locale</code></dt><dd><p>The locale to sort character vectors in.
</p>

<ul>
<li><p> If <code>NULL</code>, the default, uses the <code>"C"</code> locale unless the
<code>dplyr.legacy_locale</code> global option escape hatch is active. See the
<a href="dplyr.html#topic+dplyr-locale">dplyr-locale</a> help page for more details.
</p>
</li>
<li><p> If a single string from <code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code> is supplied, then
this will be used as the locale to sort with. For example, <code>"en"</code> will
sort with the American English locale. This requires the stringi package.
</p>
</li>
<li><p> If <code>"C"</code> is supplied, then character vectors will always be sorted in the
C locale. This does not require stringi and is often much faster than
supplying a locale identifier.
</p>
</li></ul>

<p>The C locale is not the same as English locales, such as <code>"en"</code>,
particularly when it comes to data containing a mix of upper and lower case
letters. This is explained in more detail on the <a href="dplyr.html#topic+dplyr-locale">locale</a>
help page under the <code style="white-space: pre;">&#8288;Default locale&#8288;</code> section.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_arrange_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_arrange_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_arrange_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::arrange()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# arrange
# In this case we sort the data descending and show the first value
# is the same as the maximum value.
iris %&gt;%
  track() %&gt;%
  arrange(
    desc(Petal.Width),
    .messages="{.count} items, columns: {.cols}",
    .headline="Reordered dataframe:") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='p_bind_cols'>Set operations</h2><span id='topic+p_bind_cols'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_bind_cols(
  ...,
  .messages = "{.count.out} in combined set",
  .headline = "Bind columns"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_bind_cols_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine</p>
</td></tr>
<tr><td><code id="p_bind_cols_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="p_bind_cols_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::bind_cols()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_bind_rows'>Set operations</h2><span id='topic+p_bind_rows'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_bind_rows(..., .messages = "{.count.out} in union", .headline = "Union")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_bind_rows_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine</p>
</td></tr>
<tr><td><code id="p_bind_rows_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="p_bind_rows_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::bind_rows()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_capture_exclusions'>Start capturing exclusions on a tracked dataframe.</h2><span id='topic+p_capture_exclusions'></span>

<h3>Description</h3>

<p>Start capturing exclusions on a tracked dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_capture_exclusions(.data, .capture = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_capture_exclusions_+3A_.data">.data</code></td>
<td>
<p>a tracked dataframe</p>
</td></tr>
<tr><td><code id="p_capture_exclusions_+3A_.capture">.capture</code></td>
<td>
<p>Should we capture exclusions (things removed from the data
set). This is useful for debugging data issues but comes at a significant
cost. Defaults to the value of <code>getOption("dtrackr.exclusions")</code> or
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with the exclusions flag set (or cleared if
<code>.capture=FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
tmp = iris %&gt;% track() %&gt;% capture_exclusions()
tmp %&gt;% filter(Species!="versicolor") %&gt;% history()
</code></pre>

<hr>
<h2 id='p_clear'>Clear the dtrackr history graph</h2><span id='topic+p_clear'></span>

<h3>Description</h3>

<p>This is unlikely to be needed directly and is mostly and internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_clear(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_clear_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with the history graph removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
mtcars %&gt;% track() %&gt;% comment("A comment") %&gt;% p_clear() %&gt;% history()
</code></pre>

<hr>
<h2 id='p_comment'>Add a generic comment to the dtrackr history graph</h2><span id='topic+p_comment'></span>

<h3>Description</h3>

<p>A comment can be any kind of note and is added once for every current
grouping as defined by the <code>.message</code> field. It can be made context specific
by including variables such as {.count} and {.total} in <code>.message</code> which
refer to the grouped and ungrouped counts at this current stage of the
pipeline respectively. It can also pull in any global variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_comment(
  .data,
  .messages = .defaultMessage(),
  .headline = .defaultHeadline(),
  .type = "info",
  .asOffshoot = (.type == "exclusion"),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_comment_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="p_comment_+3A_.messages">.messages</code></td>
<td>
<p>a character vector of glue specifications. A glue
specification can refer to any grouping variables of .data, or any
variables defined in the calling environment, the {.total} of all rows,
the {.count} variable which is the count in each group and {.strata} a
description of the group</p>
</td></tr>
<tr><td><code id="p_comment_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, or any variables defined in the calling environment, or the
{.total} variable (which is <code>nrow(.data)</code>) and {.strata} which is a
description of the grouping</p>
</td></tr>
<tr><td><code id="p_comment_+3A_.type">.type</code></td>
<td>
<p>one of &quot;info&quot;,&quot;...,&quot;exclusion&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="p_comment_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>do you want this comment to be an offshoot of the main
flow (default = FALSE).</p>
</td></tr>
<tr><td><code id="p_comment_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same .data dataframe with the history graph updated with the comment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
iris %&gt;% track() %&gt;% comment("hello {.total} rows") %&gt;% history()
</code></pre>

<hr>
<h2 id='p_copy'>Copy the dtrackr history graph from one dataframe to another</h2><span id='topic+p_copy'></span>

<h3>Description</h3>

<p>Copy the dtrackr history graph from one dataframe to another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_copy(.data, from)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_copy_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="p_copy_+3A_from">from</code></td>
<td>
<p>the dataframe to copy the history graph from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with the history graph of &quot;from&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% p_copy(iris %&gt;% comment("A comment")) %&gt;% history()
</code></pre>

<hr>
<h2 id='p_count_if'>Simple count_if dplyr summary function</h2><span id='topic+p_count_if'></span>

<h3>Description</h3>

<p>Simple count_if dplyr summary function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_count_if(..., na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_count_if_+3A_...">...</code></td>
<td>
<p>expression to be evaluated</p>
</td></tr>
<tr><td><code id="p_count_if_+3A_na.rm">na.rm</code></td>
<td>
<p>ignore NA values?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a count of the number of times the expression evaluated to true, in the current context
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
tmp = iris %&gt;% dplyr::group_by(Species)
tmp %&gt;% dplyr::summarise(long_ones = p_count_if(Petal.Length &gt; 4))
</code></pre>

<hr>
<h2 id='p_count_subgroup'>Add a subgroup count to the dtrackr history graph</h2><span id='topic+p_count_subgroup'></span>

<h3>Description</h3>

<p>A frequent use case for more detailed description is to have a subgroup count
within a flowchart. This works best for factor subgroup columns but other
data will be converted to a factor automatically. The count of the items in
each subgroup is added as a new stage in the flowchart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_count_subgroup(
  .data,
  .subgroup,
  ...,
  .messages = .defaultCountSubgroup(),
  .headline = .defaultHeadline(),
  .type = "info",
  .asOffshoot = FALSE,
  .tag = NULL,
  .maxsubgroups = .defaultMaxSupportedGroupings()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_count_subgroup_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="p_count_subgroup_+3A_.subgroup">.subgroup</code></td>
<td>
<p>a column with a small number of levels (e.g. a factor)</p>
</td></tr>
<tr><td><code id="p_count_subgroup_+3A_...">...</code></td>
<td>
<p>passed to <code style="white-space: pre;">&#8288;base::factor(subgroup values, ...)&#8288;</code> to allow reordering
of levels etc.</p>
</td></tr>
<tr><td><code id="p_count_subgroup_+3A_.messages">.messages</code></td>
<td>
<p>a character vector of glue specifications. A glue
specification can refer to anything from the calling environment,
{.subgroup} for the subgroup column name and {.name} for the subgroup
column value, {.count} for the subgroup column count, {.subtotal} for
the current stratification grouping count and {.total} for the whole
dataset count</p>
</td></tr>
<tr><td><code id="p_count_subgroup_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, {.subtotal} for the current grouping count, or any variables
defined in the calling environment</p>
</td></tr>
<tr><td><code id="p_count_subgroup_+3A_.type">.type</code></td>
<td>
<p>one of &quot;info&quot;,&quot;exclusion&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="p_count_subgroup_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>do you want this comment to be an offshoot of the main
flow (default = FALSE).</p>
</td></tr>
<tr><td><code id="p_count_subgroup_+3A_.tag">.tag</code></td>
<td>
<p>if you want to use the summary data from this step in the future
then give it a name with .tag.</p>
</td></tr>
<tr><td><code id="p_count_subgroup_+3A_.maxsubgroups">.maxsubgroups</code></td>
<td>
<p>the maximum number of discrete values allowed in
.subgroup is configurable with
<code>options("dtrackr.max_supported_groupings"=XX)</code>. The default is 16. Large
values produce unwieldy flow charts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same .data dataframe with the history graph updated with a
subgroup count as a new stage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
survival::cgd %&gt;% track() %&gt;% group_by(treat) %&gt;%
  count_subgroup(center) %&gt;% history()
</code></pre>

<hr>
<h2 id='p_distinct'>Distinct values of data</h2><span id='topic+p_distinct'></span>

<h3>Description</h3>

<p>Distinct acts in the same way as in <code>dplyr::distinct</code>. Prior to the operation
the size of the group is calculated {.count.in} and after the operation the
output size {.count.out} The group {.strata} is also available (if
grouped) for reporting. See <code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_distinct(
  .data,
  ...,
  .messages = "removing {.count.in-.count.out} duplicates",
  .headline = .defaultHeadline(),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_distinct_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_distinct_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Optional variables to
use when determining uniqueness. If there are multiple rows for a given
combination of inputs, only the first row will be preserved. If omitted,
will use all variables in the data frame.
Named arguments passed on to <code><a href="dplyr.html#topic+distinct">dplyr::distinct</a></code></p>

<dl>
<dt><code>.keep_all</code></dt><dd><p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_distinct_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="p_distinct_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="p_distinct_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with distinct values and history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::distinct()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = bind_rows(iris %&gt;% track(), iris %&gt;% track() %&gt;% filter(Petal.Length &gt; 5))
tmp %&gt;% group_by(Species) %&gt;% distinct() %&gt;% history()
</code></pre>

<hr>
<h2 id='p_exclude_all'>Exclude all items matching one or more criteria</h2><span id='topic+p_exclude_all'></span>

<h3>Description</h3>

<p>Apply a set of filters and summarise the actions of the filter to the <code>dtrackr</code>
history graph. Because of the ... filter specification, all parameters MUST BE
NAMED. The filters work in an combinatorial manner, i.e. the results EXCLUDE ALL
rows that match any of the criteria. If <code>na.rm = TRUE</code> they also remove
anything that cannot be evaluated by any criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_exclude_all(
  .data,
  ...,
  .headline = .defaultHeadline(),
  na.rm = FALSE,
  .type = "exclusion",
  .asOffshoot = TRUE,
  .stage = (if (is.null(.tag)) "" else .tag),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_exclude_all_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="p_exclude_all_+3A_...">...</code></td>
<td>
<p>a dplyr filter specification as a set of formulae where the LHS are
predicates to test the data set against, items that match any of the predicates will
be excluded. The RHS is a glue specification, defining the message, to be
entered in the history graph for each predicate. This can refer to grouping variables
variables from the environment and {.excluded} and {.matched} or
{.missing} (excluded = matched+missing), {.count} and {.total} -
group and overall counts respectively, e.g. &quot;excluding {.matched} items
and {.missing} with missing values&quot;.</p>
</td></tr>
<tr><td><code id="p_exclude_all_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, or any variables defined in the calling environment</p>
</td></tr>
<tr><td><code id="p_exclude_all_+3A_na.rm">na.rm</code></td>
<td>
<p>(default FALSE) if the filter cannot be evaluated for a row
count that row as missing and either exclude it (TRUE) or don't exclude it
(FALSE)</p>
</td></tr>
<tr><td><code id="p_exclude_all_+3A_.type">.type</code></td>
<td>
<p>default &quot;exclusion&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="p_exclude_all_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>do you want this comment to be an offshoot of the main
flow (default = TRUE).</p>
</td></tr>
<tr><td><code id="p_exclude_all_+3A_.stage">.stage</code></td>
<td>
<p>a name for this step in the pathway</p>
</td></tr>
<tr><td><code id="p_exclude_all_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the filtered .data dataframe with the history graph updated with the
summary of excluded items as a new offshoot stage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

iris %&gt;% track() %&gt;% capture_exclusions() %&gt;% exclude_all(
      Petal.Length &gt; 5 ~ "{.excluded} long ones",
      Petal.Length &lt; 2 ~ "{.excluded} short ones"
) %&gt;% history()


# simultaneous evaluation of criteria:
data.frame(a = 1:10) %&gt;%
  track() %&gt;%
  exclude_all(
    # These two criteria identify the same value and one item is excluded
    a &gt; 9 ~ "{.excluded} value &gt; 9",
    a == max(a) ~ "{.excluded} max value",
  ) %&gt;%
  status() %&gt;%
  history()

# the behaviour is equivalent to the inverse of dplyr's filter function:
data.frame(a=1:10) %&gt;%
  dplyr::filter(a &lt;= 9, a != max(a)) %&gt;%
  nrow()

# step-wise evaluation of criteria results in a different output
data.frame(a = 1:10) %&gt;%
  track() %&gt;%
  # Performing the same exclusion sequentially results in 2 items
  # being excluded as the criteria no longer identify the same
  # item.
  exclude_all(a &gt; 9 ~ "{.excluded} value &gt; 9") %&gt;%
  exclude_all(a == max(a) ~ "{.excluded} max value") %&gt;%
  status() %&gt;%
  history()

# the behaviour is equivalent to the inverse of dplyr's filter function:
data.frame(a=1:10) %&gt;%
  dplyr::filter(a &lt;= 9) %&gt;%
  dplyr::filter(a != max(a)) %&gt;%
  nrow()

</code></pre>

<hr>
<h2 id='p_excluded'>Get the dtrackr excluded data record</h2><span id='topic+p_excluded'></span>

<h3>Description</h3>

<p>Get the dtrackr excluded data record
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_excluded(.data, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_excluded_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="p_excluded_+3A_simplify">simplify</code></td>
<td>
<p>return a single summary dataframe of all exclusions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new dataframe of the excluded data up to this point in the workflow. This dataframe is by default flattened, but if <code>.simplify=FALSE</code> has a nested structure containing records excluded at each part of the pipeline.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
tmp = iris %&gt;% track() %&gt;% capture_exclusions()
tmp %&gt;% exclude_all(
   Petal.Length &gt; 5.8 ~ "{.excluded} long ones",
   Petal.Length &lt; 1.3 ~ "{.excluded} short ones",
   .stage = "petal length exclusion"
) %&gt;% excluded()
</code></pre>

<hr>
<h2 id='p_filter'>Filtering data</h2><span id='topic+p_filter'></span>

<h3>Description</h3>

<p>Filter acts in the same way as in <code>dplyr</code> where predicates which evaluate to
TRUE act to select items to include, and items for which the predicate cannot
be evaluated are excluded. For tracking prior to the filter operation the
size of each group is calculated {.count.in} and after the operation the
output size of each group {.count.out}. The grouping {.strata} is also
available (if grouped) for reporting. See <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_filter(
  .data,
  ...,
  .messages = "excluded {.excluded} items",
  .headline = .defaultHeadline(),
  .type = "exclusion",
  .asOffshoot = (.type == "exclusion"),
  .stage = (if (is.null(.tag)) "" else .tag),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_filter_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_filter_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>.data</code>. If multiple expressions are included, they are combined with the
<code>&amp;</code> operator. Only rows for which all conditions evaluate to <code>TRUE</code> are
kept.
Named arguments passed on to <code><a href="dplyr.html#topic+filter">dplyr::filter</a></code></p>

<dl>
<dt><code>.by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_filter_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="p_filter_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="p_filter_+3A_.type">.type</code></td>
<td>
<p>the format type of the action typically an exclusion</p>
</td></tr>
<tr><td><code id="p_filter_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>if the type is exclusion, <code>.asOffshoot</code> places the
information box outside of the main flow, as an exclusion.</p>
</td></tr>
<tr><td><code id="p_filter_+3A_.stage">.stage</code></td>
<td>
<p>a name for this step in the pathway</p>
</td></tr>
<tr><td><code id="p_filter_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with <code>.tag</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the filtered <code>.data</code> dataframe with history graph updated
</p>


<h3>See Also</h3>

<p>dplyr::filter()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% track() %&gt;% group_by(Species)
tmp %&gt;% filter(Petal.Length &gt; 5) %&gt;% history()
</code></pre>

<hr>
<h2 id='p_flowchart'>Flowchart output</h2><span id='topic+p_flowchart'></span>

<h3>Description</h3>

<p>Generate a flowchart of the history of the dataframe(s), with all the tracked
data pipeline as stages in the flowchart. Multiple dataframes can be plotted
together in which case an attempt is made to determine which parts are
common.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_flowchart(
  .data,
  filename = NULL,
  size = std_size$full,
  maxWidth = size$width,
  maxHeight = size$height,
  formats = c("dot", "png", "pdf", "svg"),
  defaultToHTML = TRUE,
  landscape = size$rot != 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_flowchart_+3A_.data">.data</code></td>
<td>
<p>the tracked dataframe(s) either as a single dataframe or as a
list of dataframes.</p>
</td></tr>
<tr><td><code id="p_flowchart_+3A_filename">filename</code></td>
<td>
<p>a file name which will be where the formatted flowcharts are
saved. If no extension is specified the output formats are determined by
the <code>formats</code> parameter.</p>
</td></tr>
<tr><td><code id="p_flowchart_+3A_size">size</code></td>
<td>
<p>a named list with 3 elements, length and width in inches and
rotation. A predefined set of standard sizes are available in the
<a href="#topic+std_size">std_size</a> object.</p>
</td></tr>
<tr><td><code id="p_flowchart_+3A_maxwidth">maxWidth</code></td>
<td>
<p>a width (on the paper) in inches if <code>size</code> is not defined</p>
</td></tr>
<tr><td><code id="p_flowchart_+3A_maxheight">maxHeight</code></td>
<td>
<p>a height (on the paper) in inches if <code>size</code> is not defined</p>
</td></tr>
<tr><td><code id="p_flowchart_+3A_formats">formats</code></td>
<td>
<p>some of <code>pdf</code>,<code>dot</code>,<code>svg</code>,<code>png</code>,<code>ps</code></p>
</td></tr>
<tr><td><code id="p_flowchart_+3A_defaulttohtml">defaultToHTML</code></td>
<td>
<p>if the correct output format is not easy to determine
from the context, default providing <code>HTML</code> (TRUE) or to embedding the <code>PNG</code> (FALSE)</p>
</td></tr>
<tr><td><code id="p_flowchart_+3A_landscape">landscape</code></td>
<td>
<p>rotate the output by 270 degrees into a landscape format.
<code>maxWidth</code> and <code>maxHeight</code> still apply and refer to the paper width to fit
the flowchart into after rotation. (you might need to flip width and height)</p>
</td></tr>
<tr><td><code id="p_flowchart_+3A_...">...</code></td>
<td>
<p>other parameters passed onto either <code>p_get_as_dot()</code>, notable ones are
<code>fill</code> (background colour e.g. <code>lightgrey</code>), <code>fontsize</code> (in points),
<code>colour</code> (font colour)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the nature of the flowchart output depends on the context in which
the function is called. It will be some form of browse-able html output if
called from an interactive session or a <code>PNG</code>/<code>PDF</code> link if in <code>knitr</code> and
knitting latex or word type outputs, if file name is specified the output
will also be saved at the given location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% track() %&gt;% comment(.tag = "step1") %&gt;% filter(Species!="versicolor")
tmp %&gt;% group_by(Species) %&gt;% comment(.tag="step2") %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_full_join'>Full join</h2><span id='topic+p_full_join'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_full_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS",
    "{.count.out} in linked set"),
  .headline = "Full join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_full_join_+3A_x">x</code>, <code id="p_full_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_full_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>suffix</code></dt><dd><p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</dd>
<dt><code>keep</code></dt><dd><p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
<dt><code>multiple</code></dt><dd><p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</dd>
<dt><code>unmatched</code></dt><dd><p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</dd>
<dt><code>relationship</code></dt><dd><p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_full_join_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="p_full_join_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::full_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Full join
join = lhs %&gt;% full_join(rhs, by="name", multiple = "all") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()

</code></pre>

<hr>
<h2 id='p_get'>Get the dtrackr history graph</h2><span id='topic+p_get'></span>

<h3>Description</h3>

<p>This provides the raw history graph and is not really intended for mainstream use.
The internal structure of the graph is explained below. print and plot S3 methods exist for
the dtrackr history graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_get(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_get_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the history graph. This is a list, of class <code>trackr_graph</code>, containing the following named items:
</p>

<ul>
<li><p> excluded - the data items that have been excluded thus far as a nested dataframe
</p>
</li>
<li><p> tags - a dataframe of tag-value pairs containing the summary of the data at named points in the data flow (see <code><a href="#topic+tagged">tagged()</a></code>)
</p>
</li>
<li><p> nodes - a dataframe of the nodes of the flow chart
</p>
</li>
<li><p> edges - an edge list (as a dataframe) of the relationships between the nodes in the flow chart
</p>
</li>
<li><p> head - the current most recent nodes added into the graph as a dataframe.
</p>
</li></ul>

<p>The format of this data may grow over time but these fields are unlikely to be changed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
graph = iris %&gt;% track() %&gt;% comment("A comment") %&gt;% history()
print(graph)
</code></pre>

<hr>
<h2 id='p_get_as_dot'>DOT output</h2><span id='topic+p_get_as_dot'></span>

<h3>Description</h3>

<p>(advance usage) outputs a <code>dtrackr</code> history graph as a DOT string for rendering with <code>Graphviz</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_get_as_dot(.data, fill = "lightgrey", fontsize = "8", colour = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_get_as_dot_+3A_.data">.data</code></td>
<td>
<p>the tracked dataframe</p>
</td></tr>
<tr><td><code id="p_get_as_dot_+3A_fill">fill</code></td>
<td>
<p>the default node fill colour</p>
</td></tr>
<tr><td><code id="p_get_as_dot_+3A_fontsize">fontsize</code></td>
<td>
<p>the default font size</p>
</td></tr>
<tr><td><code id="p_get_as_dot_+3A_colour">colour</code></td>
<td>
<p>the default font colour</p>
</td></tr>
<tr><td><code id="p_get_as_dot_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a representation of the history graph in <code>Graphviz</code> dot format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% track() %&gt;% comment(.tag = "step1") %&gt;% filter(Species!="versicolor")
dot = tmp %&gt;% group_by(Species) %&gt;% comment(.tag="step2") %&gt;% p_get_as_dot()
cat(dot)
</code></pre>

<hr>
<h2 id='p_group_by'>Stratifying your analysis</h2><span id='topic+p_group_by'></span>

<h3>Description</h3>

<p>Grouping a data set acts in the normal way. When tracking a dataframe
sometimes a <code>group_by()</code> operation will create a lot of groups. This happens
for example if you are doing a <code>group_by()</code>, <code>summarise()</code> step that is
aggregating data on a fine scale, e.g. by day in a time-series. This is
generally a terrible idea when tracking a dataframe as the resulting
flowchart will have many many branches and be illegible. <code>dtrackr</code> will detect this issue and
pause tracking the dataframe with a warning. It is up to the user to the
<code>resume()</code> tracking when the large number of groups have been resolved e.g.
using a <code>dplyr::ungroup()</code>. This limit is configurable with
<code>options("dtrackr.max_supported_groupings"=XX)</code>. The default is 16. See
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_group_by(
  .data,
  ...,
  .messages = "stratify by {.cols}",
  .headline = NULL,
  .tag = NULL,
  .maxgroups = .defaultMaxSupportedGroupings()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_group_by_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_group_by_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.
Named arguments passed on to <code><a href="dplyr.html#topic+group_by">dplyr::group_by</a></code></p>

<dl>
<dt><code>.add</code></dt><dd><p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</dd>
<dt><code>.drop</code></dt><dd><p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</dd>
<dt><code>x</code></dt><dd><p>A <code><a href="dplyr.html#topic+tbl">tbl()</a></code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_group_by_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.cols} which is the columns that are being grouped by.</p>
</td></tr>
<tr><td><code id="p_group_by_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, or {.cols}.</p>
</td></tr>
<tr><td><code id="p_group_by_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
<tr><td><code id="p_group_by_+3A_.maxgroups">.maxgroups</code></td>
<td>
<p>the maximum number of subgroups allowed before the tracking
is paused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data but grouped.
</p>


<h3>See Also</h3>

<p>dplyr::group_by()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% track() %&gt;% group_by(Species, .messages="stratify by {.cols}")
tmp %&gt;% comment("{.strata}") %&gt;% history()
</code></pre>

<hr>
<h2 id='p_group_modify'>Group-wise modification of data and complex operations</h2><span id='topic+p_group_modify'></span>

<h3>Description</h3>

<p>Group modifying a data set acts in the normal way. The internal mechanics of
the modify function are opaque to the history. This means these can be used
to wrap any unsupported operation without losing the history (e.g. <code>df %&gt;% track() %&gt;% group_modify(function(d,...) { d %&gt;% unsupported_operation() })</code>
) Prior to the operation the size of the group is calculated {.count.in}
and after the operation the output size {.count.out} The group {.strata}
is also available (if grouped) for reporting See <code><a href="dplyr.html#topic+group_map">dplyr::group_modify()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_group_modify(
  .data,
  ...,
  .messages = NULL,
  .headline = .defaultHeadline(),
  .type = "modify",
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_group_modify_+3A_.data">.data</code></td>
<td>
<p>A grouped tibble</p>
</td></tr>
<tr><td><code id="p_group_modify_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code>
Named arguments passed on to <code><a href="dplyr.html#topic+group_map">dplyr::group_modify</a></code></p>

<dl>
<dt><code>.f</code></dt><dd><p>A function or formula to apply to each group.
</p>
<p>If a <strong>function</strong>, it is used as is. It should have at least 2 formal arguments.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ head(.x)</code>, it is converted to a function.
</p>
<p>In the formula, you can use
</p>

<ul>
<li> <p><code>.</code> or <code>.x</code> to refer to the subset of rows of <code>.tbl</code>
for the given group
</p>
</li>
<li> <p><code>.y</code> to refer to the key, a one row tibble with one column per grouping variable
that identifies the group
</p>
</li></ul>
</dd>
<dt><code>.keep</code></dt><dd><p>are the grouping variables kept in <code>.x</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_group_modify_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="p_group_modify_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, or {.strata},{.count.in},and {.count.out}</p>
</td></tr>
<tr><td><code id="p_group_modify_+3A_.type">.type</code></td>
<td>
<p>default &quot;modify&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="p_group_modify_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformed .data dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::group_modify()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% track() %&gt;% group_by(Species)
tmp %&gt;% group_modify(
      function(d,g,...) { return(tibble::tibble(x=runif(10))) },
      .messages="{.count.in} in, {.count.out} out"
) %&gt;% history()
</code></pre>

<hr>
<h2 id='p_include_any'>Include any items matching a criteria</h2><span id='topic+p_include_any'></span>

<h3>Description</h3>

<p>Apply a set of inclusion criteria and record the actions of the
filter to the <code>dtrackr</code> history graph. Because of the ... filter specification,
all parameters MUST BE NAMED. This function is the opposite of
<code><a href="#topic+exclude_all">exclude_all()</a></code> and the filtering criteria work to identify rows to
include i.e. the results include anything that match any of the criteria. If
<code>na.rm=TRUE</code> they also keep anything that cannot be evaluated by the criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_include_any(
  .data,
  ...,
  .headline = .defaultHeadline(),
  na.rm = TRUE,
  .type = "inclusion",
  .asOffshoot = FALSE,
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_include_any_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="p_include_any_+3A_...">...</code></td>
<td>
<p>a dplyr filter specification as a set of formulae where the LHS
are predicates to test the data set against, items that match at least one
of the predicates will be included. The RHS is a glue specification,
defining the message, to be entered in the history graph for each predicate
matched. This can refer to grouping variables, variables from the
environment and {.included} and {.matched} or {.missing} (included =
matched+missing), {.count} and {.total} - group and overall counts
respectively, e.g. &quot;excluding {.matched} items and {.missing} with
missing values&quot;.</p>
</td></tr>
<tr><td><code id="p_include_any_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, or any variables defined in the calling environment</p>
</td></tr>
<tr><td><code id="p_include_any_+3A_na.rm">na.rm</code></td>
<td>
<p>(default TRUE) if the filter cannot be evaluated for a row
count that row as missing and either exclude it (TRUE) or don't exclude it
(FALSE)</p>
</td></tr>
<tr><td><code id="p_include_any_+3A_.type">.type</code></td>
<td>
<p>default &quot;inclusion&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="p_include_any_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>do you want this comment to be an offshoot of the main
flow (default = FALSE).</p>
</td></tr>
<tr><td><code id="p_include_any_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the filtered .data dataframe with the history graph updated with the
summary of included items as a new stage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

iris %&gt;% track() %&gt;% group_by(Species) %&gt;% include_any(
      Petal.Length &gt; 5 ~ "{.included} long ones",
      Petal.Length &lt; 2 ~ "{.included} short ones"
) %&gt;% history()

# simultaneous evaluation of criteria:
data.frame(a = 1:10) %&gt;%
  track() %&gt;%
  include_any(
    # These two criteria identify the same value and one item is excluded
    a &gt; 1 ~ "{.included} value &gt; 1",
    a != min(a) ~ "{.included} everything but the smallest value",
  ) %&gt;%
  status() %&gt;%
  history()

# the behaviour is equivalent to dplyr's filter function:
data.frame(a=1:10) %&gt;%
  dplyr::filter(a &gt; 1, a != min(a)) %&gt;%
  nrow()

# step-wise evaluation of criteria results in a different output
data.frame(a = 1:10) %&gt;%
  track() %&gt;%
  # Performing the same exclusion sequentially results in 2 items
  # being excluded as the criteria no longer identify the same
  # item.
  include_any(a &gt; 1 ~ "{.included} value &gt; 1") %&gt;%
  include_any(a != min(a) ~ "{.included} everything but the smallest value") %&gt;%
  status() %&gt;%
  history()

# the behaviour is equivalent to dplyr's filter function:
data.frame(a=1:10) %&gt;%
  dplyr::filter(a &gt; 1) %&gt;%
  dplyr::filter(a != min(a)) %&gt;%
  nrow()

</code></pre>

<hr>
<h2 id='p_inner_join'>Inner joins</h2><span id='topic+p_inner_join'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_inner_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS",
    "{.count.out} in linked set"),
  .headline = "Inner join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_inner_join_+3A_x">x</code>, <code id="p_inner_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_inner_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>suffix</code></dt><dd><p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</dd>
<dt><code>keep</code></dt><dd><p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
<dt><code>multiple</code></dt><dd><p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</dd>
<dt><code>unmatched</code></dt><dd><p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</dd>
<dt><code>relationship</code></dt><dd><p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_inner_join_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="p_inner_join_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::inner_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Inner join
join = lhs %&gt;% inner_join(rhs, by="name", multiple = "all") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history() %&gt;% print()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_intersect'>Set operations</h2><span id='topic+p_intersect'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_intersect(
  x,
  y,
  ...,
  .messages = "{.count.out} in intersection",
  .headline = "Intersection"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_intersect_+3A_x">x</code>, <code id="p_intersect_+3A_y">y</code></td>
<td>
<p>Vectors to combine.</p>
</td></tr>
<tr><td><code id="p_intersect_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine</p>
</td></tr>
<tr><td><code id="p_intersect_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="p_intersect_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>generics::intersect()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_left_join'>Left join</h2><span id='topic+p_left_join'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_left_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS",
    "{.count.out} in linked set"),
  .headline = "Left join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_left_join_+3A_x">x</code>, <code id="p_left_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_left_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>suffix</code></dt><dd><p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</dd>
<dt><code>keep</code></dt><dd><p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
<dt><code>multiple</code></dt><dd><p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</dd>
<dt><code>unmatched</code></dt><dd><p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</dd>
<dt><code>relationship</code></dt><dd><p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_left_join_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="p_left_join_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::left_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Left join
join = lhs %&gt;% left_join(rhs, by="name", multiple = "all") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()

</code></pre>

<hr>
<h2 id='p_mutate'>dplyr modifying operations</h2><span id='topic+p_mutate'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_mutate(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_mutate_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_mutate_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>

<p>Named arguments passed on to <code><a href="dplyr.html#topic+mutate">dplyr::mutate</a></code></p>

<dl>
<dt><code>.by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.keep</code></dt><dd><p>Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>
</dd>
<dt><code>.before,.after</code></dt><dd><p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, control where new columns
should appear (the default is to add to the right hand side). See
<code><a href="dplyr.html#topic+relocate">relocate()</a></code> for more details.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_mutate_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_mutate_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_mutate_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::mutate()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# mutate
# In this example we compare the column names of the input and the
# output to identify the new columns created by the mutate operation as
# the `.new_cols` variable
iris %&gt;%
  track() %&gt;%
  mutate(extra_col = NA_real_,
         .messages="{.new_cols}",
         .headline="Extra columns from mutate:") %&gt;%
  history()

</code></pre>

<hr>
<h2 id='p_nest_join'>Nest join</h2><span id='topic+p_nest_join'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+nest_join">dplyr::nest_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_nest_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS", "{.count.out} matched"),
  .headline = "Nest join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_nest_join_+3A_x">x</code>, <code id="p_nest_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_nest_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+nest_join">dplyr::nest_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>keep</code></dt><dd><p>Should the new list-column contain join keys? The default
will preserve the join keys for inequality joins.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the list-column created by the join. If <code>NULL</code>,
the default, the name of <code>y</code> is used.</p>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
<dt><code>unmatched</code></dt><dd><p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_nest_join_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="p_nest_join_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::nest_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Nest join
join = lhs %&gt;% nest_join(rhs, by="name") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history() %&gt;% print()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_pause'>Pause tracking the data frame.</h2><span id='topic+p_pause'></span>

<h3>Description</h3>

<p>Pausing tracking of a data frame may be required if an operation is about to
be performed that creates a lot of groupings or that you otherwise don't
want to pollute the history graph (e.g. maybe selecting something using
an anti-join). Once paused the history is not updated until a <code>resume()</code> is
called, or when the data frame is ungrouped (if <code>auto</code> is enabled).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_pause(.data, auto = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_pause_+3A_.data">.data</code></td>
<td>
<p>a tracked dataframe</p>
</td></tr>
<tr><td><code id="p_pause_+3A_auto">auto</code></td>
<td>
<p>if <code>TRUE</code> the tracking will resume automatically when the
number of groups has fallen to a sensible level (default is <code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with history graph tracking paused
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% track() %&gt;% pause() %&gt;% history()
</code></pre>

<hr>
<h2 id='p_pivot_longer'>Reshaping data using <code>tidyr::pivot_longer</code></h2><span id='topic+p_pivot_longer'></span>

<h3>Description</h3>

<p>A drop in replacement for <code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code> which optionally takes a
message and headline to store in the history graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_pivot_longer(data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_pivot_longer_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="p_pivot_longer_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.
Named arguments passed on to <code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer</a></code></p>

<dl>
<dt><code>cols</code></dt><dd><p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pivot into
longer format.</p>
</dd>
<dt><code>cols_vary</code></dt><dd><p>When pivoting <code>cols</code> into longer format, how should the
output rows be arranged relative to their original row number?
</p>

<ul>
<li> <p><code>"fastest"</code>, the default, keeps individual rows from <code>cols</code> close
together in the output. This often produces intuitively ordered output
when you have at least one key column from <code>data</code> that is not involved in
the pivoting process.
</p>
</li>
<li> <p><code>"slowest"</code> keeps individual columns from <code>cols</code> close together in the
output. This often produces intuitively ordered output when you utilize
all of the columns from <code>data</code> in the pivoting process.
</p>
</li></ul>
</dd>
<dt><code>names_to</code></dt><dd><p>A character vector specifying the new column or columns to
create from the information stored in the column names of <code>data</code> specified
by <code>cols</code>.
</p>

<ul>
<li><p> If length 0, or if <code>NULL</code> is supplied, no columns will be created.
</p>
</li>
<li><p> If length 1, a single column will be created which will contain the
column names specified by <code>cols</code>.
</p>
</li>
<li><p> If length &gt;1, multiple columns will be created. In this case, one of
<code>names_sep</code> or <code>names_pattern</code> must be supplied to specify how the
column names should be split. There are also two additional character
values you can take advantage of:
</p>

<ul>
<li> <p><code>NA</code> will discard the corresponding component of the column name.
</p>
</li>
<li> <p><code>".value"</code> indicates that the corresponding component of the column
name defines the name of the output column containing the cell values,
overriding <code>values_to</code> entirely.
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>names_prefix</code></dt><dd><p>A regular expression used to remove matching text
from the start of each variable name.</p>
</dd>
<dt><code>names_sep,names_pattern</code></dt><dd><p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.
</p>
<p><code>names_sep</code> takes the same specification as <code><a href="tidyr.html#topic+separate">separate()</a></code>, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).
</p>
<p><code>names_pattern</code> takes the same specification as <code><a href="tidyr.html#topic+extract">extract()</a></code>, a regular
expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>If these arguments do not give you enough control, use
<code>pivot_longer_spec()</code> to create a spec object and process manually as
needed.</p>
</dd>
<dt><code>names_ptypes,values_ptypes</code></dt><dd><p>Optionally, a list of column name-prototype
pairs. Alternatively, a single empty prototype can be supplied, which will
be applied to all columns. A prototype (or ptype for short) is a
zero-length vector (like <code>integer()</code> or <code>numeric()</code>) that defines the type,
class, and attributes of a vector. Use these arguments if you want to
confirm that the created columns are the types that you expect. Note that
if you want to change (instead of confirm) the types of specific columns,
you should use <code>names_transform</code> or <code>values_transform</code> instead.</p>
</dd>
<dt><code>names_transform,values_transform</code></dt><dd><p>Optionally, a list of column
name-function pairs. Alternatively, a single function can be supplied,
which will be applied to all columns. Use these arguments if you need to
change the types of specific columns. For example, <code>names_transform = list(week = as.integer)</code> would convert a character variable called <code>week</code>
to an integer.
</p>
<p>If not specified, the type of the columns generated from <code>names_to</code> will
be character, and the type of the variables generated from <code>values_to</code>
will be the common type of the input columns used to generate them.</p>
</dd>
<dt><code>names_repair</code></dt><dd><p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</dd>
<dt><code>values_to</code></dt><dd><p>A string specifying the name of the column to create
from the data stored in cell values. If <code>names_to</code> is a character
containing the special <code>.value</code> sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.</p>
</dd>
<dt><code>values_drop_na</code></dt><dd><p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code>s
in the <code>value_to</code> column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in <code>data</code> were created by its structure.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_pivot_longer_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_pivot_longer_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_pivot_longer_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the result of the <code>tidyr::pivot_longer</code> but with a history graph
updated.
</p>


<h3>See Also</h3>

<p>tidyr::pivot_longer()
</p>

<hr>
<h2 id='p_pivot_wider'>Reshaping data using <code>tidyr::pivot_wider</code></h2><span id='topic+p_pivot_wider'></span>

<h3>Description</h3>

<p>A drop in replacement for <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code> which optionally takes a
message and headline to store in the history graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_pivot_wider(data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_pivot_wider_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="p_pivot_wider_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.
Named arguments passed on to <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider</a></code></p>

<dl>
<dt><code>id_cols</code></dt><dd><p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A set of columns that
uniquely identify each observation. Typically used when you have
redundant variables, i.e. variables whose values are perfectly correlated
with existing variables.
</p>
<p>Defaults to all columns in <code>data</code> except for the columns specified through
<code>names_from</code> and <code>values_from</code>. If a tidyselect expression is supplied, it
will be evaluated on <code>data</code> after removing the columns specified through
<code>names_from</code> and <code>values_from</code>.</p>
</dd>
<dt><code>id_expand</code></dt><dd><p>Should the values in the <code>id_cols</code> columns be expanded by
<code><a href="tidyr.html#topic+expand">expand()</a></code> before pivoting? This results in more rows, the output will
contain a complete expansion of all possible values in <code>id_cols</code>. Implicit
factor levels that aren't represented in the data will become explicit.
Additionally, the row values corresponding to the expanded <code>id_cols</code> will
be sorted.</p>
</dd>
<dt><code>names_from,values_from</code></dt><dd><p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A pair of
arguments describing which column (or columns) to get the name of the
output column (<code>names_from</code>), and which column (or columns) to get the
cell values from (<code>values_from</code>).
</p>
<p>If <code>values_from</code> contains multiple values, the value will be added to the
front of the output column.</p>
</dd>
<dt><code>names_prefix</code></dt><dd><p>String added to the start of every variable name. This is
particularly useful if <code>names_from</code> is a numeric vector and you want to
create syntactic variable names.</p>
</dd>
<dt><code>names_sep</code></dt><dd><p>If <code>names_from</code> or <code>values_from</code> contains multiple
variables, this will be used to join their values together into a single
string to use as a column name.</p>
</dd>
<dt><code>names_glue</code></dt><dd><p>Instead of <code>names_sep</code> and <code>names_prefix</code>, you can supply
a glue specification that uses the <code>names_from</code> columns (and special
<code>.value</code>) to create custom column names.</p>
</dd>
<dt><code>names_sort</code></dt><dd><p>Should the column names be sorted? If <code>FALSE</code>, the default,
column names are ordered by first appearance.</p>
</dd>
<dt><code>names_vary</code></dt><dd><p>When <code>names_from</code> identifies a column (or columns) with
multiple unique values, and multiple <code>values_from</code> columns are provided,
in what order should the resulting column names be combined?
</p>

<ul>
<li> <p><code>"fastest"</code> varies <code>names_from</code> values fastest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value1_name2, value2_name1, value2_name2&#8288;</code>. This is the default.
</p>
</li>
<li> <p><code>"slowest"</code> varies <code>names_from</code> values slowest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value2_name1, value1_name2, value2_name2&#8288;</code>.
</p>
</li></ul>
</dd>
<dt><code>names_expand</code></dt><dd><p>Should the values in the <code>names_from</code> columns be expanded
by <code><a href="tidyr.html#topic+expand">expand()</a></code> before pivoting? This results in more columns, the output
will contain column names corresponding to a complete expansion of all
possible values in <code>names_from</code>. Implicit factor levels that aren't
represented in the data will become explicit. Additionally, the column
names will be sorted, identical to what <code>names_sort</code> would produce.</p>
</dd>
<dt><code>names_repair</code></dt><dd><p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</dd>
<dt><code>values_fill</code></dt><dd><p>Optionally, a (scalar) value that specifies what each
<code>value</code> should be filled in with when missing.
</p>
<p>This can be a named list if you want to apply different fill values to
different value columns.</p>
</dd>
<dt><code>values_fn</code></dt><dd><p>Optionally, a function applied to the value in each cell
in the output. You will typically use this when the combination of
<code>id_cols</code> and <code>names_from</code> columns does not uniquely identify an
observation.
</p>
<p>This can be a named list if you want to apply different aggregations
to different <code>values_from</code> columns.</p>
</dd>
<dt><code>unused_fn</code></dt><dd><p>Optionally, a function applied to summarize the values from
the unused columns (i.e. columns not identified by <code>id_cols</code>,
<code>names_from</code>, or <code>values_from</code>).
</p>
<p>The default drops all unused columns from the result.
</p>
<p>This can be a named list if you want to apply different aggregations
to different unused columns.
</p>
<p><code>id_cols</code> must be supplied for <code>unused_fn</code> to be useful, since otherwise
all unspecified columns will be considered <code>id_cols</code>.
</p>
<p>This is similar to grouping by the <code>id_cols</code> then summarizing the
unused columns using <code>unused_fn</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_pivot_wider_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_pivot_wider_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_pivot_wider_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data dataframe result of the <code>tidyr::pivot_wider</code> function but with
a history graph updated with a <code>.message</code> if requested.
</p>


<h3>See Also</h3>

<p>tidyr::pivot_wider()
</p>

<hr>
<h2 id='p_reframe'>Summarise a data set</h2><span id='topic+p_reframe'></span>

<h3>Description</h3>

<p>Summarising a data set acts in the normal <code>dplyr</code> manner to collapse groups
to individual rows. Any columns resulting from the summary can be added to
the history graph. In the history this also joins any stratified branches and
allows you to generate some summary statistics about the un-grouped data. See
<code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_reframe(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_reframe_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_reframe_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.
Named arguments passed on to <code><a href="dplyr.html#topic+reframe">dplyr::reframe</a></code></p>

<dl>
<dt><code>.by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_reframe_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any summary
variable defined in the ... parameter, or any global variable, or
{.strata}</p>
</td></tr>
<tr><td><code id="p_reframe_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any summary
variable defined in the ... parameter, or any global variable, or
{.strata}</p>
</td></tr>
<tr><td><code id="p_reframe_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe summarised with the history graph updated showing
the summarise operation as a new stage
</p>


<h3>See Also</h3>

<p>dplyr::reframe()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% group_by(Species) %&gt;% track()
tmp %&gt;% reframe(tibble(
  param = c("mean","min","max"),
  value = c(mean(Petal.Length), min(Petal.Length), max(Petal.Length))
  ), .messages="length {param}: {value}") %&gt;% history()
</code></pre>

<hr>
<h2 id='p_relocate'>dplyr modifying operations</h2><span id='topic+p_relocate'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_relocate(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_relocate_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_relocate_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>

<p>Named arguments passed on to <code><a href="dplyr.html#topic+relocate">dplyr::relocate</a></code></p>

<dl>
<dt><code>.before,.after</code></dt><dd><p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Destination of
columns selected by <code>...</code>. Supplying neither will move columns to the
left-hand side; specifying both is an error.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_relocate_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_relocate_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_relocate_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::relocate()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# relocate, this shows how the columns can be reordered
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  relocate(
    tidyselect::starts_with("Sepal"),
    .after=Species,
    .messages="{.cols}",
    .headline="Order of columns from relocate:") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='p_rename'>dplyr modifying operations</h2><span id='topic+p_rename'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_rename(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_rename_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_rename_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>

<p>Named arguments passed on to <code><a href="dplyr.html#topic+rename">dplyr::rename</a></code></p>

<dl>
<dt><code>.fn</code></dt><dd><p>A function used to transform the selected <code>.cols</code>. Should
return a character vector the same length as the input.</p>
</dd>
<dt><code>.cols</code></dt><dd><p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to rename;
defaults to all columns.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_rename_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_rename_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_rename_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::rename()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# rename can show us which columns are new and which have been
# removed (with .dropped_cols)
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  rename(
    Stamen.Width = Sepal.Width,
    Stamen.Length = Sepal.Length,
    .messages=c("added {.new_cols}","dropped {.dropped_cols}"),
    .headline="Renamed columns:") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='p_rename_with'>dplyr modifying operations</h2><span id='topic+p_rename_with'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_rename_with(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_rename_with_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_rename_with_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>

<p>Named arguments passed on to <code><a href="dplyr.html#topic+rename">dplyr::rename_with</a></code></p>

<dl>
<dt><code>.fn</code></dt><dd><p>A function used to transform the selected <code>.cols</code>. Should
return a character vector the same length as the input.</p>
</dd>
<dt><code>.cols</code></dt><dd><p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to rename;
defaults to all columns.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_rename_with_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_rename_with_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_rename_with_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::rename_with()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# rename can show us which columns are new and which have been
# removed (with .dropped_cols)
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  rename(
    Stamen.Width = Sepal.Width,
    Stamen.Length = Sepal.Length,
    .messages=c("added {.new_cols}","dropped {.dropped_cols}"),
    .headline="Renamed columns:") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='p_resume'>Resume tracking the data frame.</h2><span id='topic+p_resume'></span>

<h3>Description</h3>

<p>This may reset the grouping of the tracked data if the grouping structure
has changed since the data frame was paused. If you try and resume tracking a
data frame with too many groups (as defined by <code>options("dtrackr.max_supported_groupings"=XX)</code>)
then the resume will fail and the data frame will still be paused. This can
be overridden by specifying a value for the <code>.maxgroups</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_resume(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_resume_+3A_.data">.data</code></td>
<td>
<p>a tracked dataframe</p>
</td></tr>
<tr><td><code id="p_resume_+3A_...">...</code></td>
<td>

<p>Named arguments passed on to <code><a href="#topic+p_group_by">p_group_by</a></code></p>

<dl>
<dt><code>.messages</code></dt><dd><p>a set of glue specs. The glue code can use any global
variable, or {.cols} which is the columns that are being grouped by.</p>
</dd>
<dt><code>.headline</code></dt><dd><p>a headline glue spec. The glue code can use any global
variable, or {.cols}.</p>
</dd>
<dt><code>.tag</code></dt><dd><p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</dd>
<dt><code>.maxgroups</code></dt><dd><p>the maximum number of subgroups allowed before the tracking
is paused.</p>
</dd>
<dt><code>...</code></dt><dd><p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data data frame with history graph tracking resumed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
iris %&gt;% track() %&gt;% pause() %&gt;% resume() %&gt;% history()
</code></pre>

<hr>
<h2 id='p_right_join'>Right join</h2><span id='topic+p_right_join'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_right_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS",
    "{.count.out} in linked set"),
  .headline = "Right join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_right_join_+3A_x">x</code>, <code id="p_right_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_right_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>suffix</code></dt><dd><p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</dd>
<dt><code>keep</code></dt><dd><p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
<dt><code>multiple</code></dt><dd><p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</dd>
<dt><code>unmatched</code></dt><dd><p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</dd>
<dt><code>relationship</code></dt><dd><p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_right_join_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="p_right_join_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::right_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Full join
join = lhs %&gt;% full_join(rhs, by="name", multiple = "all") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()

</code></pre>

<hr>
<h2 id='p_select'>dplyr modifying operations</h2><span id='topic+p_select'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_select(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_select_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_select_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="p_select_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_select_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_select_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::select()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# select
# The output of the select verb (here using tidyselect syntax) can be captured
# and here all column names are being reported with the .cols variable.
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  select(
    tidyselect::starts_with("Sepal"),
    .messages="{.cols}",
    .headline="Output columns from select:") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='p_semi_join'>Semi join</h2><span id='topic+p_semi_join'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_semi_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS",
    "{.count.out} in intersection"),
  .headline = "Semi join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_semi_join_+3A_x">x</code>, <code id="p_semi_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_semi_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_semi_join_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="p_semi_join_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::semi_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Semi join
join = lhs %&gt;% semi_join(rhs, by="name") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history() %&gt;% print()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()

</code></pre>

<hr>
<h2 id='p_set'>Set the dtrackr history graph</h2><span id='topic+p_set'></span>

<h3>Description</h3>

<p>This is unlikely to be useful to an end user and is called automatically by many of the other
functions here. On the off chance you need to copy history metadata from one dataframe to another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_set(.data, .graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_set_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="p_set_+3A_.graph">.graph</code></td>
<td>
<p>a history graph list (consisting of nodes, edges, and head) see examples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with the history graph metadata set to the provided value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
mtcars %&gt;% p_set(iris %&gt;% comment("A comment") %&gt;% p_get()) %&gt;% history()
</code></pre>

<hr>
<h2 id='p_setdiff'>Set operations</h2><span id='topic+p_setdiff'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_setdiff(
  x,
  y,
  ...,
  .messages = "{.count.out} items in difference",
  .headline = "Difference"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_setdiff_+3A_x">x</code>, <code id="p_setdiff_+3A_y">y</code></td>
<td>
<p>Vectors to combine.</p>
</td></tr>
<tr><td><code id="p_setdiff_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine</p>
</td></tr>
<tr><td><code id="p_setdiff_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="p_setdiff_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::setdiff()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_slice'>Slice operations</h2><span id='topic+p_slice'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_slice(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_slice_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_slice_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_slice_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="p_slice_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# an arbitrary 50 items from the iris dataframe is selected. The
# history is tracked
iris %&gt;% track() %&gt;% slice(51:100) %&gt;% history()

</code></pre>

<hr>
<h2 id='p_slice_head'>Slice operations</h2><span id='topic+p_slice_head'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_slice_head(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_slice_head_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_slice_head_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice_head</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_slice_head_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="p_slice_head_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice_head()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# the first 50% of the data frame, is taken and the history tracked
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_head(prop=0.5,.messages="{.count.out} / {.count.in}",
             .headline="First {sprintf('%1.0f',prop*100)}%") %&gt;%
  history()

# The last 100 items:
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_tail(n=100,.messages="{.count.out} / {.count.in}",
             .headline="Last 100") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='p_slice_max'>Slice operations</h2><span id='topic+p_slice_max'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_slice_max(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_slice_max_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_slice_max_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice_max</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_slice_max_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="p_slice_max_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice_max()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)


# Subset the data by the maximum of a given value
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_max(prop=0.5, order_by = Sepal.Width,
            .messages="{.count.out} / {.count.in} = {prop} (with ties)",
            .headline="Widest 50% Sepals") %&gt;%
  history()


# The narrowest 25% of the iris data set by group can be calculated in the
# slice_min() function. Recording this is a matter of tracking and
# using glue specs.
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  slice_min(prop=0.25, order_by = Sepal.Width,
            .messages="{.count.out} / {.count.in} (with ties)",
            .headline="narrowest {sprintf('%1.0f',prop*100)}% {Species}") %&gt;%
  history()

</code></pre>

<hr>
<h2 id='p_slice_min'>Slice operations</h2><span id='topic+p_slice_min'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_slice_min(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_slice_min_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_slice_min_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice_min</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_slice_min_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="p_slice_min_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice_min()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)


# Subset the data by the maximum of a given value
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_max(prop=0.5, order_by = Sepal.Width,
            .messages="{.count.out} / {.count.in} = {prop} (with ties)",
            .headline="Widest 50% Sepals") %&gt;%
  history()


# The narrowest 25% of the iris data set by group can be calculated in the
# slice_min() function. Recording this is a matter of tracking and
# using glue specs.
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  slice_min(prop=0.25, order_by = Sepal.Width,
            .messages="{.count.out} / {.count.in} (with ties)",
            .headline="narrowest {sprintf('%1.0f',prop*100)}% {Species}") %&gt;%
  history()

</code></pre>

<hr>
<h2 id='p_slice_sample'>Slice operations</h2><span id='topic+p_slice_sample'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_slice_sample(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_slice_sample_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_slice_sample_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice_sample</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_slice_sample_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="p_slice_sample_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice_sample()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# In this example the iris dataframe is resampled 100 times with replacement
# within each group and the
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  slice_sample(n=100, replace=TRUE,
               .messages="{.count.out} / {.count.in} = {n}",
               .headline="100 {Species}") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='p_slice_tail'>Slice operations</h2><span id='topic+p_slice_tail'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_slice_tail(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_slice_tail_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_slice_tail_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice_tail</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_slice_tail_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="p_slice_tail_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice_tail()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# the first 50% of the data frame, is taken and the history tracked
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_head(prop=0.5,.messages="{.count.out} / {.count.in}",
             .headline="First {sprintf('%1.0f',prop*100)}%") %&gt;%
  history()

# The last 100 items:
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_tail(n=100,.messages="{.count.out} / {.count.in}",
             .headline="Last 100") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='p_status'>Add a summary to the dtrackr history graph</h2><span id='topic+p_status'></span>

<h3>Description</h3>

<p>In the middle of a pipeline you may wish to document something about the data
that is more complex than the simple counts. <code>status</code> is essentially a
<code>dplyr</code> summarisation step which is connected to a <code>glue</code> specification
output, that is recorded in the data frame history. This means you can do an
arbitrary interim summarisation and put the result into the flowchart without
disrupting the pipeline flow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_status(
  .data,
  ...,
  .messages = .defaultMessage(),
  .headline = .defaultHeadline(),
  .type = "info",
  .asOffshoot = FALSE,
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_status_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="p_status_+3A_...">...</code></td>
<td>
<p>any normal dplyr::summarise specification, e.g. <code>count=n()</code> or
<code>av=mean(x)</code>, etcetera.</p>
</td></tr>
<tr><td><code id="p_status_+3A_.messages">.messages</code></td>
<td>
<p>a character vector of glue specifications. A glue
specification can refer to the summary outputs, any grouping variables of
.data, the {.strata}, or any variables defined in the calling environment</p>
</td></tr>
<tr><td><code id="p_status_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, or any variables defined in the calling environment</p>
</td></tr>
<tr><td><code id="p_status_+3A_.type">.type</code></td>
<td>
<p>one of &quot;info&quot;,&quot;exclusion&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="p_status_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>do you want this comment to be an offshoot of the main
flow (default = FALSE).</p>
</td></tr>
<tr><td><code id="p_status_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because of the ... summary specification parameters MUST BE NAMED.
</p>


<h3>Value</h3>

<p>the same .data dataframe with the history metadata updated with the
status inserted as a new stage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
tmp = iris %&gt;% track() %&gt;% group_by(Species)
tmp %&gt;% status(
      long = p_count_if(Petal.Length&gt;5),
      short = p_count_if(Petal.Length&lt;2),
      .messages="{Species}: {long} long ones &amp; {short} short ones"
) %&gt;% history()
</code></pre>

<hr>
<h2 id='p_summarise'>Summarise a data set</h2><span id='topic+p_summarise'></span>

<h3>Description</h3>

<p>Summarising a data set acts in the normal <code>dplyr</code> manner to collapse groups
to individual rows. Any columns resulting from the summary can be added to
the history graph. In the history this also joins any stratified branches and
allows you to generate some summary statistics about the un-grouped data. See
<code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_summarise(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_summarise_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_summarise_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.
Named arguments passed on to <code><a href="dplyr.html#topic+summarise">dplyr::summarise</a></code></p>

<dl>
<dt><code>.by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.groups</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Grouping structure of the
result.
</p>

<ul>
<li><p> &quot;drop_last&quot;: dropping the last level of grouping. This was the
only supported option before version 1.0.0.
</p>
</li>
<li><p> &quot;drop&quot;: All levels of grouping are dropped.
</p>
</li>
<li><p> &quot;keep&quot;: Same grouping structure as <code>.data</code>.
</p>
</li>
<li><p> &quot;rowwise&quot;: Each row is its own group.
</p>
</li></ul>

<p>When <code>.groups</code> is not specified, it is chosen
based on the number of rows of the results:
</p>

<ul>
<li><p> If all the results have 1 row, you get &quot;drop_last&quot;.
</p>
</li>
<li><p> If the number of rows varies, you get &quot;keep&quot; (note that returning a
variable number of rows was deprecated in favor of <code><a href="dplyr.html#topic+reframe">reframe()</a></code>, which
also unconditionally drops all levels of grouping).
</p>
</li></ul>

<p>In addition, a message informs you of that choice, unless the result is ungrouped,
the option &quot;dplyr.summarise.inform&quot; is set to <code>FALSE</code>,
or when <code>summarise()</code> is called from a function in a package.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="p_summarise_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any summary
variable defined in the ... parameter, or any global variable, or
{.strata}</p>
</td></tr>
<tr><td><code id="p_summarise_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any summary
variable defined in the ... parameter, or any global variable, or
{.strata}</p>
</td></tr>
<tr><td><code id="p_summarise_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe summarised with the history graph updated showing
the summarise operation as a new stage
</p>


<h3>See Also</h3>

<p>dplyr::summarise()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% group_by(Species) %&gt;% track()
tmp %&gt;% summarise(avg = mean(Petal.Length), .messages="{avg} length") %&gt;% history()
</code></pre>

<hr>
<h2 id='p_tagged'>Retrieve tagged data in the history graph</h2><span id='topic+p_tagged'></span>

<h3>Description</h3>

<p>Any counts at the individual stages that was stored with a <code>.tag</code> option in a pipeline step can be recovered here. The idea here is to provide a quick way to access a single value
for the counts or other details tagged in a pipeline into a format that can be reported in text of a document. (e.g. for a results section). For more examples the consort statement vignette
has some examples of use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_tagged(.data, .tag = NULL, .strata = NULL, .glue = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_tagged_+3A_.data">.data</code></td>
<td>
<p>the tracked dataframe.</p>
</td></tr>
<tr><td><code id="p_tagged_+3A_.tag">.tag</code></td>
<td>
<p>(optional) the tag to retrieve.</p>
</td></tr>
<tr><td><code id="p_tagged_+3A_.strata">.strata</code></td>
<td>
<p>(optional) filter the tagged data by the strata. set to &quot;&quot; to filter just the top level ungrouped data.</p>
</td></tr>
<tr><td><code id="p_tagged_+3A_.glue">.glue</code></td>
<td>
<p>(optional) a glue specification which will be applied to the tagged content to generate a <code>.label</code> for the tagged content.</p>
</td></tr>
<tr><td><code id="p_tagged_+3A_...">...</code></td>
<td>
<p>(optional) any other named parameters will be passed to <code>glue::glue</code> and can be used to generate a label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>various things depending on what is requested.
</p>
<p>By default a tibble with a <code>.tag</code> column and all associated summary values in a nested <code>.content</code> column.
</p>
<p>If a <code>.strata</code> column is specified the results are filtered to just those that match a given <code>.strata</code> grouping (i.e. this will be the grouping label on the flowchart). Ungrouped content will have an empty &quot;&quot; as <code>.strata</code>
</p>
<p>If <code>.tag</code> is specified the result will be for a single tag and <code>.content</code> will be automatically un-nested to give a single un-nested dataframe of the content captured at the <code>.tag</code> tagged step.
This could be single or multiple rows depending on whether the original data was grouped at the point of tagging.
</p>
<p>If both the <code>.tag</code> and <code>.glue</code> is specified a <code>.label</code> column will be computed from <code>.glue</code> and the tagged content. If the result of this is a single row then just the string value of <code>.label</code> is returned.
</p>
<p>If just the <code>.glue</code> is specified, an un-nested dataframe with <code>.tag</code>,<code>.strata</code> and <code>.label</code> columns with a label for each tag in each strata.
</p>
<p>If this seems complex then the best thing is to experiment until you get the output you want, leaving any <code>.glue</code> options until you think you know what you are doing. It made sense at the time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
tmp = iris %&gt;% track() %&gt;% comment(.tag = "step1")
tmp = tmp %&gt;% filter(Species!="versicolor") %&gt;% group_by(Species)
tmp %&gt;% comment(.tag="step2") %&gt;% tagged(.glue = "{.count}/{.total}")
</code></pre>

<hr>
<h2 id='p_track'>Start tracking the dtrackr history graph</h2><span id='topic+p_track'></span>

<h3>Description</h3>

<p>Start tracking the dtrackr history graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_track(
  .data,
  .messages = .defaultMessage(),
  .headline = .defaultHeadline(),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_track_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="p_track_+3A_.messages">.messages</code></td>
<td>
<p>a character vector of glue specifications. A glue
specification can refer to any grouping variables of .data, or any
variables defined in the calling environment, the {.total} variable which
is the count of all rows, the {.count} variable which is the count of
rows in the current group and the {.strata} which describes the current
group. Defaults to the value of <code>getOption("dtrackr.default_message")</code>.</p>
</td></tr>
<tr><td><code id="p_track_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, or any variables defined in the calling environment, or the
{.total} variable which is <code>nrow(.data)</code>, or {.strata} a summary of the
current group. Defaults to the value of <code>getOption("dtrackr.default_headline")</code>.</p>
</td></tr>
<tr><td><code id="p_track_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with additional history graph metadata, to allow
tracking.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
iris %&gt;% track() %&gt;% history()
</code></pre>

<hr>
<h2 id='p_transmute'>dplyr modifying operations</h2><span id='topic+p_transmute'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_transmute(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_transmute_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="p_transmute_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="p_transmute_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_transmute_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="p_transmute_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::transmute()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# In this example we compare the column names of the input and the
# output to identify the new columns created by the transmute operation as
# the `.new_cols` variable
# Here we do the same for a transmute()
iris %&gt;%
  track() %&gt;%
  group_by(Species, .add=TRUE) %&gt;%
  transmute(
    sepal.w = Sepal.Width-1,
    sepal.l = Sepal.Length+1,
    .messages="{.new_cols}",
    .headline="New columns from transmute:") %&gt;%
  history()

</code></pre>

<hr>
<h2 id='p_ungroup'>Remove a stratification from a data set</h2><span id='topic+p_ungroup'></span>

<h3>Description</h3>

<p>Un-grouping a data set logically combines the different arms. In the history
this joins any stratified branches and acts as a specific type of <code><a href="#topic+status">status()</a></code>,
allowing you to generate some summary statistics about the un-grouped data.
See <code><a href="dplyr.html#topic+group_by">dplyr::ungroup()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_ungroup(
  x,
  ...,
  .messages = .defaultMessage(),
  .headline = .defaultHeadline(),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_ungroup_+3A_x">x</code></td>
<td>
<p>A <code><a href="dplyr.html#topic+tbl">tbl()</a></code></p>
</td></tr>
<tr><td><code id="p_ungroup_+3A_...">...</code></td>
<td>
<p>variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="p_ungroup_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any any global
variable, or {.count}. the default is &quot;total {.count} items&quot;</p>
</td></tr>
<tr><td><code id="p_ungroup_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use {.count} and
{.strata}.</p>
</td></tr>
<tr><td><code id="p_ungroup_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe but ungrouped with the history graph
updated showing the ungroup operation as a new stage.
</p>


<h3>See Also</h3>

<p>dplyr::ungroup()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% group_by(Species) %&gt;% comment("A test")
tmp %&gt;% ungroup(.messages="{.count} items in combined") %&gt;% history()
</code></pre>

<hr>
<h2 id='p_union'>Set operations</h2><span id='topic+p_union'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_union(
  x,
  y,
  ...,
  .messages = "{.count.out} unique items in union",
  .headline = "Distinct union"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_union_+3A_x">x</code>, <code id="p_union_+3A_y">y</code></td>
<td>
<p>Vectors to combine.</p>
</td></tr>
<tr><td><code id="p_union_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine</p>
</td></tr>
<tr><td><code id="p_union_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="p_union_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>generics::union()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_union_all'>Set operations</h2><span id='topic+p_union_all'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_union_all(
  x,
  y,
  ...,
  .messages = "{.count.out} items in union",
  .headline = "Union"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_union_all_+3A_x">x</code>, <code id="p_union_all_+3A_y">y</code></td>
<td>
<p>Pair of compatible data frames. A pair of data frames is
compatible if they have the same column names (possibly in different
orders) and compatible types.</p>
</td></tr>
<tr><td><code id="p_union_all_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine</p>
</td></tr>
<tr><td><code id="p_union_all_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="p_union_all_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::union_all()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='p_untrack'>Remove tracking from the dataframe</h2><span id='topic+p_untrack'></span>

<h3>Description</h3>

<p>Remove tracking from the dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_untrack(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_untrack_+3A_.data">.data</code></td>
<td>
<p>a tracked dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with history graph metadata removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
iris %&gt;% track() %&gt;% untrack() %&gt;% class()
</code></pre>

<hr>
<h2 id='pause'>Pause tracking the data frame.</h2><span id='topic+pause'></span>

<h3>Description</h3>

<p>Pausing tracking of a data frame may be required if an operation is about to
be performed that creates a lot of groupings or that you otherwise don't
want to pollute the history graph (e.g. maybe selecting something using
an anti-join). Once paused the history is not updated until a <code>resume()</code> is
called, or when the data frame is ungrouped (if <code>auto</code> is enabled).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pause(.data, auto = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pause_+3A_.data">.data</code></td>
<td>
<p>a tracked dataframe</p>
</td></tr>
<tr><td><code id="pause_+3A_auto">auto</code></td>
<td>
<p>if <code>TRUE</code> the tracking will resume automatically when the
number of groups has fallen to a sensible level (default is <code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with history graph tracking paused
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;% track() %&gt;% pause() %&gt;% history()
</code></pre>

<hr>
<h2 id='pivot_longer.trackr_df'>Reshaping data using <code>tidyr::pivot_longer</code></h2><span id='topic+pivot_longer.trackr_df'></span>

<h3>Description</h3>

<p>A drop in replacement for <code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code> which optionally takes a
message and headline to store in the history graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
pivot_longer(data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_longer.trackr_df_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="pivot_longer.trackr_df_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.
Named arguments passed on to <code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer</a></code></p>

<dl>
<dt><code>cols</code></dt><dd><p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pivot into
longer format.</p>
</dd>
<dt><code>cols_vary</code></dt><dd><p>When pivoting <code>cols</code> into longer format, how should the
output rows be arranged relative to their original row number?
</p>

<ul>
<li> <p><code>"fastest"</code>, the default, keeps individual rows from <code>cols</code> close
together in the output. This often produces intuitively ordered output
when you have at least one key column from <code>data</code> that is not involved in
the pivoting process.
</p>
</li>
<li> <p><code>"slowest"</code> keeps individual columns from <code>cols</code> close together in the
output. This often produces intuitively ordered output when you utilize
all of the columns from <code>data</code> in the pivoting process.
</p>
</li></ul>
</dd>
<dt><code>names_to</code></dt><dd><p>A character vector specifying the new column or columns to
create from the information stored in the column names of <code>data</code> specified
by <code>cols</code>.
</p>

<ul>
<li><p> If length 0, or if <code>NULL</code> is supplied, no columns will be created.
</p>
</li>
<li><p> If length 1, a single column will be created which will contain the
column names specified by <code>cols</code>.
</p>
</li>
<li><p> If length &gt;1, multiple columns will be created. In this case, one of
<code>names_sep</code> or <code>names_pattern</code> must be supplied to specify how the
column names should be split. There are also two additional character
values you can take advantage of:
</p>

<ul>
<li> <p><code>NA</code> will discard the corresponding component of the column name.
</p>
</li>
<li> <p><code>".value"</code> indicates that the corresponding component of the column
name defines the name of the output column containing the cell values,
overriding <code>values_to</code> entirely.
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>names_prefix</code></dt><dd><p>A regular expression used to remove matching text
from the start of each variable name.</p>
</dd>
<dt><code>names_sep,names_pattern</code></dt><dd><p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.
</p>
<p><code>names_sep</code> takes the same specification as <code><a href="tidyr.html#topic+separate">separate()</a></code>, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).
</p>
<p><code>names_pattern</code> takes the same specification as <code><a href="tidyr.html#topic+extract">extract()</a></code>, a regular
expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>If these arguments do not give you enough control, use
<code>pivot_longer_spec()</code> to create a spec object and process manually as
needed.</p>
</dd>
<dt><code>names_ptypes,values_ptypes</code></dt><dd><p>Optionally, a list of column name-prototype
pairs. Alternatively, a single empty prototype can be supplied, which will
be applied to all columns. A prototype (or ptype for short) is a
zero-length vector (like <code>integer()</code> or <code>numeric()</code>) that defines the type,
class, and attributes of a vector. Use these arguments if you want to
confirm that the created columns are the types that you expect. Note that
if you want to change (instead of confirm) the types of specific columns,
you should use <code>names_transform</code> or <code>values_transform</code> instead.</p>
</dd>
<dt><code>names_transform,values_transform</code></dt><dd><p>Optionally, a list of column
name-function pairs. Alternatively, a single function can be supplied,
which will be applied to all columns. Use these arguments if you need to
change the types of specific columns. For example, <code>names_transform = list(week = as.integer)</code> would convert a character variable called <code>week</code>
to an integer.
</p>
<p>If not specified, the type of the columns generated from <code>names_to</code> will
be character, and the type of the variables generated from <code>values_to</code>
will be the common type of the input columns used to generate them.</p>
</dd>
<dt><code>names_repair</code></dt><dd><p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</dd>
<dt><code>values_to</code></dt><dd><p>A string specifying the name of the column to create
from the data stored in cell values. If <code>names_to</code> is a character
containing the special <code>.value</code> sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.</p>
</dd>
<dt><code>values_drop_na</code></dt><dd><p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code>s
in the <code>value_to</code> column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in <code>data</code> were created by its structure.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pivot_longer.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="pivot_longer.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="pivot_longer.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the result of the <code>tidyr::pivot_longer</code> but with a history graph
updated.
</p>


<h3>See Also</h3>

<p>tidyr::pivot_longer()
</p>

<hr>
<h2 id='pivot_wider.trackr_df'>Reshaping data using <code>tidyr::pivot_wider</code></h2><span id='topic+pivot_wider.trackr_df'></span>

<h3>Description</h3>

<p>A drop in replacement for <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code> which optionally takes a
message and headline to store in the history graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
pivot_wider(data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_wider.trackr_df_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="pivot_wider.trackr_df_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.
Named arguments passed on to <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider</a></code></p>

<dl>
<dt><code>id_cols</code></dt><dd><p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A set of columns that
uniquely identify each observation. Typically used when you have
redundant variables, i.e. variables whose values are perfectly correlated
with existing variables.
</p>
<p>Defaults to all columns in <code>data</code> except for the columns specified through
<code>names_from</code> and <code>values_from</code>. If a tidyselect expression is supplied, it
will be evaluated on <code>data</code> after removing the columns specified through
<code>names_from</code> and <code>values_from</code>.</p>
</dd>
<dt><code>id_expand</code></dt><dd><p>Should the values in the <code>id_cols</code> columns be expanded by
<code><a href="tidyr.html#topic+expand">expand()</a></code> before pivoting? This results in more rows, the output will
contain a complete expansion of all possible values in <code>id_cols</code>. Implicit
factor levels that aren't represented in the data will become explicit.
Additionally, the row values corresponding to the expanded <code>id_cols</code> will
be sorted.</p>
</dd>
<dt><code>names_from,values_from</code></dt><dd><p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A pair of
arguments describing which column (or columns) to get the name of the
output column (<code>names_from</code>), and which column (or columns) to get the
cell values from (<code>values_from</code>).
</p>
<p>If <code>values_from</code> contains multiple values, the value will be added to the
front of the output column.</p>
</dd>
<dt><code>names_prefix</code></dt><dd><p>String added to the start of every variable name. This is
particularly useful if <code>names_from</code> is a numeric vector and you want to
create syntactic variable names.</p>
</dd>
<dt><code>names_sep</code></dt><dd><p>If <code>names_from</code> or <code>values_from</code> contains multiple
variables, this will be used to join their values together into a single
string to use as a column name.</p>
</dd>
<dt><code>names_glue</code></dt><dd><p>Instead of <code>names_sep</code> and <code>names_prefix</code>, you can supply
a glue specification that uses the <code>names_from</code> columns (and special
<code>.value</code>) to create custom column names.</p>
</dd>
<dt><code>names_sort</code></dt><dd><p>Should the column names be sorted? If <code>FALSE</code>, the default,
column names are ordered by first appearance.</p>
</dd>
<dt><code>names_vary</code></dt><dd><p>When <code>names_from</code> identifies a column (or columns) with
multiple unique values, and multiple <code>values_from</code> columns are provided,
in what order should the resulting column names be combined?
</p>

<ul>
<li> <p><code>"fastest"</code> varies <code>names_from</code> values fastest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value1_name2, value2_name1, value2_name2&#8288;</code>. This is the default.
</p>
</li>
<li> <p><code>"slowest"</code> varies <code>names_from</code> values slowest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value2_name1, value1_name2, value2_name2&#8288;</code>.
</p>
</li></ul>
</dd>
<dt><code>names_expand</code></dt><dd><p>Should the values in the <code>names_from</code> columns be expanded
by <code><a href="tidyr.html#topic+expand">expand()</a></code> before pivoting? This results in more columns, the output
will contain column names corresponding to a complete expansion of all
possible values in <code>names_from</code>. Implicit factor levels that aren't
represented in the data will become explicit. Additionally, the column
names will be sorted, identical to what <code>names_sort</code> would produce.</p>
</dd>
<dt><code>names_repair</code></dt><dd><p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</dd>
<dt><code>values_fill</code></dt><dd><p>Optionally, a (scalar) value that specifies what each
<code>value</code> should be filled in with when missing.
</p>
<p>This can be a named list if you want to apply different fill values to
different value columns.</p>
</dd>
<dt><code>values_fn</code></dt><dd><p>Optionally, a function applied to the value in each cell
in the output. You will typically use this when the combination of
<code>id_cols</code> and <code>names_from</code> columns does not uniquely identify an
observation.
</p>
<p>This can be a named list if you want to apply different aggregations
to different <code>values_from</code> columns.</p>
</dd>
<dt><code>unused_fn</code></dt><dd><p>Optionally, a function applied to summarize the values from
the unused columns (i.e. columns not identified by <code>id_cols</code>,
<code>names_from</code>, or <code>values_from</code>).
</p>
<p>The default drops all unused columns from the result.
</p>
<p>This can be a named list if you want to apply different aggregations
to different unused columns.
</p>
<p><code>id_cols</code> must be supplied for <code>unused_fn</code> to be useful, since otherwise
all unspecified columns will be considered <code>id_cols</code>.
</p>
<p>This is similar to grouping by the <code>id_cols</code> then summarizing the
unused columns using <code>unused_fn</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pivot_wider.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="pivot_wider.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="pivot_wider.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data dataframe result of the <code>tidyr::pivot_wider</code> function but with
a history graph updated with a <code>.message</code> if requested.
</p>


<h3>See Also</h3>

<p>tidyr::pivot_wider()
</p>

<hr>
<h2 id='plot.trackr_graph'>Plots a history graph as html</h2><span id='topic+plot.trackr_graph'></span>

<h3>Description</h3>

<p>Plots a history graph as html
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_graph'
plot(x, fill = "lightgrey", fontsize = "8", colour = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.trackr_graph_+3A_x">x</code></td>
<td>
<p>a dtrackr history graph (e.g. output from <code><a href="#topic+history">history()</a></code>)</p>
</td></tr>
<tr><td><code id="plot.trackr_graph_+3A_fill">fill</code></td>
<td>
<p>the default node fill colour</p>
</td></tr>
<tr><td><code id="plot.trackr_graph_+3A_fontsize">fontsize</code></td>
<td>
<p>the default font size</p>
</td></tr>
<tr><td><code id="plot.trackr_graph_+3A_colour">colour</code></td>
<td>
<p>the default font colour</p>
</td></tr>
<tr><td><code id="plot.trackr_graph_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>HTML displayed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
iris %&gt;% comment("hello {.total} rows") %&gt;% history() %&gt;% plot()
</code></pre>

<hr>
<h2 id='print.trackr_graph'>Print a history graph to the console</h2><span id='topic+print.trackr_graph'></span>

<h3>Description</h3>

<p>Print a history graph to the console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_graph'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.trackr_graph_+3A_x">x</code></td>
<td>
<p>a dtrackr history graph (e.g. output from <code><a href="#topic+p_get">p_get()</a></code>)</p>
</td></tr>
<tr><td><code id="print.trackr_graph_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
iris %&gt;% comment("hello {.total} rows") %&gt;% history() %&gt;% print()
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reframe.trackr_df'>Summarise a data set</h2><span id='topic+reframe.trackr_df'></span>

<h3>Description</h3>

<p>Summarising a data set acts in the normal <code>dplyr</code> manner to collapse groups
to individual rows. Any columns resulting from the summary can be added to
the history graph. In the history this also joins any stratified branches and
allows you to generate some summary statistics about the un-grouped data. See
<code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
reframe(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reframe.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="reframe.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.</p>
</td></tr>
<tr><td><code id="reframe.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any summary
variable defined in the ... parameter, or any global variable, or
{.strata}</p>
</td></tr>
<tr><td><code id="reframe.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any summary
variable defined in the ... parameter, or any global variable, or
{.strata}</p>
</td></tr>
<tr><td><code id="reframe.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe summarised with the history graph updated showing
the summarise operation as a new stage
</p>


<h3>See Also</h3>

<p>dplyr::reframe()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% group_by(Species) %&gt;% track()
tmp %&gt;% reframe(tibble(
  param = c("mean","min","max"),
  value = c(mean(Petal.Length), min(Petal.Length), max(Petal.Length))
  ), .messages="length {param}: {value}") %&gt;% history()
</code></pre>

<hr>
<h2 id='relocate.trackr_df'>dplyr modifying operations</h2><span id='topic+relocate.trackr_df'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
relocate(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relocate.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="relocate.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>

<p>Named arguments passed on to <code><a href="dplyr.html#topic+relocate">dplyr::relocate</a></code></p>

<dl>
<dt><code>.before,.after</code></dt><dd><p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Destination of
columns selected by <code>...</code>. Supplying neither will move columns to the
left-hand side; specifying both is an error.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="relocate.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="relocate.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="relocate.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::relocate()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# relocate, this shows how the columns can be reordered
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  relocate(
    tidyselect::starts_with("Sepal"),
    .after=Species,
    .messages="{.cols}",
    .headline="Order of columns from relocate:") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='rename_with.trackr_df'>dplyr modifying operations</h2><span id='topic+rename_with.trackr_df'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
rename_with(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_with.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="rename_with.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>

<p>Named arguments passed on to <code><a href="dplyr.html#topic+rename">dplyr::rename_with</a></code></p>

<dl>
<dt><code>.fn</code></dt><dd><p>A function used to transform the selected <code>.cols</code>. Should
return a character vector the same length as the input.</p>
</dd>
<dt><code>.cols</code></dt><dd><p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to rename;
defaults to all columns.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="rename_with.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="rename_with.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="rename_with.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::rename_with()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# rename can show us which columns are new and which have been
# removed (with .dropped_cols)
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  rename(
    Stamen.Width = Sepal.Width,
    Stamen.Length = Sepal.Length,
    .messages=c("added {.new_cols}","dropped {.dropped_cols}"),
    .headline="Renamed columns:") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='rename.trackr_df'>dplyr modifying operations</h2><span id='topic+rename.trackr_df'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
rename(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="rename.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>

<p>Named arguments passed on to <code><a href="dplyr.html#topic+rename">dplyr::rename</a></code></p>

<dl>
<dt><code>.fn</code></dt><dd><p>A function used to transform the selected <code>.cols</code>. Should
return a character vector the same length as the input.</p>
</dd>
<dt><code>.cols</code></dt><dd><p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to rename;
defaults to all columns.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="rename.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="rename.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="rename.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::rename()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# rename can show us which columns are new and which have been
# removed (with .dropped_cols)
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  rename(
    Stamen.Width = Sepal.Width,
    Stamen.Length = Sepal.Length,
    .messages=c("added {.new_cols}","dropped {.dropped_cols}"),
    .headline="Renamed columns:") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='resume'>Resume tracking the data frame.</h2><span id='topic+resume'></span>

<h3>Description</h3>

<p>This may reset the grouping of the tracked data if the grouping structure
has changed since the data frame was paused. If you try and resume tracking a
data frame with too many groups (as defined by <code>options("dtrackr.max_supported_groupings"=XX)</code>)
then the resume will fail and the data frame will still be paused. This can
be overridden by specifying a value for the <code>.maxgroups</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resume(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resume_+3A_.data">.data</code></td>
<td>
<p>a tracked dataframe</p>
</td></tr>
<tr><td><code id="resume_+3A_...">...</code></td>
<td>

<p>Named arguments passed on to <code><a href="#topic+p_group_by">p_group_by</a></code></p>

<dl>
<dt><code>.messages</code></dt><dd><p>a set of glue specs. The glue code can use any global
variable, or {.cols} which is the columns that are being grouped by.</p>
</dd>
<dt><code>.headline</code></dt><dd><p>a headline glue spec. The glue code can use any global
variable, or {.cols}.</p>
</dd>
<dt><code>.tag</code></dt><dd><p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</dd>
<dt><code>.maxgroups</code></dt><dd><p>the maximum number of subgroups allowed before the tracking
is paused.</p>
</dd>
<dt><code>...</code></dt><dd><p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.
Named arguments passed on to <code><a href="dplyr.html#topic+group_by">dplyr::group_by</a></code></p>

<dl>
<dt><code>.add</code></dt><dd><p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</dd>
<dt><code>.drop</code></dt><dd><p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</dd>
<dt><code>x</code></dt><dd><p>A <code><a href="dplyr.html#topic+tbl">tbl()</a></code></p>
</dd>
</dl>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data data frame with history graph tracking resumed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
iris %&gt;% track() %&gt;% pause() %&gt;% resume() %&gt;% history()
</code></pre>

<hr>
<h2 id='right_join.trackr_df'>Right join</h2><span id='topic+right_join.trackr_df'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
right_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS",
    "{.count.out} in linked set"),
  .headline = "Right join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="right_join.trackr_df_+3A_x">x</code>, <code id="right_join.trackr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="right_join.trackr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>suffix</code></dt><dd><p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</dd>
<dt><code>keep</code></dt><dd><p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
<dt><code>multiple</code></dt><dd><p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</dd>
<dt><code>unmatched</code></dt><dd><p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</dd>
<dt><code>relationship</code></dt><dd><p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="right_join.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="right_join.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::right_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Full join
join = lhs %&gt;% full_join(rhs, by="name", multiple = "all") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()

</code></pre>

<hr>
<h2 id='save_dot'>Save DOT content to a file</h2><span id='topic+save_dot'></span>

<h3>Description</h3>

<p>Convert a digraph in dot format to SVG and save it to a range of output file types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_dot(
  dot,
  filename,
  size = std_size$half,
  maxWidth = size$width,
  maxHeight = size$height,
  formats = c("dot", "png", "pdf", "svg"),
  landscape = size$rot != 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_dot_+3A_dot">dot</code></td>
<td>
<p>a <code>graphviz</code> dot string</p>
</td></tr>
<tr><td><code id="save_dot_+3A_filename">filename</code></td>
<td>
<p>the full path of the file name (minus extension for multiple
formats)</p>
</td></tr>
<tr><td><code id="save_dot_+3A_size">size</code></td>
<td>
<p>a named list with 3 elements, length and width in inches and
rotation. A predefined set of standard sizes are available in the
<a href="#topic+std_size">std_size</a> object.</p>
</td></tr>
<tr><td><code id="save_dot_+3A_maxwidth">maxWidth</code></td>
<td>
<p>a width (on the paper) in inches if <code>size</code> is not defined</p>
</td></tr>
<tr><td><code id="save_dot_+3A_maxheight">maxHeight</code></td>
<td>
<p>a height (on the paper) in inches if <code>size</code> is not defined</p>
</td></tr>
<tr><td><code id="save_dot_+3A_formats">formats</code></td>
<td>
<p>some of <code>pdf</code>,<code>dot</code>,<code>svg</code>,<code>png</code>,<code>ps</code></p>
</td></tr>
<tr><td><code id="save_dot_+3A_landscape">landscape</code></td>
<td>
<p>rotate the output by 270 degrees into a landscape format.
<code>maxWidth</code> and <code>maxHeight</code> still apply and refer to the paper width to fit
the flowchart into after rotation. (you might need to flip width and height)</p>
</td></tr>
<tr><td><code id="save_dot_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with items <code>paths</code> with the absolute paths of the saved files
as a named list, and <code>svg</code> as the SVG string of the rendered dot file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>save_dot("digraph {A-&gt;B}",tempfile())
</code></pre>

<hr>
<h2 id='select.trackr_df'>dplyr modifying operations</h2><span id='topic+select.trackr_df'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
select(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="select.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="select.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="select.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="select.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::select()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# select
# The output of the select verb (here using tidyselect syntax) can be captured
# and here all column names are being reported with the .cols variable.
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  select(
    tidyselect::starts_with("Sepal"),
    .messages="{.cols}",
    .headline="Output columns from select:") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='semi_join.trackr_df'>Semi join</h2><span id='topic+semi_join.trackr_df'></span>

<h3>Description</h3>

<p>Mutating joins behave as <code>dplyr</code> joins, except the history graph of the two
sides of the joins is merged resulting in a tracked dataframe with the
history of both input dataframes. See <code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code> for more details
on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
semi_join(
  x,
  y,
  ...,
  .messages = c("{.count.lhs} on LHS", "{.count.rhs} on RHS",
    "{.count.out} in intersection"),
  .headline = "Semi join by {.keys}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semi_join.trackr_df_+3A_x">x</code>, <code id="semi_join.trackr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="semi_join.trackr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.
Named arguments passed on to <code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join</a></code></p>

<dl>
<dt><code>by</code></dt><dd><p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</dd>
<dt><code>copy</code></dt><dd><p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</dd>
<dt><code>na_matches</code></dt><dd><p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="semi_join.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.keys} for the joining columns, {.count.lhs},
{.count.rhs}, {.count.out} for the input and output dataframes sizes
respectively</p>
</td></tr>
<tr><td><code id="semi_join.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.keys} for the joining columns, {.count.lhs}, {.count.rhs},
{.count.out} for the input and output dataframes sizes respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the join of the two dataframes with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::semi_join()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
# Joins across data sets

# example data uses the dplyr starways data
people = starwars %&gt;% select(-films, -vehicles, -starships)
films = starwars %&gt;% select(name,films) %&gt;% tidyr::unnest(cols = c(films))

lhs = people %&gt;% track() %&gt;% comment("People df {.total}")
rhs = films %&gt;% track() %&gt;% comment("Films df {.total}") %&gt;%
  comment("a test comment")

# Semi join
join = lhs %&gt;% semi_join(rhs, by="name") %&gt;% comment("joined {.total}")
# See what the history of the graph is:
join %&gt;% history() %&gt;% print()
nrow(join)
# Display the tracked graph (not run in examples)
# join %&gt;% flowchart()

</code></pre>

<hr>
<h2 id='setdiff.trackr_df'>Set operations</h2><span id='topic+setdiff.trackr_df'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
setdiff(
  x,
  y,
  ...,
  .messages = "{.count.out} items in difference",
  .headline = "Difference"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setdiff.trackr_df_+3A_x">x</code>, <code id="setdiff.trackr_df_+3A_y">y</code></td>
<td>
<p>Vectors to combine.</p>
</td></tr>
<tr><td><code id="setdiff.trackr_df_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine</p>
</td></tr>
<tr><td><code id="setdiff.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="setdiff.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::setdiff()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='slice_head.trackr_df'>Slice operations</h2><span id='topic+slice_head.trackr_df'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
slice_head(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_head.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="slice_head.trackr_df_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice_head</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="slice_head.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="slice_head.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice_head()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# the first 50% of the data frame, is taken and the history tracked
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_head(prop=0.5,.messages="{.count.out} / {.count.in}",
             .headline="First {sprintf('%1.0f',prop*100)}%") %&gt;%
  history()

# The last 100 items:
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_tail(n=100,.messages="{.count.out} / {.count.in}",
             .headline="Last 100") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='slice_max.trackr_df'>Slice operations</h2><span id='topic+slice_max.trackr_df'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
slice_max(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_max.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="slice_max.trackr_df_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice_max</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="slice_max.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="slice_max.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice_max()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)


# Subset the data by the maximum of a given value
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_max(prop=0.5, order_by = Sepal.Width,
            .messages="{.count.out} / {.count.in} = {prop} (with ties)",
            .headline="Widest 50% Sepals") %&gt;%
  history()


# The narrowest 25% of the iris data set by group can be calculated in the
# slice_min() function. Recording this is a matter of tracking and
# using glue specs.
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  slice_min(prop=0.25, order_by = Sepal.Width,
            .messages="{.count.out} / {.count.in} (with ties)",
            .headline="narrowest {sprintf('%1.0f',prop*100)}% {Species}") %&gt;%
  history()

</code></pre>

<hr>
<h2 id='slice_min.trackr_df'>Slice operations</h2><span id='topic+slice_min.trackr_df'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
slice_min(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_min.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="slice_min.trackr_df_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice_min</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="slice_min.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="slice_min.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice_min()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)


# Subset the data by the maximum of a given value
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_max(prop=0.5, order_by = Sepal.Width,
            .messages="{.count.out} / {.count.in} = {prop} (with ties)",
            .headline="Widest 50% Sepals") %&gt;%
  history()


# The narrowest 25% of the iris data set by group can be calculated in the
# slice_min() function. Recording this is a matter of tracking and
# using glue specs.
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  slice_min(prop=0.25, order_by = Sepal.Width,
            .messages="{.count.out} / {.count.in} (with ties)",
            .headline="narrowest {sprintf('%1.0f',prop*100)}% {Species}") %&gt;%
  history()

</code></pre>

<hr>
<h2 id='slice_sample.trackr_df'>Slice operations</h2><span id='topic+slice_sample.trackr_df'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
slice_sample(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_sample.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="slice_sample.trackr_df_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice_sample</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="slice_sample.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="slice_sample.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice_sample()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# In this example the iris dataframe is resampled 100 times with replacement
# within each group and the
iris %&gt;%
  track() %&gt;%
  group_by(Species) %&gt;%
  slice_sample(n=100, replace=TRUE,
               .messages="{.count.out} / {.count.in} = {n}",
               .headline="100 {Species}") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='slice_tail.trackr_df'>Slice operations</h2><span id='topic+slice_tail.trackr_df'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
slice_tail(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_tail.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="slice_tail.trackr_df_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice_tail</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="slice_tail.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="slice_tail.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice_tail()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# the first 50% of the data frame, is taken and the history tracked
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_head(prop=0.5,.messages="{.count.out} / {.count.in}",
             .headline="First {sprintf('%1.0f',prop*100)}%") %&gt;%
  history()

# The last 100 items:
iris %&gt;% track() %&gt;% group_by(Species) %&gt;%
  slice_tail(n=100,.messages="{.count.out} / {.count.in}",
             .headline="Last 100") %&gt;%
  history()
</code></pre>

<hr>
<h2 id='slice.trackr_df'>Slice operations</h2><span id='topic+slice.trackr_df'></span>

<h3>Description</h3>

<p>Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>,
<code><a href="dplyr.html#topic+slice">dplyr::slice_min()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_max()</a></code>, <code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>,
for more details on the underlying functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
slice(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="slice.trackr_df_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.
Named arguments passed on to <code><a href="dplyr.html#topic+slice">dplyr::slice</a></code></p>

<dl>
<dt><code>.by,by</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</dd>
<dt><code>.preserve</code></dt><dd><p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</dd>
<dt><code>n,prop</code></dt><dd><p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</dd>
<dt><code>order_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</dd>
<dt><code>with_ties</code></dt><dd><p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</dd>
<dt><code>na_rm</code></dt><dd><p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</dd>
<dt><code>weight_by</code></dt><dd><p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</dd>
<dt><code>replace</code></dt><dd><p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="slice.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, {.count.in}, {.count.out} for the input and output dataframes
sizes respectively and {.excluded} for the difference</p>
</td></tr>
<tr><td><code id="slice.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable,
{.count.in}, {.count.out} for the input and output dataframes sizes
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sliced dataframe with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::slice()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# an arbitrary 50 items from the iris dataframe is selected. The
# history is tracked
iris %&gt;% track() %&gt;% slice(51:100) %&gt;% history()

</code></pre>

<hr>
<h2 id='status'>Add a summary to the dtrackr history graph</h2><span id='topic+status'></span>

<h3>Description</h3>

<p>In the middle of a pipeline you may wish to document something about the data
that is more complex than the simple counts. <code>status</code> is essentially a
<code>dplyr</code> summarisation step which is connected to a <code>glue</code> specification
output, that is recorded in the data frame history. This means you can do an
arbitrary interim summarisation and put the result into the flowchart without
disrupting the pipeline flow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status(
  .data,
  ...,
  .messages = .defaultMessage(),
  .headline = .defaultHeadline(),
  .type = "info",
  .asOffshoot = FALSE,
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="status_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="status_+3A_...">...</code></td>
<td>
<p>any normal dplyr::summarise specification, e.g. <code>count=n()</code> or
<code>av=mean(x)</code>, etcetera.</p>
</td></tr>
<tr><td><code id="status_+3A_.messages">.messages</code></td>
<td>
<p>a character vector of glue specifications. A glue
specification can refer to the summary outputs, any grouping variables of
.data, the {.strata}, or any variables defined in the calling environment</p>
</td></tr>
<tr><td><code id="status_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, or any variables defined in the calling environment</p>
</td></tr>
<tr><td><code id="status_+3A_.type">.type</code></td>
<td>
<p>one of &quot;info&quot;,&quot;exclusion&quot;: used to define formatting</p>
</td></tr>
<tr><td><code id="status_+3A_.asoffshoot">.asOffshoot</code></td>
<td>
<p>do you want this comment to be an offshoot of the main
flow (default = FALSE).</p>
</td></tr>
<tr><td><code id="status_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because of the ... summary specification parameters MUST BE NAMED.
</p>


<h3>Value</h3>

<p>the same .data dataframe with the history metadata updated with the
status inserted as a new stage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
tmp = iris %&gt;% track() %&gt;% group_by(Species)
tmp %&gt;% status(
      long = p_count_if(Petal.Length&gt;5),
      short = p_count_if(Petal.Length&lt;2),
      .messages="{Species}: {long} long ones &amp; {short} short ones"
) %&gt;% history()
</code></pre>

<hr>
<h2 id='std_size'>Standard paper sizes</h2><span id='topic+std_size'></span>

<h3>Description</h3>

<p>A list of standard paper sizes for outputting flowcharts or other dot
graphs. These include width and height dimensions in inches and can be
used as one way to specify the output size of a dot graph, including
flowcharts (see the <code>size</code> parameter of <code><a href="#topic+flowchart">flowchart()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std_size
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 12.
</p>


<h3>Details</h3>

<p>The sizes available are <code>A4</code>, <code>A5</code>, <code>full</code> (fits a portrait A4 with margins), <code>half</code> (half an
A4 with margins), <code>third</code>, <code>two_third</code>, <code>quarter</code>, <code>sixth</code> (all with reference to
an A4 page with margins). There are 2 landscape sizes <code>A4_landscape</code> and <code>full_landscape</code> which
fit an A4 page with or without margins. There are also 2 slide dimensions,
to fit with standard presentation software dimensions.
</p>
<p>This is just a convenience. Similar effects can be achieved by providing <code>width</code> and <code>height</code>
parameters to <code><a href="#topic+flowchart">flowchart()</a></code> directly.
</p>

<hr>
<h2 id='summarise.trackr_df'>Summarise a data set</h2><span id='topic+summarise.trackr_df'></span>

<h3>Description</h3>

<p>Summarising a data set acts in the normal <code>dplyr</code> manner to collapse groups
to individual rows. Any columns resulting from the summary can be added to
the history graph. In the history this also joins any stratified branches and
allows you to generate some summary statistics about the un-grouped data. See
<code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
summarise(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="summarise.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.</p>
</td></tr>
<tr><td><code id="summarise.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any summary
variable defined in the ... parameter, or any global variable, or
{.strata}</p>
</td></tr>
<tr><td><code id="summarise.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any summary
variable defined in the ... parameter, or any global variable, or
{.strata}</p>
</td></tr>
<tr><td><code id="summarise.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe summarised with the history graph updated showing
the summarise operation as a new stage
</p>


<h3>See Also</h3>

<p>dplyr::summarise()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% group_by(Species) %&gt;% track()
tmp %&gt;% summarise(avg = mean(Petal.Length), .messages="{avg} length") %&gt;% history()
</code></pre>

<hr>
<h2 id='tagged'>Retrieve tagged data in the history graph</h2><span id='topic+tagged'></span>

<h3>Description</h3>

<p>Any counts at the individual stages that was stored with a <code>.tag</code> option in a pipeline step can be recovered here. The idea here is to provide a quick way to access a single value
for the counts or other details tagged in a pipeline into a format that can be reported in text of a document. (e.g. for a results section). For more examples the consort statement vignette
has some examples of use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tagged(.data, .tag = NULL, .strata = NULL, .glue = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tagged_+3A_.data">.data</code></td>
<td>
<p>the tracked dataframe.</p>
</td></tr>
<tr><td><code id="tagged_+3A_.tag">.tag</code></td>
<td>
<p>(optional) the tag to retrieve.</p>
</td></tr>
<tr><td><code id="tagged_+3A_.strata">.strata</code></td>
<td>
<p>(optional) filter the tagged data by the strata. set to &quot;&quot; to filter just the top level ungrouped data.</p>
</td></tr>
<tr><td><code id="tagged_+3A_.glue">.glue</code></td>
<td>
<p>(optional) a glue specification which will be applied to the tagged content to generate a <code>.label</code> for the tagged content.</p>
</td></tr>
<tr><td><code id="tagged_+3A_...">...</code></td>
<td>
<p>(optional) any other named parameters will be passed to <code>glue::glue</code> and can be used to generate a label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>various things depending on what is requested.
</p>
<p>By default a tibble with a <code>.tag</code> column and all associated summary values in a nested <code>.content</code> column.
</p>
<p>If a <code>.strata</code> column is specified the results are filtered to just those that match a given <code>.strata</code> grouping (i.e. this will be the grouping label on the flowchart). Ungrouped content will have an empty &quot;&quot; as <code>.strata</code>
</p>
<p>If <code>.tag</code> is specified the result will be for a single tag and <code>.content</code> will be automatically un-nested to give a single un-nested dataframe of the content captured at the <code>.tag</code> tagged step.
This could be single or multiple rows depending on whether the original data was grouped at the point of tagging.
</p>
<p>If both the <code>.tag</code> and <code>.glue</code> is specified a <code>.label</code> column will be computed from <code>.glue</code> and the tagged content. If the result of this is a single row then just the string value of <code>.label</code> is returned.
</p>
<p>If just the <code>.glue</code> is specified, an un-nested dataframe with <code>.tag</code>,<code>.strata</code> and <code>.label</code> columns with a label for each tag in each strata.
</p>
<p>If this seems complex then the best thing is to experiment until you get the output you want, leaving any <code>.glue</code> options until you think you know what you are doing. It made sense at the time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
tmp = iris %&gt;% track() %&gt;% comment(.tag = "step1")
tmp = tmp %&gt;% filter(Species!="versicolor") %&gt;% group_by(Species)
tmp %&gt;% comment(.tag="step2") %&gt;% tagged(.glue = "{.count}/{.total}")
</code></pre>

<hr>
<h2 id='track'>Start tracking the dtrackr history graph</h2><span id='topic+track'></span>

<h3>Description</h3>

<p>Start tracking the dtrackr history graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track(
  .data,
  .messages = .defaultMessage(),
  .headline = .defaultHeadline(),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track_+3A_.data">.data</code></td>
<td>
<p>a dataframe which may be grouped</p>
</td></tr>
<tr><td><code id="track_+3A_.messages">.messages</code></td>
<td>
<p>a character vector of glue specifications. A glue
specification can refer to any grouping variables of .data, or any
variables defined in the calling environment, the {.total} variable which
is the count of all rows, the {.count} variable which is the count of
rows in the current group and the {.strata} which describes the current
group. Defaults to the value of <code>getOption("dtrackr.default_message")</code>.</p>
</td></tr>
<tr><td><code id="track_+3A_.headline">.headline</code></td>
<td>
<p>a glue specification which can refer to grouping variables
of .data, or any variables defined in the calling environment, or the
{.total} variable which is <code>nrow(.data)</code>, or {.strata} a summary of the
current group. Defaults to the value of <code>getOption("dtrackr.default_headline")</code>.</p>
</td></tr>
<tr><td><code id="track_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with additional history graph metadata, to allow
tracking.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
iris %&gt;% track() %&gt;% history()
</code></pre>

<hr>
<h2 id='transmute.trackr_df'>dplyr modifying operations</h2><span id='topic+transmute.trackr_df'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::add_tally()</a></code>,
<code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>, <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details
on underlying functions. <code>dtrackr</code> provides equivalent functions for
mutating, selecting and renaming a data set which act in the same way as
<code>dplyr</code>. <code>mutate</code> / <code>select</code> / <code>rename</code> generally don't add anything in terms
of provenance of data so the default behaviour is to miss these out of the
<code>dtrackr</code> history. This can be overridden with the <code>.messages</code>, or
<code>.headline</code> values in which case they behave just like a <code>comment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
transmute(.data, ..., .messages = "", .headline = "", .tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transmute.trackr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="transmute.trackr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="transmute.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, grouping variable, {.new_cols} or {.dropped_cols} for changes to
columns, {.cols} for the output column names, or {.strata}. Defaults to nothing.</p>
</td></tr>
<tr><td><code id="transmute.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use any global
variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} or {.strata}.
Defaults to nothing.</p>
</td></tr>
<tr><td><code id="transmute.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>.data</code> dataframe after being modified by the <code>dplyr</code> equivalent
function, but with the history graph updated with a new stage if the
<code>.messages</code> or <code>.headline</code> parameter is not empty.
</p>


<h3>See Also</h3>

<p>dplyr::transmute()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# mutate and other functions are unitary operations that generally change
# the structure but not size of a dataframe. In dtrackr these are by ignored
# by default but we can change that so that their behaviour is obvious.

# In this example we compare the column names of the input and the
# output to identify the new columns created by the transmute operation as
# the `.new_cols` variable
# Here we do the same for a transmute()
iris %&gt;%
  track() %&gt;%
  group_by(Species, .add=TRUE) %&gt;%
  transmute(
    sepal.w = Sepal.Width-1,
    sepal.l = Sepal.Length+1,
    .messages="{.new_cols}",
    .headline="New columns from transmute:") %&gt;%
  history()

</code></pre>

<hr>
<h2 id='ungroup.trackr_df'>Remove a stratification from a data set</h2><span id='topic+ungroup.trackr_df'></span>

<h3>Description</h3>

<p>Un-grouping a data set logically combines the different arms. In the history
this joins any stratified branches and acts as a specific type of <code><a href="#topic+status">status()</a></code>,
allowing you to generate some summary statistics about the un-grouped data.
See <code><a href="dplyr.html#topic+group_by">dplyr::ungroup()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
ungroup(
  x,
  ...,
  .messages = .defaultMessage(),
  .headline = .defaultHeadline(),
  .tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ungroup.trackr_df_+3A_x">x</code></td>
<td>
<p>A <code><a href="dplyr.html#topic+tbl">tbl()</a></code></p>
</td></tr>
<tr><td><code id="ungroup.trackr_df_+3A_...">...</code></td>
<td>
<p>variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="ungroup.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any any global
variable, or {.count}. the default is &quot;total {.count} items&quot;</p>
</td></tr>
<tr><td><code id="ungroup.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a headline glue spec. The glue code can use {.count} and
{.strata}.</p>
</td></tr>
<tr><td><code id="ungroup.trackr_df_+3A_.tag">.tag</code></td>
<td>
<p>if you want the summary data from this step in the future then
give it a name with .tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe but ungrouped with the history graph
updated showing the ungroup operation as a new stage.
</p>


<h3>See Also</h3>

<p>dplyr::ungroup()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

tmp = iris %&gt;% group_by(Species) %&gt;% comment("A test")
tmp %&gt;% ungroup(.messages="{.count} items in combined") %&gt;% history()
</code></pre>

<hr>
<h2 id='union_all.trackr_df'>Set operations</h2><span id='topic+union_all.trackr_df'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
union_all(
  x,
  y,
  ...,
  .messages = "{.count.out} items in union",
  .headline = "Union"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="union_all.trackr_df_+3A_x">x</code>, <code id="union_all.trackr_df_+3A_y">y</code></td>
<td>
<p>Pair of compatible data frames. A pair of data frames is
compatible if they have the same column names (possibly in different
orders) and compatible types.</p>
</td></tr>
<tr><td><code id="union_all.trackr_df_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine</p>
</td></tr>
<tr><td><code id="union_all.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="union_all.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>dplyr::union_all()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='union.trackr_df'>Set operations</h2><span id='topic+union.trackr_df'></span>

<h3>Description</h3>

<p>These perform set operations on tracked dataframes. It merges the history
of 2 (or more) dataframes and combines the rows (or columns). It calculates the total number of
resulting rows as {.count.out} in other terms it performs exactly the same
operation as the equivalent <code>dplyr</code> operation. See <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>,
<code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>,
<code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>,<code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, or <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> for the
underlying function details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackr_df'
union(
  x,
  y,
  ...,
  .messages = "{.count.out} unique items in union",
  .headline = "Distinct union"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="union.trackr_df_+3A_x">x</code>, <code id="union.trackr_df_+3A_y">y</code></td>
<td>
<p>Vectors to combine.</p>
</td></tr>
<tr><td><code id="union.trackr_df_+3A_...">...</code></td>
<td>
<p>a collection of tracked data frames to combine</p>
</td></tr>
<tr><td><code id="union.trackr_df_+3A_.messages">.messages</code></td>
<td>
<p>a set of glue specs. The glue code can use any global
variable, or {.count.out}</p>
</td></tr>
<tr><td><code id="union.trackr_df_+3A_.headline">.headline</code></td>
<td>
<p>a glue spec. The glue code can use any global variable, or
{.count.out}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dplyr output with the history graph updated.
</p>


<h3>See Also</h3>

<p>generics::union()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)

# Set operations
people = starwars %&gt;% select(-films, -vehicles, -starships)
chrs = people %&gt;% track("start")

lhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Droid" ~ "{.included} droids"
)

# these are different subsets of the same data
rhs = chrs %&gt;% include_any(
  species == "Human" ~ "{.included} humans",
  species == "Gungan" ~ "{.included} gungans"
) %&gt;% comment("{.count} gungans &amp; humans")


# Unions
set = bind_rows(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union(lhs,rhs) %&gt;% comment("{.count} human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = union_all(lhs,rhs) %&gt;% comment("{.count} 2*human,droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

# Intersections and differences

set = setdiff(lhs,rhs) %&gt;% comment("{.count} droids and gungans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()

set = intersect(lhs,rhs) %&gt;% comment("{.count} humans")
# display the history of the result:
set %&gt;% history()
nrow(set)
# not run - display the flowchart:
# set %&gt;% flowchart()
</code></pre>

<hr>
<h2 id='untrack'>Remove tracking from the dataframe</h2><span id='topic+untrack'></span>

<h3>Description</h3>

<p>Remove tracking from the dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untrack(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="untrack_+3A_.data">.data</code></td>
<td>
<p>a tracked dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the .data dataframe with history graph metadata removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(dtrackr)
iris %&gt;% track() %&gt;% untrack() %&gt;% class()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
