<!DOCTYPE html><html lang="en"><head><title>Help for package AllelicSeries</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AllelicSeries}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AllelicSeries-package'><p>AllelicSeries: Allelic Series Test</p></a></li>
<li><a href='#Aggregator'><p>Aggregator</p></a></li>
<li><a href='#ASBT'><p>Allelic Series Burden Test</p></a></li>
<li><a href='#ASBTSS'><p>Allelic Series Burden Test from Summary Statistics</p></a></li>
<li><a href='#ASKAT'><p>Allelic Series SKAT Test</p></a></li>
<li><a href='#ASKATSS'><p>Allelic Series SKAT-O from Summary Statistics</p></a></li>
<li><a href='#BaselineSS'><p>Baseline Counts Test from Sumstats</p></a></li>
<li><a href='#CalcRegParam'><p>Calculate Regression Parameters</p></a></li>
<li><a href='#CalcSumstats'><p>Calculate Summary Statistics</p></a></li>
<li><a href='#CheckInputs'><p>Check Inputs</p></a></li>
<li><a href='#CheckInputsSS'><p>Input Checks for Summary Statistics</p></a></li>
<li><a href='#COAST'><p>COding-variant Allelic Series Test</p></a></li>
<li><a href='#COAST-class'><p>Allelic Series Output Class</p></a></li>
<li><a href='#COASTSS'><p>COding-variant Allelic Series Test from Summary Statistics</p></a></li>
<li><a href='#Comparator'><p>Comparator Test</p></a></li>
<li><a href='#CorCpp'><p>Correlation C++</p></a></li>
<li><a href='#Counts'><p>Count Variants and Carriers</p></a></li>
<li><a href='#DfOrNULL-class'><p>Data.frame or Null Class</p></a></li>
<li><a href='#DGP'><p>Data Generating Process</p></a></li>
<li><a href='#FilterGenos'><p>Filter Noncausal Variants</p></a></li>
<li><a href='#GenAnno'><p>Generate Genotype Annotations</p></a></li>
<li><a href='#GenCovar'><p>Generate Covariates</p></a></li>
<li><a href='#GenGeno'><p>Generate Genotypes</p></a></li>
<li><a href='#GenGenoMat'><p>Generate Genotype Matrix</p></a></li>
<li><a href='#GenomicControl'><p>Genomic Control</p></a></li>
<li><a href='#GenPheno'><p>Generate Phenotypes</p></a></li>
<li><a href='#isPD'><p>Check if Positive Definite</p></a></li>
<li><a href='#OLS'><p>Ordinary Least Squares</p></a></li>
<li><a href='#print.COAST'><p>Print Method for COAST Object.</p></a></li>
<li><a href='#ResidVar'><p>Calculate Residual Variance</p></a></li>
<li><a href='#Score'><p>Calculate Score Statistic</p></a></li>
<li><a href='#show+2CCOAST-method'><p>Show Method for COAST Object</p></a></li>
<li><a href='#SumCountSS'><p>Allelic Sum Test from Sumstats</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Allelic Series Test</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of gene-level rare variant association tests targeting allelic series: genes where increasingly deleterious mutations have increasingly large phenotypic effects. The COding-variant Allelic Series Test (COAST) operates on the benign missense variants (BMVs), deleterious missense variants (DMVs), and protein truncating variants (PTVs) within a gene. COAST uses a set of adjustable weights that tailor the test towards rejecting the null hypothesis for genes where the average magnitude of effect increases monotonically from BMVs to DMVs to PTVs. See McCaw ZR, O’Dushlaine C, Somineni H, Bereket M, Klein C, Karaletsos T, Casale FP, Koller D, Soare TW. (2023) "An allelic series rare variant association test for candidate gene discovery" &lt;<a href="https://doi.org/10.1016%2Fj.ajhg.2023.07.001">doi:10.1016/j.ajhg.2023.07.001</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/insitro/AllelicSeries">https://github.com/insitro/AllelicSeries</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>CompQuadForm, glue, methods, Rcpp, RNOmni, SKAT</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-23 02:24:26 UTC; zmccaw</td>
</tr>
<tr>
<td>Author:</td>
<td>Zachary McCaw <a href="https://orcid.org/0000-0002-2006-9828"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Christoph Klein <a href="https://orcid.org/0000-0002-1748-625X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Thomas Soare <a href="https://orcid.org/0000-0002-4903-8646"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jianhui Gao <a href="https://orcid.org/0000-0003-0915-1473"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  insitro [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zachary McCaw &lt;zmccaw@insitro.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-23 15:20:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='AllelicSeries-package'>AllelicSeries: Allelic Series Test</h2><span id='topic+AllelicSeries'></span><span id='topic+AllelicSeries-package'></span>

<h3>Description</h3>

<p>Implementation of gene-level rare variant association tests targeting allelic series: genes where increasingly deleterious mutations have increasingly large phenotypic effects. The COding-variant Allelic Series Test (COAST) operates on the benign missense variants (BMVs), deleterious missense variants (DMVs), and protein truncating variants (PTVs) within a gene. COAST uses a set of adjustable weights that tailor the test towards rejecting the null hypothesis for genes where the average magnitude of effect increases monotonically from BMVs to DMVs to PTVs. See McCaw ZR, O’Dushlaine C, Somineni H, Bereket M, Klein C, Karaletsos T, Casale FP, Koller D, Soare TW. (2023) &quot;An allelic series rare variant association test for candidate gene discovery&quot; <a href="https://doi.org/10.1016/j.ajhg.2023.07.001">doi:10.1016/j.ajhg.2023.07.001</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Zachary McCaw <a href="mailto:zmccaw@insitro.com">zmccaw@insitro.com</a> (<a href="https://orcid.org/0000-0002-2006-9828">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Christoph Klein <a href="mailto:cklein@insitro.com">cklein@insitro.com</a> (<a href="https://orcid.org/0000-0002-1748-625X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Thomas Soare <a href="mailto:tsoare@insitro.com">tsoare@insitro.com</a> (<a href="https://orcid.org/0000-0002-4903-8646">ORCID</a>) [contributor]
</p>
</li>
<li><p> Jianhui Gao <a href="mailto:jianhui.gao@mail.utoronto.ca">jianhui.gao@mail.utoronto.ca</a> (<a href="https://orcid.org/0000-0003-0915-1473">ORCID</a>) [contributor]
</p>
</li>
<li><p> insitro [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/insitro/AllelicSeries">https://github.com/insitro/AllelicSeries</a>
</p>
</li></ul>


<hr>
<h2 id='Aggregator'>Aggregator</h2><span id='topic+Aggregator'></span>

<h3>Description</h3>

<p>Aggregates genotypes within annotation categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aggregator(
  anno,
  geno,
  drop_empty = TRUE,
  indicator = FALSE,
  method = "none",
  min_mac = 0,
  weights = c(1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Aggregator_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with integer values in 1 through
the number of annotation categories L.</p>
</td></tr>
<tr><td><code id="Aggregator_+3A_geno">geno</code></td>
<td>
<p>(n x snps) genotype matrix.</p>
</td></tr>
<tr><td><code id="Aggregator_+3A_drop_empty">drop_empty</code></td>
<td>
<p>Drop empty columns? Default: TRUE.</p>
</td></tr>
<tr><td><code id="Aggregator_+3A_indicator">indicator</code></td>
<td>
<p>Convert raw counts to indicators? Default: FALSE.</p>
</td></tr>
<tr><td><code id="Aggregator_+3A_method">method</code></td>
<td>
<p>Method for aggregating across categories:
(&quot;none&quot;, &quot;max&quot;, &quot;sum&quot;). Default: &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="Aggregator_+3A_min_mac">min_mac</code></td>
<td>
<p>Minimum minor allele count for inclusion. Default: 0.</p>
</td></tr>
<tr><td><code id="Aggregator_+3A_weights">weights</code></td>
<td>
<p>(L x 1) vector of annotation category weights. Note that the
number of annotation categories L is inferred from the length of <code>weights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(n x L) Numeric matrix without weighting, (n x 1) numeric matrix
with weighting.
</p>


<h3>Notes</h3>


<ul>
<li><p> Ensure the length of the <code>weights</code> vector matches the total number of
annotation categories.
</p>
</li>
<li><p> The <code>weights</code> essentially scales the minor allele count in the <code>l</code>th
category by <code>weights[l]</code>.
</p>
</li></ul>


<hr>
<h2 id='ASBT'>Allelic Series Burden Test</h2><span id='topic+ASBT'></span>

<h3>Description</h3>

<p>Burden test with allelic series weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASBT(
  anno,
  geno,
  pheno,
  apply_int = TRUE,
  covar = NULL,
  indicator = FALSE,
  is_pheno_binary = FALSE,
  method = "none",
  min_mac = 0,
  return_beta = FALSE,
  score_test = FALSE,
  weights = c(1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ASBT_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with integer values in 1 through
the number of annotation categories L.</p>
</td></tr>
<tr><td><code id="ASBT_+3A_geno">geno</code></td>
<td>
<p>(n x snps) genotype matrix.</p>
</td></tr>
<tr><td><code id="ASBT_+3A_pheno">pheno</code></td>
<td>
<p>(n x 1) phenotype vector.</p>
</td></tr>
<tr><td><code id="ASBT_+3A_apply_int">apply_int</code></td>
<td>
<p>Apply rank-based inverse normal transform to the phenotype?
Default: TRUE. Ignored if phenotype is binary.</p>
</td></tr>
<tr><td><code id="ASBT_+3A_covar">covar</code></td>
<td>
<p>(n x p) covariate matrix. Defaults to an (n x 1) intercept.</p>
</td></tr>
<tr><td><code id="ASBT_+3A_indicator">indicator</code></td>
<td>
<p>Convert raw counts to indicators?</p>
</td></tr>
<tr><td><code id="ASBT_+3A_is_pheno_binary">is_pheno_binary</code></td>
<td>
<p>Is the phenotype binary? Default: FALSE.</p>
</td></tr>
<tr><td><code id="ASBT_+3A_method">method</code></td>
<td>
<p>Method for aggregating across categories: (&quot;none&quot;, &quot;max&quot;,
&quot;sum&quot;). Default: &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="ASBT_+3A_min_mac">min_mac</code></td>
<td>
<p>Minimum minor allele count for inclusion. Default: 0.</p>
</td></tr>
<tr><td><code id="ASBT_+3A_return_beta">return_beta</code></td>
<td>
<p>Return the estimated effect size? Default: FALSE.</p>
</td></tr>
<tr><td><code id="ASBT_+3A_score_test">score_test</code></td>
<td>
<p>Run a score test? If FALSE, performs a Wald test.</p>
</td></tr>
<tr><td><code id="ASBT_+3A_weights">weights</code></td>
<td>
<p>(L x 1) vector of annotation category weights. Note that the
number of annotation categories L is inferred from the length of <code>weights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_beta = TRUE</code>, a list of including the effect size
data.frame &quot;betas&quot; and the p-value &quot;pval&quot;. If <code>return_beta = FALSE</code>,
a numeric p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data.
data &lt;- DGP(n = 1e3, snps = 1e2)

# Run the Allelic Series Burden Test.
# Note: the output is a scalar p-value.
results &lt;- ASBT(
  anno = data$anno,
  geno = data$geno,
  pheno = data$pheno,
  covar = data$covar
)
</code></pre>

<hr>
<h2 id='ASBTSS'>Allelic Series Burden Test from Summary Statistics</h2><span id='topic+ASBTSS'></span>

<h3>Description</h3>

<p>Allelic series burden test from summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASBTSS(
  anno,
  beta,
  se,
  check = TRUE,
  eps = 1,
  lambda = 1,
  ld = NULL,
  method = "none",
  return_beta = FALSE,
  weights = c(1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ASBTSS_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with integer values in 1 through
the number of annotation categories L.</p>
</td></tr>
<tr><td><code id="ASBTSS_+3A_beta">beta</code></td>
<td>
<p>(snps x 1) vector of effect sizes for the coding genetic variants
within a gene.</p>
</td></tr>
<tr><td><code id="ASBTSS_+3A_se">se</code></td>
<td>
<p>(snps x 1) vector of standard errors for the effect sizes.</p>
</td></tr>
<tr><td><code id="ASBTSS_+3A_check">check</code></td>
<td>
<p>Run input checks? Default: TRUE.</p>
</td></tr>
<tr><td><code id="ASBTSS_+3A_eps">eps</code></td>
<td>
<p>Epsilon added to the diagonal of the LD matrix if not positive
definite. Note, smaller values increase the chances of a false positive.</p>
</td></tr>
<tr><td><code id="ASBTSS_+3A_lambda">lambda</code></td>
<td>
<p>Optional genomic inflation factor. Defaults to 1, which
results in no rescaling.</p>
</td></tr>
<tr><td><code id="ASBTSS_+3A_ld">ld</code></td>
<td>
<p>(snps x snps) matrix of correlations among the genetic variants.
Although ideally provided, an identity matrix is assumed if not.</p>
</td></tr>
<tr><td><code id="ASBTSS_+3A_method">method</code></td>
<td>
<p>Method for aggregating across categories:
(&quot;none&quot;, &quot;sum&quot;). Default: &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="ASBTSS_+3A_return_beta">return_beta</code></td>
<td>
<p>Return the estimated effect size? Default: FALSE.</p>
</td></tr>
<tr><td><code id="ASBTSS_+3A_weights">weights</code></td>
<td>
<p>(L x 1) vector of annotation category weights. Note that the
number of annotation categories L is inferred from the length of <code>weights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_beta = TRUE</code>, a list of including the effect size
data.frame &quot;betas&quot; and the p-value &quot;pval&quot;. If <code>return_beta = FALSE</code>,
a numeric p-value.
</p>


<h3>Notes</h3>


<ul>
<li><p> The allelic series burden does not require the minor allele frequencies.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Generate data.
data &lt;- DGP(n = 1e3)
sumstats &lt;- CalcSumstats(data = data)

# Run allelic series burden test from sumstats.
results &lt;- ASBTSS(
  anno = sumstats$sumstats$anno,
  beta = sumstats$sumstats$beta, 
  se = sumstats$sumstats$se,
  ld = sumstats$ld
)
show(results)
</code></pre>

<hr>
<h2 id='ASKAT'>Allelic Series SKAT Test</h2><span id='topic+ASKAT'></span>

<h3>Description</h3>

<p>Sequence kernel association test (SKAT) with allelic series weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASKAT(
  anno,
  geno,
  pheno,
  apply_int = TRUE,
  covar = NULL,
  is_pheno_binary = FALSE,
  min_mac = 0,
  return_null_model = FALSE,
  weights = c(1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ASKAT_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with integer values in 1 through
the number of annotation categories L.</p>
</td></tr>
<tr><td><code id="ASKAT_+3A_geno">geno</code></td>
<td>
<p>(n x snps) genotype matrix.</p>
</td></tr>
<tr><td><code id="ASKAT_+3A_pheno">pheno</code></td>
<td>
<p>(n x 1) phenotype vector.</p>
</td></tr>
<tr><td><code id="ASKAT_+3A_apply_int">apply_int</code></td>
<td>
<p>Apply rank-based inverse normal transform to the phenotype?
Default: TRUE. Ignored if phenotype is binary.</p>
</td></tr>
<tr><td><code id="ASKAT_+3A_covar">covar</code></td>
<td>
<p>(n x p) covariate matrix. Defaults to an (n x 1) intercept.</p>
</td></tr>
<tr><td><code id="ASKAT_+3A_is_pheno_binary">is_pheno_binary</code></td>
<td>
<p>Is the phenotype binary? Default: FALSE.</p>
</td></tr>
<tr><td><code id="ASKAT_+3A_min_mac">min_mac</code></td>
<td>
<p>Minimum minor allele count for inclusion. Default: 0.</p>
</td></tr>
<tr><td><code id="ASKAT_+3A_return_null_model">return_null_model</code></td>
<td>
<p>Return the null model in addition to the p-value?
Useful if running additional SKAT tests. Default: FALSE.</p>
</td></tr>
<tr><td><code id="ASKAT_+3A_weights">weights</code></td>
<td>
<p>(L x 1) vector of annotation category weights. Note that the
number of annotation categories L is inferred from the length of <code>weights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_null_model</code>, a list containing the p-value and the
SKAT null model. Otherwise, a numeric p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data.
data &lt;- DGP(n = 1e3, snps = 1e2)

# Run the Allelic Series SKAT Test.
# Note: the output is a scalar p-value.
results &lt;- ASKAT(
  anno = data$anno,
  geno = data$geno,
  pheno = data$pheno,
  covar = data$covar
)
</code></pre>

<hr>
<h2 id='ASKATSS'>Allelic Series SKAT-O from Summary Statistics</h2><span id='topic+ASKATSS'></span>

<h3>Description</h3>

<p>Allelic series sequence kernel association test from summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASKATSS(
  anno,
  beta,
  se,
  check = TRUE,
  eps = 1,
  lambda = 1,
  ld = NULL,
  maf = NULL,
  weights = c(1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ASKATSS_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with integer values in 1 through
the number of annotation categories L.</p>
</td></tr>
<tr><td><code id="ASKATSS_+3A_beta">beta</code></td>
<td>
<p>(snps x 1) vector of effect sizes for the coding genetic variants
within a gene.</p>
</td></tr>
<tr><td><code id="ASKATSS_+3A_se">se</code></td>
<td>
<p>(snps x 1) vector of standard errors for the effect sizes.</p>
</td></tr>
<tr><td><code id="ASKATSS_+3A_check">check</code></td>
<td>
<p>Run input checks? Default: TRUE.</p>
</td></tr>
<tr><td><code id="ASKATSS_+3A_eps">eps</code></td>
<td>
<p>Epsilon added to the diagonal of the LD matrix if not positive
definite. Note, smaller values increase the chances of a false positive.</p>
</td></tr>
<tr><td><code id="ASKATSS_+3A_lambda">lambda</code></td>
<td>
<p>Optional genomic inflation factor. Defaults to 1, which
results in no rescaling.</p>
</td></tr>
<tr><td><code id="ASKATSS_+3A_ld">ld</code></td>
<td>
<p>(snps x snps) matrix of correlations among the genetic variants.
Although ideally provided, an identity matrix is assumed if not.</p>
</td></tr>
<tr><td><code id="ASKATSS_+3A_maf">maf</code></td>
<td>
<p>(snps x 1) vector of minor allele frequencies. Although ideally
provided, defaults to the zero vector.</p>
</td></tr>
<tr><td><code id="ASKATSS_+3A_weights">weights</code></td>
<td>
<p>(L x 1) vector of annotation category weights. Note that the
number of annotation categories L is inferred from the length of <code>weights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric p-value of the allelic series SKAT-O test.
</p>


<h3>Notes</h3>


<ul>
<li><p> The SKAT test requires per-variant minor allele frequencies (MAFs) for
the purpose of up-weighting rarer variants. If unknown, <code>maf</code> can be
safely omitted. The only consequence is that the SKAT weights will no
longer be inversely proportional to the genotypic variance.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Generate data.
data &lt;- DGP(n = 1e3)
sumstats &lt;- CalcSumstats(data = data)

# Run allelic series SKAT test from sumstats.
# Note: the SKAT test requires MAF.
results &lt;- ASKATSS(
  anno = sumstats$sumstats$anno,
  beta = sumstats$sumstats$beta, 
  maf = sumstats$sumstats$maf,
  se = sumstats$sumstats$se,
  ld = sumstats$ld
)
show(results)
</code></pre>

<hr>
<h2 id='BaselineSS'>Baseline Counts Test from Sumstats</h2><span id='topic+BaselineSS'></span>

<h3>Description</h3>

<p>Baseline Counts Test from Sumstats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BaselineSS(anno, beta, ld, se, n_anno = 3L, return_beta = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BaselineSS_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with integer values in 1 through
the number of annotation categories L.</p>
</td></tr>
<tr><td><code id="BaselineSS_+3A_beta">beta</code></td>
<td>
<p>(snps x 1) vector of effect sizes for
the coding genetic variants within a gene.</p>
</td></tr>
<tr><td><code id="BaselineSS_+3A_ld">ld</code></td>
<td>
<p>(snps x snps) matrix of correlations among the genetic variants.</p>
</td></tr>
<tr><td><code id="BaselineSS_+3A_se">se</code></td>
<td>
<p>(snps x 1) vector of standard errors for the effect sizes.</p>
</td></tr>
<tr><td><code id="BaselineSS_+3A_n_anno">n_anno</code></td>
<td>
<p>Number of annotation categories L.</p>
</td></tr>
<tr><td><code id="BaselineSS_+3A_return_beta">return_beta</code></td>
<td>
<p>Return estimated effect sizes and standard errors?
Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_beta</code>, a list containing the category effect sizes,
standard errors, and the p-value. Otherwise, the numeric p-value only.
</p>

<hr>
<h2 id='CalcRegParam'>Calculate Regression Parameters</h2><span id='topic+CalcRegParam'></span>

<h3>Description</h3>

<p>Calculate phenotypic regression coefficients and the residual variation
based on proportion of variation explained (PVE) by each factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcRegParam(pve_age = 0.1, pve_pcs = 0.2, pve_sex = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcRegParam_+3A_pve_age">pve_age</code></td>
<td>
<p>PVE by age.</p>
</td></tr>
<tr><td><code id="CalcRegParam_+3A_pve_pcs">pve_pcs</code></td>
<td>
<p>PVE by PCs (collectively).</p>
</td></tr>
<tr><td><code id="CalcRegParam_+3A_pve_sex">pve_sex</code></td>
<td>
<p>PVE by sex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the (5 x 1) regression coefficient vector &quot;coef&quot; and
the residual standard deviation &quot;sd&quot;.
</p>

<hr>
<h2 id='CalcSumstats'>Calculate Summary Statistics</h2><span id='topic+CalcSumstats'></span>

<h3>Description</h3>

<p>Generate summary statistics from individual-level data. Provide either a
list of data as generated by <code><a href="#topic+DGP">DGP</a></code>, or all of <code>anno</code>, <code>geno</code>,
and <code>pheno</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcSumstats(
  anno = NULL,
  covar = NULL,
  data = NULL,
  geno = NULL,
  pheno = NULL,
  is_binary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcSumstats_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector.</p>
</td></tr>
<tr><td><code id="CalcSumstats_+3A_covar">covar</code></td>
<td>
<p>(subjects x covars) covariate matrix.</p>
</td></tr>
<tr><td><code id="CalcSumstats_+3A_data">data</code></td>
<td>
<p>List of data containing the annotation vector <code>anno</code>, the
covariate data <code>covar</code>, the genotype matrix <code>geno</code>, and the phenotype
vector <code>pheno</code>, as returned by <code><a href="#topic+DGP">DGP</a></code>. Overrides the other
arguments if provided.</p>
</td></tr>
<tr><td><code id="CalcSumstats_+3A_geno">geno</code></td>
<td>
<p>(subjects x snps) genotype matrix.</p>
</td></tr>
<tr><td><code id="CalcSumstats_+3A_pheno">pheno</code></td>
<td>
<p>(subjects x 1) phenotype vector.</p>
</td></tr>
<tr><td><code id="CalcSumstats_+3A_is_binary">is_binary</code></td>
<td>
<p>Is the phenotype binary? Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the following items:
</p>

<ul>
<li> <p><code>ld</code>: A SNP x SNP correlation (LD) matrix.
</p>
</li>
<li> <p><code>sumstats</code>: A SNP x 5 matrix of summary statistics, including the
.  annotation, MAF, estimated effect size, standard error, and p-value.
</p>
</li>
<li> <p><code>type</code>: Either &quot;binary&quot; or &quot;quantitative&quot;.'
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- DGP()
sumstats &lt;- CalcSumstats(data = data)
</code></pre>

<hr>
<h2 id='CheckInputs'>Check Inputs</h2><span id='topic+CheckInputs'></span>

<h3>Description</h3>

<p>Check Inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckInputs(anno, covar, geno, is_pheno_binary, pheno, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckInputs_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector.</p>
</td></tr>
<tr><td><code id="CheckInputs_+3A_covar">covar</code></td>
<td>
<p>(n x p) covariate matrix.</p>
</td></tr>
<tr><td><code id="CheckInputs_+3A_geno">geno</code></td>
<td>
<p>(n x snps) genotype matrix.</p>
</td></tr>
<tr><td><code id="CheckInputs_+3A_is_pheno_binary">is_pheno_binary</code></td>
<td>
<p>Is the phenotype binary?</p>
</td></tr>
<tr><td><code id="CheckInputs_+3A_pheno">pheno</code></td>
<td>
<p>(n x 1) phenotype vector.</p>
</td></tr>
<tr><td><code id="CheckInputs_+3A_weights">weights</code></td>
<td>
<p>(L x 1) annotation category weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='CheckInputsSS'>Input Checks for Summary Statistics</h2><span id='topic+CheckInputsSS'></span>

<h3>Description</h3>

<p>Input Checks for Summary Statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckInputsSS(anno, beta, se, lambda, ld, weights, is_skat = FALSE, maf = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckInputsSS_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with values in c(0, 1, 2).</p>
</td></tr>
<tr><td><code id="CheckInputsSS_+3A_beta">beta</code></td>
<td>
<p>(snps x 1) vector of effect sizes for the coding genetic variants
within a gene.</p>
</td></tr>
<tr><td><code id="CheckInputsSS_+3A_se">se</code></td>
<td>
<p>(snps x 1) vector of standard errors for the effect sizes.</p>
</td></tr>
<tr><td><code id="CheckInputsSS_+3A_lambda">lambda</code></td>
<td>
<p>Genomic inflation factor.</p>
</td></tr>
<tr><td><code id="CheckInputsSS_+3A_ld">ld</code></td>
<td>
<p>(snps x snps) matrix of correlations among the genetic variants.
Although ideally provided, an identity matrix is assumed if not.</p>
</td></tr>
<tr><td><code id="CheckInputsSS_+3A_weights">weights</code></td>
<td>
<p>(L x 1) annotation category weights.</p>
</td></tr>
<tr><td><code id="CheckInputsSS_+3A_is_skat">is_skat</code></td>
<td>
<p>Logical, is the check for the SKAT test?</p>
</td></tr>
<tr><td><code id="CheckInputsSS_+3A_maf">maf</code></td>
<td>
<p>(snps x 1) vector of minor allele frequencies. Although ideally
provided, defaults to the zero vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating whether the matrix was positive definite.
</p>

<hr>
<h2 id='COAST'>COding-variant Allelic Series Test</h2><span id='topic+COAST'></span>

<h3>Description</h3>

<p>Main allelic series test. Performs both Burden and SKAT type tests, then
combines the results to calculate an omnibus p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COAST(
  anno,
  geno,
  pheno,
  apply_int = TRUE,
  covar = NULL,
  include_orig_skato_all = FALSE,
  include_orig_skato_ptv = FALSE,
  is_pheno_binary = FALSE,
  min_mac = 0,
  ptv_anno = 3,
  pval_weights = NULL,
  return_omni_only = FALSE,
  score_test = FALSE,
  weights = c(1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="COAST_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with integer values in 1 through
the number of annotation categories L.</p>
</td></tr>
<tr><td><code id="COAST_+3A_geno">geno</code></td>
<td>
<p>(n x snps) genotype matrix.</p>
</td></tr>
<tr><td><code id="COAST_+3A_pheno">pheno</code></td>
<td>
<p>(n x 1) phenotype vector.</p>
</td></tr>
<tr><td><code id="COAST_+3A_apply_int">apply_int</code></td>
<td>
<p>Apply rank-based inverse normal transform to the phenotype?
Default: TRUE. Ignored if phenotype is binary.</p>
</td></tr>
<tr><td><code id="COAST_+3A_covar">covar</code></td>
<td>
<p>(n x p) covariate matrix. Defaults to an (n x 1) intercept.</p>
</td></tr>
<tr><td><code id="COAST_+3A_include_orig_skato_all">include_orig_skato_all</code></td>
<td>
<p>Include the original version of SKAT-O applied
to all variants in the omnibus test? Default: FALSE.</p>
</td></tr>
<tr><td><code id="COAST_+3A_include_orig_skato_ptv">include_orig_skato_ptv</code></td>
<td>
<p>Include the original version of SKAT-O applied
to PTV variants only in the omnibus test? Default: FALSE.</p>
</td></tr>
<tr><td><code id="COAST_+3A_is_pheno_binary">is_pheno_binary</code></td>
<td>
<p>Is the phenotype binary? Default: FALSE.</p>
</td></tr>
<tr><td><code id="COAST_+3A_min_mac">min_mac</code></td>
<td>
<p>Minimum minor allele count for inclusion. Default: 0.</p>
</td></tr>
<tr><td><code id="COAST_+3A_ptv_anno">ptv_anno</code></td>
<td>
<p>Annotation of the PTV category, only required if
include_orig_skato_ptv is set to TRUE.</p>
</td></tr>
<tr><td><code id="COAST_+3A_pval_weights">pval_weights</code></td>
<td>
<p>Optional vector of relative weights for combining the
component tests to perform the omnibus test. By default, 50% of weight is
given to the 6 burden tests, and 50% to the 1 SKAT test. If specified, the
weight vector should have length 7, and the length should be increased if
either <code>include_orig_skato_all</code> or <code>include_orig_skato_ptv</code> is active.</p>
</td></tr>
<tr><td><code id="COAST_+3A_return_omni_only">return_omni_only</code></td>
<td>
<p>Return only the omnibus p-value? Default: FALSE.</p>
</td></tr>
<tr><td><code id="COAST_+3A_score_test">score_test</code></td>
<td>
<p>Use a score test for burden analysis? If FALSE, uses a
Wald test.</p>
</td></tr>
<tr><td><code id="COAST_+3A_weights">weights</code></td>
<td>
<p>(L x 1) vector of annotation category weights. Note that the
number of annotation categories L is inferred from the length of <code>weights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>COAST</code> with slots for effect sizes, variant
counts, and p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data.
data &lt;- DGP(n = 1e3, snps = 1e2)

# Run the COding-variant Allelic Series Test.
results &lt;- COAST(
  anno = data$anno,
  geno = data$geno,
  pheno = data$pheno,
  covar = data$covar
)
show(results)

</code></pre>

<hr>
<h2 id='COAST-class'>Allelic Series Output Class</h2><span id='topic+COAST-class'></span>

<h3>Description</h3>

<p>Allelic Series Output Class
</p>


<h3>Slots</h3>


<dl>
<dt><code>Betas</code></dt><dd><p>Effect sizes and standard errors.</p>
</dd>
<dt><code>Counts</code></dt><dd><p>Allele, variant, and carrier counts.</p>
</dd>
<dt><code>Pvals</code></dt><dd><p>Result p-values.</p>
</dd>
</dl>

<hr>
<h2 id='COASTSS'>COding-variant Allelic Series Test from Summary Statistics</h2><span id='topic+COASTSS'></span>

<h3>Description</h3>

<p>Main function for performing the allelic series test from summary statistics.
Performs both Burden and SKAT type tests, then combines the results to
calculate an omnibus p-value. Note that not all tests included in
<code><a href="#topic+COAST">COAST</a></code> are available when working with summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COASTSS(
  anno,
  beta,
  se,
  check = TRUE,
  eps = 1,
  lambda = c(1, 1, 1),
  ld = NULL,
  maf = NULL,
  pval_weights = c(0.25, 0.25, 0.5),
  weights = c(1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="COASTSS_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with integer values in 1 through
the number of annotation categories L.</p>
</td></tr>
<tr><td><code id="COASTSS_+3A_beta">beta</code></td>
<td>
<p>(snps x 1) vector of effect sizes for the coding genetic variants
within a gene.</p>
</td></tr>
<tr><td><code id="COASTSS_+3A_se">se</code></td>
<td>
<p>(snps x 1) vector of standard errors for the effect sizes.</p>
</td></tr>
<tr><td><code id="COASTSS_+3A_check">check</code></td>
<td>
<p>Run input checks? Default: TRUE.</p>
</td></tr>
<tr><td><code id="COASTSS_+3A_eps">eps</code></td>
<td>
<p>Epsilon added to the diagonal of the LD matrix if not positive
definite. Note, epsilon should increase as the sample size decreases.</p>
</td></tr>
<tr><td><code id="COASTSS_+3A_lambda">lambda</code></td>
<td>
<p>Optional (3 x 1) vector of inflation factors, one for each
component test. Defaults to a 1s vector, which results in no rescaling.</p>
</td></tr>
<tr><td><code id="COASTSS_+3A_ld">ld</code></td>
<td>
<p>(snps x snps) matrix of correlations among the genetic variants.
Although ideally provided, an identity matrix is assumed if not.</p>
</td></tr>
<tr><td><code id="COASTSS_+3A_maf">maf</code></td>
<td>
<p>(snps x 1) vector of minor allele frequencies. Although ideally
provided, defaults to the zero vector.</p>
</td></tr>
<tr><td><code id="COASTSS_+3A_pval_weights">pval_weights</code></td>
<td>
<p>(3 x 1) vector of relative weights for combining the
component tests to perform the omnibus test. The default of
c(0.25, 0.25, 0.50) gives the SKAT test equal weight to the two burden tests.</p>
</td></tr>
<tr><td><code id="COASTSS_+3A_weights">weights</code></td>
<td>
<p>(L x 1) vector of annotation category weights. Note that the
number of annotation categories L is inferred from the length of <code>weights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data.
data &lt;- DGP(n = 1e3)
sumstats &lt;- CalcSumstats(data = data)

# Run the Coding-variant Allelic Series Test from summary statistics.
results &lt;- COASTSS(
  anno = sumstats$sumstats$anno,
  beta = sumstats$sumstats$beta, 
  se = sumstats$sumstats$se,
  ld = sumstats$ld,
  maf = sumstats$sumstats$maf,
)
show(results)
</code></pre>

<hr>
<h2 id='Comparator'>Comparator Test</h2><span id='topic+Comparator'></span>

<h3>Description</h3>

<p>Runs burden, SKAT, and SKAT-O, using default settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Comparator(covar, geno, pheno, apply_int = TRUE, is_pheno_binary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Comparator_+3A_covar">covar</code></td>
<td>
<p>(n x p) covariate matrix.</p>
</td></tr>
<tr><td><code id="Comparator_+3A_geno">geno</code></td>
<td>
<p>(n x snps) genotype matrix.</p>
</td></tr>
<tr><td><code id="Comparator_+3A_pheno">pheno</code></td>
<td>
<p>(n x 1) phenotype vector.</p>
</td></tr>
<tr><td><code id="Comparator_+3A_apply_int">apply_int</code></td>
<td>
<p>Apply rank-based inverse normal transform to the phenotype?
Default: TRUE. Ignored if phenotype is binary.</p>
</td></tr>
<tr><td><code id="Comparator_+3A_is_pheno_binary">is_pheno_binary</code></td>
<td>
<p>Is the phenotype binary? Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data.
data &lt;- DGP(n = 1e3, snps = 1e2)

# Run the comparators.
results &lt;- Comparator(
  geno = data$geno,
  pheno = data$pheno,
  covar = data$covar
)
</code></pre>

<hr>
<h2 id='CorCpp'>Correlation C++</h2><span id='topic+CorCpp'></span>

<h3>Description</h3>

<p>Correlation C++
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CorCpp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CorCpp_+3A_x">x</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix of correlation among the columns.
</p>


<h3>Notes</h3>

<p>Verified this function is faster that R's built-in correlation function
for large genotype matrices.
</p>

<hr>
<h2 id='Counts'>Count Variants and Carriers</h2><span id='topic+Counts'></span>

<h3>Description</h3>

<p>Count Variants and Carriers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Counts(anno, geno, n_anno, min_mac = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Counts_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with integer values in 1 through
the number of annotation categories L.</p>
</td></tr>
<tr><td><code id="Counts_+3A_geno">geno</code></td>
<td>
<p>(n x snps) genotype matrix.</p>
</td></tr>
<tr><td><code id="Counts_+3A_n_anno">n_anno</code></td>
<td>
<p>Number of annotation categories L.</p>
</td></tr>
<tr><td><code id="Counts_+3A_min_mac">min_mac</code></td>
<td>
<p>Minimum minor allele count for inclusion. Default: 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame of allele, variant, and carrier counts.
</p>

<hr>
<h2 id='DfOrNULL-class'>Data.frame or Null Class</h2><span id='topic+DfOrNULL-class'></span>

<h3>Description</h3>

<p>Data.frame or Null Class
</p>

<hr>
<h2 id='DGP'>Data Generating Process</h2><span id='topic+DGP'></span>

<h3>Description</h3>

<p>Generate a data set consisting of:
</p>

<ul>
<li> <p><code>anno</code>: (snps x 1) annotation vector.
</p>
</li>
<li> <p><code>covar</code>: (subjects x 6) covariate matrix.
</p>
</li>
<li> <p><code>geno</code>: (subjects x snps) genotype matrix.
</p>
</li>
<li> <p><code>pheno</code>: (subjects x 1) phenotype vector.
</p>
</li>
<li> <p><code>type</code>: Either &quot;binary&quot; or &quot;quantitative&quot;.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>DGP(
  anno = NULL,
  beta = c(1, 2, 3),
  binary = FALSE,
  geno = NULL,
  include_residual = TRUE,
  indicator = FALSE,
  maf_range = c(0.001, 0.005),
  method = "none",
  n = 100,
  prop_anno = c(0.5, 0.4, 0.1),
  prop_causal = 1,
  random_signs = FALSE,
  random_var = 0,
  snps = 100,
  weights = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DGP_+3A_anno">anno</code></td>
<td>
<p>Annotation vector, if providing genotypes. Should match the
number of columns in geno.</p>
</td></tr>
<tr><td><code id="DGP_+3A_beta">beta</code></td>
<td>
<p>If method = &quot;none&quot;, a (L x 1) coefficient with effect sizes for
each annotation category. By default, there are L = 3 annotation categories
corresponding to BMVs, DMVs, and PTVs. If method != &quot;none&quot;, a scalar
effect size for the allelic series burden score.</p>
</td></tr>
<tr><td><code id="DGP_+3A_binary">binary</code></td>
<td>
<p>Generate binary phenotype? Default: FALSE.</p>
</td></tr>
<tr><td><code id="DGP_+3A_geno">geno</code></td>
<td>
<p>Genotype matrix, if providing genotypes.</p>
</td></tr>
<tr><td><code id="DGP_+3A_include_residual">include_residual</code></td>
<td>
<p>Include residual? If FALSE, returns the expected
value. Intended for testing.</p>
</td></tr>
<tr><td><code id="DGP_+3A_indicator">indicator</code></td>
<td>
<p>Convert raw counts to indicators? Default: FALSE.</p>
</td></tr>
<tr><td><code id="DGP_+3A_maf_range">maf_range</code></td>
<td>
<p>Range of minor allele frequencies: c(MIN, MAX).</p>
</td></tr>
<tr><td><code id="DGP_+3A_method">method</code></td>
<td>
<p>Genotype aggregation method. Default: &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="DGP_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="DGP_+3A_prop_anno">prop_anno</code></td>
<td>
<p>Proportions of annotations in each category. Length should
equal the number of annotation categories. Default of c(0.5, 0.4, 0.1) is
based on the approximate empirical frequencies of BMVs, DMVs, and PTVs.</p>
</td></tr>
<tr><td><code id="DGP_+3A_prop_causal">prop_causal</code></td>
<td>
<p>Proportion of variants which are causal. Default: 1.0.</p>
</td></tr>
<tr><td><code id="DGP_+3A_random_signs">random_signs</code></td>
<td>
<p>Randomize signs? FALSE for burden-type genetic
architecture, TRUE for SKAT-type.</p>
</td></tr>
<tr><td><code id="DGP_+3A_random_var">random_var</code></td>
<td>
<p>Frailty variance in the case of random signs. Default: 0.</p>
</td></tr>
<tr><td><code id="DGP_+3A_snps">snps</code></td>
<td>
<p>Number of SNP in the gene. Default: 100.</p>
</td></tr>
<tr><td><code id="DGP_+3A_weights">weights</code></td>
<td>
<p>Annotation category weights. Length should match <code>prop_anno</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing: genotypes, annotations, covariates, phenotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data.
data &lt;- DGP(n = 100)

# View components.
table(data$anno)
head(data$covar)
head(data$geno[, 1:5])
hist(data$pheno)
</code></pre>

<hr>
<h2 id='FilterGenos'>Filter Noncausal Variants</h2><span id='topic+FilterGenos'></span>

<h3>Description</h3>

<p>Remove a random fraction of variants, which are designated non-causal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterGenos(anno, geno, prop_causal = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FilterGenos_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector.</p>
</td></tr>
<tr><td><code id="FilterGenos_+3A_geno">geno</code></td>
<td>
<p>(n x snps) genotype matrix.</p>
</td></tr>
<tr><td><code id="FilterGenos_+3A_prop_causal">prop_causal</code></td>
<td>
<p>Proportion of variants which are causal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the (n x snps) genotype matrix &quot;geno&quot; and the
(snps x 1) annotation vector &quot;anno&quot;.
</p>

<hr>
<h2 id='GenAnno'>Generate Genotype Annotations</h2><span id='topic+GenAnno'></span>

<h3>Description</h3>

<p>Returns a vector of length = the number of columns (SNPs) in the genotype
matrix. Each SNP is categorized into one of L categories, where L is
determined by the length of <code>prop_anno</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenAnno(snps, prop_anno = c(0.5, 0.4, 0.1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenAnno_+3A_snps">snps</code></td>
<td>
<p>Number of SNPs in the gene.</p>
</td></tr>
<tr><td><code id="GenAnno_+3A_prop_anno">prop_anno</code></td>
<td>
<p>Proportions of annotations in each category. Length should
equal the number of annotation categories. Default of c(0.5, 0.4, 0.1) is
based on the approximate empirical frequencies of BMVs, DMVs, and PTVs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(snps x 1) integer vector.
</p>

<hr>
<h2 id='GenCovar'>Generate Covariates</h2><span id='topic+GenCovar'></span>

<h3>Description</h3>

<p>Generate an (n x 6) covariate matrix with columns representing an intercept,
age, sex, and 3 genetic PCs. Because these simulations address rare variant
analysis, correlation between genotypes and the genetic PCs (based on
common variants) is unnecessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenCovar(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenCovar_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(n x 6) numeric matrix.
</p>

<hr>
<h2 id='GenGeno'>Generate Genotypes</h2><span id='topic+GenGeno'></span>

<h3>Description</h3>

<p>Generates genotypes in linkage equilibrium with accompanying annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenGeno(n, snps, maf_range = c(0.001, 0.005), prop_anno = c(0.5, 0.4, 0.1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenGeno_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="GenGeno_+3A_snps">snps</code></td>
<td>
<p>Number of SNP in the gene.</p>
</td></tr>
<tr><td><code id="GenGeno_+3A_maf_range">maf_range</code></td>
<td>
<p>Range of minor allele frequencies: c(MIN, MAX).</p>
</td></tr>
<tr><td><code id="GenGeno_+3A_prop_anno">prop_anno</code></td>
<td>
<p>Proportions of annotations in each category. Length should
equal the number of annotation categories. Default of c(0.5, 0.4, 0.1) is
based on the approximate empirical frequencies of BMVs, DMVs, and PTVs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the (n x snps) genotype matrix &quot;geno&quot; and the
(snps x 1) annotation vector &quot;anno&quot;.
</p>

<hr>
<h2 id='GenGenoMat'>Generate Genotype Matrix</h2><span id='topic+GenGenoMat'></span>

<h3>Description</h3>

<p>Generate genotypes for <code>n</code> subject at <code>snps</code> variants in linkage
equilibrium. Genotypes are generated such that the MAC is always &gt;= 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenGenoMat(n, snps, maf_range = c(0.001, 0.005))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenGenoMat_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="GenGenoMat_+3A_snps">snps</code></td>
<td>
<p>Number of SNP in the gene.</p>
</td></tr>
<tr><td><code id="GenGenoMat_+3A_maf_range">maf_range</code></td>
<td>
<p>Range of minor allele frequencies: c(MIN, MAX).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(n x snps) numeric matrix.
</p>

<hr>
<h2 id='GenomicControl'>Genomic Control</h2><span id='topic+GenomicControl'></span>

<h3>Description</h3>

<p>Genomic Control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenomicControl(lambda, pval, df = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenomicControl_+3A_lambda">lambda</code></td>
<td>
<p>Genomic inflation factor.</p>
</td></tr>
<tr><td><code id="GenomicControl_+3A_pval">pval</code></td>
<td>
<p>Numeric p-value.</p>
</td></tr>
<tr><td><code id="GenomicControl_+3A_df">df</code></td>
<td>
<p>Degrees of freedom. Should not require modification in most cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corrected p-value.
</p>

<hr>
<h2 id='GenPheno'>Generate Phenotypes</h2><span id='topic+GenPheno'></span>

<h3>Description</h3>

<p>Simulate a phenotype based on annotations, covariates, and genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenPheno(
  anno,
  beta,
  covar,
  geno,
  reg_param,
  binary = FALSE,
  include_residual = TRUE,
  indicator = FALSE,
  method = "none",
  prop_causal = 1,
  random_signs = FALSE,
  random_var = 0,
  weights = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenPheno_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_beta">beta</code></td>
<td>
<p>If method = &quot;none&quot;, a (L x 1) coefficient with effect sizes for
each annotation category. By default, there are L = 3 annotation categories
corresponding to BMVs, DMVs, and PTVs. If method != &quot;none&quot;, a scalar
effect size for the allelic series burden score.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_covar">covar</code></td>
<td>
<p>Covariate matrix.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_geno">geno</code></td>
<td>
<p>(n x snps) genotype matrix.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_reg_param">reg_param</code></td>
<td>
<p>Regression parameters.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_binary">binary</code></td>
<td>
<p>Generate binary phenotype? Default: FALSE.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_include_residual">include_residual</code></td>
<td>
<p>Include residual? If FALSE, returns the expected
value. Intended for testing.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_indicator">indicator</code></td>
<td>
<p>Convert raw counts to indicators? Default: FALSE.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_method">method</code></td>
<td>
<p>Genotype aggregation method. Default: &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_prop_causal">prop_causal</code></td>
<td>
<p>Proportion of variants which are causal.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_random_signs">random_signs</code></td>
<td>
<p>Randomize signs? FALSE for burden-type genetic
architecture, TRUE for SKAT-type.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_random_var">random_var</code></td>
<td>
<p>Frailty variance in the case of random signs. Default: 0.</p>
</td></tr>
<tr><td><code id="GenPheno_+3A_weights">weights</code></td>
<td>
<p>Annotation category weights used for aggregation if
method != &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(n x 1) numeric vector.
</p>


<h3>Phenotype generation</h3>


<ul>
<li><p> To generate phenotypes from the baseline model, set <code>method</code> to &quot;none&quot; and
provide a vector <code>beta</code> of length equal to the number of annotation
categories specifying the effect sizes of each.
</p>
</li>
<li><p> To generate phenotypes from the allelic series burden models, set <code>method</code>
to &quot;max&quot; or &quot;sum&quot; and provide a scalar <code>beta.</code>
</p>
</li>
<li><p> To generate phenotypes from the allelic series SKAT model, set <code>method</code> to
&quot;none&quot;, set <code>random_signs</code> to true, and provide a vector <code>beta</code> of length
equal to the number of annotation categories.
</p>
</li></ul>


<hr>
<h2 id='isPD'>Check if Positive Definite</h2><span id='topic+isPD'></span>

<h3>Description</h3>

<p>Check if Positive Definite
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isPD(x, force_symmetry = FALSE, tau = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isPD_+3A_x">x</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
<tr><td><code id="isPD_+3A_force_symmetry">force_symmetry</code></td>
<td>
<p>Force the matrix to be symmetric?</p>
</td></tr>
<tr><td><code id="isPD_+3A_tau">tau</code></td>
<td>
<p>Threshold the minimum eigenvalue must exceed for the matrix
to be considered positive definite.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating whether the matrix is PD.
</p>

<hr>
<h2 id='OLS'>Ordinary Least Squares</h2><span id='topic+OLS'></span>

<h3>Description</h3>

<p>Fits the standard OLS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OLS(y, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OLS_+3A_y">y</code></td>
<td>
<p>(n x 1) Numeric vector.</p>
</td></tr>
<tr><td><code id="OLS_+3A_x">X</code></td>
<td>
<p>(n x p) Numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the following:
</p>

<ul>
<li><p>beta: Regression coefficients.
</p>
</li>
<li><p>v: Residual variance.
</p>
</li>
<li><p>se: Standard errors.
</p>
</li>
<li><p>z: Z-scores.
</p>
</li>
<li><p>pval: P-values based on the chi2 distribution.
</p>
</li></ul>


<hr>
<h2 id='print.COAST'>Print Method for COAST Object.</h2><span id='topic+print.COAST'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>COAST</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'COAST'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.COAST_+3A_x">x</code></td>
<td>
<p>An object of class <code>COAST</code>.</p>
</td></tr>
<tr><td><code id="print.COAST_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>

<hr>
<h2 id='ResidVar'>Calculate Residual Variance</h2><span id='topic+ResidVar'></span>

<h3>Description</h3>

<p>Calculate Residual Variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResidVar(y, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResidVar_+3A_y">y</code></td>
<td>
<p>(n x 1) Numeric phenotype vector.</p>
</td></tr>
<tr><td><code id="ResidVar_+3A_x">X</code></td>
<td>
<p>(n x q) Numeric covariate matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar residual variance.
</p>

<hr>
<h2 id='Score'>Calculate Score Statistic</h2><span id='topic+Score'></span>

<h3>Description</h3>

<p>Calculate Score Statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Score(y, G, X, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Score_+3A_y">y</code></td>
<td>
<p>(n x 1) Numeric phenotype vector.</p>
</td></tr>
<tr><td><code id="Score_+3A_g">G</code></td>
<td>
<p>(n x p) Numeric genotype matrix.</p>
</td></tr>
<tr><td><code id="Score_+3A_x">X</code></td>
<td>
<p>(n x q) Numeric covariate matrix.</p>
</td></tr>
<tr><td><code id="Score_+3A_v">v</code></td>
<td>
<p>Scalar residual variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar score statistic.
</p>

<hr>
<h2 id='show+2CCOAST-method'>Show Method for COAST Object</h2><span id='topic+show+2CCOAST-method'></span>

<h3>Description</h3>

<p>Show Method for COAST Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'COAST'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2CCOAST-method_+3A_object">object</code></td>
<td>
<p>An object of class <code>COAST</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='SumCountSS'>Allelic Sum Test from Sumstats</h2><span id='topic+SumCountSS'></span>

<h3>Description</h3>

<p>Allelic Sum Test from Sumstats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SumCountSS(anno, beta, ld, se, weights, return_beta = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SumCountSS_+3A_anno">anno</code></td>
<td>
<p>(snps x 1) annotation vector with integer values in 1 through
the number of annotation categories L.</p>
</td></tr>
<tr><td><code id="SumCountSS_+3A_beta">beta</code></td>
<td>
<p>(snps x 1) vector of effect sizes for
the coding genetic variants within a gene.</p>
</td></tr>
<tr><td><code id="SumCountSS_+3A_ld">ld</code></td>
<td>
<p>(snps x snps) matrix of correlations among the genetic variants.</p>
</td></tr>
<tr><td><code id="SumCountSS_+3A_se">se</code></td>
<td>
<p>(snps x 1) vector of standard errors for the effect sizes.</p>
</td></tr>
<tr><td><code id="SumCountSS_+3A_weights">weights</code></td>
<td>
<p>(L x 1) vector of annotation category weights. Note that the
number of annotation categories L is inferred from the length of <code>weights</code>.</p>
</td></tr>
<tr><td><code id="SumCountSS_+3A_return_beta">return_beta</code></td>
<td>
<p>Return estimated effect sizes and standard errors?
Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_beta</code>, a list containing the category effect sizes,
standard errors, and the p-value. Otherwise, the numeric p-value only.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
