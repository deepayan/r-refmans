<!DOCTYPE html><html lang="en"><head><title>Help for package smacof</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smacof}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biplotmds'><p>MDS Biplots</p></a></li>
<li><a href='#bootmds'><p>SMACOF Bootstrap</p></a></li>
<li><a href='#bread'><p>Breakfast preferences</p></a></li>
<li><a href='#breakfast'><p>Breakfast preferences</p></a></li>
<li><a href='#CanadaNews'><p>Canadian Newspapers</p></a></li>
<li><a href='#confEllipse'><p>Pseudo Confidence Ellipses</p></a></li>
<li><a href='#crimes'><p>Crime Correlations</p></a></li>
<li><a href='#csrranking'><p>CSR activities</p></a></li>
<li><a href='#dissWeights'><p>Create Weights for Uniform Weighted Distribution</p></a></li>
<li><a href='#driftVectors'><p>Asymmetric MDS: Drift Vectors</p></a></li>
<li><a href='#Duration'><p>Facets of the subjective duration of imagined situations</p></a></li>
<li><a href='#ekman'><p>Ekman data set</p></a></li>
<li><a href='#EW_ger'><p>Work values</p></a></li>
<li><a href='#FaceExp'><p>Facial Expression Data</p></a></li>
<li><a href='#fitCircle'><p>Fitting circle into point configuration</p></a></li>
<li><a href='#GOPdtm'><p>Republican Statements</p></a></li>
<li><a href='#gravity'><p>Gravity dissimilarities</p></a></li>
<li><a href='#Guerry'><p>Map Dataset France 1830</p></a></li>
<li><a href='#Guttman1991'><p>Guttman's Intelligence Facets</p></a></li>
<li><a href='#helm'><p>Helm's color data</p></a></li>
<li><a href='#icExplore'><p>Exploring Initial Configurations</p></a></li>
<li><a href='#indvalues'><p>Schwartz Value Survey</p></a></li>
<li><a href='#intelligence'><p>Intelligence Tests</p></a></li>
<li><a href='#jackmds'><p>SMACOF Jackknife</p></a></li>
<li><a href='#kinshipdelta'><p>Kinship Terms</p></a></li>
<li><a href='#KIPT'><p>Kennedy Institute Phonics Test</p></a></li>
<li><a href='#LawLer'><p>Management Performance Data</p></a></li>
<li><a href='#morse'><p>Morse Code Confusion Data</p></a></li>
<li><a href='#morsescales'><p>Morse Code Confusion Scales</p></a></li>
<li><a href='#OCP'><p>Organizational Culture Profile</p></a></li>
<li><a href='#partypref'><p>Party preferences</p></a></li>
<li><a href='#perception'><p>Rectangle Perception Data</p></a></li>
<li><a href='#permtest'><p>SMACOF Permutation</p></a></li>
<li><a href='#Plato7'><p>Plato's Seven Works</p></a></li>
<li><a href='#plot.smacof'><p>2D SMACOF plots</p></a></li>
<li><a href='#Procrustes'><p>Procrustean Similarity Transformations</p></a></li>
<li><a href='#PVQ40'><p>Portrait Value Questionnaire</p></a></li>
<li><a href='#randomstress'><p>Stress Calculation for Random Dissimilarities</p></a></li>
<li><a href='#rectangles'><p>Rectangles</p></a></li>
<li><a href='#residuals.smacof'><p>Residuals</p></a></li>
<li><a href='#RockHard'><p>RockHard Ratings</p></a></li>
<li><a href='#sim2diss'><p>Converts similarites to dissimilarities</p></a></li>
<li><a href='#smacofConstraint'><p>SMACOF Constraint</p></a></li>
<li><a href='#smacofIndDiff'><p>SMACOF for Individual Differences</p></a></li>
<li><a href='#smacofSphere'><p>Spherical SMACOF</p></a></li>
<li><a href='#smacofSym'><p>Symmetric smacof</p></a></li>
<li><a href='#stardist'><p>Distances among stars in zodiac signs</p></a></li>
<li><a href='#stress0'><p>Zero-Iterations Stress</p></a></li>
<li><a href='#summary.smacofB'><p>S3 methods for smacof</p></a></li>
<li><a href='#svm_mdsplot'><p>Support Vector Machine MDS</p></a></li>
<li><a href='#symdecomp'><p>Proximity Matrix Decomposition</p></a></li>
<li><a href='#torgerson'><p>Torgerson Scaling</p></a></li>
<li><a href='#trading'><p>Trading data</p></a></li>
<li><a href='#transform'><p>Internal Dissimilarity Transformation</p></a></li>
<li><a href='#unfolding'><p>Nonmetric unfolding</p></a></li>
<li><a href='#uniscale'><p>Unidimensional Scaling</p></a></li>
<li><a href='#VaziriXu'><p>Visual Object Representations</p></a></li>
<li><a href='#vmu'><p>Vector Model of Unfolding</p></a></li>
<li><a href='#winedat'><p>Wine tasting</p></a></li>
<li><a href='#wish'><p>Wish dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multidimensional Scaling</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the following approaches for multidimensional scaling (MDS) based on stress minimization using majorization (smacof): ratio/interval/ordinal/spline MDS on symmetric dissimilarity matrices, MDS with external constraints on the configuration, individual differences scaling (idioscal, indscal), MDS with spherical restrictions, and ratio/interval/ordinal/spline unfolding (circular restrictions, row-conditional). Various tools and extensions like jackknife MDS, bootstrap MDS, permutation tests, MDS biplots, gravity models, unidimensional scaling, drift vectors (asymmetric MDS), classical scaling, and Procrustes are implemented as well.  </td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, polynom, Hmisc, nnls, grDevices, MASS,
weights, ellipse, wordcloud, parallel, foreach, doParallel</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), plotrix, colorspace, e1071</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, prefmod, MPsychoR, calibrate, ggplot2, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-09 22:38:13 UTC; patrick</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Mair [aut, cre],
  Jan De Leeuw [aut],
  Patrick J. F. Groenen [aut],
  Ingwer Borg [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Mair &lt;mair@fas.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-10 09:27:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='biplotmds'>MDS Biplots</h2><span id='topic+biplotmds'></span><span id='topic+biplotmds.smacof'></span><span id='topic+biplotmds.smacofID'></span><span id='topic+plot.mdsbi'></span>

<h3>Description</h3>

<p>Regresses external variables on a MDS configuration which results in a MDS biplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacof'
biplotmds(object, extvar, scale = TRUE)
## S3 method for class 'mdsbi'
plot(x, vecscale = NULL, plot.dim = c(1,2), sphere = TRUE, col = 1, 
                     label.conf = list(label = TRUE, pos = 3, col = 1, cex = 0.8), 
                     vec.conf = list(col = 1, cex = 0.8, length = 0.1), 
                     identify = FALSE, type = "p", pch = 20, 
                     asp = 1, main, xlab, ylab, xlim, ylim, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biplotmds_+3A_object">object</code></td>
<td>
<p>Object of class <code>"smacof"</code> or <code>"smacofID"</code>.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_extvar">extvar</code></td>
<td>
<p>Data frame with external variables.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_scale">scale</code></td>
<td>
<p>If <code>TRUE</code>, external variables are standardized internally.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_x">x</code></td>
<td>
<p>Object of class <code>"mdsbi"</code>.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_vecscale">vecscale</code></td>
<td>
<p>Scaling factor for regression coefficients, either a single number or <code>NULL</code> (see details).</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_plot.dim">plot.dim</code></td>
<td>
<p>Vector with dimensions to be plotted.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_xlim">xlim</code></td>
<td>
<p>Scale x-axis.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_ylim">ylim</code></td>
<td>
<p>Scale y-axis.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_pch">pch</code></td>
<td>
<p>Plot symbol.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_col">col</code></td>
<td>
<p>Point color.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_type">type</code></td>
<td>
<p>What type of plot should be drawn.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_sphere">sphere</code></td>
<td>
<p>In case of spherical smacof, whether sphere should be plotted or not.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_label.conf">label.conf</code></td>
<td>
<p>List with arguments for plotting the labels of the configurations in a configuration plot (logical value whether to plot labels or not, label position, label color).</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_vec.conf">vec.conf</code></td>
<td>
<p>List with arguments for arrows and arrow labels of the external variables.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_identify">identify</code></td>
<td>
<p>If <code>TRUE</code>, the <code>identify()</code> function is called internally that allows to add configuration labels by mouse click.</p>
</td></tr>
<tr><td><code id="biplotmds_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see <code><a href="graphics.html#topic+plot.default">plot</a></code> for detailed information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a model for individual differences is provided, the external variables are regressed on the group stimulus space configurations. In the biplot only the relative length of the vectors and their direction matters. Using the scale argument the user can control for the relative length of the vectors. If <code>vecscale = NULL</code>, the <code>vecscale()</code> function from the <span class="pkg">candisc</span> package is used which tries to automatically calculate the scale factor so that the vectors approximately fill the same space as the configuration. 
</p>


<h3>Value</h3>

   
<p>Returns an object belonging to classes <code>"mlm"</code> and <code>"mdsbi"</code>. See <code><a href="stats.html#topic+lm">lm</a></code> for details.
</p>
<table role = "presentation">
<tr><td><code>R2vec</code></td>
<td>
<p>Vector containing the R2 values.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Greenacre, M. (2010). Biplots in Practice. Fundacion BBVA, Bilbao, Spain.
</p>
<p>Mair, P., Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2, Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.smacof">plot.smacof</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## morse code data with external scales
res &lt;- mds(morse)
fitbi &lt;- biplotmds(res, morsescales[,2:3])
plot(fitbi, main = "MDS Biplot", vecscale = 0.5)

## wish data with external economic development factor
diss &lt;- sim2diss(wish, method = 7)
res &lt;- mds(diss, type = "ordinal")
ecdev &lt;- data.frame(ecdev = c(3,1,3,3,8,3,7,9,4,7,10,6))
fitbi &lt;- biplotmds(res, ecdev)
plot(fitbi, main = "MDS Biplot", vecscale = 1)
plot(fitbi, main = "MDS Biplot", vecscale = 0.5, xlim = c(-1, 1), 
vec.conf = list(col = "red", length = 0.05))

## Ekman's color data (by Michael Friendly)
require(colorspace)
wavelengths &lt;- attr(ekman, "Labels")
colors &lt;- c("#2600F0", "#0028FF", "#0092FF", "#00B2FF", "#00FFFF", "#00FF61", "#77FF00", "#B3FF00",
            "#FFF200", "#FFBE00", "#FF9B00", "#FF5700", "#F60000", "#D60000")
ekmanD &lt;- sim2diss(ekman)
res &lt;- mds(ekmanD, type = "ordinal")
RGB &lt;- t(col2rgb(colors)) / 255
HCL &lt;- as(hex2RGB(colors), "polarLUV")
HCL &lt;- slot(HCL, "coords")
fit &lt;- biplotmds(res, cbind(RGB, HCL))
fit
plot(fit, vecscale = 0.5, cex = 6, col = colors,
    label.conf=list(cex = 1, pos = ifelse(wavelengths &lt; 560, 2, 4)),
    vec.conf = list(cex = 1.2), main = "Ekman configuration and color properties" )

</code></pre>

<hr>
<h2 id='bootmds'>SMACOF Bootstrap</h2><span id='topic+bootmds'></span><span id='topic+bootmds.smacofB'></span><span id='topic+plot.smacofboot'></span>

<h3>Description</h3>

<p>Performs a bootstrap on a SMACOF solution. It works for derived dissimilarities only. The original data matrix needs to 
be provided, as well as the type of dissimilarity measure used to compute the input dissimilarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofB'
bootmds(object, data,  method.dat = "pearson", nrep = 100, 
alpha = 0.05, verbose = FALSE, ...)

## S3 method for class 'smacofboot'
plot(x, plot.dim = c(1,2), col = 1, 
label.conf = list(label = TRUE, pos = 3, cex = 0.8), 
ell = list(lty = 1, lwd = 1, col = "gray"), main, xlab, ylab, xlim, ylim, 
asp = 1, type = "p", pch = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootmds_+3A_object">object</code></td>
<td>
<p>Object of class <code>"smacofB"</code>, i.e., an MDS solution from <code>mds()</code>.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_data">data</code></td>
<td>
<p>Initial data (before dissimilarity computation).</p>
</td></tr>
<tr><td><code id="bootmds_+3A_method.dat">method.dat</code></td>
<td>
<p>Dissimilarity computation used as MDS input. This must be one of <code>"pearson"</code>, <code>"spearman"</code>, <code>"kendall"</code>, <code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>, <code>"canberra"</code>, <code>"binary"</code>. For unfolding models it is either <code>"full"</code> for full permutations or <code>"rows"</code> for permutations within rows.</p>
</td></tr> 
<tr><td><code id="bootmds_+3A_nrep">nrep</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level for confidence ellipsoids.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, bootstrap index is printed out.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_...">...</code></td>
<td>
<p>Additional arguments needed for dissimilarity computation as specified in <code>sim2diss()</code>.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_x">x</code></td>
<td>
<p>Object of class <code>"smacofboot"</code></p>
</td></tr>
<tr><td><code id="bootmds_+3A_plot.dim">plot.dim</code></td>
<td>
<p>Vector with dimensions to be plotted.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_col">col</code></td>
<td>
<p>Color for points.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_label.conf">label.conf</code></td>
<td>
<p>List with arguments for plotting the labels of the configurations in a configuration plot (logical value whether to plot labels or not, label position). If <code>pos = 5</code> labels are placed away from the nearest point.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_ell">ell</code></td>
<td>
<p>List with arguments for plotting ellipses: line type, line width, color.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_xlim">xlim</code></td>
<td>
<p>Scale x-axis.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_ylim">ylim</code></td>
<td>
<p>Scale y-axis.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_pch">pch</code></td>
<td>
<p>Plotting symbol for object point.</p>
</td></tr>
<tr><td><code id="bootmds_+3A_type">type</code></td>
<td>
<p>Type of plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to examine the stability solution of an MDS, a bootstrap on the raw data can be performed. This results in confidence ellipses in the configuration plot. The ellipses are returned as list which allows users to produce (and further customize) the plot by hand. 
</p>


<h3>Value</h3>

   
<table role = "presentation">
<tr><td><code>cov</code></td>
<td>
<p>Covariances for ellipse computation</p>
</td></tr>
<tr><td><code>bootconf</code></td>
<td>
<p>Configurations bootstrap samples</p>
</td></tr>
<tr><td><code>stressvec</code></td>
<td>
<p>Bootstrap stress values</p>
</td></tr>
<tr><td><code>bootci</code></td>
<td>
<p>Stress bootstrap percentile confidence interval</p>
</td></tr>
<tr><td><code>stab</code></td>
<td>
<p>Stability coefficient</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jacoby, W. G., &amp; Armstrong, D. A. (2014). Bootstrap confidence regions for multidimensional scaling solutions. American Journal of Political Science, 58, 264-278. 
</p>
<p>Mair, P., Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2, Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jackmds">jackmds</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example using Euclidean distances
data &lt;- na.omit(PVQ40[,1:5])
diss &lt;- dist(t(data))   ## Euclidean distances 
fit &lt;- mds(diss)        ## 2D interval MDS

set.seed(123)
resboot &lt;- bootmds(fit, data, method.dat = "euclidean", nrep = 50)
resboot
plot(resboot)

## Example using Pearson correlations 
sim &lt;- cor(data)
diss &lt;- sim2diss(sim, method = 1)  ## subtract from 1 (method needs to be passed to bootmds)
fit &lt;- mds(diss, type = "ratio", ndim = 3)        ## 3D ratio MDS

set.seed(123)
resboot &lt;- bootmds(fit, data, method.dat = "pearson", nrep = 50, alpha = 0.1, method = 1)
resboot
## plot 1st against 3rd dimension
ellipses &lt;- plot(resboot, plot.dim = c(1,3), ell = list(lty = 2, col = "gray", lwd = 0.8))
str(ellipses)  ## list of ellipse coordinates for each object
</code></pre>

<hr>
<h2 id='bread'>Breakfast preferences</h2><span id='topic+bread'></span>

<h3>Description</h3>

<p>The data set is described in Bro (1998). The raw data consist of ratings of 10 
breads on 11 different attributes carried out by 8 raters. 
Note that the bread samples are pairwise replications: Each of the 5 different breads, 
which have a different salt content, was presented twice for rating. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bread)</code></pre>


<h3>Format</h3>

<p>A list of length 8 with elements of class <code>"dist"</code>. The attributes are 
bread odor, yeast odor, off-flavor, color, moisture, dough, salt taste, sweet taste, yeast taste, 
other taste, and total taste. 
</p>


<h3>References</h3>

<p>Bro, R. (1998). Multi-way Analysis in the Food Industry: Models, Algorithms, and Applications. Ph.D. thesis, University of Amsterdam (NL) &amp; Royal Veterinary and Agricultural University (DK).</p>


<h3>Examples</h3>

<pre><code class='language-R'>bread
</code></pre>

<hr>
<h2 id='breakfast'>Breakfast preferences</h2><span id='topic+breakfast'></span>

<h3>Description</h3>

<p>42 individuals were asked to order 15 breakfast items due to their preference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breakfast)</code></pre>


<h3>Format</h3>

<p>Data frame with students in the rows and breakfast items in the columns. 
</p>
<p>toast: toast pop-up
</p>
<p>butoast: buttered toast
</p>
<p>engmuff: English muffin and margarine
</p>
<p>jdonut: jelly donut
</p>
<p>cintoast: cinnamon toast
</p>
<p>bluemuff: blueberry muffin and margarine
</p>
<p>hrolls: hard rolls and butter
</p>
<p>toastmarm: toast and marmalade
</p>
<p>butoastj: buttered toast and jelly
</p>
<p>toastmarg: toast and margarine
</p>
<p>cinbun: cinnamon bun
</p>
<p>danpastry: Danish pastry
</p>
<p>gdonut: glazed donut
</p>
<p>cofcake: coffee cake
</p>
<p>cornmuff: corn muffin and butter
</p>


<h3>References</h3>

<p>Green, P. E. &amp; Rao, V. (1972). Applied multidimensional scaling. Hinsdale, IL: Dryden.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>breakfast
</code></pre>

<hr>
<h2 id='CanadaNews'>Canadian Newspapers</h2><span id='topic+CanadaNews'></span>

<h3>Description</h3>

<p>We took Canadian newspapers that appeared in the time period between June and September 2009 and searched for articles that contained the word &quot;aboriginal&quot;. A total of 92 articles was found. In these articles, we determined the frequencies of other meaningful words (e.g., tribal, moose, arctic, and health). The data are organized as word co-occurrence matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CanadaNews)</code></pre>


<h3>Format</h3>

<p>Matrix with word co-occurrence counts.
</p>


<h3>References</h3>

<p>Borg, I., Groenen, P. J. F., &amp; Mair, P. (2017). Applied Multidimensional Scaling and Unfolding. New York: Springer. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(CanadaNews)
</code></pre>

<hr>
<h2 id='confEllipse'>Pseudo Confidence Ellipses</h2><span id='topic+confEllipse'></span><span id='topic+confEllipse.smacofB'></span><span id='topic+confEllipse.smacofID'></span><span id='topic+plot.confell'></span>

<h3>Description</h3>

<p>Computes pseudo-confidence ellipses for symmetric and individual difference MDS fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofID'
confEllipse(object)

## S3 method for class 'confell'
plot(x, eps = 0.05, plot.dim = c(1,2), col = 1, 
label.conf = list(label = TRUE, pos = 3, cex = 0.8), 
ell = list(lty = 1, lwd = 1, col = 1), main, xlab, ylab, xlim, ylim, 
asp = 1, type = "p", pch = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confEllipse_+3A_object">object</code></td>
<td>
<p>Object of class <code>"smacofB"</code> or <code>"smacofID"</code>.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_x">x</code></td>
<td>
<p>Object of class <code>"confell"</code></p>
</td></tr>
<tr><td><code id="confEllipse_+3A_eps">eps</code></td>
<td>
<p>Perturbation region (e.g. 0.05 means that we look at a perturbation region where stress is at most 5% larger than the minimum we have found).</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_plot.dim">plot.dim</code></td>
<td>
<p>Vector with dimensions to be plotted.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_col">col</code></td>
<td>
<p>Color for points.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_label.conf">label.conf</code></td>
<td>
<p>List with arguments for plotting the labels of the configurations in a configuration plot (logical value whether to plot labels or not, label position). If <code>pos = 5</code> labels are placed away from the nearest point.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_ell">ell</code></td>
<td>
<p>List with arguments for plotting ellipses: line type, line width, color.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_xlim">xlim</code></td>
<td>
<p>Scale x-axis.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_ylim">ylim</code></td>
<td>
<p>Scale y-axis.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_pch">pch</code></td>
<td>
<p>Plotting symbol for object point.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_type">type</code></td>
<td>
<p>Type of plot.</p>
</td></tr>
<tr><td><code id="confEllipse_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>confEllipse</code> function normalizes the dissimilarities and performs a few more iterations to optimize the configuration and the individual diffierence weights. This result is then passed to a function that computes the stress derivatives which are the basis of the ellipses in the plot function. This function works for ratio scaled versions only. 
</p>


<h3>Value</h3>

   
<p>Returns an object belonging to classes <code>"confell"</code>.
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>Configuration (group stimulus space for individual difference models)</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Stress derivatives</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Optimized stress (raw value)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mair, P., Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2, Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.smacofboot">plot.smacofboot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple ratio MDS fit 
delta &lt;- sim2diss(cor(PVQ40agg))
res &lt;- mds(delta, ndim = 3)
cres &lt;- confEllipse(res)
plot(cres, plot.dim = c(1,2))
plot(cres, plot.dim = c(1,3))
plot(cres, plot.dim = c(2,3))


## INDSCAL on Helm data
fit1 &lt;- indscal(helm)
cfit1 &lt;- confEllipse(fit1)
plot(cfit1, ell = list(col = "gray", lty = 2), ylim = c(-0.04, 0.04))

## IDIOSCAL on Helm data
fit2 &lt;- idioscal(helm)
cfit2 &lt;- confEllipse(fit2)
plot(cfit1, ell = list(col = "gray", lty = 2), ylim = c(-0.04, 0.04))

</code></pre>

<hr>
<h2 id='crimes'>Crime Correlations</h2><span id='topic+crimes'></span>

<h3>Description</h3>

<p>Correlations of crime rates in 50 US states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(crimes)</code></pre>


<h3>Format</h3>

<p>Crime correlation matrix.
</p>


<h3>References</h3>

<p>Borg, I., Groenen, P. J. F., &amp; Mair, P. (2017). Applied Multidimensional Scaling and Unfolding. New York: Springer. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crimes
</code></pre>

<hr>
<h2 id='csrranking'>CSR activities</h2><span id='topic+csrranking'></span>

<h3>Description</h3>

<p>This dataset collects rankings of 100 individual on 5 topics that reflect social responsibilties on corporations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(csrranking)</code></pre>


<h3>Format</h3>

<p>A data frame where each individual ranked prevention of environmental pollution (Environment), waste prevention (Waste Prevention),  selling organic products (Organic Products), participating on charity programs (Charity), and fair treatment of employees (Employee) according to its own preferences. A value of 1 corresponds to highest importance, 5 to lowest importance. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>csrranking

</code></pre>

<hr>
<h2 id='dissWeights'>Create Weights for Uniform Weighted Distribution</h2><span id='topic+dissWeights'></span>

<h3>Description</h3>

<p>Compute weights as a function of the dissimilarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissWeights(delta, type = c("unif", "knn", "power", "unifpower"), 
           k = NULL, power = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dissWeights_+3A_delta">delta</code></td>
<td>
<p>Either a symmetric dissimilarity matrix or an object of class <code>"dist"</code></p>
</td></tr>
<tr><td><code id="dissWeights_+3A_type">type</code></td>
<td>
<p>One of <code>"unif"</code> (default), <code>"knn"</code>, <code>"power"</code>, <code>"unifpower"</code>. See details for a description of the various options.</p>
</td></tr>
<tr><td><code id="dissWeights_+3A_k">k</code></td>
<td>
<p>The number of smallest dissimilarities per row for which the weights need to be set to 1. The default <code>k = NULL</code> makes <code>k</code> to be set to use the 25% smallest dissimilarities per row.</p>
</td></tr>
<tr><td><code id="dissWeights_+3A_power">power</code></td>
<td>
<p>power to which the dissimilarities need to be raised as weights. Default is 0, so that all weights are 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weights are computed as a function of the dissimilarities depending on <code>type</code>.
</p>
<p>- <code>"unif"</code> Compute weights such that the weighted empirical distribution (histogram) of the dissimilarities is uniform. Particularly if the number of objects is large, the dissimilarities that occuur most often will start to dominate the solution. This option de-emphasizes often occuring dissimilarities such that the weighted empirical distribution (the weighted histogram) becomes approximately uniform.
</p>
<p>- <code>"knn"</code> Per row of the dissimilarity matrix the <code>k</code> smallest dissimilarities obtain a weight of 1 and the others a 0.
</p>
<p>- <code>"power"</code> The weights are set to the <code>delta^power</code>. If <code>power</code> is small (e.g., <code>power = -5</code>) then the smaller dissimilarities will be better fitted. If <code>power</code> is large (e.g., <code>power = 5</code>) then the larger dissimilarities will be better fitted.  
</p>
<p>- <code>"unifpower"</code> First weights are determined by the <code>"unif"</code> option and then multiplied by the weights obtained by the <code>"power"</code> option. If the dissimilarity matrix is large, then this option is needed to see an effect of the <code>"power"</code> option on the MDS solution.  
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>weightmat</code></td>
<td>
<p>the weight matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick Groenen</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## mds solution for kinship data with uniform weights
res &lt;- mds(kinshipdelta, weightmat = dissWeights(kinshipdelta, type = "unif"))
par(mfrow = c(2,2))
plot(res, main = "uniform weights")
plot(res, plot.type = "Shepard")
plot(res, plot.type = "histogram")

## mds solution for kinship data with knn weights
res &lt;- mds(kinshipdelta, weightmat = dissWeights(kinshipdelta, type = "knn", k = 5))
par(mfrow = c(1,2))
plot(res, main = "knn weights with k=5")
plot(res, plot.type = "Shepard")

## mds solution for kinship data with power weights emphasizing large dissimilarities
res &lt;- mds(kinshipdelta, weightmat = dissWeights(kinshipdelta, type = "power", power = 5))
par(mfrow = c(2,2))
plot(res, main = "Power = 5 weights")
plot(res, plot.type = "Shepard")
plot(res, plot.type = "histogram")

## mds solution for kinship data with power weights emphasizing small dissimilarities
res &lt;- mds(kinshipdelta, weightmat = dissWeights(kinshipdelta, type = "power", power = -5))
par(mfrow = c(2,2))
plot(res, main = "Power = -5 weights")
plot(res, plot.type = "Shepard")
plot(res, plot.type = "histogram")

## mds solution for kinship data with power weights emphasizing large dissimilarities 
## while correcting for nonuniform dissimilarities
res &lt;- mds(kinshipdelta, weightmat = dissWeights(kinshipdelta, type = "unifpower", power = 5))
par(mfrow = c(2,2))
plot(res, main = "Uniform power = 5 weights")
plot(res, plot.type = "Shepard")
plot(res, plot.type = "histogram")

## mds solution for kinship data with power weights emphasizing small dissimilarities
## while correcting for nonuniform dissimilarities
res &lt;- mds(kinshipdelta, weightmat = dissWeights(kinshipdelta, type = "unifpower", power = -5))
par(mfrow = c(2,2))
plot(res, main = "Uniform power = -5 weights")
plot(res, plot.type = "Shepard")
plot(res, plot.type = "histogram")
</code></pre>

<hr>
<h2 id='driftVectors'>Asymmetric MDS: Drift Vectors</h2><span id='topic+driftVectors'></span><span id='topic+plot.driftvec'></span>

<h3>Description</h3>

<p>Takes an asymmetric dissimilarity matrix and decomposes it into a symmetric and a skew-symmetric part. 
Fits an MDS on the symmetric part and computes drift vectors for the skew-symmetric portion. This model makes 
it possible to see how these two components are related to each other. It is limited to two dimensions only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driftVectors(data, type = c("ratio", "interval", "ordinal","mspline"), 
             weightmat = NULL, init = "torgerson", ties = "primary",  verbose = FALSE, 
             relax = FALSE, modulus = 1, itmax = 1000, eps = 1e-6, 
             spline.degree = 2, spline.intKnots = 2)
             
## S3 method for class 'driftvec'
plot(x, adjust = 1, main, xlim, ylim, 
                        xlab = "Dimension 1", ylab = "Dimension 2", pch = 20, asp = 1, 
                        col.conf = "black", col.drift = "lightgray", 
                        label.conf = list(label = TRUE, pos = 3, col = "black", 
                        cex = 0.8), ...) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="driftVectors_+3A_data">data</code></td>
<td>
<p>Asymmetric dissimilarity matrix</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_weightmat">weightmat</code></td>
<td>
<p>Optional matrix with dissimilarity weights</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_init">init</code></td>
<td>
<p>Either <code>"torgerson"</code> (classical scaling starting solution), <code>"random"</code> (random configuration), or a user-defined matrix</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_type">type</code></td>
<td>
<p>MDS type: <code>"interval"</code>, <code>"ratio"</code>, <code>"ordinal"</code> (nonmetric MDS), or <code>"mspline"</code></p>
</td></tr>
<tr><td><code id="driftVectors_+3A_ties">ties</code></td>
<td>
<p>Tie specification for ordinal MDS only: <code>"primary"</code>, <code>"secondary"</code>, or <code>"tertiary"</code></p>
</td></tr>
<tr><td><code id="driftVectors_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate stress is printed out</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_relax">relax</code></td>
<td>
<p>If <code>TRUE</code>, block relaxation is used for majorization</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_modulus">modulus</code></td>
<td>
<p>Number of smacof iterations per monotone regression call</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_spline.degree">spline.degree</code></td>
<td>
<p>Degree of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_spline.intknots">spline.intKnots</code></td>
<td>
<p>Number of interior knots of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_x">x</code></td>
<td>
<p>Object of class <code>"driftvec"</code></p>
</td></tr>
<tr><td><code id="driftVectors_+3A_adjust">adjust</code></td>
<td>
<p>Scaling factor for drift vectors (value larger than 1 increases the length)</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_xlim">xlim</code></td>
<td>
<p>Scale x-axis</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_ylim">ylim</code></td>
<td>
<p>Scale y-axis</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_pch">pch</code></td>
<td>
<p>Plot symbol</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_col.conf">col.conf</code></td>
<td>
<p>Point color (MDS configurations)</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_col.drift">col.drift</code></td>
<td>
<p>Color for drift vectors (arrows)</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_label.conf">label.conf</code></td>
<td>
<p>Settings for plotting labels</p>
</td></tr>
<tr><td><code id="driftVectors_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The skew-symmetric values are embedded into the MDS representation of the symmetrized data by drawing errors (drift vectors)
from each point <code class="reqn">i</code> to each point <code class="reqn">j</code> in the configuration so that these vectors correspond in length and 
direction to the values of row <code class="reqn">i</code> of the skew-symmetric matrix.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fitsym</code></td>
<td>
<p>MDS output for symmetric portion</p>
</td></tr>
<tr><td><code>sym</code></td>
<td>
<p>Symmetric matrix</p>
</td></tr>
<tr><td><code>skewsym</code></td>
<td>
<p>Skew-symmetric matrix</p>
</td></tr>
<tr><td><code>driftcoor</code></td>
<td>
<p>Drift vector coordinates</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>Stress-1 value</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>nobj</code></td>
<td>
<p>Number of objects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick Mair</p>


<h3>References</h3>

<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.). Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smacofSym">smacofSym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple example
P &lt;- matrix(c(0,  4,  6, 13, 
              5,  0, 37, 21, 
              4, 38,  0, 16, 
              8, 31, 18,  0), nrow = 4, ncol = 4, byrow = TRUE) 
D &lt;- sim2diss(P, method = 40) 
res &lt;- driftVectors(D, type = "interval")
plot(res)
plot(res, adjust = 0.1)    ## shorten drift vectors 

## Morse code data
fit.drift &lt;- driftVectors(morse2, type = "ordinal")
fit.drift
plot(fit.drift)
</code></pre>

<hr>
<h2 id='Duration'>Facets of the subjective duration of imagined situations</h2><span id='topic+Duration'></span><span id='topic+DurationRaw'></span>

<h3>Description</h3>

<p>The <code>DurationRaw</code> dataset contains the duration rating of 76 subjects on 24 situations. 
Subjects were asked to rate the duration on a 7 point scale (1 ... substantially shorter, 
7 ... substantially longer). The <code>Duration</code> data file contains the corresponding 
correlations between the 24 situations including some information about the facets. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Duration)
data(DurationRaw)
</code></pre>


<h3>Format</h3>

<p>Data frame 24 correlations based on duration ratings:
</p>
<p>S1-S24: situation
</p>
<p>F1: pleasant (1), neutral (2), unpleasant (3)
</p>
<p>F2: variable (1), monotonous (2)
</p>
<p>F3: difficult (1), easy (2)
</p>
<p>F3: many (1), few (2)
</p>
<p>structuple: the facet structure written as a tuple
</p>


<h3>References</h3>

<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.). Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ddiss &lt;- sim2diss(Duration[,paste0("S", 1:24)])
fit &lt;- mds(ddiss, type = "ordinal", ndim = 4)
plot(fit)

</code></pre>

<hr>
<h2 id='ekman'>Ekman data set</h2><span id='topic+ekman'></span>

<h3>Description</h3>

<p>Ekman dissimilarities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ekman)</code></pre>


<h3>Format</h3>

<p>Object of class <code>dist</code>
</p>


<h3>Details</h3>

<p>Ekman presents similarities for 14 colors which are based on a rating by 31 subjects where each pair of colors 
was rated on a 5-point scale (0 = no similarity up to 4 = identical). 
After averaging, the similarities were divided by 4 such that they are within the 
unit interval. Similarities of colors with wavelengths from 434 to 674 nm.</p>


<h3>References</h3>

<p>Ekman, G. (1954). Dimensions of color vision. Journal of Psychology, 38, 467-474.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ekman
</code></pre>

<hr>
<h2 id='EW_ger'>Work values</h2><span id='topic+EW_ger'></span><span id='topic+EW_eng'></span>

<h3>Description</h3>

<p>Intercorrelations of 13 working values for former West (first list element) and East Germany.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EW_eng)</code></pre>


<h3>Format</h3>

<p>Object of class <code>dist</code>
</p>


<h3>Details</h3>

<p>Note that in <code>EW_ger</code> the labels are given in German. For smacof, the data must be converted into a dissimilarity matrix by applying the <code>sim2diss()</code> function to each list element.
</p>


<h3>References</h3>

<p>ALLBUS 1991, German General Social Survey. 
</p>
<p>Borg, I., Groenen, P. J. F., &amp; Mair, P. (2010). Multidimensionale Skalierung. Muenchen: Hampp Verlag.
</p>
<p>Borg, I., Groenen, P. J. F., &amp; Mair, P. (2012). Multidimensional Scaling. New York: Springer, forthcoming.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EW_eng)
data(EW_ger)
</code></pre>

<hr>
<h2 id='FaceExp'>Facial Expression Data</h2><span id='topic+FaceExp'></span><span id='topic+FaceScale'></span>

<h3>Description</h3>

<p>Dissimilarity matrix of 13 facial expressions (Abelson &amp; Sermat, 1962). The external scales are taken from Engen et al. (1958) reflecting the following three perceptual dimensions: pleasant-unpleasant (PU), attention-rejection (AR), and tension-sleep (TS). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FaceExp)
data(FaceScale)
</code></pre>


<h3>Format</h3>

<p>Symmetric dissimilarity matrix and data frame with 3 perceptual dimensions</p>


<h3>References</h3>

<p>Abelson, R. P., &amp; Sermat, V. (1962). Multidimensional scaling of facial expressions. Journal of Experimental Psychology, 63, 546-554. 
</p>
<p>Engen, B., Levy, N., &amp; Schlossberg, H. (1958). The dimensional analysis of a new series of facial expressions. Journal of Experimental Psychology, 55, 454-458. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(FaceExp)
str(FaceScale)
</code></pre>

<hr>
<h2 id='fitCircle'>Fitting circle into point configuration</h2><span id='topic+fitCircle'></span>

<h3>Description</h3>

<p>Utility function for fitting a circle into 2D point configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitCircle(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitCircle_+3A_x">x</code></td>
<td>
<p>Vector with x-coordinates</p>
</td></tr>
<tr><td><code id="fitCircle_+3A_y">y</code></td>
<td>
<p>Vector with y-coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cx</code></td>
<td>
<p>x-coordinate center</p>
</td></tr>
<tr><td><code>cy</code></td>
<td>
<p>y-coordinate center</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>circle radius</p>
</td></tr>
</table>


<h3>References</h3>

<p>Pratt, V. (1987). Direct least-squares fitting of algebraic surfaces. Computer Graphics, Vol. 21, pages 145-152.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Dataset on Schwartz values:
require(plotrix)
valsD &lt;- 1 - cor(indvalues)
fit &lt;- mds(valsD)
plot(fit, main = "MDS Value Circle")
circle &lt;- fitCircle(fit$conf[,1], fit$conf[,2])
draw.circle(circle$cx, circle$cy, radius = circle$radius, border = "gray") 
</code></pre>

<hr>
<h2 id='GOPdtm'>Republican Statements</h2><span id='topic+GOPdtm'></span>

<h3>Description</h3>

<p>Document-term matrix based on statements by Republican voters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GOPdtm)</code></pre>


<h3>Format</h3>

<p>Document-term matrix with statements in the rows and terms (keywords) in the columns
</p>


<h3>Details</h3>

<p>This dataset emerges from statements of Republican voters scraped from the official 
GOP website. They were asked to complete the sentence &quot;I am a Republican because ...&quot;. We have 
selected the 37 most frequent words and created a document-term matrix.
</p>


<h3>References</h3>

<p>air, P., Rusch, T. &amp; Hornik, K. (2014). The Grand Old Party - A party of values? SpringerPlus, 3(697), <a href="https://springerplus.springeropen.com/articles/10.1186/2193-1801-3-697">https://springerplus.springeropen.com/articles/10.1186/2193-1801-3-697</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GOPdtm)
GOPdtm
</code></pre>

<hr>
<h2 id='gravity'>Gravity dissimilarities</h2><span id='topic+gravity'></span>

<h3>Description</h3>

<p>Computes the dissimilarities using a gravity model based on co-occurrences.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gravity(X, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gravity_+3A_x">X</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="gravity_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first step in this function is to compute the co-occurences. Based on the 
binarized data matrix <code class="reqn">Y</code> we compute <code class="reqn">Y'Y</code> which leads to the co-occurence matrix.
We then use the gravity model to compute the gravity dissimilarities. 
In order to give more (or less) structure to the MDS solution, the tuning parameter (which 
defines a power transformation) can be increased (or decreased). In addition, 
a weight matrix is created that sets cells with no co-occurences to 0. The corresponding weight matrix for blanking out these cells is established automatically in <code>mds()</code>. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>gravdiss</code></td>
<td>
<p>Gravity dissimilarities</p>
</td></tr>
<tr><td><code>weightmat</code></td>
<td>
<p>Weight matrix for subsequent smacof computation</p>
</td></tr>
<tr><td><code>co.occ</code></td>
<td>
<p>Matrix with co-occurences</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick Mair</p>


<h3>References</h3>

<p>Mair, P., Rusch, T. &amp; Hornik, K. (2014). The Grand Old Party - A party of values?
SpringerPlus, 3(697), <a href="https://springerplus.springeropen.com/articles/10.1186/2193-1801-3-697">https://springerplus.springeropen.com/articles/10.1186/2193-1801-3-697</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mds">mds</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GOPdtm)
gravD &lt;- gravity(GOPdtm, lambda = 2)
res &lt;- mds(gravD$gravdiss)  
res$weightmat  ## NA's were blanked out when fitting the model
plot(res)
</code></pre>

<hr>
<h2 id='Guerry'>Map Dataset France 1830</h2><span id='topic+Guerry'></span>

<h3>Description</h3>

<p>Distances (in km) among French Departments in 1830.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Guerry)</code></pre>


<h3>Format</h3>

<p>Symmetric matrix with distances. 
</p>


<h3>References</h3>

<p>Friendly, M. (2007). A. M. Guerry's Moral Statistics of France: Challenges for Multivariate Spatial Analysis, 
Statistical Science, 2007, 22(3), 368-399. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Guerry
</code></pre>

<hr>
<h2 id='Guttman1991'>Guttman's Intelligence Facets</h2><span id='topic+Guttman1991'></span><span id='topic+Guttman1965'></span>

<h3>Description</h3>

<p>The first dataset (<code>Guttman1991</code>) contains similarities and facets for Guttman's 3D cylindrical intelligence structure as published in Guttman (1991). The second dataset (<code>Guttman1965</code>) contains similarities and structural intelligence facets from Guttman (1965). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Guttman1991)
data(Guttman1965)
</code></pre>


<h3>Format</h3>

<p>List with two elements: The first element contains the similarity matrix, the second element the facets labels.
</p>


<h3>References</h3>

<p>Guttman, L. &amp; Levy, S. (1991). Two structural laws for intelligence tests. Intelligence, 15, 79-103. 
</p>
<p>Guttman, L. (1965). The structure of interrelations among intelligence tests. In C. W. Harris (Ed.), Proceedings of the 1964 Invitational Conference on Testing Problems (pp. 23-36). Princeton: ETS. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Guttman1991[[1]]        ## similarity matrix
Guttman1991[[2]]        ## facets

Guttman1965[[1]]        ## similarity matrix
Guttman1965[[2]]        ## facets
</code></pre>

<hr>
<h2 id='helm'>Helm's color data</h2><span id='topic+helm'></span>

<h3>Description</h3>

<p>Contains dissimilarity data for individual difference scaling from an experiment carried out by Helm (1959). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(helm)</code></pre>


<h3>Format</h3>

<p>List containing objects of class <code>dist</code>
</p>


<h3>Details</h3>

<p>A detailed description of the experiment can be found in Borg and Groenen (2005, p. 451) with the corresponding Table 21.1. containing distance estimates for color pairs. There were 14 subjects that rated the similarity of colors, 2 of whom replicated the experiment. 10 subjects have a normal color vision (labelled by N1 to N10 in our list object), 4 of them are red-green deficient in varying degrees. In this dataset we give the dissimilarity matrices for each of the subjects, including the replications. They are organized as a list of length 16 suited for <code>smacofIndDiff</code> computations.
</p>
<p>The authors thank Michael Friendly and Phil Spector for data preparation. 
</p>


<h3>References</h3>

<p>Helm, C. E. (1959). A multidimensional ratio scaling analysis of color relations. Technical Report, Princeton University and Educational Testing Service. Princeton, NJ. 
</p>
<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling: Theory and Applications (2nd edition). New York: Springer. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>helm
</code></pre>

<hr>
<h2 id='icExplore'>Exploring Initial Configurations</h2><span id='topic+icExplore'></span><span id='topic+plot.icexplore'></span>

<h3>Description</h3>

<p>Allows to user to explore the effect of various random starting configurations when fitting an MDS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icExplore(delta, nrep = 100, returnfit = FALSE, ndim = 2, 
type = c("ratio", "interval", "ordinal","mspline"), weightmat = NULL, ties = "primary",	
verbose = FALSE, relax = FALSE, modulus = 1, itmax = 1000, eps = 1e-6, 
spline.degree = 2, spline.intKnots = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icExplore_+3A_delta">delta</code></td>
<td>
<p>Either a symmetric dissimilarity matrix or an object of class <code>"dist"</code></p>
</td></tr>
<tr><td><code id="icExplore_+3A_nrep">nrep</code></td>
<td>
<p>Number of initial random configurations</p>
</td></tr>
<tr><td><code id="icExplore_+3A_returnfit">returnfit</code></td>
<td>
<p>If <code>TRUE</code> all fitted models are returned.</p>
</td></tr>
<tr><td><code id="icExplore_+3A_ndim">ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="icExplore_+3A_weightmat">weightmat</code></td>
<td>
<p>Optional matrix with dissimilarity weights</p>
</td></tr>
<tr><td><code id="icExplore_+3A_type">type</code></td>
<td>
<p>MDS type: <code>"interval"</code>, <code>"ratio"</code>, <code>"ordinal"</code> (nonmetric MDS), or <code>"mspline"</code></p>
</td></tr>
<tr><td><code id="icExplore_+3A_ties">ties</code></td>
<td>
<p>Tie specification (ordinal MDS only): <code>"primary"</code>, <code>"secondary"</code>, or <code>"tertiary"</code></p>
</td></tr>
<tr><td><code id="icExplore_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, replication number is printed</p>
</td></tr>
<tr><td><code id="icExplore_+3A_relax">relax</code></td>
<td>
<p>If <code>TRUE</code>, block relaxation is used for majorization</p>
</td></tr>
<tr><td><code id="icExplore_+3A_modulus">modulus</code></td>
<td>
<p>Number of smacof iterations per monotone regression call</p>
</td></tr>
<tr><td><code id="icExplore_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="icExplore_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="icExplore_+3A_spline.degree">spline.degree</code></td>
<td>
<p>Degree of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
<tr><td><code id="icExplore_+3A_spline.intknots">spline.intKnots</code></td>
<td>
<p>Number of interior knots of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a large set of MDS solutions using random initial configurations, matches them all by Procrustean fittings, computes the inter-correlations of their point coordinates, and finally runs an interval MDS of these inter-correlations. It can be used to explore local minima.
</p>
<p>In the plot function the number reflects the index of corresponding MDS fit, the size reflects the stress value: the larger the font, the larger the stress (i.e., the worse the solution). The size is associated with a corresponding color shading (the smaller the size the darker the color). 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mdsfit</code></td>
<td>
<p>Fitted MDS objects (<code>NULL</code> if <code>returnfit = FALSE</code>)</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>Configuration based on multiple random starts</p>
</td></tr>
<tr><td><code>stressvec</code></td>
<td>
<p>Vector with stress values</p>
</td></tr>
</table>


<h3>References</h3>

<p>Borg, I. and Mair, P. (2017). The choice of initial configurations in multidimensional scaling: local
minima, fit, and interpretability. Austrian Journal of Statistics, 46, 19-32. <a href="https://doi.org/10.17713/ajs.v46i2.561">doi:10.17713/ajs.v46i2.561</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mds">mds</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simple example with 20 random starts
diss &lt;- sim2diss(wish, method = 7)
set.seed(123)
res &lt;- icExplore(diss, type = "ordinal", nrep = 20, returnfit = TRUE)
res
plot(res) 

res$mdsfit[[14]]  ## bad fitting solution
res$mdsfit[[3]]   ## better fitting solution
</code></pre>

<hr>
<h2 id='indvalues'>Schwartz Value Survey</h2><span id='topic+indvalues'></span>

<h3>Description</h3>

<p>Responses from a sample in Britain were collected varying in value measures of the Schwartz value theory. The instrument used was the Schwartz Value Survey (SVS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(indvalues)</code></pre>


<h3>Format</h3>

<p>Data frame with 327 persons in the rows and psychological values in the columns. 
</p>


<h3>Details</h3>

<p>The data were centered (row-wise) and converted from preferences into dissimilarities.
</p>


<h3>References</h3>

<p>Borg, I., Bardi, A., &amp; Schwartz, S. H. (2017). Does the value circle exist within persons or only across persons? Journal of Personality, 85(2), 151-162. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PVQ40">PVQ40</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>str(indvalues)
</code></pre>

<hr>
<h2 id='intelligence'>Intelligence Tests</h2><span id='topic+intelligence'></span>

<h3>Description</h3>

<p>Contains intercorrelations of 8 intelligence tests, together with two facets. 
In addition, a hypothesized restriction matrix for the intercorrelations is provided. 
The proximities for items with the same structuples, such as p(NA1,NA2) and p(GA1,GA3), all are set to the value 
5. The proximities that correspond to the immediate neighborhood relations
are set to the value 4, since none of these distances should be larger 
than any distance between definitionally equivalent items. Finally, the large 
distances between the groups NI, GA and the groups NA, GI are set to 3.
The intelligence tests are coded on the follwing facets: format (N = numerical, G = geometrical) and 
requirement (A = application, I - inference). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(intelligence)</code></pre>


<h3>Format</h3>

<p>Data frame of 8 intelligence tests: facets, intercorrelations, and restrictions
</p>
<p>Test: Test number
</p>
<p>Languange: numerical, geometrical
</p>
<p>Requirement: application, inference
</p>
<p>T1-T8: intercorrelations
</p>
<p>R1-R8: restrictions
</p>


<h3>References</h3>

<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.). Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>idiss &lt;- sim2diss(intelligence[,paste0("T", 1:8)])
fit &lt;- mds(idiss)
plot(fit)
</code></pre>

<hr>
<h2 id='jackmds'>SMACOF Jackknife</h2><span id='topic+jackmds'></span><span id='topic+jackmds.smacofB'></span><span id='topic+plot.smacofJK'></span><span id='topic+print.smacofJK'></span>

<h3>Description</h3>

<p>These methods perform a SMACOF Jackknife and plot the corresponding solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofB'
jackmds(object, eps = 1e-6, itmax = 100, verbose = FALSE)

## S3 method for class 'smacofJK'
plot(x, plot.dim = c(1,2), hclpar = list(c = 50, l = 70), 
col.p, col.l, plot.lines = TRUE, legend = FALSE, inset = c(-0.2, 0), cex.legend = 0.7,
main, xlab, ylab, xlim, ylim, asp = 1, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jackmds_+3A_object">object</code></td>
<td>
<p>Object of class <code>"smacofB"</code>, i.e., an MDS solution from <code>smacofSym()</code></p>
</td></tr>
<tr><td><code id="jackmds_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="jackmds_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="jackmds_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate stress is printed out</p>
</td></tr>
<tr><td><code id="jackmds_+3A_x">x</code></td>
<td>
<p>Object of class <code>"smacofJK"</code></p>
</td></tr>
<tr><td><code id="jackmds_+3A_plot.dim">plot.dim</code></td>
<td>
<p>Vector with dimensions to be plotted.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_hclpar">hclpar</code></td>
<td>
<p>Chroma and luminance to be used for HCL colors (further details see <code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code>)</p>
</td></tr>
<tr><td><code id="jackmds_+3A_col.p">col.p</code></td>
<td>
<p>Point color. If omitted, hcl colors will be used; if specified, the corresponding (single) color will be used for plotting.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_col.l">col.l</code></td>
<td>
<p>Line color. If omitted, hcl colors will be used; if specified, the corresponding (single) color will be used for plotting.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_plot.lines">plot.lines</code></td>
<td>
<p>If <code>TRUE</code>, the Jackknife configurations are plotted are connected with their centroid.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_legend">legend</code></td>
<td>
<p>If <code>TRUE</code>, the centroid labels are added as legend.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_inset">inset</code></td>
<td>
<p>Inset distance from the margins as a fraction of the plot region when legend is placed by keyword.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Character expansion factor for legend.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_xlim">xlim</code></td>
<td>
<p>Scale x-axis.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_ylim">ylim</code></td>
<td>
<p>Scale y-axis.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio.</p>
</td></tr>
<tr><td><code id="jackmds_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see <code><a href="graphics.html#topic+plot.default">plot</a></code> for detailed information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to examine the stability solution of an MDS, a Jackknife on the configurations can be performed (see de Leeuw &amp; Meulman, 1986) and plotted. The plot shows the jackknife configurations which are connected to their centroid. In addition, the original smacof configuration (transformed through Procrustes) is plotted. The Jackknife function itself returns also a stability measure (as ratio of between and total variance), a measure for cross validity, and the dispersion around the original smacof solution. 
</p>


<h3>Value</h3>

   
<table role = "presentation">
<tr><td><code>smacof.conf</code></td>
<td>
<p>SMACOF configurations</p>
</td></tr>
<tr><td><code>jackknife.conf</code></td>
<td>
<p>An array of n-1 configuration matrices for each Jackknife MDS solution</p>
</td></tr>
<tr><td><code>comparison.conf</code></td>
<td>
<p>Centroid Jackknife configurations (comparison matrix)</p>
</td></tr>
<tr><td><code>stab</code></td>
<td>
<p>Stability measure</p>
</td></tr>
<tr><td><code>cross</code></td>
<td>
<p>Cross validity</p>
</td></tr>
<tr><td><code>disp</code></td>
<td>
<p>Dispersion</p>
</td></tr>
<tr><td><code>loss</code></td>
<td>
<p>Value of the loss function</p>
</td></tr>
<tr><td><code>ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Model call</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>nobj</code></td>
<td>
<p>Number of objects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan de Leeuw and Patrick Mair</p>


<h3>References</h3>

<p>De Leeuw, J., &amp; Meulman, J. (1986). A special jackknife for multidimensional scaling. Journal of Classification, 3, 97-112.
</p>
<p>Mair, P., Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2, Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootmds">bootmds</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## symmetric smacof
data &lt;- na.omit(PVQ40[,1:5])
diss &lt;- dist(t(data))   ## Euclidean distances 
fit &lt;- mds(diss) 
res.jk &lt;- jackmds(fit)

plot(res.jk, col.p = "black", col.l = "gray")
plot(res.jk, hclpar = list(c = 80, l = 40))
plot(res.jk, hclpar = list(c = 80, l = 40), plot.lines = FALSE)

</code></pre>

<hr>
<h2 id='kinshipdelta'>Kinship Terms</h2><span id='topic+kinshipdelta'></span><span id='topic+kinshipscales'></span>

<h3>Description</h3>

<p>Percentages of how often 15 kinship terms were not grouped together by college students including three external scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kinshipdelta)

data(kinshipscales)
</code></pre>


<h3>Format</h3>

<p>Dissimilarity matrix of 15 kinship terms and data frame with the following external scales:
</p>
<p>Gender (1 = male, 2 = female)
</p>
<p>Generation (-2 = two back, -1 = one back, 0 = same generation, 1 = one ahead, 2 = two ahead)
</p>
<p>Degree (1 = first, 2 = second, 3 = third, 4 = fourth)
</p>


<h3>References</h3>

<p>Rosenberg, S. &amp; Kim, M. P. (1975). The method of sorting as a data gathering procedure in multivariate research. Multivariate Behavioral Research, 10, 489-502.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kinshipdelta
kinshipscales

</code></pre>

<hr>
<h2 id='KIPT'>Kennedy Institute Phonics Test</h2><span id='topic+KIPT'></span>

<h3>Description</h3>

<p>Contains correlations of eight test items of the Kennedy Institute Phonics Test (KIPT), a test for reading skills. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(KIPT)
</code></pre>


<h3>Format</h3>

<p>An 8 times 8 correlation matrix. Items: 
</p>
<p>Nonsense word production: NP
</p>
<p>Long vowel production: LVP
</p>
<p>Short vowel production: SVP
</p>
<p>Consonant cluster production: CCP 
</p>
<p>Nonsense word recognition: NR 
</p>
<p>Single letter production: SLP 
</p>
<p>Consonant cluster recognition: CCR 
</p>
<p>Initial letter recognition: ILR
</p>


<h3>References</h3>

<p>Guthrie, J. T. (1973). Models of reading and reading disability. Journal of Educational Psychology, 65, 9-18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KIPT
sim2diss(KIPT)
</code></pre>

<hr>
<h2 id='LawLer'>Management Performance Data</h2><span id='topic+Lawler'></span>

<h3>Description</h3>

<p>Performance of managers: 3 criteria (&quot;traits&quot;) and 3 methods. Traits:
T1 = Quality of output, T2 = Ability to generate output, T3 = Demonstrated effort to perform.
Methods: M1 = Rating by superior, M2 = Peer rating, M3 = Self-rating. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Lawler)</code></pre>


<h3>Format</h3>

<p>Symmetric matrix (trait-method combinations) with inter-correlations. 
</p>


<h3>References</h3>

<p>Lawler, E. E. (1967).  Management performance as seen from above, below, and within.  In 
Evaluation of executive performance.  Princeton, New Jersey.  Educational Testing Service. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lawler
</code></pre>

<hr>
<h2 id='morse'>Morse Code Confusion Data</h2><span id='topic+morse'></span><span id='topic+morse2'></span>

<h3>Description</h3>

<p>Confusion percentages between Morse code signals. The scores are derived 
from confusion rates on 36 Morse code signals (26 for the alphabet; 10 for the numbers 
0,...,9). Each Morse code signal is a sequence of up to five 'beeps'. The beeps can be 
short (0.05 sec) or long (0.15 sec), and, when there are two or more beeps in a signal, 
they are separated by periods of silence (0.05 sec).
</p>
<p>Rothkopf asked 598 subjects to judge whether two signals, presented acoustically one 
after another, were the same or not. The values are the average percentages with which 
the answer 'Same!' was given in each combination of row stimulus i and column stimulus j, 
where either i or j was the first signal presented. The values are 1 minus the 
symmetrized confusion rates and are thus dissimilarities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(morse)
data(morse2)
</code></pre>


<h3>Format</h3>

<p>Symmetric and asymmetric dissimilarity matrices of 36 morse codes</p>


<h3>Details</h3>

<p>The first dataset (<code>morse</code>) contains a symmetric version, the second dataset (<code>morse2</code>) the original asymmetric version.
</p>


<h3>References</h3>

<p>Rothkopf, E. Z. (1957). A measure of stimulus similarity and errors in some 
paired-associate learning. Journal of Experimental Psychology, 53, 94-101.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>morse
morse2
</code></pre>

<hr>
<h2 id='morsescales'>Morse Code Confusion Scales</h2><span id='topic+morsescales'></span>

<h3>Description</h3>

<p>Two properties of Morse code signals. Each Morse code signal is a
sequence of up to five 'beeps'. The beeps can be short (0.05 sec) or
long (0.15 sec), and, when there are two or more beeps in a signal,
they are separated by periods of silence (0.05 sec). The two external
variables are: Signal type (1 = all short beeps, 2 = more short than long beeps, 
3 = same short and long beeps, 4 = more long than short beeps, 5 = all long beeps)
and Signal length (in seconds; 1 = .05, 2 = .15, 3 = .25, 4 = .35, 5 = .45,
6 = .55, 7 = .65, 8 = .85, 9 = .95).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(morsescales)
</code></pre>


<h3>Format</h3>

<p>Matrix of 36 morse codes by 2 properties. The first column contains the morse 
code letters.</p>


<h3>References</h3>

<p>Rothkopf, E. Z. (1957). A measure of stimulus similarity and errors in some 
paired-associate learning. Journal of Experimental Psychology, 53, 94-101.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>morsescales
</code></pre>

<hr>
<h2 id='OCP'>Organizational Culture Profile</h2><span id='topic+OCP'></span>

<h3>Description</h3>

<p>Contains similarities (correlations) of 54 OCP (see O'Reilly, Chatman, and Caldwell, 1991) items. The last three columns contain the facet assigned by Bilsky and Jehn (2002) as well as the external variables for regional restrictions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OCP)</code></pre>


<h3>Format</h3>

<p>Data frame with OCP item correlations and facet:
</p>
<p>i1-i54: OCP item correlations
</p>
<p>facet: factor with facets
</p>
<p>z1, z2: external constraints
</p>


<h3>References</h3>

<p>Bilsky, W. &amp; Jehn, K. (2002).  Organizational Culture and Individual Values: Evidence 
for a Common Structure.  In M. Myrtek (Ed.), The Person in Biological and Social Context, 
pp. 211-228. Goettingen, Germany: Hogrefe Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ocpD &lt;- sim2diss(OCP[,1:54])
fit &lt;- mds(ocpD, type = "ordinal")
plot(fit)
</code></pre>

<hr>
<h2 id='partypref'>Party preferences</h2><span id='topic+partypref'></span>

<h3>Description</h3>

<p>Artificial dataset containing the judges in the rows and the parties in the columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(partypref)</code></pre>


<h3>Format</h3>

<p>Matrix of party preferences.
</p>


<h3>References</h3>

<p>Borg, I., Groenen, P. J. F., &amp; Mair, P. (2010). Multidimensionale Skalierung. Muenchen: Hampp Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>partypref
</code></pre>

<hr>
<h2 id='perception'>Rectangle Perception Data</h2><span id='topic+perception'></span>

<h3>Description</h3>

<p>42 subjects are assigned to two groups of 21 persons. 120 stimulus pairs of rectangles are presented. For the first group (width-height; WH), the rectangles were constructed according to a design as given in <code>rect_constr</code>. For the second group (size-shape; SS) the rectangles were constructed according to a grid design, which is orthogonal in the dimensional system reflecting area (size), and width/height (shape). All subjects had to judge the similarity of the rectangles on a scale from 0 to 9. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(perception)</code></pre>


<h3>Format</h3>

<p>List of subject dissimilarities for WH (first element) and SS group (second element).
</p>


<h3>References</h3>

<p>Borg, I. &amp; Leutner, D. (1983). Dimensional models for the perception of rectangles. Perception and Psychophysics, 34, 257-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rectangles">rectangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>perception
rect_constr
</code></pre>

<hr>
<h2 id='permtest'>SMACOF Permutation</h2><span id='topic+permtest'></span><span id='topic+permtest.smacof'></span><span id='topic+permtest.smacofR'></span><span id='topic+plot.smacofPerm'></span><span id='topic+print.smacofPerm'></span>

<h3>Description</h3>

<p>These methods perform a permutation test for a symmetric or an unfolding SMACOF model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacof'
permtest(object, data,  method.dat = "pearson", nrep = 100, verbose = TRUE, ...)
## S3 method for class 'smacofR'
permtest(object, data = NULL,  method.dat = "rows", nrep = 100, verbose = TRUE, ...)
## S3 method for class 'smacofPerm'
plot(x, alpha = 0.05, main, xlab, ylab, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permtest_+3A_object">object</code></td>
<td>
<p>Object of class <code>"smacofB"</code>, i.e., an MDS solution from <code>smacofSym()</code></p>
</td></tr>
<tr><td><code id="permtest_+3A_data">data</code></td>
<td>
<p>Optional argument; if provided permutations are performed on the data matrix (see details; ignored for unfolding models)</p>
</td></tr>
<tr><td><code id="permtest_+3A_method.dat">method.dat</code></td>
<td>
<p>If data are provided, this must be one of <code>"pearson"</code>, <code>"spearman"</code>, <code>"kendall"</code>, <code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>, <code>"canberra"</code>, <code>"binary"</code>. For unfolding models it is either <code>"full"</code> for full permutations or <code>"rows"</code> for permutations within rows.</p>
</td></tr> 
<tr><td><code id="permtest_+3A_nrep">nrep</code></td>
<td>
<p>Number of permutations</p>
</td></tr>
<tr><td><code id="permtest_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, permutation index is printed out</p>
</td></tr>
<tr><td><code id="permtest_+3A_x">x</code></td>
<td>
<p>Object of class <code>"smacofPerm"</code></p>
</td></tr>
<tr><td><code id="permtest_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level</p>
</td></tr>
<tr><td><code id="permtest_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="permtest_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="permtest_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="permtest_+3A_...">...</code></td>
<td>
<p>additional plot arguments for plot function; additional arguments to be passed to <code>sim2diss</code> in permutation functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine permutes m dissimilarity values, where m is the number of lower diagonal elements in the corresponding dissimilarity matrix. For each sample a symmetric, nonmetric SMACOF of dimension <code>ndim</code> is computed and the stress values are stored in <code>stressvec</code>. Using the fitted stress value, the p-value is computed. Subsequently, the empirical cumulative distribution function can be plotted using the plot method. 
</p>
<p>If the MDS fit provided on derived proximities of a data matrix, this matrix can be passed to the <code>permtest</code> function. Consequently, the data 
matrix is subject to permutations. The proximity measure used for MDS fit has to match the one used for the permutation test. If a correlation 
similarity is provided, it is converted internally into a dissimilarity using <code>sim2diss</code> with corresponding arguments passed to the
<code>...</code> argument. 
</p>


<h3>Value</h3>

   
<table role = "presentation">
<tr><td><code>stressvec</code></td>
<td>
<p>Vector containing the stress values of the permutation samples</p>
</td></tr>
<tr><td><code>stress.obs</code></td>
<td>
<p>Stress (observed sample)</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>Resulting p-value</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Model call</p>
</td></tr>
<tr><td><code>nrep</code></td>
<td>
<p>Number of permutations</p>
</td></tr>
<tr><td><code>nobj</code></td>
<td>
<p>Number of objects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick Mair and Ingwer Borg</p>


<h3>References</h3>

<p>Mair, P., Borg, I., and Rusch, T. (2016). Goodness-of-fit assessment in multidimensional scaling
and unfolding. Multivariate Behavioral Research, 51, 772-789.
</p>
<p>Mair, P, Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2, Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jackmds">jackmds</a></code>, <code><a href="#topic+bootmds">bootmds</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## permuting the dissimilarity matrix (full)
data(kinshipdelta)
fitkin &lt;- mds(kinshipdelta, ndim = 2, type = "interval")
set.seed(222)
res.perm &lt;- permtest(fitkin)
res.perm
plot(res.perm)

## permuting the data matrix
GOPdtm[GOPdtm &gt; 1] &lt;- 1     ## use binary version
diss1 &lt;- dist(t(GOPdtm[,1:10]), method = "binary")  ## Jaccard distance
fitgop1 &lt;- mds(diss1, type = "ordinal")
fitgop1
set.seed(123)
permtest(fitgop1, GOPdtm[,1:10], nrep = 10, method.dat = "binary")

rmat &lt;- cor(GOPdtm[,1:10], method = "kendall")  ## Kendall correlation
diss2 &lt;- sim2diss(rmat, method = 1)
fitgop2 &lt;- mds(diss2, type = "ordinal")
fitgop2
set.seed(123)
permtest(fitgop2, GOPdtm[,1:10], nrep = 10, method.dat = "kendall", method = 1)

## unfolding permutation
data(breakfast)
res.unfolding &lt;- unfolding(breakfast, ndim = 2)
set.seed(123)
permtest(res.unfolding, nrep = 20, method.dat = "rows")
</code></pre>

<hr>
<h2 id='Plato7'>Plato's Seven Works</h2><span id='topic+Plato7'></span>

<h3>Description</h3>

<p>This dataset contains statistical information about Plato's seven works. The underlying problem to this dataset is the fact that
the chronological order of Plato's works is unknown. Scholars only know that Republic was his first work, and Laws his last work. For each work, Cox and Brandwood (1959) extracted the last five syllables of each sentence. Each syllable is classified
as long or short which gives 32 types. Consequently, we obtain a percentage distribution across the 32 scenarios for each of the seven works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Plato7)</code></pre>


<h3>Format</h3>

<p>Data frame containing syllable percentages of Plato's 7 works. 
</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Brandwood, L. (1959). On a discriminatory problem connected with the work of Plato. Journal of the Royal Statistical Society (Series B), 21, 195-200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plato7
</code></pre>

<hr>
<h2 id='plot.smacof'>2D SMACOF plots</h2><span id='topic+plot.smacof'></span><span id='topic+plot.smacofR'></span><span id='topic+plot.smacofID'></span>

<h3>Description</h3>

<p>These methods provide various 2D plots for SMACOF models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacof'
plot(x, plot.type = "confplot", plot.dim = c(1,2), sphere = TRUE, 
                      bubscale = 1, col = 1, label.conf = list(label = TRUE, pos = 3, 
                      col = 1, cex = 0.8), hull.conf = list(hull = FALSE, col = 1, 
                      lwd = 1, ind = NULL), shepard.x = NULL, identify = FALSE, 
                      type = "p", pch = 20, cex = 0.5, asp = 1, main, xlab, ylab, 
                      xlim, ylim, col.hist = NULL, ...)

## S3 method for class 'smacofR'
plot(x, plot.type = "confplot", what = c("both", "columns", "rows"), 
                       plot.dim = c(1,2), col.rows = hcl(0), col.columns = hcl(240), 
                       label.conf.rows = list(label = TRUE, pos = 3, 
                       col = hcl(0, l = 50), cex = 0.8), 
                       label.conf.columns = list(label = TRUE, pos = 3, 
                       col = hcl(240, l = 50), cex = 0.8),  
                       shepard.x = NULL, col.dhat = NULL, type = "p", pch = 20,
                       cex = 0.5, asp = 1, main, xlab, ylab, xlim, ylim, ...)

## S3 method for class 'smacofID'
plot(x, plot.type = "confplot", plot.dim = c(1,2), bubscale = 1, 
                        col = 1, label.conf = list(label = TRUE, pos = 3, col = 1, 
                        cex = 0.8), identify = FALSE, type = "p", pch = 20,  cex = 0.5, 
                        asp = 1, plot.array, main, xlab, ylab, xlim, ylim, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.smacof_+3A_x">x</code></td>
<td>
<p>Object of class <code>"smacof"</code>, <code>"smacofR"</code>, and <code>"smacofID"</code> (see details)</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_plot.type">plot.type</code></td>
<td>
<p>String indicating which type of plot to be produced: <code>"confplot"</code>, <code>"resplot"</code> 
<code>"Shepard"</code>, <code>"stressplot"</code>, <code>"bubbleplot"</code> <code>"histogram"</code> (see details)</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_plot.dim">plot.dim</code></td>
<td>
<p>Vector with dimensions to be plotted.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_xlim">xlim</code></td>
<td>
<p>Scale x-axis.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_ylim">ylim</code></td>
<td>
<p>Scale y-axis.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_type">type</code></td>
<td>
<p>What type of plot should be drawn (see also <code><a href="graphics.html#topic+plot.default">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_pch">pch</code></td>
<td>
<p>Plot symbol.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_cex">cex</code></td>
<td>
<p>Symbol size.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_col">col</code></td>
<td>
<p>Point color.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_sphere">sphere</code></td>
<td>
<p>In case of spherical smacof, whether sphere should be plotted or not.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_bubscale">bubscale</code></td>
<td>
<p>Scaling factor (size) for the bubble plot.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_label.conf">label.conf</code></td>
<td>
<p>List with arguments for plotting the labels of the configurations in a configuration plot (logical value whether to plot labels or not, label position, label color). If <code>pos = 5</code> labels are placed away from the nearest point.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_hull.conf">hull.conf</code></td>
<td>
<p>Option to add convex hulls to a configuration plot. Hull index needs to be provided.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_shepard.x">shepard.x</code></td>
<td>
<p>Shepard plot only: original data (e.g. correlation matrix) can be provided for plotting on x-axis.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_identify">identify</code></td>
<td>
<p>If <code>TRUE</code>, the <code>identify()</code> function is called internally that allows to add configuration labels by mouse click.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_what">what</code></td>
<td>
<p>For unfolding only: Whether row coordinates, column coordinates, or both should be plotted.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_col.rows">col.rows</code></td>
<td>
<p>Row colors in unfolding configuration plot.</p>
</td></tr> 
<tr><td><code id="plot.smacof_+3A_col.columns">col.columns</code></td>
<td>
<p>Column colors in unfolding configuration plot.</p>
</td></tr> 
<tr><td><code id="plot.smacof_+3A_col.dhat">col.dhat</code></td>
<td>
<p>Shepard plot only: color specification of the dhats. For row conditional transformations in unfolding a vector of the length of the number of rows should be specified.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_label.conf.rows">label.conf.rows</code></td>
<td>
<p>List with arguments for plotting the labels of the row configurations in an unfolding configuration plot (logical value whether to plot labels or not, label position, label color).</p>
</td></tr> 
<tr><td><code id="plot.smacof_+3A_label.conf.columns">label.conf.columns</code></td>
<td>
<p>List with arguments for plotting the labels of the columns configurations in an unfolding configuration plot (logical value whether to plot labels or not, label position, label color).</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_col.hist">col.hist</code></td>
<td>
<p>Color of the borders of the histogram.</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_plot.array">plot.array</code></td>
<td>
<p>Array arrangements of plots for individual difference models (see details).</p>
</td></tr>
<tr><td><code id="plot.smacof_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see <code><a href="graphics.html#topic+plot.default">plot</a></code> for detailed information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mds()</code> and <code>smacofSym()</code> create an object of class <code>"smacof"</code>, <code>unfolding()</code>, <code>prefscal()</code>, and <code>smacofRect()</code> produce <code>"smacofR"</code>, and <code>smacofIndDiff()</code> generates <code>"smacofID"</code>.
</p>
<p>Plot description:
</p>
<p>- Configuration plot (<code>plot.type = "confplot"</code>): Plots the MDS configuration.
</p>
<p>- Residual plot (<code>plot.type = "resplot"</code>): Plots the disparities (d-hats) distances against  
the fitted distances. 
</p>
<p>- Shepard diagram (<code>plot.type = "Shepard"</code>): Diagram with the observed dissimilarities against the fitted distances including (isotonic) regression line.
</p>
<p>- Stress decomposition plot (<code>plot.type = "stressplot"</code>): Plots the stress contribution in of each observation. Note that it rescales the stress-per-point (SPP) from the corresponding smacof function to percentages (sum is 100). The higher the contribution, the worse the fit. 
</p>
<p>- Bubble plot (<code>plot.type = "bubbleplot"</code>, not available for rectangular SMACOF): Combines the configuration plot with the point stress contribution. The larger the bubbles, the worse the fit. 
</p>
<p>- Histogram (<code>plot.type = "histogram"</code>: gives a weighted histogram of the dissimilarities. For optional arguments, see <code><a href="weights.html#topic+wtd.hist">wtd.hist</a></code>.
</p>
<p>For <code>smacofIndDiff()</code> the residual plot, Shepard diagram, and stress plot are based on the sum of the residuals across individuals/ways. The configuration plot represents the group stimulus space (i.e., joint configuration). If <code>plot.array</code> is not specified, it produces a Shepard plot of the distances summed across subjects, if <code>plot.array = 0</code> it produces a sqrt(nsubjects) times sqrt(nsubjects) array of graph panels, if <code>plot.array = 3</code> it produces 3x3 arrays of graph panels, if <code>plot.array = c(2, 3)</code> it produces 2x3 arrays of graph panels, and if <code>plot.array = c(3, 2, 5)</code> produces 3x2 arrays of panels (only the first two values are used).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.procr">plot.procr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 2D plots for simple MDS
data(trading)
res &lt;- mds(trading)
plot(res, plot.type = "confplot")
plot(res, plot.type = "confplot", label.conf = list(pos = 5)) ## avoid overlapping labels
plot(res, plot.type = "Shepard")
plot(res, plot.type = "stressplot")
plot(res, plot.type = "resplot")
plot(res, plot.type = "bubbleplot")
plot(res, plot.type = "histogram")

## Add convex hulls to configuration plot
r &lt;- cor(PVQ40, use = "pairwise.complete.obs")
diss &lt;- sim2diss(r, method = "corr") 
res &lt;- mds(delta = diss, type = "ordinal") 
codes &lt;- substring(colnames(PVQ40), 1, 2)  ## supplementary variable
plot(res, hull.conf = list(hull = TRUE, ind = codes, col = "coral1", lwd = 2))

## Shepard plots
ekmanD &lt;- sim2diss(ekman)
fit1 &lt;- mds(ekmanD, type = "ordinal")
plot(fit1, plot.type = "Shepard")
plot(fit1, plot.type = "Shepard", shepard.x = ekman)  ## original data on x-axis

## Joint configuration plot and row/column stressplots for unfolding
data(breakfast)
res &lt;- unfolding(breakfast)
plot(res, plot.type = "confplot")
plot(res, plot.type = "stressplot")
</code></pre>

<hr>
<h2 id='Procrustes'>Procrustean Similarity Transformations</h2><span id='topic+Procrustes'></span><span id='topic+plot.procr'></span>

<h3>Description</h3>

<p>Solves the Procrustean problem of fitting one (MDS) configuration (testee) to another (target) MDS configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Procrustes(X, Y)

## S3 method for class 'procr'
plot(x, plot.type = "jointplot", plot.dim = c(1,2), main, xlab, ylab, 
                     xlim, ylim, asp = 1, pch = 20, col.X = "cadetblue", 
                     col.Y = "gray", col.Yhat = "coral1", 
                     label.conf = list(label = TRUE, pos = 3, cex = 0.8), 
                     arrows = TRUE, length = 0.10, 
                     legend = list(plot = TRUE, labels = c("Target", "Testee"), 
                                   pos = "bottomright"), ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Procrustes_+3A_x">X</code></td>
<td>
<p>Target configuration</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_y">Y</code></td>
<td>
<p>Testee configuration</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_x">x</code></td>
<td>
<p>Object of class <code>procr</code></p>
</td></tr>
<tr><td><code id="Procrustes_+3A_plot.type">plot.type</code></td>
<td>
<p>Either <code>"jointplot"</code> or <code>"transplot"</code></p>
</td></tr>
<tr><td><code id="Procrustes_+3A_plot.dim">plot.dim</code></td>
<td>
<p>Vector with dimensions to be plotted.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_xlim">xlim</code></td>
<td>
<p>Scale x-axis.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_ylim">ylim</code></td>
<td>
<p>Scale y-axis.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_pch">pch</code></td>
<td>
<p>Plot symbol.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_col.x">col.X</code></td>
<td>
<p>Color target configuration.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_col.y">col.Y</code></td>
<td>
<p>Color testee configuration.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_col.yhat">col.Yhat</code></td>
<td>
<p>Color transformed configuration.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_label.conf">label.conf</code></td>
<td>
<p>List with arguments for plotting the labels of the configurations in a configuration plot (logical value whether to plot labels or not, label position, label color).</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_length">length</code></td>
<td>
<p>length of the edges of the arrow head (in inches).</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_arrows">arrows</code></td>
<td>
<p>For <code>"transplot"</code> only, whether arrows should be plotted or not.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_legend">legend</code></td>
<td>
<p>List with arguments for plotting the legend.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_...">...</code></td>
<td>
<p>Additional plot arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Y</code> is going to be modified by finding an optimal dilation factor, an optimal translation and rotation for <code>Y</code>
such that it is a similar as possible to <code>X</code>. <code>X</code> remains untouched.  
</p>


<h3>Value</h3>

<p>Returns an object of class <code>procr</code> with:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>Input target configuration</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Input testee configuration</p>
</td></tr>
<tr><td><code>Yhat</code></td>
<td>
<p>Procrustes transformed (fitted) configuration</p>
</td></tr>
<tr><td><code>translation</code></td>
<td>
<p>Translation vector</p>
</td></tr>
<tr><td><code>dilation</code></td>
<td>
<p>Dilation factor</p>
</td></tr>
<tr><td><code>rotation</code></td>
<td>
<p>Rotation-reflection matrix</p>
</td></tr>
<tr><td><code>confdistX</code></td>
<td>
<p>Configuration distances X</p>
</td></tr>
<tr><td><code>confdistY</code></td>
<td>
<p>Configuration distances Y</p>
</td></tr>
<tr><td><code>confdistYhat</code></td>
<td>
<p>Configuration distances of fitted configuration</p>
</td></tr>
<tr><td><code>congcoef</code></td>
<td>
<p>Congruence coefficient</p>
</td></tr>
<tr><td><code>aliencoef</code></td>
<td>
<p>Alienation coefficient</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Correlation coefficient between X and Y-hat (shrinkage ratio)</p>
</td></tr>
<tr><td><code>pairdist</code></td>
<td>
<p>Pairwise object distances (sorted)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling and Unfolding (2nd ed.). Springer.
</p>
<p>Mair, P., Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2, Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>
<p>Borg, I. and Mair, P. (2022). A note on Procrustean fittings of noisy configurations. Austrian Journal of Statistics, 51, 1-9. <a href="https://doi.org/10.17713/ajs.v51i4.1423">doi:10.17713/ajs.v51i4.1423</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## artificial example:
X &lt;- matrix(c(1, -1, -1, 1, 2, 2, -2, -2), ncol = 2)
Y &lt;- matrix(c(0.07, 0.93, 1.93, 1.07, 2.62, 3.12, 1.38, 0.88), ncol = 2)
op &lt;- par(mfrow = c(1,2))
plot(X[,1], X[,2], xlim = c(-3, 3), ylim = c(-2, 3.5), asp = 1, xlab = "", ylab = "")
rect(-1, -2, 1, 2)
points(Y[,1], Y[,2], xlim = c(-3, 3), col = "gray")
polygon(Y[,1], Y[,2], border = "gray")
fitp &lt;- Procrustes(X, Y)
plot(fitp$Yhat[,1], fitp$Yhat[,2], col = "red", xlim = c(-3, 3), ylim = c(-2, 3.5), 
     asp = 1, xlab = "", ylab = "")
polygon(fitp$Yhat[,1], fitp$Yhat[,2], border = "red")
par(op)

## MDS example:
eastD &lt;- sim2diss(EW_eng$east)
attr(eastD, "Labels") &lt;- abbreviate(attr(eastD, "Labels"))
fit.east &lt;- mds(eastD, type = "ordinal")
westD &lt;- sim2diss(EW_eng$west)
attr(westD, "Labels") &lt;- abbreviate(attr(westD, "Labels"))
fit.west &lt;- mds(westD, type = "ordinal", init = torgerson(eastD))

fit.proc &lt;- Procrustes(fit.east$conf, fit.west$conf)
fit.proc

## Configuration plots; Procrustes plots.
plot(fit.east, main = "MDS East Germany")   ## MDS plot East Germany
plot(fit.west, main = "MDS West Germany")   ## MDS plot West Germany

## Procrustes configurations (X and Yhat)
plot(fit.proc, ylim = c(-1, 1),  col.X = "cadetblue", col.Yhat = "brown", pch = 19, 
    legend = list(pos = "topleft", labels = c("East Germany", "West Germany"))) 
    
## Procrustes transformations (Y and Yhat)
plot(fit.proc, plot.type = "transplot", length = 0.05, ylim = c(-1,1), 
     legend = list(pos = "bottomright", 
     labels = c("West Germany (untransformed)", "West Germany (transformed)")))
</code></pre>

<hr>
<h2 id='PVQ40'>Portrait Value Questionnaire</h2><span id='topic+PVQ40'></span><span id='topic+PVQ40agg'></span>

<h3>Description</h3>

<p>The PVQ40 (Schwartz et al., 1999) consists of 40 items, each a short portrait of one person. For example, to measure power, the PVQ includes two portraits (male/female versions): It is important to him to be rich. He wants to have a lot of money and expensive things. It is important to him to get respect from others. He wants people to do what he says. Respondents indicate on 6-point bipolar rating scale (1 ... not at all like me, 6 ... very much like me) the degree to which the description also fits himself/herself. Gender and age of the participants are added as attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PVQ40)</code></pre>


<h3>Format</h3>

<p>PVQ40 data of 151 adults from various states in the USA:
</p>
<p>sd1-sd4: self-direction
</p>
<p>po1-po3: power
</p>
<p>un1-un6: universalism
</p>
<p>ac1-ac4: achievement
</p>
<p>se1-se5: security
</p>
<p>st1-st3: stimulation
</p>
<p>co1-co4: conformity
</p>
<p>tr1-tr4: tradition
</p>
<p>he1-he3: hedonism
</p>
<p>be1-be4: benevolence
</p>
<p>Age and Gender are added as attributes.
</p>


<h3>Details</h3>

<p><code>PVQ40agg</code> is an aggregated version of <code>PVQ40</code> where the item scores belonging to the same value are averaged. Abbreviations: power (PO), achievement (AC), hedonism (HE), stimulation (ST), self-direction (SD), universalism (UN), benevolence (BE), tradition (TR), conformity (CO), security (SE). 
</p>


<h3>References</h3>

<p>Borg, I., Bardi, A., &amp; Schwartz, S. H. (2017). Does the value circle exist within persons or only across persons? Journal of Personality, 85(2), 151-162. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indvalues">indvalues</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>str(PVQ40)
head(PVQ40)
attr(PVQ40, "Gender")
attr(PVQ40, "Age")
str(PVQ40agg)
</code></pre>

<hr>
<h2 id='randomstress'>Stress Calculation for Random Dissimilarities</h2><span id='topic+randomstress'></span>

<h3>Description</h3>

<p>Creates random dissimilarity matrices (n objects), fits an MDS, and returns the stress values 
of each MDS fit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomstress(n, ndim, nrep = 100, type = c("ratio", "interval", "ordinal", "mspline"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomstress_+3A_n">n</code></td>
<td>
<p>Number of objects</p>
</td></tr>
<tr><td><code id="randomstress_+3A_ndim">ndim</code></td>
<td>
<p>Number of dimensions for MDS</p>
</td></tr>
<tr><td><code id="randomstress_+3A_nrep">nrep</code></td>
<td>
<p>Number of random samples</p>
</td></tr>
<tr><td><code id="randomstress_+3A_type">type</code></td>
<td>
<p>MDS type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random dissimilarities are drawn from a U(0,1) distribution.
</p>


<h3>Value</h3>

   
<p>Returns a vector with stress values.
</p>


<h3>References</h3>

<p>Spence I., Ogilvie, J.C. (1973). A table of expected stress values for random rankings in
nonmetric multidimensional scaling. Multivariate Behavioral Research, 8, 511-517.
</p>
<p>Mair, P., Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2. 
Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 8 objects, 2 dimensions, interval MDS (50 replications)
stressvec &lt;- randomstress(n = 8, ndim = 2, nrep = 50, type = "interval")
mean(stressvec)
</code></pre>

<hr>
<h2 id='rectangles'>Rectangles</h2><span id='topic+rectangles'></span><span id='topic+rectangles2'></span><span id='topic+rect_constr'></span>

<h3>Description</h3>

<p>These data are based on an experiment by Borg and Leutner (1983). They constructed rectangles on the basis of the grid design (see <code>rect_constr</code>). Each point in this grid defines a rectangle. Rectangle 16, for example, had a width of 4.25 cm and a height of 1.25 cm; rectangle 4 was 3.00 cm wide and 2.75 cm tall. A total of 21 persons rated (twice) the similarity of each pair of these 16 rectangles (on a 10-point scale ranging from from 0 = equal/identical to 9 = very different) The means of these ratings over persons and replications are given in <code>rectangles</code>. A second dataset (<code>rectangles2</code>) is constructed based on area and shape of the rectangles. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rectangles)
data(rect_constr)
data(rectangles2)
</code></pre>


<h3>Format</h3>

<p>The rectangles are object of class <code>dist</code>, the constraints are given as matrix
</p>


<h3>References</h3>

<p>Borg, I., &amp; Leutner, D. (1983). Dimensional models for the perception of rectangles. Perception and Psychophysics, 34, 257-269.
</p>
<p>Borg, I., Groenen, P. J. F., &amp; Mair, P. (2017). Applied Multidimensional Scaling and Unfolding. New York, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rectangles
rect_constr
rectangles2
</code></pre>

<hr>
<h2 id='residuals.smacof'>Residuals</h2><span id='topic+residuals.smacof'></span><span id='topic+residuals.smacofR'></span><span id='topic+residuals.smacofID'></span>

<h3>Description</h3>

<p>Computes the residuals by subtracting the configuration dissimilarites from the observed dissimilarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacof'
residuals(object, ...)
## S3 method for class 'smacofR'
residuals(object, ...)
## S3 method for class 'smacofID'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.smacof_+3A_object">object</code></td>
<td>
<p>Object of class <code>smacof</code>, <code>smacofR</code> (rectangular), or <code>smacofID</code> (individual differences)</p>
</td></tr>
<tr><td><code id="residuals.smacof_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- mds(kinshipdelta)
residuals(res)

</code></pre>

<hr>
<h2 id='RockHard'>RockHard Ratings</h2><span id='topic+RockHard'></span>

<h3>Description</h3>

<p>Data from RockHard Magazine: In this German Heavy Metal Magazine around 50 records are rated by the writers
on a scale from (0 ... worst to 10 ... best) each month. The dataset contains all ratings from 2013. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RockHard)</code></pre>


<h3>Format</h3>

<p>Data frame with raters in the colums, bands/albums in the rows. 
</p>


<h3>References</h3>

<p>Mair, P., de Leeuw, J., &amp; Wurzer, M. (2015). Multidimensional Unfolding. Wiley StatsRef: Statistics Reference Online. 
New York: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(RockHard)
</code></pre>

<hr>
<h2 id='sim2diss'>Converts similarites to dissimilarities</h2><span id='topic+sim2diss'></span>

<h3>Description</h3>

<p>Utility function for converting similarities into dissimilarities. Different methods are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim2diss(s, method = "corr", to.dist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim2diss_+3A_s">s</code></td>
<td>
<p>Similarity matrix (not necessarily symmetric, nor square)</p>
</td></tr>
<tr><td><code id="sim2diss_+3A_method">method</code></td>
<td>
<p>Various methods for converting similarities into dissimilarities: <code>"corr"</code>, <code>"reverse"</code>, <code>"reciprocal"</code>, <code>"ranks"</code>, <code>"exp"</code>, <code>"Gaussian"</code>, <code>"cooccurrence"</code>, <code>"gravity"</code>, <code>"confusion"</code>, <code>"transition"</code>, <code>"membership"</code>, <code>"probability"</code>, or an integer value from which the similarity is subtracted</p>
</td></tr> 
<tr><td><code id="sim2diss_+3A_to.dist">to.dist</code></td>
<td>
<p>If <code>TRUE</code>, object of class dist is produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversion formulas for the various methods can be found in the package vignette. 
</p>


<h3>Value</h3>

<p>Returns dissimiarities either as matrix or as dist object.
</p>


<h3>References</h3>

<p>Mair, P., Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2. 
Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Convert crimes data (correlations)
data(crimes)
crimeD &lt;- sim2diss(crimes, method = "corr", to.dist = TRUE)

## Convert Wish data (similarities) by subtracting from 7
data(wish)
wishD &lt;- sim2diss(wish, method = 7, to.dist = TRUE)

## Convert Ekman data (similarities) into dissimilarities
data(ekman)
ekmanD &lt;- sim2diss(ekman, method = "confusion", to.dist = TRUE)

## Convert album ratings (rectangular similarities) by reversing the ratings
data(RockHard)
rockD1 &lt;- sim2diss(RockHard[,5:18], method = "reverse")
</code></pre>

<hr>
<h2 id='smacofConstraint'>SMACOF Constraint</h2><span id='topic+smacofConstraint'></span>

<h3>Description</h3>

<p>SMACOF with internal constraints on the configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smacofConstraint(delta, constraint = "unrestricted", external, ndim = 2, 
                 type = c("ratio", "interval", "ordinal", "mspline"), weightmat = NULL,
                 init = NULL, ties = "primary", verbose = FALSE, modulus = 1, 
                 itmax = 1000, eps = 1e-6, spline.intKnots = 4, spline.degree = 2, 
                 constraint.type = c("ratio", "interval", "ordinal", "spline", 
                 "mspline"), constraint.ties = "primary", 
                 constraint.spline.intKnots = 2, constraint.spline.degree = 2)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smacofConstraint_+3A_delta">delta</code></td>
<td>
<p>Either a symmetric dissimilarity matrix or an object of class <code>"dist"</code></p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_constraint">constraint</code></td>
<td>
<p>Type of constraint: <code>"unrestricted"</code>, <code>"unique"</code>, <code>"diagonal"</code>, or a user-specified function (see details)</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_external">external</code></td>
<td>
<p>Data frame or matrix with external covariates, or list for simplex and circumplex (see details)</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_ndim">ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_type">type</code></td>
<td>
<p>MDS type: <code>"interval"</code>, <code>"ratio"</code>, <code>"ordinal"</code> (nonmetric MDS), or <code>"mspline"</code></p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_weightmat">weightmat</code></td>
<td>
<p>Optional matrix with dissimilarity weights</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_init">init</code></td>
<td>
<p>Optional matrix with starting values for configurations. If <code>NULL</code> random starts are used (see details).</p>
</td></tr> 
<tr><td><code id="smacofConstraint_+3A_ties">ties</code></td>
<td>
<p>Tie specification for non-metric MDS only: <code>"primary"</code>, <code>"secondary"</code>, or <code>"tertiary"</code></p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate stress is printed out</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_modulus">modulus</code></td>
<td>
<p>Number of smacof iterations per monotone regression call</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_spline.degree">spline.degree</code></td>
<td>
<p>Degree of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_spline.intknots">spline.intKnots</code></td>
<td>
<p>Number of interior knots of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_constraint.type">constraint.type</code></td>
<td>
<p>Transformation for <code>external</code> covariates: <code>"ratio"</code>,
<code>"interval"</code>, <code>"ordinal"</code>, <code>"spline"</code>, or         
<code>"mspline"</code>)</p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_constraint.ties">constraint.ties</code></td>
<td>
<p>Tie specification for <code>external</code> covariates with 
<code>constraint.type = "ordinal"</code>: <code>"primary"</code>, 
<code>"secondary"</code>, or <code>"tertiary"</code></p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_constraint.spline.intknots">constraint.spline.intKnots</code></td>
<td>
<p>Number of interior knots for <code>external</code> covariates
with <code>constraint.type = "spline"</code> or <code>"mspline"</code></p>
</td></tr>
<tr><td><code id="smacofConstraint_+3A_constraint.spline.degree">constraint.spline.degree</code></td>
<td>
<p>Degree of the spline for <code>external</code> covariates
with <code>constraint.type = "spline"</code> or <code>"mspline"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>external</code> is mandatory to specify and requires a data frame (or matrix) of dimension (n x q). Alternatively, for simplex fitting the user can specify a list of the following structure: <code>external = list("simplex", dim2)</code> with <code>dim2</code> denoting the dimension of the simplex with dim2 &lt; n. For a circumplex fitting, the list has to be of the following form: <code>external = list("circumplex", dim2, k1, k2)</code> with <code class="reqn">1 \leq k1 \leq k2 \leq n</code> (see also examples section). k1 and k2 denote the circumplex width.
</p>
<p>In constraint smacof, the configuration matrix <code class="reqn">X</code> is subject to a constraint based on the external scales (predictors <code class="reqn">Z</code> specified using <code>external</code>) of the following linear form: <code class="reqn">X = ZC</code>. The type of constraint in <code class="reqn">C</code> can be specified using the <code>constraint</code> argument. We provide the following standard setting: 
</p>
<p>For <code>constraint = "unrestricted"</code>, <code class="reqn">C</code> is unrestricted. Note that <code>"linear"</code> still works as well for backward compatibility.  
</p>
<p>The same for <code>constraint = "diagonal"</code> where <code class="reqn">X</code> needs to be of dimension <code class="reqn">(n x q)</code> where <code class="reqn">q</code> is the number of columns of the external scale matrix (and thus number of dimensions). Here, <code class="reqn">C</code> is restricted to be diagonal. 
</p>
<p>For <code>constraint = "unrestricted"</code> or <code>"diagonal"</code>, the external covariates <code class="reqn">Z</code> can be optimally transformed as specified by <code>constraint.type</code>. Choosing the number of covariates equal to the number of dimensions together with <code>constraint.type = "ordinal"</code>, <code>constraint.ties = "primary"</code> will effectively restrict the configuration to parallel regions defined by the categories of the covariates. Note that missing values of the covariates are estimated by the model.
</p>
<p>For <code>constraint = "unique"</code> we get the Bentler-Weeks uniqueness model. Hence <code class="reqn">X</code> is of dimension <code class="reqn">(n x (n + p))</code>. This implies that we fit a certain number of dimensions p and, in addition we extract n additional dimensions where each object is scored on a separate dimension. More technical details can be found in the corresponding JSS article (reference see below).
</p>
<p>In addition, the user can specify his own constraint function with the following arguments: configuration matrix with starting values (<code>init</code>) (mandatory in this case), matrix <code class="reqn">V</code> (<code>weightmat</code>; based on the weight matrix, see package vignette), external scale matrix (<code>external</code>). The function must return a matrix of resulting configurations. 
</p>
<p>If no starting configuration is provided, a random starting solution is used. In most applications, this is not a good idea in order to find a well fitting model. The user can fit an exploratory MDS using <code>mds()</code> first, and use the resulting configurations as starting configuration for <code>smacofConstraint()</code>. Alternatively, if the user has starting configurations determined by some underlying theory, they can be used as well. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>Observed dissimilarities</p>
</td></tr>
<tr><td><code>obsdiss</code></td>
<td>
<p>Observed dissimilarities, normalized</p>
</td></tr>
<tr><td><code>confdist</code></td>
<td>
<p>Configuration dissimilarities</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>Matrix of final configurations</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Matrix with restrictions</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>Stress-1 value</p>
</td></tr>
<tr><td><code>spp</code></td>
<td>
<p>Stress per point</p>
</td></tr>
<tr><td><code>resmat</code></td>
<td>
<p>Matrix with squared residuals</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>Residual sum-of-squares</p>
</td></tr>
<tr><td><code>weightmat</code></td>
<td>
<p>Weight matrix</p>
</td></tr>
<tr><td><code>ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code>extvars</code></td>
<td>
<p>List for each external covariate with a list of class <code>"optscal"</code></p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>Starting configuration</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Type of smacof model</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>nobj</code></td>
<td>
<p>Number of objects</p>
</td></tr>
</table>


<h3>References</h3>

<p>De Leeuw, J. &amp; Mair, P. (2009). Multidimensional scaling using majorization: The R package smacof. Journal of Statistical Software, 31(3), 1-30, <a href="https://doi.org/10.18637/jss.v031.i03">doi:10.18637/jss.v031.i03</a>
</p>
<p>Mair, P., Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2. 
Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>
<p>De Leeuw, J., &amp; Heiser, W. (1980). Multidimensional scaling with restrictions on the configurations. In P. R. Krishnaiah (eds.), Multivariate Analysis V, pp. 501-522. North-Holland. 
</p>
<p>Borg, I., &amp; Lingoes, J. C. (1980). A model and algorithm for multidimensional scaling with external constraints on the distances. Psychometrika, 45, 25-38.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smacofSym">smacofSym</a></code>, <code><a href="#topic+smacofRect">smacofRect</a></code>, <code><a href="#topic+smacofIndDiff">smacofIndDiff</a></code>, <code><a href="#topic+smacofSphere">smacofSphere</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

## theoretical grid restrictions (rectangles; keep covariate ties tied)
fit.rect1 &lt;- mds(rectangles, type = "ordinal", init = rect_constr) 
fit.rect2 &lt;- smacofConstraint(rectangles, type = "ordinal", ties = "secondary",
                        constraint = "diagonal", init = fit.rect1$conf, 
                        external = rect_constr, constraint.type = "ordinal")
plot(fit.rect2)

## regional restrictions morse code data (signal length, strength)
fitMorse1 &lt;- mds(morse, type = "ordinal")
fitMorse1
fitMorse2 &lt;- smacofConstraint(morse, type = "ordinal", constraint = "unrestricted",
                              external = morsescales[,2:3], 
                              constraint.type = "ordinal", 
                              init = fitMorse1$conf)
fitMorse2
plot(fitMorse2)

## facial expression data I (axial restriction, C diagonal)
Delta &lt;- FaceExp
attr(Delta, "Labels") &lt;- NULL            
fitFace &lt;- mds(Delta, type = "ordinal")   ## starting solution
Z &lt;- FaceScale[, c(1,3)]                  ## external variables
fitFaceC1 &lt;- smacofConstraint(Delta, type = "ordinal", 
  constraint = "diagonal", external = Z, constraint.type = "ordinal", 
  init = fitFace$conf)
fitFaceC1$C 
plot(fitFaceC1, xlab = "Pleasant-Unpleasant", ylab = "Tension-Sleep", 
  main = "Face Expression (Diagonal Restriction)")

## facial expression data II (C unrestricted)
fitFaceC3 &lt;- smacofConstraint(Delta, type = "ordinal", 
  constraint = "unrestricted", external = Z, constraint.type = "ordinal", 
  init = fitFace$conf)
fitFaceC3$C   
plot(fitFaceC3, main = "Face Expression (C Unrestricted, Ordinal Transformation)")
</code></pre>

<hr>
<h2 id='smacofIndDiff'>SMACOF for Individual Differences</h2><span id='topic+smacofIndDiff'></span><span id='topic+indscal'></span><span id='topic+idioscal'></span>

<h3>Description</h3>

<p>Performs smacof for individual differences also known as Three-Way smacof on a list of dissimilarity matrices. Various restrictions decompositions and restrictions on the weight matrix are provided. The most prominent models are 
INDSCAL and IDIOSCAL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smacofIndDiff(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"), 
              constraint = c("indscal", "idioscal", "identity"),
              weightmat = NULL, init = "torgerson", ties = "primary",  
              verbose = FALSE, modulus = 1, itmax = 1000, eps = 1e-6,
              spline.degree = 2, spline.intKnots = 2)
              
indscal(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"), 
        weightmat = NULL, init = "torgerson", ties = "primary", 
        verbose = FALSE, modulus = 1, itmax = 1000, eps = 1e-6,
        spline.degree = 2, spline.intKnots = 2)

idioscal(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"), 
         weightmat = NULL, init = "torgerson", ties = "primary", 
         verbose = FALSE, modulus = 1, itmax = 1000, eps = 1e-6,
         spline.degree = 2, spline.intKnots = 2)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smacofIndDiff_+3A_delta">delta</code></td>
<td>
<p>A list of dissimilarity matrices or a list objects of class <code>dist</code></p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_ndim">ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_type">type</code></td>
<td>
<p>MDS type: <code>"interval"</code>, <code>"ratio"</code>, <code>"ordinal"</code> (nonmetric MDS), or <code>"mspline"</code></p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_weightmat">weightmat</code></td>
<td>
<p>Optional matrix with dissimilarity weights</p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_init">init</code></td>
<td>
<p>Matrix with starting values for configurations (optional)</p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_ties">ties</code></td>
<td>
<p>Tie specification for non-metric MDS</p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_constraint">constraint</code></td>
<td>
<p>Either <code>"indscal"</code>, <code>"idioscal"</code>, or <code>"identity"</code> (see details)</p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate stress is printed out</p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_modulus">modulus</code></td>
<td>
<p>Number of smacof iterations per monotone regression call</p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_spline.degree">spline.degree</code></td>
<td>
<p>Degree of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
<tr><td><code id="smacofIndDiff_+3A_spline.intknots">spline.intKnots</code></td>
<td>
<p>Number of interior knots of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the constraint is <code>"indscal"</code>, INDSCAL is performed with configuration weight matrices restricted to be diagonal. <code>indscal()</code> is a corresponding wrapper function that can be used instead of <code>smacofIndDiff()</code> with 
<code>"indscal"</code> constraints.
</p>
<p>IDIOSCAL can be computed using the <code>"idioscal"</code> argument. The weight matrices are then unconstrained. 
<code>idioscal()</code> is a corresponding wrapper function that can be used instead of <code>smacofIndDiff()</code> with 
<code>"idioscal"</code> constraints.
</p>
<p>Addtional weight restrictions can be imposed with <code>"identity"</code> which restricts the configurations across individuals/replications/ways to be equal. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>Observed dissimilarities</p>
</td></tr>
<tr><td><code>obsdiss</code></td>
<td>
<p>List of observed dissimilarities, normalized</p>
</td></tr>
<tr><td><code>confdist</code></td>
<td>
<p>List of configuration dissimilarities</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>List of matrices of final configurations</p>
</td></tr>
<tr><td><code>gspace</code></td>
<td>
<p>Joint configuration aka group stimulus space</p>
</td></tr>
<tr><td><code>cweights</code></td>
<td>
<p>Individual weights</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>Stress-1 value</p>
</td></tr>
<tr><td><code>resmat</code></td>
<td>
<p>Matrix with squared residuals</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>Residual sum-of-squares</p>
</td></tr>
<tr><td><code>spp</code></td>
<td>
<p>Stress per point (in percent)</p>
</td></tr>
<tr><td><code>spps</code></td>
<td>
<p>Stress per point per subject (in percent, conditional on subject)</p>
</td></tr>
<tr><td><code>sps</code></td>
<td>
<p>Stress per subject (in percent)</p>
</td></tr>
<tr><td><code>ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Type of smacof model</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>nobj</code></td>
<td>
<p>Number of objects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan de Leeuw and Patrick Mair</p>


<h3>References</h3>

<p>De Leeuw, J., &amp; Mair, P. (2009). Multidimensional scaling using majorization: 
The R package smacof. Journal of Statistical Software, 31(3), 1-30, <a href="https://doi.org/10.18637/jss.v031.i03">doi:10.18637/jss.v031.i03</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smacofConstraint">smacofConstraint</a></code>, <code><a href="#topic+smacofSym">smacofSym</a></code>, <code><a href="#topic+smacofRect">smacofRect</a></code>, <code><a href="#topic+smacofSphere">smacofSphere</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: rectangle perception data
res.diag &lt;- indscal(perception, type = "ordinal")        ## INDSCAL
res.diag$cweights
plot(res.diag)
plot(res.diag, type = "p", pch = 25, col = 4, label.conf = list(label = TRUE, pos = 3, col = 4))

res.idio &lt;- idioscal(perception, type = "ordinal")  ## IDIOSCAL
Wk &lt;- res.idio$cweights
G &lt;- res.idio$gspace
G
G

## identity restricted weights
res.id &lt;- smacofIndDiff(perception, type = "ordinal", constraint = "identity")     
summary(res.id)
res.id$cweights
plot(res.id)
plot(res.id, type = "p", pch = 25, col = 4, label.conf = list(label = TRUE, pos = 3, col = 4))


## Example 2: Helm's color data 
res.helm &lt;- indscal(helm, type = "interval")
plot(res.helm, plot.type = "confplot")
barplot(sort(res.helm$sps, decreasing = TRUE), main = "Stress per Subject", cex.names = 0.8) 
plot(res.helm, plot.type = "bubbleplot")
plot(res.helm, plot.type = "stressplot")
plot(res.helm, plot.type = "Shepard")

## idioscal and indscal with random starting configuration:
set.seed(123)
startconf &lt;- matrix(rnorm(20), 10, 2)
idioscal(helm, init = startconf, type = "interval")
indscal(helm, init = startconf, type = "interval")

</code></pre>

<hr>
<h2 id='smacofSphere'>Spherical SMACOF</h2><span id='topic+smacofSphere'></span>

<h3>Description</h3>

<p>Dual and primal approach for spherical SMACOF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smacofSphere(delta, ndim = 2, type = c("ratio", "interval", "ordinal","mspline"), 
             algorithm = c("dual", "primal"), weightmat = NULL, 
             init = "torgerson", ties = "primary", verbose = FALSE, penalty = 100, 
             relax = FALSE, modulus = 1, itmax = 1000, eps = 1e-6,
             spline.degree = 2, spline.intKnots = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smacofSphere_+3A_delta">delta</code></td>
<td>
<p>Either a symmetric dissimilarity matrix or an object of class <code>dist</code></p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_ndim">ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_type">type</code></td>
<td>
<p>MDS type: <code>"interval"</code>, <code>"ratio"</code>, or <code>"ordinal"</code> (nonmetric MDS)</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm type (see details)</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_weightmat">weightmat</code></td>
<td>
<p>Optional matrix with dissimilarity weights</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_init">init</code></td>
<td>
<p>Either <code>"torgerson"</code> (classical scaling starting solution), <code>"random"</code> (random configuration), or a user-defined matrix</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_ties">ties</code></td>
<td>
<p>Tie specification for non-metric MDS only</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate stress is printed out</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_penalty">penalty</code></td>
<td>
<p>Penalty parameter for dual algorithm (larger 0), see details</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_relax">relax</code></td>
<td>
<p>If <code>TRUE</code>, block relaxation is used for majorization (dual algorithm)</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_modulus">modulus</code></td>
<td>
<p>Number of smacof iterations per monotone regression call</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_spline.degree">spline.degree</code></td>
<td>
<p>Degree of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
<tr><td><code id="smacofSphere_+3A_spline.intknots">spline.intKnots</code></td>
<td>
<p>Number of interior knots of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For large scale problems it is suggested to use the dual algorithm. Using the penalty parameter (dual algorithm), the user allow for slight point deviations from the circle (the higher the penalty, the stricter the algorithm is in terms of placing points in the sphere, see examples section below).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>Observed dissimilarities</p>
</td></tr>
<tr><td><code>obsdiss</code></td>
<td>
<p>Observed dissimilarities, normalized</p>
</td></tr>
<tr><td><code>obsdiss1</code></td>
<td>
<p>Dual SMACOF: Observed dissimilarities</p>
</td></tr>
<tr><td><code>obsdiss2</code></td>
<td>
<p>Dual SMACOF: Restriction matrix</p>
</td></tr>
<tr><td><code>confdist</code></td>
<td>
<p>Configuration dissimilarities</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>Matrix with fitted configurations</p>
</td></tr>
<tr><td><code>spp</code></td>
<td>
<p>Stress per point</p>
</td></tr>
<tr><td><code>resmat</code></td>
<td>
<p>Matrix with squared residuals</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>Residual sum-of-squares</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>Stress-1 value</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>Starting configurations</p>
</td></tr>
<tr><td><code>ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code>dummyvec</code></td>
<td>
<p>Dummy vector of restriction matrix</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Type of smacof model</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>nobj</code></td>
<td>
<p>Number of objects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan de Leeuw and Patrick Mair</p>


<h3>References</h3>

<p>De Leeuw, J. &amp; Mair, P. (2009). Multidimensional scaling using majorization: 
The R package smacof. Journal of Statistical Software, 31(3), 1-30, <a href="https://doi.org/10.18637/jss.v031.i03">doi:10.18637/jss.v031.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smacofRect">smacofRect</a></code>, <code><a href="#topic+smacofIndDiff">smacofIndDiff</a></code>, <code><a href="#topic+smacofSym">smacofSym</a></code>,<code><a href="#topic+smacofConstraint">smacofConstraint</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## spherical SMACOF solution for trading data
## dual algorithm
res &lt;- smacofSphere(trading, type = "ordinal")  
res
plot(res)

## lower penalty
res &lt;- smacofSphere(trading, penalty = 20, type = "ordinal")  
res
plot(res)

## primal algorithm, interval
res &lt;- smacofSphere(trading, type = "interval", algorithm = "primal")  
res
</code></pre>

<hr>
<h2 id='smacofSym'>Symmetric smacof</h2><span id='topic+smacofSym'></span><span id='topic+mds'></span>

<h3>Description</h3>

<p>Multidimensional scaling on a symmetric dissimilarity matrix using SMACOF. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smacofSym(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"), 
          weightmat = NULL, init = "torgerson", ties = "primary", principal = FALSE, 
          verbose = FALSE, relax = FALSE, modulus = 1, itmax = 1000, eps = 1e-06, 
          spline.degree = 2, spline.intKnots = 2)

mds(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"), 
    weightmat = NULL, init = "torgerson", ties = "primary", principal = FALSE, 
    verbose = FALSE, relax = FALSE, modulus = 1, itmax = 1000, eps = 1e-06, 
    spline.degree = 2, spline.intKnots = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smacofSym_+3A_delta">delta</code></td>
<td>
<p>Either a symmetric dissimilarity matrix or an object of class <code>"dist"</code></p>
</td></tr>
<tr><td><code id="smacofSym_+3A_ndim">ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="smacofSym_+3A_weightmat">weightmat</code></td>
<td>
<p>Optional matrix with dissimilarity weights</p>
</td></tr>
<tr><td><code id="smacofSym_+3A_init">init</code></td>
<td>
<p>Either <code>"torgerson"</code> (classical scaling starting solution), <code>"random"</code> (random configuration), or a user-defined matrix</p>
</td></tr>
<tr><td><code id="smacofSym_+3A_type">type</code></td>
<td>
<p>MDS type: <code>"interval"</code>, <code>"ratio"</code>, <code>"ordinal"</code> (nonmetric MDS), or <code>"mspline"</code></p>
</td></tr>
<tr><td><code id="smacofSym_+3A_ties">ties</code></td>
<td>
<p>Tie specification (ordinal MDS only): <code>"primary"</code>, <code>"secondary"</code>, or <code>"tertiary"</code></p>
</td></tr>
<tr><td><code id="smacofSym_+3A_principal">principal</code></td>
<td>
<p>If <code>TRUE</code>, principal axis transformation is applied to the final configuration</p>
</td></tr>
<tr><td><code id="smacofSym_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate stress is printed out</p>
</td></tr>
<tr><td><code id="smacofSym_+3A_relax">relax</code></td>
<td>
<p>If <code>TRUE</code>, block relaxation is used for majorization</p>
</td></tr>
<tr><td><code id="smacofSym_+3A_modulus">modulus</code></td>
<td>
<p>Number of smacof iterations per monotone regression call</p>
</td></tr>
<tr><td><code id="smacofSym_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="smacofSym_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="smacofSym_+3A_spline.degree">spline.degree</code></td>
<td>
<p>Degree of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
<tr><td><code id="smacofSym_+3A_spline.intknots">spline.intKnots</code></td>
<td>
<p>Number of interior knots of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mds()</code> is a wrapper function and can be used instead of <code>smacofSym()</code>. It reports the Stress-1 value (normalized). The main output are the coordinates in the low-dimensional space (configuration; <code>conf</code>; see also <code><a href="#topic+plot.smacof">plot.smacof</a></code>). 
</p>
<p>Four types of MDS can be fitted: ratio MDS (no dissimilarity transformation), interval MDS (linear transformation), ordinal MDS (ordinal transformation with various options for handling ties), and spline MDS (monotone spline transformation). Shepard plots in <code><a href="#topic+plot.smacof">plot.smacof</a></code> give insight into this transformation.
</p>
<p>Setting <code>principal = TRUE</code> is useful for interpretatbility of the dimensions, or to check hypotheses about the dimensions.
</p>
<p>In case of missing input dissimilarities, the <code>weightmat</code> is computed internally so that missings are blanked out during optimization. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>Observed dissimilarities, not normalized</p>
</td></tr>
<tr><td><code>dhat</code></td>
<td>
<p>Disparities (transformed proximities, approximated distances, d-hats)</p>
</td></tr>
<tr><td><code>confdist</code></td>
<td>
<p>Configuration distances</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>Matrix of fitted configurations</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>Stress-1 value</p>
</td></tr>
<tr><td><code>spp</code></td>
<td>
<p>Stress per point (stress contribution of each point on a percentage scale)</p>
</td></tr>
<tr><td><code>resmat</code></td>
<td>
<p>Matrix with squared residuals</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>Residual sum-of-squares</p>
</td></tr>
<tr><td><code>weightmat</code></td>
<td>
<p>Weight matrix</p>
</td></tr>
<tr><td><code>ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>Starting configuration</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Name of smacof model</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>nobj</code></td>
<td>
<p>Number of objects</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of MDS model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan de Leeuw, Patrick Mair, and Patrick Groenen</p>


<h3>References</h3>

<p>De Leeuw, J. &amp; Mair, P. (2009). Multidimensional scaling using majorization: 
The R package smacof. Journal of Statistical Software, 31(3), 1-30, <a href="https://doi.org/10.18637/jss.v031.i03">doi:10.18637/jss.v031.i03</a> 
</p>
<p>Mair, P, Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2. Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>
<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.). Springer.
</p>
<p>Borg, I., Groenen, P. J. F., &amp; Mair, P. (2018). Applied Multidimensional Scaling and Unfolding (2nd ed.). Springer. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smacofConstraint">smacofConstraint</a></code>, <code><a href="#topic+smacofRect">smacofRect</a></code>, <code><a href="#topic+smacofIndDiff">smacofIndDiff</a></code>, <code><a href="#topic+smacofSphere">smacofSphere</a></code>, <code><a href="#topic+plot.smacof">plot.smacof</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simple SMACOF solution (interval MDS) for kinship data
res &lt;- mds(kinshipdelta, type = "interval")
res
summary(res)
plot(res)
plot(res, type = "p", label.conf = list(label = TRUE, col = "darkgray"), pch = 25, col = "red")

## ratio MDS, random starts
set.seed(123)
res &lt;- mds(kinshipdelta, init = "random")
res

## 3D ordinal SMACOF solution for trading data (secondary approach to ties)
data(trading)
res &lt;- mds(trading, ndim = 3, type = "ordinal", ties = "secondary")
res

## spline MDS 
delta &lt;- sim2diss(cor(PVQ40agg))
res &lt;- mds(delta, type = "mspline", spline.degree = 3, spline.intKnots = 4)
res
plot(res, "Shepard")
</code></pre>

<hr>
<h2 id='stardist'>Distances among stars in zodiac signs</h2><span id='topic+stardist'></span>

<h3>Description</h3>

<p>A distance matrix for the 10 brightest stars in each of the 12 zodiac signs was computed. Astronomers measure the projected positions of objects on the celestial sphere in two angles, i.e. right ascension <code class="reqn">\alpha</code> and declination <code class="reqn">\delta</code>. For every zodiac sign, the projected distances on the sky between individual stars <code class="reqn">S_{i}</code> and <code class="reqn">S_{j}</code> have been calculated in decimal degrees by means of the Pythagorean theorem
</p>
<p style="text-align: center;"><code class="reqn">d_{i,j} = \sqrt {\left( {\alpha _i - \alpha _j } \right)2 + \left( {\delta _i - \delta _j } \right)2 }</code>
</p>
<p> assuming planar geometry. Since the zodiac signs are relatively small compared to the whole celestial sphere and the computation is only done for illustrative purposes, such a simplified assumption is appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stardist)</code></pre>


<h3>Format</h3>

<p>A dist object contaning the star distances.
</p>


<h3>Note</h3>

<p>Thanks to Paul Eigenthaler, Department of Astronomy, University of Vienna for calculating the distances.</p>


<h3>Examples</h3>

<pre><code class='language-R'>stardist

</code></pre>

<hr>
<h2 id='stress0'>Zero-Iterations Stress</h2><span id='topic+stress0'></span>

<h3>Description</h3>

<p>Computes the stress for 0 iterations based on a starting configuration provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stress0(delta, init, type = c("interval", "ratio", "ordinal", "mspline"), 
        weightmat = NULL, ties = "primary", spline.degree = 2, spline.intKnots = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stress0_+3A_delta">delta</code></td>
<td>
<p>Either a symmetric dissimilarity matrix or an object of class <code>"dist"</code></p>
</td></tr>
<tr><td><code id="stress0_+3A_init">init</code></td>
<td>
<p>An initial configuration provided by the user</p>
</td></tr>
<tr><td><code id="stress0_+3A_weightmat">weightmat</code></td>
<td>
<p>Optional matrix with dissimilarity weights</p>
</td></tr>
<tr><td><code id="stress0_+3A_type">type</code></td>
<td>
<p>MDS type: <code>"interval"</code>, <code>"ratio"</code>, <code>"ordinal"</code> (nonmetric MDS), or <code>"mspline"</code></p>
</td></tr>
<tr><td><code id="stress0_+3A_ties">ties</code></td>
<td>
<p>Tie specification (ordinal MDS only): <code>"primary"</code>, <code>"secondary"</code>, or <code>"tertiary"</code></p>
</td></tr>
<tr><td><code id="stress0_+3A_spline.degree">spline.degree</code></td>
<td>
<p>Degree of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
<tr><td><code id="stress0_+3A_spline.intknots">spline.intKnots</code></td>
<td>
<p>Number of interior knots of the spline for <code>"mspline"</code> MDS type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes stress-1 for a particular starting configuration the user needs to provide. It can also be helpful if the user wants to force a particular theoretical configuration (as specified in <code>inits</code>) on the data.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>Observed dissimilarities, not normalized</p>
</td></tr>
<tr><td><code>dhat</code></td>
<td>
<p>Disparities (transformed proximities, approximated distances, d-hats)</p>
</td></tr>
<tr><td><code>confdist</code></td>
<td>
<p>Configuration distances</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>Matrix of fitted configurations</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>Stress-1 value</p>
</td></tr>
<tr><td><code>spp</code></td>
<td>
<p>Stress per point (stress contribution in percentages)</p>
</td></tr>
<tr><td><code>resmat</code></td>
<td>
<p>Matrix with squared residuals</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>Residual sum-of-squares</p>
</td></tr>
<tr><td><code>weightmat</code></td>
<td>
<p>Weight matrix</p>
</td></tr>
<tr><td><code>ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>Starting configuration</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Name of smacof model</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>nobj</code></td>
<td>
<p>Number of objects</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of MDS model</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mds">mds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rectangle starting solution
rect_constr
stress0(rectangles, init = rect_constr)

## torgerson starting solution
tstart &lt;- torgerson(rectangles)
stress0(rectangles, init = tstart)
</code></pre>

<hr>
<h2 id='summary.smacofB'>S3 methods for smacof</h2><span id='topic+summary.smacofB'></span><span id='topic+print.smacofB'></span><span id='topic+summary.smacofR'></span><span id='topic+print.smacofR'></span><span id='topic+summary.smacofID'></span><span id='topic+print.smacofID'></span>

<h3>Description</h3>

<p>Print and summary methods for objects of class <code>smacofB</code>, <code>smacofR</code> (rectangular), and <code>smacofID</code> (individual differences).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofB'
summary(object, ...)
## S3 method for class 'smacofB'
print(x, ...)
## S3 method for class 'smacofR'
summary(object, ...)
## S3 method for class 'smacofR'
print(x, ...)
## S3 method for class 'smacofID'
summary(object, ...)
## S3 method for class 'smacofID'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.smacofB_+3A_object">object</code></td>
<td>
<p>Object of class <code>smacofB</code>, <code>smacofR</code>, <code>smacofID</code></p>
</td></tr>
<tr><td><code id="summary.smacofB_+3A_x">x</code></td>
<td>
<p>Object of class <code>smacofB</code>, <code>smacofR</code>, <code>smacofID</code></p>
</td></tr>
<tr><td><code id="summary.smacofB_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(kinshipdelta)
res &lt;- smacofSym(kinshipdelta)
res
summary(res)


</code></pre>

<hr>
<h2 id='svm_mdsplot'>Support Vector Machine MDS</h2><span id='topic+svm_mdsplot'></span>

<h3>Description</h3>

<p>Plots 2D MDS configuration including facets as determined by an SVM. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svm_mdsplot(mds_object, svm_object, class, legend1 = TRUE, legend2 = TRUE, 
            inset = c(-0.2, 0.5), plot.dim = c(1,2), by = 0.01, 
            main, xlab, ylab, xlim, ylim, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svm_mdsplot_+3A_mds_object">mds_object</code></td>
<td>
<p>Object of class <code>"smacofB"</code>, i.e., an MDS solution from <code>smacofSym()</code> or <code>smacofConstraint</code>.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_svm_object">svm_object</code></td>
<td>
<p>Object of class <code>"svm"</code>, i.e., an SVM solution from <code>svm</code> or <code>tune.svm</code></p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_class">class</code></td>
<td>
<p>Vector of class assignments (facets) for each object.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_legend1">legend1</code></td>
<td>
<p>If <code>TRUE</code>, facet legend is added.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_legend2">legend2</code></td>
<td>
<p>If <code>TRUE</code>, class legend is added.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_inset">inset</code></td>
<td>
<p>Inset distance from the margins for both legends as a fraction of the plot region when legend is placed by keyword.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_plot.dim">plot.dim</code></td>
<td>
<p>Vector with dimensions to be plotted.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_by">by</code></td>
<td>
<p>Scaling factor for resolution (the smaller, the higher the resolution).</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_xlim">xlim</code></td>
<td>
<p>Scale x-axis.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_ylim">ylim</code></td>
<td>
<p>Scale y-axis.</p>
</td></tr>
<tr><td><code id="svm_mdsplot_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see <code><a href="graphics.html#topic+image">image</a></code> for detailed information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the SVM implementation of <code>e1071</code> one can determine facets in an MDS configuration based on an SVM fit. This function plots the resulting facets on top of the 2D MDS configuration. Note that this function is work in progress. 
</p>


<h3>References</h3>

<p>Mair, P., Cetron, J. S., and Borg, I. (2022). Using support vector machines for facet partitioning in
multidimensional scaling. Multivariate Behavioral Research. Forthcoming; <a href="https://doi.org/10.1080/00273171.2022.2035207">doi:10.1080/00273171.2022.2035207</a>
</p>


<h3>See Also</h3>

<p><code><a href="e1071.html#topic+svm">svm</a></code>, <code><a href="e1071.html#topic+tune.wrapper">tune.svm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Guttman intelligence data
Delta &lt;- sim2diss(Guttman1965[[1]])
class &lt;- Guttman1965[[2]]

## ordinal MDS fit
mds_gut &lt;- mds(Delta, ndim = 2, type = "ordinal")  
mds_gut
cols &lt;- rainbow_hcl(4)[as.numeric(class)]
plot(mds_gut, col = cols, label.conf = list(col = cols))
legend("bottomright", legend = levels(class), cex = 0.7, col = rainbow_hcl(4), pch = 19)

## radial SVM fit
X &lt;- mds_gut$conf                    ## extract configuration
dat &lt;- data.frame(class = class, X)  ## merge with class vector
costvec &lt;- 2^seq(-4, 4)              ## tuning parameter grid
gamma &lt;- seq(0.01, 0.5, 10)

set.seed(111)
svm_gut &lt;- tune.svm(class ~ D1 + D2, data = dat, kernel = "radial", 
                    cross = 10, cost = costvec)$best.model
svm_gut
preds &lt;- predict(svm_gut, data = dat)  ## predicted classes
table(obs = class, pred = preds)       ## confusion matrix

svm_mdsplot(mds_gut, svm_gut, dat$class, inset = c(-0.3, 0.5))
</code></pre>

<hr>
<h2 id='symdecomp'>Proximity Matrix Decomposition</h2><span id='topic+symdecomp'></span>

<h3>Description</h3>

<p>Additive decomposition of an asymmetric, square proximity matrix into a symmetric matrix and an skew-symmetric matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symdecomp(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symdecomp_+3A_p">P</code></td>
<td>
<p>Square proximity matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the decompositon <code class="reqn">P = M + N</code> (M and N are orthogonal).
</p>


<h3>Value</h3>

<p>Returns the following matrices: 
</p>
<table role = "presentation">
<tr><td><code>M</code></td>
<td>
<p>symmetric component</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>skew-symmetric component</p>
</td></tr>
</table>


<h3>References</h3>

<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.). Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(92,5,4,8,4,84,38,62,6,37,87,17,13,31,17,88), ncol = 4)
symdecomp(P)
</code></pre>

<hr>
<h2 id='torgerson'>Torgerson Scaling</h2><span id='topic+torgerson'></span>

<h3>Description</h3>

<p>Classical MDS aka Torgerson Scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torgerson(delta, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="torgerson_+3A_delta">delta</code></td>
<td>
<p>Dissimilarity matrix</p>
</td></tr>
<tr><td><code id="torgerson_+3A_p">p</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code class="reqn">n \times p</code> matrix of configurations
</p>


<h3>References</h3>

<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.). Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- torgerson(Guerry)
</code></pre>

<hr>
<h2 id='trading'>Trading data</h2><span id='topic+trading'></span>

<h3>Description</h3>

<p>Data from the New Geographical Digest (1986) analyzed in Cox and Cox (2001). For 20 countries their main trading partners were dichotomously scored (1 = trade performed, 0 = trade not performed). 
Based on this dichotomous matrix the dissimilarities were computed using the Jaccard coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(trading)</code></pre>


<h3>Format</h3>

<p>Object of class <code>"dist"</code> with dissimilarities of the following countries:
</p>
<p>Arge: Argentina
</p>
<p>Aust: Australia
</p>
<p>Braz: Brazil
</p>
<p>Cana: Canada
</p>
<p>Chin: China
</p>
<p>Czec: Czechoslovakia 
</p>
<p>Egyp: Egypt
</p>
<p>E.Ge: East Germany
</p>
<p>Fran: France
</p>
<p>Hung: Hungary
</p>
<p>Indi: India
</p>
<p>Ital: Italy
</p>
<p>Japa: Japan
</p>
<p>N.Ze: New Zealand
</p>
<p>Pola: Poland
</p>
<p>Swed: Sweden
</p>
<p>USA
</p>
<p>USSR: Soviet Union
</p>
<p>U.K.: United Kingdom
</p>
<p>W.Ge: West Germany
</p>


<h3>References</h3>

<p>Cox, T.F., Cox, M.A.A. (1991). Multidimensional scaling on a sphere. Communications in Statistics: Theory and Methods, 20, 2943-2953.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trading)

</code></pre>

<hr>
<h2 id='transform'>Internal Dissimilarity Transformation</h2><span id='topic+transform'></span><span id='topic+transPrep'></span>

<h3>Description</h3>

<p>Utility functions for optimal scaling calls (used internally)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transPrep(x, trans = "ordinals", spline.intKnots = 4, spline.degree = 2, missing = "none")
transform(Target, x, w = rep(1,length(x$x)), normq = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_+3A_target">Target</code></td>
<td>
<p>unconstrained vector of target values</p>
</td></tr>
<tr><td><code id="transform_+3A_x">x</code></td>
<td>
<p>object of type optScal</p>
</td></tr>
<tr><td><code id="transform_+3A_w">w</code></td>
<td>
<p>vector non-negative weights</p>
</td></tr>
<tr><td><code id="transform_+3A_normq">normq</code></td>
<td>
<p>sum of squares normalization</p>
</td></tr>
<tr><td><code id="transform_+3A_trans">trans</code></td>
<td>
<p>type of transformation</p>
</td></tr>
<tr><td><code id="transform_+3A_spline.intknots">spline.intKnots</code></td>
<td>
<p>interior spline knots</p>
</td></tr>
<tr><td><code id="transform_+3A_spline.degree">spline.degree</code></td>
<td>
<p>spline degree</p>
</td></tr>
<tr><td><code id="transform_+3A_missing">missing</code></td>
<td>
<p>missing treatment</p>
</td></tr>
</table>

<hr>
<h2 id='unfolding'>Nonmetric unfolding</h2><span id='topic+unfolding'></span><span id='topic+smacofRect'></span><span id='topic+prefscal'></span>

<h3>Description</h3>

<p>Variant of smacof for rectangular matrices (typically ratings, preferences) that allows for nonmetric transformations. Also known as nonmetric unfolding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfolding(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"),
         conditionality = "unconditional", lambda = 0.5, omega = 1, 
         circle = c("none", "row", "column"), weightmat = NULL, init = NULL, 
         fixed = c("none", "row", "column"), fixed.coord = NULL,
         ties = c("primary", "secondary"), verbose = FALSE, relax = TRUE, 
         itmax = 10000, eps = 1e-6, spline.degree = 2, spline.intKnots = 2,
         parallelize = FALSE)

smacofRect(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"),
         conditionality = "unconditional", lambda = 0.5, omega = 1, 
         circle = c("none", "row", "column"), weightmat = NULL, init = NULL, 
         fixed = c("none", "row", "column"), fixed.coord = NULL,
         ties = c("primary", "secondary"), verbose = FALSE, relax = TRUE, 
         itmax = 10000, eps = 1e-6, spline.degree = 2, spline.intKnots = 2,
         parallelize = FALSE)

prefscal(delta, ndim = 2, type = c("ratio", "interval", "ordinal", "mspline"),
         conditionality = "unconditional", lambda = 0.5, omega = 1, 
         circle = c("none", "row", "column"), weightmat = NULL, init = NULL, 
         fixed = c("none", "row", "column"), fixed.coord = NULL,
         ties = c("primary", "secondary"), verbose = FALSE, relax = TRUE, 
         itmax = 10000, eps = 1e-6, spline.degree = 2, spline.intKnots = 2,
         parallelize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unfolding_+3A_delta">delta</code></td>
<td>
<p>Data frame or matrix of preferences, ratings, dissimilarities.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_ndim">ndim</code></td>
<td>
<p>Number of dimensions.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_type">type</code></td>
<td>
<p>MDS type: <code>"interval"</code>, <code>"ratio"</code>, <code>"ordinal"</code>, or <code>"mspline"</code>.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_conditionality">conditionality</code></td>
<td>
<p>A single transformations are applied for the entire matrix <code>"unconditional"</code>, or for each row separately <code>"row"</code>.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_lambda">lambda</code></td>
<td>
<p>Penalty strength balancing the loss contribution of stress and the penalty (see details).</p>
</td></tr>
<tr><td><code id="unfolding_+3A_omega">omega</code></td>
<td>
<p>Penalty width determines for what values of the variation coefficient the penalty should become active (see details).</p>
</td></tr>
<tr><td><code id="unfolding_+3A_circle">circle</code></td>
<td>
<p>If <code>"column"</code>, the column configurations are restricted to be on a circle, if <code>"row"</code>, row configurations are on a circle, if <code>"none"</code>, there are no restrictions on row and column configurations</p>
</td></tr>
<tr><td><code id="unfolding_+3A_weightmat">weightmat</code></td>
<td>
<p>Optional matrix with dissimilarity weights.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_init">init</code></td>
<td>
<p>Optional list of length two with starting values for the row coordinates (first element) and column coordinates (second element).</p>
</td></tr>
<tr><td><code id="unfolding_+3A_fixed">fixed</code></td>
<td>
<p>Do external unfolding by fixing the <code>row</code> coordinates, <code>column</code> coordinate, or choose <code>none</code> (default) to do normal unfolding. Even fixed coordinates are uniformly scaled by a constant to fit the loss function.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_fixed.coord">fixed.coord</code></td>
<td>
<p>Matrix with fixed coordinates of the appropriate size.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_ties">ties</code></td>
<td>
<p>Tie specification for <code>ordinal</code> transformations: <code>primary</code> unties the ties and <code>secondary</code> keeps the ties tied.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate stress is printed out.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_relax">relax</code></td>
<td>
<p>If <code>TRUE</code>, block relaxation is used for majorization after 100 iterations. It tends to reduce the number of iterations by a factor 2.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_spline.degree">spline.degree</code></td>
<td>
<p>Degree of the spline for an <code>"mspline"</code> transformation.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_spline.intknots">spline.intKnots</code></td>
<td>
<p>Number of interior knots of the spline for a <code>"mspline"</code> transformation.</p>
</td></tr>
<tr><td><code id="unfolding_+3A_parallelize">parallelize</code></td>
<td>
<p>Tries to parallelize the computations when <code>conditionality = "row"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unfolding tries to match a rectangular matrix <code>delta</code> of dissimilarities between row and column objects by Euclidean distances between row and column points. Badness of fit is measured by raw Stress as the sum of squared differences between <code>delta</code> and the Euclidean distances. Instead of dissimilarities optimal transformations (dhats) can be found. The dhats should be a function of the original <code>delta</code> restricted to be <code>"ratio"</code>, <code>"interval"</code>, <code>"ordinal"</code>, or <code>"mspline"</code>. These transformations can be the same for the entire matrix (<code>conditionality = "unconditional"</code>) of data, or different per row (<code>conditionality = "row"</code>). To avoid a degenerate solution with all dhats and distances equal to 1, the prefscal penalty is is used. 
</p>
<p>A penalty is added based on the variation coefficient of the dhats (mean dhat divided by the standard deviation of the dhats). The penalty width (<code>omega</code>) weights the penalty and determines from what value of the variation coefficient of the dhats the penalty should become active. The penalty strength (<code>lambda</code>) is needed to ensure that the penalty can be strong enough. Busing et al. (2005) suggest to use <code class="reqn">\lambda = 0.5</code> and <code class="reqn">\omega = 1.0</code> (for unconditional solutions <code class="reqn">\omega</code> can be lowered to a value as low as 0.1). 
</p>
<p>External unfolding can be done by specifying <code>fixed = "row"</code> or <code>"column"</code> and providing the fixed coordinates in <code>fixed.coord</code>. Then, either the rows or columns are fixed up to a uniform constant.
</p>
<p>Creates an object of class <code>smacofR</code>. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>obsdiss</code></td>
<td>
<p>Observed dissimilarities, corresponds to <code>delta</code></p>
</td></tr>
<tr><td><code>confdist</code></td>
<td>
<p>Configuration dissimilarities</p>
</td></tr>
<tr><td><code>dhat</code></td>
<td>
<p>Matrix with optimal transformation of size <code>delta</code></p>
</td></tr>
<tr><td><code>iord</code></td>
<td>
<p>List of size 1 for matrix conditional and size <code>nrow(delta)</code> for row conditional with the index that orders the dhats. Needed for the Shepard plot</p>
</td></tr>
<tr><td><code>conf.row</code></td>
<td>
<p>Matrix of final row configurations</p>
</td></tr>
<tr><td><code>conf.col</code></td>
<td>
<p>Matrix of final column configurations</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>Final, normalized stress value</p>
</td></tr>
<tr><td><code>pstress</code></td>
<td>
<p>Penalized stress value (the criterion that is minimized)</p>
</td></tr>
<tr><td><code>spp.row</code></td>
<td>
<p>Stress per point, rows</p>
</td></tr>
<tr><td><code>spp.col</code></td>
<td>
<p>Stress per point, columns</p>
</td></tr>
<tr><td><code>congvec</code></td>
<td>
<p>Vector of congruency coefficients</p>
</td></tr>
<tr><td><code>ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Type of smacof model</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>nind</code></td>
<td>
<p>Number of individuals (rows)</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>Transformation</p>
</td></tr>
<tr><td><code>conditionality</code></td>
<td>
<p>Conditionality of the transformation</p>
</td></tr>
<tr><td><code>nobj</code></td>
<td>
<p>Number of objects (columns)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick Groenen, Jan de Leeuw and Patrick Mair</p>


<h3>References</h3>

<p>De Leeuw, J. &amp; Mair, P. (2009). Multidimensional scaling using majorization: 
The R package smacof. Journal of Statistical Software, 31(3), 1-30, <a href="https://doi.org/10.18637/jss.v031.i03">doi:10.18637/jss.v031.i03</a> 
</p>
<p>Mair, P., Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2. 
Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>
<p>Busing, F. M. T. A., Groenen, P. J. F., &amp; Heiser, W. J. (2005). Avoiding degeneracy in multidimensional unfolding by penalizing on the coefficient of variation. Psychometrika, 70, 71-98.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.smacof">plot.smacof</a></code>, <code><a href="#topic+smacofConstraint">smacofConstraint</a></code>, <code><a href="#topic+smacofSym">smacofSym</a></code>, <code><a href="#topic+smacofIndDiff">smacofIndDiff</a></code>, <code><a href="#topic+smacofSphere">smacofSphere</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Ratio unfolding
res &lt;- unfolding(breakfast)
res

## various configuration plots
plot(res)
plot(res, type = "p", pch = 25)
plot(res, type = "p", pch = 25, col.columns = 3, 
     label.conf.columns = list(label = TRUE, pos = 3, col = 3), 
     col.rows = 8, label.conf.rows = list(label = TRUE, pos = 3, col = 8))

## Shepard plot
plot(res, "Shepard")

## Stress decomposition chart
plot(res, "stressplot")

## Not run: 
## Ordinal unfolding, row-conditional
## Note that ordinal unfolding may need many iterations (several thousands)
res &lt;- unfolding(breakfast, type = "ordinal", conditionality = "row", omega = 0.1, itmax = 3000)
res
plot(res, "Shepard")      ## Shepard plot
plot(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='uniscale'>Unidimensional Scaling</h2><span id='topic+uniscale'></span><span id='topic+print.uniscale'></span><span id='topic+plot.uniscale'></span>

<h3>Description</h3>

<p>Simple implementation where all dissimilarity permutations are subject to a 1D MDS fit and the one which leads to a minimal stress values is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniscale(delta, weightmat = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniscale_+3A_delta">delta</code></td>
<td>
<p>Either a symmetric dissimilarity matrix or an object of class <code>"dist"</code></p>
</td></tr>
<tr><td><code id="uniscale_+3A_weightmat">weightmat</code></td>
<td>
<p>Optional matrix with dissimilarity weights</p>
</td></tr>
<tr><td><code id="uniscale_+3A_verbose">verbose</code></td>
<td>
<p>Permutation printout</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>Observed dissimilarities, not normalized</p>
</td></tr>
<tr><td><code>confdist</code></td>
<td>
<p>Configuration distances</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>Vector with fitted configurations</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>Stress-1 value</p>
</td></tr>
<tr><td><code>weightmat</code></td>
<td>
<p>Weight matrix</p>
</td></tr>
<tr><td><code>nobj</code></td>
<td>
<p>Number of objects</p>
</td></tr>
<tr><td><code>npermtot</code></td>
<td>
<p>Total number of permutations (factorial)</p>
</td></tr>
<tr><td><code>npermscale</code></td>
<td>
<p>Number of accepted permutations (monotonicity check)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mair P., De Leeuw J. (2015). Unidimensional scaling. In Wiley StatsRef: Statistics Reference Online, Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mds">mds</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## unidimensional scaling of Plato's 7 works
PlatoD &lt;- dist(t(Plato7))
fit.uni &lt;- uniscale(PlatoD)
fit.uni
plot(fit.uni)
</code></pre>

<hr>
<h2 id='VaziriXu'>Visual Object Representations</h2><span id='topic+VaziriXu'></span>

<h3>Description</h3>

<p>Contains two similarity matrices related to an experiment on visual object represenations. 
</p>
<p>similarities (correlations) of 54 OCP (see O'Reilly, Chatman, and Caldwell, 1991) items. The last three columns contain the facet assigned by Bilsky and Jehn (2002) as well as the external variables for regional restrictions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VaziriXu)</code></pre>


<h3>Format</h3>

<p>List of two similarity matrices from two experimental conditions: artificial and real object categories.
</p>
<p>V1-V4: early visual areas
</p>
<p>LO: lateral occipital regions
</p>
<p>VOT: ventral occipitotemporal regions
</p>
<p>V3A, V3B, IPS0-IPS4: topographic regions along the intraparietal sulcus
</p>
<p>Inferior IPS: inferior intraparietal sulcus
</p>
<p>Superior IPS: superior intraparietal sulcus
</p>


<h3>References</h3>

<p>Vaziri-Pashkam M, Xu Y (2018). An information-driven two-pathway characterization of occipito-temporal and posterior parietal visual object representations. Cerebral Cortex, forthcoming.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vx1 &lt;- sim2diss(VaziriXu[[1]])
vx2 &lt;- sim2diss(VaziriXu[[2]])
</code></pre>

<hr>
<h2 id='vmu'>Vector Model of Unfolding</h2><span id='topic+vmu'></span><span id='topic+print.vmu'></span><span id='topic+plot.vmu'></span>

<h3>Description</h3>

<p>Computes the metric vector model of unfolding (VMU) on rectangular input data (preferences, ratings) with the individuals (rows) represented as vectors in the biplot. There is also the option to fix the column coordinates. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmu(delta, ndim = 2, center = TRUE, scale = FALSE, col.coord = NULL)

## S3 method for class 'vmu'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vmu_+3A_delta">delta</code></td>
<td>
<p>Data frame or matrix of preferences, ratings, dissimilarities</p>
</td></tr>
<tr><td><code id="vmu_+3A_ndim">ndim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="vmu_+3A_center">center</code></td>
<td>
<p>If <code>TRUE</code> input data are centered row-wise.</p>
</td></tr>
<tr><td><code id="vmu_+3A_scale">scale</code></td>
<td>
<p>If <code>TRUE</code> input data are scaled row-wise.</p>
</td></tr>
<tr><td><code id="vmu_+3A_col.coord">col.coord</code></td>
<td>
<p>Optional fixed coordinates for the column objects in <code>delta</code>.</p>
</td></tr>
<tr><td><code id="vmu_+3A_x">x</code></td>
<td>
<p>Object of class <code>"vmu"</code>.</p>
</td></tr>
<tr><td><code id="vmu_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>biplot</code> in <code>stats</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>conf.row</code></td>
<td>
<p>Row coordinates</p>
</td></tr>
<tr><td><code>conf.col</code></td>
<td>
<p>Column coordinates</p>
</td></tr>
<tr><td><code>VAF</code></td>
<td>
<p>variance accounted for</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ingwer Borg and Patrick Mair</p>


<h3>References</h3>

<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.). Springer.
</p>
<p>Borg, I., Groenen, P. J. F., &amp; Mair, P. (2018). Applied Multidimensional Scaling and Unfolding (2nd ed.). Springer.
</p>
<p>Tucker, L. R. (1960). Intra-individual and inter-individual multidimensionality. In H. Gulliksen &amp; S. Messick (Eds.), Psychological scaling: Theory and applications (pp. 155-167). Wiley.
</p>
<p>Mair, P, Groenen, P. J. F., De Leeuw, J. (2022). More on multidimensional scaling in R: smacof version 2. Journal of Statistical Software, 102(10), 1-47. <a href="https://doi.org/10.18637/jss.v102.i10">doi:10.18637/jss.v102.i10</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+biplot">biplot</a></code>, <code><a href="#topic+unfolding">unfolding</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## VMU on portrait value questionnaire ratings
fit_vmu &lt;- vmu(PVQ40agg)         ## fit 2D VMU
fit_vmu
plot(fit_vmu, cex = c(1, 0.7))   ## call biplot from stats

## VMU with fixed column coordinates (circular)
tuv &lt;- matrix(0, nrow = 10, ncol = 2)
alpha &lt;- -360/10
for (i in 1:10){
  alpha &lt;- alpha+360/10
  tuv[i, 1]&lt;- cos(alpha*pi/180)
  tuv[i, 2] &lt;- sin(alpha*pi/180) 
}
fit_vmu2 &lt;- vmu(PVQ40agg, col.coord = tuv)  ## fit 2D circular VMU
fit_vmu2
plot(fit_vmu2, cex = c(1, 0.7))
</code></pre>

<hr>
<h2 id='winedat'>Wine tasting</h2><span id='topic+winedat'></span>

<h3>Description</h3>

<p>This dataset collects dissimilarity matrices of 10 raters of 6 different wines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(winedat)</code></pre>


<h3>Format</h3>

<p>A list of dissimilarity matrices reflecting the rating of 10 judges on 6 different wines (Ziniel Chardonnay, Markowitsch Chardonnay, Krems Chardonnay, Castel Nova Chardonnay, Ritinitis Noble Retsina, RetsinaCriteria). The attributes color, smell, taste, fun, and overall impression were rated on a scale from 1 (very good) to 5. Based on these ratings the distances were computed.    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>winedat

</code></pre>

<hr>
<h2 id='wish'>Wish dataset</h2><span id='topic+wish'></span>

<h3>Description</h3>

<p>Similarity ratings for 12 countries. There were no instructions concerning the characteristics on which these similarity judgements were to be made, this was information to discover rather than to impose. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wish)</code></pre>


<h3>Format</h3>

<p>Object of class <code>dist</code>
</p>


<h3>Details</h3>

<p>For smacof, the data must be converted into a dissimilarity matrix (see examples). 
</p>


<h3>References</h3>

<p>Borg, I., Groenen, P. J. F., &amp; Mair, P. (2010). Multidimensionale Skalierung. Muenchen: Hampp Verlag.
</p>
<p>Borg, I., Groenen, P. J. F., &amp; Mair, P. (2012). Multidimensional Scaling. New York: Springer, forthcoming.
</p>
<p>Wish, M. (1971). Individual differences in perceptions and preferences among nations. In C. W. King and D. Tigert (Eds.), Attitude research reaches new heights, pp. 312-328. Chicago: American Marketing Association.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wish)
sim2diss(wish, method = max(wish))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
