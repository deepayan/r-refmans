<!DOCTYPE html><html lang="en"><head><title>Help for package RDS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RDS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RDS-package'><p>RDS: Respondent-Driven Sampling</p></a></li>
<li><a href='#+5B.rds.data.frame'><p>indexing</p></a></li>
<li><a href='#+5B+26lt+3B-.rds.data.frame'><p>indexing</p></a></li>
<li><a href='#as.char'><p>converts to character with minimal loss of precision for numeric variables</p></a></li>
<li><a href='#as.rds.data.frame'><p>Coerces a data.frame object into an rds.data.frame object.</p></a></li>
<li><a href='#assert.valid.rds.data.frame'><p>Does various checks and throws errors if x is not a valid rds.data.frame</p></a></li>
<li><a href='#bootstrap.contingency.test'><p>Performs a bootstrap test of independance between two categorical variables</p></a></li>
<li><a href='#bootstrap.incidence'><p>Calculates incidence and bootstrap confidence intervals for immunoassay data collected with RDS</p></a></li>
<li><a href='#bottleneck.plot'><p>Bottleneck Plot</p></a></li>
<li><a href='#compute.weights'><p>Compute estimates of the sampling weights of the respondent's observations</p>
based on various estimators</a></li>
<li><a href='#control.list.accessor'><p>Named element accessor for ergm control lists</p></a></li>
<li><a href='#control.rds.estimates'><p>Auxiliary for Controlling RDS.bootstrap.intervals</p></a></li>
<li><a href='#convergence.plot'><p>Convergence Plots</p></a></li>
<li><a href='#count.transitions'><p>Counts the number or recruiter-&gt;recruitee transitions between different levels</p>
of the grouping variable.</a></li>
<li><a href='#cumulative.estimate'><p>Calculates estimates at each successive wave of the sampling process</p></a></li>
<li><a href='#differential.activity.estimates'><p>Differential Activity between groups</p></a></li>
<li><a href='#export.rds.interval.estimate'><p>Convert the output of print.rds.interval.estimate from a character data.frame to a numeric matrix</p></a></li>
<li><a href='#faux'><p>A Simulated RDS Data Set</p></a></li>
<li><a href='#fauxmadrona'><p>A Simulated RDS Data Set with no seed dependency</p></a></li>
<li><a href='#fauxsycamore'><p>A Simulated RDS Data Set with extreme seed dependency</p></a></li>
<li><a href='#fauxtime'><p>A Simulated RDS Data Set</p></a></li>
<li><a href='#get.h.hat'><p>Get Horvitz-Thompson estimator assuming inclusion probability proportional</p>
to the inverse of network.var (i.e. degree).</a></li>
<li><a href='#get.id'><p>Get the subject id</p></a></li>
<li><a href='#get.net.size'><p>Returns the network size of each subject (i.e. their degree).</p></a></li>
<li><a href='#get.number.of.recruits'><p>Calculates the number of (direct) recuits for each respondent.</p></a></li>
<li><a href='#get.population.size'><p>Returns the population size associated with the data.</p></a></li>
<li><a href='#get.recruitment.time'><p>Returns the recruitment time for each subject</p></a></li>
<li><a href='#get.rid'><p>Get recruiter id</p></a></li>
<li><a href='#get.seed.id'><p>Calculates the root seed id for each node of the recruitement tree.</p></a></li>
<li><a href='#get.seed.rid'><p>Gets the recruiter id associated with the seeds</p></a></li>
<li><a href='#get.stationary.distribution'><p>Markov chain statistionary distribution</p></a></li>
<li><a href='#get.wave'><p>Calculates the depth of the recruitment tree (i.e. the recruitment wave)</p>
at each node.</a></li>
<li><a href='#gile.ss.weights'><p>Weights using Giles SS estimator</p></a></li>
<li><a href='#has.recruitment.time'><p>RDS data.frame has recruitment time information</p></a></li>
<li><a href='#hcg.replicate.weights'><p>HCG parametric bootstrap replicate weights</p></a></li>
<li><a href='#hcg.weights'><p>homophily configuration graph weights</p></a></li>
<li><a href='#homophily.estimates'><p>This function computes an estimate of the population homophily and the recruitment homophily based on</p>
a categorical variable.</a></li>
<li><a href='#impute.degree'><p>Imputes missing degree values</p></a></li>
<li><a href='#impute.visibility'><p>Estimates each person's personal visibility based on their self-reported degree and the</p>
number of their (direct) recruits. It uses the time the person was recruited as a factor in
determining the number of recruits they produce.</a></li>
<li><a href='#impute.visibility_mle'><p>Estimates each person's personal visibility based on their self-reported degree and the</p>
number of their (direct) recruits. It uses the time the person was recruited as a factor in
determining the number of recruits they produce.</a></li>
<li><a href='#is.rds.data.frame'><p>Is an instance of rds.data.frame</p></a></li>
<li><a href='#is.rds.interval.estimate'><p>Is an instance of rds.interval.estimate</p></a></li>
<li><a href='#is.rds.interval.estimate.list'><p>Is an instance of rds.interval.estimate.list</p>
This is a (typically time ordered) sequence of RDS estimates of a comparable quantity</a></li>
<li><a href='#LRT.trend.test'><p>Compute a test of trend in prevalences based on a likelihood-ratio statistic</p></a></li>
<li><a href='#LRT.value.trend'><p>Compute a test of trend in prevalences based on a likelihood-ratio statistic</p></a></li>
<li><a href='#MA.estimates'><p>MA Estimates</p></a></li>
<li><a href='#plot.rds.data.frame'><p>Diagnostic plots for the RDS recruitment process</p></a></li>
<li><a href='#print.differential.activity.estimate'><p>Prints an differential.activity.estimate object</p></a></li>
<li><a href='#print.pvalue.table'><p>Displays a pvalue.table</p></a></li>
<li><a href='#print.rds.contin.bootstrap'><p>Displays an rds.contin.bootstrap</p></a></li>
<li><a href='#print.rds.data.frame'><p>Displays an rds.data.frame</p></a></li>
<li><a href='#print.rds.interval.estimate'><p>Prints an <code>rds.interval.estimate</code> object</p></a></li>
<li><a href='#print.summary.svyglm.RDS'><p>Summarizing Generalized Linear Model Fits with Odds Ratios</p></a></li>
<li><a href='#RDS.bootstrap.intervals'><p>RDS Bootstrap Interval Estimates</p></a></li>
<li><a href='#RDS.compare.proportions'><p>Compares the rates of two variables against one another.</p></a></li>
<li><a href='#RDS.compare.two.proportions'><p>Compares the rates of two variables against one another.</p></a></li>
<li><a href='#RDS.HCG.estimates'><p>Homophily Configuration Graph Estimates</p></a></li>
<li><a href='#RDS.I.estimates'><p>Compute RDS-I Estimates</p></a></li>
<li><a href='#rds.I.weights'><p>RDS-I weights</p></a></li>
<li><a href='#RDS.II.estimates'><p>RDS-II Estimates</p></a></li>
<li><a href='#rds.interval.estimate'><p>An object of class rds.interval.estimate</p></a></li>
<li><a href='#RDS.SS.estimates'><p>Gile's SS Estimates</p></a></li>
<li><a href='#rdssampleC'><p>Create RDS samples with given characteristics</p></a></li>
<li><a href='#read.rdsat'><p>Import data from the 'RDSAT' format as an <code>rds.data.frame</code></p></a></li>
<li><a href='#read.rdsobj'><p>Import data saved using write.rdsobj</p></a></li>
<li><a href='#reingold.tilford.plot'><p>Plots the recruitment network using the Reingold Tilford algorithm.</p></a></li>
<li><a href='#rid.from.coupons'><p>Determines the recruiter.id from recruitment coupon information</p></a></li>
<li><a href='#set.control.class'><p>Set the class of the control list</p></a></li>
<li><a href='#show.rds.data.frame'><p>Displays an rds.data.frame</p></a></li>
<li><a href='#summary.svyglm.RDS'><p>Summarizing Generalized Linear Model Fits with Odds Ratios for Survey Data</p></a></li>
<li><a href='#transition.counts.to.Markov.mle'><p>calculates the mle. i.e. the row proportions of the transition matrix</p></a></li>
<li><a href='#ult'><p>Extract or replace the *ult*imate (last) element of a vector or a list, or an element counting from the end.</p></a></li>
<li><a href='#vh.weights'><p>Volz-Heckathorn (RDS-II) weights</p></a></li>
<li><a href='#write.graphviz'><p>writes an rds.data.frame recruitment tree as a GraphViz file</p></a></li>
<li><a href='#write.netdraw'><p>Writes out the RDS tree in NetDraw format</p></a></li>
<li><a href='#write.rdsat'><p>Writes out the RDS tree in RDSAT format</p></a></li>
<li><a href='#write.rdsobj'><p>Export an rds.data.frame to file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Respondent-Driven Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark S. Handcock &lt;handcock@stat.ucla.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality for carrying out estimation
    with data collected using Respondent-Driven Sampling. This includes
    Heckathorn's RDS-I and RDS-II estimators as well as Gile's Sequential
    Sampling estimator. The package is part of the "RDS Analyst" suite of
    packages for the analysis of respondent-driven sampling data.
    See Gile and Handcock (2010) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9531.2010.01223.x">doi:10.1111/j.1467-9531.2010.01223.x</a>&gt;, 
    Gile and Handcock (2015) &lt;<a href="https://doi.org/10.1111%2Frssa.12091">doi:10.1111/rssa.12091</a>&gt; and
    Gile, Beaudry, Handcock and Ott (2018) &lt;<a href="https://doi.org/10.1146%2Fannurev-statistics-031017-100704">doi:10.1146/annurev-statistics-031017-100704</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hpmrg.org">https://hpmrg.org</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.5.1), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survey, sspse, testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>gridExtra, ggplot2 (&ge; 2.0.0), network, igraph, reshape2,
scales, anytime, Hmisc, statnet.common, ergm, isotone</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-05 16:12:34 UTC; handcock</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark S. Handcock <a href="https://orcid.org/0000-0002-9985-2785"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Krista J. Gile [aut],
  Ian E. Fellows [aut],
  W. Whipple Neely [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-06 08:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='RDS-package'>RDS: Respondent-Driven Sampling</h2><span id='topic+RDS'></span><span id='topic+RDS-package'></span>

<h3>Description</h3>

<p>Provides functionality for carrying out estimation with data collected using Respondent-Driven Sampling. This includes Heckathorn's RDS-I and RDS-II estimators as well as Gile's Sequential Sampling estimator. The package is part of the &quot;RDS Analyst&quot; suite of packages for the analysis of respondent-driven sampling data. See Gile and Handcock (2010) <a href="https://doi.org/10.1111/j.1467-9531.2010.01223.x">doi:10.1111/j.1467-9531.2010.01223.x</a>, Gile and Handcock (2015) <a href="https://doi.org/10.1111/rssa.12091">doi:10.1111/rssa.12091</a> and Gile, Beaudry, Handcock and Ott (2018) <a href="https://doi.org/10.1146/annurev-statistics-031017-100704">doi:10.1146/annurev-statistics-031017-100704</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mark S. Handcock <a href="mailto:handcock@stat.ucla.edu">handcock@stat.ucla.edu</a> (<a href="https://orcid.org/0000-0002-9985-2785">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Krista J. Gile <a href="mailto:gile@math.umass.edu">gile@math.umass.edu</a>
</p>
</li>
<li><p> Ian E. Fellows <a href="mailto:ian@fellstat.com">ian@fellstat.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> W. Whipple Neely <a href="mailto:wwneely@stat.washington.edu">wwneely@stat.washington.edu</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://hpmrg.org">https://hpmrg.org</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.rds.data.frame'>indexing</h2><span id='topic++5B.rds.data.frame'></span><span id='topic++5B+2Crds.data.frame-method'></span>

<h3>Description</h3>

<p>indexing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rds.data.frame'
x[i, j, ..., drop, warn = TRUE]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B.rds.data.frame_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="+2B5B.rds.data.frame_+3A_i">i</code></td>
<td>
<p>indices</p>
</td></tr>
<tr><td><code id="+2B5B.rds.data.frame_+3A_j">j</code></td>
<td>
<p>indices</p>
</td></tr>
<tr><td><code id="+2B5B.rds.data.frame_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="+2B5B.rds.data.frame_+3A_drop">drop</code></td>
<td>
<p>drop</p>
</td></tr>
<tr><td><code id="+2B5B.rds.data.frame_+3A_warn">warn</code></td>
<td>
<p>Warn if any new seeds are created</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subsetting of RDS recruitment trees does not always yield a
full RDS tree. In this case, subjects whose recruiter is no longer in
the dataset are considered seeds.
is issued if the 'warn' parameter is TRUE.
dat &lt;- data.frame(id=c(1,2,3,4,5), recruiter.id=c(2,-1,2,-1,4), network.size.variable=c(4,8,8,2,3))
r &lt;- as.rds.data.frame(dat)
r[1:3,] # A valid pruning of the RDS tree.
r[c(1,5),warn=FALSE] # recruiter.id of last row set to -1 (i.e. a seed) to maintain validity of tree
</p>

<hr>
<h2 id='+5B+26lt+3B-.rds.data.frame'>indexing</h2><span id='topic++5B+3C-.rds.data.frame'></span><span id='topic++5B+3C-+2Crds.data.frame-method'></span>

<h3>Description</h3>

<p>indexing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'rds.data.frame'
 x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B+2B26lt+2B3B-.rds.data.frame_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.rds.data.frame_+3A_i">i</code></td>
<td>
<p>indices</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.rds.data.frame_+3A_j">j</code></td>
<td>
<p>indices</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.rds.data.frame_+3A_value">value</code></td>
<td>
<p>value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indexed assignment. If the result is not a valid rds.data.frame, an error
is emitted.
</p>

<hr>
<h2 id='as.char'>converts to character with minimal loss of precision for numeric variables</h2><span id='topic+as.char'></span>

<h3>Description</h3>

<p>converts to character with minimal loss of precision for numeric variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.char(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.char_+3A_x">x</code></td>
<td>
<p>the value</p>
</td></tr>
<tr><td><code id="as.char_+3A_...">...</code></td>
<td>
<p>passed to either format or as.character.</p>
</td></tr>
</table>

<hr>
<h2 id='as.rds.data.frame'>Coerces a data.frame object into an rds.data.frame object.</h2><span id='topic+as.rds.data.frame'></span>

<h3>Description</h3>

<p>This function converts a regular R data frame into an  
<code>rds.data.frame</code>.  The greatest advantage of this is that it 
performs integrity checks and will fail if the recruitment information 
in the original data frame is incomplete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.rds.data.frame(
  df,
  id = if (is.null(attr(df, "id"))) "id" else attr(df, "id"),
  recruiter.id = if (is.null(attr(df, "recruiter.id"))) {
     "recruiter.id"
 } else
    attr(df, "recruiter.id"),
  network.size = if (is.null(attr(df, "network.size.variable"))) {
    
    "network.size.variable"
 } else attr(df, "network.size.variable"),
  population.size = if (all(is.na(get.population.size(df, FALSE)))) {
     NULL
 } else
    get.population.size(df, FALSE),
  max.coupons = if (is.null(attr(df, "max.coupons"))) {
     NULL
 } else attr(df,
    "max.coupons"),
  notes = if (is.null(attr(df, "notes"))) {
     NULL
 } else attr(df, "time"),
  time = if (is.null(attr(df, "time"))) {
     NULL
 } else attr(df, "time"),
  check.valid = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.rds.data.frame_+3A_df">df</code></td>
<td>
<p>A data.frame representing an RDS sample.</p>
</td></tr>
<tr><td><code id="as.rds.data.frame_+3A_id">id</code></td>
<td>
<p>The unique identifier.</p>
</td></tr>
<tr><td><code id="as.rds.data.frame_+3A_recruiter.id">recruiter.id</code></td>
<td>
<p>The unique identifier of the recruiter of this row.</p>
</td></tr>
<tr><td><code id="as.rds.data.frame_+3A_network.size">network.size</code></td>
<td>
<p>The number of alters (i.e. possible recruitees).</p>
</td></tr>
<tr><td><code id="as.rds.data.frame_+3A_population.size">population.size</code></td>
<td>
<p>The size of the population from which this RDS sample 
has been drawn. Either a single number, or a vector of length three indicating low, mid 
and high estimates.</p>
</td></tr>
<tr><td><code id="as.rds.data.frame_+3A_max.coupons">max.coupons</code></td>
<td>
<p>The number of recruitment coupons distributed to each 
enrolled subject (i.e. the maximum number of recruitees for any subject).</p>
</td></tr>
<tr><td><code id="as.rds.data.frame_+3A_notes">notes</code></td>
<td>
<p>Data set notes.</p>
</td></tr>
<tr><td><code id="as.rds.data.frame_+3A_time">time</code></td>
<td>
<p>the name of the recruitment time variable. optional.</p>
</td></tr>
<tr><td><code id="as.rds.data.frame_+3A_check.valid">check.valid</code></td>
<td>
<p>If true, validity checks are performed to ensure that the data is well formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rds.data.frame object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(id=c(1,2,3,4,5), recruiter.id=c(2,-1,2,-1,4),
                  network.size.variable=c(4,8,8,2,3))
as.rds.data.frame(dat)

</code></pre>

<hr>
<h2 id='assert.valid.rds.data.frame'>Does various checks and throws errors if x is not a valid rds.data.frame</h2><span id='topic+assert.valid.rds.data.frame'></span>

<h3>Description</h3>

<p>Does various checks and throws errors if x is not a valid rds.data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert.valid.rds.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert.valid.rds.data.frame_+3A_x">x</code></td>
<td>
<p>an rds.data.frame</p>
</td></tr>
<tr><td><code id="assert.valid.rds.data.frame_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Throws an informative message if x is malformed.
</p>

<hr>
<h2 id='bootstrap.contingency.test'>Performs a bootstrap test of independance between two categorical variables</h2><span id='topic+bootstrap.contingency.test'></span>

<h3>Description</h3>

<p>Performs a bootstrap test of independance between two categorical variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap.contingency.test(
  rds.data,
  row.var,
  col.var,
  number.of.bootstrap.samples = 1000,
  weight.type = c("HCG", "RDS-II", "Arithmetic Mean"),
  table.only = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap.contingency.test_+3A_rds.data">rds.data</code></td>
<td>
<p>an rds.data.frame</p>
</td></tr>
<tr><td><code id="bootstrap.contingency.test_+3A_row.var">row.var</code></td>
<td>
<p>the name of the first categorical variable</p>
</td></tr>
<tr><td><code id="bootstrap.contingency.test_+3A_col.var">col.var</code></td>
<td>
<p>the name of the second categorical variable</p>
</td></tr>
<tr><td><code id="bootstrap.contingency.test_+3A_number.of.bootstrap.samples">number.of.bootstrap.samples</code></td>
<td>
<p>The number of simulated boootstrap populations</p>
</td></tr>
<tr><td><code id="bootstrap.contingency.test_+3A_weight.type">weight.type</code></td>
<td>
<p>The type of weighting to use for the contningency table. Only large sample methods are allowed.</p>
</td></tr>
<tr><td><code id="bootstrap.contingency.test_+3A_table.only">table.only</code></td>
<td>
<p>only returns the weighted table, without bootstrap.</p>
</td></tr>
<tr><td><code id="bootstrap.contingency.test_+3A_verbose">verbose</code></td>
<td>
<p>level of output</p>
</td></tr>
<tr><td><code id="bootstrap.contingency.test_+3A_...">...</code></td>
<td>
<p>Additional parameters for compute_weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first estimates a Homophily Configuration Graph model for the underlying
network under the assumption that the two variables are independant and that the population size is large. 
It then draws bootstrap
RDS samples from this population distribution and calculates the chi.squared statistic on
the weighted contingency table. Weights are calculated using the HCG estimator assuming a large population size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(faux)
bootstrap.contingency.test(rds.data=faux, row.var="X", col.var="Y",
  number.of.bootstrap.samples=50, verbose=FALSE)
</code></pre>

<hr>
<h2 id='bootstrap.incidence'>Calculates incidence and bootstrap confidence intervals for immunoassay data collected with RDS</h2><span id='topic+bootstrap.incidence'></span>

<h3>Description</h3>

<p>Calculates incidence and bootstrap confidence intervals for immunoassay data collected with RDS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap.incidence(
  rds.data,
  recent.variable,
  hiv.variable,
  N = NULL,
  weight.type = c("Gile's SS", "RDS-I", "RDS-I (DS)", "RDS-II", "Arithmetic Mean", "HCG"),
  mean.duration = 200,
  frr = 0.01,
  post.infection.cutoff = 730,
  number.of.bootstrap.samples = 1000,
  se.mean.duration = 0,
  se.frr = 0,
  confidence.level = 0.95,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap.incidence_+3A_rds.data">rds.data</code></td>
<td>
<p>an rds.data.frame</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_recent.variable">recent.variable</code></td>
<td>
<p>The name of the variable indicating recent infection</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_hiv.variable">hiv.variable</code></td>
<td>
<p>The name of the variable indicating of hiv infection</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_n">N</code></td>
<td>
<p>Population size</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_weight.type">weight.type</code></td>
<td>
<p>A string giving the type of estimator to use. The options
are <code>"Gile's SS"</code>, <code>"RDS-I"</code>, <code>"RDS-II"</code>, <code>"RDS-I/DS"</code>,
and <code>"Arithemic Mean"</code>. It defaults to <code>"Gile's
SS"</code>.</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_mean.duration">mean.duration</code></td>
<td>
<p>Estimated mean duration of recent infection (MDRI) (days)</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_frr">frr</code></td>
<td>
<p>Estimated false-recent rate (FRR)</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_post.infection.cutoff">post.infection.cutoff</code></td>
<td>
<p>Post-infection time cut-off T, separating &quot;true-recent&quot; from &quot;false-recent&quot; results (days)</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_number.of.bootstrap.samples">number.of.bootstrap.samples</code></td>
<td>
<p>The number of bootstrap samples used to construct the interval.</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_se.mean.duration">se.mean.duration</code></td>
<td>
<p>The standard error of the mean.duration estimate</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_se.frr">se.frr</code></td>
<td>
<p>The standard error of the false recency estimate</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_confidence.level">confidence.level</code></td>
<td>
<p>The level of confidence for the interval</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_verbose">verbose</code></td>
<td>
<p>verbosity control</p>
</td></tr>
<tr><td><code id="bootstrap.incidence_+3A_...">...</code></td>
<td>
<p>additional arguments to compute.weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recent.variable and hiv should be the names of logical variables. Otherwise they are converted to logical using as.numeric(x) &gt; 0.5.
</p>
<p>This function estimates incidence using RDS sampling wieghts. Confidence intervals are constucted using HCG bootstraps.
See http://www.incidence-estimation.org/ for additional information on (non-RDS) incidence estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(faux)
faux$hiv &lt;- faux$X == "blue"
faux$recent &lt;- NA
faux$recent[faux$hiv] &lt;- runif(sum(faux$hiv)) &lt; .2
faux$recent[runif(nrow(faux)) &gt; .5] &lt;- NA
faux$hiv[is.na(faux$recent)][c(1,6,10,21)] &lt;- NA
attr(faux,"time") &lt;- "wave"
bootstrap.incidence(faux,"recent","hiv",weight.type="RDS-II", number.of.bootstrap.samples=100)
</code></pre>

<hr>
<h2 id='bottleneck.plot'>Bottleneck Plot</h2><span id='topic+bottleneck.plot'></span>

<h3>Description</h3>

<p>Bottleneck Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bottleneck.plot(
  rds.data,
  outcome.variable,
  est.func = RDS.II.estimates,
  as.factor = FALSE,
  n.eval.points = 25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bottleneck.plot_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.frame.</p>
</td></tr>
<tr><td><code id="bottleneck.plot_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>A character vector of outcome variables.</p>
</td></tr>
<tr><td><code id="bottleneck.plot_+3A_est.func">est.func</code></td>
<td>
<p>A function taking rds.data and outcome.variable as parameters and
returning an rds.weighted.estimate object.</p>
</td></tr>
<tr><td><code id="bottleneck.plot_+3A_as.factor">as.factor</code></td>
<td>
<p>Convert all outcome variables to factors</p>
</td></tr>
<tr><td><code id="bottleneck.plot_+3A_n.eval.points">n.eval.points</code></td>
<td>
<p>number of evaluation points to calculate the estimates at</p>
</td></tr>
<tr><td><code id="bottleneck.plot_+3A_...">...</code></td>
<td>
<p>additional parameters for est.func.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Krista J. Gile, Lisa G. Johnston, Matthew J. Salganik <em>Diagnostics for Respondent-driven Sampling</em> eprint arXiv:1209.6254, 2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fauxmadrona)
bottleneck.plot(fauxmadrona,"disease")
</code></pre>

<hr>
<h2 id='compute.weights'>Compute estimates of the sampling weights of the respondent's observations
based on various estimators</h2><span id='topic+compute.weights'></span>

<h3>Description</h3>

<p>Compute estimates of the sampling weights of the respondent's observations
based on various estimators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.weights(
  rds.data,
  weight.type = c("Gile's SS", "RDS-I", "RDS-I (DS)", "RDS-II", "Arithmetic Mean", "HCG"),
  N = NULL,
  subset = NULL,
  control = control.rds.estimates(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute.weights_+3A_rds.data">rds.data</code></td>
<td>
<p>An <code>rds.data.frame</code> that indicates recruitment patterns
by a pair of attributes named &ldquo;id&rdquo; and &ldquo;recruiter.id&rdquo;.</p>
</td></tr>
<tr><td><code id="compute.weights_+3A_weight.type">weight.type</code></td>
<td>
<p>A string giving the type of estimator to use. The options
are <code>"Gile's SS"</code>, <code>"RDS-I"</code>, <code>"RDS-II"</code>, <code>"RDS-I/DS"</code>,
and <code>"Arithemic Mean"</code>. It defaults to <code>"Gile's
SS"</code>.</p>
</td></tr>
<tr><td><code id="compute.weights_+3A_n">N</code></td>
<td>
<p>An estimate of the number of members of the population being
sampled. If <code>NULL</code> it is read as the <code>population.size.mid</code> attribute of
the <code>rds.data</code> frame. If that is missing, the weights will sum to 1. Note that
this parameter is required for Gile's SS.</p>
</td></tr>
<tr><td><code id="compute.weights_+3A_subset">subset</code></td>
<td>
<p>An optional criterion to subset <code>rds.data</code> by. It is
an R expression which, when evaluated, subset the
data. In plain English, it can be something like <code>subset = seed &gt; 0</code> to
exclude seeds. It can also be the name of a logical vector of the same length of
the outcome variable where TRUE means include it in the analysis. If
<code>NULL</code> then no subsetting is done.</p>
</td></tr>
<tr><td><code id="compute.weights_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm
tuning. Constructed using<br />
<code><a href="#topic+control.rds.estimates">control.rds.estimates</a></code>.</p>
</td></tr>
<tr><td><code id="compute.weights_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the individual weighting algorithms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of weights for each of the respondents. It is of the same
size as the number of rows in <code>rds.data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rds.I.weights">rds.I.weights</a></code>, <code><a href="#topic+gile.ss.weights">gile.ss.weights</a></code>, <code><a href="#topic+vh.weights">vh.weights</a></code>
</p>

<hr>
<h2 id='control.list.accessor'>Named element accessor for ergm control lists</h2><span id='topic+control.list.accessor'></span><span id='topic++24.control.list'></span>

<h3>Description</h3>

<p>Utility method that overrides the standard &lsquo;$&rsquo; list accessor to disable
partial matching for ergm <code>control.list</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'control.list'
object$name
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control.list.accessor_+3A_object">object</code></td>
<td>
<p>list-coearceable object with elements to be searched</p>
</td></tr>
<tr><td><code id="control.list.accessor_+3A_name">name</code></td>
<td>
<p>literal character name of list element to search for and return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Executes <code><a href="base.html#topic+getElement">getElement</a></code> instead of <code><a href="base.html#topic++24">$</a></code> so
that element names must match exactly to be returned and partially matching
names will not return the wrong object.
</p>


<h3>Value</h3>

<p>Returns the named list element exactly matching <code>name</code>, or
<code>NULL</code> if no matching elements found
</p>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>See Also</h3>

<p>see <code><a href="base.html#topic+getElement">getElement</a></code>
</p>

<hr>
<h2 id='control.rds.estimates'>Auxiliary for Controlling RDS.bootstrap.intervals</h2><span id='topic+control.rds.estimates'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning RDS.bootstrap.intervals algorithm,
which computes interval estimates for via bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.rds.estimates(
  confidence.level = 0.95,
  SS.infinity = 0.01,
  lowprevalence = c(8, 14),
  discrete.cutoff = 0.8,
  useC = TRUE,
  number.of.bootstrap.samples = NULL,
  hcg.reltol = sqrt(.Machine$double.eps),
  hcg.BS.reltol = 1e+05 * sqrt(.Machine$double.eps),
  hcg.max.optim = 500,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control.rds.estimates_+3A_confidence.level">confidence.level</code></td>
<td>
<p>The confidence level for the confidence intervals.
The default is 0.95 for 95%.</p>
</td></tr>
<tr><td><code id="control.rds.estimates_+3A_ss.infinity">SS.infinity</code></td>
<td>
<p>The sample proportion, <code>n/N</code>, below which the computation
of the SS weights should simplify to that of the <code>RDS-II</code> weights.</p>
</td></tr>
<tr><td><code id="control.rds.estimates_+3A_lowprevalence">lowprevalence</code></td>
<td>
<p>Standard confidence interval procedures can be inaccurate when the
outcome expected count is close to zero. This sets conditions where alternatives to the
standard are used for the <code>ci.type="hmg"</code> option. See Details for its use.</p>
</td></tr>
<tr><td><code id="control.rds.estimates_+3A_discrete.cutoff">discrete.cutoff</code></td>
<td>
<p>The minimum proportion of the values of the outcome variable that
need to be unique before the variable is judged to be continuous.</p>
</td></tr>
<tr><td><code id="control.rds.estimates_+3A_usec">useC</code></td>
<td>
<p>Use a C-level implementation of Gile's bootstrap (rather than
the R level). The implementations should be computational
equivalent (except for speed).</p>
</td></tr>
<tr><td><code id="control.rds.estimates_+3A_number.of.bootstrap.samples">number.of.bootstrap.samples</code></td>
<td>
<p>The number of bootstrap samples to take
in estimating the uncertainty of the estimator. If <code>NULL</code> it defaults
to the number necessary to compute the standard error to accuracy 0.001.</p>
</td></tr>
<tr><td><code id="control.rds.estimates_+3A_hcg.reltol">hcg.reltol</code></td>
<td>
<p>Relative convergence tolerance for the HCG estimator.  The algorithm stops if
it is unable to reduce the log-likelihood by a factor of <code>reltol * (abs(log-likelihood) + reltol)</code>
at a step. Defaults to <code>sqrt(.Machine$double.eps)</code>, typically about <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="control.rds.estimates_+3A_hcg.bs.reltol">hcg.BS.reltol</code></td>
<td>
<p>Relative convergence tolerance for the bootstrap of the HCG estimator. 
It has the same interpretation as <code>hcg.reltol</code> except it is applied to each bootstrap sample.
It is typically the same or larger than <code>hcg.reltol</code>.</p>
</td></tr>
<tr><td><code id="control.rds.estimates_+3A_hcg.max.optim">hcg.max.optim</code></td>
<td>
<p>The number of iterations on the likelihood optimization for the HCG estimator.</p>
</td></tr>
<tr><td><code id="control.rds.estimates_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only used within a call to the <code><a href="#topic+RDS.bootstrap.intervals">RDS.bootstrap.intervals</a></code>
function.
</p>
<p>Some of the arguments are not yet fully implemented. It will evolve slower to incorporate more
arguments as the package develops.
</p>
<p>Standard confidence interval procedures can be inaccurate when the
outcome expected count is close to zero. In these cases
the combined Agresti-Coull and the bootstrap-t interval of
Mantalos and Zografos (2008) can be used.
The <code>lowprevalence</code> argument is a
two vector parameter setting the conditions under which the approximation is used.
The first is the penalty term on the differential activity. If the observed number
of the rare group minus the product of the first parameter and the differential
activity is lower than the
second parameter, the low prevalence approximation is used.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDS.bootstrap.intervals">RDS.bootstrap.intervals</a></code>
</p>

<hr>
<h2 id='convergence.plot'>Convergence Plots</h2><span id='topic+convergence.plot'></span>

<h3>Description</h3>

<p>This function creates diagnostic convergence plots for RDS estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convergence.plot(
  rds.data,
  outcome.variable,
  est.func = RDS.II.estimates,
  as.factor = FALSE,
  n.eval.points = 25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convergence.plot_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.frame.</p>
</td></tr>
<tr><td><code id="convergence.plot_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>A character vector of outcome variables.</p>
</td></tr>
<tr><td><code id="convergence.plot_+3A_est.func">est.func</code></td>
<td>
<p>A function taking rds.data and outcome.variable as parameters and
returning an rds.weighted.estimate object.</p>
</td></tr>
<tr><td><code id="convergence.plot_+3A_as.factor">as.factor</code></td>
<td>
<p>Convert all outcome variables to factors</p>
</td></tr>
<tr><td><code id="convergence.plot_+3A_n.eval.points">n.eval.points</code></td>
<td>
<p>number of evaluation points to calculate the estimates at</p>
</td></tr>
<tr><td><code id="convergence.plot_+3A_...">...</code></td>
<td>
<p>additional parameters for est.func.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Krista J. Gile, Lisa G. Johnston, Matthew J. Salganik <em>Diagnostics for Respondent-driven Sampling</em> eprint arXiv:1209.6254, 2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(faux)
convergence.plot(faux,c("X","Y"))
</code></pre>

<hr>
<h2 id='count.transitions'>Counts the number or recruiter-&gt;recruitee transitions between different levels
of the grouping variable.</h2><span id='topic+count.transitions'></span>

<h3>Description</h3>

<p>Counts the number or recruiter-&gt;recruitee transitions between different levels
of the grouping variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.transitions(rds.data, group.variable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count.transitions_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
<tr><td><code id="count.transitions_+3A_group.variable">group.variable</code></td>
<td>
<p>The name of a categorical variable in rds.data</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(faux)
count.transitions(faux,"X")
</code></pre>

<hr>
<h2 id='cumulative.estimate'>Calculates estimates at each successive wave of the sampling process</h2><span id='topic+cumulative.estimate'></span>

<h3>Description</h3>

<p>Calculates estimates at each successive wave of the sampling process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative.estimate(
  rds.data,
  outcome.variable,
  est.func = RDS.II.estimates,
  n.eval.points = 25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumulative.estimate_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
<tr><td><code id="cumulative.estimate_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>The outcome</p>
</td></tr>
<tr><td><code id="cumulative.estimate_+3A_est.func">est.func</code></td>
<td>
<p>A function taking rds.data and outcome.variable as parameters and
returning an rds.weighted.estimate object</p>
</td></tr>
<tr><td><code id="cumulative.estimate_+3A_n.eval.points">n.eval.points</code></td>
<td>
<p>number of evaluation points to calculate the estimates at</p>
</td></tr>
<tr><td><code id="cumulative.estimate_+3A_...">...</code></td>
<td>
<p>additional parameters for est.func</p>
</td></tr>
</table>

<hr>
<h2 id='differential.activity.estimates'>Differential Activity between groups</h2><span id='topic+differential.activity.estimates'></span>

<h3>Description</h3>

<p>Differential Activity between groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>differential.activity.estimates(
  rds.data,
  outcome.variable,
  weight.type = "Gile's SS",
  N = NULL,
  subset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="differential.activity.estimates_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.frame object</p>
</td></tr>
<tr><td><code id="differential.activity.estimates_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>A character string of column names representing categorical variables.</p>
</td></tr>
<tr><td><code id="differential.activity.estimates_+3A_weight.type">weight.type</code></td>
<td>
<p>A string giving the type of estimator to use. The options
are <code>"Gile's SS"</code>, <code>"RDS-I"</code>, <code>"RDS-II"</code>, <code>"RDS-I/DS"</code>,
and <code>"Arithemic Mean"</code>. It defaults to <code>"Gile's
SS"</code>.</p>
</td></tr>
<tr><td><code id="differential.activity.estimates_+3A_n">N</code></td>
<td>
<p>The population size.</p>
</td></tr>
<tr><td><code id="differential.activity.estimates_+3A_subset">subset</code></td>
<td>
<p>An expression defining a subset of rds.data.</p>
</td></tr>
<tr><td><code id="differential.activity.estimates_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to compute.weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the ratio of the average degree of one population
group divided by the average degree of those in another population group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(faux)
differential.activity.estimates(faux,"X",weight.type="RDS-II")
</code></pre>

<hr>
<h2 id='export.rds.interval.estimate'>Convert the output of print.rds.interval.estimate from a character data.frame to a numeric matrix</h2><span id='topic+export.rds.interval.estimate'></span>

<h3>Description</h3>

<p>Convert the output of print.rds.interval.estimate from a character data.frame to a numeric matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.rds.interval.estimate(x, proportion = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export.rds.interval.estimate_+3A_x">x</code></td>
<td>
<p>An object, typically the result of print.rds.interval.estimate.</p>
</td></tr>
<tr><td><code id="export.rds.interval.estimate_+3A_proportion">proportion</code></td>
<td>
<p>logical, Should the outcome be treated as a proportion and converted to a percentage.</p>
</td></tr>
</table>

<hr>
<h2 id='faux'>A Simulated RDS Data Set</h2><span id='topic+faux'></span>

<h3>Description</h3>

<p>This is a faux set used to demonstrate RDS functions and analysis.
It is used is some simple examples and has categorical variables &quot;X&quot;, &quot;Y&quot; and &quot;Z&quot;.
</p>


<h3>Format</h3>

<p>An rds.data.frame object
</p>


<h3>References</h3>

<p>Gile, Krista J., Handcock, Mark S., 2010 <em>Respondent-driven Sampling: An Assessment of Current Methodology</em>,  <em>Sociological Methodology</em>, 40, 285-327.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fauxsycamore">fauxsycamore</a></code>, <code><a href="#topic+fauxmadrona">fauxmadrona</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(faux)
RDS.I.estimates(rds.data=faux,outcome.variable='X')
</code></pre>

<hr>
<h2 id='fauxmadrona'>A Simulated RDS Data Set with no seed dependency</h2><span id='topic+fauxmadrona'></span><span id='topic+fauxmadrona.network'></span>

<h3>Description</h3>

<p>This is a faux set used to illustrate how the estimators perform under
different populations and RDS schemes.
</p>


<h3>Format</h3>

<p>An <code>rds.data.frame</code>
</p>


<h3>Details</h3>

<p>The population had N=1000 nodes.  In this case, the sample size is 500 so
that there is a relatively small sample fraction (50%). There is homophily
on disease status (R=5) and there is differential activity by disease status
whereby the infected nodes have mean degree twice that of the uninfected
(w=1.8).
</p>
<p>In the sampling, the seeds are chosen randomly from the full population, so
there is no dependency induced by seed selection.
</p>
<p>Each sample member is given 2 uniquely identified coupons to distribute to
other members of the target population in their acquaintance.  Further each
respondent distributes their coupons completely at random from among those
they are connected to.
</p>
<p>Here are the results for this data set and the sister <code>fauxsycamore</code>
data set:
</p>

<table>
<tr>
 <td style="text-align: right;"> <b>Name</b> </td><td style="text-align: left;"> <b>City</b> </td><td style="text-align: left;"> <b>Type</b> </td><td style="text-align: left;">
<b>Mean</b> </td><td style="text-align: left;"> <b>RDS I (SH)</b> </td><td style="text-align: left;"> <b>RDS II (VH)</b> </td><td style="text-align: left;"> <b>SS</b>
</td>
</tr>
<tr>
 <td style="text-align: right;"> fauxsycamore </td><td style="text-align: left;"> Oxford</td><td style="text-align: left;"> seed dependency, 70% </td><td style="text-align: left;">
0.2408 </td><td style="text-align: left;"> 0.1087 </td><td style="text-align: left;"> 0.1372 </td><td style="text-align: left;"> 0.1814</td>
</tr>
<tr>
 <td style="text-align: right;"> fauxmadrona </td><td style="text-align: left;">
Seattle</td><td style="text-align: left;"> no seed dependency, 50% </td><td style="text-align: left;"> 0.2592 </td><td style="text-align: left;"> 0.1592 </td><td style="text-align: left;"> 0.1644
</td><td style="text-align: left;"> 0.1941</td>
</tr>

</table>

<p>Even with only 50% sample, the VH is substantially biased , and the SS
does much better.
</p>


<h3>Source</h3>

<p>The original network is included as
<code>fauxmadrona.network</code> as a <code>network</code> object.  <br /> The data set
also includes the <code>data.frame</code> of the RDS data set as
<code>fauxmadrona</code>.  <br /> Use <code>data(package="RDS")</code> to get a full list
of datasets.
</p>


<h3>References</h3>

<p>Gile, Krista J., Handcock, Mark S., 2010 <em>Respondent-driven
Sampling: An Assessment of Current Methodology</em>, <em>Sociological
Methodology</em>, 40, 285-327.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fauxsycamore">fauxsycamore</a></code>, <code><a href="#topic+faux">faux</a></code>
</p>

<hr>
<h2 id='fauxsycamore'>A Simulated RDS Data Set with extreme seed dependency</h2><span id='topic+fauxsycamore'></span><span id='topic+fauxsycamore.network'></span>

<h3>Description</h3>

<p>This is a faux set used to demonstrate RDS functions and analysis.  The
population had N=715 nodes.  In this case, the sample size is 500 so that
there is a relatively large sample fraction (70%). There is homophily on
disease status (R=5) and there is differential activity by disease status
whereby the infected nodes have mean degree twice that of the uninfected
(w=1.8).
</p>


<h3>Format</h3>

<p>An rds.data.frame plus the original network as a network object
</p>


<h3>Details</h3>

<p>In the sampling the seeds are chosen randomly from the infected population,
so there is extreme dependency induced by seed selection.
</p>
<p>Each sample member is given 2 uniquely identified coupons to distribute to
other members of the target population in their acquaintance.  Further each
respondent distributes their coupons completely at random from among those
they are connected to.
</p>
<p>With 70% sample, the VH is substantially biased, so the SS (and presumably
MA) do much better.  We expect the MA to perform a bit better than the SS.
</p>
<p>It is network 702 and its sample from YesYes on mosix. Look for
&quot;extract702.R&quot; <br /> The original network is included as
<code>fauxsycamore.network</code> as a <code>network</code> object.  <br /> The data set
also includes the <code>data.frame</code> of the RDS data set as
<code>fauxsycamore</code>.  <br /> Use <code>data(package="RDS")</code> to get a full list
of datasets.
</p>


<h3>References</h3>

<p>Gile, Krista J., Handcock, Mark S., 2009.
<em>Respondent-driven Sampling: An Assessment of Current Methodology</em>,
<em>Sociological Methodology</em>, 40, 285-327.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+faux">faux</a></code>, <code><a href="#topic+fauxmadrona">fauxmadrona</a></code>
</p>

<hr>
<h2 id='fauxtime'>A Simulated RDS Data Set</h2><span id='topic+fauxtime'></span>

<h3>Description</h3>

<p>This is a faux set used to demonstrate RDS functions and analysis.
</p>


<h3>Format</h3>

<p>An rds.data.frame object
</p>


<h3>References</h3>

<p>Gile, Krista J., Handcock, Mark S., 2010 <em>Respondent-driven Sampling: An Assessment of Current Methodology</em>,  <em>Sociological Methodology</em>, 40, 285-327.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fauxsycamore">fauxsycamore</a></code>, <code><a href="#topic+fauxmadrona">fauxmadrona</a></code>
</p>

<hr>
<h2 id='get.h.hat'>Get Horvitz-Thompson estimator assuming inclusion probability proportional
to the inverse of network.var (i.e. degree).</h2><span id='topic+get.h.hat'></span>

<h3>Description</h3>

<p>Get Horvitz-Thompson estimator assuming inclusion probability proportional
to the inverse of network.var (i.e. degree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.h.hat(
  rds.data,
  group.variable,
  network.var = attr(rds.data, "network.size")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.h.hat_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.from</p>
</td></tr>
<tr><td><code id="get.h.hat_+3A_group.variable">group.variable</code></td>
<td>
<p>The grouping variable.</p>
</td></tr>
<tr><td><code id="get.h.hat_+3A_network.var">network.var</code></td>
<td>
<p>The network.size variable.</p>
</td></tr>
</table>

<hr>
<h2 id='get.id'>Get the subject id</h2><span id='topic+get.id'></span>

<h3>Description</h3>

<p>Get the subject id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.id(x, check.type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.id_+3A_x">x</code></td>
<td>
<p>an rds.data.frame object</p>
</td></tr>
<tr><td><code id="get.id_+3A_check.type">check.type</code></td>
<td>
<p>if true, x is required to be of type rds.data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>returns the variable indicated by the 'id' attribute, coercing to
a character vector
</p>

<hr>
<h2 id='get.net.size'>Returns the network size of each subject (i.e. their degree).</h2><span id='topic+get.net.size'></span>

<h3>Description</h3>

<p>Returns the network size of each subject (i.e. their degree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.net.size(x, check.type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.net.size_+3A_x">x</code></td>
<td>
<p>the rds.data.frame</p>
</td></tr>
<tr><td><code id="get.net.size_+3A_check.type">check.type</code></td>
<td>
<p>if true, x is required to be of type rds.data.frame</p>
</td></tr>
</table>

<hr>
<h2 id='get.number.of.recruits'>Calculates the number of (direct) recuits for each respondent.</h2><span id='topic+get.number.of.recruits'></span>

<h3>Description</h3>

<p>Calculates the number of (direct) recuits for each respondent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.number.of.recruits(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.number.of.recruits_+3A_data">data</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fauxmadrona)
nr &lt;- get.number.of.recruits(fauxmadrona)
#frequency of number recruited by each id
barplot(table(nr))
</code></pre>

<hr>
<h2 id='get.population.size'>Returns the population size associated with the data.</h2><span id='topic+get.population.size'></span>

<h3>Description</h3>

<p>Returns the population size associated with the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.population.size(x, check.type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.population.size_+3A_x">x</code></td>
<td>
<p>the rds.data.frame</p>
</td></tr>
<tr><td><code id="get.population.size_+3A_check.type">check.type</code></td>
<td>
<p>if true, x is required to be of type rds.data.frame</p>
</td></tr>
</table>

<hr>
<h2 id='get.recruitment.time'>Returns the recruitment time for each subject</h2><span id='topic+get.recruitment.time'></span>

<h3>Description</h3>

<p>Returns the recruitment time for each subject
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.recruitment.time(
  x,
  to.numeric = TRUE,
  wave.fallback = FALSE,
  check.type = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.recruitment.time_+3A_x">x</code></td>
<td>
<p>the rds.data.frame</p>
</td></tr>
<tr><td><code id="get.recruitment.time_+3A_to.numeric">to.numeric</code></td>
<td>
<p>if true, time will be converted into a numeric variable.</p>
</td></tr>
<tr><td><code id="get.recruitment.time_+3A_wave.fallback">wave.fallback</code></td>
<td>
<p>if true, subjects' recruitment times are ordered by wave and then by data.frame index if no recruitment time variable is available.</p>
</td></tr>
<tr><td><code id="get.recruitment.time_+3A_check.type">check.type</code></td>
<td>
<p>if true, x is required to be of type rds.data.frame</p>
</td></tr>
</table>

<hr>
<h2 id='get.rid'>Get recruiter id</h2><span id='topic+get.rid'></span>

<h3>Description</h3>

<p>Get recruiter id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rid(x, check.type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.rid_+3A_x">x</code></td>
<td>
<p>an rds.data.frame object</p>
</td></tr>
<tr><td><code id="get.rid_+3A_check.type">check.type</code></td>
<td>
<p>if true, x is required to be of type rds.data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>returns the variable indicated by the 'recruiter.id' attribute, coercing to
a character vector
</p>

<hr>
<h2 id='get.seed.id'>Calculates the root seed id for each node of the recruitement tree.</h2><span id='topic+get.seed.id'></span>

<h3>Description</h3>

<p>Calculates the root seed id for each node of the recruitement tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.seed.id(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.seed.id_+3A_data">data</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fauxmadrona)
seeds &lt;- get.seed.id(fauxmadrona)
#number recruited by each seed
barplot(table(seeds))
</code></pre>

<hr>
<h2 id='get.seed.rid'>Gets the recruiter id associated with the seeds</h2><span id='topic+get.seed.rid'></span>

<h3>Description</h3>

<p>Gets the recruiter id associated with the seeds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.seed.rid(x, check.type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.seed.rid_+3A_x">x</code></td>
<td>
<p>an rds.data.frame object</p>
</td></tr>
<tr><td><code id="get.seed.rid_+3A_check.type">check.type</code></td>
<td>
<p>if true, x is required to be of type rds.data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All seed nodes must have the same placeholder recruiter id.
</p>

<hr>
<h2 id='get.stationary.distribution'>Markov chain statistionary distribution</h2><span id='topic+get.stationary.distribution'></span>

<h3>Description</h3>

<p>Markov chain statistionary distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.stationary.distribution(mle)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.stationary.distribution_+3A_mle">mle</code></td>
<td>
<p>The transition probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of proportions representing the proportion in each group at the
stationary distribution of the Markov chain.
</p>

<hr>
<h2 id='get.wave'>Calculates the depth of the recruitment tree (i.e. the recruitment wave) 
at each node.</h2><span id='topic+get.wave'></span>

<h3>Description</h3>

<p>Calculates the depth of the recruitment tree (i.e. the recruitment wave) 
at each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.wave(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.wave_+3A_data">data</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fauxmadrona)
#number subjects in each wave
w &lt;- get.wave(fauxmadrona)
#number recruited in each wave
barplot(table(w))
</code></pre>

<hr>
<h2 id='gile.ss.weights'>Weights using Giles SS estimator</h2><span id='topic+gile.ss.weights'></span>

<h3>Description</h3>

<p>Weights using Giles SS estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gile.ss.weights(
  degs,
  N,
  number.ss.samples.per.iteration = 500,
  number.ss.iterations = 5,
  hajek = TRUE,
  SS.infinity = 0.04,
  se = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gile.ss.weights_+3A_degs">degs</code></td>
<td>
<p>subjects' degrees (i.e. network sizes).</p>
</td></tr>
<tr><td><code id="gile.ss.weights_+3A_n">N</code></td>
<td>
<p>Population size estimate.</p>
</td></tr>
<tr><td><code id="gile.ss.weights_+3A_number.ss.samples.per.iteration">number.ss.samples.per.iteration</code></td>
<td>
<p>The number of samples to use to estimate inclusion probabilities
in a probability proportional to size without replacement design.</p>
</td></tr>
<tr><td><code id="gile.ss.weights_+3A_number.ss.iterations">number.ss.iterations</code></td>
<td>
<p>number of iterations to use in giles SS algorithm.</p>
</td></tr>
<tr><td><code id="gile.ss.weights_+3A_hajek">hajek</code></td>
<td>
<p>Should the hajek estiamtor be used. If false, the HT estimator is used.</p>
</td></tr>
<tr><td><code id="gile.ss.weights_+3A_ss.infinity">SS.infinity</code></td>
<td>
<p>The sample proportion, <code>n/N</code>, below which the computation of the SS weights should simplify to that of the <code>RDS-II</code> weights.</p>
</td></tr>
<tr><td><code id="gile.ss.weights_+3A_se">se</code></td>
<td>
<p>Should covariances be included.</p>
</td></tr>
<tr><td><code id="gile.ss.weights_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='has.recruitment.time'>RDS data.frame has recruitment time information</h2><span id='topic+has.recruitment.time'></span>

<h3>Description</h3>

<p>RDS data.frame has recruitment time information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.recruitment.time(x, check.type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has.recruitment.time_+3A_x">x</code></td>
<td>
<p>the rds.data.frame</p>
</td></tr>
<tr><td><code id="has.recruitment.time_+3A_check.type">check.type</code></td>
<td>
<p>if true, x is required to be of type rds.data.frame</p>
</td></tr>
</table>

<hr>
<h2 id='hcg.replicate.weights'>HCG parametric bootstrap replicate weights</h2><span id='topic+hcg.replicate.weights'></span>

<h3>Description</h3>

<p>HCG parametric bootstrap replicate weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcg.replicate.weights(
  rds.data,
  outcome.variable,
  number.of.bootstrap.samples = 500,
  include.sample.weights = FALSE,
  N = NULL,
  small.fraction = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hcg.replicate.weights_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
<tr><td><code id="hcg.replicate.weights_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>The column name of the variable defining the groups for the homophily configuration graph</p>
</td></tr>
<tr><td><code id="hcg.replicate.weights_+3A_number.of.bootstrap.samples">number.of.bootstrap.samples</code></td>
<td>
<p>The number of bootstrap replicate weights to be generated</p>
</td></tr>
<tr><td><code id="hcg.replicate.weights_+3A_include.sample.weights">include.sample.weights</code></td>
<td>
<p>If TRUE, the first column of the returned frame are the HCG weights for the sample</p>
</td></tr>
<tr><td><code id="hcg.replicate.weights_+3A_n">N</code></td>
<td>
<p>The population size</p>
</td></tr>
<tr><td><code id="hcg.replicate.weights_+3A_small.fraction">small.fraction</code></td>
<td>
<p>If TRUE, the sample size is assumed to be small compared to the population size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates bootstrap replicate weights which may be used to
analyze RDS data in other packages or software systems (e.g. the survey package
with svrepdesign).
</p>


<h3>Value</h3>

<p>A data.frame of replicate weights. If include.sample.weights is TRUE, the
first column are the HCG weights for the observed sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("fauxmadrona")
set.seed(1)
# Generate replicate weights
result &lt;- hcg.replicate.weights(fauxmadrona, "disease", 50, TRUE)
# Analyze with survey package and compare to internal function
if(require(survey)){
  set.seed(1)
  design &lt;- svrepdesign(fauxmadrona, type = "bootstrap", 
    weights= result[[1]], repweights = result[-1])
  svymean(~disease, design) |&gt; print()
  RDS.bootstrap.intervals(fauxmadrona, "disease", "HCG", "HCG", 
  number.of.bootstrap.samples = 50) |&gt; print()
}

## End(Not run)
</code></pre>

<hr>
<h2 id='hcg.weights'>homophily configuration graph weights</h2><span id='topic+hcg.weights'></span>

<h3>Description</h3>

<p>homophily configuration graph weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcg.weights(
  rds.data,
  outcome.variable,
  N = NULL,
  small.fraction = FALSE,
  reltol = sqrt(.Machine$double.eps),
  max.optim = 500,
  theta.start = NULL,
  weights.include.seeds = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hcg.weights_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
<tr><td><code id="hcg.weights_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>The variable used to base the weights on.</p>
</td></tr>
<tr><td><code id="hcg.weights_+3A_n">N</code></td>
<td>
<p>Population size</p>
</td></tr>
<tr><td><code id="hcg.weights_+3A_small.fraction">small.fraction</code></td>
<td>
<p>should a small sample fraction be assumed</p>
</td></tr>
<tr><td><code id="hcg.weights_+3A_reltol">reltol</code></td>
<td>
<p>Relative convergence tolerance for the HCG estimator.  The algorithm stops if
it is unable to reduce the log-likelihood by a factor of <code>reltol * (abs(log-likelihood) + reltol)</code>
at a step. Defaults to <code>sqrt(.Machine$double.eps)</code>, typically about <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="hcg.weights_+3A_max.optim">max.optim</code></td>
<td>
<p>The number of iterations on the likelihood optimization for the HCG estimator.</p>
</td></tr>
<tr><td><code id="hcg.weights_+3A_theta.start">theta.start</code></td>
<td>
<p>The initial value of theta used in the likelihood optimization for the HCG estimator. If NULL, the default, it is the margin of the table of counts for the transitions.</p>
</td></tr>
<tr><td><code id="hcg.weights_+3A_weights.include.seeds">weights.include.seeds</code></td>
<td>
<p>logical Should the weights be computed including the influence of the seeds?</p>
</td></tr>
<tr><td><code id="hcg.weights_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fauxtime)
hcg.weights(fauxtime,"var1",N=3000)
fauxtime$NETWORK[c(1,100,40,82,77)] &lt;- NA
</code></pre>

<hr>
<h2 id='homophily.estimates'>This function computes an estimate of the population homophily and the recruitment homophily based on 
a categorical variable.</h2><span id='topic+homophily.estimates'></span>

<h3>Description</h3>

<p>This function computes an estimate of the population homophily and the recruitment homophily based on 
a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophily.estimates(
  rds.data,
  outcome.variable,
  weight.type = NULL,
  uncertainty = NULL,
  recruitment = FALSE,
  N = NULL,
  to.group0.variable = NULL,
  to.group1.variable = NULL,
  number.ss.samples.per.iteration = NULL,
  confidence.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="homophily.estimates_+3A_rds.data">rds.data</code></td>
<td>
<p>An <code>rds.data.frame</code> that indicates recruitment patterns by a pair of attributes named &ldquo;id&rdquo; and &ldquo;recruiter.id&rdquo;.</p>
</td></tr>
<tr><td><code id="homophily.estimates_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>A string giving the name of the variable in the <code>rds.data</code> that contains a categorical or numeric variable to be analyzed.</p>
</td></tr>
<tr><td><code id="homophily.estimates_+3A_weight.type">weight.type</code></td>
<td>
<p>A string giving the type of estimator to use. The options are<br />
<code>"Gile's SS"</code>, <code>"RDS-I"</code>, <code>"RDS-II"</code>, <code>"RDS-I/DS"</code>, <code>"Good-Fellows"</code> and <code>"Arithemic Mean"</code>. If <code>NULL</code> it defaults to <code>"Gile's SS"</code>.</p>
</td></tr>
<tr><td><code id="homophily.estimates_+3A_uncertainty">uncertainty</code></td>
<td>
<p>A string giving the type of uncertainty estimator to use. The options are <code>"Gile's SS"</code> and <code>"Salganik"</code>. This is usually determined by <code>weight.type</code> to be consistent with the estimator's origins (e.g., for <code>"Gile's SS"</code>, <code>"RDS-I"</code>, <code>"RDS-II"</code>, <code>"RDS-I/DS"</code>, and <code>"Arithemic Mean"</code>). Hence it's current functionality is limited. If <code>NULL</code> it defaults to <code>"Gile's SS"</code>.</p>
</td></tr>
<tr><td><code id="homophily.estimates_+3A_recruitment">recruitment</code></td>
<td>
<p>A logical indicating if the homophily in the recruitment chains should be computed also. The default is FALSE.</p>
</td></tr>
<tr><td><code id="homophily.estimates_+3A_n">N</code></td>
<td>
<p>An estimate of  the number of members of the population being sampled. If <code>NULL</code> it is read as the <code>population.size.mid</code> attribute of the <code>rds.data</code> frame. If that is missing it defaults to 1000.</p>
</td></tr>
<tr><td><code id="homophily.estimates_+3A_to.group0.variable">to.group0.variable</code></td>
<td>
<p>The number in the network of each survey respondent who have group variable value 0. Usually this is not available. The default is to not use this variable.</p>
</td></tr>
<tr><td><code id="homophily.estimates_+3A_to.group1.variable">to.group1.variable</code></td>
<td>
<p>The number in the network of each survey respondent who have group variable value 1. Usually this is not available. The default is to not use this variable.</p>
</td></tr>
<tr><td><code id="homophily.estimates_+3A_number.ss.samples.per.iteration">number.ss.samples.per.iteration</code></td>
<td>
<p>The number of samples to take in estimating the inclusion probabilites in each iteration of the sequential sampling algorithm. If <code>NULL</code> it is read as the<br />
<code>number.ss.samples.per.iteration</code> attribute of <code>rds.data</code>. If that is missing it defaults to 5000.</p>
</td></tr>
<tr><td><code id="homophily.estimates_+3A_confidence.level">confidence.level</code></td>
<td>
<p>The confidence level for the confidence intervals. The default is 0.95 for 95%.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>outcome.variable</code> is binary then the homophily estimate of
0 verses 1 is returned, otherwise a vector of differential homophily
estimates is returned.
</p>


<h3>Recruitment Homophily</h3>

<p>The recruitment homophily is a homophily
measure for the recruitment process. It addresses the question: Do
respondents differential recruit people like themselves? That is, the
homophily on a variable in the recruitment chains. Take as an example infection
status. In this case, it is the ratio of number of recruits that have the
same infection status as their recruiter to the number we would expect if there
was no homophily on infection status. The difference with the Population
Homophily (see below) is that this is in the recruitment chain rather than
the population of social ties. For example, of the recruitment homophily on
infection status is about 1, we see little effect of recruitment homophily on infection
status (as the numbers of homophilous pairs are close to what we would
expect by chance).
</p>


<h3>Population Homophily</h3>

<p>This is an estimate the homophily of a given variable
in the underlying networked
population. For example, consider HIV status. The
population homophily is the homophily in the HIV status of
two people who are tied in the underlying population social network (a
&ldquo;couple&rdquo;). Specifically, the population homophily is the ratio of the expected
number of HIV discordant couples absent homophily to the expected number of HIV
discordant couples with the homophily. Hence larger values of population
homophily indicate more homophily on HIV status. For example, a value of 1
means the couple are random with respect to HIV status. A value of 2 means
there are twice as many HIV discordant couples as we would expect if there was
no homophily in the population. This measure is meaningful across different
levels of differential activity. As we do not see most of the population
network, we estimate the population homophily from the RDS data. As an example,
suppose the population homophily on HIV is 0.75 so there are 25% more HIV
discordant couples than expected due to chance. So their is actually
heterophily on HIV in the population. If the population homophily on sex is
1.1, there are 10% more same-sex couples than expected due to chance. Hence
there is modest homophily on sex.
</p>


<h3>Author(s)</h3>

<p>Mark S. Handcock with help from Krista J. Gile
</p>


<h3>References</h3>

<p>Gile, Krista J., Handcock, Mark S., 2010,
<em>Respondent-driven Sampling: An Assessment of Current Methodology</em>.
Sociological Methodology 40, 285-327.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fauxmadrona)
names(fauxmadrona)
#
# True value:
#
if(require(network)){
	a=as.sociomatrix(fauxmadrona.network)
	deg &lt;- apply(a,1,sum)
	dis &lt;- fauxmadrona.network \
	deg1 &lt;- apply(a[dis==1,],1,sum)
	deg0 &lt;- apply(a[dis==0,],1,sum)
	# differential activity
	mean(deg1)/ mean(deg0)
	p=mean(dis)
	N=1000
	# True homophily
	p*(1-p)*mean(deg0)*mean(deg1)*N/(mean(deg)*sum(a[dis==1,dis==0]))
}
# HT based estimators using the to.group information
data(fauxmadrona)
homophily.estimates(fauxmadrona,outcome.variable="disease",
  to.group0.variable="tonondiseased", to.group1.variable="todiseased",
  N=1000)
# HT based estimators not using the to.group information
homophily.estimates(fauxmadrona,outcome.variable="disease",
  N=1000,weight.type="RDS-II")

## End(Not run)
</code></pre>

<hr>
<h2 id='impute.degree'>Imputes missing degree values</h2><span id='topic+impute.degree'></span>

<h3>Description</h3>

<p>Imputes missing degree values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.degree(
  rds.data,
  trait.variable = NULL,
  N = NULL,
  method = c("mean", "quantile"),
  quantile = 0.5,
  recruitment.lower.bound = TRUE,
  round.degree = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute.degree_+3A_rds.data">rds.data</code></td>
<td>
<p>an rds.data.frame</p>
</td></tr>
<tr><td><code id="impute.degree_+3A_trait.variable">trait.variable</code></td>
<td>
<p>the name of the variable in rds.data to stratify the imputation by</p>
</td></tr>
<tr><td><code id="impute.degree_+3A_n">N</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="impute.degree_+3A_method">method</code></td>
<td>
<p>If mean, the weighted mean value is imputed, otherwize a quantile is used.</p>
</td></tr>
<tr><td><code id="impute.degree_+3A_quantile">quantile</code></td>
<td>
<p>If method is &quot;quantile&quot;, this is the quantile that is used. Defaults to median</p>
</td></tr>
<tr><td><code id="impute.degree_+3A_recruitment.lower.bound">recruitment.lower.bound</code></td>
<td>
<p>If TRUE, then for each individual, the degree is taken to be the minimum of
the number of recruits plus one, and the reported degree</p>
</td></tr>
<tr><td><code id="impute.degree_+3A_round.degree">round.degree</code></td>
<td>
<p>Should degrees be integer rounded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imputes degree values using the weighted mean or quantile values of the non-missing degrees.
Weights are calcualted using Gile's SS if N is not NULL, or RDS-II if it is. If a trait variable is specified,
means and quantile are calculated within the levels of the trait variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(faux)
rds.data &lt;- faux
rds.data$network.size[c(1,2,30,52,81,101,108,111)] &lt;- NA
impute.degree(rds.data)
impute.degree(rds.data,trait.variable="X")
impute.degree(rds.data,trait.variable="X",method="quantile")
</code></pre>

<hr>
<h2 id='impute.visibility'>Estimates each person's personal visibility based on their self-reported degree and the 
number of their (direct) recruits. It uses the time the person was recruited as a factor in 
determining the number of recruits they produce.</h2><span id='topic+impute.visibility'></span>

<h3>Description</h3>

<p>Estimates each person's personal visibility based on their self-reported degree and the 
number of their (direct) recruits. It uses the time the person was recruited as a factor in 
determining the number of recruits they produce.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.visibility(
  rds.data,
  max.coupons = NULL,
  type.impute = c("median", "distribution", "mode", "mean"),
  recruit.time = NULL,
  include.tree = FALSE,
  reflect.time = FALSE,
  parallel = 1,
  parallel.type = "PSOCK",
  interval = 10,
  burnin = 5000,
  mem.optimism.prior = NULL,
  df.mem.optimism.prior = 5,
  mem.scale.prior = 2,
  df.mem.scale.prior = 10,
  mem.overdispersion = 15,
  return.posterior.sample.visibilities = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute.visibility_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_max.coupons">max.coupons</code></td>
<td>
<p>The number of recruitment coupons distributed to each 
enrolled subject (i.e. the maximum number of recruitees for any subject).
By default it is taken by the attribute or data, else the maximum recorded number of coupons.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_type.impute">type.impute</code></td>
<td>
<p>The type of imputation based on the conditional distribution. 
It can be of type <code>distribution</code>,<code>mode</code>,<code>median</code>, or <code>mean</code> 
with the first , the default, being a random draw from the conditional distribution.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_recruit.time">recruit.time</code></td>
<td>
<p>vector; An optional value for the data/time that the person was interviewed.
It needs to resolve as a numeric vector with number of elements the number
of rows of the data with non-missing values of the network variable. If it
is a character name of a variable in the data then that variable is used.
If it is NULL then the sequence number of the recruit in the data is used.
If it is NA then the recruitment is not used in the model.
Otherwise, the recruitment time is used in the model to better predict the visibility of the person.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_include.tree">include.tree</code></td>
<td>
<p>logical; If <code>TRUE</code>, 
augment the reported network size by the number of recruits and one for the recruiter (if any).
This reflects a more accurate value for the visibility, but is not the self-reported degree.
In particular, it typically produces a positive visibility (compared to a possibility zero self-reported degree).</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_reflect.time">reflect.time</code></td>
<td>
<p>logical; If <code>FALSE</code> then the <code>recruit.time</code> is the time before the 
end of the study (instead of the time since the survey started or chronological time).</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_parallel">parallel</code></td>
<td>
<p>count; the number of parallel processes to run for the
Monte-Carlo sample.  This uses MPI or PSOCK. The default is 1, that is not to
use parallel processing.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_parallel.type">parallel.type</code></td>
<td>
<p>The type of parallel processing to use. The options are
&quot;PSOCK&quot; or &quot;MPI&quot;. This requires the corresponding type to be installed.
The default is &quot;PSOCK&quot;.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_interval">interval</code></td>
<td>
<p>count; the number of proposals between sampled statistics.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_burnin">burnin</code></td>
<td>
<p>count; the number of proposals before any MCMC sampling is
done. It typically is set to a fairly large number.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_mem.optimism.prior">mem.optimism.prior</code></td>
<td>
<p>scalar; A hyper parameter being the mean of the 
distribution of the optimism parameter.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_df.mem.optimism.prior">df.mem.optimism.prior</code></td>
<td>
<p>scalar; A hyper parameter being the degrees-of-freedom
of the prior for the optimism parameter. This gives the equivalent sample size that would
contain the same amount of information inherent in the prior.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_mem.scale.prior">mem.scale.prior</code></td>
<td>
<p>scalar; A hyper parameter being the scale of the concentration of
baseline negative binomial measurement error model.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_df.mem.scale.prior">df.mem.scale.prior</code></td>
<td>
<p>scalar; A hyper parameter being the degrees-of-freedom of
the prior for the standard deviation of the dispersion parameter in the visibility model.
This gives the equivalent sample size
that would contain the same amount of information inherent in the prior for
the standard deviation.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_mem.overdispersion">mem.overdispersion</code></td>
<td>
<p>scalar; A parameter being the overdispersion of the negative binomial
distribution that is the baseline for the measurement error model.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_return.posterior.sample.visibilities">return.posterior.sample.visibilities</code></td>
<td>
<p>logical; If TRUE then return a
matrix of dimension <code>samplesize</code> by <code>n</code> of 
posterior draws from the visibility distribution for those in the survey.
The sample for the <code>i</code>th person is the <code>i</code>th column.
The default is FALSE so that the vector of imputes defined by <code>type.impute</code> is returned.</p>
</td></tr>
<tr><td><code id="impute.visibility_+3A_verbose">verbose</code></td>
<td>
<p>logical; if this is <code>TRUE</code>, the program will print out additional</p>
</td></tr>
</table>


<h3>References</h3>

<p>McLaughlin, Katherine R.; Johnston, Lisa G.; Jakupi, Xhevat; Gexha-Bunjaku, Dafina; Deva, Edona and Handcock, Mark S. (2023)
Modeling the Visibility Distribution for Respondent-Driven Sampling with Application to Population Size Estimation,
<em>Annals of Applied Statistics</em>, <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fauxmadrona)
# The next line fits the model for the self-reported personal
# network sizes and imputes the personal network sizes 
# It may take up to 60 seconds.
visibility &lt;- impute.visibility(fauxmadrona)
# frequency of estimated personal visibility
table(visibility)

## End(Not run)
</code></pre>

<hr>
<h2 id='impute.visibility_mle'>Estimates each person's personal visibility based on their self-reported degree and the 
number of their (direct) recruits. It uses the time the person was recruited as a factor in 
determining the number of recruits they produce.</h2><span id='topic+impute.visibility_mle'></span>

<h3>Description</h3>

<p>Estimates each person's personal visibility based on their self-reported degree and the 
number of their (direct) recruits. It uses the time the person was recruited as a factor in 
determining the number of recruits they produce.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.visibility_mle(
  rds.data,
  max.coupons = NULL,
  type.impute = c("distribution", "mode", "median", "mean"),
  recruit.time = NULL,
  include.tree = FALSE,
  unit.scale = NULL,
  unit.model = c("cmp", "nbinom"),
  optimism = FALSE,
  guess = NULL,
  reflect.time = TRUE,
  maxit = 100,
  K = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute.visibility_mle_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_max.coupons">max.coupons</code></td>
<td>
<p>The number of recruitment coupons distributed to each 
enrolled subject (i.e. the maximum number of recruitees for any subject).
By default it is taken by the attribute or data, else the maximum recorded number of coupons.</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_type.impute">type.impute</code></td>
<td>
<p>The type of imputation based on the conditional distribution. 
It can be of type <code>distribution</code>,<code>mode</code>,<code>median</code>, or <code>mean</code> 
with the first , the default, being a random draw from the conditional distribution.</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_recruit.time">recruit.time</code></td>
<td>
<p>vector; An optional value for the data/time that the person was interviewed.
It needs to resolve as a numeric vector with number of elements the number
of rows of the data with non-missing values of the network variable. If it
is a character name of a variable in the data then that variable is used.
If it is NULL then the sequence number of the recruit in the data is used.
If it is NA then the recruitment is not used in the model.
Otherwise, the recruitment time is used in the model to better predict the visibility of the person.</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_include.tree">include.tree</code></td>
<td>
<p>logical; If <code>TRUE</code>, 
augment the reported network size by the number of recruits and one for the recruiter (if any).
This reflects a more accurate value for the visibility, but is not the self-reported degree.
In particular, it typically produces a positive visibility (compared to a possibility zero self-reported degree).</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_unit.scale">unit.scale</code></td>
<td>
<p>numeric; If not <code>NULL</code> it sets the numeric value of the scale parameter
of the distribution of the unit sizes.
For the negative binomial, it is the multiplier on the variance of the negative binomial 
compared to a Poisson (via the Poisson-Gamma mixture representation). Sometimes the scale is 
unnaturally large (e.g. 40) so this give the option of fixing it (rather than using
the MLE of it). The model is fit with the parameter fixed at this passed value.</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_unit.model">unit.model</code></td>
<td>
<p>The type of distribution for the unit sizes.
It can be of <code>nbinom</code>, meaning a negative binomial. 
In this case, <code>unit.scale</code> is the multiplier 
on the variance of the negative binomial compared to a Poisson of the same mean.
The alternative is <code>cmp</code>, meaning a Conway-Maxwell-Poisson distribution.
In this case, <code>unit.scale</code>
is the scale parameter compared to a Poisson of the same mean (values less than one mean 
under-dispersed and values over one mean over-dispersed). The default is <code>cmp</code>.</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_optimism">optimism</code></td>
<td>
<p>logical; If <code>TRUE</code> then add a term to the model allowing
the (proportional) inflation of the self-reported degrees relative to the unit sizes.</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_guess">guess</code></td>
<td>
<p>vector; if not <code>NULL</code>, the initial parameter values for the MLE fitting.</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_reflect.time">reflect.time</code></td>
<td>
<p>logical; If <code>FALSE</code> then the <code>recruit.time</code> is the time before the 
end of the study (instead of the time since the survey started or chronological time).</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_maxit">maxit</code></td>
<td>
<p>integer; The maximum number of iterations in the likelihood maximization. By default it is 100.</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_k">K</code></td>
<td>
<p>integer; The maximum degree. All self-reported degrees above this are recorded as being at least K.
By default it is the 95th percentile of the self-reported network sizes.</p>
</td></tr>
<tr><td><code id="impute.visibility_mle_+3A_verbose">verbose</code></td>
<td>
<p>logical; if this is <code>TRUE</code>, the program will print out additional</p>
</td></tr>
</table>


<h3>References</h3>

<p>McLaughlin, K.R., M.S. Handcock, and L.G. Johnston, 2015. 
Inference for the visibility distribution for respondent-driven sampling. 
In JSM Proceedings. Alexandria, VA: American Statistical Association. 2259-2267.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fauxmadrona)
# The next line fits the model for the self-reported personal
# network sizes and imputes the personal network sizes 
# It may take up to 60 seconds.
visibility &lt;- impute.visibility(fauxmadrona)
# frequency of estimated personal visibility
table(visibility)

## End(Not run)
</code></pre>

<hr>
<h2 id='is.rds.data.frame'>Is an instance of rds.data.frame</h2><span id='topic+is.rds.data.frame'></span>

<h3>Description</h3>

<p>Is an instance of rds.data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rds.data.frame(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.rds.data.frame_+3A_x">x</code></td>
<td>
<p>An object to be tested.</p>
</td></tr>
</table>

<hr>
<h2 id='is.rds.interval.estimate'>Is an instance of rds.interval.estimate</h2><span id='topic+is.rds.interval.estimate'></span>

<h3>Description</h3>

<p>Is an instance of rds.interval.estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rds.interval.estimate(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.rds.interval.estimate_+3A_x">x</code></td>
<td>
<p>An object to be tested.</p>
</td></tr>
</table>

<hr>
<h2 id='is.rds.interval.estimate.list'>Is an instance of rds.interval.estimate.list
This is a (typically time ordered) sequence of RDS estimates of a comparable quantity</h2><span id='topic+is.rds.interval.estimate.list'></span>

<h3>Description</h3>

<p>Is an instance of rds.interval.estimate.list
This is a (typically time ordered) sequence of RDS estimates of a comparable quantity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rds.interval.estimate.list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.rds.interval.estimate.list_+3A_x">x</code></td>
<td>
<p>An object to be tested.</p>
</td></tr>
</table>

<hr>
<h2 id='LRT.trend.test'>Compute a test of trend in prevalences based on a likelihood-ratio statistic</h2><span id='topic+LRT.trend.test'></span><span id='topic+LRT.trend'></span><span id='topic+LRT.trend.null'></span>

<h3>Description</h3>

<p>This function takes a series of point estimates and their associated standard errors and
computes the p-value for the test of a monotone decrease in the 
population prevalences (in sequence order). 
The p-value for a monotone increase is
also reported. An optional plot of the estimates and the null distribution of the test statistics is provided.
More formally, let the <code class="reqn">K</code> population prevalences in sequence order be <code class="reqn">p_1, \ldots, p_K</code>.
We test the null hypothesis:<br />
</p>
<p style="text-align: center;"><code class="reqn">H_0 : p_1 = \ldots = p_K</code>
</p>

<p>vs
</p>
<p style="text-align: center;"><code class="reqn">H_1 : p_1 \ge p_2 \ldots \ge p_K</code>
</p>

<p>with at least one equality strict. The alternatie hypothesis is for a monotone decreasing trend.
A likelihood ratio statistic for this test has 
been derived (Bartholomew 1959).
The null distribution of the likelihood ratio statistic is very complex 
but can be determined by a simple Monte Carlo process.<br />
Alternatively, we can test the null hypothesis:<br />
</p>
<p style="text-align: center;"><code class="reqn">H_0 : p_1 \ge p_2 \ldots \ge p_K</code>
</p>

<p>vs
</p>
<p style="text-align: center;"><code class="reqn">H_1 : \overline{H_0}</code>
</p>

<p>The null distribution of the likelihood ratio statistic is very complex 
but can be determined by a simple Monte Carlo process.
In both cases we also test for:<br />
</p>
<p style="text-align: center;"><code class="reqn">H : p_1 \le p_2 \ldots \le p_K</code>
</p>

<p>that is, a monotonically increasing trend.
The function requires the isotone library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRT.trend.test(
  data,
  variables = colnames(data),
  null = "monotone",
  confidence.level = 0.95,
  number.of.bootstrap.samples = 5000,
  plot = NULL,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LRT.trend.test_+3A_data">data</code></td>
<td>
<p>A two row matrix or data.frame of prevalence estimates and
their standard errors. The first row is the prevalence estimates and the
second are the standard errors. The column are the comparison groups in the
order (e.g., time) there are to be assessed. The row names of <code>data</code>
should be &quot;estimate&quot; and &quot;sigma&quot;. This is</p>
</td></tr>
<tr><td><code id="LRT.trend.test_+3A_variables">variables</code></td>
<td>
<p>A character vector of column names it select from <code>data</code>.</p>
</td></tr>
<tr><td><code id="LRT.trend.test_+3A_null">null</code></td>
<td>
<p>A character string indicating the null hypothesis to use. The value <code>"monotone"</code> uses the various 
monotone hypotheses as the nulls. If not <code>"monotone"</code>, the null is chosen to be that of equality of the means
over all periods.</p>
</td></tr>
<tr><td><code id="LRT.trend.test_+3A_confidence.level">confidence.level</code></td>
<td>
<p>The confidence level for the confidence intervals. The default is 0.95 for 95%.</p>
</td></tr>
<tr><td><code id="LRT.trend.test_+3A_number.of.bootstrap.samples">number.of.bootstrap.samples</code></td>
<td>
<p>The number of Monte Carlo draws to
determine the null distribution of the likelihood ratio statistic.</p>
</td></tr>
<tr><td><code id="LRT.trend.test_+3A_plot">plot</code></td>
<td>
<p>A character vector of choices, a subset of <code>estimates</code>, <code>distributions</code>.
If <code>estimates</code> is given then a plot of the estimates and nominal 95% confidence bands (as error bars) is produced.
If <code>distributions</code> is given then a plot is produced of the null distributions of 
the likelihood
ratio statistic with the observed likelihood ratio statistics plotted as a vertical dashed line.</p>
</td></tr>
<tr><td><code id="LRT.trend.test_+3A_seed">seed</code></td>
<td>
<p>The value of the random number seed. Preset by default to allow reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
 <ul>
<li><p><code>pvalue.increasing</code>: The p-value for the test of a monotone increase in population prevalence.
</p>
</li>
<li><p><code>pvalue.decreasing</code>: The p-value for the test of a monotone decrease in population prevalence.
</p>
</li>
<li><p><code>L</code>: The value of the likelihood-ratio statistic.
</p>
</li>
<li><p><code>x</code>: The passed vector of prevalence estimates in the order (e.g., time).
</p>
</li>
<li><p><code>sigma</code> The passed vector of standard error estimates corresponding to <code>x</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mark S. Handcock
</p>


<h3>References</h3>

<p>Bartholomew, D. J. (1959). A test of homogeneity for ordered alternatives. Biometrika 46 36-48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- t(data.frame(estimate=c(0.16,0.15,0.3), sigma=c(0.04,0.04,0.1)))
colnames(d) &lt;- c("time_1","time_2","time_3") 
LRT.trend.test(d,number.of.bootstrap.samples=1000)
</code></pre>

<hr>
<h2 id='LRT.value.trend'>Compute a test of trend in prevalences based on a likelihood-ratio statistic</h2><span id='topic+LRT.value.trend'></span>

<h3>Description</h3>

<p>This function takes a series of point estimates and their associated standard errors and
computes the p-value for the test of a monotone decrease in the 
population prevalences (in sequence order). 
The p-value for a monotone increase is
also reported.
More formally, let the <code class="reqn">K</code> population prevalences in sequence order be <code class="reqn">p_1, \ldots, p_K</code>.
We test the null hypothesis:<br />
</p>
<p style="text-align: center;"><code class="reqn">H_0 : p_1 = \ldots = p_K</code>
</p>

<p>vs
</p>
<p style="text-align: center;"><code class="reqn">H_1 : p_1 \ge p_2 \ldots \ge p_K</code>
</p>

<p>with at least one equality strict. A likelihood ratio statistic for this test has 
been derived (Bartholomew 1959).
The null distribution of the likelihood ratio statistic is very complex 
but can be determined by a simple Monte Carlo process.<br />
We also test the null hypothesis:<br />
</p>
<p style="text-align: center;"><code class="reqn">H_0 : p_1 \ge p_2 \ldots \ge p_K</code>
</p>

<p>vs
</p>
<p style="text-align: center;"><code class="reqn">H_1 : \overline{H_0}</code>
</p>

<p>The null distribution of the likelihood ratio statistic is very complex 
but can be determined by a simple Monte Carlo process.
The function requires the isotone library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRT.value.trend(x, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LRT.value.trend_+3A_x">x</code></td>
<td>
<p>A vector of prevalence estimates in the order (e.g., time).</p>
</td></tr>
<tr><td><code id="LRT.value.trend_+3A_sigma">sigma</code></td>
<td>
<p>A vector of standard error estimates corresponding to <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
 <ul>
<li><p><code>pvalue.increasing</code>: The p-value for the test of a monotone increase in population prevalence.
</p>
</li>
<li><p><code>pvalue.decreasing</code>: The p-value for the test of a monotone decrease in population prevalence.
</p>
</li>
<li><p><code>L</code>: The value of the likelihood-ratio statistic.
</p>
</li>
<li><p><code>x</code>: The passed vector of prevalence estimates in the order (e.g., time).
</p>
</li>
<li><p><code>sigma</code> The passed vector of standard error estimates corresponding to <code>x</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mark S. Handcock
</p>


<h3>References</h3>

<p>Bartholomew, D. J. (1959). A test of homogeneity for ordered alternatives. Biometrika 46 36-48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
x &lt;- c(0.16,0.15,0.3)
sigma &lt;- c(0.04,0.04,0.1)
LRT.value.trend(x,sigma)

## End(Not run)
</code></pre>

<hr>
<h2 id='MA.estimates'>MA Estimates</h2><span id='topic+MA.estimates'></span>

<h3>Description</h3>

<p>This function computes the sequential sampling (MA) estimates for a
categorical variable or numeric variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MA.estimates(
  rds.data,
  trait.variable,
  seed.selection = "degree",
  number.of.seeds = NULL,
  number.of.coupons = NULL,
  number.of.iterations = 3,
  N = NULL,
  M1 = 25,
  M2 = 20,
  seed = 1,
  initial.sampling.probabilities = NULL,
  MPLE.samplesize = 50000,
  SAN.maxit = 5,
  SAN.nsteps = 2^19,
  sim.interval = 10000,
  number.of.cross.ties = NULL,
  max.degree = NULL,
  parallel = 1,
  parallel.type = "PSOCK",
  full.output = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MA.estimates_+3A_rds.data">rds.data</code></td>
<td>
<p>An <code>rds.data.frame</code> that indicates recruitment patterns
by a pair of attributes named &ldquo;id&rdquo; and &ldquo;recruiter.id&rdquo;.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_trait.variable">trait.variable</code></td>
<td>
<p>A string giving the name of the variable in the
<code>rds.data</code> that contains a categorical or numeric variable to be
analyzed.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_seed.selection">seed.selection</code></td>
<td>
<p>An estimate of the mechanism guiding the choice of
seeds.  The choices are </p>
 <dl>
<dt>&quot;allwithtrait&quot;</dt><dd><p>indicating that all
the seeds had the trait;</p>
</dd> <dt>&quot;random&quot;</dt><dd><p>meaning they were, as if, a simple
random sample of individuals from the population;</p>
</dd>
<dt>&quot;sample&quot;</dt><dd><p>indicating that the seeds are taken as those in the sample
(and resampled for the population with that composition if necessary);</p>
</dd>
<dt>&quot;degree&quot;</dt><dd><p>is proportional to the degree of the individual;</p>
</dd>
<dt>&quot;allwithtraitdegree&quot;</dt><dd><p>indicating that all the seeds had the trait and
the probability of being a seed is proportional to the degree of the
respondent.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="MA.estimates_+3A_number.of.seeds">number.of.seeds</code></td>
<td>
<p>The number of seeds chosen to initiate the sampling.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_number.of.coupons">number.of.coupons</code></td>
<td>
<p>The number of coupons given to each respondent.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_number.of.iterations">number.of.iterations</code></td>
<td>
<p>The number of iterations used at the core of the
algorithm.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_n">N</code></td>
<td>
<p>An estimate of the number of members of the population being
sampled. If <code>NULL</code> it is read as the <code>pop.size.mid</code> attribute of
the <code>rds.data</code> frame. If that is missing it defaults to 1000.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_m1">M1</code></td>
<td>
<p>The number of networked populations generated at each iteration.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_m2">M2</code></td>
<td>
<p>The number of (full) RDS samples generated for each networked
population at each iteration.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_seed">seed</code></td>
<td>
<p>The random number seed used to initiate the computations.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_initial.sampling.probabilities">initial.sampling.probabilities</code></td>
<td>
<p>Initialize sampling probabilities for
the algorithm. If missing, they are taken as proportional to degree, and
this is almost always the best starting values.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_mple.samplesize">MPLE.samplesize</code></td>
<td>
<p>Number of samples to take in the computation of the
maximum pseudolikelihood estimator (MPLE) of the working model parameter.
The default is almost always sufficient.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_san.maxit">SAN.maxit</code></td>
<td>
<p>A ceiling on the number of simulated annealing iterations.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_san.nsteps">SAN.nsteps</code></td>
<td>
<p>Number of MCMC proposals for all the annealing runs combined.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_sim.interval">sim.interval</code></td>
<td>
<p>Number of MCMC steps between each of the M1 sampled
networks per iteration.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_number.of.cross.ties">number.of.cross.ties</code></td>
<td>
<p>The expected number of ties between those with
the trait and those without. If missing, it is computed based on the
respondent's reports of the number of ties they have to population members
who have the trait (i.e. <code>ties.to.trait.variable</code>) and do not have the
trait (i.e. <code>ties.not.to.trait.variable</code>).</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_max.degree">max.degree</code></td>
<td>
<p>Impose ceiling on degree size.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_parallel">parallel</code></td>
<td>
<p>Number of processors to use in the computations. The default
is 1, that is no parallel processing.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_parallel.type">parallel.type</code></td>
<td>
<p>The type of cluster to start. e.g. 'PSOCK', 'MPI', etc.</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_full.output">full.output</code></td>
<td>
<p>More verbose output</p>
</td></tr>
<tr><td><code id="MA.estimates_+3A_verbose">verbose</code></td>
<td>
<p>Should verbose diagnostics be printed while the algorithm is
running.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>trait.variable</code> is numeric then the model-assisted estimate
of the mean is returned, otherwise a vector of proportion estimates is
returned. If <code>full.output=TRUE</code> this leads to:
</p>
<p>If <code>full.output=FALSE</code> this leads to an object of class
<code>rds.interval.estimate</code> which is a list with component
</p>

<dl>
<dt>estimate</dt><dd><p>the numerical point estimate of proportion of the<code>trait.variable</code>.</p>
</dd>
<dt>interval</dt><dd><p>a matrix with size columns and one row per category of <code>trait.variable</code>:
</p>

<dl>
<dt>point estimate</dt><dd><p> The HT estimate of the population mean.</p>
</dd>
<dt>95% Lower Bound</dt><dd><p>Lower 95% confidence bound</p>
</dd>
<dt>95% Upper Bound</dt><dd><p>Upper 95% confidence bound</p>
</dd>
<dt>Design Effect</dt><dd><p>The design effect of the RDS</p>
</dd>
<dt>s.e.</dt><dd><p>standard error</p>
</dd>
<dt>n</dt><dd><p>count of the number of sample values with that value of the trait</p>
</dd>
</dl>

</dd>
<dt>rds.data</dt><dd><p>an <code>rds.data.frame</code> that indicates recruitment
patterns by a pair of attributes named &ldquo;id&rdquo; and &ldquo;recruiter.id&rdquo;.</p>
</dd>
<dt>N</dt><dd><p>an estimate of the number of members of the population being
sampled. If <code>NULL</code> it is read as the <code>pop.size.mid</code> attribute of
the <code>rds.data</code> frame. If that is missing it defaults to 1000.</p>
</dd>
<dt>M1</dt><dd><p>the number of networked populations generated at each iteration.</p>
</dd>
<dt>M2</dt><dd><p>the number of (full) RDS populations generated for each
networked population at each iteration.</p>
</dd>
<dt>seed</dt><dd><p>the random number seed used to initiate the computations.</p>
</dd>
<dt>seed.selection</dt><dd><p>an estimate of the mechanism guiding the choice
of seeds.  The choices are 
</p>

<dl>
<dt>&quot;allwithtrait&quot;</dt><dd><p>indicating that
all the seeds had the trait;</p>
</dd> <dt>&quot;random&quot;</dt><dd><p>meaning they were, as if, a
simple random sample of individuals from the population;</p>
</dd>
<dt>&quot;sample&quot;</dt><dd><p>indicating that the seeds are taken as those in the sample
(and resampled for the population with that composition if necessary);</p>
</dd>
<dt>&quot;degree&quot;</dt><dd><p>is proportional to the degree of the individual;</p>
</dd>
<dt>&quot;allwithtraitdegree&quot;</dt><dd><p>indicating that all the seeds had the trait and
the probability of being a seed is proportional to the degree of the
respondent.</p>
</dd>
</dl>

</dd>
<dt>number.of.seeds</dt><dd><p>The number of seeds chosen to initiate the sampling.</p>
</dd>
<dt>number.of.coupons</dt><dd><p>The number of coupons given to each respondent.</p>
</dd>
<dt>number.of.iterations</dt><dd><p>The number of iterations used at the core of the algorithm.</p>
</dd>
<dt>outcome.variable</dt><dd><p>The name of the outcome variable</p>
</dd>
<dt>weight.type</dt><dd><p>The type of weighting used (i.e. MA)</p>
</dd>
<dt>uncertainty</dt><dd><p>The type of weighting used (i.e. MA)</p>
</dd>
<dt>details</dt><dd><p>A list of other diagnostic output from the computations.</p>
</dd>
<dt>varestBS</dt><dd><p>Output from the bootstrap procedure. A list with two
elements: <code>var</code> is the bootstrap variance, and <code>BSest</code> is the
vector of bootstrap estimates themselves.</p>
</dd>
<dt>coefficient</dt><dd><p>estimate of the parameter of the ERGM for the
network.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Krista J. Gile with help from Mark S. Handcock
</p>


<h3>References</h3>

<p>Gile, Krista J. 2011 Improved Inference for
Respondent-Driven Sampling Data with Application to HIV Prevalence
Estimation, Journal of the American Statistical Association, 106,
135-146.
</p>
<p>Gile, Krista J., Handcock, Mark S., 2010. Respondent-driven Sampling:
An Assessment of Current Methodology, Sociological Methodology, 40,
285-327. &lt;doi:10.1111/j.1467-9531.2010.01223.x&gt;
</p>
<p>Gile, Krista J., Beaudry, Isabelle S. and Handcock, Mark S., 2018 
Methods for Inference from Respondent-Driven Sampling Data,
Annual Review of Statistics and Its Application
&lt;doi:10.1146/annurev-statistics-031017-100704&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDS.I.estimates">RDS.I.estimates</a></code>, <code><a href="#topic+RDS.I.estimates">RDS.I.estimates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(faux)
MA.estimates(rds.data=faux,trait.variable='X')

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.rds.data.frame'>Diagnostic plots for the RDS recruitment process</h2><span id='topic+plot.rds.data.frame'></span>

<h3>Description</h3>

<p>Diagnostic plots for the RDS recruitment process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rds.data.frame'
plot(
  x,
  plot.type = c("Recruitment tree", "Network size by wave", "Recruits by wave",
    "Recruits per seed", "Recruits per subject"),
  stratify.by = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rds.data.frame_+3A_x">x</code></td>
<td>
<p>An rds.data.frame object.</p>
</td></tr>
<tr><td><code id="plot.rds.data.frame_+3A_plot.type">plot.type</code></td>
<td>
<p>the type of diagnostic.</p>
</td></tr>
<tr><td><code id="plot.rds.data.frame_+3A_stratify.by">stratify.by</code></td>
<td>
<p>A factor used to color or stratify the plot elements.</p>
</td></tr>
<tr><td><code id="plot.rds.data.frame_+3A_...">...</code></td>
<td>
<p>Additional arguments for the underlying plot function if applicable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several types of diagnostics are supported by the plot.type argument.
'Recruitment tree' displays a network plot of the RDS recruitment process.
'Network size by wave' monitors systematic changes is network size based on how far subjects are from the seed
'Recruits by wave' displays counts of subjects based on how far they rare from their seed.
'Recruit per seed' shows the total tree size for each seed.
'Recruits per subject' shows counts of how many subjects are recruited by each subject who are non-terminal.
</p>


<h3>Value</h3>

<p>Either nothing (for the recruitment tree plot), or a ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fauxmadrona)
## Not run: 
plot(fauxmadrona)

## End(Not run)
plot(fauxmadrona, plot.type='Recruits by wave')
plot(fauxmadrona, plot.type='Recruits per seed')
plot(fauxmadrona, plot.type='Recruits per subject')

plot(fauxmadrona, plot.type='Recruits by wave', stratify.by='disease')
plot(fauxmadrona, plot.type='Recruits per seed', stratify.by='disease')
plot(fauxmadrona, plot.type='Recruits per subject', stratify.by='disease')
</code></pre>

<hr>
<h2 id='print.differential.activity.estimate'>Prints an differential.activity.estimate object</h2><span id='topic+print.differential.activity.estimate'></span>

<h3>Description</h3>

<p>Prints an differential.activity.estimate object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'differential.activity.estimate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.differential.activity.estimate_+3A_x">x</code></td>
<td>
<p>an differential.activity.estimate object</p>
</td></tr>
<tr><td><code id="print.differential.activity.estimate_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='print.pvalue.table'>Displays a pvalue.table</h2><span id='topic+print.pvalue.table'></span>

<h3>Description</h3>

<p>Displays a pvalue.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pvalue.table'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pvalue.table_+3A_x">x</code></td>
<td>
<p>a pvalue.table object</p>
</td></tr>
<tr><td><code id="print.pvalue.table_+3A_...">...</code></td>
<td>
<p>additional parameters passed to print.data.frame.</p>
</td></tr>
</table>

<hr>
<h2 id='print.rds.contin.bootstrap'>Displays an rds.contin.bootstrap</h2><span id='topic+print.rds.contin.bootstrap'></span>

<h3>Description</h3>

<p>Displays an rds.contin.bootstrap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rds.contin.bootstrap'
print(x, show.table = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rds.contin.bootstrap_+3A_x">x</code></td>
<td>
<p>an rds.contin.bootstrap object</p>
</td></tr>
<tr><td><code id="print.rds.contin.bootstrap_+3A_show.table">show.table</code></td>
<td>
<p>Display weighted contingency table</p>
</td></tr>
<tr><td><code id="print.rds.contin.bootstrap_+3A_...">...</code></td>
<td>
<p>additional parameters passed to print.matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='print.rds.data.frame'>Displays an rds.data.frame</h2><span id='topic+print.rds.data.frame'></span>

<h3>Description</h3>

<p>Displays an rds.data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rds.data.frame'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rds.data.frame_+3A_x">x</code></td>
<td>
<p>an rds.data.frame object</p>
</td></tr>
<tr><td><code id="print.rds.data.frame_+3A_...">...</code></td>
<td>
<p>additional parameters passed to print.data.frame.</p>
</td></tr>
</table>

<hr>
<h2 id='print.rds.interval.estimate'>Prints an <code>rds.interval.estimate</code> object</h2><span id='topic+print.rds.interval.estimate'></span>

<h3>Description</h3>

<p>Prints an <code>rds.interval.estimate</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rds.interval.estimate'
print(x, as.percentage = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rds.interval.estimate_+3A_x">x</code></td>
<td>
<p>an <code>rds.interval.estimate</code> object</p>
</td></tr>
<tr><td><code id="print.rds.interval.estimate_+3A_as.percentage">as.percentage</code></td>
<td>
<p>logical. Print the interval estimates
as percentages (as distinct from proportions). 
The default, NULL, means that it will determine if
the variable is discrete or continuous and only print them as percentages if they are discrete.</p>
</td></tr>
<tr><td><code id="print.rds.interval.estimate_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.svyglm.RDS'>Summarizing Generalized Linear Model Fits with Odds Ratios</h2><span id='topic+print.summary.svyglm.RDS'></span>

<h3>Description</h3>

<p><code>print.summary.svyglm.RDS</code> is a version of <code>print.summary.svyglm</code> that 
reports odds-ratios in place of coefficients in the summary table. 
This only applies for the <code>binomial</code> family. Otherwise it is identical to
<code>print.summary.svyglm</code>.
The default in<br />
<code>print.summary.svyglm</code> is to display the log-odds-ratios 
and this displays the exponetiated from
and a 95
p-values are still displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.svyglm.RDS'
print(
  x,
  digits = max(3, getOption("digits") - 3),
  symbolic.cor = x$symbolic.cor,
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.svyglm.RDS_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.svyglm.RDS"</code>, usually, a result of a
call to <code>RDS::summary.svyglm</code>.</p>
</td></tr>
<tr><td><code id="print.summary.svyglm.RDS_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="print.summary.svyglm.RDS_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical. If <code>TRUE</code>, print the correlations in a
symbolic form (see <code><a href="stats.html#topic+symnum">symnum</a></code>) rather than as numbers.</p>
</td></tr>
<tr><td><code id="print.summary.svyglm.RDS_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, &lsquo;significance stars&rsquo; are
printed for each coefficient.</p>
</td></tr>
<tr><td><code id="print.summary.svyglm.RDS_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="survey.html#topic+svyglm">svyglm</a></code>, <code><a href="survey.html#topic+summary.svyglm">summary.svyglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## For examples see example(svyglm)

</code></pre>

<hr>
<h2 id='RDS.bootstrap.intervals'>RDS Bootstrap Interval Estimates</h2><span id='topic+RDS.bootstrap.intervals'></span>

<h3>Description</h3>

<p>This function computes an interval estimate for one or more categorical
variables. It optionally uses attributes of the RDS data set to determine
the type of estimator and type of uncertainty estimate to use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDS.bootstrap.intervals(
  rds.data,
  outcome.variable,
  weight.type = NULL,
  uncertainty = NULL,
  N = NULL,
  subset = NULL,
  confidence.level = 0.95,
  number.of.bootstrap.samples = NULL,
  fast = TRUE,
  useC = TRUE,
  ci.type = "t",
  control = control.rds.estimates(),
  to.factor = FALSE,
  cont.breaks = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDS.bootstrap.intervals_+3A_rds.data">rds.data</code></td>
<td>
<p>An <code>rds.data.frame</code> that indicates recruitment patterns
by a pair of attributes named &ldquo;id&rdquo; and &ldquo;recruiter.id&rdquo;.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>A string giving the name of the variable in the
<code>rds.data</code> that contains a categorical or numeric variable to be
analyzed.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_weight.type">weight.type</code></td>
<td>
<p>A string giving the type of estimator to use. The options
are <code>"Gile's SS"</code>, <code>"RDS-I"</code>, <code>"RDS-II"</code>, <code>"RDS-I (DS)"</code>,
and <code>"Arithemic Mean"</code>. If <code>NULL</code> it defaults to <code>"Gile's
SS"</code>.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_uncertainty">uncertainty</code></td>
<td>
<p>A string giving the type of uncertainty estimator to use.
The options are <code>"SRS"</code>, <code>"Gile"</code> and <code>"Salganik"</code>. This is usually
determined by <code>weight.type</code> to be consistent with the estimator's
origins. The estimators RDS-I, RDS-I (DS), and RDS-II default to <code>"Salganik"</code>,  &quot;Arithmetic
Mean&quot; defaults to <code>"SRS"</code> and &quot;Gile's SS&quot; defaults to the <code>"Gile"</code> bootstrap.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_n">N</code></td>
<td>
<p>An estimate of the number of members of the population being
sampled. If <code>NULL</code> it is read as the <code>population.size.mid</code> attribute of
the <code>rds.data</code> frame. If that is missing it defaults to 1000.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_subset">subset</code></td>
<td>
<p>An optional criterion to subset <code>rds.data</code> by. It is a
character string giving an R expression which, when evaluated, subset the
data. In plain English, it can be something like <code>"seed &gt; 0"</code> to
exclude seeds. It can be the name of a logical vector of the same length of
the outcome variable where TRUE means include it in the analysis. If
<code>NULL</code> then no subsetting is done.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_confidence.level">confidence.level</code></td>
<td>
<p>The confidence level for the confidence intervals.
The default is 0.95 for 95%.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_number.of.bootstrap.samples">number.of.bootstrap.samples</code></td>
<td>
<p>The number of bootstrap samples to take
in estimating the uncertainty of the estimator. If <code>NULL</code> it defaults
to the number necessary to compute the standard error to accuracy 0.001.
<code>outcome.variable</code>. Otherwise it will compute the population frequencies of each value of the <code>outcome.variable</code>.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_fast">fast</code></td>
<td>
<p>Use a fast bootstrap where the weights are reused from the
estimator rather than being recomputed for each bootstrap sample.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_usec">useC</code></td>
<td>
<p>Use a C-level implementation of Gile's bootstrap (rather than
the R level). The implementations should be a computational
equivalent estimator (except for speed).</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_ci.type">ci.type</code></td>
<td>
<p>Type of confidence interval to use, if possible. If &quot;t&quot;, use lower and upper confidence
interval values based on the standard deviation of the bootstrapped values and a t multiplier.
If &quot;pivotal&quot;, use lower and upper confidence interval values based on the
basic bootstrap (also called the pivotal confidence interval).
If &quot;quantile&quot;, use lower and upper confidence interval values based on the
quantiles of the bootstrap sample.
If &quot;proportion&quot;, use the &quot;t&quot; unless the estimated proportion is less than 0.15 or the bounds are
outside [0,1 . In this case, try the &quot;quantile&quot; and constrain the bounds to be compatible with [0,1].</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm
tuning. Constructed using<br />
<code><a href="#topic+control.rds.estimates">control.rds.estimates</a></code>.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_to.factor">to.factor</code></td>
<td>
<p>force variable to be a factor</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_cont.breaks">cont.breaks</code></td>
<td>
<p>For continuous variates, some bootstrap proceedures require categorical data.
In these cases, in order to contruct each bootstrap replicate, the outcome variable is split into
cont.breaks categories.</p>
</td></tr>
<tr><td><code id="RDS.bootstrap.intervals_+3A_...">...</code></td>
<td>
<p>Additional arguments for RDS.*.estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>rds.interval.estimate</code> summarizing the inference.
The confidence interval and standard error are based on the bootstrap procedure.
In additon, the object has attribute <code>bsresult</code> which provides details of the
bootstrap procedure. The contents of the <code>bsresult</code> attribute depends on the
<code>uncertainty</code> used. If <code>uncertainty=="Salganik"</code> then <code>bsresult</code> is a
vector of standard deviations of the bootstrap samples.
If <code>uncertainty=="Gile's SS"</code> then
<code>bsresult</code> is a list with components for the bootstrap point estimate,
the bootstrap
samples themselves and the standard deviations of the bootstrap samples.
If <code>uncertainty=="SRS"</code> then <code>bsresult</code> is NULL.
</p>


<h3>References</h3>

<p>Gile, Krista J. 2011 <em>Improved Inference for
Respondent-Driven Sampling Data with Application to HIV Prevalence
Estimation</em>, <em>Journal of the American Statistical Association</em>, 106,
135-146.
</p>
<p>Gile, Krista J., Handcock, Mark S., 2010. Respondent-driven Sampling:
An Assessment of Current Methodology, Sociological Methodology, 40,
285-327. &lt;doi:10.1111/j.1467-9531.2010.01223.x&gt;
</p>
<p>Gile, Krista J., Beaudry, Isabelle S. and Handcock, Mark S., 2018 
Methods for Inference from Respondent-Driven Sampling Data,
Annual Review of Statistics and Its Application
&lt;doi:10.1146/annurev-statistics-031017-100704&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(fauxmadrona)
RDS.bootstrap.intervals(rds.data=fauxmadrona,weight.type="RDS-II",
     uncertainty="Salganik",
	outcome.variable="disease",N=1000,number.of.bootstrap.samples=50)

data(fauxtime)
RDS.bootstrap.intervals(rds.data=fauxtime,weight.type="HCG",
     uncertainty="HCG",
	outcome.variable="var1",N=1000,number.of.bootstrap.samples=10)

## End(Not run)

</code></pre>

<hr>
<h2 id='RDS.compare.proportions'>Compares the rates of two variables against one another.</h2><span id='topic+RDS.compare.proportions'></span>

<h3>Description</h3>

<p>Compares the rates of two variables against one another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDS.compare.proportions(first.interval, second.interval, M = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDS.compare.proportions_+3A_first.interval">first.interval</code></td>
<td>
<p>An <code>rds.interval.estimate</code> object fit with either &quot;Gile&quot; or &quot;Salganik&quot; uncertainty.</p>
</td></tr>
<tr><td><code id="RDS.compare.proportions_+3A_second.interval">second.interval</code></td>
<td>
<p>An <code>rds.interval.estimate</code> object fit with either &quot;Gile&quot; or &quot;Salganik&quot; uncertainty.</p>
</td></tr>
<tr><td><code id="RDS.compare.proportions_+3A_m">M</code></td>
<td>
<p>The number of bootstrap resamplings to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function preforms a bootstrap test comparing the 
the rates of two variables against one another.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(faux)
int1 &lt;- RDS.bootstrap.intervals(faux, outcome.variable=c("X"), 
weight.type="RDS-II", uncertainty="Salganik", N=1000,
number.ss.samples.per.iteration=1000, 
	confidence.level=0.95, number.of.bootstrap.samples=100)
int2 &lt;- RDS.bootstrap.intervals(faux, outcome.variable=c("Y"), 
	weight.type="RDS-II", uncertainty="Salganik", N=1000,
number.ss.samples.per.iteration=1000,
confidence.level=0.95, number.of.bootstrap.samples=100)
RDS.compare.proportions(int1,int2)

## End(Not run)
</code></pre>

<hr>
<h2 id='RDS.compare.two.proportions'>Compares the rates of two variables against one another.</h2><span id='topic+RDS.compare.two.proportions'></span>

<h3>Description</h3>

<p>Compares the rates of two variables against one another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDS.compare.two.proportions(
  data,
  variables,
  confidence.level = 0.95,
  number.of.bootstrap.samples = 5000,
  plot = FALSE,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDS.compare.two.proportions_+3A_data">data</code></td>
<td>
<p>An object of class <code>rds.interval.estimates.list</code> with attribute <br />
<code>variables</code> containing a character vector of names of objects of class<br />
<code>rds.interval.estimate</code>.</p>
</td></tr>
<tr><td><code id="RDS.compare.two.proportions_+3A_variables">variables</code></td>
<td>
<p>A character vector of column names to select from <code>data</code>.</p>
</td></tr>
<tr><td><code id="RDS.compare.two.proportions_+3A_confidence.level">confidence.level</code></td>
<td>
<p>The confidence level for the confidence intervals. The default is 0.95 for 95%.</p>
</td></tr>
<tr><td><code id="RDS.compare.two.proportions_+3A_number.of.bootstrap.samples">number.of.bootstrap.samples</code></td>
<td>
<p>The number of Monte Carlo draws to determine the null distribution of the likelihood
ratio statistic.</p>
</td></tr>
<tr><td><code id="RDS.compare.two.proportions_+3A_plot">plot</code></td>
<td>
<p>Logical, if TRUE then a plot is produces of the null distribution of the likelihood
ratio statistic with the observed statistics plotted as a vertical dashed line.</p>
</td></tr>
<tr><td><code id="RDS.compare.two.proportions_+3A_seed">seed</code></td>
<td>
<p>The value of the random number seed. Preset by default to allow reproducability.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>pvalue.table</code> containing the cross-tabulation of p-values
for comparing the two classes
</p>

<hr>
<h2 id='RDS.HCG.estimates'>Homophily Configuration Graph Estimates</h2><span id='topic+RDS.HCG.estimates'></span>

<h3>Description</h3>

<p>This function computes the Homophily Configuration Graph type estimates for a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDS.HCG.estimates(
  rds.data,
  outcome.variable,
  N = NULL,
  subset = NULL,
  small.fraction = FALSE,
  empir.lik = TRUE,
  to.factor = FALSE,
  cont.breaks = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDS.HCG.estimates_+3A_rds.data">rds.data</code></td>
<td>
<p>An <code>rds.data.frame</code> with recruitment time set.</p>
</td></tr>
<tr><td><code id="RDS.HCG.estimates_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>A string giving the name of the variable in the
<code>rds.data</code> that contains a categorical variable to be analyzed.</p>
</td></tr>
<tr><td><code id="RDS.HCG.estimates_+3A_n">N</code></td>
<td>
<p>Population size to be used to calculate the empirical likelihood interval. If NULL, this value is
taken to be the population.size.mid attribute of the data and if that is not set, no finite population
correction is used.</p>
</td></tr>
<tr><td><code id="RDS.HCG.estimates_+3A_subset">subset</code></td>
<td>
<p>An optional criterion to subset <code>rds.data</code> by. It is
an R expression which, when evaluated, subset the
data. In plain English, it can be something like <code>subset = seed &gt; 0</code> to
exclude seeds. It can also be the name of a logical vector of the same length of
the outcome variable where TRUE means include it in the analysis. If
<code>NULL</code> then no subsetting is done.</p>
</td></tr>
<tr><td><code id="RDS.HCG.estimates_+3A_small.fraction">small.fraction</code></td>
<td>
<p>Should a small sample fraction be assumed</p>
</td></tr>
<tr><td><code id="RDS.HCG.estimates_+3A_empir.lik">empir.lik</code></td>
<td>
<p>Should confidence intervals be estimated using 
empirical likelihood.</p>
</td></tr>
<tr><td><code id="RDS.HCG.estimates_+3A_to.factor">to.factor</code></td>
<td>
<p>force variable to be a factor</p>
</td></tr>
<tr><td><code id="RDS.HCG.estimates_+3A_cont.breaks">cont.breaks</code></td>
<td>
<p>If variable is numeric, how many discretization points should be used in the calculation of the weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the <code>empir.lik</code> is true, an object of class
<code>rds.interval.estimate</code> is returned. This is a list with components
</p>
 <ul>
<li><p><code>estimate</code>: The numerical point estimate of proportion
of the <code>trait.variable</code>.  </p>
</li>
<li><p><code>interval</code>: A matrix with six
columns and one row per category of <code>trait.variable</code>: </p>

<ul>
<li><p><code>point estimate</code>: The HT estimate of the population mean.
</p>
</li>
<li><p><code>95% Lower Bound</code>: Lower 95% confidence bound.  </p>
</li>
<li><p><code>95%
Upper Bound</code>: Upper 95% confidence bound.  </p>
</li>
<li><p><code>Design Effect</code>: The
design effect of the RDS.  </p>
</li>
<li><p><code>s.e.</code>: Standard error.  </p>
</li>
<li><p><code>n</code>:
Count of the number of sample values with that value of the trait.  </p>
</li></ul>
 </li></ul>

<p>Otherwise an object of class <code>rds.HCG.estimate</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Ian E. Fellows
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDS.I.estimates">RDS.I.estimates</a></code>, <code><a href="#topic+RDS.II.estimates">RDS.II.estimates</a></code>, <code><a href="#topic+RDS.SS.estimates">RDS.SS.estimates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fauxtime)
RDS.HCG.estimates(rds.data=fauxtime,outcome.variable='var1')
</code></pre>

<hr>
<h2 id='RDS.I.estimates'>Compute RDS-I Estimates</h2><span id='topic+RDS.I.estimates'></span>

<h3>Description</h3>

<p>This function computes the RDS-I type estimates for a categorical variable.
It is also referred to as the Salganik-Heckathorn estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDS.I.estimates(
  rds.data,
  outcome.variable,
  N = NULL,
  subset = NULL,
  smoothed = FALSE,
  empir.lik = TRUE,
  to.factor = FALSE,
  cont.breaks = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDS.I.estimates_+3A_rds.data">rds.data</code></td>
<td>
<p>An <code>rds.data.frame</code> that indicates recruitment patterns
by a pair of attributes named &ldquo;id&rdquo; and &ldquo;recruiter.id&rdquo;.</p>
</td></tr>
<tr><td><code id="RDS.I.estimates_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>A string giving the name of the variable in the
<code>rds.data</code> that contains a categorical variable to be analyzed.</p>
</td></tr>
<tr><td><code id="RDS.I.estimates_+3A_n">N</code></td>
<td>
<p>Population size to be used to calculate the empirical likelihood interval. If NULL, this value is
taken to be the population.size.mid attribute of the data and if that is not set, no finite population
correction is used.</p>
</td></tr>
<tr><td><code id="RDS.I.estimates_+3A_subset">subset</code></td>
<td>
<p>An optional criterion to subset <code>rds.data</code> by. It is
an R expression which, when evaluated, subset the
data. In plain English, it can be something like <code>subset = seed &gt; 0</code> to
exclude seeds. It can also be the name of a logical vector of the same length of
the outcome variable where TRUE means include it in the analysis. If
<code>NULL</code> then no subsetting is done.</p>
</td></tr>
<tr><td><code id="RDS.I.estimates_+3A_smoothed">smoothed</code></td>
<td>
<p>Logical, if TRUE then the &ldquo;data smoothed&rdquo; version of RDS-I is used,
where it is assumed that the observed Markov process is reversible.</p>
</td></tr>
<tr><td><code id="RDS.I.estimates_+3A_empir.lik">empir.lik</code></td>
<td>
<p>Should confidence intervals be estimated using 
empirical likelihood.</p>
</td></tr>
<tr><td><code id="RDS.I.estimates_+3A_to.factor">to.factor</code></td>
<td>
<p>force variable to be a factor</p>
</td></tr>
<tr><td><code id="RDS.I.estimates_+3A_cont.breaks">cont.breaks</code></td>
<td>
<p>The number of categories used for the RDS-I adjustment when the variate is continuous.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the <code>empir.lik</code> is true, an object of class
<code>rds.interval.estimate</code> is returned. This is a list with components
</p>
 <ul>
<li><p><code>estimate</code>: The numerical point estimate of proportion
of the <code>trait.variable</code>.  </p>
</li>
<li><p><code>interval</code>: A matrix with six
columns and one row per category of <code>trait.variable</code>: </p>

<ul>
<li><p><code>point estimate</code>: The HT estimate of the population mean.
</p>
</li>
<li><p><code>95% Lower Bound</code>: Lower 95% confidence bound.  </p>
</li>
<li><p><code>95%
Upper Bound</code>: Upper 95% confidence bound.  </p>
</li>
<li><p><code>Design Effect</code>: The
design effect of the RDS.  </p>
</li>
<li><p><code>s.e.</code>: Standard error.  </p>
</li>
<li><p><code>n</code>:
Count of the number of sample values with that value of the trait.  </p>
</li></ul>
 </li></ul>

<p>Otherwise an object of class <code>rds.I.estimate</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Mark S. Handcock and W. Whipple Neely
</p>


<h3>References</h3>

<p>Gile, Krista J., Handcock, Mark S., 2010. Respondent-driven Sampling:
An Assessment of Current Methodology, Sociological Methodology, 40,
285-327. &lt;doi:10.1111/j.1467-9531.2010.01223.x&gt;
</p>
<p>Gile, Krista J., Beaudry, Isabelle S. and Handcock, Mark S., 2018 
Methods for Inference from Respondent-Driven Sampling Data,
Annual Review of Statistics and Its Application
&lt;doi:10.1146/annurev-statistics-031017-100704&gt;.
</p>
<p>Neely, W. W., 2009. <em>Bayesian methods for data from respondent driven
sampling</em>. Dissertation in-progress, Department of Statistics, University of
Wisconsin, Madison.
</p>
<p>Salganik, M., Heckathorn, D. D., 2004. <em>Sampling and estimation in
hidden populations using respondent-driven sampling</em>. Sociological
Methodology 34, 193-239.
</p>
<p>Volz, E., Heckathorn, D., 2008. <em>Probability based estimation theory
for Respondent Driven Sampling</em>. The Journal of Official Statistics 24 (1),
79-97.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDS.II.estimates">RDS.II.estimates</a></code>, <code><a href="#topic+RDS.SS.estimates">RDS.SS.estimates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux)
RDS.I.estimates(rds.data=faux,outcome.variable='X')
RDS.I.estimates(rds.data=faux,outcome.variable='X',smoothed=TRUE)
</code></pre>

<hr>
<h2 id='rds.I.weights'>RDS-I weights</h2><span id='topic+rds.I.weights'></span>

<h3>Description</h3>

<p>RDS-I weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rds.I.weights(rds.data, outcome.variable, N = NULL, smoothed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rds.I.weights_+3A_rds.data">rds.data</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
<tr><td><code id="rds.I.weights_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>The variable used to base the weights on.</p>
</td></tr>
<tr><td><code id="rds.I.weights_+3A_n">N</code></td>
<td>
<p>Population size</p>
</td></tr>
<tr><td><code id="rds.I.weights_+3A_smoothed">smoothed</code></td>
<td>
<p>Should the data smoothed RDS-I weights be computed.</p>
</td></tr>
<tr><td><code id="rds.I.weights_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>

<hr>
<h2 id='RDS.II.estimates'>RDS-II Estimates</h2><span id='topic+RDS.II.estimates'></span>

<h3>Description</h3>

<p>This function computes the RDS-II estimates for a categorical variable or
the RDS-II estimate for a numeric variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDS.II.estimates(
  rds.data,
  outcome.variable,
  N = NULL,
  subset = NULL,
  empir.lik = TRUE,
  to.factor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDS.II.estimates_+3A_rds.data">rds.data</code></td>
<td>
<p>An <code>rds.data.frame</code> that indicates recruitment patterns
by a pair of attributes named &ldquo;id&rdquo; and &ldquo;recruiter.id&rdquo;.</p>
</td></tr>
<tr><td><code id="RDS.II.estimates_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>A string giving the name of the variable in the
<code>rds.data</code> that contains a categorical or numeric variable to be
analyzed.</p>
</td></tr>
<tr><td><code id="RDS.II.estimates_+3A_n">N</code></td>
<td>
<p>Population size to be used to calculate the empirical likelihood interval. If NULL, this value is
taken to be the population.size.mid attribute of the data and if that is not set, no finite population
correction is used.</p>
</td></tr>
<tr><td><code id="RDS.II.estimates_+3A_subset">subset</code></td>
<td>
<p>An optional criterion to subset <code>rds.data</code> by. It is
an R expression which, when evaluated, subset the
data. In plain English, it can be something like <code>subset = seed &gt; 0</code> to
exclude seeds. It can also be the name of a logical vector of the same length of
the outcome variable where TRUE means include it in the analysis. If
<code>NULL</code> then no subsetting is done.</p>
</td></tr>
<tr><td><code id="RDS.II.estimates_+3A_empir.lik">empir.lik</code></td>
<td>
<p>If true, and outcome.variable is numeric, standard errors
based on empirical likelihood will be given.</p>
</td></tr>
<tr><td><code id="RDS.II.estimates_+3A_to.factor">to.factor</code></td>
<td>
<p>force variable to be a factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>outcome.variable</code> is numeric then the RDS-II estimate of the mean is returned, otherwise a vector of proportion estimates is returned.
If the <code>empir.lik</code> is true, an object of class <code>rds.interval.estimate</code> is returned. This is a list with components
</p>
 <ul>
<li><p><code>estimate</code>: The numerical point estimate of proportion
of the <code>trait.variable</code>.  </p>
</li>
<li><p><code>interval</code>: A matrix with six
columns and one row per category of <code>trait.variable</code>: </p>

<ul>
<li><p><code>point estimate</code>: The HT estimate of the population mean.
</p>
</li>
<li><p><code>95% Lower Bound</code>: Lower 95% confidence bound.  </p>
</li>
<li><p><code>95%
Upper Bound</code>: Upper 95% confidence bound.  </p>
</li>
<li><p><code>Design Effect</code>: The
design effect of the RDS.  </p>
</li>
<li><p><code>s.e.</code>: Standard error.  </p>
</li>
<li><p><code>n</code>:
Count of the number of sample values with that value of the trait.  </p>
</li></ul>
 </li></ul>

<p>Otherwise, an object of class <code>rds.II.estimate</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Mark S. Handcock and W. Whipple Neely
</p>


<h3>References</h3>

<p>Gile, Krista J., Handcock, Mark S., 2010. Respondent-driven Sampling:
An Assessment of Current Methodology, Sociological Methodology, 40,
285-327. &lt;doi:10.1111/j.1467-9531.2010.01223.x&gt;
</p>
<p>Gile, Krista J., Beaudry, Isabelle S. and Handcock, Mark S., 2018 
Methods for Inference from Respondent-Driven Sampling Data,
Annual Review of Statistics and Its Application
&lt;doi:10.1146/annurev-statistics-031017-100704&gt;.
</p>
<p>Salganik, M., Heckathorn, D. D., 2004. <em>Sampling and estimation in
hidden populations using respondent-driven sampling</em>. Sociological
Methodology 34, 193-239.
</p>
<p>Volz, E., Heckathorn, D., 2008. <em>Probability based estimation theory
for Respondent Driven Sampling</em>. The Journal of Official Statistics 24 (1),
79-97.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDS.I.estimates">RDS.I.estimates</a></code>, <code><a href="#topic+RDS.SS.estimates">RDS.SS.estimates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux)
RDS.II.estimates(rds.data=faux,outcome.variable='X')
RDS.II.estimates(rds.data=faux,outcome.variable='X',subset= Y!="blue")

</code></pre>

<hr>
<h2 id='rds.interval.estimate'>An object of class rds.interval.estimate</h2><span id='topic+rds.interval.estimate'></span>

<h3>Description</h3>

<p>This function creates an object of class <code>rds.interval.estimate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rds.interval.estimate(
  estimate,
  outcome.variable,
  weight.type,
  uncertainty,
  weights,
  N = NULL,
  conf.level = 0.95,
  csubset = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rds.interval.estimate_+3A_estimate">estimate</code></td>
<td>
<p>The numerical point estimate of proportion of the
<code>trait.variable</code>.</p>
</td></tr>
<tr><td><code id="rds.interval.estimate_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>A string giving the name of the variable in the
<code>rds.data</code> that contains a categorical variable to be analyzed.</p>
</td></tr>
<tr><td><code id="rds.interval.estimate_+3A_weight.type">weight.type</code></td>
<td>
<p>A string giving the type of estimator to use. The options
are <code>"Gile's SS"</code>, <code>"RDS-I"</code>, <code>"RDS-II"</code>, <code>"RDS-I
(DS)"</code>, and <code>"Arithemic Mean"</code>. If <code>NULL</code> it defaults to
<code>"Gile's SS"</code>.</p>
</td></tr>
<tr><td><code id="rds.interval.estimate_+3A_uncertainty">uncertainty</code></td>
<td>
<p>A string giving the type of uncertainty estimator to use.
The options are <code>"SRS"</code>, <code>"Gile"</code> and <code>"Salganik"</code>. This is
usually determined by <code>weight.type</code> to be consistent with the
estimator's origins. The estimators <code>"RDS-I"</code>, <code>"RDS-I (DS)"</code>, <code>"RDS-II"</code> default to
<code>"Salganik"</code>, &quot;Arithmetic Mean&quot; defaults to <code>"SRS"</code> and &quot;Gile's
SS&quot; defaults to the <code>"Gile"</code> bootstrap.</p>
</td></tr>
<tr><td><code id="rds.interval.estimate_+3A_weights">weights</code></td>
<td>
<p>A numerical vector of sampling weights for the sample, in
order of the sample.  They should be inversely proportional to the
first-order inclusion probabilites, although this is not assessed or
inforced.</p>
</td></tr>
<tr><td><code id="rds.interval.estimate_+3A_n">N</code></td>
<td>
<p>An estimate of the number of members of the population being
sampled. If <code>NULL</code> it is read as the <code>pop.size.mid</code> attribute of
the <code>rds.data</code> frame. If that is missing it defaults to 1000.</p>
</td></tr>
<tr><td><code id="rds.interval.estimate_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level for the confidence intervals. The
default is 0.95 for 95%.</p>
</td></tr>
<tr><td><code id="rds.interval.estimate_+3A_csubset">csubset</code></td>
<td>
<p>A character string representing text to add to the output label. Typically
this will be the expression used it define the subset of the data used  for the estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>rds.interval.estimate</code> is returned. This is
a list with components </p>
 <ul>
<li><p><code>estimate</code>: The numerical point
estimate of proportion of the <code>trait.variable</code>.  </p>
</li>
<li><p><code>interval</code>:
A matrix with six columns and one row per category of <code>trait.variable</code>:
</p>
 <ul>
<li><p><code>point estimate</code>: The HT estimate of the population
mean.  </p>
</li>
<li><p><code>95% Lower Bound</code>: Lower 95% confidence bound.
</p>
</li>
<li><p><code>95% Upper Bound</code>: Upper 95% confidence bound.  </p>
</li>
<li><p><code>Design
Effect</code>: The design effect of the RDS.  </p>
</li>
<li><p><code>s.e.</code>: Standard error.
</p>
</li>
<li><p><code>n</code>: Count of the number of sample values with that value of the
trait.  </p>
</li></ul>
 </li></ul>



<h3>Author(s)</h3>

<p>Mark S. Handcock
</p>


<h3>References</h3>

<p>Gile, Krista J., Handcock, Mark S., 2010. Respondent-driven Sampling:
An Assessment of Current Methodology, Sociological Methodology, 40,
285-327. &lt;doi:10.1111/j.1467-9531.2010.01223.x&gt;
</p>
<p>Gile, Krista J., Beaudry, Isabelle S. and Handcock, Mark S., 2018 
Methods for Inference from Respondent-Driven Sampling Data,
Annual Review of Statistics and Its Application
&lt;doi:10.1146/annurev-statistics-031017-100704&gt;.
</p>
<p>Salganik, M., Heckathorn, D. D., 2004. <em>Sampling and estimation in
hidden populations using respondent-driven sampling</em>. Sociological
Methodology 34, 193-239.
</p>
<p>Volz, E., Heckathorn, D., 2008. <em>Probability based estimation theory
for Respondent Driven Sampling</em>. The Journal of Official Statistics 24 (1),
79-97.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux)
RDS.I.estimates(rds.data=faux,outcome.variable='X',smoothed=TRUE)

</code></pre>

<hr>
<h2 id='RDS.SS.estimates'>Gile's SS Estimates</h2><span id='topic+RDS.SS.estimates'></span>

<h3>Description</h3>

<p>This function computes the sequential sampling (SS) estimates for a
categorical variable or numeric variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDS.SS.estimates(
  rds.data,
  outcome.variable,
  N = NULL,
  subset = NULL,
  number.ss.samples.per.iteration = 500,
  number.ss.iterations = 5,
  control = control.rds.estimates(),
  hajek = TRUE,
  empir.lik = TRUE,
  to.factor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDS.SS.estimates_+3A_rds.data">rds.data</code></td>
<td>
<p>An <code>rds.data.frame</code> that indicates recruitment patterns
by a pair of attributes named &ldquo;id&rdquo; and &ldquo;recruiter.id&rdquo;.</p>
</td></tr>
<tr><td><code id="RDS.SS.estimates_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>A string giving the name of the variable in the
<code>rds.data</code> that contains a categorical or numeric variable to be
analyzed.</p>
</td></tr>
<tr><td><code id="RDS.SS.estimates_+3A_n">N</code></td>
<td>
<p>An estimate of the number of members of the population being
sampled. If <code>NULL</code> it is read as the <code>population.size.mid</code> attribute of
the <code>rds.data</code> frame. If that is missing it defaults to 1000.</p>
</td></tr>
<tr><td><code id="RDS.SS.estimates_+3A_subset">subset</code></td>
<td>
<p>An optional criterion to subset <code>rds.data</code> by. It is
an R expression which, when evaluated, subset the
data. In plain English, it can be something like <code>subset = seed &gt; 0</code> to
exclude seeds. It can also be the name of a logical vector of the same length of
the outcome variable where TRUE means include it in the analysis. If
<code>NULL</code> then no subsetting is done.</p>
</td></tr>
<tr><td><code id="RDS.SS.estimates_+3A_number.ss.samples.per.iteration">number.ss.samples.per.iteration</code></td>
<td>
<p>The number of samples to take in
estimating the inclusion probabilites in each iteration of the sequential
sampling algorithm. If <code>NULL</code> it is read as the
eponymous attribute of <code>rds.data</code>. If that
is missing it defaults to 5000.</p>
</td></tr>
<tr><td><code id="RDS.SS.estimates_+3A_number.ss.iterations">number.ss.iterations</code></td>
<td>
<p>The number of iterations of the sequential
sampling algorithm. If that is missing it defaults to 5.</p>
</td></tr>
<tr><td><code id="RDS.SS.estimates_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm
tuning. Constructed using<br />
<code><a href="#topic+control.rds.estimates">control.rds.estimates</a></code>.</p>
</td></tr>
<tr><td><code id="RDS.SS.estimates_+3A_hajek">hajek</code></td>
<td>
<p>logical; Use the standard Hajek-type estimator of Gile (2011)
or the standard Hortitz-Thompson. The default is TRUE.</p>
</td></tr>
<tr><td><code id="RDS.SS.estimates_+3A_empir.lik">empir.lik</code></td>
<td>
<p>If true, and outcome.variable is numeric, standard errors
based on empirical likelihood will be given.</p>
</td></tr>
<tr><td><code id="RDS.SS.estimates_+3A_to.factor">to.factor</code></td>
<td>
<p>force variable to be a factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>outcome.variable</code> is numeric then the Gile SS estimate of the mean is returned, otherwise a vector of proportion estimates is returned.
If the <code>empir.lik</code> is true, an object of class <code>rds.interval.estimate</code> is returned. This is a list with components
</p>
 <ul>
<li><p><code>estimate</code>: The numerical point estimate of proportion
of the <code>trait.variable</code>.  </p>
</li>
<li><p><code>interval</code>: A matrix with six
columns and one row per category of <code>trait.variable</code>: </p>

<ul>
<li><p><code>point estimate</code>: The HT estimate of the population mean.
</p>
</li>
<li><p><code>95% Lower Bound</code>: Lower 95% confidence bound.  </p>
</li>
<li><p><code>95%
Upper Bound</code>: Upper 95% confidence bound.  </p>
</li>
<li><p><code>Design Effect</code>: The
design effect of the RDS.  </p>
</li>
<li><p><code>s.e.</code>: Standard error.  </p>
</li>
<li><p><code>n</code>:
Count of the number of sample values with that value of the trait.  </p>
</li></ul>
 </li></ul>

<p>Otherwise, an object of class <code>rds.SS.estimate</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Krista J. Gile with help from Mark S. Handcock
</p>


<h3>References</h3>

<p>Gile, Krista J. 2011 <em>Improved Inference for Respondent-Driven Sampling
Data with Application to HIV Prevalence Estimation</em>, <em>Journal of the
American Statistical Association</em>, 106, 135-146.
</p>
<p>Gile, Krista J., Handcock, Mark S., 2010. Respondent-driven Sampling:
An Assessment of Current Methodology, Sociological Methodology, 40,
285-327. &lt;doi:10.1111/j.1467-9531.2010.01223.x&gt;
</p>
<p>Gile, Krista J., Beaudry, Isabelle S. and Handcock, Mark S., 2018 
Methods for Inference from Respondent-Driven Sampling Data,
Annual Review of Statistics and Its Application
&lt;doi:10.1146/annurev-statistics-031017-100704&gt;.
</p>
<p>Gile, Krista J., Handcock, Mark S., 2015 <em>Network Model-Assisted
Inference from Respondent-Driven Sampling Data</em>, Journal of the Royal Statistical Society, A. &lt;doi:10.1111/rssa.12091&gt;.
</p>
<p>Salganik, M., Heckathorn, D. D., 2004. <em>Sampling and estimation in
hidden populations using respondent-driven sampling</em>. Sociological
Methodology 34, 193-239.
</p>
<p>Volz, E., Heckathorn, D., 2008. <em>Probability based estimation theory
for Respondent Driven Sampling</em>. The Journal of Official Statistics 24 (1),
79-97.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDS.I.estimates">RDS.I.estimates</a></code>, <code><a href="#topic+RDS.II.estimates">RDS.II.estimates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fauxmadrona)
RDS.SS.estimates(rds.data=fauxmadrona,outcome.variable="disease",N=1000)

</code></pre>

<hr>
<h2 id='rdssampleC'>Create RDS samples with given characteristics</h2><span id='topic+rdssampleC'></span>

<h3>Description</h3>

<p>Create RDS samples with given characteristics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdssampleC(
  net,
  nnodes = network.size(net),
  nsamp0,
  fixinitial,
  nsamp,
  replace,
  coupons,
  select = NULL,
  bias = NULL,
  rds.samp = NULL,
  seed.distribution = NULL,
  attrall = FALSE,
  trait.variable = "disease",
  nsims = 1,
  seeds = NULL,
  prob.network.recall = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdssampleC_+3A_net">net</code></td>
<td>
<p>the network object from which to draw a sample</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_nnodes">nnodes</code></td>
<td>
<p>the number of nodes in the network [at least as default]</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_nsamp0">nsamp0</code></td>
<td>
<p>the number of seeds to be drawn (i.e. the size of the 0th wave of sampling)</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_fixinitial">fixinitial</code></td>
<td>
<p>a variable that indicates the distribution from which to draw the initial seeds, if the seeds
variable is NULL and the seed.distribution variable is NULL</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_nsamp">nsamp</code></td>
<td>
<p>number of individuals in each RDS sample</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_replace">replace</code></td>
<td>
<p>sampling with replacement</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_coupons">coupons</code></td>
<td>
<p>number of coupons</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_select">select</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_bias">bias</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_rds.samp">rds.samp</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_seed.distribution">seed.distribution</code></td>
<td>
<p>a variable [what kind?] that indicates the distribution from which to draw the initial seeds</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_attrall">attrall</code></td>
<td>
<p>Whether all the information about the sample should be returned [??]</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_trait.variable">trait.variable</code></td>
<td>
<p>attribute of interest</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_nsims">nsims</code></td>
<td>
<p>number of RDS samples to draw</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_seeds">seeds</code></td>
<td>
<p>an array of seeds. Default is NULL, in which case the function draws the seeds from the nodes of the network.</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_prob.network.recall">prob.network.recall</code></td>
<td>
<p>simulates the probability that an individual will remember any particular link</p>
</td></tr>
<tr><td><code id="rdssampleC_+3A_verbose">verbose</code></td>
<td>
<p>Print verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
nsample: vector of indices of sampled nodes
wsample: vector of waves of each sampled node
degsample: vector of degrees of sampled nodes
attrsample: vector of attrs of sampled nodes
toattr: vector of numbers of referrals to attrsd nodes
tonoattr: vector of number of referrans to unattrsd
nominators: recruiter of each sample
</p>

<hr>
<h2 id='read.rdsat'>Import data from the 'RDSAT' format as an <code>rds.data.frame</code></h2><span id='topic+read.rdsat'></span>

<h3>Description</h3>

<p>This function imports RDSAT data files as <code>rds.data.frame</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.rdsat(file, delim = c("&lt;auto&gt;", "\t", " ", ","), N = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.rdsat_+3A_file">file</code></td>
<td>
<p>the name of the file which the data are to be read from.
If it
does not contain an _absolute_ path, the file name is
_relative_ to the current working directory, 'getwd()'.
Tilde-expansion is performed where supported.  As from R
2.10.0 this can be a compressed file (see 'file')</p>
</td></tr>
<tr><td><code id="read.rdsat_+3A_delim">delim</code></td>
<td>
<p>The seperator defining columns. &lt;auto&gt; will guess the
delimitor based on the file.</p>
</td></tr>
<tr><td><code id="read.rdsat_+3A_n">N</code></td>
<td>
<p>The population size (Optional).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- paste0(path.package("RDS"),"/extdata/nyjazz.rdsat")
rd &lt;- read.rdsat(fn)
plot(rd)
</code></pre>

<hr>
<h2 id='read.rdsobj'>Import data saved using write.rdsobj</h2><span id='topic+read.rdsobj'></span>

<h3>Description</h3>

<p>Import data saved using write.rdsobj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.rdsobj(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.rdsobj_+3A_file">file</code></td>
<td>
<p>the name of the file which the data are to be read from.
If it
does not contain an _absolute_ path, the file name is
_relative_ to the current working directory, 'getwd()'.
Tilde-expansion is performed where supported.  As from R
2.10.0 this can be a compressed file (see 'file')</p>
</td></tr>
</table>

<hr>
<h2 id='reingold.tilford.plot'>Plots the recruitment network using the Reingold Tilford algorithm.</h2><span id='topic+reingold.tilford.plot'></span>

<h3>Description</h3>

<p>Plots the recruitment network using the Reingold Tilford algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reingold.tilford.plot(
  x,
  vertex.color = NULL,
  vertex.color.scale = hue_pal(),
  vertex.size = 2,
  vertex.size.range = c(1, 5),
  edge.arrow.size = 0,
  vertex.label.cex = 0.2,
  vertex.frame.color = NA,
  vertex.label = get.id(x),
  show.legend = TRUE,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reingold.tilford.plot_+3A_x">x</code></td>
<td>
<p>An rds.data.frame</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_vertex.color">vertex.color</code></td>
<td>
<p>The name of the categorical variable in x to color the points with.</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_vertex.color.scale">vertex.color.scale</code></td>
<td>
<p>The scale to create the color palette.</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_vertex.size">vertex.size</code></td>
<td>
<p>The size of the vertex points. either a number or the name of a 
column of x.</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_vertex.size.range">vertex.size.range</code></td>
<td>
<p>If vertex.size represents a variable, vertex.size.range is a 
vector of length 2 representing the minimum and maximum cex for the points.</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>
<p>The size of the arrow from recruiter to recruitee.</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>
<p>The size expansion factor for the vertex.labels.</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_vertex.frame.color">vertex.frame.color</code></td>
<td>
<p>the color of the outside of the vertex.points.</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_vertex.label">vertex.label</code></td>
<td>
<p>The name of a variable to use as vertex labels. NA implies no labels.</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>If true and either vertex.color or vertex.size represent variables, 
legends will be displayed at the bottom of the plot.</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_plot">plot</code></td>
<td>
<p>Logical, if TRUE then a plot is produced of recruitment tree.
ratio statistic with the observed statistics plotted as a vertical dashed line.</p>
</td></tr>
<tr><td><code id="reingold.tilford.plot_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to plot.igraph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-column vector of the positions of the nodes in the recruitment tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fauxmadrona)
data(faux)
reingold.tilford.plot(faux)
reingold.tilford.plot(fauxmadrona,vertex.color="disease")

## End(Not run)
</code></pre>

<hr>
<h2 id='rid.from.coupons'>Determines the recruiter.id from recruitment coupon information</h2><span id='topic+rid.from.coupons'></span>

<h3>Description</h3>

<p>Determines the recruiter.id from recruitment coupon information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rid.from.coupons(
  data,
  subject.coupon = NULL,
  coupon.variables,
  subject.id = NULL,
  seed.id = "seed"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rid.from.coupons_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="rid.from.coupons_+3A_subject.coupon">subject.coupon</code></td>
<td>
<p>The variable representing the coupon returned by subject</p>
</td></tr>
<tr><td><code id="rid.from.coupons_+3A_coupon.variables">coupon.variables</code></td>
<td>
<p>The variable representing the coupon ids given to the subject</p>
</td></tr>
<tr><td><code id="rid.from.coupons_+3A_subject.id">subject.id</code></td>
<td>
<p>The variable representing the subject's id</p>
</td></tr>
<tr><td><code id="rid.from.coupons_+3A_seed.id">seed.id</code></td>
<td>
<p>The recruiter.id to assign to seed subjects.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", "nyjazz.csv", package="RDS")
dat &lt;- read.csv(fpath)
dat$recruiter.id &lt;- rid.from.coupons(dat,"own.coupon",
                      paste0("coupon.",1:7),"id")

#create and rds.data.frame
rds &lt;- as.rds.data.frame(dat,network.size="network.size")
</code></pre>

<hr>
<h2 id='set.control.class'>Set the class of the control list</h2><span id='topic+set.control.class'></span>

<h3>Description</h3>

<p>This function sets the class of the control list, with the default being the
name of the calling function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.control.class(
  myname = as.character(RDS::ult(sys.calls(), 2)[[1L]]),
  control = get("control", pos = parent.frame())
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.control.class_+3A_myname">myname</code></td>
<td>
<p>Name of the class to set.</p>
</td></tr>
<tr><td><code id="set.control.class_+3A_control">control</code></td>
<td>
<p>Control list. Defaults to the <code>control</code> variable in the
calling function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The control list with class set.
</p>


<h3>See Also</h3>

<p>check.control.class, print.control.list
</p>

<hr>
<h2 id='show.rds.data.frame'>Displays an rds.data.frame</h2><span id='topic+show.rds.data.frame'></span>

<h3>Description</h3>

<p>Displays an rds.data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.rds.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show.rds.data.frame_+3A_x">x</code></td>
<td>
<p>an rds.data.frame object.</p>
</td></tr>
<tr><td><code id="show.rds.data.frame_+3A_...">...</code></td>
<td>
<p>additional parameters passed to print.data.frame.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.svyglm.RDS'>Summarizing Generalized Linear Model Fits with Odds Ratios for Survey Data</h2><span id='topic+summary.svyglm.RDS'></span>

<h3>Description</h3>

<p><code>RDS::summary.svyglm.RDS</code> is a version of <code>summary.svyglm</code> that 
reports odds-ratios in place of coefficients in the summary table. 
This only applies for the <code>binomial</code> family. Otherwise it is identical to
<code>summary.svyglm</code>.
The default in <code>summary.svyglm</code> is to display the log-odds-ratios 
and this displays the exponetiated from
and a 95
p-values are still displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svyglm.RDS'
summary(object, correlation = FALSE, df.resid = NULL, odds = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.svyglm.RDS_+3A_object">object</code></td>
<td>
<p>an object of class <code>"svyglm"</code>, usually, a result of a call
to <code><a href="survey.html#topic+svyglm">svyglm</a></code>.</p>
</td></tr>
<tr><td><code id="summary.svyglm.RDS_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of the
estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.svyglm.RDS_+3A_df.resid">df.resid</code></td>
<td>
<p>Optional denominator degrees of freedom for Wald tests.</p>
</td></tr>
<tr><td><code id="summary.svyglm.RDS_+3A_odds">odds</code></td>
<td>
<p>logical; Should the coefficients be reported as odds (rather than log-odds)?</p>
</td></tr>
<tr><td><code id="summary.svyglm.RDS_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>svyglm</code> fits a generalised linear model to data from a complex survey design, with
inverse-probability weighting and design-based standard errors.
</p>
<p>There is no <code>anova</code> method for <code>svyglm</code> as the models are not
fitted by maximum likelihood.
</p>
<p>See the manual page on <code>svyglm</code> for detail of that function.
</p>


<h3>Value</h3>

<p><code>RDS::summary.svyglm</code> returns an object of class <code>"summary.svyglm.RDS"</code>,
a list with components
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr> <tr><td><code>family</code></td>
<td>
<p>the component
from <code>object</code>.</p>
</td></tr> <tr><td><code>deviance</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr> <tr><td><code>df.residual</code></td>
<td>
<p>the
component from <code>object</code>.</p>
</td></tr> <tr><td><code>null.deviance</code></td>
<td>
<p>the component from
<code>object</code>.</p>
</td></tr> <tr><td><code>df.null</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p>the deviance residuals: see
<code><a href="survey.html#topic+residuals.svyglm">residuals.svyglm</a></code>.</p>
</td></tr> <tr><td><code>coefficients</code></td>
<td>
<p>the matrix of
coefficients, standard errors, z-values and p-values.  Aliased coefficients
are omitted.</p>
</td></tr> <tr><td><code>aliased</code></td>
<td>
<p>named logical vector showing if the original
coefficients are aliased.</p>
</td></tr> <tr><td><code>dispersion</code></td>
<td>
<p>either the supplied argument or
the inferred/estimated dispersion if the latter is <code>NULL</code>.</p>
</td></tr> <tr><td><code>df</code></td>
<td>
<p>a
3-vector of the rank of the model and the number of residual degrees of
freedom, plus number of coefficients (including aliased ones).</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>the unscaled (<code>dispersion = 1</code>) estimated
covariance matrix of the estimated coefficients.</p>
</td></tr> <tr><td><code>cov.scaled</code></td>
<td>
<p>ditto,
scaled by <code>dispersion</code>.</p>
</td></tr> <tr><td><code>correlation</code></td>
<td>
<p>(only if <code>correlation</code>
is true.)  The estimated correlations of the estimated coefficients.</p>
</td></tr>
<tr><td><code>symbolic.cor</code></td>
<td>
<p>(only if <code>correlation</code> is true.)  The value of the
argument <code>symbolic.cor</code>.</p>
</td></tr>
<tr><td><code>odds</code></td>
<td>
<p>Are the coefficients reported as odds (rather than log-odds)?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="survey.html#topic+svyglm">svyglm</a></code>, <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## For examples see example(svyglm)

</code></pre>

<hr>
<h2 id='transition.counts.to.Markov.mle'>calculates the mle. i.e. the row proportions of the transition matrix</h2><span id='topic+transition.counts.to.Markov.mle'></span>

<h3>Description</h3>

<p>calculates the mle. i.e. the row proportions of the transition matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition.counts.to.Markov.mle(transition.counts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition.counts.to.Markov.mle_+3A_transition.counts">transition.counts</code></td>
<td>
<p>a matrix or table of transition counts</p>
</td></tr>
</table>


<h3>Details</h3>

<p>depreicated. just use prop.table(transition.counts,1)
</p>

<hr>
<h2 id='ult'>Extract or replace the *ult*imate (last) element of a vector or a list, or an element counting from the end.</h2><span id='topic+ult'></span>

<h3>Description</h3>

<p>Extract or replace the *ult*imate (last) element of a vector or a list, or an element counting from the end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ult(x, i = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ult_+3A_x">x</code></td>
<td>
<p>a vector or a list.</p>
</td></tr>
<tr><td><code id="ult_+3A_i">i</code></td>
<td>
<p>index from the end of the list to extract or replace (where 1 is the last element, 2 is the penultimate element, etc.).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An element of 'x'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
(last &lt;- ult(x))
(penultimate &lt;- ult(x, 2)) # 2nd last.



</code></pre>

<hr>
<h2 id='vh.weights'>Volz-Heckathorn (RDS-II) weights</h2><span id='topic+vh.weights'></span>

<h3>Description</h3>

<p>Volz-Heckathorn (RDS-II) weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vh.weights(degs, N = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vh.weights_+3A_degs">degs</code></td>
<td>
<p>The degrees (i.e. network sizes) of the sample units.</p>
</td></tr>
<tr><td><code id="vh.weights_+3A_n">N</code></td>
<td>
<p>Population size</p>
</td></tr>
</table>

<hr>
<h2 id='write.graphviz'>writes an rds.data.frame recruitment tree as a GraphViz file</h2><span id='topic+write.graphviz'></span>

<h3>Description</h3>

<p>writes an rds.data.frame recruitment tree as a GraphViz file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.graphviz(x, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.graphviz_+3A_x">x</code></td>
<td>
<p>An rds.data.frame.</p>
</td></tr>
<tr><td><code id="write.graphviz_+3A_file">file</code></td>
<td>
<p>A character vector representing the file</p>
</td></tr>
</table>

<hr>
<h2 id='write.netdraw'>Writes out the RDS tree in NetDraw format</h2><span id='topic+write.netdraw'></span>

<h3>Description</h3>

<p>Writes out the RDS tree in NetDraw format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.netdraw(x, file = NULL, by.seed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.netdraw_+3A_x">x</code></td>
<td>
<p>An rds.data.frame.</p>
</td></tr>
<tr><td><code id="write.netdraw_+3A_file">file</code></td>
<td>
<p>a character vector representing a file.</p>
</td></tr>
<tr><td><code id="write.netdraw_+3A_by.seed">by.seed</code></td>
<td>
<p>If true, seperate files will be created for each seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If by.seed is false, two files are created using 'file' as a base name.
<code>paste0(file,".DL")</code> contains the edge information, and <code>paste0(file,".vna")</code>
contains the nodal attributes
</p>

<hr>
<h2 id='write.rdsat'>Writes out the RDS tree in RDSAT format</h2><span id='topic+write.rdsat'></span>

<h3>Description</h3>

<p>Writes out the RDS tree in RDSAT format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.rdsat(x, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.rdsat_+3A_x">x</code></td>
<td>
<p>An rds.data.frame.</p>
</td></tr>
<tr><td><code id="write.rdsat_+3A_file">file</code></td>
<td>
<p>a character vector representing a file.</p>
</td></tr>
</table>

<hr>
<h2 id='write.rdsobj'>Export an rds.data.frame to file</h2><span id='topic+write.rdsobj'></span>

<h3>Description</h3>

<p>Export an rds.data.frame to file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.rdsobj(x, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.rdsobj_+3A_x">x</code></td>
<td>
<p>The rds.data.frame to export</p>
</td></tr>
<tr><td><code id="write.rdsobj_+3A_file">file</code></td>
<td>
<p>The name of the file to create.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
