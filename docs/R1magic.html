<!DOCTYPE html><html><head><title>Help for package R1magic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {R1magic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CompareL1_L2_TV1'>
<p>Compare L1, L2 and TV on a sparse signal.</p></a></li>
<li><a href='#DFTMatrix0'>
<p>Generate Discrete Fourier Transform Matrix using DFTMatrixPlain.</p></a></li>
<li><a href='#DFTMatrixPlain'>
<p>Generate Plain Discrete Fourier Transform Matrix without the coefficient</p></a></li>
<li><a href='#GaussianMatrix'>
<p>Generate Gaussian Random Matrix</p></a></li>
<li><a href='#Lnorm'><p>L-p norm of a given complex vector</p></a></li>
<li><a href='#mutualCoherence'>
<p>Cumulative mutual coherence</p></a></li>
<li><a href='#objective1TV'>
<p>1-D Total Variation Penalized Objective Function</p></a></li>
<li><a href='#objectiveL1'><p>Objective function for ridge L1 penalty</p></a></li>
<li><a href='#objectiveL2'><p>Objective function for Tikhinov L2 penalty</p></a></li>
<li><a href='#oo'>
<p>Frequency expression for DFT</p></a></li>
<li><a href='#scaleBack.lm'><p>Transform back multiple regression coefficients to unscaled regression coefficients</p>
Original question posed by Mark Seeto on the R mailing list.</a></li>
<li><a href='#solve1TV'>
<p>1-D Total Variation Penalized Nonlinear Minimization</p></a></li>
<li><a href='#solveL1'>
<p>l1  Penalized Nonlinear Minimization</p></a></li>
<li><a href='#solveL2'>
<p>l2  Penalized Nonlinear Minimization</p></a></li>
<li><a href='#sparseSignal'>
<p>Sparse digital signal Generator.</p></a></li>
<li><a href='#TV1'>
<p>1-D total variation of a vector.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compressive Sampling: Sparse Signal Recovery Utilities</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-27</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities for sparse signal recovery suitable for compressed sensing. L1, L2 and TV penalties, DFT basis matrix, simple sparse signal generator, mutual cumulative coherence between two matrices and examples, Lp complex norm, scaling back regression coefficients.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-27 16:07:46 UTC; msuzen</td>
</tr>
<tr>
<td>Author:</td>
<td>Mehmet Suzen [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-27 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CompareL1_L2_TV1'>
Compare L1, L2 and TV on a sparse signal.
</h2><span id='topic+CompareL1_L2_TV1'></span>

<h3>Description</h3>

<p>Compare L1, L2 and TV on a sparse signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareL1_L2_TV1(N, M, per)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareL1_L2_TV1_+3A_n">N</code></td>
<td>

<p>Size of the sparse signal to generate , integer.
</p>
</td></tr>
<tr><td><code id="CompareL1_L2_TV1_+3A_m">M</code></td>
<td>

<p>Number of measurements.
</p>
</td></tr>
<tr><td><code id="CompareL1_L2_TV1_+3A_per">per</code></td>
<td>

<p>Percentage of spikes.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

<hr>
<h2 id='DFTMatrix0'>
Generate Discrete Fourier Transform Matrix using DFTMatrixPlain.
</h2><span id='topic+DFTMatrix0'></span>

<h3>Description</h3>

<p>Generate Discrete Fourier Transform Matrix (NxN).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFTMatrix0(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFTMatrix0_+3A_n">N</code></td>
<td>

<p>Integer value determines the dimension of the square matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a NxN square matrix.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>


<h3>See Also</h3>

<p>DFTMatrixPlain
</p>


<h3>Examples</h3>

<pre><code class='language-R'> DFTMatrix0(2)
</code></pre>

<hr>
<h2 id='DFTMatrixPlain'>
Generate Plain Discrete Fourier Transform Matrix without the coefficient
</h2><span id='topic+DFTMatrixPlain'></span>

<h3>Description</h3>

<p>Generate plain Discrete Fourier Transform Matrix (NxN) without a coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFTMatrixPlain(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFTMatrixPlain_+3A_n">N</code></td>
<td>

<p>Integer value defines the dimension of the square plain DFT matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a NxN square matrix.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DFTMatrixPlain(2)
</code></pre>

<hr>
<h2 id='GaussianMatrix'>
Generate Gaussian Random Matrix
</h2><span id='topic+GaussianMatrix'></span>

<h3>Description</h3>

<p>Generate Gaussian Random Matrix ( zero mean and standard deviation one.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussianMatrix(N, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussianMatrix_+3A_n">N</code></td>
<td>

<p>Integer value determines number of rows.
</p>
</td></tr>
<tr><td><code id="GaussianMatrix_+3A_m">M</code></td>
<td>

<p>Integer value determines number of columns.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  MxN matrix.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GaussianMatrix(3,2)

</code></pre>

<hr>
<h2 id='Lnorm'>L-p norm of a given complex vector</h2><span id='topic+Lnorm'></span>

<h3>Description</h3>

<p>L-p norm of a given complex vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lnorm(X, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lnorm_+3A_x">X</code></td>
<td>
<p>a complex vector, can be real too.</p>
</td></tr>
<tr><td><code id="Lnorm_+3A_p">p</code></td>
<td>
<p>norm value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>L-p norm of the complex vector
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

<hr>
<h2 id='mutualCoherence'>
Cumulative mutual coherence
</h2><span id='topic+mutualCoherence'></span>

<h3>Description</h3>

<p>Generate vector of cumulative mutual coherence of a given matrix up to a given order. \
Mutual Cumulative Coherence of a Matrix A at order k is defined as 
<code class="reqn"> M(A, k) = max_{p} max_{p \ne q, q \in \Omega } \sum_{q} | &lt;a_{p}, a_{q}&gt; | / ( |a_{p}| |a_{q}|)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutualCoherence(A, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutualCoherence_+3A_a">A</code></td>
<td>

<p>A matrix.
</p>
</td></tr>
<tr><td><code id="mutualCoherence_+3A_k">k</code></td>
<td>

<p>Integer value determines number of columns or the order of mutual coherence function to .
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns k-vector
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>


<h3>References</h3>

<p>Compressed sensing in diffuse optical tomography \ M. Suzen, A.Giannoula and T. Durduran, \ Opt. Express 18, 23676-23690 (2010)  \
J. A. Tropp \ Greed is good: algorithmic results for sparse approximation, \IEEE Trans. Inf. Theory 50, 2231-2242 (2004)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
B &lt;- matrix(rnorm(100), 10, 10) # Gaussian Random Matrix
mutualCoherence(B, 3) # mutual coherence up to order k
</code></pre>

<hr>
<h2 id='objective1TV'>
1-D Total Variation Penalized Objective Function
</h2><span id='topic+objective1TV'></span>

<h3>Description</h3>

<p>1-D Total Variation Penalized Objective Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objective1TV(x, T, phi, y, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objective1TV_+3A_x">x</code></td>
<td>

<p>Initial value of the vector to be recovered. Sparse representation 
of the vector ( N x 1 matrix ) X=Tx, where X is the original vector
</p>
</td></tr>
<tr><td><code id="objective1TV_+3A_t">T</code></td>
<td>

<p>sparsity bases ( N x N matrix )
</p>
</td></tr>
<tr><td><code id="objective1TV_+3A_phi">phi</code></td>
<td>

<p>Measurement matrix (M x N).
</p>
</td></tr>
<tr><td><code id="objective1TV_+3A_y">y</code></td>
<td>

<p>Measurement vector (Mx1).
</p>
</td></tr>
<tr><td><code id="objective1TV_+3A_lambda">lambda</code></td>
<td>

<p>Penalty coefficient.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

<hr>
<h2 id='objectiveL1'>Objective function for ridge L1 penalty</h2><span id='topic+objectiveL1'></span>

<h3>Description</h3>

<p>Objective function for ridge L1 penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectiveL1(x, T, phi, y, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectiveL1_+3A_x">x</code></td>
<td>
<p>unknown vector</p>
</td></tr>
<tr><td><code id="objectiveL1_+3A_t">T</code></td>
<td>
<p>transform bases</p>
</td></tr>
<tr><td><code id="objectiveL1_+3A_phi">phi</code></td>
<td>
<p>measurement matrix</p>
</td></tr>
<tr><td><code id="objectiveL1_+3A_y">y</code></td>
<td>
<p>measurement vector</p>
</td></tr>
<tr><td><code id="objectiveL1_+3A_lambda">lambda</code></td>
<td>
<p>penalty term</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Thank you Jason Xu of Washington University for pointing out complex number handling
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

<hr>
<h2 id='objectiveL2'>Objective function for Tikhinov L2 penalty</h2><span id='topic+objectiveL2'></span>

<h3>Description</h3>

<p>Objective function for Tikhinov L2 penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectiveL2(x, T, phi, y, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectiveL2_+3A_x">x</code></td>
<td>
<p>unknown vector</p>
</td></tr>
<tr><td><code id="objectiveL2_+3A_t">T</code></td>
<td>
<p>transform bases</p>
</td></tr>
<tr><td><code id="objectiveL2_+3A_phi">phi</code></td>
<td>
<p>measurement matrix</p>
</td></tr>
<tr><td><code id="objectiveL2_+3A_y">y</code></td>
<td>
<p>measurement vector</p>
</td></tr>
<tr><td><code id="objectiveL2_+3A_lambda">lambda</code></td>
<td>
<p>penalty term</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Thank you Jason Xu of Washington University for pointing out complex number handling
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

<hr>
<h2 id='oo'>
Frequency expression for DFT
</h2><span id='topic+oo'></span>

<h3>Description</h3>

<p>Frequency expression for DFT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oo(p, omega)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oo_+3A_p">p</code></td>
<td>

<p>Exponent
</p>
</td></tr>
<tr><td><code id="oo_+3A_omega">omega</code></td>
<td>

<p>Omega expression for DFT
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

<hr>
<h2 id='scaleBack.lm'>Transform back multiple regression coefficients to unscaled regression coefficients
Original question posed by Mark Seeto on the R mailing list.</h2><span id='topic+scaleBack.lm'></span>

<h3>Description</h3>

<p>Transform back multiple regression coefficients to unscaled regression coefficients
Original question posed by Mark Seeto on the R mailing list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleBack.lm(X, Y, betas.scaled)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleBack.lm_+3A_x">X</code></td>
<td>
<p>unscaled design matrix without the intercept, m by n matrix</p>
</td></tr>
<tr><td><code id="scaleBack.lm_+3A_y">Y</code></td>
<td>
<p>unscaled response, m by 1 matrix</p>
</td></tr>
<tr><td><code id="scaleBack.lm_+3A_betas.scaled">betas.scaled</code></td>
<td>
<p>coefficients vector of multiple regression, first term is the intercept</p>
</td></tr>
</table>


<h3>Note</h3>

<p>2015-04-10
</p>


<h3>Author(s)</h3>

<p>M.Suzen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
 X            &lt;- matrix(rnorm(12), 4, 3)
 Y            &lt;- matrix(rnorm(4), 4, 1)
 betas.scaled &lt;- matrix(rnorm(3), 3, 1)
 betas        &lt;- scaleBack.lm(X, Y, betas.scaled)
</code></pre>

<hr>
<h2 id='solve1TV'>
1-D Total Variation Penalized Nonlinear Minimization
</h2><span id='topic+solve1TV'></span>

<h3>Description</h3>

<p>1-D Total Variation Penalized Nonlinear Minimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'> solve1TV(phi,y,T,x0,lambda=0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve1TV_+3A_x0">x0</code></td>
<td>

<p>Initial value of the vector to be recovered. Sparse representation 
of the vector ( N x 1 matrix ) X=Tx, where X is the original vector
</p>
</td></tr>
<tr><td><code id="solve1TV_+3A_t">T</code></td>
<td>

<p>sparsity bases ( N x N matrix )
</p>
</td></tr>
<tr><td><code id="solve1TV_+3A_phi">phi</code></td>
<td>

<p>Measurement matrix (M x N).
</p>
</td></tr>
<tr><td><code id="solve1TV_+3A_y">y</code></td>
<td>

<p>Measurement vector (Mx1).
</p>
</td></tr>
<tr><td><code id="solve1TV_+3A_lambda">lambda</code></td>
<td>

<p>Penalty coefficient. Defaults 0.1
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nlm object.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

<hr>
<h2 id='solveL1'>
l1  Penalized Nonlinear Minimization
</h2><span id='topic+solveL1'></span>

<h3>Description</h3>

<p>l1 Penalized Nonlinear Minimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'> solveL1(phi,y,T,x0,lambda=0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveL1_+3A_x0">x0</code></td>
<td>

<p>Initial value of the vector to be recovered. Sparse representation 
of the vector ( N x 1 matrix ) X=Tx, where X is the original vector
</p>
</td></tr>
<tr><td><code id="solveL1_+3A_t">T</code></td>
<td>

<p>sparsity bases ( N x N matrix )
</p>
</td></tr>
<tr><td><code id="solveL1_+3A_phi">phi</code></td>
<td>

<p>Measurement matrix (M x N).
</p>
</td></tr>
<tr><td><code id="solveL1_+3A_y">y</code></td>
<td>

<p>Measurement vector (Mx1).
</p>
</td></tr>
<tr><td><code id="solveL1_+3A_lambda">lambda</code></td>
<td>

<p>Penalty coefficient. Defaults 0.1
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nlm object.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

<hr>
<h2 id='solveL2'>
l2  Penalized Nonlinear Minimization
</h2><span id='topic+solveL2'></span>

<h3>Description</h3>

<p>l2 Penalized Nonlinear Minimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'> solveL2(phi,y,T,x0,lambda=0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveL2_+3A_x0">x0</code></td>
<td>

<p>Initial value of the vector to be recovered. Sparse representation 
of the vector ( N x 1 matrix ) X=Tx, where X is the original vector
</p>
</td></tr>
<tr><td><code id="solveL2_+3A_t">T</code></td>
<td>

<p>sparsity bases ( N x N matrix )
</p>
</td></tr>
<tr><td><code id="solveL2_+3A_phi">phi</code></td>
<td>

<p>Measurement matrix (M x N).
</p>
</td></tr>
<tr><td><code id="solveL2_+3A_y">y</code></td>
<td>

<p>Measurement vector (Mx1).
</p>
</td></tr>
<tr><td><code id="solveL2_+3A_lambda">lambda</code></td>
<td>

<p>Penalty coefficient. Defaults 0.1
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nlm object.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

<hr>
<h2 id='sparseSignal'>
Sparse digital signal Generator.
</h2><span id='topic+sparseSignal'></span>

<h3>Description</h3>

<p>Sparse digital signal Generator with given thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseSignal(N, s, b = 1, delta = 1e-07, nlev = 0.05, slev = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseSignal_+3A_n">N</code></td>
<td>

<p>Number of signal components, vector size.
</p>
</td></tr>
<tr><td><code id="sparseSignal_+3A_s">s</code></td>
<td>

<p>Number of spikes, significatn components
</p>
</td></tr>
<tr><td><code id="sparseSignal_+3A_b">b</code></td>
<td>

<p>Signal bandwidth, defaults 1.
</p>
</td></tr>
<tr><td><code id="sparseSignal_+3A_delta">delta</code></td>
<td>

<p>Length of discrete distances among components, defaults 1e-7.
</p>
</td></tr>
<tr><td><code id="sparseSignal_+3A_nlev">nlev</code></td>
<td>

<p>Maximum value of insignificant component, relative to b, defaults to 0.05
</p>
</td></tr>
<tr><td><code id="sparseSignal_+3A_slev">slev</code></td>
<td>

<p>Maximum value of significant component, relative to b, defaults to 0.9
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

<hr>
<h2 id='TV1'>
1-D total variation of a vector.
</h2><span id='topic+TV1'></span>

<h3>Description</h3>

<p>1-D total variation of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TV1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TV1_+3A_x">x</code></td>
<td>

<p>A vector.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mehmet Suzen
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
