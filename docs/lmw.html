<!DOCTYPE html><html lang="en"><head><title>Help for package lmw</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lmw}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lmw-package'><p>lmw: Linear Model Weights</p></a></li>
<li><a href='#influence.lmw'><p>Regression Diagnostics for <code>lmw</code> and <code>lmw_est</code> objects</p></a></li>
<li><a href='#lalonde'><p>Data from National Supported Work Demonstration and PSID, as analyzed by</p>
Dehejia and Wahba (1999).</a></li>
<li><a href='#lmw'><p>Compute linear regression-implied weights</p></a></li>
<li><a href='#lmw_est'><p>Estimate a treatment effect from a linear model</p></a></li>
<li><a href='#lmw_iv'><p>Compute instrumental variable regression-implied weights</p></a></li>
<li><a href='#plot.lmw'><p>Plots diagnosing regression-implied weights</p></a></li>
<li><a href='#plot.lmw_est'><p>Plot diagnostics for an <code>lmw_est</code> object</p></a></li>
<li><a href='#plot.summary.lmw'><p>Produce a Love plot of balance statistics</p></a></li>
<li><a href='#summary.lmw'><p>Assess balance for an <code>lmw</code> object</p></a></li>
<li><a href='#summary.lmw_est_aipw'><p>Extract effect estimates and standard errors from <code>lmw_est</code> fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear Model Weights</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes the implied weights of linear regression models for estimating
     average causal effects and provides diagnostics based on these weights. These
     diagnostics rely on the analyses in Chattopadhyay and Zubizarreta (2023)
     &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasac058">doi:10.1093/biomet/asac058</a>&gt; where
     several regression estimators are represented as weighting estimators, in connection
     to inverse probability weighting. 'lmw' provides tools to diagnose
     representativeness, balance, extrapolation, and influence for these models,
     clarifying the target population of inference. Tools are also available to
     simplify estimating treatment effects for specific target populations of interest.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ngreifer/lmw">https://github.com/ngreifer/lmw</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ngreifer/lmw/issues">https://github.com/ngreifer/lmw/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>chk (&ge; 0.9.1), sandwich (&ge; 3.0-2), backports (&ge; 1.4.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MatchIt (&ge; 4.3.2), WeightIt (&ge; 0.14.2), marginaleffects (&ge;
0.17.0), PSweight (&ge; 1.1.8), estimatr, lmtest, ivreg, mlogit,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 16:01:46 UTC; NoahGreifer</td>
</tr>
<tr>
<td>Author:</td>
<td>Ambarish Chattopadhyay
    <a href="https://orcid.org/0000-0002-1502-0974"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Noah Greifer <a href="https://orcid.org/0000-0003-3067-7154"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jose Zubizarreta <a href="https://orcid.org/0000-0002-0322-147X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Noah Greifer &lt;ngreifer@iq.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 16:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='lmw-package'>lmw: Linear Model Weights</h2><span id='topic+lmw-package'></span>

<h3>Description</h3>

<p>Computes the implied weights of linear regression models for estimating average causal effects and provides diagnostics based on these weights. These diagnostics rely on the analyses in Chattopadhyay and Zubizarreta (2023) <a href="https://doi.org/10.1093/biomet/asac058">doi:10.1093/biomet/asac058</a> where several regression estimators are represented as weighting estimators, in connection to inverse probability weighting. 'lmw' provides tools to diagnose representativeness, balance, extrapolation, and influence for these models, clarifying the target population of inference. Tools are also available to simplify estimating treatment effects for specific target populations of interest.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Noah Greifer <a href="mailto:ngreifer@iq.harvard.edu">ngreifer@iq.harvard.edu</a> (<a href="https://orcid.org/0000-0003-3067-7154">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Ambarish Chattopadhyay <a href="mailto:ambarish_chattopadhyay@g.harvard.edu">ambarish_chattopadhyay@g.harvard.edu</a> (<a href="https://orcid.org/0000-0002-1502-0974">ORCID</a>)
</p>
</li>
<li><p> Jose Zubizarreta <a href="mailto:zubizarreta@hcp.med.harvard.edu">zubizarreta@hcp.med.harvard.edu</a> (<a href="https://orcid.org/0000-0002-0322-147X">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ngreifer/lmw">https://github.com/ngreifer/lmw</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ngreifer/lmw/issues">https://github.com/ngreifer/lmw/issues</a>
</p>
</li></ul>


<hr>
<h2 id='influence.lmw'>Regression Diagnostics for <code>lmw</code> and <code>lmw_est</code> objects</h2><span id='topic+influence.lmw'></span><span id='topic+influence.lmw_est'></span>

<h3>Description</h3>

<p><code>influence()</code> produces influence measures for <code>lmw</code> objects that
can be used as regression diagnostics to identify influential cases. These
functions produce similar outputs to <code><a href="stats.html#topic+lm.influence">lm.influence()</a></code> but also
include the sample influence curve (SIC) values, which combine information
about the hat values, residuals, and implied regression weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmw'
influence(model, outcome, data = NULL, ...)

## S3 method for class 'lmw_est'
influence(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="influence.lmw_+3A_model">model</code></td>
<td>
<p>an <code>lmw</code> or <code>lmw_est</code> object; the output of a call to
<code><a href="#topic+lmw">lmw()</a></code> or <code><a href="#topic+lmw_est">lmw_est()</a></code>.</p>
</td></tr>
<tr><td><code id="influence.lmw_+3A_outcome">outcome</code></td>
<td>
<p>the name of the outcome variable. Can be supplied as a string
containing the name of the outcome variable or as the outcome variable
itself. If not supplied, the outcome variable in the <code>formula</code> supplied
to <code>lmw()</code>, if any, will be used.</p>
</td></tr>
<tr><td><code id="influence.lmw_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the outcome variable named in
<code>outcome</code>.</p>
</td></tr>
<tr><td><code id="influence.lmw_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>influence()</code> computes the hat values, (weighted) residuals, and sample
influence curve (SIC) values for each unit, which can be used as regression
diagnostics to assess influence. The weighted residuals are weighted by the
sampling weights (if supplied), not the implied regression weights. The SIC
values are computed as <code>SIC = (N-1) * w * r / (1 - h)</code>, where <code>N</code>
is the sample size, <code>w</code> are the units' implied regression weights,
<code>r</code> are the (weighted) residuals, and <code>h</code> are the hat values. SIC
values are scaled to have a maximum of 1. Higher values indicate greater
relative influence.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>hat</code></td>
<td>
<p>a vector containing
the diagonal of the hat matrix.</p>
</td></tr>
<tr><td><code>wt.res</code></td>
<td>
<p>a vector of (weighted)
residuals.</p>
</td></tr>
<tr><td><code>sic</code></td>
<td>
<p>a vector containing the scaled SIC values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>influence.lmw()</code> uses non-standard evaluation to interpret its
<code>outcome</code> argument. For programmers who wish to use
<code>influence.lmw()</code> inside other functions, an effective way to pass the
name of an arbitrary outcome (e.g., <code>y</code> passed as a string) is to use
<code><a href="base.html#topic+do.call">do.call()</a></code>, for example: </p>
<pre>fun &lt;- function(m, y, d) {
do.call("influence", list(m, y, d)) } </pre><p> When using <code>influence.lmw()</code>
inside <code><a href="base.html#topic+lapply">lapply()</a></code> or <code>purrr::map</code> to loop over outcomes, this
syntax must be used as well.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.lmw">plot.lmw()</a></code> for plotting the SIC values;
<code><a href="stats.html#topic+lm.influence">lm.influence()</a></code> for influence measures for <code>lm</code> objects,
which do not include SIC values; <code><a href="stats.html#topic+hatvalues">hatvalues()</a></code> for hat values for
<code>lm</code> objects (note that <code>lmw_est</code> objects also have a
<code>hatvalues()</code> method).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# URI regression for ATT
lmw.out1 &lt;- lmw(~ treat + age + education + race + married +
                     nodegree + re74 + re75,
                data = lalonde, estimand = "ATT",
                method = "URI", treat = "treat")

# Influence for re78 outcome
infl &lt;- influence(lmw.out1, outcome = "re78")
str(infl)

# Can also be used after lmw_est():
lmw.est1 &lt;- lmw_est(lmw.out1, outcome = "re78")
all.equal(infl,
          influence(lmw.est1))

</code></pre>

<hr>
<h2 id='lalonde'>Data from National Supported Work Demonstration and PSID, as analyzed by
Dehejia and Wahba (1999).</h2><span id='topic+lalonde'></span>

<h3>Description</h3>

<p>This is a subsample of the data from the treated group in the National
Supported Work Demonstration (NSW) and the comparison sample from the
Population Survey of Income Dynamics (PSID). This data was previously
analyzed extensively by Lalonde (1986) and Dehejia and Wahba (1999). The
original dataset is available at
<a href="https://users.nber.org/~rdehejia/nswdata2.html">https://users.nber.org/~rdehejia/nswdata2.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lalonde
</code></pre>


<h3>Format</h3>

<p>A data frame with 2675 observations (185 treated, 2490 control). There
are 9 variables measured for each individual. In addition, two constructed variables are included: <code>treat_multi</code>, which splits the original control group into two, and <code>Ins</code>, which is a constructed instrumental variable.
</p>

<ul>
<li><p> &quot;treat&quot; is the
treatment assignment (1=treated, 0=control).
</p>
</li>
<li><p> &quot;age&quot; is age in years.
</p>
</li>
<li><p> &quot;education&quot; is education in number of years of schooling.
</p>
</li>
<li><p> &quot;race&quot; is
the individual's race/ethnicity, (Black, Hispanic, or White).
</p>
</li>
<li><p> &quot;married&quot; is an indicator for married (1=married, 0=not married).
</p>
</li>
<li><p> &quot;nodegree&quot; is an indicator for whether the individual lacks a high school
degree (i.e., has fewer than 12 years of schooling; 1=no degree, 0=degree).
</p>
</li>
<li><p> &quot;re74&quot; is income in 1974, in U.S. dollars.
</p>
</li>
<li><p> &quot;re75&quot; is income in
1975, in U.S. dollars.
</p>
</li>
<li><p> &quot;re78&quot; is income in 1978, in U.S. dollars.
</p>
</li>
<li><p> &quot;treat_multi&quot; is a constructed version of &quot;treat&quot; that splits the control group into to levels (1=treated, 2=control group A, 3=control group B).
</p>
</li>
<li><p> &quot;Ins&quot; is a binary instrumental variable.
</p>
</li></ul>

<p>&quot;treat&quot; is the treatment variable, &quot;re78&quot; is the outcome, and the others are
pre-treatment covariates. Note that in the original data, &quot;race&quot; is instead
coded as two dummy variables, &quot;black&quot; and &quot;hispan&quot;.
</p>


<h3>Details</h3>

<p>The data corresponds to the NSW treated sample and the PSID control sample
with 1974 earnings included. This specific dataset is different from the one in the
<span class="pkg">MatchIt</span> and <span class="pkg">cobalt</span> packages, which is a subset of this dataset.
</p>


<h3>References</h3>

<p>Lalonde, R. (1986). Evaluating the econometric evaluations of
training programs with experimental data. American Economic Review 76:
604-620.
</p>
<p>Dehejia, R.H. and Wahba, S. (1999).  Causal Effects in Nonexperimental
Studies: Re-Evaluating the Evaluation of Training Programs.  Journal of the
American Statistical Association 94: 1053-1062.
</p>

<hr>
<h2 id='lmw'>Compute linear regression-implied weights</h2><span id='topic+lmw'></span>

<h3>Description</h3>

<p>Computes the weights implied by a linear outcome regression model that would
estimate a weighted difference in outcome means equal to the
covariate-adjusted treatment effect resulting from the supplied regression
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmw(
  formula,
  data = NULL,
  estimand = "ATE",
  method = "URI",
  treat = NULL,
  base.weights = NULL,
  s.weights = NULL,
  dr.method = "WLS",
  obj = NULL,
  fixef = NULL,
  target = NULL,
  target.weights = NULL,
  contrast = NULL,
  focal = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmw_+3A_formula">formula</code></td>
<td>
<p>a one-sided formula with the treatment and covariates on the
right-hand side corresponding to the outcome regression model to be fit. The
outcome variable is not involved in computing the weights and does not need
to be specified. See Details for how this formula is interpreted in light of
other options.</p>
</td></tr>
<tr><td><code id="lmw_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>
and <code>treat</code>.</p>
</td></tr>
<tr><td><code id="lmw_+3A_estimand">estimand</code></td>
<td>
<p>the estimand of interest, which determines how covariates
are centered. Should be one of <code>"ATE"</code> for the average treatment
effect, <code>"ATT"</code> for the average treatment effect in the treated,
<code>"ATC"</code> for the average treatment effect in the control, or
<code>"CATE"</code> for the conditional average treatment effect. When
<code>estimand = "CATE"</code>, an argument to <code>target</code> must be supplied.
This argument also affects what <code><a href="#topic+summary.lmw">summary.lmw()</a></code> considers to be
the target population. Default is <code>"ATE"</code> unless <code>obj</code> is
specified, in which case it takes its value from the supplied object.</p>
</td></tr>
<tr><td><code id="lmw_+3A_method">method</code></td>
<td>
<p>the method used to estimate the weights; either <code>"URI"</code>
(the default) for uni-regression imputation weights, where a single model is
fit to the whole dataset, or <code>"MRI"</code> for multi-regression imputation,
where the model is fit separately in the treatment groups. This affects the
interpretation of <code>formula</code>. See Details.</p>
</td></tr>
<tr><td><code id="lmw_+3A_treat">treat</code></td>
<td>
<p>the name of the treatment variable in <code>data</code>. If
unspecified, the first variable present in <code>formula</code> will be taken as
the treatment variable with a message. See Details.</p>
</td></tr>
<tr><td><code id="lmw_+3A_base.weights">base.weights</code></td>
<td>
<p>a vector of base weights. See Details. If omitted and
<code>obj</code> is specified, the weights from the supplied object will be used.
Can be supplied as a numeric vector, a string containing the name of the
variable in <code>data</code> containing the base weights, or the unquoted name of
the variable in <code>data</code> containing the base weights.</p>
</td></tr>
<tr><td><code id="lmw_+3A_s.weights">s.weights</code></td>
<td>
<p>a vector of sampling weights. See Details. If omitted and
<code>obj</code> is specified, the sampling weights from the supplied object will
be used. Can be supplied as a numeric vector, a string containing the name
of the variable in <code>data</code> containing the sampling weights, or the
unquoted name of the variable in <code>data</code> containing the sampling
weights.</p>
</td></tr>
<tr><td><code id="lmw_+3A_dr.method">dr.method</code></td>
<td>
<p>the method used to incorporate the <code>base.weights</code> into
a doubly-robust estimator. Can be one of <code>"WLS"</code> for weighted least
squares (<code>"IPWRA"</code> is an allowable alias) or <code>"AIPW"</code> for augmented inverse probability weighting.
Ignored when <code>base.weights</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lmw_+3A_obj">obj</code></td>
<td>
<p>a <code>matchit</code> or <code>weightit</code> object corresponding to the
matched or weighted sample in which the implied outcome regression would
take place. See Details.</p>
</td></tr>
<tr><td><code id="lmw_+3A_fixef">fixef</code></td>
<td>
<p>optional; a string or one-sided formula containing the name of
the fixed effects variable in <code>data</code>. See Details. Cannot be used with
<code>dr.method = "AIPW"</code>.</p>
</td></tr>
<tr><td><code id="lmw_+3A_target">target</code></td>
<td>
<p>a list or data frame containing the target values for each
covariate included in <code>formula</code>. Ignored with a warning when
<code>estimand</code> is not <code>"CATE"</code>. See Details.</p>
</td></tr>
<tr><td><code id="lmw_+3A_target.weights">target.weights</code></td>
<td>
<p>a vector of sampling weights to be applied to
<code>target</code> when supplied as a data frame. Ignored with a warning when
<code>estimand</code> is not <code>"CATE"</code>. See Details.</p>
</td></tr>
<tr><td><code id="lmw_+3A_contrast">contrast</code></td>
<td>
<p>for multi-category treatments with <code>method = "URI"</code>, a
vector containing the names or indices of the two treatment levels to be
contrasted (since in this case the weights depend on the specific contrast).
See Details.</p>
</td></tr>
<tr><td><code id="lmw_+3A_focal">focal</code></td>
<td>
<p>the level of the treatment variable to be considered &quot;focal&quot;
(i.e., the &quot;treated&quot; level when <code>estimand = "ATT"</code> or the control level
when <code>estimand = "ATC"</code>). Ignored when <code>estimand</code> is <code>"ATE"</code>
or <code>"CATE"</code>. Otherwise, if unspecified, the second value of
<code>contrast</code> will be considered focal when <code>estimand = "ATT"</code> and
the first value of <code>contrast</code> will be considered focal when
<code>estimand = "ATC"</code>. For binary treatments, this generally does not need
to be supplied. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>formula</code> is interpreted differently depending on whether <code>method</code>
is <code>"URI"</code> or <code>"MRI"</code>. When <code>method = "URI"</code>, the formula is
taken literally as the right-hand side of the outcome model formula. The
only difference is that the covariates will be centered based on the
argument to <code>estimand</code> (see below). When <code>method = "MRI"</code>, all
references to the treatment are removed (i.e., covariate interactions with
treatment become covariate main effects if not already present), and the new
formula is taken as the right-hand side of the model formula fit within each
treatment group. This is equivalent to allowing all covariates to have both
main effects and interactions with treatment after centering the covariates
based on the argument to <code>estimand</code>. Allowing the treatment to interact
with all covariates with <code>method = "URI"</code> is equivalent to specifying
<code>method = "MRI"</code>, and, for binary treatments, the returned weights will
be the same when <code>fixef = NULL</code>.
</p>
<p>When any treatment-by-covariate interactions are present in <code>formula</code>
or when <code>method = "MRI"</code>, covariates are centered at specific values to
ensure the resulting weights correspond to the desired estimand as supplied
to the <code>estimand</code> argument. For the ATE, the covariates are centered at
their means in the full sample. For the ATT and ATC, the covariates are
centered at their means in the treatment or control group (i.e., the
<code>focal</code> group), respectively. For the CATE, the covariates are centered
according to the argument supplied to <code>target</code> (see below). Note that
when covariate-by-covariate interactions are present, they will be centered
after computing the interaction rather than the interaction being computed
on the centered covariates unless <code>estimand = "CATE"</code>, in which case
the covariates will be centered at the values specified in <code>target</code>
prior to involvement in interactions.
</p>


<h4>Estimating a CATE</h4>

<p>When <code>estimand = "CATE"</code>, <code>target</code> can be supplied either as a
single target profile (i.e., a list or a data frame with one row) or as a
target dataset, potentially with its own sampling weights, which are
supplied to <code>target.weights</code>. The variables included in <code>target</code>
must correspond to all the named <em>covariates</em> in <code>formula</code>; for
example, if <code>formula = ~ X1 + log(X1) + X2 + X1:X2</code>, values in
<code>target</code> must be given for <code>X1</code> and <code>X2</code>, but not
<code>log(X1)</code> or <code>X1:X2</code>. To choose a target profile value for a
factor corresponding to a proportion (e.g., a target value of .5 for a
variable like <code>sex</code> indicating a target population with a 50-50 sex
split), the factor variable must be split into a numeric variable
beforehand, e.g., using <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code> or
<code>cobalt::splitfactor()</code>. <code>target</code> values cannot be given to
variables specified using <code>$</code>, <code style="white-space: pre;">&#8288;[[]]&#8288;</code>, or <code style="white-space: pre;">&#8288;[]&#8288;</code> (e.g.,
<code>data$X1</code>), so an error will be thrown if they are used in
<code>formula</code>. When a target dataset is supplied, covariates will be
centered at their means in the (<code>target.weights</code>-weighted) target
dataset.
</p>



<h4>Base weights and sampling weights</h4>

<p>Base weights (<code>base.weights</code>) and sampling weights (<code>s.weights</code>)
are similar in that they both involve combining weights with an outcome
regression model. However, they differ in a few ways. Sampling weights are
primarily used to adjust the target population; when the outcome model is
fit, it is fit using weighted least squares, and when target balance is
assessed, it is assessed using the sampling weighted population as the
target population. Centering of covariates in the outcome model is done
using the sampling weighted covariate means. Base weights are primarily used
to offer a second level of balancing beyond the implied regression weights;
they can be incorporated into the effect estimate either using weighted
least squares or using the augmented inverse probability weighting (AIPW)
estimator. Base weights do not change the target population, so when target
balance is assessed, it is assessed using the unweighted population as the
target population.
</p>
<p>Some forms of weights both change the target population and provide an extra
layer of balancing, like propensity score weights that target estimands
other than the ATT, ATC, or ATE (e.g., overlap weights), or matching weights
where the target population is defined by the matching (e.g., matching with
a caliper, cardinality matching, or coarsened exact matching). Because these
weights change the target population, they should be supplied to
<code>s.weights</code> to ensure covariates are appropriately centered. When there
are no treatment-by-covariate interactions and <code>method = "URI"</code>,
whether weights are supplied to <code>base.weights</code> or <code>s.weights</code> will
not matter for the estimation of the weights but will affect the target
population in <a href="#topic+summary.lmw">balance assessment</a>.
</p>
<p>When both <code>base.weights</code> and <code>s.weights</code> are supplied, e.g., when
the base weights are the result of a propensity score model fit with
sampling weights, it is assumed the base weights do not incorporate the
sampling weights; that is, it is assumed that to estimate a treatment effect
<em>without</em> regression adjustment, the base weights and the sampling
weights would have to be multiplied together. This is true, for example, for
the weights in a <code>matchit</code> or <code>weightit</code> object (see below) but
not for weights in the output of <code>MatchIt::match.data()</code> unless called
with <code>include.s.weights = FALSE</code> or weights resulting from
<code>CBPS::CBPS()</code>.
</p>



<h4>Regression after using <span class="pkg">MatchIt</span> or <span class="pkg">WeightIt</span></h4>

<p>Regression weights can be computed in a matched or weighted sample by
supplying a <code>matchit</code> or <code>weightit</code> object (from <span class="pkg">MatchIt</span> or
<span class="pkg">WeightIt</span>, respectively) to the <code>obj</code> argument of <code>lmw()</code>.
The estimand, focal group (if any), base weights, and sampling weights (if any) will be taken from
the supplied object and used in the calculation of the implied regression
weights, unless these have been supplied separately to <code>lmw()</code>. The
<code>weights</code> component of the supplied object containing the matching or
balancing weights will be passed to <code>base.weights</code> and the
<code>s.weights</code> component will be passed to <code>s.weights</code>. Arguments
supplied to <code>lmw()</code> will take precedence over the corresponding
components in the <code>obj</code> object.
</p>



<h4>Multi-category treatments</h4>

<p>There are a few differences when the
treatment has multiple (i.e., more than 2) categories. If <code>estimand</code> is
<code>"ATT"</code> or <code>"ATC"</code>, an argument should be supplied to <code>focal</code>
identifying which group is the treated or control (i.e., &quot;focal&quot;) group,
respectively.
</p>
<p>The key difference, though, is when <code>method = "URI"</code>, because in this
case the contrast between each pair of treatment groups has its own weights
and its own implied target population. Because <code>lmw()</code> only produces
one set of weights, an argument must be supplied to <code>contrast</code>
identifying which groups are to be used as the contrast for computing the
weights. In addition, to compute the treatment effect corresponding to the
chosen contrast as a weighted difference in outcome means, the difference
must be taken between the weighted mean of the non-reference group and the
weighted mean of <em>all other groups combined</em>, rather than simply the
weighted mean of the reference group.
</p>
<p>The implication of this is that contrast statistics computed in the weighted
sample involve all units, even those not in the contrasted groups, whereas
statistics computed in the unweighted sample only involve units in the
contrasted groups. See <code><a href="#topic+summary.lmw">summary.lmw()</a></code> for more information on
assessing balance using the regression weights for multi-category
treatments. Given these complications, it is generally best to use
<code>method = "MRI"</code> with multi-category treatments.
</p>



<h4>Fixed effects</h4>

<p>A fixed effects variable can be supplied to the
<code>fixef</code> argument. This is equivalent to adding the fixed effects
variable as a predictor that does not interact with the treatment or any
other covariate. The difference is that computation is much faster when the
fixed effect has many levels because demeaning is used rather than including
the fixed effect variable as a collection of dummy variables. When using
URI, the weights will be the same regardless of whether the fixed effect
variable is included as a covariate or supplied to <code>fixef</code>; when using
MRI, results will differ because the fixed effect variable does not interact
with treatment. The fixed effects variable will not appear in the
<code><a href="#topic+summary.lmw">summary.lmw()</a></code> output (but can be added using <code>addlvariables</code>
argument) or in the model output of <code><a href="#topic+lmw_est">lmw_est()</a></code> or
<code><a href="#topic+summary.lmw_est">summary.lmw_est()</a></code>. Because it does not interact with the
treatment, the distribution of the fixed effect variable may not correspond
to the target population, so caution should be used if it is expected the
treatment effect varies across levels of this variable (in which case it
should be included as a predictor). Currently only one fixed effect variable
is allowed.
</p>



<h3>Value</h3>

<p>An <code>lmw</code> object, which contains the following components:
</p>
<table role = "presentation">
<tr><td><code>treat</code></td>
<td>
<p>the treatment variable, given as a factor.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the
computed implied regression weights.</p>
</td></tr>
<tr><td><code>covs</code></td>
<td>
<p>a data frame containing
the covariates included the model formula.</p>
</td></tr>
<tr><td><code>estimand</code></td>
<td>
<p>the requested
estimand.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used to estimate the weights
(<code>"URI"</code> or <code>"MRI"</code>).</p>
</td></tr>
<tr><td><code>base.weights</code></td>
<td>
<p>the weights supplied to
<code>base.weights</code>.</p>
</td></tr>
<tr><td><code>s.weights</code></td>
<td>
<p>the weights supplied to
<code>s.weights</code>.</p>
</td></tr>
<tr><td><code>dr.method</code></td>
<td>
<p>when <code>base.weights</code> are supplied,
the method for computing the doubly-robust weights.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the
original call to <code>lmw()</code>.</p>
</td></tr>
<tr><td><code>fixef</code></td>
<td>
<p>the fixed effects variable if
supplied to <code>fixef</code>.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the model formula.</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>the supplied target profile or dataset when <code>estimand = "CATE"</code>,
after some initial processing. The <code>"target.weights"</code>
attribute contains the <code>target.weights</code> if supplied.</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>the contrasted treatment groups.</p>
</td></tr>
<tr><td><code>focal</code></td>
<td>
<p>the focal
treatment level when <code>estimand</code> is <code>"ATT"</code> or <code>"ATC"</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chattopadhyay, A., &amp; Zubizarreta, J. R. (2023). On the implied weights of linear regression for causal inference. <em>Biometrika</em>, 110(3), 615–629. <a href="https://doi.org/10.1093/biomet/asac058">doi:10.1093/biomet/asac058</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.lmw">summary.lmw()</a></code> for summarizing balance and
representativeness; <code><a href="#topic+plot.lmw">plot.lmw()</a></code> for plotting features of the
weights; <code><a href="#topic+lmw_est">lmw_est()</a></code> for estimating treatment effects from
<code>lmw</code> objects; <code><a href="#topic+influence.lmw">influence.lmw()</a></code> for influence measures;
<code><a href="stats.html#topic+lm">lm()</a></code> for fitting standard regression models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde")

# URI regression for ATT
lmw.out1 &lt;- lmw(~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                estimand = "ATT", method = "URI",
                treat = "treat")
lmw.out1
summary(lmw.out1)

# MRI regression for ATT
lmw.out2 &lt;- lmw(~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                estimand = "ATT", method = "MRI",
                treat = "treat")
lmw.out2
summary(lmw.out2)


# MRI regression for ATT after propensity score matching
m.out &lt;- MatchIt::matchit(treat ~ age + education + race +
                            married + nodegree + re74 + re75,
                          data = lalonde, method = "nearest",
                          estimand = "ATT")
lmw.out3 &lt;- lmw(~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                method = "MRI", treat = "treat", obj = m.out)
lmw.out3
summary(lmw.out3)

# MRI regression for CATE with given target profile
target.prof &lt;- list(age = 25, education = 11, race = "black",
                    married = 0, nodegree = 1, re74 = 0,
                    re75 = 0)
lmw.out4 &lt;- lmw(~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                estimand = "CATE", method = "MRI",
                treat = "treat", target = target.prof)
lmw.out4
summary(lmw.out4)

# MRI regression for CATE with given target dataset (in
# this case, will give the same as with estimand = "ATT")
target.data &lt;- subset(lalonde, treat == 1)
lmw.out4 &lt;- lmw(~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                estimand = "CATE", method = "MRI",
                treat = "treat", target = target.data)
lmw.out4
summary(lmw.out4)

# URI regression with fixed effects for 'race'
lmw.out5 &lt;- lmw(~ treat + age + education + married +
                  nodegree + re74 + re75, data = lalonde,
                method = "URI", treat = "treat",
                fixef = ~race)
lmw.out5

# Produces the same weights as when included as a covariate
all.equal(lmw.out1$weights, lmw.out5$weights)

# MRI for a multi-category treatment, ATT with 1 as the focal
# group
lmw.out6 &lt;- lmw(~ treat_multi + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                estimand = "ATT", method = "MRI",
                treat = "treat_multi", focal = "1")
lmw.out6
summary(lmw.out6)

# URI for a multi-category treatment; need to specify
# contrast because only two groups can be compared at
# a time
lmw.out7 &lt;- lmw(~ treat_multi + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                estimand = "ATE", method = "URI",
                treat = "treat_multi", contrast = c("2", "3"))
lmw.out7
summary(lmw.out7)

</code></pre>

<hr>
<h2 id='lmw_est'>Estimate a treatment effect from a linear model</h2><span id='topic+lmw_est'></span><span id='topic+lmw_est.lmw'></span><span id='topic+lmw_est.lmw_aipw'></span><span id='topic+lmw_est.lmw_iv'></span>

<h3>Description</h3>

<p><code>lmw_est()</code> fits the outcome regression corresponding to the model used
to compute the weights in the supplied <code>lmw</code> object and returns the
model coefficients and their covariance matrix. Use
<code><a href="#topic+summary.lmw_est">summary.lmw_est()</a></code> to compute and view the treatment effect and
potential outcome mean estimates and their standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmw_est(x, ...)

## S3 method for class 'lmw'
lmw_est(x, outcome, data = NULL, robust = TRUE, cluster = NULL, ...)

## S3 method for class 'lmw_aipw'
lmw_est(x, outcome, data = NULL, robust = TRUE, cluster = NULL, ...)

## S3 method for class 'lmw_iv'
lmw_est(x, outcome, data = NULL, robust = TRUE, cluster = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmw_est_+3A_x">x</code></td>
<td>
<p>an <code>lmw</code> or <code>lmw_iv</code> object; the output of a call to
<code><a href="#topic+lmw">lmw()</a></code> or <code><a href="#topic+lmw_iv">lmw_iv()</a></code>.</p>
</td></tr>
<tr><td><code id="lmw_est_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="sandwich.html#topic+vcovHC">sandwich::vcovHC()</a></code> or
<code><a href="sandwich.html#topic+vcovCL">sandwich::vcovCL()</a></code>.</p>
</td></tr>
<tr><td><code id="lmw_est_+3A_outcome">outcome</code></td>
<td>
<p>the name of the outcome variable. Can be supplied as a string
containing the name of the outcome variable or as the outcome variable
itself. If not supplied, the outcome variable in the <code>formula</code> supplied
to <code>lmw()</code> or <code>lmw_iv()</code>, if any, will be used.</p>
</td></tr>
<tr><td><code id="lmw_est_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the outcome variable named in
<code>outcome</code> and the cluster variable(s) when <code>cluster</code> is supplied
as a <code>formula</code>.</p>
</td></tr>
<tr><td><code id="lmw_est_+3A_robust">robust</code></td>
<td>
<p>whether to compute the robust covariance matrix for the model
coefficients. Allowable values include those allowed for the <code>type</code>
argument of <code><a href="sandwich.html#topic+vcovHC">sandwich::vcovHC()</a></code> or <code><a href="sandwich.html#topic+vcovCL">sandwich::vcovCL()</a></code>
when <code>cluster</code> is specified. Can also be specified as <code>TRUE</code> (the
default), which means <code>"HC3"</code> or <code>"HC1"</code> when <code>cluster</code> is
specified, or <code>FALSE</code>, which means <code>"const"</code> (i.e., the standard
non-robust covariance). When <code>cluster</code> is specified, <code>robust</code> will
be set to <code>TRUE</code> if <code>FALSE</code>. When AIPW is used, <code>robust</code> is
ignored; the HC0 robust covariance matrix is used.</p>
</td></tr>
<tr><td><code id="lmw_est_+3A_cluster">cluster</code></td>
<td>
<p>the clustering variable(s) for computing a cluster-robust
covariance matrix. See <code><a href="sandwich.html#topic+vcovCL">sandwich::vcovCL()</a></code>. If supplied as a
<code>formula</code>, the clustering variables must be present in the original
dataset used to compute the weights or <code>data</code>. When AIPW is used,
<code>cluster</code> is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lmw_est()</code> uses <code><a href="stats.html#topic+lm.fit">lm.fit()</a></code> or <code><a href="stats.html#topic+lm.wfit">lm.wfit()</a></code> to fit
the outcome regression model (and first stage model for <code>lmw_iv</code>
objects) and returns the output of these functions augmented with other
components related to the estimation of the weights. Unlike with
<code style="white-space: pre;">&#8288;lm.[w]fit()&#8288;</code>, the covariance matrix of the parameter estimates is also
included in the output.
</p>
<p>For <code>lmw</code> objects, the model fit is that supplied to the <code>formula</code>
input to <code>lmw()</code> except that it is fit in a dataset appropriately
centered to ensure the estimand corresponds with the one requested. When
<code>method = "MRI"</code> in the call to <code>lmw()</code>, the model is fit as an
interaction between the treatment and all the (centered) terms in the model
formula. The results will be similar to those from using <code><a href="stats.html#topic+lm">lm()</a></code> on
this model and supplied data except that the covariates are centered
beforehand. The product of the sampling weights and base weights supplied to
<code>lmw()</code>, if any, will be supplied to <code>lm.wfit()</code> to fit the model
using weighted least squares.
</p>
<p>For <code>lmw_aipw</code> objects, the model is fit as above except that base
weights are not included in the model fitting and are instead used to
compute additional augmentation terms that are added to the estimated
potential outcome means from the outcome regression. The variance-covariance
matrix is computed using M-estimation; this corresponds to the HC0 robust
covariance matrix for the model parameters with the base weights treated as
fixed, which yields conservative standard errors for the ATE. Inference is
only approximate for the ATT and ATC.
</p>
<p>For <code>lmw_iv</code> objects, the first stage model is constructed by removing
the treatment from the supplied model formula, adding the instrumental
variable as a main effect, and using the treatment variable as the outcome.
For the second stage (reduced form) model, the fitted values of the
treatment from the first stage model are used in place of the treatment in
the outcome model. The results are similar to those from using
<code>ivreg::ivreg()</code>, and the coefficients estimates will be the same
except for the intercept due to the centering of covariates.
</p>
<p>Although some coefficients in the model may be interpretable as treatment
effect estimates, <code><a href="#topic+summary.lmw_est">summary.lmw_est()</a></code> should be used to view and
extract the treatment effect and potential outcome mean estimates, standard
errors, and other model statistics. The output of <code>lmw_est()</code> should
rarely be used except to be supplied to <code>summary()</code>.
</p>


<h3>Value</h3>

<p>An <code>lmw_est</code> object with the following components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code>, <code>residuals</code>, <code>fitted.values</code>, <code>effects</code>, <code>weights</code>, <code>rank</code>, <code>df.residual</code>, <code>qr</code></td>
<td>
<p>for <code>lmw</code> objects, the output of the
<code><a href="stats.html#topic+lm.fit">lm.fit()</a></code> or <code><a href="stats.html#topic+lm.wfit">lm.wfit()</a></code> call used to fit the outcome
model. For <code>lmw_iv</code> objects, the output of the <code><a href="stats.html#topic+lm.fit">lm.fit()</a></code> or
<code><a href="stats.html#topic+lm.wfit">lm.wfit()</a></code> call used to fit the the second stage model, with
<code>residuals</code> corresponding to the residuals computed when substituting
the true treatment variable in place of the fitted treatment values in the
model.</p>
</td></tr>
<tr><td><code>model.matrix</code></td>
<td>
<p>the model matrix (supplied to the <code>x</code>
argument of <code>lm.fit</code>).</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the estimated covariance matrix of
the parameter estimates as produced by <code><a href="sandwich.html#topic+vcovHC">sandwich::vcovHC()</a></code> or
<code><a href="sandwich.html#topic+vcovCL">sandwich::vcovCL()</a></code>.</p>
</td></tr>
<tr><td><code>lmw.weights</code></td>
<td>
<p>the implied regression
weights computed by <code>lmw_est()</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call to
<code>lmw_est()</code>.</p>
</td></tr>
<tr><td><code>estimand</code></td>
<td>
<p>the requested estimand.</p>
</td></tr>
<tr><td><code>focal</code></td>
<td>
<p>the
focal treatment level when <code>estimand</code> is <code>"ATT"</code> or <code>"ATC"</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used to estimate the weights (<code>"URI"</code> or
<code>"MRI"</code>).</p>
</td></tr>
<tr><td><code>robust</code></td>
<td>
<p>the type standard error used.</p>
</td></tr>
<tr><td><code>outcome</code></td>
<td>
<p>the name of the outcome variable.</p>
</td></tr>
<tr><td><code>treat_levels</code></td>
<td>
<p>the
levels of the treatment.</p>
</td></tr>
</table>
<p>When AIPW is used, the object will be of class <code>lmw_est_aipw</code>, which
inherits from <code>lmw_est</code>, and contains the additional components:
</p>
<table role = "presentation">
<tr><td><code>coef_aipw</code></td>
<td>
<p>the model-predicted potential outcome means (<code>mu</code>) and
the augmentation terms (<code>aug</code>).</p>
</td></tr>
<tr><td><code>vcov_aipw</code></td>
<td>
<p>the covariance matrix
of the quantities in <code>coef_aipw</code>.</p>
</td></tr>
</table>
<p>When weights are included in the estimation (i.e., <code>base.weights</code> or
<code>s.weights</code> supplied to <code>lmw()</code> or <code>lmw_iv()</code>), any units
will weights equal to zero will be removed from the data prior to model
fitting.
</p>
<p>Methods exist for <code>lmw_est</code> objects for <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code>,
<code><a href="stats.html#topic+vcov">vcov()</a></code>, <code><a href="stats.html#topic+hatvalues">hatvalues()</a></code>, <code><a href="sandwich.html#topic+bread">sandwich::bread()</a></code>,
and <code><a href="sandwich.html#topic+estfun">sandwich::estfun()</a></code>, all of which are used internally to
compute the parameter estimate covariance matrix. The first two simply
extract the corresponding component from the <code>lmw_est</code> object and the
last three imitate the corresponding methods for <code>lm</code> objects (or
<code>ivreg</code> objects for <code>lmw_iv</code> inputs). Other regression-related
functions, such as <code><a href="stats.html#topic+coef">coef()</a></code>, <code><a href="stats.html#topic+residuals">residuals()</a></code>, and
<code><a href="stats.html#topic+fitted">fitted()</a></code>, use the default methods and should work correctly with
<code>lmw_est</code> objects.
</p>
<p>Note that when fixed effects are supplied through the <code>fixef</code> argument
to <code>lmw()</code> or <code>lmw_iv()</code>, standard error estimates computed using
functions outside <span class="pkg">lmw</span> may not be accurate due to issues relating to
degrees of freedom. In particular, this affects conventional and HC1-robust
standard errors. Otherwise, <code>sandwich::vcovHC()</code> can be used to compute
standard errors (setting <code>type = "const"</code> for conventional standard
errors), though <code>sandwich::vcovCL()</code> may not work as expected and
should not be used. To calculate cluster-robust standard errors, supply an
argument to <code>cluster</code> in <code>lmw_est()</code>.
</p>


<h3>Note</h3>

<p><code>lmw_est()</code> uses non-standard evaluation to interpret its
<code>outcome</code> argument. For programmers who wish to use <code>lmw_est()</code>
inside other functions, an effective way to pass the name of an arbitrary
outcome (e.g., <code>y</code> passed as a string) is to use <code><a href="base.html#topic+do.call">do.call()</a></code>,
for example: </p>
<pre>fun &lt;- function(model, outcome, data) {
do.call("lmw_est", list(model, outcome, data)) } </pre><p> When using
<code>lmw_est()</code> inside <code><a href="base.html#topic+lapply">lapply()</a></code> or <code>purrr::map</code> to loop
over outcomes, this syntax must be used as well.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.lmw_est">summary.lmw_est()</a></code> for viewing and extracting the
treatment effect and potential outcome mean estimates, standard errors, and
other model statistics; <code><a href="#topic+lmw">lmw()</a></code> or <code><a href="#topic+lmw_iv">lmw_iv()</a></code> for
estimating the weights that correspond to the model estimated by
<code>lmw_est()</code>; <code><a href="stats.html#topic+lm">lm()</a></code> and <code><a href="stats.html#topic+lm.fit">lm.fit()</a></code> for fitting the
corresponding model; <code>ivreg()</code> in the <span class="pkg">ivreg</span> package for fitting
2SLS models; <code><a href="#topic+influence.lmw_est">influence.lmw_est()</a></code> for influence measures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde")

# MRI regression for ATT
lmw.out1 &lt;- lmw(~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                  estimand = "ATT", method = "MRI",
                  treat = "treat")

lmw.fit1 &lt;- lmw_est(lmw.out1, outcome = "re78")
lmw.fit1

summary(lmw.fit1)


# MRI regression for ATT after propensity score matching
m.out &lt;- MatchIt::matchit(treat ~ age + education + race +
                            married + nodegree + re74 + re75,
                          data = lalonde, method = "nearest",
                          estimand = "ATT")
lmw.out2 &lt;- lmw(~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                method = "MRI", treat = "treat", obj = m.out)

## Using a cluster-robust SE with subclass (pair membership)
## as the cluster variable
lmw.fit2 &lt;- lmw_est(lmw.out2, outcome = "re78", cluster = ~subclass)
lmw.fit2

summary(lmw.fit2)

# AIPW for ATE with MRI regression after propensity score
# weighting
ps &lt;- glm(treat ~ age + education + race + married + nodegree +
            re74 + re75, data = lalonde,
            family = binomial)$fitted
ipw &lt;- ifelse(lalonde$treat == 1, 1/ps, 1/(1-ps))

lmw.out3 &lt;- lmw(re78 ~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                method = "MRI", treat = "treat",
                base.weights = ipw, dr.method = "AIPW")
lmw.fit3 &lt;- lmw_est(lmw.out3)
lmw.fit3

summary(lmw.fit3)

# MRI for multi-category treatment ATE
lmw.out3 &lt;- lmw(~ treat_multi + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                estimand = "ATE", method = "MRI",
                treat = "treat_multi")
lmw.fit3 &lt;- lmw_est(lmw.out3, outcome = "re78")
lmw.fit3

summary(lmw.fit3)
</code></pre>

<hr>
<h2 id='lmw_iv'>Compute instrumental variable regression-implied weights</h2><span id='topic+lmw_iv'></span>

<h3>Description</h3>

<p>Computes the weights implied by an instrumental variable (IV) model that
would estimate a weighted difference in outcome means equal to the treatment
effect resulting from the supplied model fit with two-stage least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmw_iv(
  formula,
  data = NULL,
  estimand = "ATE",
  method = "URI",
  treat = NULL,
  iv,
  base.weights = NULL,
  s.weights = NULL,
  obj = NULL,
  fixef = NULL,
  target = NULL,
  target.weights = NULL,
  contrast = NULL,
  focal = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmw_iv_+3A_formula">formula</code></td>
<td>
<p>a one-sided formula with the treatment and covariates on the
right-hand side corresponding to the second-stage (reduced form) outcome
regression model to be fit. If an outcome variable is supplied on the
left-hand side, it will be ignored. This model should not include an IV. See
Details for how this formula is interpreted in light of other options.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>,
<code>treat</code>, and <code>iv</code>.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_estimand">estimand</code></td>
<td>
<p>the estimand of interest, which determines how covariates
are centered. Should be one of <code>"ATE"</code> for the average treatment
effect, <code>"ATT"</code> for the average treatment effect in the treated,
<code>"ATC"</code> for the average treatment effect in the control, or
<code>"CATE"</code> for the conditional average treatment effect. When
<code>estimand = "CATE"</code>, an argument to <code>target</code> must be supplied.
This argument also affects what <code><a href="#topic+summary.lmw">summary.lmw()</a></code> considers to be
the target population. Default is <code>"ATE"</code> unless <code>obj</code> is
specified, in which case it takes its value from the supplied object.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_method">method</code></td>
<td>
<p>the method used to estimate the weights; either <code>"URI"</code>
(the default) for uni-regression imputation weights, where a single model is
fit to the whole dataset, or <code>"MRI"</code> for multi-regression imputation,
where the covariates fully interact with the treatment. This affects the
interpretation of <code>formula</code>. See Details.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_treat">treat</code></td>
<td>
<p>the name of the treatment variable in <code>data</code>. If
unspecified, the first variable present in <code>formula</code> will be taken as
the treatment variable with a message. Currently, only binary treatments are
supported. See Details.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_iv">iv</code></td>
<td>
<p>a character vector or one-sided formula containing the names of
the IVs in <code>data</code>. These variables should not appear in <code>formula</code>.
Multiple IVs are allowed. See Details. This argument is required.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_base.weights">base.weights</code></td>
<td>
<p>a vector of base weights. See Details. If omitted and
<code>obj</code> is specified, the weights from the supplied object will be used.
Can be supplied as a numeric vector, a string containing the name of the
variable in <code>data</code> containing the base weights, or the unquoted name of
the variable in <code>data</code> containing the base weights.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_s.weights">s.weights</code></td>
<td>
<p>a vector of sampling weights. See Details. If omitted and
<code>obj</code> is specified, the sampling weights from the supplied object will
be used. Can be supplied as a numeric vector, a string containing the name
of the variable in <code>data</code> containing the sampling weights, or the
unquoted name of the variable in <code>data</code> containing the sampling
weights.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_obj">obj</code></td>
<td>
<p>a <code>matchit</code> or <code>weightit</code> object corresponding to the
matched or weighted sample in which the implied IV regression would take
place. See Details.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_fixef">fixef</code></td>
<td>
<p>optional; a string or one-sided formula containing the name of
the fixed effects variable in <code>data</code>. See Details.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_target">target</code></td>
<td>
<p>a list or data frame containing the target values for each
covariate included in <code>formula</code>. Ignored with a warning when
<code>estimand</code> is not <code>"CATE"</code>.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_target.weights">target.weights</code></td>
<td>
<p>a vector of sampling weights to be applied to
<code>target</code> when supplied as a data frame. Ignored with a warning when
<code>estimand</code> is not <code>"CATE"</code>.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_contrast">contrast</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="lmw_iv_+3A_focal">focal</code></td>
<td>
<p>the level of the treatment variable to be considered &quot;focal&quot;
(i.e., the &quot;treated&quot; level when <code>estimand = "ATT"</code> or the control level
when <code>estimand = "ATC"</code>). Ignored when <code>estimand</code> is <code>"ATE"</code>
or <code>"CATE"</code>. For binary treatments, this generally does not need to be
supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lmw_iv()</code> computes weights that make the weighted difference in
outcome means between the treatment groups equal to the two-stage least
squares (2SLS) estimate of the treatment effect. <code>formula</code> corresponds
to the second-stage (reduced form) model, with the treatment replaced by its
fitted values resulting from the first stage model. The first stage is fit
by replacing the treatment in the supplied <code>formula</code> with the IVs named
in <code>iv</code> and using the treatment as the outcome. The treatment is
assumed to be endogenous and the supplied instrumental variables assumed to
be instruments conditional on the other covariates, which are assumed to to
be exogenous.
</p>
<p>When any treatment-by-covariate interactions are present in <code>formula</code>
or when <code>method = "MRI"</code>, covariates are centered at specific values to
ensure the resulting weights correspond to the desired estimand as supplied
to the <code>estimand</code> argument. For the ATE, the covariates are centered at
their means in the full sample. For the ATT and ATC, the covariates are
centered at their means in the treatment or control group (i.e., the
<code>focal</code> group), respectively. For the CATE, the covariates are centered
according to the argument supplied to <code>target</code> (see below). Note that
when covariate-by-covariate interactions are present, they will be centered
after computing the interaction rather than the interaction being computed
on the centered covariates unless <code>estimand = "CATE"</code>, in which case
the covariates will be centered at the values specified in <code>target</code>
prior to involvement in interactions. Note that the resulting effect estimate
does not actually correspond to the estimand supplied unless all effect
heterogeneity is due to the included covariates.
</p>
<p>When treatment-by-covariate interactions are included in <code>formula</code>,
additional instruments will be formed as the product of the supplied IVs and
the interacting covariates. When <code>method = "MRI"</code>, instruments will be
formed as the product of the supplied IVs and each of the covariates. All
treatment-by-covariate interactions are considered endogenous.
</p>


<h4>Base weights and sampling weights</h4>

<p>Base weights (<code>base.weights</code>) and sampling weights (<code>s.weights</code>)
are similar in that they both involve combining weights with an outcome
regression model. However, they differ in a few ways. Sampling weights are
primarily used to adjust the target population; when the outcome model is
fit, it is fit using weighted least squares, and when target balance is
assessed, it is assessed using the sampling weighted population as the
target population. Centering of covariates in the outcome model is done
using the sampling weighted covariate means. Base weights are primarily used
to offer a second level of balancing beyond the implied regression weights,
i.e., to fit the 2SLS models in the base-weighted sample. Base weights do
not change the target population, so when target balance is assessed, it is
assessed using the unweighted population as the target population.
</p>
<p>Some forms of weights both change the target population and provide an extra
layer of balancing, like propensity score weights that target estimands
other than the ATT, ATC, or ATE (e.g., overlap weights), or matching weights
where the target population is defined by the matching (e.g., matching with
a caliper, cardinality matching, or coarsened exact matching). Because these
weights change the target population, they should be supplied to
<code>s.weights</code> to ensure covariates are appropriately centered. In
<code>lmw_iv()</code>, whether weights are supplied to <code>base.weights</code> or
<code>s.weights</code> will not matter for the estimation of the weights but will
affect the target population in <a href="#topic+summary.lmw">balance assessment</a>.
</p>
<p>When both <code>base.weights</code> and <code>s.weights</code> are supplied, e.g., when
the base weights are the result of a propensity score model fit with
sampling weights, it is assumed the base weights do not incorporate the
sampling weights; that is, it is assumed that to estimate a treatment effect
<em>without</em> regression adjustment, the base weights and the sampling
weights would have to be multiplied together. This is true, for example, for
the weights in a <code>matchit</code> or <code>weightit</code> object (see below) but
not for weights in the output of <code>MatchIt::match.data()</code> unless called
with <code>include.s.weights = FALSE</code> or weights resulting from
<code>CBPS::CBPS()</code>.
</p>



<h4>2SLS after using <span class="pkg">MatchIt</span> or <span class="pkg">WeightIt</span></h4>

<p>Instrumental variable regression weights can be computed in a matched or weighted sample
by supplying a <code>matchit</code> or <code>weightit</code> object (from <span class="pkg">MatchIt</span>
or <span class="pkg">WeightIt</span>, respectively) to the <code>obj</code> argument of <code>lmw()</code>.
The estimand, base weights, and sampling weights (if any) will be taken from
the supplied object and used in the calculation of the implied regression
weights, unless these have been supplied separately to <code>lmw_iv()</code>. The
<code>weights</code> component of the supplied object containing the matching or
balancing weights will be passed to <code>base.weights</code> and the
<code>s.weights</code> component will be passed to <code>s.weights</code>. Arguments
supplied to <code>lmw_iv()</code> will take precedence over the corresponding
components in the <code>obj</code> object.
</p>



<h4>Multi-category treatments</h4>

<p>Multi-category treatments are not
currently supported for <code>lmw_iv()</code>.
</p>



<h4>Fixed effects</h4>

<p>A fixed effects variable can be supplied to the
<code>fixef</code> argument. This is equivalent to adding the fixed effects
variable as an exogenous predictor that does not interact with the
treatment, IV, or any other covariate. The difference is that computation is
much faster when the fixed effect has many levels because demeaning is used
rather than including the fixed effect variable as a collection of dummy
variables. When using URI, the weights will be the same regardless of
whether the fixed effect variable is included as a covariate or supplied to
<code>fixef</code>; when using MRI, results will differ because the fixed effect
variable does not interact with treatment. The fixed effects variable will
not appear in the <code><a href="#topic+summary.lmw">summary.lmw()</a></code> output (but can be added using
<code>addlvariables</code> argument) or in the model output of <code><a href="#topic+lmw_est">lmw_est()</a></code> or
<code><a href="#topic+summary.lmw_est">summary.lmw_est()</a></code>. Because it does not interact with the
treatment, the distribution of the fixed effect variable may not correspond
to the target population, so caution should be used if it is expected the
treatment effect varies across levels of this variable (in which case it
should be included as a predictor). Currently only one fixed effect variable
is allowed.
</p>



<h3>Value</h3>

<p>An <code>lmw_iv</code> object, which inherits from <code>lmw</code> objects and
contains the following components:
</p>
<table role = "presentation">
<tr><td><code>treat</code></td>
<td>
<p>the treatment variable,
given as a factor.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the computed implied regression weights.</p>
</td></tr>
<tr><td><code>covs</code></td>
<td>
<p>a data frame containing the covariates included the model
formula.</p>
</td></tr>
<tr><td><code>estimand</code></td>
<td>
<p>the requested estimand.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method
used to estimate the weights (<code>"URI"</code> or <code>"MRI"</code>).</p>
</td></tr>
<tr><td><code>base.weights</code></td>
<td>
<p>the weights supplied to <code>base.weights</code>.</p>
</td></tr>
<tr><td><code>s.weights</code></td>
<td>
<p>the weights supplied to <code>s.weights</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the
original call to <code>lmw_iv()</code>.</p>
</td></tr>
<tr><td><code>fixef</code></td>
<td>
<p>the fixed effects variable
if supplied to <code>fixef</code>.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the model formula.</p>
</td></tr>
<tr><td><code>iv</code></td>
<td>
<p>the instrumental variables, given as a one-sided formula.</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>the supplied covariate target values when <code>estimand = "CATE"</code>, after some initial processing.</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>the contrasted
treatment groups.</p>
</td></tr>
<tr><td><code>focal</code></td>
<td>
<p>the focal treatment levels when
<code>estimand</code> is <code>"ATT"</code> or <code>"ATC"</code>.</p>
</td></tr>
</table>
<p>All functions that lack a specific <code>lmw_iv</code> method work with
<code>lmw_iv</code> objects as they do for <code>lmw</code> objects, such as
<code><a href="#topic+summary.lmw">summary.lmw()</a></code>, <code><a href="#topic+plot.lmw">plot.lmw()</a></code>, etc.
</p>


<h3>References</h3>

<p>Chattopadhyay, A., &amp; Zubizarreta, J. R. (2023). On the implied weights of linear regression for causal inference. <em>Biometrika</em>, 110(3), 615–629. <a href="https://doi.org/10.1093/biomet/asac058">doi:10.1093/biomet/asac058</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.lmw">summary.lmw()</a></code> for summarizing balance and
representativeness; <code><a href="#topic+plot.lmw">plot.lmw()</a></code> for plotting features of the
weights; <code><a href="#topic+lmw_est">lmw_est()</a></code> for estimating treatment effects from
<code>lmw_iv</code> objects; <code><a href="#topic+influence.lmw">influence.lmw()</a></code> for influence measures;
<code>ivreg()</code> in the <span class="pkg">ivreg</span> package for fitting 2SLS models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># URI for the ATT using instrument `Ins`
lmw.out &lt;- lmw_iv(~ treat + age + education + race +
                    re74, data = lalonde,
                  estimand = "ATT", method = "URI",
                  treat = "treat", iv = ~Ins)
lmw.out
summary(lmw.out, addlvariables = ~married + re75)
</code></pre>

<hr>
<h2 id='plot.lmw'>Plots diagnosing regression-implied weights</h2><span id='topic+plot.lmw'></span>

<h3>Description</h3>

<p>Produces plots to diagnose properties of the weights, including their
distribution, to what degree the distribution of covariates involves
extrapolation in the weighted sample, and how much influence each unit has
on the effect estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmw'
plot(x, type = "weights", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lmw_+3A_x">x</code></td>
<td>
<p>an <code>lmw</code> object; the output of a call to <code><a href="#topic+lmw">lmw()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.lmw_+3A_type">type</code></td>
<td>
<p>the type of plot to display. Allowable options include
<code>"weights"</code>, <code>"extrapolation"</code>, and <code>"influence"</code>. See
Details. Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="plot.lmw_+3A_...">...</code></td>
<td>
<p>further arguments passed to specific types of plots.
</p>
<p>When <code>type = "weights"</code>, the following are accepted:
</p>

<dl>
<dt><code>rug</code></dt><dd><p><code>logical</code>; whether to display a rug plot of the
weights. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>mean</code></dt><dd><p>whether to display a
red line indicating the mean of the weights. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>ess</code></dt><dd><p>whether to display the original and weighted effective
sample size in the top right corner. Default is <code>TRUE</code>.</p>
</dd>
</dl>

<p>Other arguments are passed to <code><a href="stats.html#topic+density">density()</a></code>.
</p>
<p>When <code>type = "extrapolation"</code>, the following are accepted:
</p>

<dl>
<dt><code>variables</code></dt><dd><p>required; a right-sided formula or character vector
containing the names of the covariates for which extrapolation is to be
assessed.</p>
</dd>
<dt><code>data</code></dt><dd><p>an optional data frame containing the
variables named in <code>variables</code>.</p>
</dd>
</dl>

<p>When <code>type = "influence"</code>, the
following are accepted:
</p>

<dl>
<dt><code>outcome</code></dt><dd><p>the name of the
outcome variable. Can be supplied as a string containing the name of the
outcome variable or as the outcome variable itself. If not supplied, the
outcome variable in the <code>formula</code> supplied to <code>lmw()</code>, if any,
will be used.</p>
</dd>
<dt><code>data</code></dt><dd><p>an optional data frame containing the
outcome variable named in <code>outcome</code>.</p>
</dd>
<dt><code>id.n</code></dt><dd><p>the number of
points to be labelled in the plot, starting with the most extreme.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>type = "weights"</code>, <code>plot.lmw()</code> produces a density plot of
the weights within each treatment group. By construction, these weights will
have a mean of 1. Some weights may be negative. The effective sample size
(ESS) and original sample size (N) will be displayed in the upper right
corner of the plot when <code>ess = TRUE</code>.
</p>
<p>When <code>type = "extrapolation"</code>, <code>plot.lmw()</code> produces a plot of the
distribution of weights and covariates for each treatment group. Each dot
represents a unit, with values arranged on the x-axis according to their
covariate value and the size of the dots corresponding to the magnitude of
the weight. Units with positive weights are displayed in black in the upper
portion of the plot, and units with negative weights are displayed in red in
the lower portion. Having many and large red points indicates a high degree
of extrapolation. All points are equally transparent, so darker regions
indicate multiple points with the same value. The vertical lines indicates
the weighted mean of the covariate in each group, and the X indicates the
mean of the covariate in the target sample as determined by the
<code>estimand</code> argument in the original call to <code>lmw()</code>. A large
discrepancy between the vertical lines and Xs indicates a lack of balance
between the treatment group and target sample. When <code>estimand = "CATE"</code>
in the original call to <code>lmw()</code>, any variables supplied to <code>variables</code>
that were not given a target value will not have the target mean displayed.
</p>
<p>When <code>type = "influence"</code>, <code>plot.lmw()</code> produces a plot of the
scaled sample influence curve (SIC) for each unit by index. It does so by
calling <code><a href="#topic+influence.lmw">influence.lmw()</a></code>, which fits the outcome model to extract
residuals and compute the SIC as <code>SIC = (N-1) * w * r / (1 - h)</code>, where
<code>N</code> is the sample size, <code>w</code> are the units' implied regression
weights, <code>r</code> are the residuals, and <code>h</code> are the hat values. SIC
values are scaled to have a maximum of 1. Higher values indicate greater
relative influence.
</p>


<h3>Value</h3>

<p>A plot is displayed, and <code>x</code> is invisibly returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmw">lmw()</a></code>, <code><a href="#topic+summary.lmw">summary.lmw()</a></code>,
<code><a href="#topic+plot.summary.lmw">plot.summary.lmw()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde")

# URI regression for ATT
lmw.out1 &lt;- lmw(~ treat + age + education + race + married +
                   nodegree + re74 + re75, data = lalonde,
                estimand = "ATT", method = "URI",
                treat = "treat")
lmw.out1

# Distribution of weights
plot(lmw.out1, type = "weights")

# Extrapolation/representativeness for age and married
plot(lmw.out1, type = "extrapolation",
     variables = ~age + married)

# Extrapolation/representativeness for race
plot(lmw.out1, type = "extrapolation",
     variables = ~race)

# Influence for re78 outcome
plot(lmw.out1, type = "influence", outcome = "re78")
</code></pre>

<hr>
<h2 id='plot.lmw_est'>Plot diagnostics for an <code>lmw_est</code> object</h2><span id='topic+plot.lmw_est'></span>

<h3>Description</h3>

<p>Produces plots to diagnose the regression model fit to estimate the
treatment effect. These include an influence plot based on the sample
influence curve (SIC) and the regression diagnostics plots available for
<code>lm</code> objects in <code><a href="stats.html#topic+plot.lm">plot.lm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmw_est'
plot(x, type = "influence", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lmw_est_+3A_x">x</code></td>
<td>
<p>an <code>lmw_est</code> object; the output of a call to
<code><a href="#topic+lmw_est">lmw_est()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.lmw_est_+3A_type">type</code></td>
<td>
<p>the type of plot to display. Allowable options include
<code>"influence"</code> and <code>"lm"</code>. See Details. Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="plot.lmw_est_+3A_...">...</code></td>
<td>
<p>When <code>type = "influence"</code>, the following are accepted:
</p>

<dl>
<dt><code>outcome</code></dt><dd><p>the name of the outcome variable. Can be
supplied as a string containing the name of the outcome variable or as the
outcome variable itself. If not supplied, the outcome variable in the
<code>formula</code> supplied to <code>lmw()</code>, if any, will be used.</p>
</dd>
<dt><code>data</code></dt><dd><p>an optional data frame containing the outcome variable
named in <code>outcome</code>.</p>
</dd>
<dt><code>id.n</code></dt><dd><p>the number of points to be
labelled in the plot, starting with the most extreme.</p>
</dd>
</dl>

<p>When <code>type = "lm"</code>, any arguments passed to <code><a href="stats.html#topic+plot.lm">plot.lm()</a></code> are accepted and passed
directly to <code>plot.lm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>type = "influence"</code>, <code>plot.lmw_est()</code> produces a plot of the
scaled sample influence curve (SIC) for each unit by index. It does so by
calling <code><a href="#topic+influence.lmw_est">influence.lmw_est()</a></code>, which extract the model residuals
and computes the SIC as <code>SIC = (N-1) * w * r / (1 - h)</code>, where <code>N</code>
is the sample size, <code>w</code> are the units' implied regression weights,
<code>r</code> are the residuals, and <code>h</code> are the hat values. SIC values are
scaled to have a maximum of 1. Higher values indicate greater relative
influence.
</p>
<p>When <code>type = "lm"</code>, <code>plot.lmw_est()</code> produces several plots
displayed sequentially according to the arguments supplied to <code>plot()</code>.
These plots are produced by <code><a href="stats.html#topic+plot.lm">plot.lm()</a></code> to diagnose the
distribution of residuals and other measures of leverage and influence.
</p>


<h3>Value</h3>

<p>A plot is displayed, and <code>x</code> is invisibly returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmw_est">lmw_est()</a></code>, <code><a href="#topic+influence.lmw_est">influence.lmw_est()</a></code>,
<code><a href="stats.html#topic+plot.lm">plot.lm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde")

# URI regression for ATT
lmw.out1 &lt;- lmw(~ treat + age + education + race + married +
                   nodegree + re74 + re75, data = lalonde,
                estimand = "ATT", method = "URI",
                treat = "treat")

lmw.fit1 &lt;- lmw_est(lmw.out1, outcome = "re78")
lmw.fit1

# Influence using SIC
plot(lmw.fit1, type = "influence")

# Usual regression diagnostics
plot(lmw.fit1, type = "lm", which = 1)
</code></pre>

<hr>
<h2 id='plot.summary.lmw'>Produce a Love plot of balance statistics</h2><span id='topic+plot.summary.lmw'></span>

<h3>Description</h3>

<p>Produces Love plots (also known as dot plots) of balance statistics to
summarize balance visually. The plots are generated using
<code><a href="graphics.html#topic+dotchart">dotchart()</a></code> and <code><a href="graphics.html#topic+points">points()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lmw'
plot(
  x,
  stats,
  abs = TRUE,
  var.order = "data",
  threshold = NULL,
  layout = "vertical",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.summary.lmw_+3A_x">x</code></td>
<td>
<p>a <code>summary.lmw</code> object; the output of a call to
<code><a href="#topic+summary.lmw">summary.lmw()</a></code> with <code>standardize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.lmw_+3A_stats">stats</code></td>
<td>
<p>a vector of the names of the columns in the <code>summary.lmw</code>
output to plot; more than one is allowed. Abbreviations allowed. When
unspecified, the TSMD statistics for each treatment group will be plotted.</p>
</td></tr>
<tr><td><code id="plot.summary.lmw_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether the statistics should be plotted in
absolute value (<code>TRUE</code>) or not (<code>FALSE</code>). Default is <code>TRUE</code>.
This does not affect the display of KS statistics (which are always
non-negative). When <code>TRUE</code> and standardized mean differences are
displayed, the x-axis title will be &quot;TASMD&quot;, i.e., target absolute
standardized mean difference.</p>
</td></tr>
<tr><td><code id="plot.summary.lmw_+3A_var.order">var.order</code></td>
<td>
<p>how the variables should be ordered. Allowable options
include <code>"data"</code>, ordering the variables as they appear in the summary
output, <code>"alphabetical"</code>, ordering the variables alphabetically, and,
when <code>un = TRUE</code> in the call to <code>summary.lmw()</code>,
<code>"unadjusted"</code>, ordering the variables by the first statistic in
<code>stats</code> in the unadjusted sample. Default is <code>"data"</code>.
Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="plot.summary.lmw_+3A_threshold">threshold</code></td>
<td>
<p>numeric values at which to place vertical lines indicating
a balance threshold. These can make it easier to see for which variables
balance has been achieved given a threshold. Multiple values can be supplied
to add multiple lines. When <code>abs = FALSE</code>, the lines will be displayed
on both sides of zero. The lines are drawn with <code>abline</code> with the
linetype (<code>lty</code>) argument corresponding to the order of the entered
variables (see options at <code><a href="graphics.html#topic+par">par()</a></code>). Enter a value as <code>NA</code> to
skip that value of <code>lty</code> (e.g., <code>c(NA, .05)</code> to have only a dashed
vertical line at .05).</p>
</td></tr>
<tr><td><code id="plot.summary.lmw_+3A_layout">layout</code></td>
<td>
<p>how the multiple plots should be laid out. Allowable options
include <code>"vertical"</code> (the default) and <code>"horizontal"</code>.
Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="plot.summary.lmw_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+dotplot">dotplot()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Love plots will be produced for the requested statistics in the
<code>summary.lmw</code> output. How these plots are arranged depends on the value
supplied to <code>layout</code>, which uses <code><a href="graphics.html#topic+layout">layout()</a></code> to arrange the
plots.
</p>


<h3>Value</h3>

<p>A plot is displayed, and <code>x</code> is invisibly returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.lmw">summary.lmw()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde")

# URI regression for ATT
lmw.out1 &lt;- lmw(~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                estimand = "ATT", method = "URI",
                treat = "treat")
lmw.out1
(s &lt;- summary(lmw.out1))

plot(s)
plot(s, stats = "SMD", abs = FALSE)
</code></pre>

<hr>
<h2 id='summary.lmw'>Assess balance for an <code>lmw</code> object</h2><span id='topic+summary.lmw'></span><span id='topic+summary.lmw_multi'></span><span id='topic+print.summary.lmw'></span>

<h3>Description</h3>

<p>Computes balance statistics for an <code>lmw</code> object created by
<code><a href="#topic+lmw">lmw()</a></code>. Balance involves not only the similarity between the treatment
groups but also the similarity between each treatment group and the target
population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmw'
summary(
  object,
  un = TRUE,
  addlvariables = NULL,
  standardize = TRUE,
  data = NULL,
  stat = "balance",
  ...
)

## S3 method for class 'lmw_multi'
summary(
  object,
  un = TRUE,
  addlvariables = NULL,
  standardize = TRUE,
  data = NULL,
  contrast = NULL,
  stat = "balance",
  ...
)

## S3 method for class 'summary.lmw'
print(x, digits = max(3, getOption("digits") - 4), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lmw_+3A_object">object</code></td>
<td>
<p>an <code>lmw</code> object; the output of a call to <code><a href="#topic+lmw">lmw()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.lmw_+3A_un">un</code></td>
<td>
<p><code>logical</code>; whether to display balance statistics for the sample
prior to weighting and, additionally, with base weights applied (if
supplied). If <code>s.weights</code> were supplied to <code>lmw()</code>, the unadjusted sample
will be weighted by the sampling weights.</p>
</td></tr>
<tr><td><code id="summary.lmw_+3A_addlvariables">addlvariables</code></td>
<td>
<p>additional variables for which balance statistics are to
be computed along with the covariates in the <code>lmw</code> object. Can be entered
in one of three ways: as a data frame of covariates with as many rows as
there were units in the original <code>lmw()</code> call, as a string containing the
names of variables in <code>data</code>, or as a right-sided formula with the
additional variables (and possibly their transformations) found in <code>data</code>,
the environment, or the <code>lmw</code> object.</p>
</td></tr>
<tr><td><code id="summary.lmw_+3A_standardize">standardize</code></td>
<td>
<p><code>logical</code>; whether to compute standardized (<code>TRUE</code>) or
unstandardized (<code>FALSE</code>) mean differences. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.lmw_+3A_data">data</code></td>
<td>
<p>a optional data frame containing variables named in
<code>addlvariables</code> if specified as a string or formula.</p>
</td></tr>
<tr><td><code id="summary.lmw_+3A_stat">stat</code></td>
<td>
<p><code>character</code>; whether to display balance statistics (i.e.,
standardized mean differences and Kolmogorv-Smirnov statistics;
<code>"balance"</code>) or distribution statistics (i.e., means and standard
deviations; <code>"distribution"</code>). Default is <code>"balance"</code>. Abbreviations
allowed.</p>
</td></tr>
<tr><td><code id="summary.lmw_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="summary.lmw_+3A_contrast">contrast</code></td>
<td>
<p>for multi-category treatments with <code>method = "MRI"</code>, which
two groups should be compared. If <code>NULL</code>, only target balance statistics
will be displayed. Ignored with binary treatments or when <code>method = "URI"</code>.</p>
</td></tr>
<tr><td><code id="summary.lmw_+3A_x">x</code></td>
<td>
<p>a <code>summary.lmw</code> object.</p>
</td></tr>
<tr><td><code id="summary.lmw_+3A_digits">digits</code></td>
<td>
<p>the number of digits to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.lmw()</code> produces covariate balance or distribution
statistics and effective samples sizes before and after adjustment by the
regression weights and base weights, if supplied. For each covariate, the
following balance statistics are computed when <code>stat = "balance"</code>:
</p>

<ul>
<li> <p><code>SMD</code> - the standardized mean difference (SMD) between the
treated and control groups
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;TSMD Treated&#8288;</code> - the target
standardized mean difference (TSMD) between the treated group and target
sample
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;TSMD Control&#8288;</code> - the TSMD between between the control
group and target sample
</p>
</li>
<li> <p><code>KS</code> - the Kolmogorov-Smirnov (KS)
statistic between the treated and control groups
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;TKS Treated&#8288;</code> -
the target KS (TKS) statistic between the treated group and target sample
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;TKS Control&#8288;</code> - the TKS statistic between the control group and
target sample
</p>
</li></ul>

<p>For multi-category treatments with <code>method = "MRI"</code>, balance statistics are
are computed between each treatment group and the target sample.
</p>
<p>When <code>stat = "distribution"</code> the mean and standard deviation of each
covariate is compute before and after adjustment and for the target sample.
(Standard deviations are printed in parentheses for visual clarity.)
</p>
<p>After weighting with the regression weights, the mean difference between
the treated and control groups of each covariate included in the original
call to <code>lmw()</code> will be equal to zero. However, the mean difference between
each treatment group and the target sample may not be equal to zero when
<code>method = "URI"</code> in the call to <code>lmw()</code>, and covariates supplied to
<code>addlvariables</code> not included in the call to <code>lmw()</code> may not be well
balanced.
</p>
<p>When <code>s.weights</code> are supplied to <code>lmw()</code>, the unadjusted statistics (if
requested) will incorporate the sampling weights. When <code>base.weights</code> are
supplied to <code>lmw()</code>, the unadjusted statistics will <em>not</em> incorporate the
base weights; rather, balance with base weights applied (if supplied) will
be produced in a separate balance table (see Value below).
</p>
<p>SMDs are computed as the difference between the (weighted) means divided by
a standardization factor, which is the standard deviation of the covariate
in the target sample. When <code>estimand = "ATT"</code> in the call to <code>lmw()</code>, the
standardization factor is the standard deviation in the treated group; when
<code>estimand = "ATC"</code>, the standardization factor is the standard deviation in
the control group; when <code>estimand = "ATE"</code> or when <code>estimand = "CATE"</code> and
a target profile is supplied, the standardization factor is the square root
of the average of the variances of both treatment groups; when <code>estimand = "CATE"</code>
and a target dataset is supplied, the standardization factor is the
standard deviation in the target dataset. When <code>s.weights</code> is supplied, the
standardization factor is computed including the sampling weights;
otherwise it is computed in the unweighted sample.
</p>
<p>For binary covariates, the KS statistic is equal to the unstandardized
difference in means and is computed as such.
</p>
<p>When <code>estimand = "CATE"</code> in the original call to <code>lmw()</code>, any variables
supplied to <code>addlvariables</code> that were not given a target value will not
have any target statistics computed (e.g., TSMD, TKS, target means, etc.).
</p>
<p>The effective sample size (ESS) is computed within each group as <code class="reqn">(\sum w)^2/\sum w^2</code>.
With uniform weights, this is equal to the sample size.
</p>


<h3>Value</h3>

<p>A <code>summary.lmw</code> object, which contains the following components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The original call to <code>lmw()</code>.</p>
</td></tr>
<tr><td><code>nn</code></td>
<td>
<p>The (effective)
sample sizes before and after weighting.</p>
</td></tr>
<tr><td><code>bal.un</code></td>
<td>
<p>When <code>stat = "balance"</code> and <code>un = TRUE</code>, the balance statistics prior
to weighting.</p>
</td></tr>
<tr><td><code>bal.base.weighted</code></td>
<td>
<p>When <code>stat = "balance"</code>, <code>un = TRUE</code> and
base weights were supplied to <code>lmw()</code>, the balance statistics with the
base weights applied.</p>
</td></tr>
<tr><td><code>bal.weighted</code></td>
<td>
<p>When <code>stat = "balance"</code>, the balance statistics with the implied regression
weights applied.</p>
</td></tr>
<tr><td><code>dist.un</code></td>
<td>
<p>When <code>stat = "distribution"</code> and <code>un = TRUE</code>, the
distribution statistics prior to weighting.</p>
</td></tr>
<tr><td><code>dist.base.weighted</code></td>
<td>
<p>When
<code>stat = "distribution"</code>, <code>un = TRUE</code> and base weights were
supplied to <code>lmw()</code>, the distribution statistics with the base weights
applied.</p>
</td></tr>
<tr><td><code>dist.weighted</code></td>
<td>
<p>When <code>stat = "distribution"</code>, the distribution statistics with the implied
regression weights applied.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used to estimate the weights (i.e., URI or MRI)</p>
</td></tr>
<tr><td><code>base.weights.origin</code></td>
<td>
<p>If base weights were supplied through the
<code>obj</code> argument to <code>lmw()</code>, their origin (i.e, <span class="pkg">MatchIt</span> or <span class="pkg">WeightIt</span>)</p>
</td></tr>
</table>
<p>With multi-category treatments and <code>method = "MRI"</code>, the object will also
inherit from class <code>summary.lmw_multi</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmw">lmw()</a></code> for computing the implied regression weights,
<code><a href="#topic+plot.summary.lmw">plot.summary.lmw()</a></code> for plotting the balance statistics in a Love plot,
<code><a href="#topic+plot.lmw">plot.lmw()</a></code> for assessing the representativeness and extrapolation of the
weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde")

# URI regression for ATT
lmw.out1 &lt;- lmw(~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                  estimand = "ATT", method = "URI",
                  treat = "treat")

lmw.out1

summary(lmw.out1)

summary(lmw.out1, stat = "distribution")

# Adding additional variables to summary, removing unweighted
summary(lmw.out1, un = FALSE,
        addlvariables = ~I(age^2) + I(nodegree*re74))


# MRI regression for ATT after PS matching
m.out &lt;- MatchIt::matchit(treat ~ age + education + race + married +
                            nodegree + re74 + re75,
                          data = lalonde, method = "nearest",
                          estimand = "ATT")

lmw.out2 &lt;- lmw(~ treat + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                method = "MRI", treat = "treat", obj = m.out)

lmw.out2

summary(lmw.out2)

# MRI for a multi-category treatment ATE
lmw.out3 &lt;- lmw(~ treat_multi + age + education + race + married +
                  nodegree + re74 + re75, data = lalonde,
                estimand = "ATE", method = "MRI",
                treat = "treat_multi")

lmw.out3

summary(lmw.out3)

summary(lmw.out3, contrast = c("2", "1"))

</code></pre>

<hr>
<h2 id='summary.lmw_est_aipw'>Extract effect estimates and standard errors from <code>lmw_est</code> fits</h2><span id='topic+summary.lmw_est_aipw'></span><span id='topic+summary.lmw_est'></span>

<h3>Description</h3>

<p><code>summary()</code> computes the treatment effect and potential outcome mean
estimates from the supplied <code>lmw_est</code> object. It functions similarly to
<code><a href="stats.html#topic+summary.lm">summary.lm()</a></code> in producing estimate tables with the estimates,
standard errors, t-statistics, and p-values. Other model statistics can be
additionally requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmw_est_aipw'
summary(object, model = FALSE, ci = TRUE, alpha = 0.05, ...)

## S3 method for class 'lmw_est'
summary(object, model = FALSE, ci = TRUE, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lmw_est_aipw_+3A_object">object</code></td>
<td>
<p>an <code>lmw_est</code> object; the output of a call to
<code>lmw_est</code>.</p>
</td></tr>
<tr><td><code id="summary.lmw_est_aipw_+3A_model">model</code></td>
<td>
<p><code>logical</code>; whether to produce a coefficient table for the
outcome model coefficients. Note that these values should not be interpreted
or reported so they are not produced by default.</p>
</td></tr>
<tr><td><code id="summary.lmw_est_aipw_+3A_ci">ci</code></td>
<td>
<p><code>logical</code>; whether to include confidence intervals in the
output.</p>
</td></tr>
<tr><td><code id="summary.lmw_est_aipw_+3A_alpha">alpha</code></td>
<td>
<p>when <code>ci = TRUE</code>, the alpha value used to compute the
critical test statistic for the confidence interval; equivalently, 1 minus
the confidence level (e.g., for a 99% confidence interval, <code>alpha = .01</code> should be specified). Default is .05 for a 95% confidence interval.</p>
</td></tr>
<tr><td><code id="summary.lmw_est_aipw_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.lmw_est()</code> produces a table of treatment effect estimates
corresponding to all possible pairwise contrasts between the treatment
levels. These treatment effects generalize to the population implied by the
regression weights, which depends on the supplied estimand, whether sampling
weights were provided, and which of the MRI or URI models was requested. The
treatment effects are computed using linear contrasts of the outcome model
coefficients.
</p>
<p>When <code>method = "MRI"</code>, the potential outcome mean estimates are also
reported. These correspond to the potential outcome means in the population
implied by the regression weights. When <code>method = "URI"</code>, only the
treatment effects are estimated; the model-implied outcome means do not
correspond to the potential outcome means for the population implied by the
regression weights. That is, while the treatment effect generalizes to the
population defined by the regression weights, the estimated potential
outcome means do not and so are not reported.
</p>
<p>When <code>model = TRUE</code>, the model coefficients and their tests statistics
are additionally produced. It is inappropriate to interpret or report these
values as they have no causal interpretation. This is especially true when
using AIPW, as the model coefficients do not incorporate the augmentation
terms.
</p>


<h3>Value</h3>

<p>A <code>summary.lmw_est</code> object with the following components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the original call to <code>lmw_est()</code></p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>a matrix
containing the estimated potential outcome means, their standard errors,
confidence interval limits (if requested with <code>ci = TRUE</code>),
t-statistics, and p-values. Omitted when <code>method = "URI"</code> or
<code>fixef</code> is not <code>NULL</code> and for <code>lmw_iv</code> objects.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a matrix containing the treatment effect estimates and
their standard errors, t-statistics, and p-values.When <code>ci = TRUE</code>, the
confidence limits <code style="white-space: pre;">&#8288;"95%" CI L&#8288;</code> (lower) and <code style="white-space: pre;">&#8288;"95%" CI U&#8288;</code> (upper)
will be included between the standard error and t-statistic columns. When
AIPW is used, z-statistics and z-tests are reported instead.</p>
</td></tr>
<tr><td><code>model.coefficients</code></td>
<td>
<p>when <code>model = TRUE</code>, the coefficient table of
the model coefficients, which has the same columns as <code>coefficients.</code></p>
</td></tr>
<tr><td><code>aliased</code></td>
<td>
<p>when <code>model = TRUE</code>, a named logical vector showing if
the original coefficients are aliased (i.e., <code>NA</code>).</p>
</td></tr>
<tr><td><code>sigma</code>, <code>df</code>, <code>r.squared</code>, <code>adj.r.squared</code></td>
<td>
<p>the residual standard deviation, degrees of
freedom components, R-squared, and adjusted R-squared. See
<code><a href="stats.html#topic+summary.lm">summary.lm()</a></code>. When AIPW is used, <code>sigma</code> and <code>df</code> are
omitted.</p>
</td></tr>
</table>
<p>Other components containing information for printing are also included.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmw_est">lmw_est()</a></code> for fitting the outcome regression model,
<code><a href="stats.html#topic+summary.lm">summary.lm()</a></code> for more information on the output components
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples at `help("lmw_est")`
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
