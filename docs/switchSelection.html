<!DOCTYPE html><html><head><title>Help for package switchSelection</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {switchSelection}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boot'><p>Bootstrap covariance matrix for least squares estimates of linear regression</p></a></li>
<li><a href='#coef.mnprobit'><p>Coefficients extraction method for mnprobit.</p></a></li>
<li><a href='#coef.mvoprobit'><p>Coefficients extraction method for mvoprobit.</p></a></li>
<li><a href='#cps'><p>A subset of data from Current Population Survey (CPS).</p></a></li>
<li><a href='#delta_method'><p>Delta method for mvoprobit and mnprobit functions</p></a></li>
<li><a href='#fitted.mnprobit'><p>Extract Model Fitted Values</p></a></li>
<li><a href='#fitted.mvoprobit'><p>Extract Model Fitted Values</p></a></li>
<li><a href='#formula_merge'><p>Merge formulas</p></a></li>
<li><a href='#formula_split'><p>Split formula by symbol</p></a></li>
<li><a href='#formula.mnprobit'><p>Formulas of mnprobit model.</p></a></li>
<li><a href='#formula.mvoprobit'><p>Formulas of mvoprobit model.</p></a></li>
<li><a href='#grad_mnprobit'><p>Gradient of the Log-likelihood Function of Multinomial Probit Model</p></a></li>
<li><a href='#grad_mvoprobit'><p>Gradient of the Log-likelihood Function of Multivariate Ordered</p>
Probit Model</a></li>
<li><a href='#lnL_mnprobit'><p>Log-likelihood Function of Multinomial Probit Model</p></a></li>
<li><a href='#lnL_mvoprobit'><p>Log-likelihood Function of Multivariate Ordered Probit Model</p></a></li>
<li><a href='#logLik.mnprobit'><p>Extract Log-Likelihood from a Fit of the mnprobit Function.</p></a></li>
<li><a href='#logLik.mvoprobit'><p>Extract Log-Likelihood from a Fit of the mvoprobit Function.</p></a></li>
<li><a href='#loocv'><p>Leave-one-out cross-validation</p></a></li>
<li><a href='#lrtest'><p>Likelihood ratio test</p></a></li>
<li><a href='#mnprobit'><p>Multinomial probit model</p></a></li>
<li><a href='#mvoprobit'><p>Multivariate ordered probit model with heteroscedasticity</p>
and (non-random) sample selection.</a></li>
<li><a href='#nobs.mnprobit'><p>Extract the Number of Observations from a Fit of the mnprobit Function.</p></a></li>
<li><a href='#nobs.mvoprobit'><p>Extract the Number of Observations from a Fit of the mvoprobit Function.</p></a></li>
<li><a href='#predict.mnprobit'><p>Predict method for mnprobit function</p></a></li>
<li><a href='#predict.mvoprobit'><p>Predict method for mvoprobit function</p></a></li>
<li><a href='#print.lrtest'><p>Print Method for Likelihood Ratio Test</p></a></li>
<li><a href='#print.mnprobit'><p>Print for an Object of Class mnprobit</p></a></li>
<li><a href='#print.mvoprobit'><p>Print for an Object of Class mvoprobit</p></a></li>
<li><a href='#print.summary.delta_method'><p>Print summary for an Object of Class delta_method</p></a></li>
<li><a href='#print.summary.lrtest'><p>Print Summary Method for Likelihood Ratio Test</p></a></li>
<li><a href='#print.summary.mnprobit'><p>Print summary for an Object of Class mnprobit</p></a></li>
<li><a href='#print.summary.mvoprobit'><p>Print summary for an Object of Class mvoprobit</p></a></li>
<li><a href='#sigma.mnprobit'><p>Extract Residual Standard Deviation 'Sigma'</p></a></li>
<li><a href='#sigma.mvoprobit'><p>Extract Residual Standard Deviation 'Sigma'</p></a></li>
<li><a href='#starsVector'><p>Stars for p-values</p></a></li>
<li><a href='#summary.delta_method'><p>Summary for an Object of Class delta_method</p></a></li>
<li><a href='#summary.lrtest'><p>Summary Method for Likelihood Ratio Test</p></a></li>
<li><a href='#summary.mnprobit'><p>Summary for an Object of Class mnprobit</p></a></li>
<li><a href='#summary.mvoprobit'><p>Summary for an Object of Class mvoprobit</p></a></li>
<li><a href='#vcov.mnprobit'><p>Calculate Variance-Covariance Matrix for a mnprobit Object.</p></a></li>
<li><a href='#vcov.mvoprobit'><p>Calculate Variance-Covariance Matrix for a mvoprobit Object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Endogenous Switching and Sample Selection Regression Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-23</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate the parameters of multivariate endogenous switching and sample selection models using methods described in Newey (2009) &lt;<a href="https://doi.org/10.1111%2Fj.1368-423X.2008.00263.x">doi:10.1111/j.1368-423X.2008.00263.x</a>&gt;, E. Kossova, B. Potanin (2018) <a href="https://ideas.repec.org/a/ris/apltrx/0346.html">https://ideas.repec.org/a/ris/apltrx/0346.html</a>, E. Kossova, L. Kupriianova, B. Potanin (2020) <a href="https://ideas.repec.org/a/ris/apltrx/0391.html">https://ideas.repec.org/a/ris/apltrx/0391.html</a> and E. Kossova, B. Potanin (2022) <a href="https://ideas.repec.org/a/ris/apltrx/0455.html">https://ideas.repec.org/a/ris/apltrx/0455.html</a>. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), hpa (&ge; 1.3.1), mnorm (&ge; 1.2.1), gena (&ge;
1.0.0), methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, hpa, mnorm</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-23 15:11:23 UTC; Bogdan</td>
</tr>
<tr>
<td>Author:</td>
<td>Bogdan Potanin [aut, cre, ctb],
  Sofiia Dolgikh [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bogdan Potanin &lt;bogdanpotanin@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 15:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='boot'>Bootstrap covariance matrix for least squares estimates of linear regression</h2><span id='topic+boot'></span>

<h3>Description</h3>

<p>This function calculates bootstrapped covariance matrix
for least squares estimates of linear regression. The estimates should be
obtained via <code>lm</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot(model, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_+3A_model">model</code></td>
<td>
<p>object of class <code>lm</code>.</p>
</td></tr>
<tr><td><code id="boot_+3A_iter">iter</code></td>
<td>
<p>positive integer representing the number of bootstrap iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculations may take long time for high <code>iter</code> value.
</p>


<h3>Value</h3>

<p>This function returns a bootstrapped covariance matrix of the
least squares estimator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Generate data according to linear regression
n &lt;- 20
eps &lt;- rnorm(n)
x &lt;- runif(n)
y &lt;- x + eps
# Estimate the model
model &lt;- lm(y ~ x)
# Calculate bootstrap covariance matrix
boot(model, iter = 50)
</code></pre>

<hr>
<h2 id='coef.mnprobit'>Coefficients extraction method for mnprobit.</h2><span id='topic+coef.mnprobit'></span>

<h3>Description</h3>

<p>Extract coefficients and other estimates from mnprobit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mnprobit'
coef(object, ..., alt = NULL, regime = NULL, type = "coef")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.mnprobit_+3A_object">object</code></td>
<td>
<p>object of class &quot;mnprobit&quot;</p>
</td></tr>
<tr><td><code id="coef.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="coef.mnprobit_+3A_alt">alt</code></td>
<td>
<p>integer representing index of the alternative</p>
</td></tr>
<tr><td><code id="coef.mnprobit_+3A_regime">regime</code></td>
<td>
<p>integer representing regime of the continuous equation</p>
</td></tr>
<tr><td><code id="coef.mnprobit_+3A_type">type</code></td>
<td>
<p>character representing the type of the output. Possible options
are <code>"coef"</code>, <code>"coef2"</code>, <code>"cov1"</code>, <code>"var"</code>,
<code>"cov2"</code>, <code>coef_lambda</code>.
See 'Details' for additional information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider notations from the 'Details' section of 
<code><a href="#topic+mnprobit">mnprobit</a></code>.
</p>
<p>Suppose that <code>type = "coef"</code>. Then estimates of <code class="reqn">\gamma_{j}</code> 
coefficients are returned for each <code class="reqn">j\in\{1,...,J\}</code>. If <code>alt = j</code> 
then only estimates of <code class="reqn">\gamma_{j}</code> coefficients are returned.
</p>
<p>Suppose that <code>type = "coef2"</code>. Then estimates of <code class="reqn">\beta_{r}</code>
coefficients are returned for each <code class="reqn">r\in\{0,...,R - 1\}</code>. 
If <code>regime = r</code> then estimates only for the <code class="reqn">r</code>-th regime are
returned.
</p>
<p>Suppose that <code>type = "cov1"</code>. Then estimate of the covariance matrix of
<code class="reqn">u_{i}</code> is returned. If <code>alt = c(a, b)</code> then the function returns
<code class="reqn">(a, b)</code>-th element of this matrix i.e. an element from 
<code>a</code>-th row and <code>b</code>-th column that is an estimate of
<code class="reqn">Cov(u_{ai},u_{bi})</code>.
</p>
<p>Suppose that <code>type = "cov12"</code>. Then estimates of covariances between
<code class="reqn">u_{i}</code> and <code class="reqn">\varepsilon_{i}</code> are returned. 
If <code>alt = j</code> and <code>regime = r</code> then the function returns 
an estimate of <code class="reqn">Cov(u_{ji}, \varepsilon_{ri})</code>.
</p>
<p>Suppose that <code>type = "var"</code> or <code>type = "cov2"</code>. Then estimates of
the variances of <code class="reqn">\varepsilon_{i}</code> are returned.
If <code>regime = r</code> then estimate of <code class="reqn">Var(\varepsilon_{ri})</code> 
is returned.
</p>
<p>Suppose that <code>type = "coef_lambda"</code>. Then estimates of the coefficients
for <code class="reqn">\hat{\lambda}^{t}_{ji}</code> are returned i.e. 
estimates of <code class="reqn">\tau_{jt}</code> for each regime.
If <code>regime = r</code> then estimates are returned for the <code class="reqn">r</code>-th regime. 
If in addition <code>alt = j</code> then only estimates for this <code class="reqn">j</code>-th 
alternative and <code class="reqn">r</code>-th regime are returned.
</p>


<h3>Value</h3>

<p>See 'Details' section.
</p>

<hr>
<h2 id='coef.mvoprobit'>Coefficients extraction method for mvoprobit.</h2><span id='topic+coef.mvoprobit'></span>

<h3>Description</h3>

<p>Extract coefficients and other estimates from mvoprobit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvoprobit'
coef(object, ..., eq = NULL, eq2 = NULL, regime = NULL, type = "coef")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.mvoprobit_+3A_object">object</code></td>
<td>
<p>object of class &quot;mvoprobit&quot;.</p>
</td></tr>
<tr><td><code id="coef.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="coef.mvoprobit_+3A_eq">eq</code></td>
<td>
<p>integer representing an index of the ordered equation.</p>
</td></tr>
<tr><td><code id="coef.mvoprobit_+3A_eq2">eq2</code></td>
<td>
<p>integer representing an index of the continuous equation.</p>
</td></tr>
<tr><td><code id="coef.mvoprobit_+3A_regime">regime</code></td>
<td>
<p>integer representing a regime of the continuous equation.</p>
</td></tr>
<tr><td><code id="coef.mvoprobit_+3A_type">type</code></td>
<td>
<p>character representing a type of the output. Possible options
are <code>"coef"</code>, <code>"coef2"</code>, <code>"cov"</code>, <code>"cov1"</code>, <code>"var"</code>,
<code>"cov2"</code>, <code>"cov3"</code>, <code>coef_lambda</code> and <code>marginal</code>.
See 'Details' for additional information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider notations from the 'Details' section of 
<code><a href="#topic+mvoprobit">mvoprobit</a></code>.
</p>
<p>Suppose that <code>type = "coef"</code>. Then estimates of <code class="reqn">\gamma_{j}</code> 
coefficients are returned for each <code class="reqn">j\in\{1,...,J\}</code>. 
If <code>eq = j</code> then only estimates of <code class="reqn">\gamma_{j}</code> coefficients 
are returned.
</p>
<p>Suppose that <code>type = "coef_var"</code>. Then estimates of <code class="reqn">\gamma_{j}^{*}</code> 
coefficients are returned for each <code class="reqn">j\in\{1,...,J\}</code>. 
If <code>eq = j</code> then only estimates of <code class="reqn">\gamma_{j}^{*}</code> coefficients 
are returned.
</p>
<p>Suppose that <code>type = "coef2"</code>. Then estimates of <code class="reqn">\beta_{r}</code> 
coefficients are returned for each <code class="reqn">r\in\{0,...,R - 1\}</code>. 
If <code>eq2 = k</code> then only estimates for the <code class="reqn">k</code>-th continuous equation 
are returned. If <code>regime = r</code> then estimates of <code class="reqn">\beta_{r}</code>
coefficients are returned for the <code>eq2</code>-th continuous equation. 
Herewith if <code>regime</code> is not <code>NULL</code> and <code>eq2</code> is <code>NULL</code> 
it is assumed that <code>eq2 = 1</code>.
</p>
<p>Suppose that <code>type = "cov"</code>. Then estimate of the asymptotic covariance
matrix of the estimator is returned. Note that this estimate depends
on the <code>cov_type</code> argument of <code><a href="#topic+mvoprobit">mvoprobit</a></code>.
</p>
<p>Suppose that <code>type = "cov1"</code>. Then estimate of the covariance matrix of
<code class="reqn">u_{i}</code> is returned. If <code>eq = c(a, b)</code> then the function returns
<code class="reqn">(a, b)</code>-th element of this matrix i.e. an element from 
<code>a</code>-th row and <code>b</code>-th column.
</p>
<p>Suppose that <code>type = "cov12"</code>. Then estimates of covariances between
<code class="reqn">u_{i}</code> and <code class="reqn">\varepsilon_{i}</code> are returned. If <code>eq2 = k</code> then
covariances with random errors of the <code>k</code>-th continuous equation are
returned. If in addition <code>eq = j</code> and <code>regime = r</code> then the 
function returns estimate of <code class="reqn">Cov(u_{ji}, \varepsilon_{ri})</code> for the
<code>k</code>-th equation. If <code>eq2 = NULL</code> it is assumed that 
<code>eq2 = 1</code>.
</p>
<p>Suppose that <code>type = "var"</code> or <code>type = "cov2"</code>. Then estimates of
the variances of <code class="reqn">\varepsilon_{i}</code> are returned. If <code>eq2 = k</code>
then estimates only for <code class="reqn">k</code>-th continuous equation are returned.
If in addition <code>regime = r</code> then estimate of <code class="reqn">Var(\varepsilon_{ri})</code>
is returned. Herewith if <code>regime</code> is not <code>NULL</code> and
<code>eq2</code> is <code>NULL</code> it is assumed that <code>eq2 = 1</code>.
</p>
<p>Suppose that <code>type = "cov3"</code>. Then estimates of the covariances between
random errors of different equations in different regimes are returned.
If <code>eq2 = c(a, b)</code> and <code>regime = c(c, d)</code> then function returns
an estimate of the covariance of random errors of the 
<code>a</code>-th and <code>b</code>-th 
continuous equations in regimes <code>c</code> and <code>d</code> correspondingly. 
If this covariance is not identifiable then <code>NA</code> value is returned.
</p>
<p>Suppose that <code>type = "coef_lambda"</code>. Then estimates of the coefficients
for <code class="reqn">\hat{\lambda}^{t}_{ji}</code> are returned i.e. 
estimates of <code class="reqn">\tau_{jt}</code> for each regime. 
If <code>regime = r</code> then estimates are returned for the <code class="reqn">r</code>-th 
regime. If in addition <code>eq = j</code> then only estimates for this <code class="reqn">j</code> 
are returned.
</p>


<h3>Value</h3>

<p>See 'Details' section.
</p>

<hr>
<h2 id='cps'>A subset of data from Current Population Survey (CPS).</h2><span id='topic+cps'></span>

<h3>Description</h3>

<p>Labor market data on 18,253 middle age (25-54 years) married women
in the year 2022.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cps)
</code></pre>


<h3>Format</h3>

<p>A data frame with 18,253 rows and 13 columns. It contains information on
wages and some socio-demographic characteristics of middle age
(25-54 years) married women:
</p>

<dl>
<dt>age</dt><dd><p>age of individual measured in years.</p>
</dd>
<dt>lwage</dt><dd><p>logarithm of hourly wage.</p>
</dd>
<dt>slwage</dt><dd><p>logarithm of hourly wage of a spouse.</p>
</dd>
<dt>work</dt><dd><p>binary variable for employment status 
(0 - unemployed, 1 - employed).</p>
</dd>
<dt>swork</dt><dd><p>binary variable for employment status 
of a spouse (0 - unemployed, 1 - employed).</p>
</dd>
<dt>nchild</dt><dd><p>the number of children under age 5.</p>
</dd>
<dt>health</dt><dd><p>subjective health status (1 - poor, 2 - fair, 3 - good, 
4 - very good, 5 - excellent).</p>
</dd>
<dt>basic</dt><dd><p>binary variable which equals 1 for those who have graduated 
from high school or has at least some college or has associated degree and 
does not have any higher level of education, 0 - otherwise.</p>
</dd>
<dt>bachelor</dt><dd><p>binary variable which equals 1 for those whose highest 
education level is a bachelor degree.</p>
</dd>
<dt>master</dt><dd><p>binary variable which equals 1 for those whose highest 
education level is a master degree.</p>
</dd>
<dt>sbasic</dt><dd><p>the same as basic but for a spouse.</p>
</dd>
<dt>sbachelor</dt><dd><p>the same as bachelor but for a spouse.</p>
</dd>
<dt>smaster</dt><dd><p>the same as master but for a spouse.</p>
</dd> 
</dl>
<p>...

</p>


<h3>Source</h3>

<p>&lt;https://www.census.gov/programs-surveys/cps.html&gt;
</p>


<h3>References</h3>

<p>Flood S, King M, Rodgers R, Ruggles S, Warren R, 
Westberry M (2022). Integrated Public Use Microdata Series, 
Current Population Survey: Version 10.0 [dataset].
doi: 10.18128/D030.V10.0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cps)
model &lt;- mvoprobit(work ~ age + bachelor + master, data = cps)
summary(model)
 
</code></pre>

<hr>
<h2 id='delta_method'>Delta method for mvoprobit and mnprobit functions</h2><span id='topic+delta_method'></span>

<h3>Description</h3>

<p>This function uses delta method to estimate standard errors
of functions of the estimator of the parameters of 
<code>mnprobit</code> and <code>mvoprobit</code>
functions if maximum-likelihood estimator has been used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_method(
  object,
  fn,
  fn_args = list(),
  eps = max(1e-04, sqrt(.Machine$double.eps) * 10),
  cl = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_method_+3A_object">object</code></td>
<td>
<p>an object of class 'mvoprobit' or 'mnprobit'.</p>
</td></tr>
<tr><td><code id="delta_method_+3A_fn">fn</code></td>
<td>
<p>function which returns a numeric vector and should depend on the 
elements of <code>object</code>. This elements should be accessed via 
<code><a href="#topic+coef.mvoprobit">coef.mvoprobit</a></code> and 
<code><a href="#topic+coef.mnprobit">coef.mnprobit</a></code> functions. 
Also it is possible to use <code><a href="#topic+predict.mvoprobit">predict.mvoprobit</a></code> 
and <code><a href="#topic+predict.mnprobit">predict.mnprobit</a></code> functions.
The first argument of <code>fn</code> should be <code>object</code>.
Therefore <code>coef</code> and <code>predict</code> functions in <code>fn</code> should also
depend on <code>object</code>.</p>
</td></tr>
<tr><td><code id="delta_method_+3A_fn_args">fn_args</code></td>
<td>
<p>list of additional arguments of <code>fn</code>.</p>
</td></tr>
<tr><td><code id="delta_method_+3A_eps">eps</code></td>
<td>
<p>positive numeric value representing the increment used for
numeric differentiation of <code>fn</code>.</p>
</td></tr>
<tr><td><code id="delta_method_+3A_cl">cl</code></td>
<td>
<p>numeric value between <code>0</code> and <code>1</code> representing
a confidence level of the confidence interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numeric differentiation is used to estimate derivatives of
<code>fn</code> respect to various parameters of 
<code><a href="#topic+mvoprobit">mvoprobit</a></code>  and 
<code><a href="#topic+mnprobit">mnprobit</a></code> functions.
</p>
<p>This function may be used only if <code>object$estimator = "ml"</code>.
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>delta_method</code>
that is a matrix which columns are as follows:
</p>

<ul>
<li> <p><code>val</code> - output of the <code>fn</code> function.
</p>
</li>
<li> <p><code>se</code> - numeric vector such that <code>se[i]</code> represents standard
error associated with <code>val[i]</code>.
</p>
</li>
<li> <p><code>p_value</code> - numeric vector such that <code>p_value[i]</code> represents
p-value of the two-sided significance test associated with <code>val[i]</code>.
</p>
</li>
<li> <p><code>lwr</code> - realization of the lower (left) bound of the 
confidence interval.
</p>
</li>
<li> <p><code>upr</code> - realization of the upper (right) bound of the 
confidence interval.
</p>
</li></ul>

<p>An object of class <code>delta_method</code> has implementation of 
<code>summary</code> method 
<code><a href="#topic+summary.delta_method">summary.delta_method</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set seed for reproducibility
set.seed(123)

# Load required package
library("mnorm")

# The number of observations
n &lt;- 10000

# Regressors (covariates)
s1 &lt;- runif(n = n, min = -1, max = 1)
s2 &lt;- runif(n = n, min = -1, max = 1)
s3 &lt;- runif(n = n, min = -1, max = 1)
s4 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
sigma &lt;- matrix(c(1,    0.4,  0.45, 0.7,
                  0.4,  1,    0.54, 0.8,
                  0.45, 0.54, 0.81, 0.81,
                  0.7,  0.8,  0.81, 1), nrow = 4)
errors &lt;- mnorm::rmnorm(n = n, mean = c(0, 0, 0, 0), sigma = sigma)
u1 &lt;- errors[, 1]
u2 &lt;- errors[, 2]
eps0 &lt;- errors[, 3]
eps1 &lt;- errors[, 4]

# Coefficients
gamma1 &lt;- c(-1, 2)
gamma2 &lt;- c(1, 1)
gamma1_het &lt;- c(0.5, -1)
beta0 &lt;- c(1, -1, 1, -1.2)
beta1 &lt;- c(2, -1.5, 0.5, 1.2)
# Linear index of ordered equation
# mean
li1 &lt;- gamma1[1] * s1 + gamma1[2] * s2
li2 &lt;- gamma2[1] * s1 + gamma2[2] * s3
# variance
li1_het &lt;- gamma1_het[1] * s2 + gamma1_het[2] * s3

# Linear index of continuous equation
# regime 0
li_y0 &lt;- beta0[1] + beta0[2] * s1 + beta0[3] * s3 + beta0[4] * s4
# regime 1
li_y1 &lt;- beta1[1] + beta1[2] * s1 + beta1[3] * s3 + beta1[4] * s4

# Latent variables
z1_star &lt;- li1 + u1 * exp(li1_het)
z2_star &lt;- li2 + u2
y0_star &lt;- li_y0 + eps0
y1_star &lt;- li_y1 + eps1

# Cuts
cuts1 &lt;- c(-1)
cuts2 &lt;- c(0, 1)

# Observable ordered outcome
# first
z1 &lt;- rep(0, n)
z1[z1_star &gt; cuts1[1]] &lt;- 1
# second
z2 &lt;- rep(0, n)
z2[(z2_star &gt; cuts2[1]) &amp; (z2_star &lt;= cuts2[2])] &lt;- 1
z2[z2_star &gt; cuts2[2]] &lt;- 2
z2[z1 == 0] &lt;- -1

# Observable continuous outcome such
y &lt;- rep(NA, n)
y[z2 == 0] &lt;- y0_star[z2 == 0]
y[z2 != 0] &lt;- y1_star[z2 != 0]
y[z1 == 0] &lt;- Inf

# Data
data &lt;- data.frame(s1 = s1, s2 = s2, s3 = s3, s4 = s4,
                   z1 = z1, z2 = z2, y = y)

# Assign groups
groups &lt;- matrix(c(1, 2,
                   1, 1,
                   1, 0,
                   0, -1), 
                 byrow = TRUE, ncol = 2)
groups2 &lt;- matrix(c(1, 1, 0, -1), ncol = 1)

# Estimation
model &lt;- mvoprobit(list(z1 ~ s1 + s2 | s2 + s3,
                        z2 ~ s1 + s3),
                   list(y ~ s1 + s3 + s4),
                   groups = groups, groups2 = groups2, data = data)

# Use delta method to estimate standard error for each P(z1 = 0, z2 = 2)
prob02_fn &lt;- function(object)
{
   val &lt;- predict(object, group = c(1, 0))
   
   return(val)
}
prob02 &lt;- delta_method(object = model, fn = prob02_fn)
head(prob02)

# Use delta method to estimate standard error for each 
# E(y1|z1=0, z2=2) - E(y0|z1=0, z2=2)
ATE_fn &lt;- function(object)
{
   val1 &lt;- predict(object, group = c(0, 2), group2 = 1)
   val0 &lt;- predict(object, group = c(0, 2), group2 = 0)
   val &lt;- mean(val1 - val0)
   
   return(val)
}
ATE &lt;- delta_method(object = model, fn = ATE_fn)
summary(ATE)

# Use delta method to estimate standard for the difference
# between beta0 and beta1 coefficients
coef_fn &lt;- function(object)
{
   coef1 &lt;- coef(object, regime = 1, type = "coef2")
   coef0 &lt;- coef(object, regime = 0, type = "coef2")
   coef_difference &lt;- coef1 - coef0
   
   return(coef_difference)
}
coef_val &lt;- delta_method(object = model, fn = coef_fn)
summary(coef_val)


</code></pre>

<hr>
<h2 id='fitted.mnprobit'>Extract Model Fitted Values</h2><span id='topic+fitted.mnprobit'></span>

<h3>Description</h3>

<p>Extracts fitted values from 'mnprobit' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mnprobit'
fitted(object, ..., newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.mnprobit_+3A_object">object</code></td>
<td>
<p>object of class 'mnprobit'.</p>
</td></tr>
<tr><td><code id="fitted.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="fitted.mnprobit_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables 
with which to predict. If omitted, the original data frame used. 
This data frame should contain values of dependent variables even if they 
are not actually needed for prediction (simply assign them with 0 values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame. Its first column provides an index of the
most probable alternative. Columns which names coincide with the
names of the continuous equation provide unconditional expectation of
the dependent variable in available regimes.
</p>

<hr>
<h2 id='fitted.mvoprobit'>Extract Model Fitted Values</h2><span id='topic+fitted.mvoprobit'></span>

<h3>Description</h3>

<p>Extracts fitted values from 'mvoprobit' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvoprobit'
fitted(object, ..., newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.mvoprobit_+3A_object">object</code></td>
<td>
<p>object of class 'mvoprobit'.</p>
</td></tr>
<tr><td><code id="fitted.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="fitted.mvoprobit_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables 
with which to predict. If omitted, the original data frame used. 
This data frame should contain values of dependent variables even if they 
are not actually needed for prediction (simply assign them with 0 values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame. Its columns which names coincide with the
names of the ordered equations provide an index of the most probable
category. Columns which names coincide with the
names of the continuous equations provide uncinditional expectations of
the dependent variables in available regimes.
</p>

<hr>
<h2 id='formula_merge'>Merge formulas</h2><span id='topic+formula_merge'></span>

<h3>Description</h3>

<p>This function merges all variables of several formulas
into a single formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_merge(..., type = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula_merge_+3A_...">...</code></td>
<td>
<p>formulas to be merged such that there is a single element
on the left hand side and various elements on the right hand side.</p>
</td></tr>
<tr><td><code id="formula_merge_+3A_type">type</code></td>
<td>
<p>string representing the type of merge to be used.
If <code>type = "all"</code> then both right hand side and left hand side
elements of the formulas will be merged on the right hand side.
If <code>type = "terms"</code> then only right hand side elements of the
formulas will be merged on the right hand side.
If <code>type = "var-terms"</code> then the result is the same as in case
when <code>type = "terms"</code> but there will be left hand side element
of the first formula on the left hand side of the merged formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Merged formulas should have a single element on the left hand
side and voluntary number of elements on the right hand side.
</p>


<h3>Value</h3>

<p>This function returns a formula which form depends on 
<code>type</code> input argument value. See 'Details' for additional information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider three formulas
f1 &lt;- as.formula("y1 ~ x1 + x2")
f2 &lt;- as.formula("y2 ~ x2 + x3")
f3 &lt;- as.formula("y3 ~ y2 + x6")
# Merge these formulas in a various ways
formula_merge(f1, f2, f3, type = "all")
formula_merge(f1, f2, f3, type = "terms")
formula_merge(f1, f2, f3, type = "var-terms")

</code></pre>

<hr>
<h2 id='formula_split'>Split formula by symbol</h2><span id='topic+formula_split'></span>

<h3>Description</h3>

<p>This function splits one formula into two formulas
by symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_split(formula, symbol = "|")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula_split_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code>.</p>
</td></tr>
<tr><td><code id="formula_split_+3A_symbol">symbol</code></td>
<td>
<p>a string that is used to split <code>formula</code> into
two formulas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>symbol</code> should be on the right hand side of
the formula.
</p>


<h3>Value</h3>

<p>This function returns a list of two formulas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formula_split("y ~ x1 + x2 | x2 + x3")
formula_split("y ~ x1 + x2 : x2 + x3", symbol = ":")

</code></pre>

<hr>
<h2 id='formula.mnprobit'>Formulas of mnprobit model.</h2><span id='topic+formula.mnprobit'></span>

<h3>Description</h3>

<p>Provides formulas associated with the 
object of class 'mnprobit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mnprobit'
formula(x, ..., type = "formula")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.mnprobit_+3A_x">x</code></td>
<td>
<p>object of class 'mnprobit'.</p>
</td></tr>
<tr><td><code id="formula.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="formula.mnprobit_+3A_type">type</code></td>
<td>
<p>character; 
if <code>type = "formula"</code> or <code>type = 1</code> then function returns 
a formulas of multinomial equation. 
If <code>type = "formula2"</code> or <code>type = 2</code> then function returns 
a formula of continuous equation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a formula.
</p>

<hr>
<h2 id='formula.mvoprobit'>Formulas of mvoprobit model.</h2><span id='topic+formula.mvoprobit'></span>

<h3>Description</h3>

<p>Provides formulas associated with the 
object of class 'mvoprobit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvoprobit'
formula(x, ..., type = "formula", eq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.mvoprobit_+3A_x">x</code></td>
<td>
<p>object of class 'mvoprobit'.</p>
</td></tr>
<tr><td><code id="formula.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="formula.mvoprobit_+3A_type">type</code></td>
<td>
<p>character; 
if <code>type = "formula"</code> or <code>type = 1</code> then function returns formulas 
of ordered equations. 
If <code>type = "formula2"</code> or <code>type = 2</code> then function returns formulas 
of continuous equations.</p>
</td></tr>
<tr><td><code id="formula.mvoprobit_+3A_eq">eq</code></td>
<td>
<p>positive integer representing the index of the equation which
formula should be returned. If <code>NULL</code> (default) then formulas for each
equation will be returned as a list which <code>i</code>-th element associated 
with <code>i</code>-th equation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a formula or a list of formulas depending on <code>eq</code> value.
</p>

<hr>
<h2 id='grad_mnprobit'>Gradient of the Log-likelihood Function of Multinomial Probit Model</h2><span id='topic+grad_mnprobit'></span>

<h3>Description</h3>

<p>Calculates gradient of the log-likelihood function of 
multinomial probit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad_mnprobit(
  par,
  control_lnL,
  out_type = "grad",
  n_sim = 1000L,
  n_cores = 1L,
  regularization = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grad_mnprobit_+3A_par">par</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="grad_mnprobit_+3A_control_lnl">control_lnL</code></td>
<td>
<p>list with some additional parameters.</p>
</td></tr>
<tr><td><code id="grad_mnprobit_+3A_out_type">out_type</code></td>
<td>
<p>string represeint the output type of the function.</p>
</td></tr>
<tr><td><code id="grad_mnprobit_+3A_n_sim">n_sim</code></td>
<td>
<p>the number of random draws for multivariate 
normal probabilities.</p>
</td></tr>
<tr><td><code id="grad_mnprobit_+3A_n_cores">n_cores</code></td>
<td>
<p>the number of cores to be used.</p>
</td></tr>
<tr><td><code id="grad_mnprobit_+3A_regularization">regularization</code></td>
<td>
<p>list of regularization parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='grad_mvoprobit'>Gradient of the Log-likelihood Function of Multivariate Ordered
Probit Model</h2><span id='topic+grad_mvoprobit'></span>

<h3>Description</h3>

<p>Calculates gradient of the log-likelihood function of 
multivariate ordered probit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad_mvoprobit(
  par,
  control_lnL,
  out_type = "grad",
  n_sim = 1000L,
  n_cores = 1L,
  regularization = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grad_mvoprobit_+3A_par">par</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="grad_mvoprobit_+3A_control_lnl">control_lnL</code></td>
<td>
<p>list with some additional parameters.</p>
</td></tr>
<tr><td><code id="grad_mvoprobit_+3A_out_type">out_type</code></td>
<td>
<p>string represeint the output type of the function.</p>
</td></tr>
<tr><td><code id="grad_mvoprobit_+3A_n_sim">n_sim</code></td>
<td>
<p>the number of random draws for multivariate 
normal probabilities.</p>
</td></tr>
<tr><td><code id="grad_mvoprobit_+3A_n_cores">n_cores</code></td>
<td>
<p>the number of cores to be used.</p>
</td></tr>
<tr><td><code id="grad_mvoprobit_+3A_regularization">regularization</code></td>
<td>
<p>list of regularization parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='lnL_mnprobit'>Log-likelihood Function of Multinomial Probit Model</h2><span id='topic+lnL_mnprobit'></span>

<h3>Description</h3>

<p>Calculates log-likelihood function of multinomial probit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnL_mnprobit(
  par,
  control_lnL,
  out_type = "val",
  n_sim = 1000L,
  n_cores = 1L,
  regularization = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnL_mnprobit_+3A_par">par</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="lnL_mnprobit_+3A_control_lnl">control_lnL</code></td>
<td>
<p>list with some additional parameters.</p>
</td></tr>
<tr><td><code id="lnL_mnprobit_+3A_out_type">out_type</code></td>
<td>
<p>string represeint the output type of the function.</p>
</td></tr>
<tr><td><code id="lnL_mnprobit_+3A_n_sim">n_sim</code></td>
<td>
<p>the number of random draws for multivariate 
normal probabilities.</p>
</td></tr>
<tr><td><code id="lnL_mnprobit_+3A_n_cores">n_cores</code></td>
<td>
<p>the number of cores to be used.</p>
</td></tr>
<tr><td><code id="lnL_mnprobit_+3A_regularization">regularization</code></td>
<td>
<p>list of regularization parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='lnL_mvoprobit'>Log-likelihood Function of Multivariate Ordered Probit Model</h2><span id='topic+lnL_mvoprobit'></span>

<h3>Description</h3>

<p>Calculates log-likelihood function of multivariate ordered
probit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnL_mvoprobit(
  par,
  control_lnL,
  out_type = "val",
  n_sim = 1000L,
  n_cores = 1L,
  regularization = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnL_mvoprobit_+3A_par">par</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="lnL_mvoprobit_+3A_control_lnl">control_lnL</code></td>
<td>
<p>list with some additional parameters.</p>
</td></tr>
<tr><td><code id="lnL_mvoprobit_+3A_out_type">out_type</code></td>
<td>
<p>string represeint the output type of the function.</p>
</td></tr>
<tr><td><code id="lnL_mvoprobit_+3A_n_sim">n_sim</code></td>
<td>
<p>the number of random draws for multivariate 
normal probabilities.</p>
</td></tr>
<tr><td><code id="lnL_mvoprobit_+3A_n_cores">n_cores</code></td>
<td>
<p>the number of cores to be used.</p>
</td></tr>
<tr><td><code id="lnL_mvoprobit_+3A_regularization">regularization</code></td>
<td>
<p>list of regularization parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='logLik.mnprobit'>Extract Log-Likelihood from a Fit of the mnprobit Function.</h2><span id='topic+logLik.mnprobit'></span>

<h3>Description</h3>

<p>Extract Log-Likelihood from a model fit
of the <code><a href="#topic+mnprobit">mnprobit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mnprobit'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.mnprobit_+3A_object">object</code></td>
<td>
<p>object of class &quot;mnprobit&quot;</p>
</td></tr>
<tr><td><code id="logLik.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>estimator == "2step"</code> in 
<code><a href="#topic+mnprobit">mnprobit</a></code> then function may return
<code>NA</code> value since two-step estimator of covariance matrix may be
not positively defined.
</p>


<h3>Value</h3>

<p>Returns an object of class 'logLik'.
</p>

<hr>
<h2 id='logLik.mvoprobit'>Extract Log-Likelihood from a Fit of the mvoprobit Function.</h2><span id='topic+logLik.mvoprobit'></span>

<h3>Description</h3>

<p>Extract Log-Likelihood from a model fit
of the <code><a href="#topic+mvoprobit">mvoprobit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvoprobit'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.mvoprobit_+3A_object">object</code></td>
<td>
<p>object of class &quot;mvoprobit&quot;</p>
</td></tr>
<tr><td><code id="logLik.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>estimator == "2step"</code> in 
<code><a href="#topic+mvoprobit">mvoprobit</a></code> then function may return
<code>NA</code> value since two-step estimator of covariance matrix may be
not positively defined.
</p>


<h3>Value</h3>

<p>Returns an object of class 'logLik'.
</p>

<hr>
<h2 id='loocv'>Leave-one-out cross-validation</h2><span id='topic+loocv'></span>

<h3>Description</h3>

<p>This function calculates root mean squared error (RMSE) for
leave-one-out cross-validation of linear regression estimated via
least squares method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loocv(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loocv_+3A_fit">fit</code></td>
<td>
<p>object of class <code>lm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fast analytical formula is used.
</p>


<h3>Value</h3>

<p>This function returns a numeric value representing root mean squared 
error (RMSE) of leave-one-out cross-validation (LOOCV).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Generate data according to linear regression
n &lt;- 100
eps &lt;- rnorm(n)
x &lt;- runif(n)
y &lt;- x + eps
# Estimate the model
model &lt;- lm(y ~ x)
# Perform cross-validation
loocv(model)
</code></pre>

<hr>
<h2 id='lrtest'>Likelihood ratio test</h2><span id='topic+lrtest'></span>

<h3>Description</h3>

<p>This function performs chi-squared test for nested models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrtest(model1, model2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrtest_+3A_model1">model1</code></td>
<td>
<p>the first model.</p>
</td></tr>
<tr><td><code id="lrtest_+3A_model2">model2</code></td>
<td>
<p>the second model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments <code>model1</code> and <code>model2</code> should be objects
of class that has implementations of 
<code><a href="stats.html#topic+logLik">logLik</a></code> and 
<code><a href="stats.html#topic+nobs">nobs</a></code> methods. It is assumed that either <code>model1</code>
is nested into <code>model2</code> or vice versa. More precisely it is assumed
that the model with smaller log-likelihood value is nested into the model
with greater log-likelihood value.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>'lrtest'</code> that is
a list with the following elements:
</p>

<ul>
<li> <p><code>n1</code> - the number of observations in the first model.
</p>
</li>
<li> <p><code>n2</code> - the number of observations in the second model.
</p>
</li>
<li> <p><code>ll1</code> - log-likelihood value of the first model.
</p>
</li>
<li> <p><code>ll2</code> - log-likelihood value of the second model.
</p>
</li>
<li> <p><code>df1</code> - the number of parameters in the first model.
</p>
</li>
<li> <p><code>df2</code> - the number of parameters in the second model.
</p>
</li>
<li> <p><code>restrictions</code> - the number of restrictions in the nested model.
</p>
</li>
<li> <p><code>value</code> - chi-squared test statistic value.
</p>
</li>
<li> <p><code>p_value</code> - p-value of the chi-squared test.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Generate data according to linear regression
n &lt;- 100
eps &lt;- rnorm(n)
x1 &lt;- runif(n)
x2 &lt;- runif(n)
y &lt;- x1 + 0.2 * x2 + eps
# Estimate full model
model1 &lt;- lm(y ~ x1 + x2)
# Estimate restricted (nested) model
model2 &lt;- lm(y ~ x1)
# Likelihood ratio test results
lrtest(model1, model2)
</code></pre>

<hr>
<h2 id='mnprobit'>Multinomial probit model</h2><span id='topic+mnprobit'></span>

<h3>Description</h3>

<p>This function estimates parameters of multinomial probit
model and sample selection model with continuous outcome and multinomial
probit selection mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mnprobit(
  formula,
  formula2 = NULL,
  data,
  regimes = NULL,
  opt_type = "optim",
  opt_args = NULL,
  start = NULL,
  estimator = "ml",
  cov_type = "sandwich",
  degrees = NULL,
  n_sim = 1000,
  n_cores = 1,
  control = NULL,
  regularization = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mnprobit_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; corresponding to multinomial
(selection) equation.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_formula2">formula2</code></td>
<td>
<p>an object of class &quot;formula&quot; corresponding to continuous
(outcome) equation.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_data">data</code></td>
<td>
<p>data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_regimes">regimes</code></td>
<td>
<p>numeric vector such that <code>regimes[i]</code> is a regime
of continuous equation when <code>i</code>-th alternative is observable. It
should start with <code>0</code> and special value <code>-1</code> undermines that
continuous (outcome) equation is unobservable.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_opt_type">opt_type</code></td>
<td>
<p>character representing optimization function to be used.
If <code>opt_type = "optim"</code> then <code><a href="stats.html#topic+optim">optim</a></code> will be used.
If <code>opt_type = "gena"</code> then <code><a href="gena.html#topic+gena">gena</a></code> will be applied 
i.e. genetic algorithm.
If <code>opt_type = "pso"</code> then <code><a href="gena.html#topic+pso">pso</a></code> will be used 
i.e. particle swarm optimization.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_opt_args">opt_args</code></td>
<td>
<p>a list of input arguments for the optimization function
selected via <code>opt_type</code> argument. See 'Details' for information.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_start">start</code></td>
<td>
<p>numeric vector of initial parameters' values. It will be used
as a starting point for optimization purposes. It is also possible to
provide an object of class <code>'mnprobit'</code> then its <code>'par'</code> 
element will be used as a starting point.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_estimator">estimator</code></td>
<td>
<p>character determining estimation method.
If <code>estimator = "ml"</code> then maximum-likelihood will be used.
If <code>estimator = "2step"</code> then two-step estimation procedure similar
to Heckman's method will be applied.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_cov_type">cov_type</code></td>
<td>
<p>character determining the type of covariance matrix to be
returned and used for summary. If <code>cov_type = "hessian"</code> then negative
inverse of Hessian matrix will be applied. If <code>cov_type = "gop"</code> then
inverse of Jacobian outer products will be used.
If <code>cov_type = "sandwich"</code> (default) then sandwich covariance matrix
estimator will be applied.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_degrees">degrees</code></td>
<td>
<p>vector of non-negative integers such that <code>degrees[i]</code>
represents degree of the polynomial which elements are selectivity correction
terms associated with the <code>i</code>-th ordered equation. See 'Details' for
additional information.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_n_sim">n_sim</code></td>
<td>
<p>integer representing the number of GHK draws when there are
more than 3 ordered equations. Otherwise alternative (much more efficient) 
algorithms will be used to calculate multivariate normal probabilities.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_n_cores">n_cores</code></td>
<td>
<p>positive integer representing the number of CPU cores used for 
parallel computing. If possible it is highly recommend to set it equal to
the number of available physical cores especially when the system of
ordered equations has 2 or 3 equations.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See 'Details'.</p>
</td></tr>
<tr><td><code id="mnprobit_+3A_regularization">regularization</code></td>
<td>
<p>a list of control parameters for regularization.
Element <code>ridge_ind</code> is a vector of indexes of parameters subject to 
regularization according to quadratic (ridge) penalty function.
These indexes correspond to parameters from <code>par</code> output element. 
Set <code>show_ind</code> argument of
<code><a href="#topic+summary.mnprobit">summary.mnprobit</a></code> to <code>TRUE</code> to see
these indexes.
Element <code>ridge_scale</code> is a numeric vector of weights of ridge
penalty function. 
Element <code>ridge_location</code> is a numeric vector of values to be subtracted
from parameters before they pass into penalty function.
Elements <code>lasso_ind</code>, <code>lasso_scale</code> and <code>lasso_location</code> are
the same but for the absolute value (lasso) penalty term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For identification purposes the following
parametrization of the multinomial probit model is used:
</p>
<p style="text-align: center;"><code class="reqn">z_{ji}^{*} = w_{i}\gamma_{j} + u_{ji}, \quad z_{Ji}^{*} = 0,</code>
</p>
 
<p style="text-align: center;"><code class="reqn">i\in\{1,2,...,n\},\quad j\in\{1,2,...,J-1\},</code>
</p>

<p style="text-align: center;"><code class="reqn">z_{i}=\underset{t\in\{1,...,J\}}{\text{argmax} }\text{ }z_{ti}^{*}, \qquad 
      u_{i} = (u_{1i},u_{2i},...,u_{(J-1)i})^{T},</code>
</p>

<p style="text-align: center;"><code class="reqn">u_{i}\sim N\left(\begin{bmatrix}0\\ \vdots\\ 0\end{bmatrix}, 
                       \Sigma\right), i.i.d.,</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma = \begin{bmatrix}
                1 &amp; \sigma_{12}&amp; \sigma_{13} &amp; ... &amp; \sigma_{1(J-1)}\\
                \sigma_{12} &amp; \sigma_{2}^2 &amp; \sigma_{23} &amp; ... &amp; \sigma_{2(J-1)}\\
                \sigma_{13} &amp; \sigma_{23} &amp; \sigma_{3}^2 &amp; ... &amp; \sigma_{3(J-1)}\\
                \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
                \sigma_{1(J-1)} &amp; \sigma_{2(J-1)} &amp; \sigma_{3(J-1)} &amp; ... &amp; \sigma_{J-1}^2
                \end{bmatrix}.</code>
</p>

<p>Where:
</p>

<ul>
<li> <p><code class="reqn">J</code> - the number of alternatives.
</p>
</li>
<li> <p><code class="reqn">z_{ji}^{*}</code> - unobservable (latent) value of the <code>j</code>-th
alternative. 
Usually <code class="reqn">z_{ji}^{*}</code> is interpreted as a utility of the 
<code>j</code>-th alternative.
</p>
</li>
<li> <p><code class="reqn">z_{i}</code> - selected alternative.
</p>
</li>
<li> <p><code class="reqn">w_{i}</code> - regressors that should be described in <code>formula</code>.
Regressors are assumed to be the same for all alternatives.
</p>
</li>
<li> <p><code class="reqn">\gamma_{j}</code> - regression coefficients of the <code class="reqn">j</code>-th 
alternative's equation.
</p>
</li>
<li> <p><code class="reqn">w_{i}\gamma_{j}</code> - linear index of the <code class="reqn">j</code>-th 
alternative's equation.
</p>
</li>
<li> <p><code class="reqn">u_{i}</code> - multivariate normal random vector which elements are
normal random variables.
</p>
</li>
<li> <p><code class="reqn">\Sigma</code> - covariance matrix of <code class="reqn">u_{i}</code>.
</p>
</li></ul>

<p>Note that alternatives <code class="reqn">z_{i}</code> should be represented in <code>data</code> as
integers starting from <code>1</code> (not <code>0</code>).
</p>
<p>It is also possible to account for multinomial sample selection and
endogenous switching. Consider a simple example.
Suppose that there is a sample containing
information on wages of individuals. Let's denote wages of people who
are working in information technologies (IT) sector and of those who are not
by <code class="reqn">y_{1i}</code> and <code class="reqn">y_{0i}</code> correspondingly. The effect of various 
characteristics <code class="reqn">x_{i}</code> on <code class="reqn">y_{0i}</code> and <code class="reqn">y_{1i}</code> may differ. 
For example programming skills probably have a greater impact on <code class="reqn">y_{1i}</code>
than on <code class="reqn">y_{0i}</code>. So there is different equations (regimes) for these
wages:
</p>
<p style="text-align: center;"><code class="reqn">
y_{0i} = x_{i}\beta_{0} + \varepsilon_{0i}\\
y_{1i} = x_{i}\beta_{1} + \varepsilon_{1i}\\
\varepsilon_{i}=\left(\varepsilon_{0i}, \varepsilon_{1i}\right)
\text{, i.i.d.}
</code>
</p>

<p>where <code class="reqn">\beta_{0}</code> is a vector of regression coefficients representing 
the effect of individual characteristics <code class="reqn">x_{i}</code> on wage <code class="reqn">y_{0i}</code>. 
Similarly for <code class="reqn">\beta_{1}</code>.
</p>
<p>Herewith there is non-random selection into IT
sector. Suppose that <code class="reqn">z_{i}=1</code> if individual is working in IT sector, 
<code class="reqn">z_{i}=2</code> if individual is employed in non-IT sector, and 
<code class="reqn">z_{i}=3</code> if individual is unemployed.
So observable wage is:
</p>
<p style="text-align: center;"><code class="reqn">
y_{i} = 
\begin{cases}
y_{1i}\text{, if }z_{i} = 1\\
y_{0i}\text{, if }z_{i} = 2\\
\text{unobservable, if }z_{i} = 3
\end{cases}
</code>
</p>

<p>It is assumed that joint distribution of 
<code class="reqn">u_{i}</code> and <code class="reqn">\varepsilon_{i}</code> is multivariate normal.
To estimate parameters of this model it is necessarily to assign regimes 
to alternatives. Note that <code>regime[k]</code> corresponds to the regime of 
<code class="reqn">y_{i}</code> when <code class="reqn">z_{i} = k</code>.
Therefore set <code>regimes = c(1, 0, -1)</code> where 
<code>-1</code> is a special regime
for endogenously omitted observations. Dependent variable <code class="reqn">y_{i}</code> and
regressors <code class="reqn">x_{i}</code> should be provided via <code>formula2</code> argument.
</p>
<p>Note that in some applications several alternatives may have the same
regime.The number of regimes
will have a moderate impact on computational burden. However the 
function may work extremely slow when there are more than <code class="reqn">4</code>
alternatives.
</p>
<p>By default the model is estimated via maximum likelihood method. However
if <code>estimator = "2step"</code> then two-step procedure proposed by
E. Kossova and B. Potanin (2022) will be used. The idea is similar to
Heckman's method i.e. to estimate the following regression equation:
</p>
<p style="text-align: center;"><code class="reqn">
y_{i} = x_{i}\beta + 
\sum\limits_{t=1}^{J-1}
\rho_{t}\sigma_{t}\sigma_{\varepsilon}
\tilde{\lambda}^{(z_{i})}_{ti},
</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">
\tilde{\lambda}^{(j)}_{i}=A^{(j)}\lambda^{(t)}_{i}\\
A^{(j)}_{t_{1}t_{2}} = 
\begin{cases}
1\text{, if } t_{1}=j\\
-1\text{, if } t_{1}&lt;j \text{ and } t_{1}=t_{2}\\
-1\text{, if } t_{1}&gt;j \text{ and } t_{1}=t_{2} + 1\\
0\text{, otherwise}
\end{cases}, t_{1},t_{2}\leq J-1
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\lambda^{(j)}_{i}=\lambda^{(j)}_{i}
\left(\tilde{z}_{1}^{(ji)},...,
      \tilde{z}_{J-1}^{(ji)}\right)=
\nabla \ln P\left(z_{i}\right) = 
      \nabla \ln F_{\tilde{u}^{(ji)}}\left(\tilde{z}_{1}^{(ji)},...,
      \tilde{z}_{J-1}^{(ji)}\right)=
      \left(\lambda_{1i}^{(j)},...,\lambda_{(J-1)i}^{(j)}  \right),\\
\tilde{u}^{(ji)} = 
\left(u_{1i}-u_{ji},u_{2i}-u_{ji},...,
      u_{(j-1)i}-u_{ji},u_{(j+1)i}-u_{ji},...,
      u_{Ji}-u_{ji}\right),\\
\tilde{z}^{(ji)} = \left(w_{i}\left(\gamma_{j}-\gamma_{1}\right), 
                         w_{i}\left(\gamma_{j}-\gamma_{2}\right),...,
                         w_{i}\left(\gamma_{j}-\gamma_{j-1}\right),
                         w_{i}\left(\gamma_{j}-\gamma_{j+1}\right),...,
                         w_{i}\left(\gamma_{j}-\gamma_{J}\right)\right),\\
u_{Ji}=0,\quad \gamma_{J}=\left(0,...,0\right).
</code>
</p>

<p>Note that <code class="reqn">\tilde{\lambda}</code> are estimated on the first step using 
estimates from multinomial probit model. On the second step these estimates
are used as the regressors (covariates) where <code class="reqn">\beta</code> and
<code class="reqn">\rho_{t}\sigma_{t}\sigma_{\varepsilon}</code> are estimated via least squares
method. Standard errors are estimated by approach proposed by Newey (2009).
</p>
<p>Argument <code>degrees</code> is similar to the same argument of 
<code><a href="#topic+mvoprobit">mvoprobit</a></code>.
</p>
<p>Optimization always starts with <code><a href="stats.html#topic+optim">optim</a></code>. If
<code>opt_type = "gena"</code> or <code>opt_type = "pso"</code> then 
<code><a href="gena.html#topic+gena">gena</a></code> or <code><a href="gena.html#topic+pso">pso</a></code> is used
to proceed optimization starting
from initial point provided by <code>optim</code>. Manual arguments to 
<code><a href="stats.html#topic+optim">optim</a></code>
should be provided in a form of a list through <code>opt_args$optim</code>.
Similarly <code>opt_args$gena</code> and <code>opt_args$pso</code> provide manual
arguments to <code><a href="gena.html#topic+gena">gena</a></code> and <code><a href="gena.html#topic+pso">pso</a></code>.
For example to provide Nelder-Mead optimizer to 
<code><a href="stats.html#topic+optim">optim</a></code> and
restrict the number of genetic algorithm iterations to <code class="reqn">10</code> make
<code>opt_args = list(optim = list(method = "Nelder-Mead"), 
gena = list(maxiter = 10))</code>.
</p>
<p>For more information on multivariate sample selection and endogenous
switching models see 
E. Kossova and B. Potanin (2018),
E. Kossova, L. Kupriianova, and B. Potanin (2020) and
E. Kossova and B. Potanin (2022).
</p>
<p>Function <code><a href="mnorm.html#topic+pmnorm">pmnorm</a></code> is used internally for calculation
of multivariate normal probabilities, densities and their derivatives. 
</p>
<p>Currently <code>control</code> has no input arguments intended for the users. 
This argument is used for some internal purposes of the package.
</p>


<h3>Value</h3>

<p>This function returns an object of class 'mnprobit' which is a
list containing the following elements:
</p>

<ul>
<li> <p><code>par</code> - vector of parameters' estimates.
</p>
</li>
<li> <p><code>coef</code> - matrix which j-the column <code>coef[, j]</code> is a vector
of regression coefficients estimates of the j-th alternative equation i.e.
<code class="reqn">\hat{\gamma}_{j}</code>.
</p>
</li>
<li> <p><code>coef2</code> - matrix which j-the column <code>coef2[, j]</code> is a vector
of regression coefficients estimates of the continuous equation in
(j+1)-th regime.
</p>
</li>
<li> <p><code>sigma</code> - estimate of the covariance matrix of random errors
of alternatives equations i.e. <code class="reqn">\widehat{\Sigma}</code>.
</p>
</li>
<li> <p><code>cov2</code> - matrix which element <code>cov2[i, j]</code> is
an estimate of the covariance between random error of i-th alternative
equation and random error of continuous equation in (j+1)-th regime.
</p>
</li>
<li> <p><code>var2</code> - a vector such that <code>var2[i]</code> is the estimate of
the variance of the random error of continuous equation in (i+1)-the regime.
</p>
</li>
<li> <p><code>logLik</code> - log-likelihood value.
</p>
</li>
<li> <p><code>W</code> - numeric matrix of regressors of the system of
multinomial equations.
</p>
</li>
<li> <p><code>X</code> - numeric matrix of regressors of continuous equation.
</p>
</li>
<li> <p><code>z</code> - numeric vector of multinomial dependent variable values.
</p>
</li>
<li> <p><code>y</code> - numeric vector of continuous variable values.
</p>
</li>
<li> <p><code>control_lnL</code> - some additional variables to be passed to
likelihood function (not intended for users).
</p>
</li>
<li> <p><code>formula</code> - the same as <code>formula</code> input argument but all
elements are coerced to formula type.
</p>
</li>
<li> <p><code>formula2</code> - the same as <code>formula</code> input argument but all
elements are coerced to formula type.
</p>
</li>
<li> <p><code>lambda</code> - matrix such that <code>lambda[i, j]</code> corresponds
to <code class="reqn">\hat{\tilde{\lambda}}_{ji}</code>.
</p>
</li>
<li> <p><code>data</code> - the same as <code>data</code> input argument but
without missing values.
</p>
</li>
<li> <p><code>cov</code> - estimate of the covariance matrix of parameters'
estimator.
</p>
</li>
<li> <p><code>cov_type</code> - type of the asymptotic covariance matrix estimator.
</p>
</li>
<li> <p><code>cov_2step</code> - estimate of the covariance matrix of parameters'
estimator associated with the second step parameters i.e.
when <code>estimator = "2step"</code>.
</p>
</li>
<li> <p><code>tbl</code> - special table used to create a summary 
(not intended for users).
</p>
</li>
<li> <p><code>regimes</code> - the same as <code>regimes</code> input argument or 
automatically generated matrix representing the structure of the system 
of equations. Please, see 'Details' section above for more information.
</p>
</li>
<li> <p><code>n_regimes</code> - the number of regimes.
</p>
</li>
<li> <p><code>degrees</code> - the same as <code>degrees</code> input argument.
</p>
</li>
<li> <p><code>model1</code> - first step estimation results when
<code>estimator = "2step"</code>.
</p>
</li>
<li> <p><code>coef_lambda</code> - estimates of coefficients of lambdas.
</p>
</li>
<li> <p><code>n_alt</code> - the number of alternatives.
</p>
</li>
<li> <p><code>n_obs</code> - the number of observations.
</p>
</li>
<li> <p><code>J</code> - the Jacobian of the likelihood function.
</p>
</li>
<li> <p><code>p_value</code> - p-values of the tests on significance of the 
parameters where null hypothesis is that corresponding parameter equals zero.
</p>
</li>
<li> <p><code>other</code> - list of additional variables 
that is not intended for the user.
</p>
</li></ul>

<p>It is highly recommended to get estimates via
<code><a href="#topic+coef.mnprobit">coef.mnprobit</a></code> function.
</p>


<h3>References</h3>

<p>W. K. Newey (2009). 
Two-step series estimation of sample selection models.
The Econometrics Journal, vol. 12(1), pages 217-229.
</p>
<p>E. Kossova, B. Potanin (2018). 
Heckman method and switching regression model multivariate generalization.
Applied Econometrics, vol. 50, pages 114-143.
</p>
<p>E. Kossova, L. Kupriianova, B. Potanin (2020). 
Parametric and semiparametric multivariate sample selection models 
estimators' accuracy: Comparative analysis on simulated data.
Applied Econometrics, vol. 57, pages 119-139.
</p>
<p>E. Kossova, B. Potanin (2022). 
Estimation of Gaussian multinomial endogenous switching model.
Applied Econometrics, vol. 67, pages 121-143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# -------------------------------
# CPS data example
# -------------------------------

# Set seed for reproducibility
set.seed(123)

# Upload data
data(cps)

# Prepare multinomial variable for education
cps$educ &lt;- NA
cps$educ[cps$basic == 1] &lt;- 1
cps$educ[cps$bachelor == 1] &lt;- 2
cps$educ[cps$master == 1] &lt;- 3

# Multinomial probit model for education
f_educ &lt;- educ ~ age + I(age ^ 2) + sbachelor + smaster
model1 &lt;- mnprobit(f_educ, data = cps)
summary(model1)

# Endogenous education treatment model
f_lwage &lt;- lwage ~ age + I(age ^ 2) + bachelor + master + health
model2 &lt;- mnprobit(f_educ, f_lwage, data = cps, cov_type = "gop")
summary(model2)

# Endogenous education switching model
f_lwage2 &lt;- lwage ~ age + I(age ^ 2) + health
model3 &lt;- mnprobit(f_educ, f_lwage2, data = cps, 
                   regimes = c(0, 1, 2), cov_type = "gop")
summary(model3)

 
# -------------------------------
# Simulated data example 1
# Multinomial probit model
# -------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
sigma.1 &lt;- 1
sigma.2 &lt;- 0.9
rho &lt;- 0.7
sigma &lt;- matrix(c(sigma.1 ^ 2,             sigma.1 * sigma.2 * rho,
                  sigma.1 * sigma.2 * rho, sigma.2 ^ 2), 
                ncol = 2, byrow = TRUE)
u &lt;- rmnorm(n = n, mean = c(0, 0), sigma  = sigma)

# Coefficients
gamma.1 &lt;- c(0.1, 2, 3)
gamma.2 &lt;- c(-0.1, 3, -2)

# Linear index
z1.li &lt;- gamma.1[1] + gamma.1[2] * w1 + gamma.1[3] * w2
z2.li &lt;- gamma.2[1] + gamma.2[2] * w1 + gamma.2[3] * w2

# Latent variable
z1.star &lt;- z1.li + u[, 1]
z2.star &lt;- z2.li + u[, 2]
z3.star &lt;- rep(0, n)

# Observable ordered outcome
z &lt;- rep(3, n)
z[(z1.star &gt; z2.star) &amp; (z1.star &gt; z3.star)] &lt;- 1
z[(z2.star &gt; z1.star) &amp; (z2.star &gt; z3.star)] &lt;- 2
table(z)

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, z = z)

# ---
# Step 2
# Estimation of parameters
# ---

# Estimation
model &lt;- mnprobit(z ~ w1 + w2,
                  data = data)
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients
cbind(true = gamma.1, estimate = model$coef[, 1])
cbind(true = gamma.2, estimate = model$coef[, 2])
  # covariances
cbind(true = c(sigma[1, 2], sigma[2, 2]), 
      estimate = c(model$sigma[1, 2], model$sigma[2, 2]))   

# ---
# Step 3
# Estimation of probabilities and marginal effects
# ---

# For every observation in a sample predict
  # probability of 2-nd alternative i.e. P(z = 2)
prob &lt;- predict(model, alt = 2, type = "prob")
head(prob)
  # probability of each alternative
prob &lt;- predict(model, alt = NULL, type = "prob")
head(prob)

# Calculate mean marginal effect of w2 on P(z = 1)
mean(predict(model, alt = 1, type = "prob", me = "w2"))

# Calculate probabilities and marginal effects
# for manually provided observations.
  # new data
newdata &lt;- data.frame(z = c(1, 1), 
                      w1 = c(0.5, 0.2), 
                      w2 = c(-0.3, 0.8))
  # probability P(z = 2)
predict(model, alt = 2, type = "prob", newdata = newdata)
  # linear index
predict(model, type = "li", newdata = newdata)  
  # marginal effect of w1 on P(z = 2)
predict(model, alt = 2, type = "prob", newdata = newdata, me = "w1")
  # marginal effect of w1 and w2 on P(z = 3)
predict(model, alt = 3, type = "prob", 
        newdata = newdata, me = c("w1", "w2"))
  # marginal effect of w2 on the linear index
predict(model, alt = 2, type = "li", newdata = newdata, me = "w2")
  # discrete marginal effect i.e. P(z = 2 | w1 = 0.5) - P(z = 2 | w1 = 0.2)
predict(model, alt = 2, type = "prob", newdata = newdata, 
        me = "w2", eps = c(0.2, 0.5))
  # adjusted conditional expectation for endogenous switching and 
  # sample selection models with continuous outcome with random error 'e'
  # E(e | z = 2) / cov(e, u)
  # where joint distribution of 'e' and 'u' determined by
  # Gaussian copula and 'e' is normally distributed
predict(model, alt = 2, type = "lambda", newdata = newdata) 
       


# -------------------------------
# Simulated data example 2
# Multinomial selection model
# -------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Random errors
sd.z2 &lt;- sqrt(0.9)
cor.z &lt;- 0.3
sd.y0 &lt;- sqrt(2)
cor.z1y0 &lt;- 0.4
cor.z2y0 &lt;- 0.7
sd.y1 &lt;- sqrt(1.8)
cor.z1y1 &lt;- 0.3
cor.z2y1 &lt;- 0.6
cor.y &lt;- 0.8
sigma &lt;- matrix(c(
1,                cor.z * sd.z2,            cor.z1y0 * sd.y0,         cor.z1y1 * sd.y1,
cor.z * sd.z2,    sd.z2 ^ 2,                cor.z2y0 * sd.z2 * sd.y0, cor.z2y1 * sd.z2 * sd.y1,
cor.z1y0 * sd.y0, cor.z2y0 * sd.z2 * sd.y0, sd.y0 ^ 2,                cor.y * sd.y0 * sd.y1,
cor.z1y1 * sd.y1, cor.z2y1 * sd.z2 * sd.y1, cor.y * sd.y0 * sd.y1,    sd.y1 ^ 2),
                ncol = 4, byrow = TRUE)
colnames(sigma) &lt;- c("z1", "z2", "y0", "y1")
rownames(sigma) &lt;- colnames(sigma)

# Simulate random errors
errors &lt;- rmnorm(n, c(0, 0, 0, 0), sigma)
u &lt;- errors[, 1:2]
eps &lt;- errors[, 3:4]

# Regressors (covariates)
x1 &lt;- runif(n, -1, 1)
x2 &lt;- runif(n, -1, 1)
x3 &lt;- (x2 + runif(n, -1, 1)) / 2
W &lt;- cbind(1, x1, x2)
X &lt;- cbind(1, x1, x3)

# Coefficients
gamma &lt;- cbind(c(0.1, 1, 1), 
               c(0.2, -1.2, 0.8))
beta &lt;- cbind(c(1, -1, 2), 
              c(1, -2, 1))

# Linear indexes
z1.li &lt;- W %*% gamma[, 1]
z2.li &lt;- W %*% gamma[, 2]
y0.li &lt;- X %*% beta[, 1]
y1.li &lt;- X %*% beta[, 2]

# Latent variables
z1.star &lt;- z1.li + u[, 1]
z2.star &lt;- z2.li + u[, 2]
y0.star &lt;- y0.li + eps[, 1]
y1.star &lt;- y1.li + eps[, 2]

# Obvservable variable as a dummy
z1 &lt;- (z1.star &gt; z2.star) &amp; (z1.star &gt; 0)
z2 &lt;- (z2.star &gt; z1.star) &amp; (z2.star &gt; 0)
z3 &lt;- (z1 != 1) &amp; (z2 != 1)

# Aggregate observable variable
z &lt;- rep(0, n)
z[z1] &lt;- 1
z[z2] &lt;- 2
z[z3] &lt;- 3
table(z)

# Make unobservable values of continuous variable
y &lt;-  rep(Inf, n)
y[z == 1] &lt;- y0.star[z == 1]
y[z == 2] &lt;- y1.star[z == 2]

# Data
data &lt;- data.frame(z = z, y = y, 
                   x1 = x1, x2 = x2, x3 = x3)
            
# ---
# Step 2
# Estimation of parameters
# ---

# Maximum likelihood method
model.ml &lt;- mnprobit(z ~ x1 + x2, 
                  y ~ x1 + x3, regimes = c(0, 1, -1),
                  data = data, cov_type = "gop")
summary(model.ml)  

# Two-step method
model.2step &lt;- mnprobit(z ~ x1 + x2, 
                        y ~ x1 + x3, regimes = c(0, 1, -1),
                        data = data, estimator = "2step")
summary(model.2step)
       
# Semiparametric estimator using 2-nd and 3-rd level polynomials
model.snp &lt;- mnprobit(z ~ x1 + x2, 
                      y ~ x1 + x3, regimes = c(0, 1, -1),
                      data = data, estimator = "2step",
                      degrees = c(2, 3))  
summary(model.snp)

# Simple least squares as a benchmark
model.lm0 &lt;- lm(y ~ x1 + x3, data = data[z == 1, ]) 
model.lm1 &lt;- lm(y ~ x1 + x3, data = data[z == 2, ])

# Compare coefficients of continuous equations
  # y0
cbind(true = beta[, 1],
      ml = model.ml$coef2[, 1],
      twostep = model.2step$coef2[, 1],
      semiparametric = model.snp$coef2[, 1],
      ls = coef(model.lm0)) 
  # y1  
cbind(true = beta[, 2],
      ml = model.ml$coef2[, 2],
      twostep = model.2step$coef2[, 2],
      semiparametric = model.snp$coef2[, 2],
      ls = coef(model.lm1)) 
      
# Compare coefficients of multinomial equations
  # 1-nd alternative        
cbind(true = gamma[, 1],
      ml = model.ml$coef[, 1],
      twostep = model.2step$coef[, 1]) 
  # 2-nd alternative        
cbind(true = gamma[, 2],
      ml = model.ml$coef[, 2],
      twostep = model.2step$coef[, 2])  
      
# Compare variances of random errors associated with
  # z2
cbind(true = sigma[2, 2], ml = model.ml$sigma[2, 2])
  # y0
cbind(true = sd.y0 ^ 2, ml = model.ml$var2[1])
  # y1
cbind(true = sd.y1 ^ 2, ml = model.ml$var2[2])

# compare covariances between
  # z1 and z2
cbind(true = cor.z * sd.z2, 
      ml = model.ml$sigma[1, 2],
      twostep = model.2step$sigma[1, 2])
  # z1 and y0
cbind(true = cor.z1y0 * sd.y0, 
      ml = model.ml$cov2[1, 1],
      twostep = model.2step$cov2[1, 1]) 
  # z2 and y0
cbind(true = cor.z2y0 * sd.y0, ml = model.ml$cov2[2, 1])   
  # z1 and y1
cbind(true = cor.z1y1 * sd.y1, ml = model.ml$cov2[1, 2]) 
  # z2 and y1
cbind(true = cor.z2y1 * sd.y1, ml = model.ml$cov2[2, 2]) 
            
# ---
# Step 3
# Predictions and marginal effects
# ---  

# Unconditional expectation E(y1) for every observation in a sample
predict(model.ml, type = "val", regime = 1, alt = NULL) 

# Marginal effect of x1 on conditional expectation E(y0|z = 2) 
# for every observation in a sample
predict(model.ml, type = "val", regime = 0, alt = 2, me = "x1")    

# Calculate predictions and marginal effects
# for manually provided observations
# using abovementioned models.
newdata &lt;- data.frame(z = c(1, 1),
                      y = c(1, 1), 
                      x1 = c(0.5, 0.2), 
                      x2 = c(-0.3, 0.8),
                      x3 = c(0.6, -0.7))
                      
# Unconditional expectation E(y0)
predict(model.ml, type = "val", regime = 0, alt = NULL, newdata = newdata)
predict(model.2step, type = "val", regime = 0, alt = NULL, newdata = newdata)
predict(model.snp, type = "val", regime = 0, alt = NULL, newdata = newdata)

# Conditional expectation E(y1|z=3)
predict(model.ml, type = "val", regime = 1, alt = 3, newdata = newdata)
predict(model.2step, type = "val", regime = 1, alt = 3, newdata = newdata)
predict(model.snp, type = "val", regime = 1, alt = 3, newdata = newdata)

# Marginal effect of x2 on E(y0|z = 1)
predict(model.ml, type = "val", regime = 0, 
        alt = 1, me = "x2", newdata = newdata)
predict(model.2step, type = "val", regime = 0, 
        alt = 1, me = "x2", newdata = newdata)
predict(model.snp, type = "val", regime = 0, 
        alt = 1, me = "x2", newdata = newdata)

             
</code></pre>

<hr>
<h2 id='mvoprobit'>Multivariate ordered probit model with heteroscedasticity 
and (non-random) sample selection.</h2><span id='topic+mvoprobit'></span>

<h3>Description</h3>

<p>This function allows to estimate parameters of multivariate
ordered probit model and its extensions. 
It is possible to account for heteroscedastic
variances, non-normal marginal distributions of random errors 
(under Gaussian copula) and (non-random) sample selection i.e. when some 
categories of 
particular dependent variables are observable only under some specific values 
of other dependent variables. Also it is possible to include continuous
equations to get multivariate generalization of endogenous switching model.
In this case both maximum-likelihood and two-step 
(similar to Heckman's method) estimation procedures are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvoprobit(
  formula,
  formula2 = NULL,
  data = NULL,
  groups = NULL,
  groups2 = NULL,
  marginal = list(),
  opt_type = "optim",
  opt_args = NULL,
  start = NULL,
  estimator = "ml",
  cov_type = ifelse(estimator == "ml", "sandwich", "parametric"),
  degrees = NULL,
  n_sim = 1000,
  n_cores = 1,
  control = NULL,
  regularization = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvoprobit_+3A_formula">formula</code></td>
<td>
<p>list which i-th element is an object of class &quot;formula&quot;
describing the form of the linear index for the i-th ordered equation.
Mean and variance equations should be separated by '|' symbol.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_formula2">formula2</code></td>
<td>
<p>list which i-th element is an object of class &quot;formula&quot;
describing the form of the linear index for the i-th continuous equation.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_data">data</code></td>
<td>
<p>data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_groups">groups</code></td>
<td>
<p>matrix which (i, j)-th element is j-th ordered category
(value starting from 0) of i-th dependent ordered variable. Each row of this 
matrix describes observable (in data) combination of categories i.e. values 
of dependent variables. Special category <code>'-1'</code> means that variable in 
j-th column is unobservable when other dependent variables have particular 
values i.e. given in the same row. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_groups2">groups2</code></td>
<td>
<p>the same as <code>groups</code> argument but for the continuous
dependent variables from <code>formula2</code>. 
See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_marginal">marginal</code></td>
<td>
<p>list such that <code>marginal[[i]]</code>
represents parameters of marginal distribution of the random
error of the <code>i</code>-th ordered equation and <code>names(marginal)[i]</code> is 
a name of this distribution. Marginal distributions are the same as in 
<code><a href="mnorm.html#topic+pmnorm">pmnorm</a></code>.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_opt_type">opt_type</code></td>
<td>
<p>character representing optimization function to be used.
If <code>opt_type = "optim"</code> then <code><a href="stats.html#topic+optim">optim</a></code> will be used.
If <code>opt_type = "gena"</code> then <code><a href="gena.html#topic+gena">gena</a></code> will be applied 
i.e. genetic algorithm.
If <code>opt_type = "pso"</code> then <code><a href="gena.html#topic+pso">pso</a></code> will be used 
i.e. particle swarm optimization.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_opt_args">opt_args</code></td>
<td>
<p>a list of input arguments for the optimization function
selected via <code>opt_type</code> argument. See 'Details' for information.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_start">start</code></td>
<td>
<p>numeric vector of initial parameters' values. It will be used
as a starting point for optimization purposes. It is also possible to
provide an object of class <code>'mvoprobit'</code> then its <code>'par'</code> 
element will be used as a starting point.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_estimator">estimator</code></td>
<td>
<p>character determining estimation method.
If <code>estimator = "ml"</code> then maximum-likelihood method will be used.
If <code>estimator = "2step"</code> then two-step estimation procedure similar
to Heckman's method will be applied.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_cov_type">cov_type</code></td>
<td>
<p>character determining the type of covariance matrix to be
returned and used for summary.
First, suppose that <code>estimator = "ml"</code> then the following estimators are 
available. 
If <code>cov_type = "hessian"</code> then negative inverse of Hessian matrix will 
be applied. 
If <code>cov_type = "gop"</code> then inverse of Jacobian outer products will be 
used.
If <code>cov_type = "sandwich"</code> (default) then sandwich covariance matrix
estimator will be applied.
Second, suppose that <code>estimator = "2step"</code> then by default sandwich 
estimator will be used for the first step parameters and the following 
estimators are available for the second step parameters.
If <code>cov_type = "parametric"</code> then parametric estimator 
will be used on the second step which assumes joint normality of
random errors.
If <code>cov_type = "nonparametric"</code> then nonparametric estimator 
will be used.
Also <code>cov_type</code> may be a character vector such that <code>cov_type[i]</code>
determines the covariance matrix estimator of the 
<code>i</code>-th step parameters.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_degrees">degrees</code></td>
<td>
<p>vector of non-negative integers such that <code>degrees[i]</code>
represents degree of polynomial which elements are selectivity correction
terms associated with the <code>i</code>-th ordered equation. See 'Details' for
additional information.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_n_sim">n_sim</code></td>
<td>
<p>integer representing the number of GHK draws when there are
more than 3 ordered equations. Otherwise alternative (much more efficient) 
algorithms will be used to calculate multivariate normal probabilities.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_n_cores">n_cores</code></td>
<td>
<p>positive integer representing the number of CPU cores used for 
parallel computing. If possible it is highly recommend to set it equal to
the number of available physical cores especially when the system of
ordered equations has 2 or 3 equations.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See 'Details'.</p>
</td></tr>
<tr><td><code id="mvoprobit_+3A_regularization">regularization</code></td>
<td>
<p>a list of control parameters for regularization.
Element <code>ridge_ind</code> is a vector of indexes of parameters subject to 
regularization according to quadratic (ridge) penalty function.
These indexes correspond to parameters from <code>par</code> output element. 
Set <code>show_ind</code> argument of
<code><a href="#topic+summary.mvoprobit">summary.mvoprobit</a></code> to <code>TRUE</code> to see
these indexes.
Element <code>ridge_scale</code> is a numeric vector of weights of ridge
penalty function. 
Element <code>ridge_location</code> is a numeric vector of values to be subtracted
from parameters before they pass into penalty function.
Elements <code>lasso_ind</code>, <code>lasso_scale</code> and <code>lasso_location</code> are
the same but for the lasso penalty term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate ordered probit model with heteroscedastic
random errors has the following form:
</p>
<p style="text-align: center;"><code class="reqn">z_{ji}^{*} = w_{ji}\gamma_{j} + \sigma_{ji}u_{ji},</code>
</p>
 
<p style="text-align: center;"><code class="reqn">\sigma_{ji} = \exp(w_{ji}^{*}\gamma_{j}^{*}), \quad 
      u_{i}\sim N\left(\begin{bmatrix}0\\ \vdots\\ 0\end{bmatrix}, 
                       \Sigma\right), i.i.d.,</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma = \begin{bmatrix}
               1 &amp; \rho_{12} &amp; \rho_{13} &amp; ... &amp; \rho_{1J}\\
               \rho_{12} &amp; 1 &amp; \rho_{23} &amp; ... &amp; \rho_{2J}\\
               \rho_{13} &amp; \rho_{23} &amp; 1 &amp; ... &amp; \rho_{3J}\\
               \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
               \rho_{1J} &amp; \rho_{2J} &amp; \rho_{3J} &amp; ... &amp; 1
               \end{bmatrix},</code>
</p>

<p style="text-align: center;"><code class="reqn">z_{ji}=\begin{cases}
                   0\text{, if }z_{ji}^{*}\leq c_{j1}\\
                   1\text{, if }c_{j1}&lt;z_{ji}^{*}\leq c_{j2}\\
                   2\text{, if }c_{j2}&lt;z_{ji}^{*}\leq c_{j3}\\
                   \vdots\\
                   m_{j}\text{, if }z_{ji}^{*}&gt;c_{jm_{j}}\\
                   \end{cases},</code>
</p>

<p style="text-align: center;"><code class="reqn">z_{i}=(z_{1i},...,z_{Ji})^{T},\quad
       u_{i} = (u_{1i},u_{2i},...,u_{Ji})^{T},</code>
</p>

<p style="text-align: center;"><code class="reqn">i\in\{1,2,...,n\},\quad j\in\{1,2,...,J\}.</code>
</p>

<p>Where:
</p>

<ul>
<li> <p><code class="reqn">n</code> - the number of observations. If there are no omitted 
observations then <code class="reqn">n</code> equals to <code>nrow(data)</code>.
</p>
</li>
<li> <p><code class="reqn">J</code> - the number of equations i.e. <code>length(formula)</code>.
</p>
</li>
<li> <p><code class="reqn">z_{ji}^{*}</code> - unobservable (latent) value of the <code>j</code>-th
dependent variable.
</p>
</li>
<li> <p><code class="reqn">z_{ji}</code> - observable (ordered) value of the <code>j</code>-th
dependent variable.
</p>
</li>
<li> <p><code class="reqn">(m_{j} + 1)</code> - the number of categories of
<code class="reqn">z_{ji}\in\{0,1,...,m_{j}\}</code>.
</p>
</li>
<li> <p><code class="reqn">c_{jk}</code> - <code class="reqn">k</code>-th cut of the <code>j</code>-th dependent variable.
</p>
</li>
<li> <p><code class="reqn">w_{ji}</code> - regressors of the <code class="reqn">j</code>-th mean equation 
which should be described in <code>formula[[j]]</code>.
</p>
</li>
<li> <p><code class="reqn">\gamma_{j}</code> - regression coefficients of the <code class="reqn">j</code>-th 
mean equation.
</p>
</li>
<li> <p><code class="reqn">w_{ji}\gamma_{j}</code> - linear index of the <code class="reqn">j</code>-th mean equation.
</p>
</li>
<li> <p><code class="reqn">u_{i}</code> - multivariate normal random vector which elements are
standard normal random variables.
</p>
</li>
<li> <p><code class="reqn">\Sigma</code> - correlation matrix of <code class="reqn">u_{i}</code> i.e. 
<code class="reqn">\Sigma_{t_{1}t_{2}}=\rho_{\min(t_{1},t_{2}),\max(t_{1}t_{2})}=
     \text{corr}\left(u_{it_{1}}, u_{it_{2}}\right)</code>.
</p>
</li>
<li> <p><code class="reqn">\sigma_{ji}</code> - heteroscedastic standard deviation.
</p>
</li>
<li> <p><code class="reqn">\sigma_{ji}u_{ji}</code> - heteroscedastic random errors.
</p>
</li>
<li> <p><code class="reqn">w_{ji}^{*}</code> - regressors of the <code class="reqn">j</code>-th variance equation 
which should be described in <code>formula[[j]]</code> after '|' symbol.
</p>
</li>
<li> <p><code class="reqn">\gamma_{j}^{*}</code> - regression coefficients of the <code class="reqn">j</code>-th 
variance equation.
</p>
</li>
<li> <p><code class="reqn">w_{ji}^{*}\gamma_{j}^{*}</code> - linear index of the <code class="reqn">j</code>-th 
variance equation.
</p>
</li></ul>

<p>Parameters of this model are estimated via maximum-likelihood method
using numeric optimization approach provided through <code>opt_type</code> 
argument. The type of covariance matrix estimator may be provided
through <code>cov_type</code> argument.
</p>
<p>To account for (non-random) sample selection unobservable values of 
dependent variables
should be coded as -1. For example if <code class="reqn">z_{1}</code> is a
binary variable for employment status (0 - unemployed, 1 - employed) and
<code class="reqn">z_{2}</code> is ordered variable (ranging from 0 to 2) for job satisfaction
(0 - unsatisfied, 1- satisfied, 2 - highly satisfied) 
then <code class="reqn">z_{2}</code> is observable
only when <code class="reqn">z_{1}</code> equals 1 since job satisfaction observable only for
working individuals. Consequently <code class="reqn">z_{2}</code> should be equal 
to -1 (minus one) whenever <code class="reqn">z_{1}</code> equals to 0. If variables are coded 
in this way then <code>groups</code> matrix will be created automatically. 
Otherwise user may provide manual structure of selection mechanism by 
mentioning all possible combinations of <code class="reqn">z_{1}</code> and <code class="reqn">z_{2}</code> values as 
a rows of <code>groups</code> matrix. In this particular example matrix
<code>groups</code> will have the following form (no need to provide it manually):
</p>
<p style="text-align: center;"><code class="reqn">\text{groups} =
\begin{bmatrix}
1 &amp; 2\\
1 &amp; 1\\
1 &amp; 0\\
0 &amp; -1                     
\end{bmatrix}.</code>
</p>

<p>Again, please, insure that all <code class="reqn">z_{2}</code> equal to -1 for all 
<code class="reqn">z_{1}</code> which equal to 0 in your <code>data</code>. Then matrix <code>groups</code>
will automatically have the aforementioned structure 
(accounting for non-random sample selection).
</p>
<p>If some variables <code class="reqn">z_{ji}</code> are missing i.e. take <code>NA</code> value then
contribution of other dependent variables (for the i-th observation) 
still may be included into the
likelihood function by manually substituting <code>NA</code> with -1 in your 
<code>data</code>. However insure that this particular (missing) <code class="reqn">z_{ji}</code> is 
not a regressor for other dependent variable 
(that may happen in hierarchical systems).
</p>
<p>Constant terms (intercepts) are excluded from the model for identification 
purposes. If <code class="reqn">z_{ji}</code> is a binary variable then <code class="reqn">-c_{j1}</code> may be 
interpreted as a constant term of the <code class="reqn">j</code>-th equation. 
If all <code class="reqn">z_{ji}</code> are binary variables then the model becomes
multivariate probit.
</p>
<p>It is possible to estimate sample-selection and endogenous switching models
with continuous dependent variables by providing the form of
corresponding equations via <code>formula2</code> argument. Selection (switching) 
mechanism will be determined by the aforementioned multivariate ordered 
probit model. 
</p>
<p>First, consider sample selection model with one continuous
equation (<code class="reqn">y</code> - wage) and two ordered equations from the previous example
(<code class="reqn">z_{1}</code> - employment, <code class="reqn">z_{2}</code> - job satisfaction):
</p>
<p style="text-align: center;"><code class="reqn">y_{i}^{*}=x_{i}\beta+\varepsilon_{i},</code>
</p>

<p style="text-align: center;"><code class="reqn">y_{i} =
\begin{cases}
y_{i}^{*}\text{, if }z_{1i}=1\text{ and }z_{2i}\geq 1\\
\text{unobservable, otherwise}
\end{cases},</code>
</p>

<p>where <code class="reqn">y_{i}</code> and <code class="reqn">x_{i}</code> are continuous dependent variable
and the vector of exogenous variables correspondingly. These variables should
be described in <code>formula2</code>. Random errors <code class="reqn">\varepsilon_{i}</code> and
<code class="reqn">u_{i}</code> are multivariate normal. In this example it is assumed that
information on wages <code class="reqn">y_{i}</code> available only for employed <code class="reqn">z_{1i} = 1</code> 
individuals with high enough job satisfaction <code class="reqn">z_{2i} \geq 1</code> (suppose 
that unsatisfied workers where not asked wage question or surely refuse 
to answer).
</p>
<p>To estimate this model it is also 
necessarily to set unobservable values of <code class="reqn">y_{i}</code> in <code>data</code> to 
<code>Inf</code> to distinguish them from 
<code>NA</code> values representing observations
omitted by random. Finally one needs to manually specify the structure
of equations via <code>groups</code> and <code>groups2</code> arguments by providing
all possible combinations of ordered and continuous equations values:
</p>
<p style="text-align: center;"><code class="reqn">\text{groups} =
\begin{bmatrix}
1 &amp; 2\\
1 &amp; 1\\
1 &amp; 0\\
0 &amp; -1                     
\end{bmatrix}, \text{groups2} =
\begin{bmatrix}
0\\
0\\
-1\\
-1                     
\end{bmatrix}.</code>
</p>

<p>Where <code>0</code> category in <code>group2</code> indicates that continuous 
dependent variable <code class="reqn">y_{i}</code> is observable. For example
<code>groups2[2] = 0</code> indicates that <code class="reqn">y_{i}</code> is observable
when <code>groups[2, ] = c(1, 1)</code> i.e. <code class="reqn">z_{1i} = 1</code> and <code class="reqn">z_{2i} = 1</code>.
</p>
<p>Further suppose that we assume that wage equations are different for
satisfied (<code class="reqn">z_{2i} = 1</code>) and highly satisfied (<code class="reqn">z_{2i} = 2</code>)
workers:
</p>
<p style="text-align: center;"><code class="reqn">y_{0i}^{*} = x_{i}\beta_{0} + \varepsilon_{0i},</code>
</p>

<p style="text-align: center;"><code class="reqn">y_{1i}^{*} = x_{i}\beta_{1} + \varepsilon_{1i},</code>
</p>

<p style="text-align: center;"><code class="reqn">y_{i} =
\begin{cases}
y_{0i}^{*}\text{, if }z_{1i}=1\text{ and }z_{2i} = 1\\
y_{1i}^{*}\text{, if }z_{1i}=1\text{ and }z_{2i} = 2\\
\text{unobservable, otherwise}
\end{cases}.</code>
</p>

<p>To estimate this endogenous switching model arguments <code>groups</code> and 
<code>groups2</code> should be specified as follows:
</p>
<p style="text-align: center;"><code class="reqn">\text{groups} =
\begin{bmatrix}
1 &amp; 2\\
1 &amp; 1\\
1 &amp; 0\\
0 &amp; -1                     
\end{bmatrix}, \text{groups2} =
\begin{bmatrix}
1\\
0\\
-1\\
-1                     
\end{bmatrix}.</code>
</p>

<p>For example
<code>groups2[1] = 1</code> indicates that when <code>groups[1, ] = c(1, 2)</code> 
i.e. <code class="reqn">z_{1i} = 1</code> and <code class="reqn">z_{2i} = 2</code> we observe <code class="reqn">y_{i}</code> in 
regime <code>1</code> corresponding to the wage of highly satisfied workers.
Similarly <code>groups2[2] = 0</code> indicates that when 
<code>groups[2, ] = c(1, 1)</code> 
i.e. <code class="reqn">z_{1i} = 1</code> and <code class="reqn">z_{2i} = 1</code> we observe <code class="reqn">y_{i}</code> in 
regime <code>0</code> corresponding to the wage of satisfied workers.
</p>
<p>Therefore by specifying <code>groups</code> and <code>groups2</code> arguments in the
aforementioned way it is possible to estimate various sample selection
and endogenous switching models. Furthermore one may specify several
continuous equations. Indeed, consider additional continuous equation
(<code class="reqn">y^{h}</code> - working hours):
</p>
<p style="text-align: center;"><code class="reqn">y_{i}^{h*}=x_{i}^{h}\beta^{h}+\varepsilon_{i}^{h},</code>
</p>

<p style="text-align: center;"><code class="reqn">y_{i}^{h} =
\begin{cases}
y_{i}^{h*}\text{, if }z_{1i}=1\\
\text{unobservable, otherwise}
\end{cases}.</code>
</p>

<p>Then to estimate the system accounting for this additional continuous 
equation simply substitute all <code class="reqn">y_{i}^{h*}</code> 
(such that <code class="reqn">z_{1i}=0</code>) in <code>data</code> with <code>Inf</code> and specify:
</p>
<p style="text-align: center;"><code class="reqn">\text{groups} =
\begin{bmatrix}
1 &amp; 2\\
1 &amp; 1\\
1 &amp; 0\\
0 &amp; -1                     
\end{bmatrix}, \text{groups2} =
\begin{bmatrix}
1 &amp; 0\\
0 &amp; 0\\
-1 &amp; 0\\
-1 &amp; -1                    
\end{bmatrix},</code>
</p>

<p>where <code>groups2[, 1]</code> describes regimes of the wage equation <code class="reqn">y_{i}</code> 
while <code>groups[, 2]</code> contains regimes of the hours 
equation <code class="reqn">y_{i}^{h}</code>. Note that formula of the first equation (wage)
should be specified in <code>formula2[[1]]</code> and formula of the second
equation should be provided via <code>formula2[[2]]</code> i.e. as the
first and the second elements in a <code>formula2</code> list correspondingly.
</p>
<p>By default all the models are estimated via maximum likelihood method.
However if <code>estimator = "2step"</code> then models with one continuous
equation (but voluntary number of regimes of this equation) 
will be estimated via two-step procedure proposed 
by E. Kossova and B. Potanin (2018). The idea is similar to classical
Heckman's method i.e. to substitute conditional expectation of random error
into continuous equation with it's consistent estimator. 
For simplicity suppose that there is only one regime. 
Then regression equation may be represented in the following form:
</p>
<p style="text-align: center;"><code class="reqn">
y_{i}=
x_{i}\beta+
\sum\limits_{j=1}^{J} \rho_{j}\sigma\lambda_{ji}+
\varepsilon_{i}^{*},
</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">
\varepsilon_{i}^{*} = \varepsilon_{i} - E(\varepsilon_{i}|z_{1i},...z_{Ji})=
\varepsilon_{i} - \sum\limits_{j=1}^{J} \rho_{j}\sigma\lambda_{ji},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\lambda_{ji}=
\lambda_{ji}^{(1)} + \lambda_{ji}^{(2)},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\lambda_{ji}^{(1)}=
\begin{cases}
0\text{, if }z_{ji} = 0\\
-\frac{\partial \ln P_{i}^{*}}{\partial a_{ji}}\text{, otherwise }
\end{cases},
\qquad
\lambda_{ji}^{(2)}=
\begin{cases}
0\text{, if }z_{ji} = m_{j}\\
-\frac{\partial \ln P_{i}^{*}}{\partial b_{ji}}\text{, otherwise }
\end{cases},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
P_{i}^{*}(a_{1i},...,a_{Ji};b_{1i},...,b_{Ji})=
P(a_{1i}\leq u_{1i}\leq b_{1i},....,a_{Ji}\leq u_{Ji}\leq b_{Ji}),
</code>
</p>

<p style="text-align: center;"><code class="reqn"> 
a_{ji}=
\begin{cases}
-\infty\text{, if }z_{ji} = 0\\
\frac{c_{jz_{ji}}-w_{ji}\gamma_{j}}{\sigma_{ji}}\text{, otherwise }
\end{cases},
\qquad 
b_{ji}=
\begin{cases}
\infty\text{, if }z_{ji} = m_{j}\\
\frac{c_{j(z_{ji}+1)}-w_{ji}\gamma_{j}}{\sigma_{ji}}\text{, otherwise }
\end{cases}.
</code>
</p>

<p>On the first step <code class="reqn">\hat{\lambda}_{ji}</code> are calculated using estimates
of multivariate ordered probit model.
On the second step <code class="reqn">\hat{\lambda}_{ji}</code> are used as the regressors 
instead of <code class="reqn">\lambda_{ji}</code> in a least squares estimation of 
<code class="reqn">y_{i}</code> equation. If <code>cov_type = "parametric"</code> then 
asymptotic covariance matrix estimator proposed by E. Kossova and B. Potanin (2018)
is used. If <code>cov_type = "nonparametric"</code> then robust covariance matrix 
estimator of Newey (2009) is applied. To relax normality assumption 
of <code class="reqn">\varepsilon_{i}</code> 
it is possible to use multivariate generalization of Newey (2009) method
described in E. Kossova and B. Potanin (2020).
The idea is to use polynomials of <code class="reqn">\lambda_{ji}</code> on the second step:
</p>
<p style="text-align: center;"><code class="reqn">
y_{i}=
x_{i}\beta+
\sum\limits_{j=1}^{J} \sum\limits_{t=1}^{d_{j}}\tau_{jt}\lambda_{ji}^{t}+
\varepsilon_{i}^{*},
</code>
</p>

<p>where <code class="reqn">\tau_{jt}</code> are polynomial coefficients.
Polynomial order <code class="reqn">d_{j}</code> is determined by <code>degrees[j]</code> value.
If there are more than one regime then <code>degrees</code> should be a matrix
such that <code>degrees[r, j]</code> is <code class="reqn">d_{j}</code> corresponding to the 
<code class="reqn">r</code>-th regime. However if there are more than one regime and 
<code>degrees</code> is a vector it will be transformed into a matrix which rows
are the same as <code>degrees</code>.
</p>
<p>If <code>estimator = "2step"</code> then it is possible to precalculate first 
step model with <code><a href="#topic+mvoprobit">mvoprobit</a></code> function
(setting <code>formula2 = NULL</code>)
and pass it through the <code>formula</code> argument. It allows to experiment
with various <code>formula2</code> and <code>degrees</code> specifications without
extra computational burden associated with the first step estimation.
</p>
<p>Function <code><a href="mnorm.html#topic+pmnorm">pmnorm</a></code> is used internally for calculation
of multivariate normal probabilities, densities and their derivatives. 
Marginal distribution of <code class="reqn">u_{i}</code> may be determined with
<code>marginal</code> argument that is similar to the same argument 
in <code><a href="mnorm.html#topic+pmnorm">pmnorm</a></code>. Note that joint distribution
of <code class="reqn">u</code> (random errors of ordered equations) and 
<code class="reqn">\varepsilon</code> (random errors of continuous equations) will be
determined by Gaussian copula.
</p>
<p>Optimization always starts with <code><a href="stats.html#topic+optim">optim</a></code>. If
<code>opt_type = "gena"</code> or <code>opt_type = "pso"</code> then 
<code><a href="gena.html#topic+gena">gena</a></code> or <code><a href="gena.html#topic+pso">pso</a></code> is used
to proceed optimization starting
from initial point provided by <code>optim</code>. Manual arguments to 
<code><a href="stats.html#topic+optim">optim</a></code>
should be provided in a form of a list through <code>opt_args$optim</code>.
Similarly <code>opt_args$gena</code> and <code>opt_args$pso</code> provide manual
arguments to <code><a href="gena.html#topic+gena">gena</a></code> and <code><a href="gena.html#topic+pso">pso</a></code>.
For example to provide Nelder-Mead optimizer to 
<code><a href="stats.html#topic+optim">optim</a></code> and
restrict the number of genetic algorithm iterations to <code class="reqn">10</code> make
<code>opt_args = list(optim = list(method = "Nelder-Mead"), 
gena = list(maxiter = 10))</code>.
</p>
<p>For more information on multivariate sample selection and endogenous
switching models see 
E. Kossova and B. Potanin (2018),
E. Kossova, L. Kupriianova, and B. Potanin (2020) and
E. Kossova and B. Potanin (2022).
</p>
<p>Currently <code>control</code> has no input arguments intended for the users. 
This argument is used for some internal purposes of the package.
</p>


<h3>Value</h3>

<p>This function returns an object of class 'mvoprobit' which is a
list containing the following elements:
</p>

<ul>
<li> <p><code>par</code> - vector of parameters' estimates.
</p>
</li>
<li> <p><code>coef</code> - list which j-the element <code>coef[[j]]</code> is a vector
of regression coefficients estimates of the j-th ordered equation i.e.
<code class="reqn">\hat{\gamma}_{j}</code>.
</p>
</li>
<li> <p><code>coef_var</code> - list which j-the element <code>coef_var[[j]]</code> is a
vector of regression coefficients estimates of the variance part
of the j-th ordered equation i.e.
<code class="reqn">\hat{\gamma}_{j}^{*}</code>.
</p>
</li>
<li> <p><code>coef2</code> - list which j-the element <code>coef2[[j]]</code> is a matrix
of regression coefficients estimates of the j-th continuous equation.
Wherein i-th row of this matrix contains estimates of regression 
coefficients corresponding to the i-th regime of j-th continuous variable.
</p>
</li>
<li> <p><code>sigma</code> - estimate of the covariance matrix of random errors
of ordered equations i.e. <code class="reqn">\widehat{\Sigma}</code>.
</p>
</li>
<li> <p><code>var2</code> - estimates of the variances of random errors
of continuous equations.
</p>
</li>
<li> <p><code>sigma2</code> - estimates of covariances between random errors of
continuous equations.
</p>
</li>
<li> <p><code>cov2</code> - list which j-th element <code>cov_y[[j]]</code> contains
estimates of covariances between random errors of j-th continuous
equation in different regimes.
</p>
</li>
<li> <p><code>cuts</code> - list which j-the element <code>cuts[[j]]</code> is a vector
of cuts estimates of the j-th equation i.e. <code class="reqn">\hat{c}_{j}</code>.
</p>
</li>
<li> <p><code>ind</code> - list containing some indexes partition of the 
model (not intended for users).
</p>
</li>
<li> <p><code>logLik</code> - log-likelihood value.
</p>
</li>
<li> <p><code>regressors</code> - numeric matrix which j-th element
<code>regressors[[j]]</code> is a regressors matrix of the j-th
equation i.e. <code class="reqn">w_{j}</code>.
</p>
</li>
<li> <p><code>regressors2</code> - list which j-th element
<code>regressors2[[j]]</code> is a regressors matrix of the j-th
variance equation i.e. <code class="reqn">w_{j}^{*}</code>.
</p>
</li>
<li> <p><code>dependent</code> - numeric matrix which j-th column 
<code>dependent[, j]</code> is a vector of dependent variable <code class="reqn">z_{j}</code> values.
</p>
</li>
<li> <p><code>control_lnL</code> - some additional variables to be passed to
likelihood function (not intended for users).
</p>
</li>
<li> <p><code>formula</code> - the same as <code>formula</code> input argument but all
elements are coerced to formula type.
</p>
</li>
<li> <p><code>lambda</code> - matrix such that <code>lambda[i, j]</code> corresponds
to <code class="reqn">\hat{\lambda}_{ij}</code>.
<code><a href="#topic+predict.mvoprobit">predict.mvoprobit</a></code> for more information.
</p>
</li>
<li> <p><code>data_list</code> - list which j-th element data_list[[j]] is a 
dataframe containing regressors and dependent variable of the j-th equation.
</p>
</li>
<li> <p><code>data</code> - the same as <code>data</code> input argument but
without missing values.
</p>
</li>
<li> <p><code>cov</code> - estimate of the covariance matrix of parameters'
estimator.
</p>
</li>
<li> <p><code>cov_type</code> - type of the asymptotic covariance matrix estimator.
</p>
</li>
<li> <p><code>cov_2step</code> - estimate of the covariance matrix of parameters'
estimator associated with the second step parameters i.e.
when <code>estimator = "2step"</code>.
</p>
</li>
<li> <p><code>sd</code> - standard errors of the estimates.
</p>
</li>
<li> <p><code>p_value</code> - p-values of the tests on significance of the 
parameters where null hypothesis is that corresponding parameter equals zero.
</p>
</li>
<li> <p><code>tbl</code> - special table used to create a summary 
(not intended for users).
</p>
</li>
<li> <p><code>groups</code> - the same as <code>groups</code> input argument or 
automatically generated matrix representing the structure of the system 
of equations. Please, see 'Details' section above for more information.
</p>
</li>
<li> <p><code>groups2</code> - the same as <code>groups2</code> input argument or 
automatically generated matrix representing the structure of the system 
of equations. Please, see 'Details' section above for more information.
</p>
</li>
<li> <p><code>marginal</code> - the same as <code>marginal</code> input argument.
</p>
</li>
<li> <p><code>degrees</code> - the same as <code>degrees</code> input argument.
</p>
</li>
<li> <p><code>model1</code> - first step estimation results when
<code>estimator = "2step"</code>.
</p>
</li>
<li> <p><code>coef_lambda</code> - estimates of coefficients of lambdas.
</p>
</li>
<li> <p><code>other</code> - list of additional variables not intended for the user.
</p>
</li></ul>

<p>It is highly recommended to get estimates via
<code><a href="#topic+coef.mvoprobit">coef.mvoprobit</a></code> function.
</p>


<h3>References</h3>

<p>W. K. Newey (2009). 
Two-step series estimation of sample selection models.
The Econometrics Journal, vol. 12(1), pages 217-229.
</p>
<p>E. Kossova, B. Potanin (2018). 
Heckman method and switching regression model multivariate generalization.
Applied Econometrics, vol. 50, pages 114-143.
</p>
<p>E. Kossova, L. Kupriianova, B. Potanin (2020). 
Parametric and semiparametric multivariate sample selection models 
estimators' accuracy: Comparative analysis on simulated data.
Applied Econometrics, vol. 57, pages 119-139.
</p>
<p>E. Kossova, B. Potanin (2022). 
Estimation of Gaussian multinomial endogenous switching model.
Applied Econometrics, vol. 67, pages 121-143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# -------------------------------
# CPS data example
# -------------------------------

# Set seed for reproducibility
set.seed(123)

# Upload data
data(cps)

# Prepare ordered variable for education
cps$educ &lt;- NA
cps$educ[cps$basic == 1] &lt;- 0
cps$educ[cps$bachelor == 1] &lt;- 1
cps$educ[cps$master == 1] &lt;- 2

# Labor supply (probit) model
f_work &lt;- work ~ age + I(age ^ 2) + bachelor + master + health + 
                 slwage + nchild
model1 &lt;- mvoprobit(f_work, data = cps)
summary(model1)
    
# Education choice (ordered probit) model
f_educ &lt;- educ ~ age + I(age ^ 2) + sbachelor + smaster
model2 &lt;- mvoprobit(f_educ, data = cps)
summary(model2)   

# Labor supply with endogenous education 
# treatment (recursive or hierarchical ordered probit) model
model3 &lt;- mvoprobit(list(f_work, f_educ), data = cps)  
summary(model3)         

# Sample selection (on employment) Heckman's model
f_lwage &lt;- lwage ~ age + I(age ^ 2) + bachelor + master + health
cps$lwage[cps$work == 0] &lt;- Inf
model4 &lt;- mvoprobit(f_work, f_lwage, data = cps)
summary(model4)

# Endogenous education treatment with non-random sample selection
model5 &lt;- mvoprobit(list(f_work, f_educ), f_lwage, data = cps)
summary(model5)
 
# Endogenous switching model with non-random sample selection
groups &lt;- cbind(c(1, 1, 1, 0, 0, 0),
                c(0, 1, 2, 0, 1, 2))
groups2 &lt;- matrix(c(0, 1, 2, -1, -1, -1), ncol = 1)
f_lwage2 &lt;- lwage ~ age + I(age ^ 2) + health
model6 &lt;- mvoprobit(list(f_work, f_educ), f_lwage2,
                    groups = groups, groups2 = groups2,
                    data = cps)
summary(model6)

 
# -------------------------------
# Simulated data example 1
# Ordered probit model
# -------------------------------
# ---
# Step 1
# Simulation of data
# ---

# Load required package
library("mnorm")

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
u &lt;- rnorm(n = n, mean = 0, sd = 1)

# Coefficients
gamma &lt;- c(-1, 2)

# Linear index
li &lt;- gamma[1] * w1 + gamma[2] * w2

# Latent variable
z_star &lt;- li + u

# Cuts
cuts &lt;- c(-1, 0.5, 2)

# Observable ordered outcome
z &lt;- rep(0, n)
z[(z_star &gt; cuts[1]) &amp; (z_star &lt;= cuts[2])] &lt;- 1
z[(z_star &gt; cuts[2]) &amp; (z_star &lt;= cuts[3])] &lt;- 2
z[z_star &gt; cuts[3]] &lt;- 3
table(z)

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, z = z)

# ---
# Step 2
# Estimation of parameters
# ---

# Estimation
model &lt;- mvoprobit(z ~ w1 + w2,
                   data = data)
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients
cbind(true = gamma, estimate = model$coef[[1]])
  # cuts
cbind(true = cuts, estimate = model$cuts[[1]])   

# ---
# Step 3
# Estimation of probabilities and marginal effects
# ---

# Predict probability of dependent variable
# equals to 2 for every observation in a sample.
# P(z = 2)
prob &lt;- predict(model, group = 2, type = "prob")
head(prob)

# Calculate mean marginal effect of w2 on P(z = 1)
mean(predict(model, group = 1, type = "prob", me = "w2"))

# Calculate probabilities and marginal effects
# for manually provided observations.
  # new data
newdata &lt;- data.frame(z = c(1, 1), 
                      w1 = c(0.5, 0.2), 
                      w2 = c(-0.3, 0.8))
  # probability P(z = 2)
predict(model, group = 2, type = "prob", newdata = newdata)
  # linear index
predict(model, type = "li", newdata = newdata)  
  # marginal effect of w1 on P(z = 2)
predict(model, group = 2, type = "prob", newdata = newdata, me = "w1")
  # marginal effect of w1 and w2 on P(z = 3)
predict(model, group = 3, type = "prob", 
        newdata = newdata, me = c("w1", "w2"))
  # marginal effect of w2 on the linear index
predict(model, group = 2, type = "li", newdata = newdata, me = "w2")
  # discrete marginal effect i.e. P(z = 2 | w1 = 0.5) - P(z = 2 | w1 = 0.2)
predict(model, group = 2, type = "prob", newdata = newdata, 
        me = "w2", eps = c(0.2, 0.5))
  # adjusted conditional expectation for endogenous switching and 
  # sample selection models with continuous outcome with random error 'e'
  # E(e | z == 2) / cov(e, u)
  # where joint distribution of 'e' and 'u' determined by
  # Gaussian copula and 'e' is normally distributed
predict(model, group = 2, type = "lambda", newdata = newdata)        

# ---
# Step 4
# Ordered logit model
# ---

# Estimate ordered logit model with a unit variance
# that is just a matter of reparametrization i.e.
# do not affect signs and significance of coefficients
# and dot not affect at all marginal effects
logit &lt;- mvoprobit(z ~ w1 + w2,
                   data = data,
                   marginal = "logistic")
summary(logit)

# Compare ordered probit and ordered logit models
# using Akaike and Bayesian information criteria
  # AIC
c(probit = AIC(model), logit = AIC(logit))
  # BIC
c(probit = BIC(model), logit = BIC(logit))

# Calculation of probabilities and marginal effects is identical
# to the previous example
  # probability P(z = 1)
predict(logit, group = 1, type = "prob", newdata = newdata)
  # marginal effect of w2 on P(z = 1)
predict(logit, group = 1, type = "prob", newdata = newdata, me = "w2")
  # E(e | z == 1) / cov(e, u)
predict(logit, group = 1, type = "lambda", newdata = newdata)    

# ---
# Step 5
# Semiparametric model with Gallant and Nychka distribution
# ---

pgn &lt;- mvoprobit(z ~ w1 + w2,
                 data = data,
                 marginal = list("PGN" = 3))
summary(pgn)

# Calculation of probabilities and marginal effects is identical
# to the previous example
  # probability P(z = 3)
predict(pgn, group = 3, type = "prob", newdata = newdata)
  # marginal effect of w2 on P(z = 3)
predict(pgn, group = 3, type = "prob", newdata = newdata, me = "w2")
  # E(e | z == 3) / cov(e, u)
predict(pgn, group = 3, type = "lambda", newdata = newdata)  

# Test normality assumption via likelihood ratio test
lrtest(model, pgn)

 

# -------------------------------
# Simulated data example 2
# Heteroscedastic ordered 
# probit model
# -------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
u &lt;- rnorm(n, mean = 0, sd = 1)

# Coefficients of mean equation
gamma &lt;- c(-1, 2)

# Coefficients of variance equation
gamma_het &lt;- c(0.5, -1)

# Linear index of mean equation
li &lt;- gamma[1] * w1 + gamma[2] * w2

# Linear index of variance equation
li_het &lt;- gamma_het[1] * w2 + gamma_het[2] * w3

# Heteroscedastic stdandard deviation
# i.e. value of variance equation
sd_het &lt;- exp(li_het)

# Latent variable
z_star &lt;- li + u * sd_het

# Cuts
cuts &lt;- c(-1, 0.5, 2)

# Observable ordered outcome
z &lt;- rep(0, n)
z[(z_star &gt; cuts[1]) &amp; (z_star &lt;= cuts[2])] &lt;- 1
z[(z_star &gt; cuts[2]) &amp; (z_star &lt;= cuts[3])] &lt;- 2
z[z_star &gt; cuts[3]] &lt;- 3
table(z)

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, z = z)

# ---
# Step 2
# Estimation of parameters
# ---

# Estimation
model &lt;- mvoprobit(z ~ w1 + w2 | w2 + w3,
                   data = data)
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients of mean equation
cbind(true = gamma, estimate = model$coef[[1]])
  # regression coefficients of variance equation
cbind(true = gamma_het, estimate = model$coef_var[[1]])  
  # cuts
cbind(true = cuts, estimate = model$cuts[[1]])   

# Test for homoscedasticity
model0 &lt;- mvoprobit(z ~ w1 + w2, data = data)
lrtest(model, model0)

# ---
# Step 3
# Estimation of probabilities and marginal effects
# ---

# Predict probability of dependent variable
# equals to 2 for every observation in a sample.
# P(z = 2)
prob &lt;- predict(model, group = 2, type = "prob")
head(prob)

# Calculate mean marginal effect of w2 on P(z = 1)
mean(predict(model, group = 1, type = "prob", me = "w2"))

# Calculate corresponding probability, linear
# index and heteroscedastic standard deviations for 
# manually provided observations.
  # new data
newdata &lt;- data.frame(z = c(1, 1), 
                      w1 = c(0.5, 0.2), 
                      w2 = c(-0.3, 0.8),
                      w3 = c(0.6, 0.1))
  # probability P(z = 2)
predict(model, group = 2, type = "prob", newdata = newdata)
  # linear index
predict(model, type = "li", newdata = newdata)
  # standard deviation
predict(model, type = "sd", newdata = newdata)
  # marginal effect of w3 on P(Z = 3)
predict(model, group = 3, type = "prob", newdata = newdata, me = "w3")
  # marginal effect of w2 on the standard error
predict(model, group = 2, type = "sd", newdata = newdata, me = "w2")
  # discrete marginal effect i.e. P(Z = 2 | w1 = 0.5) - P(Z = 2 | w1 = 0.2)
predict(model, group = 2, type = "prob", newdata = newdata,
        me = "w2", eps = c(0.2, 0.5))



# -------------------------------
# Simulated data example 3
# Bivariate ordered probit model
# with heteroscedastic second
# equation
# -------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)
w4 &lt;- runif(n = n, min = -1, max = 1)

# Covariance matrix of random errors
rho &lt;- 0.5
sigma &lt;- matrix(c(1,   rho,
                  rho, 1), 
                nrow = 2)

# Random errors
u &lt;- mnorm::rmnorm(n = n, mean = c(0, 0), sigma = sigma)

# Coefficients
gamma1 &lt;- c(-1, 2)
gamma2 &lt;- c(1, 1.5)

# Coefficients of variance equation
gamma2_het &lt;- c(0.5, -1)

# Linear indexes
li1 &lt;- gamma1[1] * w1 + gamma1[2] * w2
li2 &lt;- gamma2[1] * w2 + gamma2[2] * w3

# Linear index of variance equation
li2_het &lt;- gamma2_het[1] * w2 + gamma2_het[2] * w4

# Heteroscedastic stdandard deviation
# i.e. value of variance equation
sd2_het &lt;- exp(li2_het)

# Latent variables
z1_star &lt;- li1 + u[, 1]
z2_star &lt;- li2 + u[, 2] * sd2_het

# Cuts
cuts1 &lt;- c(-1, 0.5, 2)
cuts2 &lt;- c(-2, 0)

# Observable ordered outcome
  # first outcome
z1 &lt;- rep(0, n)
z1[(z1_star &gt; cuts1[1]) &amp; (z1_star &lt;= cuts1[2])] &lt;- 1
z1[(z1_star &gt; cuts1[2]) &amp; (z1_star &lt;= cuts1[3])] &lt;- 2
z1[z1_star &gt; cuts1[3]] &lt;- 3
  # second outcome
z2 &lt;- rep(0, n)
z2[(z2_star &gt; cuts2[1]) &amp; (z2_star &lt;= cuts2[2])] &lt;- 1
z2[z2_star &gt; cuts2[2]] &lt;- 2
  # distribution
table(z1, z2)

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, 
                   w3 = w3, w4 = w4,
                   z1 = z1, z2 = z2)

# ---
# Step 2
# Estimation of parameters
# ---

# Estimation
model &lt;- mvoprobit(list(z1 ~ w1 + w2,
                        z2 ~ w2 + w3 | w2 + w4),
                   data = data)
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients of the first equation
cbind(true = gamma1, estimate = model$coef[[1]])
  # regression coefficients of the second equation
cbind(true = gamma2, estimate = model$coef[[2]])
  # cuts of the first equation
cbind(true = cuts1, estimate = model$cuts[[1]])   
  # cuts of the second equation
cbind(true = cuts2, estimate = model$cuts[[2]]) 
  # correlation coefficients
cbind(true = rho, estimate = model$sigma[1, 2])  
  # regression coefficients of variance equation
cbind(true = gamma2_het, estimate = model$coef_var[[2]])

# ---
# Step 3
# Estimation of probabilities and linear indexes
# ---

# Predict probability P(z1 = 2, z2 = 0)
prob &lt;- predict(model, group = c(2, 0), type = "prob")
head(prob)

# Calculate mean marginal effect of w2 on:
  # P(z1 = 1)
mean(predict(model, group = c(1, -1), type = "prob", me = "w2"))
  # P(z1 = 1, z2 = 0)
mean(predict(model, group = c(1, 0), type = "prob", me = "w2"))

# Calculate corresponding probability and linear 
# index for manually provided observations.
  # new data
newdata &lt;- data.frame(z1 = c(1, 1), 
                      z2 = c(1, 1),
                      w1 = c(0.5, 0.2), 
                      w2 = c(-0.3, 0.8),
                      w3 = c(0.6, 0.1),
                      w4 = c(0.3, -0.5))
  # probability P(z1 = 2, z2 = 0)
predict(model, group = c(2, 0), type = "prob", newdata = newdata)
  # linear index
predict(model, type = "li", newdata = newdata)  
  # marginal probability P(z2 = 1)
predict(model, group = c(-1, 1), type = "prob", newdata = newdata) 
  # marginal probability P(z1 = 3)
predict(model, group = c(3, -1), type = "prob", newdata = newdata)
  # conditional probability P(z1 = 2 | z2 = 0)
predict(model, group = c(2, 0), given_ind = 2,
        type = "prob", newdata = newdata) 
  # conditional probability P(z2 = 1 | z1 = 3)
predict(model, group = c(3, 1), given_ind = 1,
        type = "prob", newdata = newdata) 
  # marginal effect of w4 on P(Z2 = 2)
predict(model, group = c(-1, 2),
        type = "prob", newdata = newdata, me = "w4")   
  # marginal effect of w4 on P(z1 = 3, Z2 = 2)
predict(model, group = c(3, 2),
        type = "prob", newdata = newdata, me = "w4") 
  # marginal effect of w4 on P(z1 = 3 | z2 = 2)
predict(model, group = c(3, 2), given_ind = 2,
        type = "prob", newdata = newdata, me = "w4")         

# ---
# Step 4
# Replication under non-random sample selection
# ---

# Suppose that z2 is unobservable when z1 = 1 or z1 = 3
z2[(z1 == 1) | (z1 == 3)] &lt;- -1
data$z2 &lt;- z2

# Replicate estimation procedure
model &lt;- mvoprobit(list(z1 ~ w1 + w2,
                        z2 ~ w2 + w3 | w2 + w4),
                   cov_type = "GOP",
                   data = data)
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients of the first equation
cbind(true = gamma1, estimate = model$coef[[1]])
  # regression coefficients of the second equation
cbind(true = gamma2, estimate = model$coef[[2]])
  # cuts of the first equation
cbind(true = cuts1, estimate = model$cuts[[1]])   
  # cuts of the second equation
cbind(true = cuts2, estimate = model$cuts[[2]]) 
  # correlation coefficients
cbind(true = rho, estimate = model$sigma[1, 2])  
  # regression coefficients of variance equation
cbind(true = gamma2_het, estimate = model$coef_var[[2]])

# ---
# Step 5
# Semiparametric model with marginal logistic and PGN distributions
# ---

# Estimate the model
model &lt;- mvoprobit(list(z1 ~ w1 + w2,
                        z2 ~ w2 + w3 | w2 + w4),
                   data = data,
                   marginal = list(PGN = 3, logistic = NULL))
summary(model)



# -------------------------------
# Simulated data example 4
# Heckman model with
# ordered selection mechanism
# -------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
rho &lt;- 0.5
var.y &lt;- 0.3
sd.y &lt;- sqrt(var.y)
sigma &lt;- matrix(c(1,          rho * sd.y,
                  rho * sd.y, var.y),
                nrow = 2)
errors &lt;- mnorm::rmnorm(n = n, mean = c(0, 0), sigma = sigma)
u &lt;- errors[, 1]
eps &lt;- errors[, 2]

# Coefficients
gamma &lt;- c(-1, 2)
beta &lt;- c(1, -1, 1)

# Linear index
li &lt;- gamma[1] * w1 + gamma[2] * w2
li.y &lt;- beta[1] + beta[2] * w1 + beta[3] * w3

# Latent variable
z_star &lt;- li + u
y_star &lt;- li.y + eps

# Cuts
cuts &lt;- c(-1, 0.5, 2)

# Observable ordered outcome
z &lt;- rep(0, n)
z[(z_star &gt; cuts[1]) &amp; (z_star &lt;= cuts[2])] &lt;- 1
z[(z_star &gt; cuts[2]) &amp; (z_star &lt;= cuts[3])] &lt;- 2
z[z_star &gt; cuts[3]] &lt;- 3
table(z)

# Observable continuous outcome such
# that outcome 'y' is observable only 
# when 'z &gt; 1' and unobservable otherwise
# i.e. when 'z &lt;= 1' we code 'y' as 'Inf'
y &lt;- y_star
y[z &lt;= 1] &lt;- Inf

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, 
                   z = z, y = y)

# ---
# Step 2
# Estimation of parameters
# ---

# Estimation
model &lt;- mvoprobit(z ~ w1 + w2,
                   y ~ w1 + w3,
                   data = data)
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients of ordered equation
cbind(true = gamma, estimate = model$coef[[1]])
  # cuts
cbind(true = cuts, estimate = model$cuts[[1]])   
  # regression coefficients of continuous equation
cbind(true = beta, estimate = as.numeric(model$coef2[[1]]))  
  # variance
cbind(true = var.y, estimate = as.numeric(model$var2[[1]]))
  # covariance
cbind(true = rho * sd.y, estimate = as.numeric(model$cov2[[1]]))

# ---
# Step 3
# Estimation of expectations and marginal effects
# ---

# New data
newdata &lt;- data.frame(z = 1, 
                      y = 1,
                      w1 = 0.1, 
                      w2 = 0.2,
                      w3 = 0.3)

# Predict unconditional expectation of the dependent variable
predict(model, group2 = 0, newdata = newdata)

# Predict conditional expectations of the dependent variable
  # E(y | z == 2)
predict(model, group = 2, group2 = 0, newdata = newdata)
  # E(y | z == 0)
predict(model, group = 0, group2 = 0, newdata = newdata)

# ---
# Step 4
# Classical Heckman's two-step estimation procedure
# ---

# Predict adjusted conditional expectations
lambda2 &lt;- predict(model, group = 2, type = "lambda")
lambda3 &lt;- predict(model, group = 3, type = "lambda")

# Construct variable responsible for adjusted
# conditional expectation in linear regression equation
data$lambda &lt;- NA
data$lambda[model$data$z == 2] &lt;- lambda2[model$data$z == 2]
data$lambda[model$data$z == 3] &lt;- lambda3[model$data$z == 3]

# Alternatively simply get this variable from the estimation output
# of a selection part of the model
model_probit &lt;- mvoprobit(z ~ w1 + w2, data = data)
data$lambda &lt;- model_probit$lambda

# Estimate model via classical least squares
model_lm &lt;- lm(y ~ w1 + w3, data = data[!is.infinite(data$y), ])
summary(model_lm)

# Estimate model via two-step procedure
model_ts &lt;- lm(y ~ w1 + w3 + lambda, data = data[!is.infinite(data$y), ])
summary(model_ts)

# Automatic estimation of two-step model with robust standard errors
model_ts &lt;- mvoprobit(z ~ w1 + w2,
                      y ~ w1 + w3,
                      data = data, 
                      estimator = "2step")
summary(model_ts)

# Check estimates accuracy
tbl &lt;- cbind(true = beta, 
             ls = coef(model_lm),
             ml = model$coef2[[1]][1, ],
             twostep = model_ts$coef2[[1]][1, ])  
print(tbl)

# ---
# Step 5
# Semiparametric estimation procedure
# ---

# Estimate the model using Lee's method 
# assuming logistic distribution of
# random errors of the selection equation
model_Lee &lt;- mvoprobit(z ~ w1 + w2, 
                       y ~ w1 + w3,
                       data = data, 
                       marginal = list(logistic = NULL),
                       estimator = "2step")
summary(model_Lee)

# One step estimation is also available as well
# as more complex marginal distributions.
# Consider random errors in selection equation
# following PGN distribution with three parameters.
model_sp &lt;- mvoprobit(z ~ w1 + w2, 
                      y ~ w1 + w3,
                      data = data, 
                      marginal = list(PGN = 3))
summary(model_sp)

# To additionally relax normality assumption of
# random error of continuous equation it is possible
# to use Newey's two-step procedure.
model_Newey &lt;- mvoprobit(z ~ w1 + w2, 
                         y ~ w1 + w3,
                         data = data,
                         marginal = list(PGN = 3),
                         estimator = "2step",
                         degrees = 2, 
                         cov_type = "nonparametric")
summary(model_Newey)



# -------------------------------
# Simulated data example 5
# Endogenous switching model
# with heteroscedastic
# ordered selection mechanism
# -------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
rho_0 &lt;- -0.8
rho_1 &lt;- -0.7
var2_0 &lt;- 0.9
var2_1 &lt;- 1
sd_y_0 &lt;- sqrt(var2_0)
sd_y_1 &lt;- sqrt(var2_1)
cor_y_01 &lt;- 0.7
cov2_01 &lt;- sd_y_0 * sd_y_1 * cor_y_01
cov2_z_0 &lt;- rho_0 * sd_y_0
cov2_z_1 &lt;- rho_1 * sd_y_1
sigma &lt;- matrix(c(1,        cov2_z_0, cov2_z_1,
                  cov2_z_0, var2_0,   cov2_01,
                  cov2_z_1, cov2_01,  var2_1),
                nrow = 3)
errors &lt;- mnorm::rmnorm(n = n, mean = c(0, 0, 0), sigma = sigma)
u &lt;- errors[, 1]
eps_0 &lt;- errors[, 2]
eps_1 &lt;- errors[, 3]

# Coefficients
gamma &lt;- c(-1, 2)
gamma_het &lt;- c(0.5, -1)
beta_0 &lt;- c(1, -1, 1)
beta_1 &lt;- c(2, -1.5, 0.5)

# Linear index of ordered equation
  # mean
li &lt;- gamma[1] * w1 + gamma[2] * w2
  # variance
li_het &lt;- gamma_het[1] * w2 + gamma_het[2] * w3

# Linear index of continuous equation
  # regime 0
li_y_0 &lt;- beta_0[1] + beta_0[2] * w1 + beta_0[3] * w3
  # regime 1
li_y_1 &lt;- beta_1[1] + beta_1[2] * w1 + beta_1[3] * w3

# Latent variable
z_star &lt;- li + u * exp(li_het)
y_0_star &lt;- li_y_0 + eps_0
y_1_star &lt;- li_y_1 + eps_1

# Cuts
cuts &lt;- c(-1, 0.5, 2)

# Observable ordered outcome
z &lt;- rep(0, n)
z[(z_star &gt; cuts[1]) &amp; (z_star &lt;= cuts[2])] &lt;- 1
z[(z_star &gt; cuts[2]) &amp; (z_star &lt;= cuts[3])] &lt;- 2
z[z_star &gt; cuts[3]] &lt;- 3
table(z)

# Observable continuous outcome such
# that outcome 'y' is 
# in regime 1 when 'z == 1', 
# in regime 0 when 'z &lt;= 1',
# unobservable when 'z == 0'
y &lt;- rep(NA, n)
y[z == 0] &lt;- Inf
y[z == 1] &lt;- y_0_star[z == 1]
y[z &gt; 1] &lt;- y_1_star[z &gt; 1]

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, 
                   z = z, y = y)

# ---
# Step 2
# Estimation of parameters
# ---

# Assign groups
groups &lt;- matrix(0:3, ncol = 1)
groups2 &lt;- matrix(c(-1, 0, 1, 1), ncol = 1)

# Estimation
model &lt;- mvoprobit(list(z ~ w1 + w2 | w2 + w3),
                   list(y ~ w1 + w3),
                   groups = groups, groups2 = groups2,
                   data = data)
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients of ordered equation
cbind(true = gamma, estimate = model$coef[[1]])
cbind(true = gamma_het, estimate = model$coef_var[[1]])
  # cuts
cbind(true = cuts, estimate = model$cuts[[1]])   
  # regression coefficients of continuous equation
cbind(true = beta_0, estimate = model$coef2[[1]][1, ]) 
cbind(true = beta_1, estimate = model$coef2[[1]][2, ])
  # variances
cbind(true = c(var2_0, var2_1), estimate = model$var2[[1]]) 
  # covariances
cbind(true = c(cov2_z_0, cov2_z_1), estimate = model$cov2[[1]])

# ---
# Step 3
# Estimation of expectations and marginal effects
# ---

# New data
newdata &lt;- data.frame(z = 1, 
                      y = 1,
                      w1 = 0.1, 
                      w2 = 0.2,
                      w3 = 0.3)

# Predict unconditional expectation of the dependent variable
  # regime 0 
predict(model, group2 = 0, newdata = newdata)
  # regime 1
predict(model, group2 = 1, newdata = newdata)

# Predict conditional expectations of the dependent variable
# given condition 'z == 0' for regime 1 i.e. E(y1 | z = 0)
predict(model, group = 0, group2 = 1, newdata = newdata)



# -------------------------------
# Simulated data example 6
# Endogenous switching model with
# multivariate heteroscedastic
# ordered selection mechanism
# -------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)
w4 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
rho_z1_z2 &lt;- 0.5
rho_y0_z1 &lt;- 0.6
rho_y0_z2 &lt;- 0.7
rho_y1_z1 &lt;- 0.65
rho_y1_z2 &lt;- 0.75
var20 &lt;- 0.9
var21 &lt;- 1
sd_y0 &lt;- sqrt(var20)
sd_y1 &lt;- sqrt(var21)
cor_y01 &lt;- 0.7
cov201 &lt;- sd_y0 * sd_y1 * cor_y01
cov20_z1 &lt;- rho_y0_z1 * sd_y0
cov21_z1 &lt;- rho_y1_z1 * sd_y1
cov20_z2 &lt;- rho_y0_z2 * sd_y0
cov21_z2 &lt;- rho_y1_z2 * sd_y1
sigma &lt;- matrix(c(1,         rho_z1_z2,  cov20_z1,  cov21_z1, 
                  rho_z1_z2, 1,          cov20_z2,  cov21_z2,
                  cov20_z1,  cov20_z2,   var20,     cov201,
                  cov21_z1,  cov21_z2,   cov201,    var21),
                nrow = 4)
errors &lt;- mnorm::rmnorm(n = n, mean = c(0, 0, 0, 0), sigma = sigma)
u1 &lt;- errors[, 1]
u2 &lt;- errors[, 2]
eps0 &lt;- errors[, 3]
eps1 &lt;- errors[, 4]

# Coefficients
gamma1 &lt;- c(-1, 2)
gamma1_het &lt;- c(0.5, -1)
gamma2 &lt;- c(1, 1)
beta0 &lt;- c(1, -1, 1, -1.2)
beta1 &lt;- c(2, -1.5, 0.5, 1.2)

# Linear index of ordered equation
  # mean
li1 &lt;- gamma1[1] * w1 + gamma1[2] * w2
li2 &lt;- gamma2[1] * w1 + gamma2[2] * w3
  # variance
li1_het &lt;- gamma1_het[1] * w2 + gamma1_het[2] * w3

# Linear index of continuous equation
  # regime 0
li_y0 &lt;- beta0[1] + beta0[2] * w1 + beta0[3] * w3 + beta0[4] * w4
  # regime 1
li_y1 &lt;- beta1[1] + beta1[2] * w1 + beta1[3] * w3 + beta1[4] * w4

# Latent variables
z1_star &lt;- li1 + u1 * exp(li1_het)
z2_star &lt;- li2 + u2
y0_star &lt;- li_y0 + eps0
y1_star &lt;- li_y1 + eps1

# Cuts
cuts1 &lt;- c(-1, 1)
cuts2 &lt;- c(0)

# Observable ordered outcome
  # first
z1 &lt;- rep(0, n)
z1[(z1_star &gt; cuts1[1]) &amp; (z1_star &lt;= cuts1[2])] &lt;- 1
z1[z1_star &gt; cuts1[2]] &lt;- 2
  # second
z2 &lt;- rep(0, n)
z2[z2_star &gt; cuts2[1]] &lt;- 1
table(z1, z2)

# Observable continuous outcome such
# that outcome 'y' is 
# in regime 0 when 'z1 == 1', 
# in regime 1 when 'z1 == 0' or 'z1 == 2',
# unobservable when 'z2 == 0'
y &lt;- rep(NA, n)
y[z1 == 1] &lt;- y0_star[z1 == 1]
y[z1 != 1] &lt;- y1_star[z1 != 1]
y[z2 == 0] &lt;- Inf

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, w4 = w4,
                   z1 = z1, z2 = z2, y = y)

# ---
# Step 2
# Estimation of parameters
# ---

# Assign groups
groups &lt;- matrix(c(0, 0,
                   0, 1,
                   1, 0,
                   1, 1,
                   2, 0,
                   2, 1), 
                 byrow = TRUE, ncol = 2)
groups2 &lt;- matrix(c(-1, 1, -1, 0, -1, 1), ncol = 1)

# Estimation
model &lt;- mvoprobit(list(z1 ~ w1 + w2 | w2 + w3,
                        z2 ~ w1 + w3),
                   list(y ~ w1 + w3 + w4),
                   groups = groups, groups2 = groups2,
                   data = data)
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients of the first ordered equation
cbind(true = gamma1, estimate = model$coef[[1]])
cbind(true = gamma1_het, estimate = model$coef_var[[1]])
  # regression coefficients of the second ordered equation
cbind(true = gamma2, estimate = model$coef[[2]])
  # cuts
cbind(true = cuts1, estimate = model$cuts[[1]])   
cbind(true = cuts2, estimate = model$cuts[[2]])  
  # regression coefficients of continuous equation
cbind(true = beta0, estimate = model$coef2[[1]][1, ]) 
cbind(true = beta1, estimate = model$coef2[[1]][2, ])
  # variances
cbind(true = c(var20, var21), estimate = model$var2[[1]]) 
  # covariances
cbind(true = c(cov20_z1, cov20_z2), estimate = model$cov2[[1]][1, ])
cbind(true = c(cov21_z1, cov21_z2), estimate = model$cov2[[1]][2, ])

# ---
# Step 3
# Estimation of expectations and marginal effects
# ---

# New data
newdata &lt;- data.frame(z1 = 1, 
                      z2 = 1,
                      y = 1,
                      w1 = 0.1, 
                      w2 = 0.2,
                      w3 = 0.3,
                      w4 = 0.4)

# Predict unconditional expectation of the dependent variable
  # regime 0 
predict(model, group2 = 0, newdata = newdata)
  # regime 1
predict(model, group2 = 1, newdata = newdata)

# Predict conditional expectations of the dependent variable
# E(y1 | z1 = 2, z2 = 1)
predict(model, group = c(2, 1), group2 = 1, newdata = newdata)

# Marginal effect of w3 on E(y1 | z1 = 2, z2 = 1)
predict(model, group = c(2, 1), group2 = 1, newdata = newdata, me = "w3")

# ---
# Step 4
# Two-step estimation procedure
# ---

# For comparison reasons let's estimate the model
# via least squres
# Estimate model via classical least squares for a benchmark
model.ls.0 &lt;- lm(y ~ w1 + w3 + w4,
                 data = data[!is.infinite(data$y) &amp; (data$z1 == 1), ])
model.ls.1 &lt;- lm(y ~ w1 + w3 + w4,
                 data = data[!is.infinite(data$y) &amp; (data$z1 != 1), ])


# Apply two-step procedure
model_ts &lt;-  mvoprobit(list(z1 ~ w1 + w2 | w2 + w3,
                            z2 ~ w1 + w3),
                       y ~ w1 + w3 + w4,
                       groups = groups, groups2 = groups2,
                       estimator = "2step",
                       data = data)
summary(model_ts)

# Use two-step procedure with logistic marginal distributions
# that is multivariate generalization of Lee's method
model_Lee &lt;-  mvoprobit(list(z1 ~ w1 + w2 | w2 + w3,
                             z2 ~ w1 + w3),
                             y ~ w1 + w3 + w4,
                        marginal = list(logistic = NULL, logistic = NULL),
                        groups = groups, groups2 = groups2,
                        estimator = "2step",
                        data = data)
                        
# Apply multivariate generalization of Newey's method
model_Newey &lt;-  mvoprobit(list(z1 ~ w1 + w2 | w2 + w3,
                               z2 ~ w1 + w3),
                               y ~ w1 + w3 + w4,
                          marginal = list(logistic = NULL, logistic = NULL),
                          degrees = c(2, 3),
                          groups = groups, groups2 = groups2,
                          estimator = "2step",
                          data = data)

# Compare accuracy of the methods
  # beta0
tbl &lt;- cbind(true = beta0, 
             ls = coef(model.ls.0),
             ml = model$coef2[[1]][1, ],
             twostep = model_ts$coef2[[1]][1, ],
             Lee = model_Lee$coef2[[1]][1, ],
             Newey = model_Newey$coef2[[1]][1, ])  
print(tbl)
  # beta1
tbl &lt;- cbind(true = beta1, 
             ls = coef(model.ls.1),
             ml = model$coef2[[1]][2, ],
             twostep = model_ts$coef2[[1]][2, ],
             Lee = model_Lee$coef2[[1]][2, ],
             Newey = model_Newey$coef2[[1]][2, ])  
print(tbl)




# -------------------------------
# Simulated data example 7
# Endogenous multivariate
# switching model with
# multivariate heteroscedastic
# ordered selection mechanism
# -------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)
w4 &lt;- runif(n = n, min = -1, max = 1)
w5 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
var20 &lt;- 0.9
var21 &lt;- 1
var_g0 &lt;- 1.1
var_g1 &lt;- 1.2
var_g2 &lt;- 1.3
A &lt;- rWishart(1, 7, diag(7))[, , 1]
B &lt;- diag(sqrt(c(1, 1, var20, var21, 
                 var_g0, var_g1, var_g2)))
sigma &lt;-  B  %*% cov2cor(A) %*% B
errors &lt;- mnorm::rmnorm(n = n, mean = rep(0, nrow(sigma)), sigma = sigma)
u1 &lt;- errors[, 1]
u2 &lt;- errors[, 2]
eps0_y &lt;- errors[, 3]
eps1_y &lt;- errors[, 4]
eps0_g &lt;- errors[, 5]
eps1_g &lt;- errors[, 6]
eps2_g &lt;- errors[, 7]

# Coefficients
gamma1 &lt;- c(-1, 2)
gamma1_het &lt;- c(0.5, -1)
gamma2 &lt;- c(1, 1)
beta0_y &lt;- c(1, -1, 1, -1.2)
beta1_y &lt;- c(2, -1.5, 0.5, 1.2)
beta0_g &lt;- c(-1, 1, 1, 1)
beta1_g &lt;- c(1, -1, 1, 1)
beta2_g &lt;- c(1, 1, -1, 1)

# Linear index of ordered equation
  # mean
li1 &lt;- gamma1[1] * w1 + gamma1[2] * w2
li2 &lt;- gamma2[1] * w1 + gamma2[2] * w3
  # variance
li1_het &lt;- gamma1_het[1] * w2 + gamma1_het[2] * w3

# Linear index of the first continuous equation
  # regime 0
li_y0 &lt;- beta0_y[1] + beta0_y[2] * w1 + beta0_y[3] * w3 + beta0_y[4] * w4
  # regime 1
li_y1 &lt;- beta1_y[1] + beta1_y[2] * w1 + beta1_y[3] * w3 + beta1_y[4] * w4

# Linear index of the second continuous equation
  # regime 0
li_g0 &lt;- beta0_g[1] + beta0_g[2] * w2 + beta0_g[3] * w3 + beta0_g[4] * w5
  # regime 1
li_g1 &lt;- beta1_g[1] + beta1_g[2] * w2 + beta1_g[3] * w3 + beta1_g[4] * w5
  # regime 2
li_g2 &lt;- beta2_g[1] + beta2_g[2] * w2 + beta2_g[3] * w3 + beta2_g[4] * w5

# Latent variables
z1_star &lt;- li1 + u1 * exp(li1_het)
z2_star &lt;- li2 + u2
y0_star &lt;- li_y0 + eps0_y
y1_star &lt;- li_y1 + eps1_y
g0_star &lt;- li_g0 + eps0_g
g1_star &lt;- li_g1 + eps1_g
g2_star &lt;- li_g2 + eps2_g

# Cuts
cuts1 &lt;- c(-1, 1)
cuts2 &lt;- c(0)

# Observable ordered outcome
  # first
z1 &lt;- rep(0, n)
z1[(z1_star &gt; cuts1[1]) &amp; (z1_star &lt;= cuts1[2])] &lt;- 1
z1[z1_star &gt; cuts1[2]] &lt;- 2
  # second
z2 &lt;- rep(0, n)
z2[z2_star &gt; cuts2[1]] &lt;- 1
table(z1, z2)

# Observable continuous outcome such
# that outcome 'y' is 
# in regime 0 when 'z1 == 1', 
# in regime 1 when 'z1 == 0' or 'z1 == 2',
# unobservable when 'z2 == 0'
y &lt;- rep(NA, n)
y[z1 == 1] &lt;- y0_star[z1 == 1]
y[z1 != 1] &lt;- y1_star[z1 != 1]
y[z2 == 0] &lt;- Inf

#' # Observable continuous outcome such
# that outcome 'g' is 
# in regime 0 when 'z1 == z2', 
# in regime 1 when 'z1 &gt; z2',
# in regime 2 when 'z1 &lt; z2',
g &lt;- rep(NA, n)
g[z1 == z2] &lt;- g0_star[z1 == z2]
g[z1 &gt; z2] &lt;- g1_star[z1 &gt; z2]
g[z1 &lt; z2] &lt;- g2_star[z1 &lt; z2]

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, w4 = w4, w5 = w5,
                   z1 = z1, z2 = z2, y = y, g = g)

# ---
# Step 2
# Estimation of parameters
# ---

# Assign groups
groups &lt;- matrix(c(0, 0,
                   0, 1,
                   1, 0,
                   1, 1,
                   2, 0,
                   2, 1), 
                 byrow = TRUE, ncol = 2)
groups2 &lt;- matrix(NA, nrow = nrow(groups), ncol = 2)
groups2[groups[, 1] == 1, 1] &lt;- 0
groups2[(groups[, 1] == 0) | (groups[, 1] == 2), 1] &lt;- 1
groups2[groups[, 2] == 0, 1] &lt;- -1
groups2[groups[, 1] == groups[, 2], 2] &lt;- 0
groups2[groups[, 1] &gt; groups[, 2], 2] &lt;- 1
groups2[groups[, 1] &lt; groups[, 2], 2] &lt;- 2
cbind(groups, groups2)

# Estimation
model &lt;- mvoprobit(list(z1 ~ w1 + w2 | w2 + w3,
                        z2 ~ w1 + w3),
                   list(y ~ w1 + w3 + w4,
                        g ~ w2 + w3 + w5),
                   groups = groups, groups2 = groups2,
                   data = data)
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients of the first ordered equation
cbind(true = gamma1, estimate = model$coef[[1]])
cbind(true = gamma1_het, estimate = model$coef_var[[1]])
  # regression coefficients of the second ordered equation
cbind(true = gamma2, estimate = model$coef[[2]])
  # cuts
cbind(true = cuts1, estimate = model$cuts[[1]])   
cbind(true = cuts2, estimate = model$cuts[[2]])  
  # regression coefficients of the first continuous equation
cbind(true = beta0_y, estimate = model$coef2[[1]][1, ]) 
cbind(true = beta1_y, estimate = model$coef2[[1]][2, ])
  # regression coefficients of the second continuous equation
cbind(true = beta0_g, estimate = model$coef2[[2]][1, ]) 
cbind(true = beta1_g, estimate = model$coef2[[2]][2, ])
cbind(true = beta2_g, estimate = model$coef2[[2]][3, ])
  # variances
cbind(true = c(var20, var21), estimate = model$var2[[1]]) 
cbind(true = c(var_g0, var_g1, var_g2), estimate = model$var2[[2]]) 
  # correlation between ordered equations
cbind(true = c(sigma[1, 2]), estimate = model$sigma[1, 2])
  # covariances between continious and ordered equations
cbind(true = sigma[1:2, 3], estimate = model$cov2[[1]][1, ])
cbind(true = sigma[1:2, 4], estimate = model$cov2[[1]][2, ])
cbind(true = sigma[1:2, 5], estimate = model$cov2[[2]][1, ])
cbind(true = sigma[1:2, 6], estimate = model$cov2[[2]][2, ])
cbind(true = sigma[1:2, 7], estimate = model$cov2[[2]][3, ])
  # covariances between continuous equations
cbind(true = c(sigma[4, 7], sigma[3, 5], sigma[4, 6]), 
      estimate = model$sigma2[[1]]) 
      
# ---
# Step 3
# Estimation of expectations and marginal effects
# ---

# New data
newdata &lt;- data.frame(z1 = 1, 
                      z2 = 1,
                      y = 1,
                      g = 1,
                      w1 = 0.1, 
                      w2 = 0.2,
                      w3 = 0.3,
                      w4 = 0.4,
                      w5 = 0.5)

# Predict unconditional expectation of the dependent variable
  # regime 0 for 'y' and regime 1 for 'g' i.e. E(y0), E(g1)
predict(model, group2 = c(0, 1), newdata = newdata)

# Predict conditional expectations of the dependent variable
# E(y0 | z1 = 2, z2 = 1), E(g1 | z1 = 2, z2 = 1)
predict(model, group = c(2, 1), group2 = c(0, 1), newdata = newdata)

# Marginal effect of w3 on E(y1 | z1 = 2, z2 = 1) and E(g1 | z1 = 2, z2 = 1)
predict(model, group = c(2, 1), group2 = c(0, 1), 
        newdata = newdata, me = "w3")



</code></pre>

<hr>
<h2 id='nobs.mnprobit'>Extract the Number of Observations from a Fit of the mnprobit Function.</h2><span id='topic+nobs.mnprobit'></span>

<h3>Description</h3>

<p>Extract the number of observations from a model fit
of the <code><a href="#topic+mnprobit">mnprobit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mnprobit'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.mnprobit_+3A_object">object</code></td>
<td>
<p>object of class &quot;mnprobit&quot;</p>
</td></tr>
<tr><td><code id="nobs.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unobservable values of continuous equations are included into
the number of observations.
</p>


<h3>Value</h3>

<p>A single positive integer number.
</p>

<hr>
<h2 id='nobs.mvoprobit'>Extract the Number of Observations from a Fit of the mvoprobit Function.</h2><span id='topic+nobs.mvoprobit'></span>

<h3>Description</h3>

<p>Extract the number of observations from a model fit
of the <code><a href="#topic+mvoprobit">mvoprobit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvoprobit'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.mvoprobit_+3A_object">object</code></td>
<td>
<p>object of class &quot;mvoprobit&quot;</p>
</td></tr>
<tr><td><code id="nobs.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unobservable values of continuous equations are included into
the number of observations.
</p>


<h3>Value</h3>

<p>A single positive integer number.
</p>

<hr>
<h2 id='predict.mnprobit'>Predict method for mnprobit function</h2><span id='topic+predict.mnprobit'></span>

<h3>Description</h3>

<p>Predict method for mnprobit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mnprobit'
predict(
  object,
  ...,
  newdata = NULL,
  alt = 1,
  regime = -1,
  type = ifelse(is.null(regime) | (regime == -1), "prob", "val"),
  alt_obs = "all",
  me = NULL,
  eps = NULL,
  control = list(),
  se = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mnprobit_+3A_object">object</code></td>
<td>
<p>object of class &quot;mnprobit&quot;</p>
</td></tr>
<tr><td><code id="predict.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="predict.mnprobit_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables 
with which to predict. If omitted, the original data frame used.
This data frame should contain values of dependent variables even if
they are not actually needed for prediction 
(simply assign them with 0 values).</p>
</td></tr>
<tr><td><code id="predict.mnprobit_+3A_alt">alt</code></td>
<td>
<p>index of the alternative. See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="predict.mnprobit_+3A_regime">regime</code></td>
<td>
<p>regime of the continuous equation. 
See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="predict.mnprobit_+3A_type">type</code></td>
<td>
<p>string representing a type of prediction. See 'Details' for
more information.</p>
</td></tr>
<tr><td><code id="predict.mnprobit_+3A_alt_obs">alt_obs</code></td>
<td>
<p>if <code>alt_obs = "all"</code> then all observations will
be used for prediction. If <code>alt_obs</code> equals to the index of the
alternative then only observations associated with this alternative
will be used.</p>
</td></tr>
<tr><td><code id="predict.mnprobit_+3A_me">me</code></td>
<td>
<p>string representing the name of the variable for which marginal
effect should be estimated. See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="predict.mnprobit_+3A_eps">eps</code></td>
<td>
<p>numeric vector of length 1 or 2 used for calculation of
marginal effects. See 'Details'.</p>
</td></tr>
<tr><td><code id="predict.mnprobit_+3A_control">control</code></td>
<td>
<p>list of additional arguments. Currently is not intended
for the users.</p>
</td></tr>
<tr><td><code id="predict.mnprobit_+3A_se">se</code></td>
<td>
<p>logical; if <code>TRUE</code> then the function also returns standard 
errors and p-values of the two-sided significance test associated with the 
function output. 
Works only if <code><a href="#topic+predict.mvoprobit">predict.mvoprobit</a></code> returns
numeric vector or a single column matrix. 
See <code><a href="#topic+delta_method">delta_method</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'Examples' section of <code><a href="#topic+mnprobit">mnprobit</a></code>
for examples of this function application.
</p>
<p>If <code>type = "prob"</code> then function returns a probability that
alternative <code>alt</code> will be chosen. For example if <code>alt = 2</code> then
probabilities <code class="reqn">P(z_{i} = 2|w_{i})</code> will be estimated.
If <code>n_alt</code> is null then the function returns a matrix such that 
<code>i</code>-th column contains probability of selecting <code>i</code>-th alternative.
</p>
<p>If <code>type = "li"</code> then function returns a matrix which columns are
linear indexes of corresponding equations.
</p>
<p>If <code>type = "val"</code> then function returns predictions of conditional 
(on <code>group</code>) expectation of dependent variable in continuous equation
with regimes determined by <code>regime</code> argument. To predict unconditional 
expectations just set <code>alt = NULL</code>.
</p>
<p>If <code>type = "lambda"</code> then function returns conditional 
(on <code>alt</code>) expectation of random error of continuous equation
in regime <code>regime</code>.
</p>
<p>If <code>me</code> is provided then the function returns marginal effect
of variable <code>me</code> respect to the statistic determined by <code>type</code>
argument. 
For example if <code>me = "x1"</code> and <code>type = "prob"</code> then function 
returns a marginal effect of <code>x1</code> on the corresponding probability 
i.e. one that would be estimated if <code>me</code> is <code>NULL</code>.
</p>
<p>If <code>length(eps) = 1</code> then <code>eps</code> is an increment in 
numeric differentiation procedure. 
If <code>eps</code> is <code>NULL</code> then this increment will be selected 
automatically taking into account scaling of variables. 
If <code>length(eps) = 2</code> then marginal effects will be estimated as the
difference between predicted value when variable <code>me</code> equals 
<code>eps[2]</code> and when it equals <code>eps[1]</code> correspondingly.
</p>


<h3>Value</h3>

<p>This function returns predictions for each row of <code>newdata</code>
or for each observation in the model if <code>newdata</code> is <code>NULL</code>.
Structure of the output depends on the <code>type</code> argument
(see 'Details' section).
</p>

<hr>
<h2 id='predict.mvoprobit'>Predict method for mvoprobit function</h2><span id='topic+predict.mvoprobit'></span>

<h3>Description</h3>

<p>Predicted values based on object of class 'mvoprobit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvoprobit'
predict(
  object,
  ...,
  newdata = NULL,
  given_ind = numeric(),
  group = NULL,
  group2 = NULL,
  type = ifelse(is.null(group2), "prob", "val"),
  me = NULL,
  eps = NULL,
  control = list(),
  se = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mvoprobit_+3A_object">object</code></td>
<td>
<p>object of class &quot;mvoprobit&quot;</p>
</td></tr>
<tr><td><code id="predict.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="predict.mvoprobit_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables 
with which to predict. If omitted, the original data frame used.
This data frame should contain values of dependent variables even if
they are not actually needed for prediction 
(simply assign them with 0 values).</p>
</td></tr>
<tr><td><code id="predict.mvoprobit_+3A_given_ind">given_ind</code></td>
<td>
<p>numeric vector of indexes of conditioned components.</p>
</td></tr>
<tr><td><code id="predict.mvoprobit_+3A_group">group</code></td>
<td>
<p>numeric vector which i-th element represents a value of the
i-th dependent variable. If this value equals -1 then this component
will be ignored (useful for estimation of marginal probabilities).</p>
</td></tr>
<tr><td><code id="predict.mvoprobit_+3A_group2">group2</code></td>
<td>
<p>numeric vector which i-th element represents a value of the
i-th dependent variable of the continuous equation. 
If this value equals -1 then this component will be ignored.</p>
</td></tr>
<tr><td><code id="predict.mvoprobit_+3A_type">type</code></td>
<td>
<p>string representing a type of prediction. See 'Details' for
more information.</p>
</td></tr>
<tr><td><code id="predict.mvoprobit_+3A_me">me</code></td>
<td>
<p>string representing the name of the variable for which marginal
effect should be estimated. See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="predict.mvoprobit_+3A_eps">eps</code></td>
<td>
<p>numeric vector of length 1 or 2 used for calculation of
marginal effects. See 'Details'.</p>
</td></tr>
<tr><td><code id="predict.mvoprobit_+3A_control">control</code></td>
<td>
<p>list of additional arguments. Currently is not intended
for the users.</p>
</td></tr>
<tr><td><code id="predict.mvoprobit_+3A_se">se</code></td>
<td>
<p>logical; if <code>TRUE</code> then the function also returns standard 
errors and p-values of the two-sided significance test associated with the 
function output. 
Works only if <code><a href="#topic+predict.mvoprobit">predict.mvoprobit</a></code> returns
numeric vector or a single column matrix. 
See <code><a href="#topic+delta_method">delta_method</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'Examples' section of <code><a href="#topic+mvoprobit">mvoprobit</a></code>
for examples of this function application.
</p>
<p>If <code>type = "prob"</code> then function returns a joint probability that
dependent variables will have values assigned in <code>group</code>. To calculate
marginal probabilities set unnecessary <code>group</code> values to -1. To
estimate conditional probabilities provide indexes of conditioned variables
through <code>given_ind</code>. For example if <code class="reqn">z_{1}</code>, <code class="reqn">z_{2}</code> and 
<code class="reqn">z_{3}</code> are dependent variables then to calculate 
<code class="reqn">P(z_{1}=2 | z_{3} = 0)</code> set <code>given_ind = 3</code> and 
<code>groups = c(2, -1, 0)</code>. Note that conditioning on covariates 
(regressors) is omitted for notations brevity and this conditioning depends 
on the values in <code>newdata</code>.
</p>
<p>If <code>type = "li"</code> then function returns a matrix which columns are
linear indexes of corresponding equations.
</p>
<p>If <code>type = "sd"</code> then function returns a matrix which columns are
standard deviations of random errors for corresponding equations. 
</p>
<p>If <code>type = "li"</code> or <code>type = "sd"</code> and some <code>groups</code> are equal
to -1 then corresponding components will be omitted from the output matrix.
</p>
<p>If <code>type = "val"</code> then function returns predictions of conditional 
(on <code>group</code>) expectation of dependent variable in continuous equations
with regimes determined by <code>group2</code> argument. To predict unconditional 
expectations just set <code>group = NULL</code>.
</p>
<p>If <code>type = "lambda"</code> then function returns conditional 
(on <code>group</code>) expectations of random error of continuous equation
in regime <code>group2</code>.
</p>
<p>If <code>type = "val"</code> or <code>type = "lambda"</code> then output is a matrix
which <code>i</code>-th column corresponds to prediction associated with
<code>i</code>-th continuous equation.
</p>
<p>If <code>me</code> is provided then the function returns marginal effect
of variable <code>me</code> respect to the statistic determined by <code>type</code>
argument. 
For example if <code>me = "x1"</code> and <code>type = "prob"</code> then function 
returns marginal effect of <code>x1</code> on the corresponding probability 
i.e. one that would be estimated if <code>me</code> is <code>NULL</code>.
</p>
<p>If <code>length(eps) = 1</code> then <code>eps</code> is an increment in 
numeric differentiation procedure. 
If <code>eps</code> is <code>NULL</code> then this increment will be selected 
automatically taking into account scaling of variables. 
If <code>length(eps) = 2</code> then marginal effects will be estimated as the
difference of predicted value when variable <code>me</code> equals <code>eps[2]</code>
and <code>eps[1]</code> correspondingly. 
</p>
<p>For example suppose that 
<code>type = "prob"</code>, <code>me = "x1"</code>, <code>given_ind = 3</code> and
<code>groups = c(2, -1, 0)</code>. Then if <code>eps</code> is a <code>NULL</code> or a 
small number (something like <code>eps = 0.0001</code>) the following marginal
effect will be estimated (via first difference numeric differentiation):
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial P(z_{1}=2 | z_{3} = 0)}{\partial x_{1}}.</code>
</p>

<p>If <code>eps = c(1, 3)</code> then the function estimates the following difference
(useful for estimation of marginal effects of ordered covariates):
</p>
<p style="text-align: center;"><code class="reqn">P(z_{1}=2 | z_{3} = 0, x_{1} = 3) - 
      P(z_{1}=2 | z_{3} = 0, x_{1} = 1).</code>
</p>



<h3>Value</h3>

<p>This function returns predictions for each row of <code>newdata</code>
or for each observation in the model if <code>newdata</code> is <code>NULL</code>.
Structure of the output depends on the <code>type</code> argument
(see 'Details' section).
</p>

<hr>
<h2 id='print.lrtest'>Print Method for Likelihood Ratio Test</h2><span id='topic+print.lrtest'></span>

<h3>Description</h3>

<p>Prints summary for an object of class 'lrtest'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lrtest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lrtest_+3A_x">x</code></td>
<td>
<p>object of class &quot;lrtest&quot;.</p>
</td></tr>
<tr><td><code id="print.lrtest_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns input argument <code>x</code>.
</p>

<hr>
<h2 id='print.mnprobit'>Print for an Object of Class mnprobit</h2><span id='topic+print.mnprobit'></span>

<h3>Description</h3>

<p>Prints information on the object of class 'mnprobit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mnprobit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mnprobit_+3A_x">x</code></td>
<td>
<p>object of class 'mnprobit'</p>
</td></tr>
<tr><td><code id="print.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns input argument <code>NULL</code>.
</p>

<hr>
<h2 id='print.mvoprobit'>Print for an Object of Class mvoprobit</h2><span id='topic+print.mvoprobit'></span>

<h3>Description</h3>

<p>Prints information on the object of class 'mvoprobit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvoprobit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mvoprobit_+3A_x">x</code></td>
<td>
<p>object of class 'mvoprobit'</p>
</td></tr>
<tr><td><code id="print.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>

<hr>
<h2 id='print.summary.delta_method'>Print summary for an Object of Class delta_method</h2><span id='topic+print.summary.delta_method'></span>

<h3>Description</h3>

<p>Prints summary for an object of class 'delta_method'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.delta_method'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.delta_method_+3A_x">x</code></td>
<td>
<p>object of class 'delta_method'</p>
</td></tr>
<tr><td><code id="print.summary.delta_method_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns input argument <code>x</code>.
</p>

<hr>
<h2 id='print.summary.lrtest'>Print Summary Method for Likelihood Ratio Test</h2><span id='topic+print.summary.lrtest'></span>

<h3>Description</h3>

<p>Prints summary for an object of class 'lrtest'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lrtest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.lrtest_+3A_x">x</code></td>
<td>
<p>object of class &quot;lrtest&quot;</p>
</td></tr>
<tr><td><code id="print.summary.lrtest_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns input argument <code>x</code> changing
it's class to <code>lrtest</code>.
</p>

<hr>
<h2 id='print.summary.mnprobit'>Print summary for an Object of Class mnprobit</h2><span id='topic+print.summary.mnprobit'></span>

<h3>Description</h3>

<p>Prints summary for an object of class 'mnprobit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.mnprobit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.mnprobit_+3A_x">x</code></td>
<td>
<p>object of class 'mnprobit'</p>
</td></tr>
<tr><td><code id="print.summary.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>x</code>.
</p>

<hr>
<h2 id='print.summary.mvoprobit'>Print summary for an Object of Class mvoprobit</h2><span id='topic+print.summary.mvoprobit'></span>

<h3>Description</h3>

<p>Prints summary for an object of class 'mvoprobit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.mvoprobit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.mvoprobit_+3A_x">x</code></td>
<td>
<p>object of class 'mvoprobit'</p>
</td></tr>
<tr><td><code id="print.summary.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>x</code>.
</p>

<hr>
<h2 id='sigma.mnprobit'>Extract Residual Standard Deviation 'Sigma'</h2><span id='topic+sigma.mnprobit'></span>

<h3>Description</h3>

<p>Extract standard deviations of random errors of continuous
equation of <code><a href="#topic+mnprobit">mnprobit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mnprobit'
sigma(object, use.fallback = TRUE, ..., regime = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.mnprobit_+3A_object">object</code></td>
<td>
<p>object of class &quot;mnprobit&quot;.</p>
</td></tr>
<tr><td><code id="sigma.mnprobit_+3A_use.fallback">use.fallback</code></td>
<td>
<p>logical, passed to <code>nobs</code> (currently ignored).</p>
</td></tr>
<tr><td><code id="sigma.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="sigma.mnprobit_+3A_regime">regime</code></td>
<td>
<p>regime of continuous equation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available only if <code>estimator = "ml"</code>.
</p>


<h3>Value</h3>

<p>Returns the estimates of standard deviations 
of <code class="reqn">\varepsilon_{i}</code>.
If <code>regime = r</code> then estimate of 
<code class="reqn">\sqrt{Var(\varepsilon_{ri})}</code> is returned.
</p>

<hr>
<h2 id='sigma.mvoprobit'>Extract Residual Standard Deviation 'Sigma'</h2><span id='topic+sigma.mvoprobit'></span>

<h3>Description</h3>

<p>Extract standard deviations of random errors of continuous
equations of <code><a href="#topic+mvoprobit">mvoprobit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvoprobit'
sigma(object, use.fallback = TRUE, ..., regime = NULL, eq2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.mvoprobit_+3A_object">object</code></td>
<td>
<p>object of class &quot;mvoprobit&quot;.</p>
</td></tr>
<tr><td><code id="sigma.mvoprobit_+3A_use.fallback">use.fallback</code></td>
<td>
<p>logical, passed to <code>nobs</code> (currently ignored).</p>
</td></tr>
<tr><td><code id="sigma.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="sigma.mvoprobit_+3A_regime">regime</code></td>
<td>
<p>regime of continuous equation</p>
</td></tr>
<tr><td><code id="sigma.mvoprobit_+3A_eq2">eq2</code></td>
<td>
<p>index of continuous equation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available only if <code>estimator = "ml"</code> or all <code>degrees</code>
values are equal to <code>1</code>.
</p>


<h3>Value</h3>

<p>Returns estimates of the standard deviations 
of <code class="reqn">\varepsilon_{i}</code>. 
If <code>eq2 = k</code> then estimates only for <code class="reqn">k</code>-th continuous equation are 
returned. If in addition <code>regime = r</code> then estimate of 
<code class="reqn">\sqrt{Var(\varepsilon_{ri})}</code> is returned. 
Herewith if <code>regime</code> is not <code>NULL</code> and <code>eq2</code> is <code>NULL</code> 
it is assumed that <code>eq2 = 1</code>.
</p>

<hr>
<h2 id='starsVector'>Stars for p-values</h2><span id='topic+starsVector'></span>

<h3>Description</h3>

<p>This function assigns stars 
(associated with different significance levels) to p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>starsVector(p_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="starsVector_+3A_p_value">p_value</code></td>
<td>
<p>vector of values between 0 and 1 representing p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three stars are assigned to p-values not greater than 0.01.
Two stars are assigned to p-values greater than 0.01 and not greater 
than 0.05.
One star is assigned to p-values greater than 0.05 and not greater than 0.1.
</p>


<h3>Value</h3>

<p>The function returns a string vector of stars assigned according
to the rules described in 'Details' section.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_value &lt;- c(0.002, 0.2, 0.03, 0.08)
starsVector(p_value)
</code></pre>

<hr>
<h2 id='summary.delta_method'>Summary for an Object of Class delta_method</h2><span id='topic+summary.delta_method'></span>

<h3>Description</h3>

<p>Provides summary for an object of class 'delta_method'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'delta_method'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.delta_method_+3A_object">object</code></td>
<td>
<p>object of class 'delta_method'</p>
</td></tr>
<tr><td><code id="summary.delta_method_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class 'summary.delta_method'.
</p>

<hr>
<h2 id='summary.lrtest'>Summary Method for Likelihood Ratio Test</h2><span id='topic+summary.lrtest'></span>

<h3>Description</h3>

<p>Provides summary for an object of class 'lrtest'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lrtest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lrtest_+3A_object">object</code></td>
<td>
<p>object of class &quot;lrtest&quot;</p>
</td></tr>
<tr><td><code id="summary.lrtest_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function just changes the class of the 'lrtest'
object to 'summary.lrtest'.
</p>


<h3>Value</h3>

<p>Returns an object of class 'summary.lrtest'.
</p>

<hr>
<h2 id='summary.mnprobit'>Summary for an Object of Class mnprobit</h2><span id='topic+summary.mnprobit'></span>

<h3>Description</h3>

<p>Provides summary for an object of class 'mnprobit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mnprobit'
summary(object, ..., vcov = NULL, show_ind = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mnprobit_+3A_object">object</code></td>
<td>
<p>object of class 'mnprobit'</p>
</td></tr>
<tr><td><code id="summary.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="summary.mnprobit_+3A_vcov">vcov</code></td>
<td>
<p>positively defined numeric matrix representing
asymptotic variance-covariance matrix of the estimator to be
used for calculation of standard errors and p-values. It may also be a 
character. Then <code><a href="#topic+vcov.mnprobit">vcov.mnprobit</a></code> function
will be used which input argument <code>type</code> will be set to <code>vcov</code>.
If <code>estimator = "2step"</code> then <code>vcov</code> should be an estimate of the 
asymptotic covariance matrix of the first step estimator.</p>
</td></tr>
<tr><td><code id="summary.mnprobit_+3A_show_ind">show_ind</code></td>
<td>
<p>logical; if <code>TRUE</code> then indexes of parameters will be
shown. Particularly, these indexes may be used in <code>ind</code> element of
<code>regularization</code> parameter of <code><a href="#topic+mvoprobit">mvoprobit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>vcov</code> is <code>NULL</code> then this function just changes the 
class of the 'mnprobit' object to 'summary.mnprobit'. Otherwise it 
additionally changes <code>object$cov</code> to <code>vcov</code> and use it to
recalculate <code>object$se</code>, <code>object$p_value</code> and <code>object$tbl</code> 
values. It also adds the value of <code>ind</code> argument to the object.
</p>


<h3>Value</h3>

<p>Returns an object of class 'summary.mnprobit'.
</p>

<hr>
<h2 id='summary.mvoprobit'>Summary for an Object of Class mvoprobit</h2><span id='topic+summary.mvoprobit'></span>

<h3>Description</h3>

<p>Provides summary for an object of class 'mvoprobit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvoprobit'
summary(object, ..., vcov = NULL, show_ind = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mvoprobit_+3A_object">object</code></td>
<td>
<p>object of class 'mvoprobit'</p>
</td></tr>
<tr><td><code id="summary.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="summary.mvoprobit_+3A_vcov">vcov</code></td>
<td>
<p>positively defined numeric matrix representing
asymptotic variance-covariance matrix of the estimator to be
used for calculation of standard errors and p-values. It may also be a 
character. Then <code><a href="#topic+vcov.mvoprobit">vcov.mvoprobit</a></code> function
will be used which input argument <code>type</code> will be set to <code>vcov</code>.
If <code>estimator = "2step"</code> then <code>vcov</code> should be an estimate of the 
asymptotic covariance matrix of the first step estimator.</p>
</td></tr>
<tr><td><code id="summary.mvoprobit_+3A_show_ind">show_ind</code></td>
<td>
<p>logical; if <code>TRUE</code> then indexes of parameters will be
shown. Particularly, these indexes may be used in <code>ind</code> element of
<code>regularization</code> parameter of <code><a href="#topic+mvoprobit">mvoprobit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>vcov</code> is <code>NULL</code> then this function just changes the 
class of the 'mvoprobit' object to 'summary.mvoprobit'. Otherwise it 
additionally changes <code>object$cov</code> to <code>vcov</code> and use it to
recalculate <code>object$se</code>, <code>object$p_value</code> and <code>object$tbl</code> 
values. It also adds the value of <code>ind</code> argument to the object.
</p>


<h3>Value</h3>

<p>Returns an object of class 'summary.mvoprobit'.
</p>

<hr>
<h2 id='vcov.mnprobit'>Calculate Variance-Covariance Matrix for a mnprobit Object.</h2><span id='topic+vcov.mnprobit'></span>

<h3>Description</h3>

<p>Return the variance-covariance matrix of the parameters of
mnprobit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mnprobit'
vcov(
  object,
  ...,
  type = object$cov_type,
  regime = NULL,
  n_cores = object$other$n_cores,
  n_sim = object$other$n_sim
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mnprobit_+3A_object">object</code></td>
<td>
<p>an object of class <code>mnprobit</code>.</p>
</td></tr>
<tr><td><code id="vcov.mnprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="vcov.mnprobit_+3A_type">type</code></td>
<td>
<p>character representing the type of the asymptotic covariance 
matrix estimator. If</p>
</td></tr>
<tr><td><code id="vcov.mnprobit_+3A_regime">regime</code></td>
<td>
<p>non-negative integer representing the regime of the two-step
procedure for which covariance matrix should be returned.
If <code>estimator = "2step"</code> and <code>regime = NULL</code> then covariance
matrix of the first step parameters' estimator will be returned.
Otherwise the function estimates covariance matrix for the second step
parameters associated with corresponding regime.</p>
</td></tr>
<tr><td><code id="vcov.mnprobit_+3A_n_cores">n_cores</code></td>
<td>
<p>positive integer representing the number of CPU cores used for 
parallel computing. If possible it is highly recommend to set it equal to
the number of available physical cores especially when the system of
ordered equations has 2 or 3 equations.
<code>estimator</code> argument of <code><a href="#topic+mnprobit">mnprobit</a></code> is 
<code>"ml"</code> then <code>type</code> may be changed to any value available for input 
argument <code>cov_type</code> of <code><a href="#topic+mnprobit">mnprobit</a></code>. 
Otherwise <code>type</code> will coincide with <code>cov_type</code> output value 
of <code><a href="#topic+mnprobit">mnprobit</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.mnprobit_+3A_n_sim">n_sim</code></td>
<td>
<p>integer representing the number of GHK draws when there are
more then 3 ordered equations. Otherwise alternative (much more efficient) 
algorithms will be used to calculate multivariate normal probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>type</code> is closely related to the argument 
<code>cov_type</code> of <code><a href="#topic+mnprobit">mnprobit</a></code> function. 
See 'Details' and 'Usage' sections of 
<code><a href="#topic+mnprobit">mnprobit</a></code> 
for more information on <code>cov_type</code> argument.
</p>


<h3>Value</h3>

<p>Returns numeric matrix which represents estimate of the asymptotic 
covariance matrix of model's parameters.
</p>

<hr>
<h2 id='vcov.mvoprobit'>Calculate Variance-Covariance Matrix for a mvoprobit Object.</h2><span id='topic+vcov.mvoprobit'></span>

<h3>Description</h3>

<p>Return the variance-covariance matrix of the parameters of
mvoprobit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvoprobit'
vcov(
  object,
  ...,
  type = object$cov_type,
  regime = NULL,
  n_cores = object$other$n_cores,
  n_sim = object$other$n_sim
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mvoprobit_+3A_object">object</code></td>
<td>
<p>an object of class <code>mvoprobit</code>.</p>
</td></tr>
<tr><td><code id="vcov.mvoprobit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="vcov.mvoprobit_+3A_type">type</code></td>
<td>
<p>character representing the type of the asymptotic covariance 
matrix estimator. If 
<code>estimator</code> argument of <code><a href="#topic+mvoprobit">mvoprobit</a></code> is 
<code>"ml"</code> then <code>type</code> may be changed to any value available for input 
argument <code>cov_type</code> of <code><a href="#topic+mvoprobit">mvoprobit</a></code>. 
Otherwise <code>type</code> will coincide with <code>cov_type</code> output value 
of <code><a href="#topic+mvoprobit">mvoprobit</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.mvoprobit_+3A_regime">regime</code></td>
<td>
<p>non-negative integer representing the regime of the two-step
procedure for which covariance matrix should be returned.
If <code>estimator = "2step"</code> and <code>regime = NULL</code> or 
<code>is.na(regime)</code> then covariance
matrix of the first step parameters' estimator will be returned.
Otherwise the function estimates covariance matrix for the second step
parameters associated with corresponding regime.</p>
</td></tr>
<tr><td><code id="vcov.mvoprobit_+3A_n_cores">n_cores</code></td>
<td>
<p>positive integer representing the number of CPU cores used for 
parallel computing. If possible it is highly recommend to set it equal to
the number of available physical cores especially when the system of
ordered equations has 2 or 3 equations.</p>
</td></tr>
<tr><td><code id="vcov.mvoprobit_+3A_n_sim">n_sim</code></td>
<td>
<p>integer representing the number of GHK draws when there are
more than 3 ordered equations. Otherwise alternative (much more efficient) 
algorithms will be used to calculate multivariate normal probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>type</code> is closely related to the argument 
<code>cov_type</code> of <code><a href="#topic+mvoprobit">mvoprobit</a></code> function. 
See 'Details' and 'Usage' sections of 
<code><a href="#topic+mvoprobit">mvoprobit</a></code> 
for more information on <code>cov_type</code> argument.
</p>


<h3>Value</h3>

<p>Returns numeric matrix which represents estimate of the asymptotic 
covariance matrix of model's parameters.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
